{"sha": "84de8caa87b085772cbe41de0b39630ccca3afab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZGU4Y2FhODdiMDg1NzcyY2JlNDFkZTBiMzk2MzBjY2NhM2FmYWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-13T04:12:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:40Z"}, "message": "Add tests for various intrinsic behaviours.", "tree": {"sha": "cc107e5f19404269f3f19835740cae085f54c13b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc107e5f19404269f3f19835740cae085f54c13b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84de8caa87b085772cbe41de0b39630ccca3afab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84de8caa87b085772cbe41de0b39630ccca3afab", "html_url": "https://github.com/rust-lang/rust/commit/84de8caa87b085772cbe41de0b39630ccca3afab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84de8caa87b085772cbe41de0b39630ccca3afab/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926b8351cf1d1489386bbf96355990ae01f6cb11", "url": "https://api.github.com/repos/rust-lang/rust/commits/926b8351cf1d1489386bbf96355990ae01f6cb11", "html_url": "https://github.com/rust-lang/rust/commit/926b8351cf1d1489386bbf96355990ae01f6cb11"}], "stats": {"total": 911, "additions": 911, "deletions": 0}, "files": [{"sha": "effa1ed04d8ecf5e9c062b8bb3c302eea3d239cf", "filename": "src/test/compile-fail/simd-intrinsic-declaration-type.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-declaration-type.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);\n+\n+#[repr(simd)]\n+struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,\n+             i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+struct i64x2(i64, i64);\n+\n+// signed vs. unsigned doesn't matter\n+mod i {\n+    use i16x8;\n+    extern \"platform-intrinsic\" {\n+        fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8;\n+    }\n+}\n+mod u {\n+    use u16x8;\n+    extern \"platform-intrinsic\" {\n+        fn x86_mm_adds_epi16(x: u16x8, y: u16x8) -> u16x8;\n+    }\n+}\n+// but lengths do\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -> i64x2;\n+    //~^ ERROR intrinsic argument 1 has wrong type\n+    //~^^ ERROR intrinsic argument 2 has wrong type\n+    //~^^^ ERROR intrinsic return value has wrong type\n+}\n+// and so does int vs. float\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_max_ps(x: i32x4, y: i32x4) -> i32x4;\n+    //~^ ERROR intrinsic argument 1 has wrong type\n+    //~^^ ERROR intrinsic argument 2 has wrong type\n+    //~^^^ ERROR intrinsic return value has wrong type\n+}\n+\n+\n+fn main() {}"}, {"sha": "d4fbcb41e2a91ba0eb5f8718e67fd64098d71940", "filename": "src/test/compile-fail/simd-intrinsic-generic-arithmetic.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(x: T, y: T) -> T;\n+    fn simd_sub<T>(x: T, y: T) -> T;\n+    fn simd_mul<T>(x: T, y: T) -> T;\n+    fn simd_div<T>(x: T, y: T) -> T;\n+    fn simd_shl<T>(x: T, y: T) -> T;\n+    fn simd_shr<T>(x: T, y: T) -> T;\n+    fn simd_and<T>(x: T, y: T) -> T;\n+    fn simd_or<T>(x: T, y: T) -> T;\n+    fn simd_xor<T>(x: T, y: T) -> T;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+    let y = u32x4(0, 0, 0, 0);\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+\n+    unsafe {\n+        simd_add(x, x);\n+        simd_add(y, y);\n+        simd_add(z, z);\n+        simd_sub(x, x);\n+        simd_sub(y, y);\n+        simd_sub(z, z);\n+        simd_mul(x, x);\n+        simd_mul(y, y);\n+        simd_mul(z, z);\n+\n+        simd_div(z, z);\n+\n+        simd_shl(x, x);\n+        simd_shl(y, y);\n+        simd_shr(x, x);\n+        simd_shr(y, y);\n+        simd_and(x, x);\n+        simd_and(y, y);\n+        simd_or(x, x);\n+        simd_or(y, y);\n+        simd_xor(x, x);\n+        simd_xor(y, y);\n+\n+\n+        simd_add(0, 0);\n+        //~^ ERROR `simd_add` intrinsic monomorphized with non-SIMD type\n+        simd_sub(0, 0);\n+        //~^ ERROR `simd_sub` intrinsic monomorphized with non-SIMD type\n+        simd_mul(0, 0);\n+        //~^ ERROR `simd_mul` intrinsic monomorphized with non-SIMD type\n+        simd_div(0, 0);\n+        //~^ ERROR `simd_div` intrinsic monomorphized with non-SIMD type\n+        simd_shl(0, 0);\n+        //~^ ERROR `simd_shl` intrinsic monomorphized with non-SIMD type\n+        simd_shr(0, 0);\n+        //~^ ERROR `simd_shr` intrinsic monomorphized with non-SIMD type\n+        simd_and(0, 0);\n+        //~^ ERROR `simd_and` intrinsic monomorphized with non-SIMD type\n+        simd_or(0, 0);\n+        //~^ ERROR `simd_or` intrinsic monomorphized with non-SIMD type\n+        simd_xor(0, 0);\n+        //~^ ERROR `simd_xor` intrinsic monomorphized with non-SIMD type\n+\n+\n+        simd_div(x, x);\n+//~^ ERROR `simd_div` intrinsic monomorphized with SIMD vector `i32x4` with unsupported element type\n+        simd_div(y, y);\n+//~^ ERROR `simd_div` intrinsic monomorphized with SIMD vector `u32x4` with unsupported element type\n+        simd_shl(z, z);\n+//~^ ERROR `simd_shl` intrinsic monomorphized with SIMD vector `f32x4` with unsupported element type\n+        simd_shr(z, z);\n+//~^ ERROR `simd_shr` intrinsic monomorphized with SIMD vector `f32x4` with unsupported element type\n+        simd_and(z, z);\n+//~^ ERROR `simd_and` intrinsic monomorphized with SIMD vector `f32x4` with unsupported element type\n+        simd_or(z, z);\n+//~^ ERROR `simd_or` intrinsic monomorphized with SIMD vector `f32x4` with unsupported element type\n+        simd_xor(z, z);\n+//~^ ERROR `simd_xor` intrinsic monomorphized with SIMD vector `f32x4` with unsupported element type\n+    }\n+}"}, {"sha": "333ef756e1fa5057aee89a95ff2f12ad966bf969", "filename": "src/test/compile-fail/simd-intrinsic-generic-cast.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x8(f32, f32, f32, f32,\n+             f32, f32, f32, f32);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_cast::<i32, i32>(0);\n+        //~^ ERROR SIMD cast intrinsic monomorphized with non-SIMD input type `i32`\n+        simd_cast::<i32, i32x4>(0);\n+        //~^ ERROR SIMD cast intrinsic monomorphized with non-SIMD input type `i32`\n+        simd_cast::<i32x4, i32>(x);\n+        //~^ ERROR SIMD cast intrinsic monomorphized with non-SIMD return type `i32`\n+        simd_cast::<_, i32x8>(x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i32x8` with different lengths\n+    }\n+}"}, {"sha": "37827fbb6fbbb22955c1841c5e193e1702ba696b", "filename": "src/test/compile-fail/simd-intrinsic-generic-comparison.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i16x8(i16, i16, i16, i16,\n+             i16, i16, i16, i16);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_eq<T, U>(x: T, y: T) -> U;\n+    fn simd_ne<T, U>(x: T, y: T) -> U;\n+    fn simd_lt<T, U>(x: T, y: T) -> U;\n+    fn simd_le<T, U>(x: T, y: T) -> U;\n+    fn simd_gt<T, U>(x: T, y: T) -> U;\n+    fn simd_ge<T, U>(x: T, y: T) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_eq::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+        simd_ne::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+        simd_lt::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+        simd_le::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+        simd_gt::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+        simd_ge::<i32, i32>(0, 0);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD argument type\n+\n+        simd_eq::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+        simd_ne::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+        simd_lt::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+        simd_le::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+        simd_gt::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+        simd_ge::<_, i32>(x, x);\n+        //~^ ERROR SIMD comparison intrinsic monomorphized for non-SIMD return type\n+\n+        simd_eq::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+        simd_ne::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+        simd_lt::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+        simd_le::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+        simd_gt::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+        simd_ge::<_, i16x8>(x, x);\n+//~^ ERROR monomorphized with input type `i32x4` and return type `i16x8` with different lengths\n+    }\n+}"}, {"sha": "ebe442c1a2e4dee05045f81fd997a1f864da7556", "filename": "src/test/compile-fail/simd-intrinsic-generic-elements.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x2(i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x3(i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x2(f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x3(f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+struct f32x8(f32, f32, f32, f32,\n+             f32, f32, f32, f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, E>(x: T, idx: u32, y: E) -> T;\n+    fn simd_extract<T, E>(x: T, idx: u32) -> E;\n+\n+    fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n+    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n+    fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n+    fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n+}\n+\n+fn main() {\n+    let x = i32x4(0, 0, 0, 0);\n+\n+    unsafe {\n+        simd_insert(0, 0, 0);\n+        //~^ ERROR SIMD insert intrinsic monomorphized for non-SIMD input type\n+        simd_insert(x, 0, 1.0);\n+        //~^ ERROR SIMD insert intrinsic monomorphized with inserted type not SIMD element type\n+        simd_extract::<_, f32>(x, 0);\n+        //~^ ERROR SIMD insert intrinsic monomorphized with returned type not SIMD element type\n+\n+        simd_shuffle2::<i32, i32>(0, 0, [0; 2]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with non-SIMD input type\n+        simd_shuffle3::<i32, i32>(0, 0, [0; 3]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with non-SIMD input type\n+        simd_shuffle4::<i32, i32>(0, 0, [0; 4]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with non-SIMD input type\n+        simd_shuffle8::<i32, i32>(0, 0, [0; 8]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with non-SIMD input type\n+\n+        simd_shuffle2::<_, f32x2>(x, x, [0; 2]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with different input and return element\n+        simd_shuffle3::<_, f32x3>(x, x, [0; 3]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with different input and return element\n+        simd_shuffle4::<_, f32x4>(x, x, [0; 4]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with different input and return element\n+        simd_shuffle8::<_, f32x8>(x, x, [0; 8]);\n+        //~^ ERROR SIMD shuffle intrinsic monomorphized with different input and return element\n+    }\n+}"}, {"sha": "0d0bf240f720a2f117367c394485974b4fd4ce26", "filename": "src/test/compile-fail/simd-intrinsic-single-nominal-type.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-single-nominal-type.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+struct A(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+struct B(i16, i16, i16, i16, i16, i16, i16, i16);\n+\n+// each intrinsic definition has to use the same nominal type for any\n+// vector structure throughout that declaration (i.e. every instance\n+// of i16x8 in each `fn ...;` needs to be either A or B)\n+\n+extern \"platform-intrinsic\" {\n+    fn x86_mm_adds_epi16(x: A, y: A) -> B;\n+    //~^ ERROR intrinsic return value has wrong type: found `B`, expected `A`\n+    fn x86_mm_subs_epi16(x: A, y: B) -> A;\n+    //~^ ERROR intrinsic argument 2 has wrong type: found `B`, expected `A`\n+\n+    // ok:\n+    fn x86_mm_max_epi16(x: B, y: B) -> B;\n+    fn x86_mm_min_epi16(x: A, y: A) -> A;\n+}\n+\n+fn main() {}"}, {"sha": "336855eb5e18b2bca8fdd6d3f65bfcfbd9f6e0ef", "filename": "src/test/compile-fail/simd-type-generic-monomorphisation.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-type-generic-monomorphisation.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+// error-pattern:monomorphising SIMD type `Simd2<X>` with a non-machine element type `X`\n+\n+struct X(Vec<i32>);\n+#[repr(simd)]\n+struct Simd2<T>(T, T);\n+\n+fn main() {\n+    let _ = Simd2(X(vec![]), X(vec![]));\n+}"}, {"sha": "5d4ecbb5f81722a4f32f24f50905cd56056c00ef", "filename": "src/test/run-pass/simd-intrinsic-generic-arithmetic.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-arithmetic.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+macro_rules! all_eq {\n+    ($a: expr, $b: expr) => {{\n+        let a = $a;\n+        let b = $b;\n+        assert!(a.0 == b.0 && a.1 == b.1 && a.2 == b.2 && a.3 == b.3);\n+    }}\n+}\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(x: T, y: T) -> T;\n+    fn simd_sub<T>(x: T, y: T) -> T;\n+    fn simd_mul<T>(x: T, y: T) -> T;\n+    fn simd_div<T>(x: T, y: T) -> T;\n+    fn simd_shl<T>(x: T, y: T) -> T;\n+    fn simd_shr<T>(x: T, y: T) -> T;\n+    fn simd_and<T>(x: T, y: T) -> T;\n+    fn simd_or<T>(x: T, y: T) -> T;\n+    fn simd_xor<T>(x: T, y: T) -> T;\n+}\n+\n+fn main() {\n+    let x1 = i32x4(1, 2, 3, 4);\n+    let y1 = u32x4(1, 2, 3, 4);\n+    let z1 = f32x4(1.0, 2.0, 3.0, 4.0);\n+    let x2 = i32x4(2, 3, 4, 5);\n+    let y2 = u32x4(2, 3, 4, 5);\n+    let z2 = f32x4(2.0, 3.0, 4.0, 5.0);\n+\n+    unsafe {\n+        all_eq!(simd_add(x1, x2), i32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(x2, x1), i32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(y1, y2), u32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(y2, y1), u32x4(3, 5, 7, 9));\n+        all_eq!(simd_add(z1, z2), f32x4(3.0, 5.0, 7.0, 9.0));\n+        all_eq!(simd_add(z2, z1), f32x4(3.0, 5.0, 7.0, 9.0));\n+\n+        all_eq!(simd_mul(x1, x2), i32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(x2, x1), i32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(y1, y2), u32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(y2, y1), u32x4(2, 6, 12, 20));\n+        all_eq!(simd_mul(z1, z2), f32x4(2.0, 6.0, 12.0, 20.0));\n+        all_eq!(simd_mul(z2, z1), f32x4(2.0, 6.0, 12.0, 20.0));\n+\n+        all_eq!(simd_sub(x2, x1), i32x4(1, 1, 1, 1));\n+        all_eq!(simd_sub(x1, x2), i32x4(-1, -1, -1, -1));\n+        all_eq!(simd_sub(y2, y1), u32x4(1, 1, 1, 1));\n+        all_eq!(simd_sub(y1, y2), u32x4(!0, !0, !0, !0));\n+        all_eq!(simd_sub(z2, z1), f32x4(1.0, 1.0, 1.0, 1.0));\n+        all_eq!(simd_sub(z1, z2), f32x4(-1.0, -1.0, -1.0, -1.0));\n+\n+        all_eq!(simd_div(z1, z2), f32x4(1.0/2.0, 2.0/3.0, 3.0/4.0, 4.0/5.0));\n+        all_eq!(simd_div(z2, z1), f32x4(2.0/1.0, 3.0/2.0, 4.0/3.0, 5.0/4.0));\n+\n+        all_eq!(simd_shl(x1, x2), i32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n+        all_eq!(simd_shl(x2, x1), i32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n+        all_eq!(simd_shl(y1, y2), u32x4(1 << 2, 2 << 3, 3 << 4, 4 << 5));\n+        all_eq!(simd_shl(y2, y1), u32x4(2 << 1, 3 << 2, 4 << 3, 5 << 4));\n+\n+        // test right-shift by assuming left-shift is correct\n+        all_eq!(simd_shr(simd_shl(x1, x2), x2), x1);\n+        all_eq!(simd_shr(simd_shl(x2, x1), x1), x2);\n+        all_eq!(simd_shr(simd_shl(y1, y2), y2), y1);\n+        all_eq!(simd_shr(simd_shl(y2, y1), y1), y2);\n+\n+        // ensure we get logical vs. arithmetic shifts correct\n+        let (a, b, c, d) = (-12, -123, -1234, -12345);\n+        all_eq!(simd_shr(i32x4(a, b, c, d), x1), i32x4(a >> 1, b >> 2, c >> 3, d >> 4));\n+        all_eq!(simd_shr(u32x4(a as u32, b as u32, c as u32, d as u32), y1),\n+                u32x4((a as u32) >> 1, (b as u32) >> 2, (c as u32) >> 3, (d as u32) >> 4));\n+\n+        all_eq!(simd_and(x1, x2), i32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(x2, x1), i32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(y1, y2), u32x4(0, 2, 0, 4));\n+        all_eq!(simd_and(y2, y1), u32x4(0, 2, 0, 4));\n+\n+        all_eq!(simd_or(x1, x2), i32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(x2, x1), i32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(y1, y2), u32x4(3, 3, 7, 5));\n+        all_eq!(simd_or(y2, y1), u32x4(3, 3, 7, 5));\n+\n+        all_eq!(simd_xor(x1, x2), i32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(x2, x1), i32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(y1, y2), u32x4(3, 1, 7, 1));\n+        all_eq!(simd_xor(y2, y1), u32x4(3, 1, 7, 1));\n+\n+    }\n+}"}, {"sha": "a20dd3ef72a54cd831eebf714931095419dd00ad", "filename": "src/test/run-pass/simd-intrinsic-generic-cast.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-cast.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics, concat_idents,\n+           type_macros, test)]\n+#![allow(non_camel_case_types)]\n+\n+extern crate test;\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct i8x4(i8, i8, i8, i8);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct u32x4(u32, u32, u32, u32);\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct u8x4(u8, u8, u8, u8);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct f32x4(f32, f32, f32, f32);\n+\n+#[repr(simd)]\n+#[derive(PartialEq, Debug)]\n+struct f64x4(f64, f64, f64, f64);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_cast<T, U>(x: T) -> U;\n+}\n+\n+const A: i32 = -1234567;\n+const B: i32 = 12345678;\n+const C: i32 = -123456789;\n+const D: i32 = 1234567890;\n+\n+trait Foo {\n+    fn is_float() -> bool { false }\n+    fn in_range(x: i32) -> bool;\n+}\n+impl Foo for i32 {\n+    fn in_range(_: i32) -> bool { true }\n+}\n+impl Foo for i8 {\n+    fn in_range(x: i32) -> bool { -128 <= x && x < 128 }\n+}\n+impl Foo for u32 {\n+    fn in_range(x: i32) -> bool { 0 <= x }\n+}\n+impl Foo for u8 {\n+    fn in_range(x: i32) -> bool { 0 <= x && x < 128 }\n+}\n+impl Foo for f32 {\n+    fn is_float() -> bool { true }\n+    fn in_range(_: i32) -> bool { true }\n+}\n+impl Foo for f64 {\n+    fn is_float() -> bool { true }\n+    fn in_range(_: i32) -> bool { true }\n+}\n+\n+fn main() {\n+    macro_rules! test {\n+        ($from: ident, $to: ident) => {{\n+            // force the casts to actually happen, or else LLVM/rustc\n+            // may fold them and get slightly different results.\n+            let (a, b, c, d) = test::black_box((A as $from, B as $from, C as $from, D as $from));\n+            // the SIMD vectors are all FOOx4, so we can concat_idents\n+            // so we don't have to pass in the extra args to the macro\n+            let mut from = simd_cast(concat_idents!($from, x4)(a, b, c, d));\n+            let mut to = concat_idents!($to, x4)(a as $to,\n+                                                 b as $to,\n+                                                 c as $to,\n+                                                 d as $to);\n+            // assist type inference, it needs to know what `from` is\n+            // for the `if` statements.\n+            to == from;\n+\n+            // there are platform differences for some out of range\n+            // casts, so we just normalize such things: it's OK for\n+            // \"invalid\" calculations to result in nonsense answers.\n+            // (E.g. negative float to unsigned integer goes through a\n+            // library routine on the default i686 platforms, and the\n+            // implementation of that routine differs on e.g. Linux\n+            // vs. OSX, resulting in different answers.)\n+            if $from::is_float() {\n+                if !$to::in_range(A) { from.0 = 0 as $to; to.0 = 0 as $to; }\n+                if !$to::in_range(B) { from.1 = 0 as $to; to.1 = 0 as $to; }\n+                if !$to::in_range(C) { from.2 = 0 as $to; to.2 = 0 as $to; }\n+                if !$to::in_range(D) { from.3 = 0 as $to; to.3 = 0 as $to; }\n+            }\n+\n+            assert!(to == from,\n+                    \"{} -> {} ({:?} != {:?})\", stringify!($from), stringify!($to),\n+                    from, to);\n+        }}\n+    }\n+    macro_rules! tests {\n+        (: $($to: ident),*) => { () };\n+        // repeating the list twice is easier than writing a cartesian\n+        // product macro\n+        ($from: ident $(, $from_: ident)*: $($to: ident),*) => {\n+            fn $from() { unsafe { $( test!($from, $to); )* } }\n+            tests!($($from_),*: $($to),*)\n+        };\n+        ($($types: ident),*) => {{\n+            tests!($($types),* : $($types),*);\n+            $($types();)*\n+        }}\n+    }\n+\n+    // test various combinations, including truncation,\n+    // signed/unsigned extension, and floating point casts.\n+    tests!(i32, i8, u32, u8, f32);\n+    tests!(i32, u32, f32, f64)\n+}"}, {"sha": "5802fb30bd68045f59e1a31e2376057316b04da7", "filename": "src/test/run-pass/simd-intrinsic-generic-comparison.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-comparison.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics, concat_idents)]\n+#![allow(non_camel_case_types)]\n+\n+use std::f32::NAN;\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_eq<T, U>(x: T, y: T) -> U;\n+    fn simd_ne<T, U>(x: T, y: T) -> U;\n+    fn simd_lt<T, U>(x: T, y: T) -> U;\n+    fn simd_le<T, U>(x: T, y: T) -> U;\n+    fn simd_gt<T, U>(x: T, y: T) -> U;\n+    fn simd_ge<T, U>(x: T, y: T) -> U;\n+}\n+\n+macro_rules! cmp {\n+    ($method: ident($lhs: expr, $rhs: expr)) => {{\n+        let lhs = $lhs;\n+        let rhs = $rhs;\n+        let e: u32x4 = concat_idents!(simd_, $method)($lhs, $rhs);\n+        // assume the scalar version is correct/the behaviour we want.\n+        assert!((e.0 != 0) == lhs.0 .$method(&rhs.0));\n+        assert!((e.1 != 0) == lhs.1 .$method(&rhs.1));\n+        assert!((e.2 != 0) == lhs.2 .$method(&rhs.2));\n+        assert!((e.3 != 0) == lhs.3 .$method(&rhs.3));\n+    }}\n+}\n+macro_rules! tests {\n+    ($($lhs: ident, $rhs: ident;)*) => {{\n+        $(\n+            (|| {\n+                cmp!(eq($lhs, $rhs));\n+                cmp!(ne($lhs, $rhs));\n+\n+                // test both directions\n+                cmp!(lt($lhs, $rhs));\n+                cmp!(lt($rhs, $lhs));\n+\n+                cmp!(le($lhs, $rhs));\n+                cmp!(le($rhs, $lhs));\n+\n+                cmp!(gt($lhs, $rhs));\n+                cmp!(gt($rhs, $lhs));\n+\n+                cmp!(ge($lhs, $rhs));\n+                cmp!(ge($rhs, $lhs));\n+            })();\n+            )*\n+    }}\n+}\n+fn main() {\n+    // 13 vs. -100 tests that we get signed vs. unsigned comparisons\n+    // correct (i32: 13 > -100, u32: 13 < -100).    let i1 = i32x4(10, -11, 12, 13);\n+    let i1 = i32x4(10, -11, 12, 13);\n+    let i2 = i32x4(5, -5, 20, -100);\n+    let i3 = i32x4(10, -11, 20, -100);\n+\n+    let u1 = u32x4(10, !11+1, 12, 13);\n+    let u2 = u32x4(5, !5+1, 20, !100+1);\n+    let u3 = u32x4(10, !11+1, 20, !100+1);\n+\n+    let f1 = f32x4(10.0, -11.0, 12.0, 13.0);\n+    let f2 = f32x4(5.0, -5.0, 20.0, -100.0);\n+    let f3 = f32x4(10.0, -11.0, 20.0, -100.0);\n+\n+    unsafe {\n+        tests! {\n+            i1, i1;\n+            u1, u1;\n+            f1, f1;\n+\n+            i1, i2;\n+            u1, u2;\n+            f1, f2;\n+\n+            i1, i3;\n+            u1, u3;\n+            f1, f3;\n+        }\n+    }\n+\n+    // NAN comparisons are special:\n+    // -11 (*)    13\n+    // -5        -100 (*)\n+    let f4 = f32x4(NAN, f1.1, NAN, f2.3);\n+\n+    unsafe {\n+        tests! {\n+            f1, f4;\n+            f2, f4;\n+            f4, f4;\n+        }\n+    }\n+}"}, {"sha": "f0444c27170561550a80c85b48e8e4f3f17dd2c1", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84de8caa87b085772cbe41de0b39630ccca3afab/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=84de8caa87b085772cbe41de0b39630ccca3afab", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x2(i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x3(i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+#[allow(non_camel_case_types)]\n+struct i32x8(i32, i32, i32, i32,\n+             i32, i32, i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, E>(x: T, idx: u32, y: E) -> T;\n+    fn simd_extract<T, E>(x: T, idx: u32) -> E;\n+\n+    fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n+    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n+    fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n+    fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n+}\n+\n+macro_rules! all_eq {\n+    ($a: expr, $b: expr) => {{\n+        let a = $a;\n+        let b = $b;\n+        // type inference works better with the concrete type on the\n+        // left, but humans work better with the expected on the\n+        // right.\n+        assert!(b == a,\n+                \"{:?} != {:?}\", a, b);\n+    }}\n+}\n+\n+fn main() {\n+    let x2 = i32x2(20, 21);\n+    let x3 = i32x3(30, 31, 32);\n+    let x4 = i32x4(40, 41, 42, 43);\n+    let x8 = i32x8(80, 81, 82, 83, 84, 85, 86, 87);\n+    unsafe {\n+        all_eq!(simd_insert(x2, 0, 100), i32x2(100, 21));\n+        all_eq!(simd_insert(x2, 1, 100), i32x2(20, 100));\n+\n+        all_eq!(simd_insert(x3, 0, 100), i32x3(100, 31, 32));\n+        all_eq!(simd_insert(x3, 1, 100), i32x3(30, 100, 32));\n+        all_eq!(simd_insert(x3, 2, 100), i32x3(30, 31, 100));\n+\n+        all_eq!(simd_insert(x4, 0, 100), i32x4(100, 41, 42, 43));\n+        all_eq!(simd_insert(x4, 1, 100), i32x4(40, 100, 42, 43));\n+        all_eq!(simd_insert(x4, 2, 100), i32x4(40, 41, 100, 43));\n+        all_eq!(simd_insert(x4, 3, 100), i32x4(40, 41, 42, 100));\n+\n+        all_eq!(simd_insert(x8, 0, 100), i32x8(100, 81, 82, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 1, 100), i32x8(80, 100, 82, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 2, 100), i32x8(80, 81, 100, 83, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 3, 100), i32x8(80, 81, 82, 100, 84, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 4, 100), i32x8(80, 81, 82, 83, 100, 85, 86, 87));\n+        all_eq!(simd_insert(x8, 5, 100), i32x8(80, 81, 82, 83, 84, 100, 86, 87));\n+        all_eq!(simd_insert(x8, 6, 100), i32x8(80, 81, 82, 83, 84, 85, 100, 87));\n+        all_eq!(simd_insert(x8, 7, 100), i32x8(80, 81, 82, 83, 84, 85, 86, 100));\n+\n+        all_eq!(simd_extract(x2, 0), 20);\n+        all_eq!(simd_extract(x2, 1), 21);\n+\n+        all_eq!(simd_extract(x3, 0), 30);\n+        all_eq!(simd_extract(x3, 1), 31);\n+        all_eq!(simd_extract(x3, 2), 32);\n+\n+        all_eq!(simd_extract(x4, 0), 40);\n+        all_eq!(simd_extract(x4, 1), 41);\n+        all_eq!(simd_extract(x4, 2), 42);\n+        all_eq!(simd_extract(x4, 3), 43);\n+\n+        all_eq!(simd_extract(x8, 0), 80);\n+        all_eq!(simd_extract(x8, 1), 81);\n+        all_eq!(simd_extract(x8, 2), 82);\n+        all_eq!(simd_extract(x8, 3), 83);\n+        all_eq!(simd_extract(x8, 4), 84);\n+        all_eq!(simd_extract(x8, 5), 85);\n+        all_eq!(simd_extract(x8, 6), 86);\n+        all_eq!(simd_extract(x8, 7), 87);\n+    }\n+\n+    let y2 = i32x2(120, 121);\n+    let y3 = i32x3(130, 131, 132);\n+    let y4 = i32x4(140, 141, 142, 143);\n+    let y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n+    unsafe {\n+        all_eq!(simd_shuffle2(x2, y2, [3, 0]), i32x2(121, 20));\n+        all_eq!(simd_shuffle3(x2, y2, [3, 0, 1]), i32x3(121, 20, 21));\n+        all_eq!(simd_shuffle4(x2, y2, [3, 0, 1, 2]), i32x4(121, 20, 21, 120));\n+        all_eq!(simd_shuffle8(x2, y2, [3, 0, 1, 2, 1, 2, 3, 0]),\n+                i32x8(121, 20, 21, 120, 21, 120, 121, 20));\n+\n+        all_eq!(simd_shuffle2(x3, y3, [4, 2]), i32x2(131, 32));\n+        all_eq!(simd_shuffle3(x3, y3, [4, 2, 3]), i32x3(131, 32, 130));\n+        all_eq!(simd_shuffle4(x3, y3, [4, 2, 3, 0]), i32x4(131, 32, 130, 30));\n+        all_eq!(simd_shuffle8(x3, y3, [4, 2, 3, 0, 1, 5, 5, 1]),\n+                i32x8(131, 32, 130, 30, 31, 132, 132, 31));\n+\n+        all_eq!(simd_shuffle2(x4, y4, [7, 2]), i32x2(143, 42));\n+        all_eq!(simd_shuffle3(x4, y4, [7, 2, 5]), i32x3(143, 42, 141));\n+        all_eq!(simd_shuffle4(x4, y4, [7, 2, 5, 0]), i32x4(143, 42, 141, 40));\n+        all_eq!(simd_shuffle8(x4, y4, [7, 2, 5, 0, 3, 6, 4, 1]),\n+                i32x8(143, 42, 141, 40, 43, 142, 140, 41));\n+\n+        all_eq!(simd_shuffle2(x8, y8, [11, 5]), i32x2(183, 85));\n+        all_eq!(simd_shuffle3(x8, y8, [11, 5, 15]), i32x3(183, 85, 187));\n+        all_eq!(simd_shuffle4(x8, y8, [11, 5, 15, 0]), i32x4(183, 85, 187, 80));\n+        all_eq!(simd_shuffle8(x8, y8, [11, 5, 15, 0, 3, 8, 12, 1]),\n+                i32x8(183, 85, 187, 80, 83, 180, 184, 81));\n+    }\n+\n+}"}]}