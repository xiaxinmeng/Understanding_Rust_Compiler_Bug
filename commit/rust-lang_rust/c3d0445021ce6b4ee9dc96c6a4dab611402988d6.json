{"sha": "c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDA0NDUwMjFjZTZiNGVlOWRjOTZjNmE0ZGFiNjExNDAyOTg4ZDY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-10-01T07:24:44Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-18T13:21:20Z"}, "message": "Destructure byte slices and remove all the workarounds", "tree": {"sha": "67fd74b7e40b9203ce22232830ace57287157a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67fd74b7e40b9203ce22232830ace57287157a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "html_url": "https://github.com/rust-lang/rust/commit/c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb8111069ed38455d915f7f8f0e050bb3c3720cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8111069ed38455d915f7f8f0e050bb3c3720cf", "html_url": "https://github.com/rust-lang/rust/commit/bb8111069ed38455d915f7f8f0e050bb3c3720cf"}], "stats": {"total": 252, "additions": 9, "deletions": 243}, "files": [{"sha": "9ca711722a307a350f734b0b28ef13165d2de4ae", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 8, "deletions": 241, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "patch": "@@ -284,10 +284,9 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n \n use rustc_arena::TypedArena;\n use rustc_attr::{SignedInt, UnsignedInt};\n-use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{truncate, ConstValue};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n@@ -296,84 +295,21 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n-use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n-use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n \n-crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n+crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander.fold_pattern(&pat)\n }\n \n-struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n+struct LiteralExpander;\n \n-impl<'tcx> LiteralExpander<'tcx> {\n-    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n-    ///\n-    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n-    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n-    /// the array to a slice in that case.\n-    fn fold_const_value_deref(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-        // the pattern's pointee type\n-        rty: Ty<'tcx>,\n-        // the constant's pointee type\n-        crty: Ty<'tcx>,\n-    ) -> ConstValue<'tcx> {\n-        debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.kind(), &rty.kind()) {\n-            // unsize array to slice if pattern is array but match value or other patterns are slice\n-            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n-                assert_eq!(t, u);\n-                assert_eq!(p.offset, Size::ZERO);\n-                ConstValue::Slice {\n-                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n-                    start: 0,\n-                    end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n-                }\n-            }\n-            _ => val,\n-        }\n-    }\n-}\n-\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n         match (pat.ty.kind(), &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatKind::Constant { value: Const { val, ty: const_ty } })\n-                if const_ty.is_ref() =>\n-            {\n-                let crty =\n-                    if let ty::Ref(_, crty, _) = const_ty.kind() { crty } else { unreachable!() };\n-                if let ty::ConstKind::Value(val) = val {\n-                    Pat {\n-                        ty: pat.ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Deref {\n-                            subpattern: Pat {\n-                                ty: rty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant {\n-                                    value: Const::from_value(\n-                                        self.tcx,\n-                                        self.fold_const_value_deref(*val, rty, crty),\n-                                        rty,\n-                                    ),\n-                                },\n-                            },\n-                        },\n-                    }\n-                } else {\n-                    bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty)\n-                }\n-            }\n-\n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n             (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n@@ -941,8 +877,6 @@ impl<'tcx> Constructor<'tcx> {\n                     .iter()\n                     .filter_map(|c: &Constructor<'_>| match c {\n                         Slice(slice) => Some(*slice),\n-                        // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                        ConstantValue(..) => None,\n                         _ => bug!(\"bad slice pattern constructor {:?}\", c),\n                     })\n                     .map(Slice::value_kind);\n@@ -1162,12 +1096,6 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n \n-    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n-    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n-    fn from_slice_unfiltered(pats: &'p [Pat<'tcx>]) -> Self {\n-        Fields::Slice(pats)\n-    }\n-\n     /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -2183,19 +2111,7 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                match (value.val, &value.ty.kind()) {\n-                    (_, ty::Array(_, n)) => {\n-                        let len = n.eval_usize(tcx, param_env);\n-                        Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n-                    }\n-                    (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }), ty::Slice(_)) => {\n-                        let len = (end - start) as u64;\n-                        Some(Slice(Slice { array_len: None, kind: FixedLen(len) }))\n-                    }\n-                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                    // (ty::ConstKind::Value(ConstValue::ByRef { .. }), ty::Slice(_)) => { ... }\n-                    _ => Some(ConstantValue(value)),\n-                }\n+                Some(ConstantValue(value))\n             }\n         }\n         PatKind::Range(PatRange { lo, hi, end }) => {\n@@ -2230,75 +2146,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n-// meaning all other types will compare unequal and thus equal patterns often do not cause the\n-// second pattern to lint about unreachable match arms.\n-fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    _span: Span,\n-    const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pat<'tcx>],\n-    slice: &Option<Pat<'tcx>>,\n-    suffix: &[Pat<'tcx>],\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Result<bool, ErrorReported> {\n-    let const_val_val = if let ty::ConstKind::Value(val) = const_val.val {\n-        val\n-    } else {\n-        bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        )\n-    };\n-\n-    let data: &[u8] = match (const_val_val, &const_val.ty.kind()) {\n-        (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let n = n.eval_usize(tcx, param_env);\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        }\n-        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n-        }\n-        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n-        (_, ty::Slice(_)) => return Ok(false),\n-        _ => bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        ),\n-    };\n-\n-    let pat_len = prefix.len() + suffix.len();\n-    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n-        return Ok(false);\n-    }\n-\n-    for (ch, pat) in data[..prefix.len()]\n-        .iter()\n-        .zip(prefix)\n-        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n-    {\n-        if let box PatKind::Constant { value } = pat.kind {\n-            let b = value.eval_bits(tcx, param_env, pat.ty);\n-            assert_eq!(b as u8 as u128, b);\n-            if b as u8 != *ch {\n-                return Ok(false);\n-            }\n-        }\n-    }\n-\n-    Ok(true)\n-}\n-\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -2670,73 +2517,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n-            // We extract an `Option` for the pointer because slices of zero\n-            // elements don't necessarily point to memory, they are usually\n-            // just integers. The only time they should be pointing to memory\n-            // is when they are subslices of nonzero slices.\n-            let (alloc, offset, n, ty) = match value.ty.kind() {\n-                ty::Array(t, n) => {\n-                    let n = n.eval_usize(cx.tcx, cx.param_env);\n-                    // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n-                    // the result would be exactly what we early return here.\n-                    if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 != n {\n-                            return None;\n-                        }\n-                        return Some(Fields::empty());\n-                    }\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n-                            (Cow::Borrowed(alloc), offset, n, t)\n-                        }\n-                        _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n-                    }\n-                }\n-                ty::Slice(t) => {\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start);\n-                            let n = (end - start) as u64;\n-                            (Cow::Borrowed(data), offset, n, t)\n-                        }\n-                        ty::ConstKind::Value(ConstValue::ByRef { .. }) => {\n-                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                            return None;\n-                        }\n-                        _ => span_bug!(\n-                            pat.span,\n-                            \"slice pattern constant must be scalar pair but is {:?}\",\n-                            value,\n-                        ),\n-                    }\n-                }\n-                _ => span_bug!(\n-                    pat.span,\n-                    \"unexpected const-val {:?} with ctor {:?}\",\n-                    value,\n-                    constructor,\n-                ),\n-            };\n-            if ctor_wild_subpatterns.len() as u64 != n {\n-                return None;\n-            }\n-\n-            // Convert a constant slice/array pattern to a list of patterns.\n-            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n-                let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.check_init().ok()?;\n-                let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                Some(pattern)\n-            }));\n-            // Ensure none of the dereferences failed.\n-            if pats.len() as u64 != n {\n-                return None;\n-            }\n-            Some(Fields::from_slice_unfiltered(pats))\n+            span_bug!(pat.span, \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n         }\n \n         PatKind::Constant { .. } | PatKind::Range { .. } => {\n@@ -2778,21 +2559,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n                 Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n-            ConstantValue(cv) => {\n-                match slice_pat_covered_by_const(\n-                    cx.tcx,\n-                    pat.span,\n-                    cv,\n-                    prefix,\n-                    slice,\n-                    suffix,\n-                    cx.param_env,\n-                ) {\n-                    Ok(true) => Some(Fields::empty()),\n-                    Ok(false) => None,\n-                    Err(ErrorReported) => None,\n-                }\n-            }\n+            ConstantValue(_) => None,\n             _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n         },\n "}, {"sha": "f623f3f6313787767f4d8c3d2dc3dbffe3684dcc", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "patch": "@@ -140,7 +140,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n         let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors(pat.span);"}, {"sha": "6370f8c375b2a91cf5d4cef7018d52f96b6e6aec", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d0445021ce6b4ee9dc96c6a4dab611402988d6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=c3d0445021ce6b4ee9dc96c6a4dab611402988d6", "patch": "@@ -387,7 +387,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n-                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n                 // The typechecker has a special case for byte string literals, by treating them"}]}