{"sha": "f91b634643de14ab5156b0c084d80bd6845fb0ae", "node_id": "C_kwDOAAsO6NoAKGY5MWI2MzQ2NDNkZTE0YWI1MTU2YjBjMDg0ZDgwYmQ2ODQ1ZmIwYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T15:12:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T15:12:24Z"}, "message": "Auto merge of #110975 - Amanieu:panic_count, r=joshtriplett\n\nRework handling of recursive panics\n\nThis PR makes 2 changes to how recursive panics works (a panic while handling a panic).\n\n1. The panic count is no longer used to determine whether to force an immediate abort. This allows code like the following to work without aborting the process immediately:\n\n```rust\nstruct Double;\n\nimpl Drop for Double {\n    fn drop(&mut self) {\n        // 2 panics are active at once, but this is fine since it is caught.\n        std::panic::catch_unwind(|| panic!(\"twice\"));\n    }\n}\n\nlet _d = Double;\n\npanic!(\"once\");\n```\n\nRustc already generates appropriate code so that any exceptions escaping out of a `Drop` called in the unwind path will immediately abort the process.\n\n2. Any panics while the panic hook is executing will force an immediate abort. This is necessary to avoid potential deadlocks like #110771 where a panic happens while holding the backtrace lock. We don't even try to print the panic message in this case since the panic may have been caused by `Display` impls.\n\nFixes #110771", "tree": {"sha": "a07e9d832fad28603386d0c2dcf91968c75c5f38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a07e9d832fad28603386d0c2dcf91968c75c5f38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f91b634643de14ab5156b0c084d80bd6845fb0ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f91b634643de14ab5156b0c084d80bd6845fb0ae", "html_url": "https://github.com/rust-lang/rust/commit/f91b634643de14ab5156b0c084d80bd6845fb0ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f91b634643de14ab5156b0c084d80bd6845fb0ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b311b4189cce2bde455f3e091ae662a382d592", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b311b4189cce2bde455f3e091ae662a382d592", "html_url": "https://github.com/rust-lang/rust/commit/82b311b4189cce2bde455f3e091ae662a382d592"}, {"sha": "de607f1b5cc99d8ac773205702e184c2461d5e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/de607f1b5cc99d8ac773205702e184c2461d5e12", "html_url": "https://github.com/rust-lang/rust/commit/de607f1b5cc99d8ac773205702e184c2461d5e12"}], "stats": {"total": 235, "additions": 149, "deletions": 86}, "files": [{"sha": "a6a370409c0e23425fd04e253203dc1f61d59cc9", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -298,8 +298,18 @@ pub mod panic_count {\n \n     pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n \n-    // Panic count for the current thread.\n-    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = const { Cell::new(0) } }\n+    /// A reason for forcing an immediate abort on panic.\n+    #[derive(Debug)]\n+    pub enum MustAbort {\n+        AlwaysAbort,\n+        PanicInHook,\n+    }\n+\n+    // Panic count for the current thread and whether a panic hook is currently\n+    // being executed..\n+    thread_local! {\n+        static LOCAL_PANIC_COUNT: Cell<(usize, bool)> = const { Cell::new((0, false)) }\n+    }\n \n     // Sum of panic counts from all threads. The purpose of this is to have\n     // a fast path in `count_is_zero` (which is used by `panicking`). In any particular\n@@ -328,34 +338,39 @@ pub mod panic_count {\n     // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n-    // Return the state of the ALWAYS_ABORT_FLAG and number of panics.\n+    // Increases the global and local panic count, and returns whether an\n+    // immediate abort is required.\n     //\n-    // If ALWAYS_ABORT_FLAG is not set, the number is determined on a per-thread\n-    // base (stored in LOCAL_PANIC_COUNT), i.e. it is the amount of recursive calls\n-    // of the calling thread.\n-    // If ALWAYS_ABORT_FLAG is set, the number equals the *global* number of panic\n-    // calls. See above why LOCAL_PANIC_COUNT is not used.\n-    pub fn increase() -> (bool, usize) {\n+    // This also updates thread-local state to keep track of whether a panic\n+    // hook is currently executing.\n+    pub fn increase(run_panic_hook: bool) -> Option<MustAbort> {\n         let global_count = GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n-        let must_abort = global_count & ALWAYS_ABORT_FLAG != 0;\n-        let panics = if must_abort {\n-            global_count & !ALWAYS_ABORT_FLAG\n-        } else {\n-            LOCAL_PANIC_COUNT.with(|c| {\n-                let next = c.get() + 1;\n-                c.set(next);\n-                next\n-            })\n-        };\n-        (must_abort, panics)\n+        if global_count & ALWAYS_ABORT_FLAG != 0 {\n+            return Some(MustAbort::AlwaysAbort);\n+        }\n+\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, in_panic_hook) = c.get();\n+            if in_panic_hook {\n+                return Some(MustAbort::PanicInHook);\n+            }\n+            c.set((count + 1, run_panic_hook));\n+            None\n+        })\n+    }\n+\n+    pub fn finished_panic_hook() {\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, _) = c.get();\n+            c.set((count, false));\n+        });\n     }\n \n     pub fn decrease() {\n         GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n         LOCAL_PANIC_COUNT.with(|c| {\n-            let next = c.get() - 1;\n-            c.set(next);\n-            next\n+            let (count, _) = c.get();\n+            c.set((count - 1, false));\n         });\n     }\n \n@@ -366,7 +381,7 @@ pub mod panic_count {\n     // Disregards ALWAYS_ABORT_FLAG\n     #[must_use]\n     pub fn get_count() -> usize {\n-        LOCAL_PANIC_COUNT.with(|c| c.get())\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0)\n     }\n \n     // Disregards ALWAYS_ABORT_FLAG\n@@ -394,7 +409,7 @@ pub mod panic_count {\n     #[inline(never)]\n     #[cold]\n     fn is_zero_slow_path() -> bool {\n-        LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0 == 0)\n     }\n }\n \n@@ -655,23 +670,22 @@ fn rust_panic_with_hook(\n     location: &Location<'_>,\n     can_unwind: bool,\n ) -> ! {\n-    let (must_abort, panics) = panic_count::increase();\n-\n-    // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n-    // the panic hook probably triggered the last panic, otherwise the\n-    // double-panic check would have aborted the process. In this case abort the\n-    // process real quickly as we don't want to try calling it again as it'll\n-    // probably just panic again.\n-    if must_abort || panics > 2 {\n-        if panics > 2 {\n-            // Don't try to print the message in this case\n-            // - perhaps that is causing the recursive panics.\n-            rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n-        } else {\n-            // Unfortunately, this does not print a backtrace, because creating\n-            // a `Backtrace` will allocate, which we must to avoid here.\n-            let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n-            rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+    let must_abort = panic_count::increase(true);\n+\n+    // Check if we need to abort immediately.\n+    if let Some(must_abort) = must_abort {\n+        match must_abort {\n+            panic_count::MustAbort::PanicInHook => {\n+                // Don't try to print the message in this case\n+                // - perhaps that is causing the recursive panics.\n+                rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n+            }\n+            panic_count::MustAbort::AlwaysAbort => {\n+                // Unfortunately, this does not print a backtrace, because creating\n+                // a `Backtrace` will allocate, which we must to avoid here.\n+                let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n+                rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+            }\n         }\n         crate::sys::abort_internal();\n     }\n@@ -697,16 +711,16 @@ fn rust_panic_with_hook(\n     };\n     drop(hook);\n \n-    if panics > 1 || !can_unwind {\n-        // If a thread panics while it's already unwinding then we\n-        // have limited options. Currently our preference is to\n-        // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the thread cleanly.\n-        if !can_unwind {\n-            rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n-        } else {\n-            rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n-        }\n+    // Indicate that we have finished executing the panic hook. After this point\n+    // it is fine if there is a panic while executing destructors, as long as it\n+    // it contained within a `catch_unwind`.\n+    panic_count::finished_panic_hook();\n+\n+    if !can_unwind {\n+        // If a thread panics while running destructors or tries to unwind\n+        // through a nounwind function (e.g. extern \"C\") then we cannot continue\n+        // unwinding and have to abort immediately.\n+        rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n         crate::sys::abort_internal();\n     }\n \n@@ -716,7 +730,7 @@ fn rust_panic_with_hook(\n /// This is the entry point for `resume_unwind`.\n /// It just forwards the payload to the panic runtime.\n pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n-    panic_count::increase();\n+    panic_count::increase(false);\n \n     struct RewrapBox(Box<dyn Any + Send>);\n "}, {"sha": "25c8df43ee26c8201523021c17a69fb352acc2d6", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -133,10 +133,15 @@ pub struct Thread<'mir, 'tcx> {\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n-    /// The temporary used for storing the argument of\n-    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    /// Stack of active panic payloads for the current thread. Used for storing\n+    /// the argument of the call to `miri_start_panic` (the panic payload) when unwinding.\n     /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n-    pub(crate) panic_payload: Option<Scalar<Provenance>>,\n+    ///\n+    /// In real unwinding, the payload gets passed as an argument to the landing pad,\n+    /// which then forwards it to 'Resume'. However this argument is implicit in MIR,\n+    /// so we have to store it out-of-band. When there are multiple active unwinds,\n+    /// the innermost one is always caught first, so we can store them as a stack.\n+    pub(crate) panic_payloads: Vec<Scalar<Provenance>>,\n \n     /// Last OS error location in memory. It is a 32-bit integer.\n     pub(crate) last_error: Option<MPlaceTy<'tcx, Provenance>>,\n@@ -206,7 +211,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n             stack: Vec::new(),\n             top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n-            panic_payload: None,\n+            panic_payloads: Vec::new(),\n             last_error: None,\n             on_stack_empty,\n         }\n@@ -216,7 +221,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Thread {\n-            panic_payload,\n+            panic_payloads: panic_payload,\n             last_error,\n             stack,\n             top_user_relevant_frame: _,\n@@ -226,7 +231,9 @@ impl VisitTags for Thread<'_, '_> {\n             on_stack_empty: _, // we assume the closure captures no GC-relevant state\n         } = self;\n \n-        panic_payload.visit_tags(visit);\n+        for payload in panic_payload {\n+            payload.visit_tags(visit);\n+        }\n         last_error.visit_tags(visit);\n         for frame in stack {\n             frame.visit_tags(visit)"}, {"sha": "7aefdfcb976afa6b7688daa1ded2c66c651e7b81", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -63,8 +63,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let [payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n         let payload = this.read_scalar(payload)?;\n         let thread = this.active_thread_mut();\n-        assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n-        thread.panic_payload = Some(payload);\n+        thread.panic_payloads.push(payload);\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind)?;\n@@ -146,7 +145,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             // The Thread's `panic_payload` holds what was passed to `miri_start_panic`.\n             // This is exactly the second argument we need to pass to `catch_fn`.\n-            let payload = this.active_thread_mut().panic_payload.take().unwrap();\n+            let payload = this.active_thread_mut().panic_payloads.pop().unwrap();\n \n             // Push the `catch_fn` stackframe.\n             let f_instance = this.get_ptr_fn(catch_unwind.catch_fn)?.as_instance()?;"}, {"sha": "adb30714269e8a1495405de728da57dd55eaafa5", "filename": "src/tools/miri/tests/fail/panic/double_panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -1,6 +1,4 @@\n-//@error-in-other-file: the program aborted\n //@normalize-stderr-test: \"\\| +\\^+\" -> \"| ^\"\n-//@normalize-stderr-test: \"unsafe \\{ libc::abort\\(\\) \\}|crate::intrinsics::abort\\(\\);\" -> \"ABORT();\"\n //@normalize-stderr-test: \"\\n  +[0-9]+:[^\\n]+\" -> \"$1\"\n //@normalize-stderr-test: \"\\n at [^\\n]+\" -> \"$1\"\n \n@@ -11,6 +9,7 @@ impl Drop for Foo {\n     }\n }\n fn main() {\n+    //~^ERROR: panic in a function that cannot unwind\n     let _foo = Foo;\n     panic!(\"first\");\n }"}, {"sha": "b6ac56f15d4b5033e28e8977d351408d1a2c9867", "filename": "src/tools/miri/tests/fail/panic/double_panic.stderr", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -2,30 +2,17 @@ thread 'main' panicked at 'first', $DIR/double_panic.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n thread 'main' panicked at 'second', $DIR/double_panic.rs:LL:CC\n stack backtrace:\n-thread panicked while panicking. aborting.\n-error: abnormal termination: the program aborted execution\n-  --> RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC\n-   |\n-LL |     ABORT();\n-   | ^ the program aborted execution\n-   |\n-   = note: inside `std::sys::PLATFORM::abort_internal` at RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC\n-   = note: inside `std::panicking::rust_panic_with_hook` at RUSTLIB/std/src/panicking.rs:LL:CC\n-   = note: inside closure at RUSTLIB/std/src/panicking.rs:LL:CC\n-   = note: inside `std::sys_common::backtrace::__rust_end_short_backtrace::<[closure@std::panicking::begin_panic_handler::{closure#0}], !>` at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   = note: inside `std::panicking::begin_panic_handler` at RUSTLIB/std/src/panicking.rs:LL:CC\n-note: inside `<Foo as std::ops::Drop>::drop`\n+error: abnormal termination: panic in a function that cannot unwind\n   --> $DIR/double_panic.rs:LL:CC\n    |\n-LL |         panic!(\"second\");\n-   | ^\n-   = note: inside `std::ptr::drop_in_place::<Foo> - shim(Some(Foo))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/double_panic.rs:LL:CC\n+LL | / fn main() {\n+LL | |\n+LL | |     let _foo = Foo;\n+LL | |     panic!(\"first\");\n+LL | | }\n+   | |_^ panic in a function that cannot unwind\n    |\n-LL | }\n-   | ^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: inside `main` at $DIR/double_panic.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "884813150ad2adb2b88599cc0295cf2d5d070be8", "filename": "src/tools/miri/tests/pass/panic/nested_panic_caught.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -0,0 +1,25 @@\n+//@normalize-stderr-test: \"\\| +\\^+\" -> \"| ^\"\n+//@normalize-stderr-test: \"\\n  +[0-9]+:[^\\n]+\" -> \"$1\"\n+//@normalize-stderr-test: \"\\n at [^\\n]+\" -> \"$1\"\n+\n+// Checks that nested panics work correctly.\n+\n+use std::panic::catch_unwind;\n+\n+fn double() {\n+    struct Double;\n+\n+    impl Drop for Double {\n+        fn drop(&mut self) {\n+            let _ = catch_unwind(|| panic!(\"twice\"));\n+        }\n+    }\n+\n+    let _d = Double;\n+\n+    panic!(\"once\");\n+}\n+\n+fn main() {\n+    assert!(catch_unwind(|| double()).is_err());\n+}"}, {"sha": "4e2593242df75ee81de35be48e23df2454ab8659", "filename": "src/tools/miri/tests/pass/panic/nested_panic_caught.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fnested_panic_caught.stderr?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -0,0 +1,4 @@\n+thread 'main' panicked at 'once', $DIR/nested_panic_caught.rs:LL:CC\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n+thread 'main' panicked at 'twice', $DIR/nested_panic_caught.rs:LL:CC\n+stack backtrace:"}, {"sha": "66b378f62d63c738f76af9f661c5c4a8867c92e5", "filename": "tests/ui/backtrace.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/tests%2Fui%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/tests%2Fui%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbacktrace.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -104,13 +104,17 @@ fn runtest(me: &str) {\n                 \"bad output3: {}\", s);\n \n         // Make sure a stack trace isn't printed too many times\n+        //\n+        // Currently it is printed 3 times (\"once\", \"twice\" and \"panic in a\n+        // function that cannot unwind\") but in the future the last one may be\n+        // removed.\n         let p = template(me).arg(\"double-fail\")\n                                     .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n         let out = p.wait_with_output().unwrap();\n         assert!(!out.status.success());\n         let s = str::from_utf8(&out.stderr).unwrap();\n         let mut i = 0;\n-        for _ in 0..2 {\n+        for _ in 0..3 {\n             i += s[i + 10..].find(\"stack backtrace\").unwrap() + 10;\n         }\n         assert!(s[i + 10..].find(\"stack backtrace\").is_none(),"}, {"sha": "d43886e809579aac4154f75aaf5e593e08b2b714", "filename": "tests/ui/panics/nested_panic_caught.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f91b634643de14ab5156b0c084d80bd6845fb0ae/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91b634643de14ab5156b0c084d80bd6845fb0ae/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs?ref=f91b634643de14ab5156b0c084d80bd6845fb0ae", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+// needs-unwind\n+\n+// Checks that nested panics work correctly.\n+\n+use std::panic::catch_unwind;\n+\n+fn double() {\n+    struct Double;\n+\n+    impl Drop for Double {\n+        fn drop(&mut self) {\n+            let _ = catch_unwind(|| panic!(\"twice\"));\n+        }\n+    }\n+\n+    let _d = Double;\n+\n+    panic!(\"once\");\n+}\n+\n+fn main() {\n+    assert!(catch_unwind(|| double()).is_err());\n+}"}]}