{"sha": "19fef72a8c14100029e5ce39cbc5472ab091dad8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZmVmNzJhOGMxNDEwMDAyOWU1Y2UzOWNiYzU0NzJhYjA5MWRhZDg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-19T18:52:08Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-20T10:25:20Z"}, "message": "Added panic-on-overflow for rhs of left and right shift expressions.\n\nThis includes a slight refactoring of the `cast_shift_rhs` and related\nfunctions in `trans::base`, so that I can call them from much later in\nthe compiler's control flow (so that we can clearly dilineate where\nautomatic conversions of the RHS occur, versus where we check it).\n\nThe rhs-checking and fallback-masking is generalized to 8- and 16-bit\nvalues, and the fallback-masking is turned on unconditionally.\n\nFix #10183.\n\nIs this a [breaking-change]?  I would argue it is not; it only adds a\nstrict definition to what was previously undefined behavior; however,\nthere might be code that was e.g. assuming that `1_i8 << 17` yields 0.\n(This happens in certain contexts and at certain optimization levels.)", "tree": {"sha": "181c5cefa6c8a3b456ed8a5be8005c091237935d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/181c5cefa6c8a3b456ed8a5be8005c091237935d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19fef72a8c14100029e5ce39cbc5472ab091dad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19fef72a8c14100029e5ce39cbc5472ab091dad8", "html_url": "https://github.com/rust-lang/rust/commit/19fef72a8c14100029e5ce39cbc5472ab091dad8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19fef72a8c14100029e5ce39cbc5472ab091dad8/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f53b943f94b338e4c5401f1ce9efbe7da92b0c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f53b943f94b338e4c5401f1ce9efbe7da92b0c5", "html_url": "https://github.com/rust-lang/rust/commit/7f53b943f94b338e4c5401f1ce9efbe7da92b0c5"}], "stats": {"total": 195, "additions": 166, "deletions": 29}, "files": [{"sha": "cea3adccda4a11a91f758dca5563b9963cf372fa", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=19fef72a8c14100029e5ce39cbc5472ab091dad8", "patch": "@@ -756,7 +756,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n }\n \n pub fn cast_shift_expr_rhs(cx: Block,\n-                           op: ast::BinOp,\n+                           op: ast::BinOp_,\n                            lhs: ValueRef,\n                            rhs: ValueRef)\n                            -> ValueRef {\n@@ -765,24 +765,24 @@ pub fn cast_shift_expr_rhs(cx: Block,\n                    |a,b| ZExt(cx, a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: ast::BinOp,\n+pub fn cast_shift_const_rhs(op: ast::BinOp_,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n-pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n-                            lhs: ValueRef,\n-                            rhs: ValueRef,\n-                            trunc: F,\n-                            zext: G)\n-                            -> ValueRef where\n+fn cast_shift_rhs<F, G>(op: ast::BinOp_,\n+                        lhs: ValueRef,\n+                        rhs: ValueRef,\n+                        trunc: F,\n+                        zext: G)\n+                        -> ValueRef where\n     F: FnOnce(ValueRef, Type) -> ValueRef,\n     G: FnOnce(ValueRef, Type) -> ValueRef,\n {\n     // Shifts may have any size int on the rhs\n-    if ast_util::is_shift_binop(op.node) {\n+    if ast_util::is_shift_binop(op) {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n         if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }"}, {"sha": "c95b29f4e7afca2fad2ee6aeb9ca91551d46ec90", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=19fef72a8c14100029e5ce39cbc5472ab091dad8", "patch": "@@ -376,7 +376,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let signed = ty::type_is_signed(intype);\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n-            let te2 = base::cast_shift_const_rhs(b, te1, te2);\n+            let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n \n             match b.node {\n               ast::BiAdd   => {"}, {"sha": "9dd3f60ec4fcbd85cd655aaf91cf705b53fadd35", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 156, "deletions": 19, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fef72a8c14100029e5ce39cbc5472ab091dad8/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=19fef72a8c14100029e5ce39cbc5472ab091dad8", "patch": "@@ -1765,7 +1765,6 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n     let is_float = ty::type_is_fp(intype);\n     let is_signed = ty::type_is_signed(intype);\n-    let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n     let info = expr_info(binop_expr);\n \n     let binop_debug_loc = binop_expr.debug_loc();\n@@ -1838,13 +1837,17 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       ast::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n-      ast::BiShl => Shl(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiShl => {\n+          let (newbcx, res) = with_overflow_check(\n+              bcx, OverflowOp::Shl, info, lhs_t, lhs, rhs, binop_debug_loc);\n+          bcx = newbcx;\n+          res\n+      }\n       ast::BiShr => {\n-        if is_signed {\n-            AShr(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            LShr(bcx, lhs, rhs, binop_debug_loc)\n-        }\n+          let (newbcx, res) = with_overflow_check(\n+              bcx, OverflowOp::Shr, info, lhs_t, lhs, rhs, binop_debug_loc);\n+          bcx = newbcx;\n+          res\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if is_simd {\n@@ -2384,9 +2387,38 @@ enum OverflowOp {\n     Add,\n     Sub,\n     Mul,\n+    Shl,\n+    Shr,\n }\n \n impl OverflowOp {\n+    fn codegen_strategy(&self) -> OverflowCodegen {\n+        use self::OverflowCodegen::{ViaIntrinsic, ViaInputCheck};\n+        match *self {\n+            OverflowOp::Add => ViaIntrinsic(OverflowOpViaIntrinsic::Add),\n+            OverflowOp::Sub => ViaIntrinsic(OverflowOpViaIntrinsic::Sub),\n+            OverflowOp::Mul => ViaIntrinsic(OverflowOpViaIntrinsic::Mul),\n+\n+            OverflowOp::Shl => ViaInputCheck(OverflowOpViaInputCheck::Shl),\n+            OverflowOp::Shr => ViaInputCheck(OverflowOpViaInputCheck::Shr),\n+        }\n+    }\n+}\n+\n+enum OverflowCodegen {\n+    ViaIntrinsic(OverflowOpViaIntrinsic),\n+    ViaInputCheck(OverflowOpViaInputCheck),\n+}\n+\n+enum OverflowOpViaInputCheck { Shl, Shr, }\n+\n+enum OverflowOpViaIntrinsic { Add, Sub, Mul, }\n+\n+impl OverflowOpViaIntrinsic {\n+    fn to_intrinsic<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>, lhs_ty: Ty) -> ValueRef {\n+        let name = self.to_intrinsic_name(bcx.tcx(), lhs_ty);\n+        bcx.ccx().get_intrinsic(&name)\n+    }\n     fn to_intrinsic_name(&self, tcx: &ty::ctxt, ty: Ty) -> &'static str {\n         use syntax::ast::IntTy::*;\n         use syntax::ast::UintTy::*;\n@@ -2408,7 +2440,7 @@ impl OverflowOp {\n         };\n \n         match *self {\n-            OverflowOp::Add => match new_sty {\n+            OverflowOpViaIntrinsic::Add => match new_sty {\n                 ty_int(TyI8) => \"llvm.sadd.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.sadd.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.sadd.with.overflow.i32\",\n@@ -2421,7 +2453,7 @@ impl OverflowOp {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Sub => match new_sty {\n+            OverflowOpViaIntrinsic::Sub => match new_sty {\n                 ty_int(TyI8) => \"llvm.ssub.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.ssub.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.ssub.with.overflow.i32\",\n@@ -2434,7 +2466,7 @@ impl OverflowOp {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Mul => match new_sty {\n+            OverflowOpViaIntrinsic::Mul => match new_sty {\n                 ty_int(TyI8) => \"llvm.smul.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.smul.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.smul.with.overflow.i32\",\n@@ -2449,16 +2481,14 @@ impl OverflowOp {\n             },\n         }\n     }\n-}\n \n-\n-fn with_overflow_check<'a, 'b>(bcx: Block<'a, 'b>, oop: OverflowOp, info: NodeIdAndSpan,\n-                               lhs_t: Ty, lhs: ValueRef, rhs: ValueRef, binop_debug_loc: DebugLoc)\n-                               -> (Block<'a, 'b>, ValueRef) {\n-    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n-    if bcx.ccx().check_overflow() {\n-        let name = oop.to_intrinsic_name(bcx.tcx(), lhs_t);\n-        let llfn = bcx.ccx().get_intrinsic(&name);\n+    fn build_intrinsic_call<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>,\n+                                        info: NodeIdAndSpan,\n+                                        lhs_t: Ty<'tcx>, lhs: ValueRef,\n+                                        rhs: ValueRef,\n+                                        binop_debug_loc: DebugLoc)\n+                                        -> (Block<'blk, 'tcx>, ValueRef) {\n+        let llfn = self.to_intrinsic(bcx, lhs_t);\n \n         let val = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n         let result = ExtractValue(bcx, val, 0); // iN operation result\n@@ -2477,11 +2507,118 @@ fn with_overflow_check<'a, 'b>(bcx: Block<'a, 'b>, oop: OverflowOp, info: NodeId\n                     InternedString::new(\"arithmetic operation overflowed\")));\n \n         (bcx, result)\n+    }\n+}\n+\n+impl OverflowOpViaInputCheck {\n+    fn build_with_input_check<'blk, 'tcx>(&self,\n+                                          bcx: Block<'blk, 'tcx>,\n+                                          info: NodeIdAndSpan,\n+                                          lhs_t: Ty<'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc)\n+                                          -> (Block<'blk, 'tcx>, ValueRef)\n+    {\n+        let lhs_llty = val_ty(lhs);\n+        let rhs_llty = val_ty(rhs);\n+\n+        // Panic if any bits are set outside of bits that we always\n+        // mask in.\n+        //\n+        // Note that the mask's value is derived from the LHS type\n+        // (since that is where the 32/64 distinction is relevant) but\n+        // the mask's type must match the RHS type (since they will\n+        // both be fed into a and-binop)\n+        let invert_mask = !shift_mask_val(lhs_llty);\n+        let invert_mask = C_integral(rhs_llty, invert_mask, true);\n+\n+        let outer_bits = And(bcx, rhs, invert_mask, binop_debug_loc);\n+        let cond = ICmp(bcx, llvm::IntNE, outer_bits,\n+                        C_integral(rhs_llty, 0, false), binop_debug_loc);\n+        let result = match *self {\n+            OverflowOpViaInputCheck::Shl =>\n+                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOpViaInputCheck::Shr =>\n+                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n+        };\n+        let bcx =\n+            base::with_cond(bcx, cond, |bcx|\n+                controlflow::trans_fail(bcx, info,\n+                    InternedString::new(\"shift operation overflowed\")));\n+\n+        (bcx, result)\n+    }\n+}\n+\n+fn shift_mask_val(llty: Type) -> u64 {\n+    // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+    llty.int_width() - 1\n+}\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, ast::BinOp_::BiShl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    Shl(bcx, lhs, rhs, binop_debug_loc)\n+}\n+\n+fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs_t: Ty<'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, ast::BinOp_::BiShr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    let is_signed = ty::type_is_signed(lhs_t);\n+    if is_signed {\n+        AShr(bcx, lhs, rhs, binop_debug_loc)\n+    } else {\n+        LShr(bcx, lhs, rhs, binop_debug_loc)\n+    }\n+}\n+\n+fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              rhs: ValueRef,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+    let rhs_llty = val_ty(rhs);\n+    let mask = shift_mask_val(rhs_llty);\n+    And(bcx, rhs, C_integral(rhs_llty, mask, false), debug_loc)\n+}\n+\n+fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,\n+                                   lhs_t: Ty<'tcx>, lhs: ValueRef,\n+                                   rhs: ValueRef,\n+                                   binop_debug_loc: DebugLoc)\n+                                   -> (Block<'blk, 'tcx>, ValueRef) {\n+    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n+    if bcx.ccx().check_overflow() {\n+\n+        match oop.codegen_strategy() {\n+            OverflowCodegen::ViaIntrinsic(oop) =>\n+                oop.build_intrinsic_call(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n+            OverflowCodegen::ViaInputCheck(oop) =>\n+                oop.build_with_input_check(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n+        }\n     } else {\n         let res = match oop {\n             OverflowOp::Add => Add(bcx, lhs, rhs, binop_debug_loc),\n             OverflowOp::Sub => Sub(bcx, lhs, rhs, binop_debug_loc),\n             OverflowOp::Mul => Mul(bcx, lhs, rhs, binop_debug_loc),\n+\n+            OverflowOp::Shl =>\n+                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOp::Shr =>\n+                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n         };\n         (bcx, res)\n     }"}]}