{"sha": "e2326366935613816927e679d3b2dc04db44678c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMzI2MzY2OTM1NjEzODE2OTI3ZTY3OWQzYjJkYzA0ZGI0NDY3OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-04T03:18:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-04T03:18:14Z"}, "message": "Auto merge of #59897 - tmandry:variantful-generators, r=eddyb\n\nMulti-variant layouts for generators\n\nThis allows generators to overlap fields using variants, but doesn't do any such overlapping yet. It creates one variant for every state of the generator (unresumed, returned, panicked, plus one for every yield), and puts every stored local in each of the yield-point variants.\n\nRequired for optimizing generator layouts (#52924).\n\nThere was quite a lot of refactoring needed for this change. I've done my best in later commits to eliminate assumptions in the code that only certain kinds of types are multi-variant, and to centralize knowledge of the inner mechanics of generators in as few places as possible.\n\nThis change also emits debuginfo about the fields contained in each variant, as well as preserving debuginfo about stored locals while running in the generator.\n\nAlso, fixes #59972.\n\nFuture work:\n- Use this change for an optimization pass that actually overlaps locals within the generator struct (#52924)\n- In the type layout fields, don't include locals that are uninitialized for a particular variant, so miri and UB sanitizers can check our memory (see https://github.com/rust-lang/rust/issues/59972#issuecomment-483058172)\n- Preserve debuginfo scopes across generator yield points", "tree": {"sha": "9d9b3fb6ed6d688cf60a74b6072b325e8abb5872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9b3fb6ed6d688cf60a74b6072b325e8abb5872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2326366935613816927e679d3b2dc04db44678c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2326366935613816927e679d3b2dc04db44678c", "html_url": "https://github.com/rust-lang/rust/commit/e2326366935613816927e679d3b2dc04db44678c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2326366935613816927e679d3b2dc04db44678c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13fde05b12c28e1ed66bd13fdf1ea392f166b811", "url": "https://api.github.com/repos/rust-lang/rust/commits/13fde05b12c28e1ed66bd13fdf1ea392f166b811", "html_url": "https://github.com/rust-lang/rust/commit/13fde05b12c28e1ed66bd13fdf1ea392f166b811"}, {"sha": "77a6d29f483c6a1925a90f7e54b0d5721806d8fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a6d29f483c6a1925a90f7e54b0d5721806d8fa", "html_url": "https://github.com/rust-lang/rust/commit/77a6d29f483c6a1925a90f7e54b0d5721806d8fa"}], "stats": {"total": 1135, "additions": 804, "deletions": 331}, "files": [{"sha": "82a28716f5cabec22ccfdaf77cd68173bbf5ff80", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -2030,6 +2030,10 @@ impl<'tcx> Place<'tcx> {\n             variant_index))\n     }\n \n+    pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n+        self.elem(ProjectionElem::Downcast(None, variant_index))\n+    }\n+\n     pub fn index(self, index: Local) -> Place<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n@@ -2589,11 +2593,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                     let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n-                                struct_fmt.field(\"$state\", &places[freevars.len()]);\n-                                for i in (freevars.len() + 1)..places.len() {\n-                                    struct_fmt\n-                                        .field(&format!(\"${}\", i - freevars.len() - 1), &places[i]);\n-                                }\n                             });\n \n                             struct_fmt.finish()\n@@ -3031,10 +3030,29 @@ pub struct UnsafetyCheckResult {\n     pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n \n+newtype_index! {\n+    pub struct GeneratorSavedLocal {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"_{}\",\n+    }\n+}\n+\n /// The layout of generator state\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n-    pub fields: Vec<LocalDecl<'tcx>>,\n+    /// The type of every local stored inside the generator.\n+    pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n+\n+    /// Which of the above fields are in each variant. Note that one field may\n+    /// be stored in multiple variants.\n+    pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n+\n+    /// Names and scopes of all the stored generator locals.\n+    /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n+    /// debuginfo generation, and will be removed at some point.\n+    /// Do **NOT** use it for anything else, local information should not be\n+    /// in the MIR, please rely on local crate HIR or other side-channels.\n+    pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -3223,7 +3241,9 @@ BraceStructTypeFoldableImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n-        fields\n+        field_tys,\n+        variant_fields,\n+        __local_debuginfo_codegen_only_do_not_use,\n     }\n }\n \n@@ -3598,6 +3618,15 @@ impl<'tcx> TypeFoldable<'tcx> for Field {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {"}, {"sha": "d3fa5e84b6ad1fde4e98cd251752e372587b1cf2", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -177,11 +177,13 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::Discriminant(ref place) => {\n                 let ty = place.ty(local_decls, tcx).ty;\n-                if let ty::Adt(adt_def, _) = ty.sty {\n-                    adt_def.repr.discr_type().to_ty(tcx)\n-                } else {\n-                    // This can only be `0`, for now, so `u8` will suffice.\n-                    tcx.types.u8\n+                match ty.sty {\n+                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n+                    ty::Generator(_, substs, _) => substs.discr_ty(tcx),\n+                    _ => {\n+                        // This can only be `0`, for now, so `u8` will suffice.\n+                        tcx.types.u8\n+                    }\n                 }\n             }\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),"}, {"sha": "21e4d8b07a19ffecde760842a66591609b28ea0a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -604,12 +604,63 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 tcx.intern_layout(unit)\n             }\n \n-            // Tuples, generators and closures.\n             ty::Generator(def_id, ref substs, _) => {\n-                let tys = substs.field_tys(def_id, tcx);\n-                univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                // FIXME(tmandry): For fields that are repeated in multiple\n+                // variants in the GeneratorLayout, we need code to ensure that\n+                // the offset of these fields never change. Right now this is\n+                // not an issue since every variant has every field, but once we\n+                // optimize this we have to be more careful.\n+\n+                let discr_index = substs.prefix_tys(def_id, tcx).count();\n+                let prefix_tys = substs.prefix_tys(def_id, tcx)\n+                    .chain(iter::once(substs.discr_ty(tcx)));\n+                let prefix = univariant_uninterned(\n+                    &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSized)?\n+                    StructKind::AlwaysSized)?;\n+\n+                let mut size = prefix.size;\n+                let mut align = prefix.align;\n+                let variants_tys = substs.state_tys(def_id, tcx);\n+                let variants = variants_tys.enumerate().map(|(i, variant_tys)| {\n+                    let mut variant = univariant_uninterned(\n+                        &variant_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                        &ReprOptions::default(),\n+                        StructKind::Prefixed(prefix.size, prefix.align.abi))?;\n+\n+                    variant.variants = Variants::Single { index: VariantIdx::new(i) };\n+\n+                    size = size.max(variant.size);\n+                    align = align.max(variant.align);\n+\n+                    Ok(variant)\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+                let abi = if prefix.abi.is_uninhabited() ||\n+                             variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                    Abi::Uninhabited\n+                } else {\n+                    Abi::Aggregate { sized: true }\n+                };\n+                let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n+                    Abi::Scalar(s) => s.clone(),\n+                    _ => bug!(),\n+                };\n+\n+                let layout = tcx.intern_layout(LayoutDetails {\n+                    variants: Variants::Multiple {\n+                        discr,\n+                        discr_kind: DiscriminantKind::Tag,\n+                        discr_index,\n+                        variants,\n+                    },\n+                    fields: prefix.fields,\n+                    abi,\n+                    size,\n+                    align,\n+                });\n+                debug!(\"generator layout: {:#?}\", layout);\n+                layout\n             }\n \n             ty::Closure(def_id, ref substs) => {\n@@ -1647,6 +1698,14 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n \n     fn field(this: TyLayout<'tcx>, cx: &C, i: usize) -> C::TyLayout {\n         let tcx = cx.tcx();\n+        let discr_layout = |discr: &Scalar| -> C::TyLayout {\n+            let layout = LayoutDetails::scalar(cx, discr.clone());\n+            MaybeResult::from_ok(TyLayout {\n+                details: tcx.intern_layout(layout),\n+                ty: discr.value.to_ty(tcx)\n+            })\n+        };\n+\n         cx.layout_of(match this.ty.sty {\n             ty::Bool |\n             ty::Char |\n@@ -1721,7 +1780,19 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n-                substs.field_tys(def_id, tcx).nth(i).unwrap()\n+                match this.variants {\n+                    Variants::Single { index } => {\n+                        substs.state_tys(def_id, tcx)\n+                            .nth(index.as_usize()).unwrap()\n+                            .nth(i).unwrap()\n+                    }\n+                    Variants::Multiple { ref discr, discr_index, .. } => {\n+                        if i == discr_index {\n+                            return discr_layout(discr);\n+                        }\n+                        substs.prefix_tys(def_id, tcx).nth(i).unwrap()\n+                    }\n+                }\n             }\n \n             ty::Tuple(tys) => tys[i].expect_ty(),\n@@ -1741,11 +1812,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     // Discriminant field for enums (where applicable).\n                     Variants::Multiple { ref discr, .. } => {\n                         assert_eq!(i, 0);\n-                        let layout = LayoutDetails::scalar(cx, discr.clone());\n-                        return MaybeResult::from_ok(TyLayout {\n-                            details: tcx.intern_layout(layout),\n-                            ty: discr.value.to_ty(tcx)\n-                        });\n+                        return discr_layout(discr);\n                     }\n                 }\n             }"}, {"sha": "feedf5741f65b8a5a843d690cb9cc1b4ed228378", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -43,6 +43,7 @@ use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n use std::{mem, ptr};\n+use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n@@ -2416,11 +2417,17 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n+    #[inline]\n+    pub fn variant_range(&self) -> Range<VariantIdx> {\n+        (VariantIdx::new(0)..VariantIdx::new(self.variants.len()))\n+    }\n+\n     /// Computes the discriminant value used by a specific variant.\n     /// Unlike `discriminants`, this is (amortized) constant-time,\n     /// only doing at most one query for evaluating an explicit\n     /// discriminant (the last one before the requested variant),\n     /// assuming there are no constant-evaluation errors there.\n+    #[inline]\n     pub fn discriminant_for_variant(&self,\n                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                     variant_index: VariantIdx)"}, {"sha": "cca40c379fc110e99f8d54a5a36b780644adf33d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 115, "deletions": 30, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -9,15 +9,17 @@ use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n-use crate::ty::{self, AdtDef, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n+use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, Pointer};\n \n use smallvec::SmallVec;\n-use std::iter;\n+use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n+use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n@@ -298,14 +300,10 @@ static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n ///\n /// ## Generators\n ///\n-/// Perhaps surprisingly, `ClosureSubsts` are also used for\n-/// generators. In that case, what is written above is only half-true\n-/// -- the set of type parameters is similar, but the role of CK and\n-/// CS are different. CK represents the \"yield type\" and CS\n-/// represents the \"return type\" of the generator.\n-///\n-/// It'd be nice to split this struct into ClosureSubsts and\n-/// GeneratorSubsts, I believe. -nmatsakis\n+/// Generators are handled similarly in `GeneratorSubsts`.  The set of\n+/// type parameters is similar, but the role of CK and CS are\n+/// different. CK represents the \"yield type\" and CS represents the\n+/// \"return type\" of the generator.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureSubsts<'tcx> {\n@@ -391,6 +389,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n+/// Similar to `ClosureSubsts`; see the above documentation for more.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n          RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorSubsts<'tcx> {\n@@ -470,33 +469,91 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n+    /// Generator have not been resumed yet\n+    pub const UNRESUMED: usize = 0;\n+    /// Generator has returned / is completed\n+    pub const RETURNED: usize = 1;\n+    /// Generator has been poisoned\n+    pub const POISONED: usize = 2;\n+\n+    const UNRESUMED_NAME: &'static str = \"Unresumed\";\n+    const RETURNED_NAME: &'static str = \"Returned\";\n+    const POISONED_NAME: &'static str = \"Panicked\";\n+\n+    /// The valid variant indices of this Generator.\n+    #[inline]\n+    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Range<VariantIdx> {\n+        // FIXME requires optimized MIR\n+        let num_variants = tcx.generator_layout(def_id).variant_fields.len();\n+        (VariantIdx::new(0)..VariantIdx::new(num_variants))\n+    }\n+\n+    /// The discriminant for the given variant. Panics if the variant_index is\n+    /// out of range.\n+    #[inline]\n+    pub fn discriminant_for_variant(\n+        &self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>, variant_index: VariantIdx\n+    ) -> Discr<'tcx> {\n+        // Generators don't support explicit discriminant values, so they are\n+        // the same as the variant index.\n+        assert!(self.variant_range(def_id, tcx).contains(&variant_index));\n+        Discr { val: variant_index.as_usize() as u128, ty: self.discr_ty(tcx) }\n+    }\n+\n+    /// The set of all discriminants for the Generator, enumerated with their\n+    /// variant indices.\n+    #[inline]\n+    pub fn discriminants(\n+        &'a self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+        self.variant_range(def_id, tcx).map(move |index| {\n+            (index, Discr { val: index.as_usize() as u128, ty: self.discr_ty(tcx) })\n+        })\n+    }\n+\n+    /// Calls `f` with a reference to the name of the enumerator for the given\n+    /// variant `v`.\n+    #[inline]\n+    pub fn variant_name(&self, v: VariantIdx) -> Cow<'static, str> {\n+        match v.as_usize() {\n+            Self::UNRESUMED => Cow::from(Self::UNRESUMED_NAME),\n+            Self::RETURNED => Cow::from(Self::RETURNED_NAME),\n+            Self::POISONED => Cow::from(Self::POISONED_NAME),\n+            _ => Cow::from(format!(\"Suspend{}\", v.as_usize() - 3))\n+        }\n+    }\n+\n+    /// The type of the state discriminant used in the generator type.\n+    #[inline]\n+    pub fn discr_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.types.u32\n+    }\n+\n     /// This returns the types of the MIR locals which had to be stored across suspension points.\n     /// It is calculated in rustc_mir::transform::generator::StateTransform.\n     /// All the types here must be in the tuple in GeneratorInterior.\n-    pub fn state_tys(\n-        self,\n-        def_id: DefId,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a {\n-        let state = tcx.generator_layout(def_id).fields.iter();\n-        state.map(move |d| d.ty.subst(tcx, self.substs))\n-    }\n-\n-    /// This is the types of the fields of a generate which\n-    /// is available before the generator transformation.\n-    /// It includes the upvars and the state discriminant which is u32.\n-    pub fn pre_transforms_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n+    ///\n+    /// The locals are grouped by their variant number. Note that some locals may\n+    /// be repeated in multiple variants.\n+    #[inline]\n+    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a>\n     {\n-        self.upvar_tys(def_id, tcx).chain(iter::once(tcx.types.u32))\n+        let layout = tcx.generator_layout(def_id);\n+        layout.variant_fields.iter().map(move |variant| {\n+            variant.iter().map(move |field| {\n+                layout.field_tys[*field].subst(tcx, self.substs)\n+            })\n+        })\n     }\n \n-    /// This is the types of all the fields stored in a generator.\n-    /// It includes the upvars, state types and the state discriminant which is u32.\n-    pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a\n+    /// This is the types of the fields of a generator which are not stored in a\n+    /// variant.\n+    #[inline]\n+    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'a\n     {\n-        self.pre_transforms_tys(def_id, tcx).chain(self.state_tys(def_id, tcx))\n+        self.upvar_tys(def_id, tcx)\n     }\n }\n \n@@ -1996,6 +2053,34 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// If the type contains variants, returns the valid range of variant indices.\n+    /// FIXME This requires the optimized MIR in the case of generators.\n+    #[inline]\n+    pub fn variant_range(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n+        match self.sty {\n+            TyKind::Adt(adt, _) => Some(adt.variant_range()),\n+            TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If the type contains variants, returns the variant for `variant_index`.\n+    /// Panics if `variant_index` is out of range.\n+    /// FIXME This requires the optimized MIR in the case of generators.\n+    #[inline]\n+    pub fn discriminant_for_variant(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        variant_index: VariantIdx\n+    ) -> Option<Discr<'tcx>> {\n+        match self.sty {\n+            TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n+            TyKind::Generator(def_id, substs, _) =>\n+                Some(substs.discriminant_for_variant(def_id, tcx, variant_index)),\n+            _ => None,\n+        }\n+    }\n+\n     /// Push onto `out` the regions directly referenced from this type (but not\n     /// types reachable from this type via `walk_tys`). This ignores late-bound\n     /// regions binders."}, {"sha": "9bdce37b8baec1f09bc83124137d186727a66910", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 192, "deletions": 91, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -23,12 +23,13 @@ use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n use rustc::mir::Field;\n+use rustc::mir::GeneratorLayout;\n use rustc::mir::interpret::truncate;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf,\n-                        PrimitiveExt, Size, TyLayout};\n+                        PrimitiveExt, Size, TyLayout, VariantIdx};\n use rustc::ty::subst::UnpackedKind;\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n@@ -691,14 +692,15 @@ pub fn type_metadata(\n                                    usage_site_span).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n-            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n+            let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   &upvar_tys,\n-                                   unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+            prepare_enum_metadata(cx,\n+                                  t,\n+                                  def_id,\n+                                  unique_type_id,\n+                                  usage_site_span,\n+                                  upvar_tys).finalize(cx)\n         }\n         ty::Adt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n@@ -718,7 +720,8 @@ pub fn type_metadata(\n                                       t,\n                                       def.did,\n                                       unique_type_id,\n-                                      usage_site_span).finalize(cx)\n+                                      usage_site_span,\n+                                      vec![]).finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n@@ -1000,6 +1003,31 @@ struct MemberDescription<'ll> {\n     discriminant: Option<u64>,\n }\n \n+impl<'ll> MemberDescription<'ll> {\n+    fn into_metadata(self,\n+                     cx: &CodegenCx<'ll, '_>,\n+                     composite_type_metadata: &'ll DIScope) -> &'ll DIType {\n+        let member_name = CString::new(self.name).unwrap();\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateVariantMemberType(\n+                DIB(cx),\n+                composite_type_metadata,\n+                member_name.as_ptr(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                self.size.bits(),\n+                self.align.bits() as u32,\n+                self.offset.bits(),\n+                match self.discriminant {\n+                    None => None,\n+                    Some(value) => Some(cx.const_u64(value)),\n+                },\n+                self.flags,\n+                self.type_metadata)\n+        }\n+    }\n+}\n+\n // A factory for MemberDescriptions. It produces a list of member descriptions\n // for some record-like type. MemberDescriptionFactories are used to defer the\n // creation of type member descriptions in order to break cycles arising from\n@@ -1266,7 +1294,16 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n-        let adt = &self.enum_type.ty_adt_def().unwrap();\n+        let variant_info_for = |index: VariantIdx| {\n+            match &self.enum_type.sty {\n+                ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n+                ty::Generator(def_id, substs, _) => {\n+                    let generator_layout = cx.tcx.generator_layout(*def_id);\n+                    VariantInfo::Generator(*substs, generator_layout, index)\n+                }\n+                _ => bug!(),\n+            }\n+        };\n \n         // This will always find the metadata in the type map.\n         let fallback = use_enum_fallback(cx);\n@@ -1277,12 +1314,18 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         };\n \n         match self.layout.variants {\n-            layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n             layout::Variants::Single { index } => {\n+                if let ty::Adt(adt, _) = &self.enum_type.sty {\n+                    if adt.variants.is_empty() {\n+                        return vec![];\n+                    }\n+                }\n+\n+                let variant_info = variant_info_for(index);\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.layout,\n-                                          &adt.variants[index],\n+                                          variant_info,\n                                           NoDiscriminant,\n                                           self_metadata,\n                                           self.span);\n@@ -1299,7 +1342,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[index].ident.as_str().to_string()\n+                            variant_info.variant_name()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n@@ -1327,10 +1370,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 };\n                 variants.iter_enumerated().map(|(i, _)| {\n                     let variant = self.layout.for_variant(cx, i);\n+                    let variant_info = variant_info_for(i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n-                                              &adt.variants[i],\n+                                              variant_info,\n                                               discriminant_info,\n                                               self_metadata,\n                                               self.span);\n@@ -1342,20 +1386,21 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                                   self.enum_type,\n                                                   variant_type_metadata,\n                                                   member_descriptions);\n+\n                     MemberDescription {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[i].ident.as_str().to_string()\n+                            variant_info.variant_name()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align.abi,\n                         flags: DIFlags::FlagZero,\n-                        discriminant: Some(self.layout.ty.ty_adt_def().unwrap()\n-                                           .discriminant_for_variant(cx.tcx, i)\n-                                           .val as u64),\n+                        discriminant: Some(\n+                            self.layout.ty.discriminant_for_variant(cx.tcx, i).unwrap().val as u64\n+                        ),\n                     }\n                 }).collect()\n             }\n@@ -1375,7 +1420,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n-                                              &adt.variants[dataful_variant],\n+                                              variant_info_for(dataful_variant),\n                                               OptimizedDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -1415,7 +1460,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                        self.layout,\n                                        self.layout.fields.offset(discr_index),\n                                        self.layout.field(cx, discr_index).size);\n-                    name.push_str(&adt.variants[*niche_variants.start()].ident.as_str());\n+                    variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n+                        name.push_str(variant_name);\n+                    });\n \n                     // Create the (singleton) list of descriptions of union members.\n                     vec![\n@@ -1432,10 +1479,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 } else {\n                     variants.iter_enumerated().map(|(i, _)| {\n                         let variant = self.layout.for_variant(cx, i);\n+                        let variant_info = variant_info_for(i);\n                         let (variant_type_metadata, member_desc_factory) =\n                             describe_enum_variant(cx,\n                                                   variant,\n-                                                  &adt.variants[i],\n+                                                  variant_info,\n                                                   OptimizedDiscriminant,\n                                                   self_metadata,\n                                                   self.span);\n@@ -1463,7 +1511,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         };\n \n                         MemberDescription {\n-                            name: adt.variants[i].ident.as_str().to_string(),\n+                            name: variant_info.variant_name(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n@@ -1521,39 +1569,74 @@ enum EnumDiscriminantInfo<'ll> {\n     NoDiscriminant\n }\n \n+#[derive(Copy, Clone)]\n+enum VariantInfo<'tcx> {\n+    Adt(&'tcx ty::VariantDef),\n+    Generator(ty::GeneratorSubsts<'tcx>, &'tcx GeneratorLayout<'tcx>, VariantIdx),\n+}\n+\n+impl<'tcx> VariantInfo<'tcx> {\n+    fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n+        match self {\n+            VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n+            VariantInfo::Generator(substs, _, variant_index) =>\n+                f(&substs.variant_name(*variant_index)),\n+        }\n+    }\n+\n+    fn variant_name(&self) -> String {\n+        match self {\n+            VariantInfo::Adt(variant) => variant.ident.to_string(),\n+            VariantInfo::Generator(_, _, variant_index) => {\n+                // Since GDB currently prints out the raw discriminant along\n+                // with every variant, make each variant name be just the value\n+                // of the discriminant. The struct name for the variant includes\n+                // the actual variant description.\n+                format!(\"{}\", variant_index.as_usize()).to_string()\n+            }\n+        }\n+    }\n+\n+    fn field_name(&self, i: usize) -> String {\n+        let field_name = match self {\n+            VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn =>\n+                Some(variant.fields[i].ident.to_string()),\n+            VariantInfo::Generator(_, generator_layout, variant_index) => {\n+                let field = generator_layout.variant_fields[*variant_index][i.into()];\n+                let decl = &generator_layout.__local_debuginfo_codegen_only_do_not_use[field];\n+                decl.name.map(|name| name.to_string())\n+            }\n+            _ => None,\n+        };\n+        field_name.unwrap_or_else(|| format!(\"__{}\", i))\n+    }\n+}\n+\n // Returns a tuple of (1) type_metadata_stub of the variant, (2) a\n // MemberDescriptionFactory for producing the descriptions of the\n // fields of the variant. This is a rudimentary version of a full\n // RecursiveTypeDescription.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n-    variant: &'tcx ty::VariantDef,\n+    variant: VariantInfo<'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n-    let variant_name = variant.ident.as_str();\n-    let unique_type_id = debug_context(cx).type_map\n-                                          .borrow_mut()\n-                                          .get_unique_type_id_of_enum_variant(\n-                                              cx,\n-                                              layout.ty,\n-                                              &variant_name);\n-\n-    let metadata_stub = create_struct_stub(cx,\n-                                           layout.ty,\n-                                           &variant_name,\n-                                           unique_type_id,\n-                                           Some(containing_scope));\n-\n-    let arg_name = |i: usize| {\n-        if variant.ctor_kind == CtorKind::Fn {\n-            format!(\"__{}\", i)\n-        } else {\n-            variant.fields[i].ident.to_string()\n-        }\n-    };\n+    let metadata_stub = variant.map_struct_name(|variant_name| {\n+        let unique_type_id = debug_context(cx).type_map\n+                                              .borrow_mut()\n+                                              .get_unique_type_id_of_enum_variant(\n+                                                  cx,\n+                                                  layout.ty,\n+                                                  &variant_name);\n+        create_struct_stub(cx,\n+                           layout.ty,\n+                           &variant_name,\n+                           unique_type_id,\n+                           Some(containing_scope))\n+    });\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let (offsets, args) = if use_enum_fallback(cx) {\n@@ -1575,7 +1658,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             })).collect(),\n             discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-                (arg_name(i), layout.field(cx, i).ty)\n+                (variant.field_name(i), layout.field(cx, i).ty)\n             })).collect()\n         )\n     } else {\n@@ -1584,7 +1667,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             }).collect(),\n             (0..layout.fields.count()).map(|i| {\n-                (arg_name(i), layout.field(cx, i).ty)\n+                (variant.field_name(i), layout.field(cx, i).ty)\n             }).collect()\n         )\n     };\n@@ -1611,6 +1694,7 @@ fn prepare_enum_metadata(\n     enum_def_id: DefId,\n     unique_type_id: UniqueTypeId,\n     span: Span,\n+    outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n \n@@ -1624,20 +1708,36 @@ fn prepare_enum_metadata(\n     let file_metadata = unknown_file_metadata(cx);\n \n     let discriminant_type_metadata = |discr: layout::Primitive| {\n-        let def = enum_type.ty_adt_def().unwrap();\n-        let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n-            .zip(&def.variants)\n-            .map(|((_, discr), v)| {\n-                let name = SmallCStr::new(&v.ident.as_str());\n-                unsafe {\n-                    Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name.as_ptr(),\n-                        // FIXME: what if enumeration has i128 discriminant?\n-                        discr.val as u64))\n-                }\n-            })\n-            .collect();\n+        let enumerators_metadata: Vec<_> = match enum_type.sty {\n+            ty::Adt(def, _) => def\n+                .discriminants(cx.tcx)\n+                .zip(&def.variants)\n+                .map(|((_, discr), v)| {\n+                    let name = SmallCStr::new(&v.ident.as_str());\n+                    unsafe {\n+                        Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                            DIB(cx),\n+                            name.as_ptr(),\n+                            // FIXME: what if enumeration has i128 discriminant?\n+                            discr.val as u64))\n+                    }\n+                })\n+                .collect(),\n+            ty::Generator(_, substs, _) => substs\n+                .variant_range(enum_def_id, cx.tcx)\n+                .map(|variant_index| {\n+                    let name = SmallCStr::new(&substs.variant_name(variant_index));\n+                    unsafe {\n+                        Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                            DIB(cx),\n+                            name.as_ptr(),\n+                            // FIXME: what if enumeration has i128 discriminant?\n+                            variant_index.as_usize() as u64))\n+                    }\n+                })\n+                .collect(),\n+            _ => bug!(),\n+        };\n \n         let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n@@ -1650,14 +1750,18 @@ fn prepare_enum_metadata(\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n-                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id).as_str();\n \n-                let name = SmallCStr::new(&discriminant_name);\n+                let discriminant_name = match enum_type.sty {\n+                    ty::Adt(..) => SmallCStr::new(&cx.tcx.item_name(enum_def_id).as_str()),\n+                    ty::Generator(..) => SmallCStr::new(&enum_name),\n+                    _ => bug!(),\n+                };\n+\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n                         containing_scope,\n-                        name.as_ptr(),\n+                        discriminant_name.as_ptr(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         discriminant_size.bits(),\n@@ -1738,6 +1842,11 @@ fn prepare_enum_metadata(\n         );\n     }\n \n+    let discriminator_name = match &enum_type.sty {\n+        ty::Generator(..) => Some(SmallCStr::new(&\"__state\")),\n+        _ => None,\n+    };\n+    let discriminator_name = discriminator_name.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut());\n     let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n         layout::Variants::Single { .. } => None,\n@@ -1764,7 +1873,7 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    ptr::null_mut(),\n+                    discriminator_name,\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1789,7 +1898,7 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    ptr::null_mut(),\n+                    discriminator_name,\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1801,6 +1910,22 @@ fn prepare_enum_metadata(\n         },\n     };\n \n+    let mut outer_fields = match layout.variants {\n+        layout::Variants::Single { .. } => vec![],\n+        layout::Variants::Multiple { .. } => {\n+            let tuple_mdf = TupleMemberDescriptionFactory {\n+                ty: enum_type,\n+                component_types: outer_field_tys,\n+                span\n+            };\n+            tuple_mdf\n+                .create_member_descriptions(cx)\n+                .into_iter()\n+                .map(|desc| Some(desc.into_metadata(cx, containing_scope)))\n+                .collect()\n+        }\n+    };\n+\n     let variant_part_unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map\n             .borrow_mut()\n@@ -1821,9 +1946,10 @@ fn prepare_enum_metadata(\n             empty_array,\n             variant_part_unique_type_id_str.as_ptr())\n     };\n+    outer_fields.push(Some(variant_part));\n \n     // The variant part must be wrapped in a struct according to DWARF.\n-    let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n+    let type_array = create_DIArray(DIB(cx), &outer_fields);\n     let struct_wrapper = unsafe {\n         llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n@@ -1855,12 +1981,6 @@ fn prepare_enum_metadata(\n             span,\n         }),\n     );\n-\n-    fn get_enum_discriminant_name(cx: &CodegenCx<'_, '_>,\n-                                  def_id: DefId)\n-                                  -> InternedString {\n-        cx.tcx.item_name(def_id)\n-    }\n }\n \n /// Creates debug information for a composite type, that is, anything that\n@@ -1918,26 +2038,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n \n     let member_metadata: Vec<_> = member_descriptions\n         .into_iter()\n-        .map(|member_description| {\n-            let member_name = CString::new(member_description.name).unwrap();\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateVariantMemberType(\n-                    DIB(cx),\n-                    composite_type_metadata,\n-                    member_name.as_ptr(),\n-                    unknown_file_metadata(cx),\n-                    UNKNOWN_LINE_NUMBER,\n-                    member_description.size.bits(),\n-                    member_description.align.bits() as u32,\n-                    member_description.offset.bits(),\n-                    match member_description.discriminant {\n-                        None => None,\n-                        Some(value) => Some(cx.const_u64(value)),\n-                    },\n-                    member_description.flags,\n-                    member_description.type_metadata))\n-            }\n-        })\n+        .map(|desc| Some(desc.into_metadata(cx, composite_type_metadata)))\n         .collect();\n \n     let type_params = compute_type_parameters(cx, composite_type);"}, {"sha": "cbcc457fda9a29ffebea5170c433e9c0f3b076e4", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -63,6 +63,11 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n+            if let (&ty::Generator(_, substs, _), &layout::Variants::Single { index })\n+                 = (&layout.ty.sty, &layout.variants)\n+            {\n+                write!(&mut name, \"::{}\", substs.variant_name(index)).unwrap();\n+            }\n             Some(name)\n         }\n         _ => None"}, {"sha": "fcf099235aa14f2ac4c00316de6fe018b7ca0533", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -4,6 +4,7 @@ use rustc::mir::{self, Mir};\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n+use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n@@ -648,7 +649,9 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     .iter()\n                     .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (upvar, ty))| (i, upvar.debug_name, upvar.by_ref, ty));\n+                    .map(|(i, (upvar, ty))| {\n+                        (None, i, upvar.debug_name, upvar.by_ref, ty, scope, DUMMY_SP)\n+                    });\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n                     let (def_id, gen_substs) = match closure_layout.ty.sty {\n@@ -657,22 +660,48 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     };\n                     let state_tys = gen_substs.state_tys(def_id, tcx);\n \n-                    let upvar_count = upvar_debuginfo.len();\n-                    generator_layout.fields\n-                        .iter()\n+                    generator_layout.variant_fields.iter()\n                         .zip(state_tys)\n                         .enumerate()\n-                        .filter_map(move |(i, (decl, ty))| {\n-                            let ty = fx.monomorphize(&ty);\n-                            decl.name.map(|name| (i + upvar_count + 1, name, false, ty))\n+                        .flat_map(move |(variant_idx, (fields, tys))| {\n+                            let variant_idx = Some(VariantIdx::from(variant_idx));\n+                            fields.iter()\n+                                .zip(tys)\n+                                .enumerate()\n+                                .filter_map(move |(i, (field, ty))| {\n+                                    let decl = &generator_layout.\n+                                        __local_debuginfo_codegen_only_do_not_use[*field];\n+                                    if let Some(name) = decl.name {\n+                                        let ty = fx.monomorphize(&ty);\n+                                        let (var_scope, var_span) = fx.debug_loc(mir::SourceInfo {\n+                                            span: decl.source_info.span,\n+                                            scope: decl.visibility_scope,\n+                                        });\n+                                        let var_scope = var_scope.unwrap_or(scope);\n+                                        Some((variant_idx, i, name, false, ty, var_scope, var_span))\n+                                    } else {\n+                                        None\n+                                    }\n+                            })\n                         })\n                 }).into_iter().flatten();\n \n                 upvars.chain(generator_fields)\n             };\n \n-            for (field, name, by_ref, ty) in extra_locals {\n-                let byte_offset_of_var_in_env = closure_layout.fields.offset(field).bytes();\n+            for (variant_idx, field, name, by_ref, ty, var_scope, var_span) in extra_locals {\n+                let fields = match variant_idx {\n+                    Some(variant_idx) => {\n+                        match &closure_layout.variants {\n+                            Variants::Multiple { variants, .. } => {\n+                                &variants[variant_idx].fields\n+                            },\n+                            _ => bug!(\"variant index on univariant layout\"),\n+                        }\n+                    }\n+                    None => &closure_layout.fields,\n+                };\n+                let byte_offset_of_var_in_env = fields.offset(field).bytes();\n \n                 let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n \n@@ -694,10 +723,10 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     &fx.debug_context,\n                     name,\n                     ty,\n-                    scope,\n+                    var_scope,\n                     variable_access,\n                     VariableKind::LocalVariable,\n-                    DUMMY_SP\n+                    var_span\n                 );\n             }\n         });"}, {"sha": "670b6c472698d23a16e0acaf05186eb04d9c4c93", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -218,9 +218,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n         let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                let discr_val = self.layout.ty.ty_adt_def().map_or(\n-                    index.as_u32() as u128,\n-                    |def| def.discriminant_for_variant(bx.cx().tcx(), index).val);\n+                let discr_val = self.layout.ty.discriminant_for_variant(bx.cx().tcx(), index)\n+                    .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n@@ -296,9 +295,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 ..\n             } => {\n                 let ptr = self.project_field(bx, discr_index);\n-                let to = self.layout.ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(bx.tcx(), variant_index)\n-                    .val;\n+                let to =\n+                    self.layout.ty.discriminant_for_variant(bx.tcx(), variant_index).unwrap().val;\n                 bx.store(\n                     bx.cx().const_uint_big(bx.cx().backend_type(ptr.layout), to),\n                     ptr.llval,"}, {"sha": "8d3e64c1aa6c72afaed12d24f4a2a517b56a082f", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -271,13 +271,12 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let ll_t_in = bx.cx().immediate_backend_type(operand.layout);\n                         match operand.layout.variants {\n                             layout::Variants::Single { index } => {\n-                                if let Some(def) = operand.layout.ty.ty_adt_def() {\n-                                    let discr_val = def\n-                                        .discriminant_for_variant(bx.cx().tcx(), index)\n-                                        .val;\n-                                    let discr = bx.cx().const_uint_big(ll_t_out, discr_val);\n+                                if let Some(discr) =\n+                                    operand.layout.ty.discriminant_for_variant(bx.tcx(), index)\n+                                {\n+                                    let discr_val = bx.cx().const_uint_big(ll_t_out, discr.val);\n                                     return (bx, OperandRef {\n-                                        val: OperandValue::Immediate(discr),\n+                                        val: OperandValue::Immediate(discr_val),\n                                         layout: cast,\n                                     });\n                                 }"}, {"sha": "1d62b9f764a1951269dad0da5ca953f4406e431e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -684,6 +684,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n+                // We do not need to handle generators here, because this runs\n+                // before the generator transform stage.\n                 _ => {\n                     let ty = if let Some(name) = maybe_name {\n                         span_mirbug_and_err!(\n@@ -745,11 +747,26 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy { ty, variant_index: Some(variant_index) } => {\n-                match ty.sty {\n-                    ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n-                    _ => bug!(\"can't have downcast of non-adt type\"),\n+            PlaceTy { ty, variant_index: Some(variant_index) } => match ty.sty {\n+                ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                ty::Generator(def_id, substs, _) => {\n+                    let mut variants = substs.state_tys(def_id, tcx);\n+                    let mut variant = match variants.nth(variant_index.into()) {\n+                        Some(v) => v,\n+                        None => {\n+                            bug!(\"variant_index of generator out of range: {:?}/{:?}\",\n+                                 variant_index,\n+                                 substs.state_tys(def_id, tcx).count())\n+                        }\n+                    };\n+                    return match variant.nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: variant.count(),\n+                        }),\n+                    }\n                 }\n+                _ => bug!(\"can't have downcast of non-adt non-generator type\"),\n             }\n             PlaceTy { ty, variant_index: None } => match ty.sty {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n@@ -763,19 +780,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     }\n                 }\n                 ty::Generator(def_id, substs, _) => {\n-                    // Try pre-transform fields first (upvars and current state)\n-                    if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field.index()) {\n-                        return Ok(ty);\n-                    }\n-\n-                    // Then try `field_tys` which contains all the fields, but it\n-                    // requires the final optimized MIR.\n-                    return match substs.field_tys(def_id, tcx).nth(field.index()) {\n+                    // Only prefix fields (upvars and current state) are\n+                    // accessible without a variant index.\n+                    return match substs.prefix_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count(),\n+                            field_count: substs.prefix_tys(def_id, tcx).count(),\n                         }),\n-                    };\n+                    }\n                 }\n                 ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n@@ -1908,18 +1920,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             AggregateKind::Generator(def_id, substs, _) => {\n-                // Try pre-transform fields first (upvars and current state)\n-                if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field_index) {\n-                    Ok(ty)\n-                } else {\n-                    // Then try `field_tys` which contains all the fields, but it\n-                    // requires the final optimized MIR.\n-                    match substs.field_tys(def_id, tcx).nth(field_index) {\n-                        Some(ty) => Ok(ty),\n-                        None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count(),\n-                        }),\n-                    }\n+                // It doesn't make sense to look at a field beyond the prefix;\n+                // these require a variant index, and are not initialized in\n+                // aggregate rvalues.\n+                match substs.prefix_tys(def_id, tcx).nth(field_index) {\n+                    Some(ty) => Ok(ty),\n+                    None => Err(FieldAccessError::OutOfRange {\n+                        field_count: substs.prefix_tys(def_id, tcx).count(),\n+                    }),\n                 }\n             }\n             AggregateKind::Array(ty) => Ok(ty),"}, {"sha": "e745ee0f190ddb4a531679cfd0e7a8aae1d573f9", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 movability,\n             } => {\n                 // see (*) above\n-                let mut operands: Vec<_> = upvars\n+                let operands: Vec<_> = upvars\n                     .into_iter()\n                     .map(|upvar| {\n                         let upvar = this.hir.mirror(upvar);\n@@ -248,21 +248,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }).collect();\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n+                        // We implicitly set the discriminant to 0. See\n+                        // librustc_mir/transform/deaggregator.rs for details.\n                         let movability = movability.unwrap();\n-                        // Add the state operand since it follows the upvars in the generator\n-                        // struct. See librustc_mir/transform/generator.rs for more details.\n-                        operands.push(Operand::Constant(box Constant {\n-                            span: expr_span,\n-                            ty: this.hir.tcx().types.u32,\n-                            user_ty: None,\n-                            literal: this.hir.tcx().mk_const(\n-                                ty::Const::from_bits(\n-                                    this.hir.tcx(),\n-                                    0,\n-                                    ty::ParamEnv::empty().and(this.hir.tcx().types.u32),\n-                                ),\n-                            ),\n-                        }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n                     }\n                     UpvarSubsts::Closure(substs) => box AggregateKind::Closure(closure_id, substs),"}, {"sha": "58e474658ead5748000fd755df5b50deb2a9b5b9", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -54,14 +54,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 } else {\n                     match src.layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src.layout.ty.ty_adt_def() {\n+                            if let Some(discr) =\n+                                src.layout.ty.discriminant_for_variant(*self.tcx, index)\n+                            {\n                                 // Cast from a univariant enum\n                                 assert!(src.layout.is_zst());\n-                                let discr_val = def\n-                                    .discriminant_for_variant(*self.tcx, index)\n-                                    .val;\n                                 return self.write_scalar(\n-                                    Scalar::from_uint(discr_val, dest.layout.size),\n+                                    Scalar::from_uint(discr.val, dest.layout.size),\n                                     dest);\n                             }\n                         }"}, {"sha": "9c2b491925f47553c9b1a99c2a5da3ebe404ef8e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -567,9 +567,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n \n         let (discr_kind, discr_index) = match rval.layout.variants {\n             layout::Variants::Single { index } => {\n-                let discr_val = rval.layout.ty.ty_adt_def().map_or(\n+                let discr_val = rval.layout.ty.discriminant_for_variant(*self.tcx, index).map_or(\n                     index.as_u32() as u128,\n-                    |def| def.discriminant_for_variant(*self.tcx, index).val);\n+                    |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n             layout::Variants::Multiple { ref discr_kind, discr_index, .. } =>\n@@ -604,12 +604,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     bits_discr\n                 };\n                 // Make sure we catch invalid discriminants\n-                let index = rval.layout.ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .discriminants(self.tcx.tcx)\n-                    .find(|(_, var)| var.val == real_discr)\n-                    .ok_or_else(|| InterpError::InvalidDiscriminant(raw_discr.erase_tag()))?;\n+                let index = match &rval.layout.ty.sty {\n+                    ty::Adt(adt, _) => adt\n+                        .discriminants(self.tcx.tcx)\n+                        .find(|(_, var)| var.val == real_discr),\n+                    ty::Generator(def_id, substs, _) => substs\n+                        .discriminants(*def_id, self.tcx.tcx)\n+                        .find(|(_, var)| var.val == real_discr),\n+                    _ => bug!(\"tagged layout for non-adt non-generator\"),\n+                }.ok_or_else(|| InterpError::InvalidDiscriminant(raw_discr.erase_tag()))?;\n                 (real_discr, index.0)\n             },\n             layout::DiscriminantKind::Niche {"}, {"sha": "0cc480028161f170dac97c2741bccd8f52688faf", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -984,11 +984,9 @@ where\n                 discr_index,\n                 ..\n             } => {\n-                let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n-                assert!(variant_index.as_usize() < adt_def.variants.len());\n-                let discr_val = adt_def\n-                    .discriminant_for_variant(*self.tcx, variant_index)\n-                    .val;\n+                assert!(dest.layout.ty.variant_range(*self.tcx).unwrap().contains(&variant_index));\n+                let discr_val =\n+                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n \n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible"}, {"sha": "9215356daa484f405a299e73bda2a635c8e58276", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -1,5 +1,6 @@\n-use rustc::ty::TyCtxt;\n use rustc::mir::*;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::indexed_vec::Idx;\n use crate::transform::{MirPass, MirSource};\n \n@@ -55,6 +56,23 @@ impl MirPass for Deaggregator {\n                         }\n                         active_field_index\n                     }\n+                    AggregateKind::Generator(..) => {\n+                        // Right now we only support initializing generators to\n+                        // variant 0 (Unresumed).\n+                        let variant_index = VariantIdx::new(0);\n+                        set_discriminant = Some(Statement {\n+                            kind: StatementKind::SetDiscriminant {\n+                                place: lhs.clone(),\n+                                variant_index,\n+                            },\n+                            source_info,\n+                        });\n+\n+                        // Operands are upvars stored on the base place, so no\n+                        // downcast is necessary.\n+\n+                        None\n+                    }\n                     _ => None\n                 };\n "}, {"sha": "d2da1e6e3ac9d131fd573ad21b23aed9a9a452eb", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 84, "deletions": 60, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -54,13 +54,14 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n+use rustc::ty::GeneratorSubsts;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::SubstsRef;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::bit_set::BitSet;\n use std::borrow::Cow;\n-use std::iter::once;\n+use std::iter;\n use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n@@ -145,14 +146,14 @@ fn self_arg() -> Local {\n }\n \n /// Generator have not been resumed yet\n-const UNRESUMED: u32 = 0;\n+const UNRESUMED: usize = GeneratorSubsts::UNRESUMED;\n /// Generator has returned / is completed\n-const RETURNED: u32 = 1;\n+const RETURNED: usize = GeneratorSubsts::RETURNED;\n /// Generator has been poisoned\n-const POISONED: u32 = 2;\n+const POISONED: usize = GeneratorSubsts::POISONED;\n \n struct SuspensionPoint {\n-    state: u32,\n+    state: usize,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n     storage_liveness: liveness::LiveVarSet,\n@@ -163,12 +164,12 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: SubstsRef<'tcx>,\n \n-    // The index of the generator state in the generator struct\n-    state_field: usize,\n+    // The type of the discriminant in the generator struct\n+    discr_ty: Ty<'tcx>,\n \n     // Mapping from Local to (type of local, generator struct index)\n     // FIXME(eddyb) This should use `IndexVec<Local, Option<_>>`.\n-    remap: FxHashMap<Local, (Ty<'tcx>, usize)>,\n+    remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n     // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n@@ -189,33 +190,38 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n \n     // Create a Place referencing a generator struct field\n-    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n-        let base = Place::Base(PlaceBase::Local(self_arg()));\n+    fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let base = self_place.downcast_unnamed(variant_index);\n         let field = Projection {\n             base: base,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n         };\n         Place::Projection(Box::new(field))\n     }\n \n-    // Create a statement which changes the generator state\n-    fn set_state(&self, state_disc: u32, source_info: SourceInfo) -> Statement<'tcx> {\n-        let state = self.make_field(self.state_field, self.tcx.types.u32);\n-        let val = Operand::Constant(box Constant {\n-            span: source_info.span,\n-            ty: self.tcx.types.u32,\n-            user_ty: None,\n-            literal: self.tcx.mk_const(ty::Const::from_bits(\n-                self.tcx,\n-                state_disc.into(),\n-                ty::ParamEnv::empty().and(self.tcx.types.u32)\n-            )),\n-        });\n+    // Create a statement which changes the discriminant\n+    fn set_discr(&self, state_disc: VariantIdx, source_info: SourceInfo) -> Statement<'tcx> {\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n         Statement {\n             source_info,\n-            kind: StatementKind::Assign(state, box Rvalue::Use(val)),\n+            kind: StatementKind::SetDiscriminant { place: self_place, variant_index: state_disc },\n         }\n     }\n+\n+    // Create a statement which reads the discriminant into a temporary\n+    fn get_discr(&self, mir: &mut Mir<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n+        let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, mir.span);\n+        let temp = Place::Base(PlaceBase::Local(Local::new(mir.local_decls.len())));\n+        mir.local_decls.push(temp_decl);\n+\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let assign = Statement {\n+            source_info: source_info(mir),\n+            kind: StatementKind::Assign(temp.clone(), box Rvalue::Discriminant(self_place)),\n+        };\n+        (assign, temp)\n+    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n@@ -232,8 +238,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     location: Location) {\n         if let Place::Base(PlaceBase::Local(l)) = *place {\n             // Replace an Local in the remap with a generator struct access\n-            if let Some(&(ty, idx)) = self.remap.get(&l) {\n-                *place = self.make_field(idx, ty);\n+            if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n+                *place = self.make_field(variant_index, idx, ty);\n             }\n         } else {\n             self.super_place(place, context, location);\n@@ -274,7 +280,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                                             box self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n-                let state = 3 + self.suspension_points.len() as u32;\n+                let state = 3 + self.suspension_points.len();\n \n                 self.suspension_points.push(SuspensionPoint {\n                     state,\n@@ -283,11 +289,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n                 });\n \n-                state\n+                VariantIdx::new(state)\n             } else { // Return\n-                RETURNED // state for returned\n+                VariantIdx::new(RETURNED) // state for returned\n             };\n-            data.statements.push(self.set_state(state, source_info));\n+            data.statements.push(self.set_discr(state, source_info));\n             data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n         }\n \n@@ -387,6 +393,7 @@ fn locals_live_across_suspend_points(\n ) -> (\n     liveness::LiveVarSet,\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    BitSet<BasicBlock>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let def_id = source.def_id();\n@@ -431,8 +438,12 @@ fn locals_live_across_suspend_points(\n \n     let mut storage_liveness_map = FxHashMap::default();\n \n+    let mut suspending_blocks = BitSet::new_empty(mir.basic_blocks().len());\n+\n     for (block, data) in mir.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n+            suspending_blocks.insert(block);\n+\n             let loc = Location {\n                 block: block,\n                 statement_index: data.statements.len(),\n@@ -484,7 +495,7 @@ fn locals_live_across_suspend_points(\n     // The generator argument is ignored\n     set.remove(self_arg());\n \n-    (set, storage_liveness_map)\n+    (set, storage_liveness_map, suspending_blocks)\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -493,15 +504,14 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n-    -> (FxHashMap<Local, (Ty<'tcx>, usize)>,\n+    -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n         GeneratorLayout<'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n-                                                                            mir,\n-                                                                            source,\n-                                                                            movable);\n+    let (live_locals, storage_liveness, suspending_blocks) =\n+        locals_live_across_suspend_points(tcx, mir, source, movable);\n+\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(upvars);\n@@ -527,7 +537,6 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let upvar_len = upvars.len();\n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n@@ -537,37 +546,52 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         (local, var)\n     });\n \n+    // For now we will access everything via variant #3, leaving empty variants\n+    // for the UNRESUMED, RETURNED, and POISONED states.\n+    // If there were a yield-less generator without a variant #3, it would not\n+    // have any vars to remap, so we would never use this.\n+    let variant_index = VariantIdx::new(3);\n+\n     // Create a map from local indices to generator struct indices.\n-    // These are offset by (upvar_len + 1) because of fields which comes before locals.\n     // We also create a vector of the LocalDecls of these locals.\n-    let (remap, vars) = live_decls.enumerate().map(|(idx, (local, var))| {\n-        ((local, (var.ty, upvar_len + 1 + idx)), var)\n-    }).unzip();\n+    let mut remap = FxHashMap::default();\n+    let mut decls = IndexVec::new();\n+    for (idx, (local, var)) in live_decls.enumerate() {\n+        remap.insert(local, (var.ty, variant_index, idx));\n+        decls.push(var);\n+    }\n+    let field_tys = decls.iter().map(|field| field.ty).collect::<IndexVec<_, _>>();\n+\n+    // Put every var in each variant, for now.\n+    let all_vars = (0..field_tys.len()).map(GeneratorSavedLocal::from).collect();\n+    let empty_variants = iter::repeat(IndexVec::new()).take(3);\n+    let state_variants = iter::repeat(all_vars).take(suspending_blocks.count());\n \n     let layout = GeneratorLayout {\n-        fields: vars\n+        field_tys,\n+        variant_fields: empty_variants.chain(state_variants).collect(),\n+        __local_debuginfo_codegen_only_do_not_use: decls,\n     };\n \n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mir: &mut Mir<'tcx>,\n-                           cases: Vec<(u32, BasicBlock)>,\n+fn insert_switch<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+                           cases: Vec<(usize, BasicBlock)>,\n                            transform: &TransformVisitor<'a, 'tcx>,\n                            default: TerminatorKind<'tcx>) {\n     let default_block = insert_term_block(mir, default);\n-\n+    let (assign, discr) = transform.get_discr(mir);\n     let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Copy(transform.make_field(transform.state_field, tcx.types.u32)),\n-        switch_ty: tcx.types.u32,\n-        values: Cow::from(cases.iter().map(|&(i, _)| i.into()).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),\n+        discr: Operand::Move(discr),\n+        switch_ty: transform.discr_ty,\n+        values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n+        targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n     let source_info = source_info(mir);\n     mir.basic_blocks_mut().raw.insert(0, BasicBlockData {\n-        statements: Vec::new(),\n+        statements: vec![assign],\n         terminator: Some(Terminator {\n             source_info,\n             kind: switch,\n@@ -652,7 +676,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // The returned state and the poisoned state fall through to the default\n     // case which is just to return\n \n-    insert_switch(tcx, &mut mir, cases, &transform, TerminatorKind::Return);\n+    insert_switch(&mut mir, cases, &transform, TerminatorKind::Return);\n \n     for block in mir.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n@@ -766,7 +790,8 @@ fn create_generator_resume_function<'a, 'tcx>(\n     for block in mir.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n         if let &TerminatorKind::Resume = &block.terminator().kind {\n-            block.statements.push(transform.set_state(POISONED, source_info));\n+            block.statements.push(\n+                transform.set_discr(VariantIdx::new(POISONED), source_info));\n         }\n     }\n \n@@ -784,7 +809,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // Panic when resumed on the poisoned state\n     cases.insert(2, (POISONED, insert_panic_block(tcx, mir, GeneratorResumedAfterPanic)));\n \n-    insert_switch(tcx, mir, cases, &transform, TerminatorKind::Unreachable);\n+    insert_switch(mir, cases, &transform, TerminatorKind::Unreachable);\n \n     make_generator_state_argument_indirect(tcx, def_id, mir);\n     make_generator_state_argument_pinned(tcx, mir);\n@@ -830,7 +855,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n \n fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n                           transform: &TransformVisitor<'a, 'tcx>,\n-                          target: F) -> Vec<(u32, BasicBlock)>\n+                          target: F) -> Vec<(usize, BasicBlock)>\n     where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n     let source_info = source_info(mir);\n \n@@ -888,10 +913,11 @@ impl MirPass for StateTransform {\n         let gen_ty = mir.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n-        let (upvars, interior, movable) = match gen_ty.sty {\n+        let (upvars, interior, discr_ty, movable) = match gen_ty.sty {\n             ty::Generator(_, substs, movability) => {\n                 (substs.upvar_tys(def_id, tcx).collect(),\n                  substs.witness(def_id, tcx),\n+                 substs.discr_ty(tcx),\n                  movability == hir::GeneratorMovability::Movable)\n             }\n             _ => bug!(),\n@@ -921,8 +947,6 @@ impl MirPass for StateTransform {\n             movable,\n             mir);\n \n-        let state_field = upvars.len();\n-\n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n@@ -935,7 +959,7 @@ impl MirPass for StateTransform {\n             storage_liveness,\n             suspension_points: Vec::new(),\n             new_ret_local,\n-            state_field,\n+            discr_ty,\n         };\n         transform.visit_mir(mir);\n "}, {"sha": "8d9a878fc9e3766aa3f2c92cd01edbb81d1583e6", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -55,8 +55,7 @@ pub struct LivenessResult {\n }\n \n /// Computes which local variables are live within the given function\n-/// `mir`. The liveness mode `mode` determines what sorts of uses are\n-/// considered to make a variable live (e.g., do drops count?).\n+/// `mir`, including drops.\n pub fn liveness_of_locals<'tcx>(\n     mir: &Mir<'tcx>,\n ) -> LivenessResult {"}, {"sha": "59dbfecc39ffc28f65a85ed35dc0637243a05183", "filename": "src/test/debuginfo/generator-locals.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -0,0 +1,87 @@\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:print a\n+// gdb-check:$1 = 5\n+// gdb-command:print c\n+// gdb-check:$2 = 6\n+// gdb-command:print d\n+// gdb-check:$3 = 7\n+// gdb-command:continue\n+// gdb-command:print a\n+// gdb-check:$4 = 7\n+// gdb-command:print c\n+// gdb-check:$5 = 6\n+// gdb-command:print e\n+// gdb-check:$6 = 8\n+// gdb-command:continue\n+// gdb-command:print a\n+// gdb-check:$7 = 8\n+// gdb-command:print c\n+// gdb-check:$8 = 6\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+// lldb-command:print a\n+// lldbg-check:(int) $0 = 5\n+// lldbr-check:(int) a = 5\n+// lldb-command:print c\n+// lldbg-check:(int) $1 = 6\n+// lldbr-check:(int) c = 6\n+// lldb-command:print d\n+// lldbg-check:(int) $2 = 7\n+// lldbr-check:(int) d = 7\n+// lldb-command:continue\n+// lldb-command:print a\n+// lldbg-check:(int) $3 = 7\n+// lldbr-check:(int) a = 7\n+// lldb-command:print c\n+// lldbg-check:(int) $4 = 6\n+// lldbr-check:(int) c = 6\n+// lldb-command:print e\n+// lldbg-check:(int) $5 = 8\n+// lldbr-check:(int) e = 8\n+// lldb-command:continue\n+// lldb-command:print a\n+// lldbg-check:(int) $6 = 8\n+// lldbr-check:(int) a = 8\n+// lldb-command:print c\n+// lldbg-check:(int) $7 = 6\n+// lldbr-check:(int) c = 6\n+\n+#![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use std::ops::Generator;\n+use std::pin::Pin;\n+\n+fn main() {\n+    let mut a = 5;\n+    let mut b = || {\n+        let c = 6; // Live across multiple yield points\n+\n+        let d = 7; // Live across only one yield point\n+        yield;\n+        _zzz(); // #break\n+        a = d;\n+\n+        let e = 8; // Live across zero yield points\n+        _zzz(); // #break\n+        a = e;\n+\n+        yield;\n+        _zzz(); // #break\n+        a = c;\n+    };\n+    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+}\n+\n+fn _zzz() {()}"}, {"sha": "c6f98e5782b1f8449999ab71cc5bc7301c2c91bf", "filename": "src/test/debuginfo/generator-objects.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -0,0 +1,68 @@\n+// ignore-tidy-linelength\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 8.0\n+// min-gdb-version: 8.2\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:print b\n+// gdb-check:$1 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 0, 0: generator_objects::main::generator::Unresumed, 1: generator_objects::main::generator::Returned, 2: generator_objects::main::generator::Panicked, 3: generator_objects::main::generator::Suspend0 {[...]}, 4: generator_objects::main::generator::Suspend1 {[...]}}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$2 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 3, 0: generator_objects::main::generator::Unresumed, 1: generator_objects::main::generator::Returned, 2: generator_objects::main::generator::Panicked, 3: generator_objects::main::generator::Suspend0 {c: 6, d: 7}, 4: generator_objects::main::generator::Suspend1 {[...]}}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$3 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 4, 0: generator_objects::main::generator::Unresumed, 1: generator_objects::main::generator::Returned, 2: generator_objects::main::generator::Panicked, 3: generator_objects::main::generator::Suspend0 {[...]}, 4: generator_objects::main::generator::Suspend1 {c: 7, d: 8}}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$4 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 1, 0: generator_objects::main::generator::Unresumed, 1: generator_objects::main::generator::Returned, 2: generator_objects::main::generator::Panicked, 3: generator_objects::main::generator::Suspend0 {[...]}, 4: generator_objects::main::generator::Suspend1 {[...]}}}\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $0 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $1 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $2 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $3 = generator(&0x[...])\n+\n+#![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use std::ops::Generator;\n+use std::pin::Pin;\n+\n+fn main() {\n+    let mut a = 5;\n+    let mut b = || {\n+        let mut c = 6;\n+        let mut d = 7;\n+\n+        yield;\n+        a += 1;\n+        c += 1;\n+        d += 1;\n+\n+        yield;\n+        println!(\"{} {} {}\", a, c, d);\n+    };\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+}\n+\n+fn _zzz() {()}"}, {"sha": "35a67217f16718c45dd897c4b00ceaa647b8d5d8", "filename": "src/test/debuginfo/generators.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fdebuginfo%2Fgenerators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fdebuginfo%2Fgenerators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerators.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,42 +0,0 @@\n-// min-lldb-version: 310\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:run\n-// gdb-command:print a\n-// gdb-check:$1 = 5\n-// gdb-command:print d\n-// gdb-check:$2 = 6\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-// lldb-command:print a\n-// lldbg-check:(int) $0 = 5\n-// lldbr-check:(int) a = 5\n-// lldb-command:print d\n-// lldbg-check:(int) $1 = 6\n-// lldbr-check:(int) d = 6\n-\n-#![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use std::ops::Generator;\n-use std::pin::Pin;\n-\n-fn main() {\n-    let mut a = 5;\n-    let mut b = || {\n-        let d = 6;\n-        yield;\n-        _zzz(); // #break\n-        a = d;\n-    };\n-    Pin::new(&mut b).resume();\n-    Pin::new(&mut b).resume();\n-    _zzz(); // #break\n-}\n-\n-fn _zzz() {()}"}, {"sha": "9cc4272fafabf1526af662f3aaf039178d732eaf", "filename": "src/test/mir-opt/generator-drop-cleanup.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -13,7 +13,8 @@ fn main() {\n \n // START rustc.main-{{closure}}.generator_drop.0.mir\n // bb0: {\n-//     switchInt(((*_1).0: u32)) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n+//     _5 = discriminant((*_1));\n+//     switchInt(move _5) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n // }\n // bb1: {\n //     goto -> bb5;"}]}