{"sha": "e9ce02ce63cb6682c6636374f340c28d654547c2", "node_id": "C_kwDOAAsO6NoAKGU5Y2UwMmNlNjNjYjY2ODJjNjYzNjM3NGYzNDBjMjhkNjU0NTQ3YzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T19:42:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-06T19:42:58Z"}, "message": "Auto merge of #14087 - HKalbasi:layout, r=Veykril\n\nSupport computing layout of RPIT\n\nAnd some refactoring to make code more type safe.", "tree": {"sha": "d39e0e7b3f2752950cf6d16ff5280c47e82e27b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39e0e7b3f2752950cf6d16ff5280c47e82e27b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9ce02ce63cb6682c6636374f340c28d654547c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ce02ce63cb6682c6636374f340c28d654547c2", "html_url": "https://github.com/rust-lang/rust/commit/e9ce02ce63cb6682c6636374f340c28d654547c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9ce02ce63cb6682c6636374f340c28d654547c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14ad6087c54efc7debd4eb0ae15e200dcd17f38b", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ad6087c54efc7debd4eb0ae15e200dcd17f38b", "html_url": "https://github.com/rust-lang/rust/commit/14ad6087c54efc7debd4eb0ae15e200dcd17f38b"}, {"sha": "443bc7f19366d0d5dff1396275f25ce946d9d80c", "url": "https://api.github.com/repos/rust-lang/rust/commits/443bc7f19366d0d5dff1396275f25ce946d9d80c", "html_url": "https://github.com/rust-lang/rust/commit/443bc7f19366d0d5dff1396275f25ce946d9d80c"}], "stats": {"total": 279, "additions": 214, "deletions": 65}, "files": [{"sha": "6989e9fb9be5c126c1dcf98fafa78376c05e014b", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -205,7 +205,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     .return_type_impl_traits(func)\n                     .expect(\"impl trait id without impl traits\");\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n-                let data = &datas.impl_traits[idx as usize];\n+                let data = &datas.impl_traits[idx];\n                 let bound = OpaqueTyDatumBound {\n                     bounds: make_single_type_binders(data.bounds.skip_binders().to_vec()),\n                     where_clauses: chalk_ir::Binders::empty(Interner, vec![]),"}, {"sha": "45c975dfcdc32033d1bd6c50f2565de8fb79376d", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -234,9 +234,8 @@ impl TyExt for Ty {\n                     }\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n-                            let data = (*it)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let data =\n+                                (*it).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             data.substitute(Interner, &subst).into_value_and_skipped_binders().0\n                         })\n                     }\n@@ -247,9 +246,8 @@ impl TyExt for Ty {\n                 {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n-                            let data = (*it)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let data =\n+                                (*it).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             data.substitute(Interner, &opaque_ty.substitution)\n                         })\n                     }"}, {"sha": "464860dea3c380f5cbb2b9cf974d1bcbc9ef5a81", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -458,9 +458,8 @@ impl HirDisplay for Ty {\n                             let datas = db\n                                 .return_type_impl_traits(func)\n                                 .expect(\"impl trait id without data\");\n-                            let data = (*datas)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let data =\n+                                (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             let bounds = data.substitute(Interner, parameters);\n                             let mut len = bounds.skip_binders().len();\n \n@@ -718,9 +717,8 @@ impl HirDisplay for Ty {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n-                        let data = (*datas)\n-                            .as_ref()\n-                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        let data =\n+                            (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                         let bounds = data.substitute(Interner, &parameters);\n                         let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n@@ -828,9 +826,8 @@ impl HirDisplay for Ty {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n-                        let data = (*datas)\n-                            .as_ref()\n-                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        let data =\n+                            (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                         let bounds = data.substitute(Interner, &opaque_ty.substitution);\n                         let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix("}, {"sha": "a76d33c0cded33b67206c4399d217a5d9bd3a98b", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -39,7 +39,7 @@ use stdx::always;\n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n     lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, Substitution,\n+    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n     TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n@@ -352,6 +352,7 @@ pub struct InferenceResult {\n     /// **Note**: When a pattern type is resolved it may still contain\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_rpit: ArenaMap<RpitId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n@@ -525,6 +526,9 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n+        for ty in result.type_of_rpit.iter_mut().map(|x| x.1) {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n         for mismatch in result.type_mismatches.values_mut() {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n@@ -603,7 +607,7 @@ impl<'a> InferenceContext<'a> {\n                         _ => unreachable!(),\n                     };\n                     let bounds = (*rpits).map_ref(|rpits| {\n-                        rpits.impl_traits[idx as usize].bounds.map_ref(|it| it.into_iter())\n+                        rpits.impl_traits[idx].bounds.map_ref(|it| it.into_iter())\n                     });\n                     let var = self.table.new_type_var();\n                     let var_subst = Substitution::from1(Interner, var.clone());\n@@ -616,6 +620,7 @@ impl<'a> InferenceContext<'a> {\n                         always!(binders.is_empty(Interner)); // quantified where clauses not yet handled\n                         self.push_obligation(var_predicate.cast(Interner));\n                     }\n+                    self.result.type_of_rpit.insert(idx, var.clone());\n                     var\n                 },\n                 DebruijnIndex::INNERMOST,"}, {"sha": "c82c274524acd0015d627d8dfd9bf36f621764f6", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -225,10 +225,21 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             ptr.valid_range_mut().start = 1;\n             Layout::scalar(dl, ptr)\n         }\n-        TyKind::Closure(_, _)\n-        | TyKind::OpaqueType(_, _)\n-        | TyKind::Generator(_, _)\n-        | TyKind::GeneratorWitness(_, _) => return Err(LayoutError::NotImplemented),\n+        TyKind::OpaqueType(opaque_ty_id, _) => {\n+            let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+            match impl_trait_id {\n+                crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                    let infer = db.infer(func.into());\n+                    layout_of_ty(db, &infer.type_of_rpit[idx], krate)?\n+                }\n+                crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n+                    return Err(LayoutError::NotImplemented)\n+                }\n+            }\n+        }\n+        TyKind::Closure(_, _) | TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n+            return Err(LayoutError::NotImplemented)\n+        }\n         TyKind::AssociatedType(_, _)\n         | TyKind::Error\n         | TyKind::Alias(_)"}, {"sha": "ba7db9b0e20071ce86a75faacba8355a2f5cd4eb", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 106, "deletions": 1, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -5,7 +5,7 @@ use hir_def::{\n     layout::{Layout, LayoutError},\n };\n \n-use crate::{test_db::TestDB, Interner, Substitution};\n+use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n \n use super::layout_of_ty;\n \n@@ -45,13 +45,64 @@ fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n     layout_of_ty(&db, &goal_ty, module_id.krate())\n }\n \n+/// A version of `eval_goal` for types that can not be expressed in ADTs, like closures and `impl Trait`\n+fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+    // using unstable cargo features failed, fall back to using plain rustc\n+    let mut cmd = std::process::Command::new(\"rustc\");\n+    cmd.args([\"-Z\", \"unstable-options\", \"--print\", \"target-spec-json\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n+    let output = cmd.output().unwrap();\n+    assert!(output.status.success(), \"{}\", output.status);\n+    let stdout = String::from_utf8(output.stdout).unwrap();\n+    let target_data_layout =\n+        stdout.split_once(r#\"\"data-layout\": \"\"#).unwrap().1.split_once('\"').unwrap().0.to_owned();\n+\n+    let ra_fixture = format!(\n+        \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\nfn main(){{let goal = {{{ra_fixture}}};}}\",\n+    );\n+\n+    let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(&db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let adt_id = scope\n+        .declarations()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::FunctionId(x) => {\n+                let name = db.function_data(x).name.to_smol_str();\n+                (name == \"main\").then_some(x)\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    let hir_body = db.body(adt_id.into());\n+    let pat = hir_body\n+        .pats\n+        .iter()\n+        .find(|x| match x.1 {\n+            hir_def::expr::Pat::Bind { name, .. } => name.to_smol_str() == \"goal\",\n+            _ => false,\n+        })\n+        .unwrap()\n+        .0;\n+    let infer = db.infer(adt_id.into());\n+    let goal_ty = infer.type_of_pat[pat].clone();\n+    layout_of_ty(&db, &goal_ty, module_id.krate())\n+}\n+\n #[track_caller]\n fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_goal(ra_fixture, minicore).unwrap();\n     assert_eq!(l.size.bytes(), size);\n     assert_eq!(l.align.abi.bytes(), align);\n }\n \n+#[track_caller]\n+fn check_size_and_align_expr(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n+    let l = eval_expr(ra_fixture, minicore).unwrap();\n+    assert_eq!(l.size.bytes(), size);\n+    assert_eq!(l.align.abi.bytes(), align);\n+}\n+\n #[track_caller]\n fn check_fail(ra_fixture: &str, e: LayoutError) {\n     let r = eval_goal(ra_fixture, \"\");\n@@ -85,11 +136,31 @@ macro_rules! size_and_align {\n     };\n }\n \n+macro_rules! size_and_align_expr {\n+    ($($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            {\n+                let val = { $($t)* };\n+                check_size_and_align_expr(\n+                    stringify!($($t)*),\n+                    \"\",\n+                    ::std::mem::size_of_val(&val) as u64,\n+                    ::std::mem::align_of_val(&val) as u64,\n+                );\n+            }\n+        }\n+    };\n+}\n+\n #[test]\n fn hello_world() {\n     size_and_align! {\n         struct Goal(i32);\n     }\n+    size_and_align_expr! {\n+        2i32\n+    }\n }\n \n #[test]\n@@ -143,6 +214,40 @@ fn generic() {\n     }\n }\n \n+#[test]\n+fn return_position_impl_trait() {\n+    size_and_align_expr! {\n+        trait T {}\n+        impl T for i32 {}\n+        impl T for i64 {}\n+        fn foo() -> impl T { 2i64 }\n+        foo()\n+    }\n+    size_and_align_expr! {\n+        trait T {}\n+        impl T for i32 {}\n+        impl T for i64 {}\n+        fn foo() -> (impl T, impl T, impl T) { (2i64, 5i32, 7i32) }\n+        foo()\n+    }\n+    size_and_align_expr! {\n+        struct Foo<T>(T, T, (T, T));\n+        trait T {}\n+        impl T for Foo<i32> {}\n+        impl T for Foo<i64> {}\n+\n+        fn foo() -> Foo<impl T> { Foo(\n+            Foo(1i64, 2, (3, 4)),\n+            Foo(5, 6, (7, 8)),\n+            (\n+                Foo(1i64, 2, (3, 4)),\n+                Foo(5, 6, (7, 8)),\n+            ),\n+        ) }\n+        foo()\n+    }\n+}\n+\n #[test]\n fn enums() {\n     size_and_align! {"}, {"sha": "59a5ef8c14dae2435f84a57892c8406ecaf6f248", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -45,6 +45,7 @@ use chalk_ir::{\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use itertools::Either;\n+use la_arena::{Arena, Idx};\n use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n@@ -290,22 +291,24 @@ impl TypeFoldable<Interner> for CallableSig {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum ImplTraitId {\n-    ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+    ReturnTypeImplTrait(hir_def::FunctionId, RpitId),\n     AsyncBlockTypeImplTrait(hir_def::DefWithBodyId, ExprId),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ReturnTypeImplTraits {\n-    pub(crate) impl_traits: Vec<ReturnTypeImplTrait>,\n+    pub(crate) impl_traits: Arena<ReturnTypeImplTrait>,\n }\n \n has_interner!(ReturnTypeImplTraits);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub(crate) struct ReturnTypeImplTrait {\n+pub struct ReturnTypeImplTrait {\n     pub(crate) bounds: Binders<Vec<QuantifiedWhereClause>>,\n }\n \n+pub type RpitId = Idx<ReturnTypeImplTrait>;\n+\n pub fn static_lifetime() -> Lifetime {\n     LifetimeData::Static.intern(Interner)\n }"}, {"sha": "86abe1af68a60dbe2a3cfbe295f610df2ff71ff4", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ce02ce63cb6682c6636374f340c28d654547c2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=e9ce02ce63cb6682c6636374f340c28d654547c2", "patch": "@@ -36,7 +36,7 @@ use hir_def::{\n use hir_expand::{name::Name, ExpandResult};\n use intern::Interned;\n use itertools::Either;\n-use la_arena::ArenaMap;\n+use la_arena::{Arena, ArenaMap};\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n@@ -57,6 +57,51 @@ use crate::{\n     Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n+#[derive(Debug)]\n+enum ImplTraitLoweringState {\n+    /// When turning `impl Trait` into opaque types, we have to collect the\n+    /// bounds at the same time to get the IDs correct (without becoming too\n+    /// complicated). I don't like using interior mutability (as for the\n+    /// counter), but I've tried and failed to make the lifetimes work for\n+    /// passing around a `&mut TyLoweringContext`. The core problem is that\n+    /// we're grouping the mutable data (the counter and this field) together\n+    /// with the immutable context (the references to the DB and resolver).\n+    /// Splitting this up would be a possible fix.\n+    Opaque(RefCell<Arena<ReturnTypeImplTrait>>),\n+    Param(Cell<u16>),\n+    Variable(Cell<u16>),\n+    Disallowed,\n+}\n+impl ImplTraitLoweringState {\n+    fn new(impl_trait_mode: ImplTraitLoweringMode) -> ImplTraitLoweringState {\n+        match impl_trait_mode {\n+            ImplTraitLoweringMode::Opaque => Self::Opaque(RefCell::new(Arena::new())),\n+            ImplTraitLoweringMode::Param => Self::Param(Cell::new(0)),\n+            ImplTraitLoweringMode::Variable => Self::Variable(Cell::new(0)),\n+            ImplTraitLoweringMode::Disallowed => Self::Disallowed,\n+        }\n+    }\n+\n+    fn take(&self) -> Self {\n+        match self {\n+            Self::Opaque(x) => Self::Opaque(RefCell::new(x.take())),\n+            Self::Param(x) => Self::Param(Cell::new(x.get())),\n+            Self::Variable(x) => Self::Variable(Cell::new(x.get())),\n+            Self::Disallowed => Self::Disallowed,\n+        }\n+    }\n+\n+    fn swap(&self, impl_trait_mode: &Self) {\n+        match (self, impl_trait_mode) {\n+            (Self::Opaque(x), Self::Opaque(y)) => x.swap(y),\n+            (Self::Param(x), Self::Param(y)) => x.swap(y),\n+            (Self::Variable(x), Self::Variable(y)) => x.swap(y),\n+            (Self::Disallowed, Self::Disallowed) => (),\n+            _ => panic!(\"mismatched lowering mode\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n     pub db: &'a dyn HirDatabase,\n@@ -67,37 +112,23 @@ pub struct TyLoweringContext<'a> {\n     /// should be converted to variables. I think in practice, this isn't\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: ParamLoweringMode,\n-    pub impl_trait_mode: ImplTraitLoweringMode,\n-    impl_trait_counter: Cell<u16>,\n-    /// When turning `impl Trait` into opaque types, we have to collect the\n-    /// bounds at the same time to get the IDs correct (without becoming too\n-    /// complicated). I don't like using interior mutability (as for the\n-    /// counter), but I've tried and failed to make the lifetimes work for\n-    /// passing around a `&mut TyLoweringContext`. The core problem is that\n-    /// we're grouping the mutable data (the counter and this field) together\n-    /// with the immutable context (the references to the DB and resolver).\n-    /// Splitting this up would be a possible fix.\n-    opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n+    impl_trait_mode: ImplTraitLoweringState,\n     expander: RefCell<Option<Expander>>,\n     /// Tracks types with explicit `?Sized` bounds.\n     pub(crate) unsized_types: RefCell<FxHashSet<Ty>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n     pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n-        let impl_trait_counter = Cell::new(0);\n-        let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n+        let impl_trait_mode = ImplTraitLoweringState::Disallowed;\n         let type_param_mode = ParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        let opaque_type_data = RefCell::new(Vec::new());\n         Self {\n             db,\n             resolver,\n             in_binders,\n             impl_trait_mode,\n-            impl_trait_counter,\n             type_param_mode,\n-            opaque_type_data,\n             expander: RefCell::new(None),\n             unsized_types: RefCell::default(),\n         }\n@@ -108,20 +139,18 @@ impl<'a> TyLoweringContext<'a> {\n         debruijn: DebruijnIndex,\n         f: impl FnOnce(&TyLoweringContext<'_>) -> T,\n     ) -> T {\n-        let opaque_ty_data_vec = self.opaque_type_data.take();\n+        let impl_trait_mode = self.impl_trait_mode.take();\n         let expander = self.expander.take();\n         let unsized_types = self.unsized_types.take();\n         let new_ctx = Self {\n             in_binders: debruijn,\n-            impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n-            opaque_type_data: RefCell::new(opaque_ty_data_vec),\n+            impl_trait_mode,\n             expander: RefCell::new(expander),\n             unsized_types: RefCell::new(unsized_types),\n             ..*self\n         };\n         let result = f(&new_ctx);\n-        self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n-        self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n+        self.impl_trait_mode.swap(&new_ctx.impl_trait_mode);\n         self.expander.replace(new_ctx.expander.into_inner());\n         self.unsized_types.replace(new_ctx.unsized_types.into_inner());\n         result\n@@ -136,7 +165,7 @@ impl<'a> TyLoweringContext<'a> {\n     }\n \n     pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n-        Self { impl_trait_mode, ..self }\n+        Self { impl_trait_mode: ImplTraitLoweringState::new(impl_trait_mode), ..self }\n     }\n \n     pub fn with_type_param_mode(self, type_param_mode: ParamLoweringMode) -> Self {\n@@ -244,20 +273,17 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::DynTrait(bounds) => self.lower_dyn_trait(bounds),\n             TypeRef::ImplTrait(bounds) => {\n-                match self.impl_trait_mode {\n-                    ImplTraitLoweringMode::Opaque => {\n-                        let idx = self.impl_trait_counter.get();\n-                        self.impl_trait_counter.set(idx + 1);\n+                match &self.impl_trait_mode {\n+                    ImplTraitLoweringState::Opaque(opaque_type_data) => {\n                         let func = match self.resolver.generic_def() {\n                             Some(GenericDefId::FunctionId(f)) => f,\n                             _ => panic!(\"opaque impl trait lowering in non-function\"),\n                         };\n \n-                        assert!(idx as usize == self.opaque_type_data.borrow().len());\n                         // this dance is to make sure the data is in the right\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n-                        self.opaque_type_data.borrow_mut().push(ReturnTypeImplTrait {\n+                        let idx = opaque_type_data.borrow_mut().alloc(ReturnTypeImplTrait {\n                             bounds: crate::make_single_type_binders(Vec::new()),\n                         });\n                         // We don't want to lower the bounds inside the binders\n@@ -273,18 +299,18 @@ impl<'a> TyLoweringContext<'a> {\n                             .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n                                 ctx.lower_impl_trait(bounds, func)\n                             });\n-                        self.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n+                        opaque_type_data.borrow_mut()[idx] = actual_opaque_type_data;\n \n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n                         let parameters = generics.bound_vars_subst(self.db, self.in_binders);\n                         TyKind::OpaqueType(opaque_ty_id, parameters).intern(Interner)\n                     }\n-                    ImplTraitLoweringMode::Param => {\n-                        let idx = self.impl_trait_counter.get();\n+                    ImplTraitLoweringState::Param(counter) => {\n+                        let idx = counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        counter.set(idx + count_impl_traits(type_ref) as u16);\n                         if let Some(def) = self.resolver.generic_def() {\n                             let generics = generics(self.db.upcast(), def);\n                             let param = generics\n@@ -305,10 +331,10 @@ impl<'a> TyLoweringContext<'a> {\n                             TyKind::Error.intern(Interner)\n                         }\n                     }\n-                    ImplTraitLoweringMode::Variable => {\n-                        let idx = self.impl_trait_counter.get();\n+                    ImplTraitLoweringState::Variable(counter) => {\n+                        let idx = counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n                             _parent_params,\n                             self_params,\n@@ -327,7 +353,7 @@ impl<'a> TyLoweringContext<'a> {\n                         ))\n                         .intern(Interner)\n                     }\n-                    ImplTraitLoweringMode::Disallowed => {\n+                    ImplTraitLoweringState::Disallowed => {\n                         // FIXME: report error\n                         TyKind::Error.intern(Interner)\n                     }\n@@ -1863,8 +1889,12 @@ pub(crate) fn return_type_impl_traits(\n         .with_type_param_mode(ParamLoweringMode::Variable);\n     let _ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let return_type_impl_traits =\n-        ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n+    let return_type_impl_traits = ReturnTypeImplTraits {\n+        impl_traits: match ctx_ret.impl_trait_mode {\n+            ImplTraitLoweringState::Opaque(x) => x.into_inner(),\n+            _ => unreachable!(),\n+        },\n+    };\n     if return_type_impl_traits.impl_traits.is_empty() {\n         None\n     } else {"}]}