{"sha": "56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "node_id": "C_kwDOAAsO6NoAKDU2ZTQzYzM0ZTdjNTZmZTNjNzJlMDJjM2Q3ZDkyNjFjNzMwNzFmNjE", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-03-13T21:20:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-03-14T14:57:24Z"}, "message": ":arrow_up: xshell", "tree": {"sha": "4755259852b540c9811380ba0f9d0c85a7e1c086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4755259852b540c9811380ba0f9d0c85a7e1c086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "html_url": "https://github.com/rust-lang/rust/commit/56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e8515870674983cce5b945946045bc1e9b80200", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8515870674983cce5b945946045bc1e9b80200", "html_url": "https://github.com/rust-lang/rust/commit/5e8515870674983cce5b945946045bc1e9b80200"}], "stats": {"total": 459, "additions": 247, "deletions": 212}, "files": [{"sha": "1d298353f71d2b53f37907affc08f947695fba7f", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -2072,18 +2072,18 @@ checksum = \"da260301476ad19a4733a0e930db8227a48ea04561e235a5102978145ec69fcc\"\n \n [[package]]\n name = \"xshell\"\n-version = \"0.1.17\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eaad2035244c56da05573d4d7fda5f903c60a5f35b9110e157a14a1df45a9f14\"\n+checksum = \"3332cab90be2998a2aacb6494db45344bd16dfcc43ff36c42255018c6bcc96be\"\n dependencies = [\n  \"xshell-macros\",\n ]\n \n [[package]]\n name = \"xshell-macros\"\n-version = \"0.1.17\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4916a4a3cad759e499a3620523bf9545cc162d7a06163727dde97ce9aaa4cf39\"\n+checksum = \"f47e54cffa76000b7641328ab3bb1e146f93a1690ab86c5909c656f49d91019c\"\n \n [[package]]\n name = \"xtask\""}, {"sha": "c71a213c40906117e0b5107c6cfbc05c409bd2b1", "filename": "crates/ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2FCargo.toml?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -35,5 +35,5 @@ limit = { path = \"../limit\", version = \"0.0.0\" }\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n sourcegen = { path = \"../sourcegen\" }\n-xshell = \"0.1\"\n+xshell = \"0.2.0\"\n expect-test = \"1.2.0-pre.1\""}, {"sha": "b7db1dd8dbc271cb162bf5a51e8aa79f1aeed939", "filename": "crates/ide_db/src/tests/sourcegen_lints.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftests%2Fsourcegen_lints.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -4,16 +4,20 @@ use std::{borrow::Cow, fs, path::Path};\n use itertools::Itertools;\n use stdx::format_to;\n use test_utils::project_root;\n-use xshell::cmd;\n+use xshell::{cmd, Shell};\n \n /// This clones rustc repo, and so is not worth to keep up-to-date. We update\n /// manually by un-ignoring the test from time to time.\n #[test]\n #[ignore]\n fn sourcegen_lint_completions() {\n+    let sh = &Shell::new().unwrap();\n+\n     let rust_repo = project_root().join(\"./target/rust\");\n     if !rust_repo.exists() {\n-        cmd!(\"git clone --depth=1 https://github.com/rust-lang/rust {rust_repo}\").run().unwrap();\n+        cmd!(sh, \"git clone --depth=1 https://github.com/rust-lang/rust {rust_repo}\")\n+            .run()\n+            .unwrap();\n     }\n \n     let mut contents = String::from(\n@@ -30,16 +34,19 @@ pub struct LintGroup {\n \",\n     );\n \n-    generate_lint_descriptor(&mut contents);\n+    generate_lint_descriptor(sh, &mut contents);\n     contents.push('\\n');\n \n     generate_feature_descriptor(&mut contents, &rust_repo.join(\"src/doc/unstable-book/src\"));\n     contents.push('\\n');\n \n     let lints_json = project_root().join(\"./target/clippy_lints.json\");\n-    cmd!(\"curl https://rust-lang.github.io/rust-clippy/master/lints.json --output {lints_json}\")\n-        .run()\n-        .unwrap();\n+    cmd!(\n+        sh,\n+        \"curl https://rust-lang.github.io/rust-clippy/master/lints.json --output {lints_json}\"\n+    )\n+    .run()\n+    .unwrap();\n     generate_descriptor_clippy(&mut contents, &lints_json);\n \n     let contents = sourcegen::add_preamble(\"sourcegen_lints\", sourcegen::reformat(contents));\n@@ -48,10 +55,10 @@ pub struct LintGroup {\n     sourcegen::ensure_file_contents(destination.as_path(), &contents);\n }\n \n-fn generate_lint_descriptor(buf: &mut String) {\n+fn generate_lint_descriptor(sh: &Shell, buf: &mut String) {\n     // FIXME: rustdoc currently requires an input file for -Whelp cc https://github.com/rust-lang/rust/pull/88831\n     let file = project_root().join(file!());\n-    let stdout = cmd!(\"rustdoc -W help {file}\").read().unwrap();\n+    let stdout = cmd!(sh, \"rustdoc -W help {file}\").read().unwrap();\n     let start_lints = stdout.find(\"----  -------  -------\").unwrap();\n     let start_lint_groups = stdout.find(\"----  ---------\").unwrap();\n     let start_lints_rustdoc ="}, {"sha": "68d728b41f5b7f17b13b7b108306305f491366a7", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -75,7 +75,7 @@ jemallocator = { version = \"0.4.1\", package = \"tikv-jemallocator\", optional = tr\n [dev-dependencies]\n expect-test = \"1.2.0-pre.1\"\n jod-thread = \"0.1.0\"\n-xshell = \"0.1\"\n+xshell = \"0.2.0\"\n \n test_utils = { path = \"../test_utils\" }\n sourcegen = { path = \"../sourcegen\" }"}, {"sha": "9e53aa847dcf18dd51ebbffc28afc4ddd8ea0870", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -3,40 +3,43 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n-use xshell::{cmd, pushd, pushenv, read_file};\n+use xshell::{cmd, Shell};\n \n #[test]\n fn check_code_formatting() {\n-    let _dir = pushd(sourcegen::project_root()).unwrap();\n-    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n+    let sh = &Shell::new().unwrap();\n+    sh.change_dir(sourcegen::project_root());\n+    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n \n-    let out = cmd!(\"rustfmt --version\").read().unwrap();\n+    let out = cmd!(sh, \"rustfmt --version\").read().unwrap();\n     if !out.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n                  Please run `rustup component add rustfmt --toolchain stable` to install it.\",\n         )\n     }\n \n-    let res = cmd!(\"cargo fmt -- --check\").run();\n+    let res = cmd!(sh, \"cargo fmt -- --check\").run();\n     if res.is_err() {\n-        let _ = cmd!(\"cargo fmt\").run();\n+        let _ = cmd!(sh, \"cargo fmt\").run();\n     }\n     res.unwrap()\n }\n \n #[test]\n fn check_lsp_extensions_docs() {\n+    let sh = &Shell::new().unwrap();\n+\n     let expected_hash = {\n-        let lsp_ext_rs =\n-            read_file(sourcegen::project_root().join(\"crates/rust-analyzer/src/lsp_ext.rs\"))\n-                .unwrap();\n+        let lsp_ext_rs = sh\n+            .read_file(sourcegen::project_root().join(\"crates/rust-analyzer/src/lsp_ext.rs\"))\n+            .unwrap();\n         stable_hash(lsp_ext_rs.as_str())\n     };\n \n     let actual_hash = {\n         let lsp_extensions_md =\n-            read_file(sourcegen::project_root().join(\"docs/dev/lsp-extensions.md\")).unwrap();\n+            sh.read_file(sourcegen::project_root().join(\"docs/dev/lsp-extensions.md\")).unwrap();\n         let text = lsp_extensions_md\n             .lines()\n             .find_map(|line| line.strip_prefix(\"lsp_ext.rs hash:\"))\n@@ -62,6 +65,8 @@ Please adjust docs/dev/lsp-extensions.md.\n \n #[test]\n fn files_are_tidy() {\n+    let sh = &Shell::new().unwrap();\n+\n     let files = sourcegen::list_files(&sourcegen::project_root().join(\"crates\"));\n \n     let mut tidy_docs = TidyDocs::default();\n@@ -70,7 +75,7 @@ fn files_are_tidy() {\n         let extension = path.extension().unwrap_or_default().to_str().unwrap_or_default();\n         match extension {\n             \"rs\" => {\n-                let text = read_file(&path).unwrap();\n+                let text = sh.read_file(&path).unwrap();\n                 check_todo(&path, &text);\n                 check_dbg(&path, &text);\n                 check_test_attrs(&path, &text);\n@@ -80,7 +85,7 @@ fn files_are_tidy() {\n                 tidy_marks.visit(&path, &text);\n             }\n             \"toml\" => {\n-                let text = read_file(&path).unwrap();\n+                let text = sh.read_file(&path).unwrap();\n                 check_cargo_toml(&path, text);\n             }\n             _ => (),\n@@ -139,8 +144,10 @@ fn check_cargo_toml(path: &Path, text: String) {\n \n #[test]\n fn check_merge_commits() {\n-    let bors = cmd!(\"git rev-list --merges --author 'bors\\\\[bot\\\\]' HEAD~19..\").read().unwrap();\n-    let all = cmd!(\"git rev-list --merges HEAD~19..\").read().unwrap();\n+    let sh = &Shell::new().unwrap();\n+\n+    let bors = cmd!(sh, \"git rev-list --merges --author 'bors\\\\[bot\\\\]' HEAD~19..\").read().unwrap();\n+    let all = cmd!(sh, \"git rev-list --merges HEAD~19..\").read().unwrap();\n     if bors != all {\n         panic!(\n             \"\n@@ -213,6 +220,8 @@ See https://github.com/rust-lang/rust-clippy/issues/5537 for discussion.\n \n #[test]\n fn check_licenses() {\n+    let sh = &Shell::new().unwrap();\n+\n     let expected = \"\n 0BSD OR MIT OR Apache-2.0\n Apache-2.0\n@@ -235,7 +244,7 @@ Zlib OR Apache-2.0 OR MIT\n     .filter(|it| !it.is_empty())\n     .collect::<Vec<_>>();\n \n-    let meta = cmd!(\"cargo metadata --format-version 1\").read().unwrap();\n+    let meta = cmd!(sh, \"cargo metadata --format-version 1\").read().unwrap();\n     let mut licenses = meta\n         .split(|c| c == ',' || c == '{' || c == '}')\n         .filter(|it| it.contains(r#\"\"license\"\"#))"}, {"sha": "10587d913db2867e6b7f0d42ad0b6e041e453ecd", "filename": "crates/sourcegen/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2FCargo.toml?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -10,4 +10,4 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-xshell = \"0.1\"\n+xshell = \"0.2.0\""}, {"sha": "719b35b630320579e8606c2a48deb9cf3f39079b", "filename": "crates/sourcegen/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fsourcegen%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/crates%2Fsourcegen%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2Fsrc%2Flib.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -11,7 +11,7 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n-use xshell::{cmd, pushenv};\n+use xshell::{cmd, Shell};\n \n pub fn list_rust_files(dir: &Path) -> Vec<PathBuf> {\n     let mut res = list_files(dir);\n@@ -133,8 +133,8 @@ impl fmt::Display for Location {\n     }\n }\n \n-fn ensure_rustfmt() {\n-    let version = cmd!(\"rustfmt --version\").read().unwrap_or_default();\n+fn ensure_rustfmt(sh: &Shell) {\n+    let version = cmd!(sh, \"rustfmt --version\").read().unwrap_or_default();\n     if !version.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n@@ -144,10 +144,11 @@ fn ensure_rustfmt() {\n }\n \n pub fn reformat(text: String) -> String {\n-    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n-    ensure_rustfmt();\n+    let sh = Shell::new().unwrap();\n+    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n+    ensure_rustfmt(&sh);\n     let rustfmt_toml = project_root().join(\"rustfmt.toml\");\n-    let mut stdout = cmd!(\"rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\")\n+    let mut stdout = cmd!(sh, \"rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\")\n         .stdin(text)\n         .read()\n         .unwrap();"}, {"sha": "d9adf88c0276e02cce86e8f4acd636f27576de26", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -10,6 +10,6 @@ rust-version = \"1.57\"\n anyhow = \"1.0.26\"\n flate2 = \"1.0\"\n write-json = \"0.1.0\"\n-xshell = \"0.1\"\n+xshell = \"0.2.0\"\n xflags = \"0.2.1\"\n # Avoid adding more dependencies to this crate"}, {"sha": "3c58fbb76ded10853728e48241d5774dac94328f", "filename": "xtask/src/dist.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fdist.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -5,25 +5,23 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n-use anyhow::Result;\n use flate2::{write::GzEncoder, Compression};\n-use xshell::{cmd, cp, mkdir_p, pushd, pushenv, read_file, rm_rf, write_file};\n+use xshell::{cmd, Shell};\n \n use crate::{date_iso, flags, project_root};\n \n impl flags::Dist {\n-    pub(crate) fn run(self) -> Result<()> {\n-        let stable =\n-            std::env::var(\"GITHUB_REF\").unwrap_or_default().as_str() == \"refs/heads/release\";\n+    pub(crate) fn run(self, sh: &Shell) -> anyhow::Result<()> {\n+        let stable = sh.var(\"GITHUB_REF\").unwrap_or_default().as_str() == \"refs/heads/release\";\n \n         let project_root = project_root();\n         let target = Target::get(&project_root);\n         let dist = project_root.join(\"dist\");\n-        rm_rf(&dist)?;\n-        mkdir_p(&dist)?;\n+        sh.remove_path(&dist)?;\n+        sh.create_dir(&dist)?;\n \n         let release_channel = if stable { \"stable\" } else { \"nightly\" };\n-        dist_server(release_channel, &target)?;\n+        dist_server(sh, release_channel, &target)?;\n \n         if let Some(patch_version) = self.client_patch_version {\n             let version = if stable {\n@@ -32,58 +30,63 @@ impl flags::Dist {\n                 // A hack to make VS Code prefer nightly over stable.\n                 format!(\"0.3.{}\", patch_version)\n             };\n-            let release_tag = if stable { date_iso()? } else { \"nightly\".to_string() };\n-            dist_client(&version, &release_tag, &target)?;\n+            let release_tag = if stable { date_iso(sh)? } else { \"nightly\".to_string() };\n+            dist_client(sh, &version, &release_tag, &target)?;\n         }\n         Ok(())\n     }\n }\n \n-fn dist_client(version: &str, release_tag: &str, target: &Target) -> Result<()> {\n+fn dist_client(\n+    sh: &Shell,\n+    version: &str,\n+    release_tag: &str,\n+    target: &Target,\n+) -> anyhow::Result<()> {\n     let bundle_path = Path::new(\"editors\").join(\"code\").join(\"server\");\n-    mkdir_p(&bundle_path)?;\n-    cp(&target.server_path, &bundle_path)?;\n+    sh.create_dir(&bundle_path)?;\n+    sh.copy_file(&target.server_path, &bundle_path)?;\n     if let Some(symbols_path) = &target.symbols_path {\n-        cp(symbols_path, &bundle_path)?;\n+        sh.copy_file(symbols_path, &bundle_path)?;\n     }\n \n-    let _d = pushd(\"./editors/code\")?;\n+    let _d = sh.push_dir(\"./editors/code\");\n \n-    let mut patch = Patch::new(\"./package.json\")?;\n+    let mut patch = Patch::new(sh, \"./package.json\")?;\n     patch\n         .replace(r#\"\"version\": \"0.4.0-dev\"\"#, &format!(r#\"\"version\": \"{}\"\"#, version))\n         .replace(r#\"\"releaseTag\": null\"#, &format!(r#\"\"releaseTag\": \"{}\"\"#, release_tag))\n         .replace(r#\"\"$generated-start\": {},\"#, \"\")\n         .replace(\",\\n                \\\"$generated-end\\\": {}\", \"\")\n         .replace(r#\"\"enabledApiProposals\": [],\"#, r#\"\"#);\n-    patch.commit()?;\n+    patch.commit(sh)?;\n \n     Ok(())\n }\n \n-fn dist_server(release_channel: &str, target: &Target) -> Result<()> {\n-    let _e = pushenv(\"RUST_ANALYZER_CHANNEL\", release_channel);\n-    let _e = pushenv(\"CARGO_PROFILE_RELEASE_LTO\", \"thin\");\n+fn dist_server(sh: &Shell, release_channel: &str, target: &Target) -> anyhow::Result<()> {\n+    let _e = sh.push_env(\"RUST_ANALYZER_CHANNEL\", release_channel);\n+    let _e = sh.push_env(\"CARGO_PROFILE_RELEASE_LTO\", \"thin\");\n \n     // Uncomment to enable debug info for releases. Note that:\n     //   * debug info is split on windows and macs, so it does nothing for those platforms,\n     //   * on Linux, this blows up the binary size from 8MB to 43MB, which is unreasonable.\n-    // let _e = pushenv(\"CARGO_PROFILE_RELEASE_DEBUG\", \"1\");\n+    // let _e = sh.push_env(\"CARGO_PROFILE_RELEASE_DEBUG\", \"1\");\n \n     if target.name.contains(\"-linux-\") {\n         env::set_var(\"CC\", \"clang\");\n     }\n \n     let target_name = &target.name;\n-    cmd!(\"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --target {target_name} --release\").run()?;\n+    cmd!(sh, \"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --target {target_name} --release\").run()?;\n \n     let dst = Path::new(\"dist\").join(&target.artifact_name);\n     gzip(&target.server_path, &dst.with_extension(\"gz\"))?;\n \n     Ok(())\n }\n \n-fn gzip(src_path: &Path, dest_path: &Path) -> Result<()> {\n+fn gzip(src_path: &Path, dest_path: &Path) -> anyhow::Result<()> {\n     let mut encoder = GzEncoder::new(File::create(dest_path)?, Compression::best());\n     let mut input = io::BufReader::new(File::open(src_path)?);\n     io::copy(&mut input, &mut encoder)?;\n@@ -133,9 +136,9 @@ struct Patch {\n }\n \n impl Patch {\n-    fn new(path: impl Into<PathBuf>) -> Result<Patch> {\n+    fn new(sh: &Shell, path: impl Into<PathBuf>) -> anyhow::Result<Patch> {\n         let path = path.into();\n-        let contents = read_file(&path)?;\n+        let contents = sh.read_file(&path)?;\n         Ok(Patch { path, original_contents: contents.clone(), contents })\n     }\n \n@@ -145,8 +148,8 @@ impl Patch {\n         self\n     }\n \n-    fn commit(&self) -> Result<()> {\n-        write_file(&self.path, &self.contents)?;\n+    fn commit(&self, sh: &Shell) -> anyhow::Result<()> {\n+        sh.write_file(&self.path, &self.contents)?;\n         Ok(())\n     }\n }"}, {"sha": "ae978d5512e7b8f164b8fb42886e15458e58650f", "filename": "xtask/src/install.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Finstall.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -3,20 +3,20 @@\n use std::{env, path::PathBuf, str};\n \n use anyhow::{bail, format_err, Context, Result};\n-use xshell::{cmd, pushd};\n+use xshell::{cmd, Shell};\n \n use crate::flags;\n \n impl flags::Install {\n-    pub(crate) fn run(self) -> Result<()> {\n+    pub(crate) fn run(self, sh: &Shell) -> Result<()> {\n         if cfg!(target_os = \"macos\") {\n-            fix_path_for_mac().context(\"Fix path for mac\")?;\n+            fix_path_for_mac(sh).context(\"Fix path for mac\")?;\n         }\n         if let Some(server) = self.server() {\n-            install_server(server).context(\"install server\")?;\n+            install_server(sh, server).context(\"install server\")?;\n         }\n         if let Some(client) = self.client() {\n-            install_client(client).context(\"install client\")?;\n+            install_client(sh, client).context(\"install client\")?;\n         }\n         Ok(())\n     }\n@@ -39,15 +39,14 @@ pub(crate) enum Malloc {\n     Jemalloc,\n }\n \n-fn fix_path_for_mac() -> Result<()> {\n+fn fix_path_for_mac(sh: &Shell) -> Result<()> {\n     let mut vscode_path: Vec<PathBuf> = {\n         const COMMON_APP_PATH: &str =\n             r\"/Applications/Visual Studio Code.app/Contents/Resources/app/bin\";\n         const ROOT_DIR: &str = \"\";\n-        let home_dir = match env::var(\"HOME\") {\n-            Ok(home) => home,\n-            Err(e) => bail!(\"Failed getting HOME from environment with error: {}.\", e),\n-        };\n+        let home_dir = sh.var(\"HOME\").map_err(|err| {\n+            format_err!(\"Failed getting HOME from environment with error: {}.\", err)\n+        })?;\n \n         [ROOT_DIR, &home_dir]\n             .into_iter()\n@@ -58,36 +57,33 @@ fn fix_path_for_mac() -> Result<()> {\n     };\n \n     if !vscode_path.is_empty() {\n-        let vars = match env::var_os(\"PATH\") {\n-            Some(path) => path,\n-            None => bail!(\"Could not get PATH variable from env.\"),\n-        };\n+        let vars = sh.var_os(\"PATH\").context(\"Could not get PATH variable from env.\")?;\n \n         let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n         paths.append(&mut vscode_path);\n         let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n-        env::set_var(\"PATH\", &new_paths);\n+        sh.set_var(\"PATH\", &new_paths);\n     }\n \n     Ok(())\n }\n \n-fn install_client(client_opt: ClientOpt) -> Result<()> {\n-    let _dir = pushd(\"./editors/code\");\n+fn install_client(sh: &Shell, client_opt: ClientOpt) -> Result<()> {\n+    let _dir = sh.push_dir(\"./editors/code\");\n \n     // Package extension.\n     if cfg!(unix) {\n-        cmd!(\"npm --version\").run().context(\"`npm` is required to build the VS Code plugin\")?;\n-        cmd!(\"npm ci\").run()?;\n+        cmd!(sh, \"npm --version\").run().context(\"`npm` is required to build the VS Code plugin\")?;\n+        cmd!(sh, \"npm ci\").run()?;\n \n-        cmd!(\"npm run package --scripts-prepend-node-path\").run()?;\n+        cmd!(sh, \"npm run package --scripts-prepend-node-path\").run()?;\n     } else {\n-        cmd!(\"cmd.exe /c npm --version\")\n+        cmd!(sh, \"cmd.exe /c npm --version\")\n             .run()\n             .context(\"`npm` is required to build the VS Code plugin\")?;\n-        cmd!(\"cmd.exe /c npm ci\").run()?;\n+        cmd!(sh, \"cmd.exe /c npm ci\").run()?;\n \n-        cmd!(\"cmd.exe /c npm run package\").run()?;\n+        cmd!(sh, \"cmd.exe /c npm run package\").run()?;\n     };\n \n     // Find the appropriate VS Code binary.\n@@ -104,9 +100,9 @@ fn install_client(client_opt: ClientOpt) -> Result<()> {\n         .copied()\n         .find(|&bin| {\n             if cfg!(unix) {\n-                cmd!(\"{bin} --version\").read().is_ok()\n+                cmd!(sh, \"{bin} --version\").read().is_ok()\n             } else {\n-                cmd!(\"cmd.exe /c {bin}.cmd --version\").read().is_ok()\n+                cmd!(sh, \"cmd.exe /c {bin}.cmd --version\").read().is_ok()\n             }\n         })\n         .ok_or_else(|| {\n@@ -115,11 +111,11 @@ fn install_client(client_opt: ClientOpt) -> Result<()> {\n \n     // Install & verify.\n     let installed_extensions = if cfg!(unix) {\n-        cmd!(\"{code} --install-extension rust-analyzer.vsix --force\").run()?;\n-        cmd!(\"{code} --list-extensions\").read()?\n+        cmd!(sh, \"{code} --install-extension rust-analyzer.vsix --force\").run()?;\n+        cmd!(sh, \"{code} --list-extensions\").read()?\n     } else {\n-        cmd!(\"cmd.exe /c {code}.cmd --install-extension rust-analyzer.vsix --force\").run()?;\n-        cmd!(\"cmd.exe /c {code}.cmd --list-extensions\").read()?\n+        cmd!(sh, \"cmd.exe /c {code}.cmd --install-extension rust-analyzer.vsix --force\").run()?;\n+        cmd!(sh, \"cmd.exe /c {code}.cmd --list-extensions\").read()?\n     };\n \n     if !installed_extensions.contains(\"rust-analyzer\") {\n@@ -133,14 +129,14 @@ fn install_client(client_opt: ClientOpt) -> Result<()> {\n     Ok(())\n }\n \n-fn install_server(opts: ServerOpt) -> Result<()> {\n+fn install_server(sh: &Shell, opts: ServerOpt) -> Result<()> {\n     let features = match opts.malloc {\n         Malloc::System => &[][..],\n         Malloc::Mimalloc => &[\"--features\", \"mimalloc\"],\n         Malloc::Jemalloc => &[\"--features\", \"jemalloc\"],\n     };\n \n-    let cmd = cmd!(\"cargo install --path crates/rust-analyzer --locked --force --features force-always-assert {features...}\");\n+    let cmd = cmd!(sh, \"cargo install --path crates/rust-analyzer --locked --force --features force-always-assert {features...}\");\n     cmd.run()?;\n     Ok(())\n }"}, {"sha": "df726dc23cbab2fa8e56686e5aab02e44047375d", "filename": "xtask/src/main.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -14,34 +14,38 @@ mod release;\n mod dist;\n mod metrics;\n \n-use anyhow::{bail, Result};\n+use anyhow::bail;\n use std::{\n     env,\n     path::{Path, PathBuf},\n };\n-use xshell::{cmd, cp, pushd, pushenv};\n+use xshell::{cmd, Shell};\n \n-fn main() -> Result<()> {\n-    let _d = pushd(project_root())?;\n+fn main() -> anyhow::Result<()> {\n+    let sh = &Shell::new()?;\n+    sh.change_dir(project_root());\n \n     let flags = flags::Xtask::from_env()?;\n     match flags.subcommand {\n         flags::XtaskCmd::Help(_) => {\n             println!(\"{}\", flags::Xtask::HELP);\n             Ok(())\n         }\n-        flags::XtaskCmd::Install(cmd) => cmd.run(),\n-        flags::XtaskCmd::FuzzTests(_) => run_fuzzer(),\n-        flags::XtaskCmd::Release(cmd) => cmd.run(),\n-        flags::XtaskCmd::Promote(cmd) => cmd.run(),\n-        flags::XtaskCmd::Dist(cmd) => cmd.run(),\n-        flags::XtaskCmd::Metrics(cmd) => cmd.run(),\n+        flags::XtaskCmd::Install(cmd) => cmd.run(sh),\n+        flags::XtaskCmd::FuzzTests(_) => run_fuzzer(sh),\n+        flags::XtaskCmd::Release(cmd) => cmd.run(sh),\n+        flags::XtaskCmd::Promote(cmd) => cmd.run(sh),\n+        flags::XtaskCmd::Dist(cmd) => cmd.run(sh),\n+        flags::XtaskCmd::Metrics(cmd) => cmd.run(sh),\n         flags::XtaskCmd::Bb(cmd) => {\n             {\n-                let _d = pushd(\"./crates/rust-analyzer\")?;\n-                cmd!(\"cargo build --release --features jemalloc\").run()?;\n+                let _d = sh.push_dir(\"./crates/rust-analyzer\");\n+                cmd!(sh, \"cargo build --release --features jemalloc\").run()?;\n             }\n-            cp(\"./target/release/rust-analyzer\", format!(\"./target/rust-analyzer-{}\", cmd.suffix))?;\n+            sh.copy_file(\n+                \"./target/release/rust-analyzer\",\n+                format!(\"./target/rust-analyzer-{}\", cmd.suffix),\n+            )?;\n             Ok(())\n         }\n     }\n@@ -57,25 +61,25 @@ fn project_root() -> PathBuf {\n     .to_path_buf()\n }\n \n-fn run_fuzzer() -> Result<()> {\n-    let _d = pushd(\"./crates/syntax\")?;\n-    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"nightly\");\n-    if cmd!(\"cargo fuzz --help\").read().is_err() {\n-        cmd!(\"cargo install cargo-fuzz\").run()?;\n+fn run_fuzzer(sh: &Shell) -> anyhow::Result<()> {\n+    let _d = sh.push_dir(\"./crates/syntax\");\n+    let _e = sh.push_env(\"RUSTUP_TOOLCHAIN\", \"nightly\");\n+    if cmd!(sh, \"cargo fuzz --help\").read().is_err() {\n+        cmd!(sh, \"cargo install cargo-fuzz\").run()?;\n     };\n \n     // Expecting nightly rustc\n-    let out = cmd!(\"rustc --version\").read()?;\n+    let out = cmd!(sh, \"rustc --version\").read()?;\n     if !out.contains(\"nightly\") {\n         bail!(\"fuzz tests require nightly rustc\")\n     }\n \n-    cmd!(\"cargo fuzz run parser\").run()?;\n+    cmd!(sh, \"cargo fuzz run parser\").run()?;\n     Ok(())\n }\n \n-fn date_iso() -> Result<String> {\n-    let res = cmd!(\"date -u +%Y-%m-%d\").read()?;\n+fn date_iso(sh: &Shell) -> anyhow::Result<String> {\n+    let res = cmd!(sh, \"date -u +%Y-%m-%d\").read()?;\n     Ok(res)\n }\n "}, {"sha": "b683b32e6d5d2033750387c883cec1a3a310ba51", "filename": "xtask/src/metrics.rs", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmetrics.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -1,95 +1,103 @@\n use std::{\n     collections::BTreeMap,\n-    env,\n+    env, fs,\n     io::Write as _,\n     path::Path,\n     time::{Instant, SystemTime, UNIX_EPOCH},\n };\n \n-use anyhow::{bail, format_err, Result};\n-use xshell::{cmd, mkdir_p, pushd, pushenv, read_file, rm_rf};\n+use anyhow::{bail, format_err};\n+use xshell::{cmd, Shell};\n \n use crate::flags;\n \n type Unit = String;\n \n impl flags::Metrics {\n-    pub(crate) fn run(self) -> Result<()> {\n-        let mut metrics = Metrics::new()?;\n+    pub(crate) fn run(self, sh: &Shell) -> anyhow::Result<()> {\n+        let mut metrics = Metrics::new(sh)?;\n         if !self.dry_run {\n-            rm_rf(\"./target/release\")?;\n+            sh.remove_path(\"./target/release\")?;\n         }\n         if !Path::new(\"./target/rustc-perf\").exists() {\n-            mkdir_p(\"./target/rustc-perf\")?;\n-            cmd!(\"git clone https://github.com/rust-lang/rustc-perf.git ./target/rustc-perf\")\n+            sh.create_dir(\"./target/rustc-perf\")?;\n+            cmd!(sh, \"git clone https://github.com/rust-lang/rustc-perf.git ./target/rustc-perf\")\n                 .run()?;\n         }\n         {\n-            let _d = pushd(\"./target/rustc-perf\")?;\n+            let _d = sh.push_dir(\"./target/rustc-perf\");\n             let revision = &metrics.perf_revision;\n-            cmd!(\"git reset --hard {revision}\").run()?;\n+            cmd!(sh, \"git reset --hard {revision}\").run()?;\n         }\n \n-        let _env = pushenv(\"RA_METRICS\", \"1\");\n+        let _env = sh.push_env(\"RA_METRICS\", \"1\");\n \n         {\n             // https://github.com/rust-analyzer/rust-analyzer/issues/9997\n-            let _d = pushd(\"target/rustc-perf/collector/benchmarks/webrender\")?;\n-            cmd!(\"cargo update -p url --precise 1.6.1\").run()?;\n+            let _d = sh.push_dir(\"target/rustc-perf/collector/benchmarks/webrender\");\n+            cmd!(sh, \"cargo update -p url --precise 1.6.1\").run()?;\n         }\n-        metrics.measure_build()?;\n-        metrics.measure_analysis_stats_self()?;\n-        metrics.measure_analysis_stats(\"ripgrep\")?;\n-        metrics.measure_analysis_stats(\"webrender\")?;\n-        metrics.measure_analysis_stats(\"diesel/diesel\")?;\n+        metrics.measure_build(sh)?;\n+        metrics.measure_analysis_stats_self(sh)?;\n+        metrics.measure_analysis_stats(sh, \"ripgrep\")?;\n+        metrics.measure_analysis_stats(sh, \"webrender\")?;\n+        metrics.measure_analysis_stats(sh, \"diesel/diesel\")?;\n \n         if !self.dry_run {\n-            let _d = pushd(\"target\")?;\n+            let _d = sh.push_dir(\"target\");\n             let metrics_token = env::var(\"METRICS_TOKEN\").unwrap();\n             cmd!(\n+                sh,\n                 \"git clone --depth 1 https://{metrics_token}@github.com/rust-analyzer/metrics.git\"\n             )\n             .run()?;\n-            let _d = pushd(\"metrics\")?;\n+            let _d = sh.push_dir(\"metrics\");\n \n-            let mut file = std::fs::OpenOptions::new().append(true).open(\"metrics.json\")?;\n+            let mut file = fs::File::options().append(true).open(\"metrics.json\")?;\n             writeln!(file, \"{}\", metrics.json())?;\n-            cmd!(\"git add .\").run()?;\n-            cmd!(\"git -c user.name=Bot -c user.email=dummy@example.com commit --message \ud83d\udcc8\")\n+            cmd!(sh, \"git add .\").run()?;\n+            cmd!(sh, \"git -c user.name=Bot -c user.email=dummy@example.com commit --message \ud83d\udcc8\")\n                 .run()?;\n-            cmd!(\"git push origin master\").run()?;\n+            cmd!(sh, \"git push origin master\").run()?;\n         }\n-        eprintln!(\"{:#?}\", metrics);\n+        eprintln!(\"{metrics:#?}\");\n         Ok(())\n     }\n }\n \n impl Metrics {\n-    fn measure_build(&mut self) -> Result<()> {\n+    fn measure_build(&mut self, sh: &Shell) -> anyhow::Result<()> {\n         eprintln!(\"\\nMeasuring build\");\n-        cmd!(\"cargo fetch\").run()?;\n+        cmd!(sh, \"cargo fetch\").run()?;\n \n         let time = Instant::now();\n-        cmd!(\"cargo build --release --package rust-analyzer --bin rust-analyzer\").run()?;\n+        cmd!(sh, \"cargo build --release --package rust-analyzer --bin rust-analyzer\").run()?;\n         let time = time.elapsed();\n         self.report(\"build\", time.as_millis() as u64, \"ms\".into());\n         Ok(())\n     }\n-    fn measure_analysis_stats_self(&mut self) -> Result<()> {\n-        self.measure_analysis_stats_path(\"self\", \".\")\n+    fn measure_analysis_stats_self(&mut self, sh: &Shell) -> anyhow::Result<()> {\n+        self.measure_analysis_stats_path(sh, \"self\", \".\")\n     }\n-    fn measure_analysis_stats(&mut self, bench: &str) -> Result<()> {\n+    fn measure_analysis_stats(&mut self, sh: &Shell, bench: &str) -> anyhow::Result<()> {\n         self.measure_analysis_stats_path(\n+            sh,\n             bench,\n             &format!(\"./target/rustc-perf/collector/benchmarks/{}\", bench),\n         )\n     }\n-    fn measure_analysis_stats_path(&mut self, name: &str, path: &str) -> Result<()> {\n-        eprintln!(\"\\nMeasuring analysis-stats/{}\", name);\n-        let output = cmd!(\"./target/release/rust-analyzer -q analysis-stats --memory-usage {path}\")\n-            .read()?;\n+    fn measure_analysis_stats_path(\n+        &mut self,\n+        sh: &Shell,\n+        name: &str,\n+        path: &str,\n+    ) -> anyhow::Result<()> {\n+        eprintln!(\"\\nMeasuring analysis-stats/{name}\");\n+        let output =\n+            cmd!(sh, \"./target/release/rust-analyzer -q analysis-stats --memory-usage {path}\")\n+                .read()?;\n         for (metric, value, unit) in parse_metrics(&output) {\n-            self.report(&format!(\"analysis-stats/{}/{}\", name, metric), value, unit.into());\n+            self.report(&format!(\"analysis-stats/{name}/{metric}\"), value, unit.into());\n         }\n         Ok(())\n     }\n@@ -125,10 +133,10 @@ struct Host {\n }\n \n impl Metrics {\n-    fn new() -> Result<Metrics> {\n-        let host = Host::new()?;\n+    fn new(sh: &Shell) -> anyhow::Result<Metrics> {\n+        let host = Host::new(sh)?;\n         let timestamp = SystemTime::now();\n-        let revision = cmd!(\"git rev-parse HEAD\").read()?;\n+        let revision = cmd!(sh, \"git rev-parse HEAD\").read()?;\n         let perf_revision = \"c52ee623e231e7690a93be88d943016968c1036b\".into();\n         Ok(Metrics { host, timestamp, revision, perf_revision, metrics: BTreeMap::new() })\n     }\n@@ -157,28 +165,29 @@ impl Metrics {\n }\n \n impl Host {\n-    fn new() -> Result<Host> {\n+    fn new(sh: &Shell) -> anyhow::Result<Host> {\n         if cfg!(not(target_os = \"linux\")) {\n             bail!(\"can only collect metrics on Linux \");\n         }\n \n-        let os = read_field(\"/etc/os-release\", \"PRETTY_NAME=\")?.trim_matches('\"').to_string();\n+        let os = read_field(sh, \"/etc/os-release\", \"PRETTY_NAME=\")?.trim_matches('\"').to_string();\n \n-        let cpu =\n-            read_field(\"/proc/cpuinfo\", \"model name\")?.trim_start_matches(':').trim().to_string();\n+        let cpu = read_field(sh, \"/proc/cpuinfo\", \"model name\")?\n+            .trim_start_matches(':')\n+            .trim()\n+            .to_string();\n \n-        let mem = read_field(\"/proc/meminfo\", \"MemTotal:\")?;\n+        let mem = read_field(sh, \"/proc/meminfo\", \"MemTotal:\")?;\n \n         return Ok(Host { os, cpu, mem });\n \n-        fn read_field(path: &str, field: &str) -> Result<String> {\n-            let text = read_file(path)?;\n+        fn read_field(sh: &Shell, path: &str, field: &str) -> anyhow::Result<String> {\n+            let text = sh.read_file(path)?;\n \n-            let line = text\n-                .lines()\n-                .find(|it| it.starts_with(field))\n-                .ok_or_else(|| format_err!(\"can't parse {}\", path))?;\n-            Ok(line[field.len()..].trim().to_string())\n+            text.lines()\n+                .find_map(|it| it.strip_prefix(field))\n+                .map(|it| it.trim().to_string())\n+                .ok_or_else(|| format_err!(\"can't parse {}\", path))\n         }\n     }\n     fn to_json(&self, mut obj: write_json::Object<'_>) {"}, {"sha": "9bd5d9d3107402d3e9dd8ad3b9675c81bf8f7500", "filename": "xtask/src/release.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Frelease.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -1,15 +1,15 @@\n mod changelog;\n \n-use xshell::{cmd, pushd, read_dir, read_file, write_file};\n+use xshell::{cmd, Shell};\n \n-use crate::{date_iso, flags, is_release_tag, project_root, Result};\n+use crate::{date_iso, flags, is_release_tag, project_root};\n \n impl flags::Release {\n-    pub(crate) fn run(self) -> Result<()> {\n+    pub(crate) fn run(self, sh: &Shell) -> anyhow::Result<()> {\n         if !self.dry_run {\n-            cmd!(\"git switch release\").run()?;\n-            cmd!(\"git fetch upstream --tags --force\").run()?;\n-            cmd!(\"git reset --hard tags/nightly\").run()?;\n+            cmd!(sh, \"git switch release\").run()?;\n+            cmd!(sh, \"git fetch upstream --tags --force\").run()?;\n+            cmd!(sh, \"git reset --hard tags/nightly\").run()?;\n             // The `release` branch sometimes has a couple of cherry-picked\n             // commits for patch releases. If that's the case, just overwrite\n             // it. As we are setting `release` branch to an up-to-date `nightly`\n@@ -19,24 +19,24 @@ impl flags::Release {\n             // commits -- they'll be kept alive by the tag. More generally, we\n             // don't care about historic releases all that much, it's fine even\n             // to delete old tags.\n-            cmd!(\"git push --force\").run()?;\n+            cmd!(sh, \"git push --force\").run()?;\n         }\n \n         // Generates bits of manual.adoc.\n-        cmd!(\"cargo test -p ide_assists -p ide_diagnostics -p rust-analyzer -- sourcegen_\")\n+        cmd!(sh, \"cargo test -p ide_assists -p ide_diagnostics -p rust-analyzer -- sourcegen_\")\n             .run()?;\n \n         let website_root = project_root().join(\"../rust-analyzer.github.io\");\n         {\n-            let _dir = pushd(&website_root)?;\n-            cmd!(\"git switch src\").run()?;\n-            cmd!(\"git pull\").run()?;\n+            let _dir = sh.push_dir(&website_root);\n+            cmd!(sh, \"git switch src\").run()?;\n+            cmd!(sh, \"git pull\").run()?;\n         }\n         let changelog_dir = website_root.join(\"./thisweek/_posts\");\n \n-        let today = date_iso()?;\n-        let commit = cmd!(\"git rev-parse HEAD\").read()?;\n-        let changelog_n = read_dir(changelog_dir.as_path())?.len();\n+        let today = date_iso(sh)?;\n+        let commit = cmd!(sh, \"git rev-parse HEAD\").read()?;\n+        let changelog_n = sh.read_dir(changelog_dir.as_path())?.len();\n \n         for adoc in [\n             \"manual.adoc\",\n@@ -48,42 +48,46 @@ impl flags::Release {\n             let src = project_root().join(\"./docs/user/\").join(adoc);\n             let dst = website_root.join(adoc);\n \n-            let contents = read_file(src)?;\n-            write_file(dst, contents)?;\n+            let contents = sh.read_file(src)?;\n+            sh.write_file(dst, contents)?;\n         }\n \n-        let tags = cmd!(\"git tag --list\").read()?;\n+        let tags = cmd!(sh, \"git tag --list\").read()?;\n         let prev_tag = tags.lines().filter(|line| is_release_tag(line)).last().unwrap();\n \n-        let contents = changelog::get_changelog(changelog_n, &commit, prev_tag, &today)?;\n+        let contents = changelog::get_changelog(sh, changelog_n, &commit, prev_tag, &today)?;\n         let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n-        write_file(&path, &contents)?;\n+        sh.write_file(&path, &contents)?;\n \n         Ok(())\n     }\n }\n \n impl flags::Promote {\n-    pub(crate) fn run(self) -> Result<()> {\n-        let _dir = pushd(\"../rust-rust-analyzer\")?;\n-        cmd!(\"git switch master\").run()?;\n-        cmd!(\"git fetch upstream\").run()?;\n-        cmd!(\"git reset --hard upstream/master\").run()?;\n-        cmd!(\"git submodule update --recursive\").run()?;\n+    pub(crate) fn run(self, sh: &Shell) -> anyhow::Result<()> {\n+        let _dir = sh.push_dir(\"../rust-rust-analyzer\");\n+        cmd!(sh, \"git switch master\").run()?;\n+        cmd!(sh, \"git fetch upstream\").run()?;\n+        cmd!(sh, \"git reset --hard upstream/master\").run()?;\n+        cmd!(sh, \"git submodule update --recursive\").run()?;\n \n-        let branch = format!(\"rust-analyzer-{}\", date_iso()?);\n-        cmd!(\"git switch -c {branch}\").run()?;\n+        let date = date_iso(sh)?;\n+        let branch = format!(\"rust-analyzer-{date}\");\n+        cmd!(sh, \"git switch -c {branch}\").run()?;\n         {\n-            let _dir = pushd(\"src/tools/rust-analyzer\")?;\n-            cmd!(\"git fetch origin\").run()?;\n-            cmd!(\"git reset --hard origin/release\").run()?;\n+            let _dir = sh.push_dir(\"src/tools/rust-analyzer\");\n+            cmd!(sh, \"git fetch origin\").run()?;\n+            cmd!(sh, \"git reset --hard origin/release\").run()?;\n         }\n-        cmd!(\"git add src/tools/rust-analyzer\").run()?;\n-        cmd!(\"git commit -m':arrow_up: rust-analyzer'\").run()?;\n+        cmd!(sh, \"git add src/tools/rust-analyzer\").run()?;\n+        cmd!(sh, \"git commit -m':arrow_up: rust-analyzer'\").run()?;\n         if !self.dry_run {\n-            cmd!(\"git push -u origin {branch}\").run()?;\n-            cmd!(\"xdg-open https://github.com/matklad/rust/pull/new/{branch}?body=r%3F%20%40ghost\")\n-                .run()?;\n+            cmd!(sh, \"git push -u origin {branch}\").run()?;\n+            cmd!(\n+                sh,\n+                \"xdg-open https://github.com/matklad/rust/pull/new/{branch}?body=r%3F%20%40ghost\"\n+            )\n+            .run()?;\n         }\n         Ok(())\n     }"}, {"sha": "ceef9fac2d6098e406e08f63bd5449eed8b079fb", "filename": "xtask/src/release/changelog.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Frelease%2Fchangelog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e43c34e7c56fe3c72e02c3d7d9261c73071f61/xtask%2Fsrc%2Frelease%2Fchangelog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Frelease%2Fchangelog.rs?ref=56e43c34e7c56fe3c72e02c3d7d9261c73071f61", "patch": "@@ -1,16 +1,17 @@\n use std::fmt::Write;\n use std::{env, iter};\n \n-use anyhow::{bail, Result};\n-use xshell::cmd;\n+use anyhow::bail;\n+use xshell::{cmd, Shell};\n \n pub(crate) fn get_changelog(\n+    sh: &Shell,\n     changelog_n: usize,\n     commit: &str,\n     prev_tag: &str,\n     today: &str,\n-) -> Result<String> {\n-    let git_log = cmd!(\"git log {prev_tag}..HEAD --merges --reverse\").read()?;\n+) -> anyhow::Result<String> {\n+    let git_log = cmd!(sh, \"git log {prev_tag}..HEAD --merges --reverse\").read()?;\n     let mut features = String::new();\n     let mut fixes = String::new();\n     let mut internal = String::new();\n@@ -30,14 +31,15 @@ pub(crate) fn get_changelog(\n \n                 // we don't use an HTTPS client or JSON parser to keep the build times low\n                 let pr_json =\n-                    cmd!(\"curl -s -H {accept} -H {authorization} {pr_url}/{pr}\").read()?;\n-                let pr_title = cmd!(\"jq .title\").stdin(&pr_json).read()?;\n+                    cmd!(sh, \"curl -s -H {accept} -H {authorization} {pr_url}/{pr}\").read()?;\n+                let pr_title = cmd!(sh, \"jq .title\").stdin(&pr_json).read()?;\n                 let pr_title = unescape(&pr_title[1..pr_title.len() - 1]);\n-                let pr_comment = cmd!(\"jq .body\").stdin(pr_json).read()?;\n+                let pr_comment = cmd!(sh, \"jq .body\").stdin(pr_json).read()?;\n \n                 let comments_json =\n-                    cmd!(\"curl -s -H {accept} -H {authorization} {pr_url}/{pr}/comments\").read()?;\n-                let pr_comments = cmd!(\"jq .[].body\").stdin(comments_json).read()?;\n+                    cmd!(sh, \"curl -s -H {accept} -H {authorization} {pr_url}/{pr}/comments\")\n+                        .read()?;\n+                let pr_comments = cmd!(sh, \"jq .[].body\").stdin(comments_json).read()?;\n \n                 let l = iter::once(pr_comment.as_str())\n                     .chain(pr_comments.lines())"}]}