{"sha": "af385799e0d5483170973a79110bdb1ce2949579", "node_id": "C_kwDOAAsO6NoAKGFmMzg1Nzk5ZTBkNTQ4MzE3MDk3M2E3OTExMGJkYjFjZTI5NDk1Nzk", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-01-21T15:55:26Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-06-06T14:15:53Z"}, "message": "Move internal documentation to book", "tree": {"sha": "254d1931ecf96953f7b4498e231d0073274bdb35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/254d1931ecf96953f7b4498e231d0073274bdb35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af385799e0d5483170973a79110bdb1ce2949579", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmKeDBkACgkQHKDfKvWd\naKWqCw/+KtgMAa1X7p1m4C2fqD4X/3KaFz7xVqW0N8B1tvEdcdGQ5yMxm8jxbPR3\n6Zo0Cy7WHotPMkVHTxTzJDc702QzQ2GXm/pFmvC9FKOIzQzdfkmfmmEnwGtkNNT/\n0EPaZP81Sih4IyYz1QOWVtQKRvitJkDeBsaWSnmabmj00YlRKPFTByLIeJmp3fEt\nm0S6UM7UPtQz+9pL3Wq4MaGwDans/dizsDo7rezt2Y2pvakBtDl48m8iw3oJkd1X\n717QJqAWI5pfLi8WraZeE2Ws1u5mH6C7qHI9IM6TyBsc3gbZ15gIl/oK40Virelu\nrjCnF3gd8+ZPaiMruCguu2dGeYcHvpVyiNU1yXvIHHucKX106A6RawTndEgeweB+\nuGVjup/2+um+q9L4Q6UQrwNYH1syur2HNmqmxlfkrI1/tI2N1l5tCcMa/sz6pmhw\noSRijtAy4/SHJIt3TjzqRjZpOUfx8524u+WNp7aqlAIB30okOmCmwoKXvKCFWxHr\nHr51Uq1FMcKM2kqc9orclVDctMuOfDDP70sPjyX2l+l4Y5I+ZEwrYyK4Zx4vi9I1\nKjrJZSFoPwdkKWAmG8Ge3YWf+w945PHmLaFPjdpLIHbW0VGPlkAUVAnXcELgCnRJ\n/KDTRmTirgQbCS9BPSEh4BVub5SSwfih3Riv+mWA9a6Wv1hNP6M=\n=oO3z\n-----END PGP SIGNATURE-----", "payload": "tree 254d1931ecf96953f7b4498e231d0073274bdb35\nparent 853d7eeed688eb8eab9cf88d8189006e712af6ca\nauthor flip1995 <philipp.krones@embecosm.com> 1642780526 +0100\ncommitter Philipp Krones <hello@philkrones.com> 1654524953 +0200\n\nMove internal documentation to book\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af385799e0d5483170973a79110bdb1ce2949579", "html_url": "https://github.com/rust-lang/rust/commit/af385799e0d5483170973a79110bdb1ce2949579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af385799e0d5483170973a79110bdb1ce2949579/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "853d7eeed688eb8eab9cf88d8189006e712af6ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/853d7eeed688eb8eab9cf88d8189006e712af6ca", "html_url": "https://github.com/rust-lang/rust/commit/853d7eeed688eb8eab9cf88d8189006e712af6ca"}], "stats": {"total": 2098, "additions": 263, "deletions": 1835}, "files": [{"sha": "3e0b1c5c4f782c3d55afab4ee2734b2451a1333c", "filename": "book/src/development/adding_lints.md", "status": "modified", "additions": 76, "deletions": 49, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fadding_lints.md?ref=af385799e0d5483170973a79110bdb1ce2949579", "patch": "@@ -11,21 +11,24 @@ because that's clearly a non-descriptive name.\n   - [Setup](#setup)\n   - [Getting Started](#getting-started)\n   - [Testing](#testing)\n+    - [Cargo lints](#cargo-lints)\n   - [Rustfix tests](#rustfix-tests)\n   - [Edition 2018 tests](#edition-2018-tests)\n   - [Testing manually](#testing-manually)\n   - [Lint declaration](#lint-declaration)\n+  - [Lint registration](#lint-registration)\n   - [Lint passes](#lint-passes)\n   - [Emitting a lint](#emitting-a-lint)\n   - [Adding the lint logic](#adding-the-lint-logic)\n   - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n   - [Author lint](#author-lint)\n+  - [Print HIR lint](#print-hir-lint)\n   - [Documentation](#documentation)\n   - [Running rustfmt](#running-rustfmt)\n   - [Debugging](#debugging)\n   - [PR Checklist](#pr-checklist)\n   - [Adding configuration to a lint](#adding-configuration-to-a-lint)\n-  - [Cheatsheet](#cheatsheet)\n+  - [Cheat Sheet](#cheat-sheet)\n \n ## Setup\n \n@@ -42,9 +45,9 @@ take a look at our [lint naming guidelines][lint_naming]. To get started on this\n lint you can run `cargo dev new_lint --name=foo_functions --pass=early\n --category=pedantic` (category will default to nursery if not provided). This\n command will create two files: `tests/ui/foo_functions.rs` and\n-`clippy_lints/src/foo_functions.rs`, as well as run `cargo dev update_lints` to\n-register the new lint. For cargo lints, two project hierarchies (fail/pass) will\n-be created by default under `tests/ui-cargo`.\n+`clippy_lints/src/foo_functions.rs`, as well as\n+[registering the lint](#lint-registration). For cargo lints, two project\n+hierarchies (fail/pass) will be created by default under `tests/ui-cargo`.\n \n Next, we'll open up these files and add our lint!\n \n@@ -155,7 +158,7 @@ Manually testing against an example file can be useful if you have added some\n your local modifications, run\n \n ```\n-env __CLIPPY_INTERNAL_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs\n+cargo dev lint input.rs\n ```\n \n from the working copy root. With tests in place, let's have a look at\n@@ -179,17 +182,15 @@ the auto-generated lint declaration to have a real description, something like t\n \n ```rust\n declare_clippy_lint! {\n-    /// **What it does:**\n+    /// ### What it does\n     ///\n-    /// **Why is this bad?**\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n+    /// ### Why is this bad?\n     ///\n+    /// ### Example\n     /// ```rust\n     /// // example code\n     /// ```\n+    #[clippy::version = \"1.29.0\"]\n     pub FOO_FUNCTIONS,\n     pedantic,\n     \"function named `foo`, which is not a descriptive name\"\n@@ -200,6 +201,10 @@ declare_clippy_lint! {\n   section. This is the default documentation style and will be displayed\n   [like this][example_lint_page]. To render and open this documentation locally\n   in a browser, run `cargo dev serve`.\n+* The `#[clippy::version]` attribute will be rendered as part of the lint documentation.\n+  The value should be set to the current Rust version that the lint is developed in,\n+  it can be retrieved by running `rustc -vV` in the rust-clippy directory. The version\n+  is listed under *release*. (Use the version without the `-nightly`) suffix.\n * `FOO_FUNCTIONS` is the name of our lint. Be sure to follow the\n   [lint naming guidelines][lint_naming] here when naming your lint.\n   In short, the name should state the thing that is being checked for and\n@@ -222,32 +227,34 @@ declare_lint_pass!(FooFunctions => [FOO_FUNCTIONS]);\n impl EarlyLintPass for FooFunctions {}\n ```\n \n-Normally after declaring the lint, we have to run `cargo dev update_lints`,\n-which updates some files, so Clippy knows about the new lint. Since we used\n-`cargo dev new_lint ...` to generate the lint declaration, this was done\n-automatically. While `update_lints` automates most of the things, it doesn't\n-automate everything. We will have to register our lint pass manually in the\n-`register_plugins` function in `clippy_lints/src/lib.rs`:\n+[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60\n+[example_lint_page]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n+[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L110\n+\n+## Lint registration\n+\n+When using `cargo dev new_lint`, the lint is automatically registered and\n+nothing more has to be done.\n+\n+When declaring a new lint by hand and `cargo dev update_lints` is used, the lint\n+pass may have to be registered manually in the `register_plugins` function in\n+`clippy_lints/src/lib.rs`:\n \n ```rust\n-store.register_early_pass(|| box foo_functions::FooFunctions);\n+store.register_early_pass(|| Box::new(foo_functions::FooFunctions));\n ```\n \n As one may expect, there is a corresponding `register_late_pass` method\n available as well. Without a call to one of `register_early_pass` or\n `register_late_pass`, the lint pass in question will not be run.\n \n-One reason that `cargo dev` does not automate this step is that multiple lints\n-can use the same lint pass, so registering the lint pass may already be done\n-when adding a new lint. Another reason that this step is not automated is that\n-the order that the passes are registered determines the order the passes\n-actually run, which in turn affects the order that any emitted lints are output\n-in.\n-\n-[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60\n-[example_lint_page]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n-[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n-[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L110\n+One reason that `cargo dev update_lints` does not automate this step is that\n+multiple lints can use the same lint pass, so registering the lint pass may\n+already be done when adding a new lint. Another reason that this step is not\n+automated is that the order that the passes are registered determines the order\n+the passes actually run, which in turn affects the order that any emitted lints\n+are output in.\n \n ## Lint passes\n \n@@ -425,7 +432,7 @@ The project's MSRV can then be matched against the feature MSRV in the LintPass\n using the `meets_msrv` utility function.\n \n ``` rust\n-if !meets_msrv(self.msrv.as_ref(), &msrvs::STR_STRIP_PREFIX) {\n+if !meets_msrv(self.msrv, msrvs::STR_STRIP_PREFIX) {\n     return;\n }\n ```\n@@ -478,6 +485,19 @@ you are implementing your lint.\n \n [author_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9a12cb60e5c6ad4e3003ac6d5e63cf55\n \n+## Print HIR lint\n+\n+To implement a lint, it's helpful to first understand the internal representation\n+that rustc uses. Clippy has the `#[clippy::dump]` attribute that prints the\n+[_High-Level Intermediate Representation (HIR)_] of the item, statement, or \n+expression that the attribute is attached to. To attach the attribute to expressions\n+you often need to enable `#![feature(stmt_expr_attributes)]`.\n+\n+[Here][print_hir_example] you can find an example, just select _Tools_ and run _Clippy_.\n+\n+[_High-Level Intermediate Representation (HIR)_]: https://rustc-dev-guide.rust-lang.org/hir.html\n+[print_hir_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=daf14db3a7f39ca467cd1b86c34b9afb\n+\n ## Documentation\n \n The final thing before submitting our PR is to add some documentation to our\n@@ -487,21 +507,23 @@ Please document your lint with a doc comment akin to the following:\n \n ```rust\n declare_clippy_lint! {\n-    /// **What it does:** Checks for ... (describe what the lint matches).\n+    /// ### What it does\n+    /// Checks for ... (describe what the lint matches).\n     ///\n-    /// **Why is this bad?** Supply the reason for linting the code.\n+    /// ### Why is this bad?\n+    /// Supply the reason for linting the code.\n     ///\n-    /// **Known problems:** None. (Or describe where it could go wrong.)\n-    ///\n-    /// **Example:**\n+    /// ### Example\n     ///\n     /// ```rust,ignore\n-    /// // Bad\n-    /// Insert a short example of code that triggers the lint\n-    ///\n-    /// // Good\n-    /// Insert a short example of improved code that doesn't trigger the lint\n+    /// // A short example of code that triggers the lint\n     /// ```\n+    /// \n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// // A short example of improved code that doesn't trigger the lint\n+    /// ```\n+    #[clippy::version = \"1.29.0\"]\n     pub FOO_FUNCTIONS,\n     pedantic,\n     \"function named `foo`, which is not a descriptive name\"\n@@ -558,14 +580,16 @@ directory. Adding a configuration to a lint can be useful for thresholds or to c\n behavior that can be seen as a false positive for some users. Adding a configuration is done\n in the following steps:\n \n-1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n+1. Adding a new configuration entry to [clippy_lints::utils::conf](/clippy_lints/src/utils/conf.rs)\n     like this:\n     ```rust\n-    /// Lint: LINT_NAME. <The configuration field doc comment>\n+    /// Lint: LINT_NAME.\n+    ///\n+    /// <The configuration field doc comment>\n     (configuration_ident: Type = DefaultValue),\n     ```\n-    The configuration value and identifier should usually be the same. The doc comment will be\n-    automatically added to the lint documentation.\n+    The doc comment is automatically added to the documentation of the listed lints. The default\n+    value will be formatted using the `Debug` implementation of the type.\n 2. Adding the configuration value to the lint impl struct:\n     1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n         generated with the `declare_lint_pass!` macro. This struct needs to be defined manually\n@@ -626,14 +650,14 @@ in the following steps:\n         with the configuration value and a rust file that should be linted by Clippy. The test can\n         otherwise be written as usual.\n \n-## Cheatsheet\n+## Cheat Sheet\n \n Here are some pointers to things you are likely going to need for every lint:\n \n * [Clippy utils][utils] - Various helper functions. Maybe the function you need\n-  is already in here (`implements_trait`, `match_def_path`, `snippet`, etc)\n+  is already in here ([`is_type_diagnostic_item`], [`implements_trait`], [`snippet`], etc)\n * [Clippy diagnostics][diagnostics]\n-* [The `if_chain` macro][if_chain]\n+* [Let chains][let-chains]\n * [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]\n * [`Span`][span]\n * [`Applicability`][applicability]\n@@ -657,8 +681,11 @@ documentation currently. This is unfortunate, but in most cases you can probably\n get away with copying things from existing similar lints. If you are stuck,\n don't hesitate to ask on [Zulip] or in the issue/PR.\n \n-[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs\n-[if_chain]: https://docs.rs/if_chain/*/if_chain/\n+[utils]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/index.html\n+[`is_type_diagnostic_item`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.is_type_diagnostic_item.html\n+[`implements_trait`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.implements_trait.html\n+[`snippet`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/source/fn.snippet.html\n+[let-chains]: https://github.com/rust-lang/rust/pull/94927\n [from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n [in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html\n [span]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"}, {"sha": "57a90a924ec3cf9fd0a58ab6d3d969a2b1b91ef8", "filename": "book/src/development/basics.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fbasics.md?ref=af385799e0d5483170973a79110bdb1ce2949579", "patch": "@@ -91,15 +91,18 @@ cargo dev fmt\n cargo dev update_lints\n # create a new lint and register it\n cargo dev new_lint\n+# automatically formatting all code before each commit\n+cargo dev setup git-hook\n # (experimental) Setup Clippy to work with IntelliJ-Rust\n-cargo dev ide_setup\n+cargo dev setup intellij\n ```\n+More about intellij command usage and reasons [here](../CONTRIBUTING.md#intellij-rust)\n \n ## lintcheck\n `cargo lintcheck` will build and run clippy on a fixed set of crates and generate a log of the results.  \n-You can `git diff` the updated log against its previous version and \n+You can `git diff` the updated log against its previous version and\n see what impact your lint made on a small set of crates.  \n-If you add a new lint, please audit the resulting warnings and make sure \n+If you add a new lint, please audit the resulting warnings and make sure\n there are no false positives and that the suggestions are valid.\n \n Refer to the tools [README] for more details.\n@@ -167,6 +170,5 @@ rustup component add clippy\n > [proxies](https://rust-lang.github.io/rustup/concepts/proxies.html). That is, `~/.cargo/bin/cargo-clippy` and\n > `~/.cargo/bin/clippy-driver` should be hard or soft links to `~/.cargo/bin/rustup`. You can repair these by running\n > `rustup update`.\n- \n- \n+\n [glossary]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html"}, {"sha": "1d1aee0da2cc7be9c0cd84ad8613f35322df7b81", "filename": "book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 158, "deletions": 95, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=af385799e0d5483170973a79110bdb1ce2949579", "patch": "@@ -4,17 +4,19 @@ You may need following tooltips to catch up with common operations.\n \n - [Common tools for writing lints](#common-tools-for-writing-lints)\n   - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n-  - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n+  - [Checking if an expr is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n+  - [Checking for a specific type](#checking-for-a-specific-type)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n   - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n-  - [Dealing with macros](#dealing-with-macros)\n+  - [Dealing with macros](#dealing-with-macros-and-expansions)\n \n Useful Rustc dev guide links:\n - [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Diagnostic items](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html)\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n-# Retrieving the type of an expression\n+## Retrieving the type of an expression\n \n Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n \n@@ -24,7 +26,7 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - does it implement a trait?\n \n This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n-that gives you access to the underlying structure [`TyS`][TyS].\n+that gives you access to the underlying structure [`Ty`][Ty].\n \n Example of use:\n ```rust\n@@ -53,42 +55,81 @@ Two noticeable items here:\n   created by type checking step, it includes useful information such as types\n   of expressions, ways to resolve methods and so on.\n \n-# Checking if an expr is calling a specific method\n+## Checking if an expr is calling a specific method\n \n Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n \n ```rust\n-impl LateLintPass<'_> for MyStructLint {\n+impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            // Check our expr is calling a method\n-            if let hir::ExprKind::MethodCall(path, _, _args, _) = &expr.kind;\n+        // Check our expr is calling a method\n+        if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind\n             // Check the name of this method is `some_method`\n-            if path.ident.name == sym!(some_method);\n-            then {\n+            && path.ident.name == sym!(some_method)\n+            // Optionally, check the type of the self argument.\n+            // - See \"Checking for a specific type\"\n+        {\n                 // ...\n-            }\n         }\n     }\n }\n ```\n \n-# Checking if a type implements a specific trait\n+## Checking for a specific type\n \n-There are two ways to do this, depending if the target trait is part of lang items.\n+There are three ways to check if an expression type is a specific type we want to check for.\n+All of these methods only check for the base type, generic arguments have to be checked separately.\n \n ```rust\n-use clippy_utils::{implements_trait, match_trait_method, paths};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use clippy_utils::{paths, match_def_path};\n+use rustc_span::symbol::sym;\n+use rustc_hir::LangItem;\n \n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // 1. Using expression and Clippy's convenient method\n-        // we use `match_trait_method` function from Clippy's toolbox\n-        if match_trait_method(cx, expr, &paths::INTO) {\n-            // `expr` implements `Into` trait\n+        // Getting the expression type\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        // 1. Using diagnostic items\n+        // The last argument is the diagnostic item to check for\n+        if is_type_diagnostic_item(cx, ty, sym::Option) {\n+            // The type is an `Option`\n+        }\n+\n+        // 2. Using lang items\n+        if is_type_lang_item(cx, ty, LangItem::RangeFull) {\n+            // The type is a full range like `.drain(..)`\n+        }\n+\n+        // 3. Using the type path\n+        // This method should be avoided if possible\n+        if match_def_path(cx, def_id, &paths::RESULT) {\n+            // The type is a `core::result::Result`\n+        }\n+    }\n+}\n+```\n+\n+Prefer using diagnostic items and lang items where possible.\n+\n+## Checking if a type implements a specific trait\n+\n+There are three ways to do this, depending on if the target trait has a diagnostic item, lang item or neither.\n+\n+```rust\n+use clippy_utils::{implements_trait, is_trait_method, match_trait_method, paths};\n+use rustc_span::symbol::sym;\n+\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // 1. Using diagnostic items with the expression\n+        // we use `is_trait_method` function from Clippy's utils\n+        if is_trait_method(cx, expr, sym::Iterator) {\n+            // method call in `expr` belongs to `Iterator` trait\n         }\n \n-        // 2. Using type context `TyCtxt`\n+        // 2. Using lang items with the expression type\n         let ty = cx.typeck_results().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n@@ -97,107 +138,129 @@ impl LateLintPass<'_> for MyStructLint {\n             .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n                 // `expr` implements `Drop` trait\n             }\n+\n+        // 3. Using the type path with the expression\n+        // we use `match_trait_method` function from Clippy's utils\n+        // (This method should be avoided if possible)\n+        if match_trait_method(cx, expr, &paths::INTO) {\n+            // `expr` implements `Into` trait\n+        }\n     }\n }\n ```\n \n-> Prefer using lang items, if the target trait is available there.\n-\n-A list of defined paths for Clippy can be found in [paths.rs][paths]\n+> Prefer using diagnostic and lang items, if the target trait has one.\n \n We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n+A list of defined paths for Clippy can be found in [paths.rs][paths]\n \n-# Checking if a type defines a specific method\n+## Checking if a type defines a specific method\n \n To check if our type defines a method called `some_method`:\n \n ```rust\n-use clippy_utils::{is_type_diagnostic_item, return_ty};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::return_ty;\n \n impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n-        if_chain! {\n-            // Check if item is a method/function\n-            if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;\n+        // Check if item is a method/function\n+        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind\n             // Check the method is named `some_method`\n-            if impl_item.ident.name == sym!(some_method);\n+            && impl_item.ident.name == sym!(some_method)\n             // We can also check it has a parameter `self`\n-            if signature.decl.implicit_self.has_implicit_self();\n+            && signature.decl.implicit_self.has_implicit_self()\n             // We can go further and even check if its return type is `String`\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n-            then {\n-                // ...\n-            }\n+            && is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type))\n+        {\n+            // ...\n         }\n     }\n }\n ```\n \n-# Dealing with macros\n-\n-There are several helpers in [`clippy_utils`][utils] to deal with macros:\n-\n-- `in_macro()`: detect if the given span is expanded by a macro\n-\n-You may want to use this for example to not start linting in any macro.\n-\n-```rust\n-macro_rules! foo {\n-    ($param:expr) => {\n-        match $param {\n-            \"bar\" => println!(\"whatever\"),\n-            _ => ()\n-        }\n-    };\n-}\n-\n-foo!(\"bar\");\n-\n-// if we lint the `match` of `foo` call and test its span\n-assert_eq!(in_macro(match_span), true);\n-```\n-\n-- `in_external_macro()`: detect if the given span is from an external macro, defined in a foreign crate\n-\n-You may want to use it for example to not start linting in macros from other crates\n-\n-```rust\n-#[macro_use]\n-extern crate a_crate_with_macros;\n-\n-// `foo` is defined in `a_crate_with_macros`\n-foo!(\"bar\");\n-\n-// if we lint the `match` of `foo` call and test its span\n-assert_eq!(in_external_macro(cx.sess(), match_span), true);\n-```\n-\n-- `differing_macro_contexts()`: returns true if the two given spans are not from the same context\n-\n-```rust\n-macro_rules! m {\n-    ($a:expr, $b:expr) => {\n-        if $a.is_some() {\n-            $b;\n-        }\n-    }\n-}\n-\n-let x: Option<u32> = Some(42);\n-m!(x, x.unwrap());\n-\n-// These spans are not from the same context\n-// x.is_some() is from inside the macro\n-// x.unwrap() is from outside the macro\n-assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n-```\n-\n-[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+## Dealing with macros and expansions\n+\n+Keep in mind that macros are already expanded and desugaring is already applied\n+to the code representation that you are working with in Clippy. This unfortunately causes a lot of\n+false positives because macro expansions are \"invisible\" unless you actively check for them.\n+Generally speaking, code with macro expansions should just be ignored by Clippy because that code can be\n+dynamic in ways that are difficult or impossible to see.\n+Use the following functions to deal with macros:\n+\n+- `span.from_expansion()`: detects if a span is from macro expansion or desugaring.\n+  Checking this is a common first step in a lint.\n+\n+   ```rust\n+   if expr.span.from_expansion() {\n+       // just forget it\n+       return;\n+   }\n+   ```\n+\n+- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, which macro call expanded it.\n+   It is sometimes useful to check if the context of two spans are equal.\n+\n+   ```rust\n+   // expands to `1 + 0`, but don't lint\n+   1 + mac!()\n+   ```\n+   ```rust\n+   if left.span.ctxt() != right.span.ctxt() {\n+       // the coder most likely cannot modify this expression\n+       return;\n+   }\n+   ```\n+  Note: Code that is not from expansion is in the \"root\" context. So any spans where `from_expansion` returns `true` can\n+  be assumed to have the same context. And so just using `span.from_expansion()` is often good enough.\n+\n+\n+- `in_external_macro(span)`: detect if the given span is from a macro defined in a foreign crate.\n+   If you want the lint to work with macro-generated code, this is the next line of defense to avoid macros\n+   not defined in the current crate. It doesn't make sense to lint code that the coder can't change.\n+\n+   You may want to use it for example to not start linting in macros from other crates\n+\n+   ```rust\n+   #[macro_use]\n+   extern crate a_crate_with_macros;\n+\n+   // `foo` is defined in `a_crate_with_macros`\n+   foo!(\"bar\");\n+\n+   // if we lint the `match` of `foo` call and test its span\n+   assert_eq!(in_external_macro(cx.sess(), match_span), true);\n+   ```\n+\n+- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, what expanded it\n+\n+One thing `SpanContext` is useful for is to check if two spans are in the same context. For example,\n+in `a == b`, `a` and `b` have the same context. In a `macro_rules!` with `a == $b`, `$b` is expanded to some\n+expression with a different context from `a`.\n+\n+   ```rust\n+   macro_rules! m {\n+       ($a:expr, $b:expr) => {\n+           if $a.is_some() {\n+               $b;\n+           }\n+       }\n+   }\n+\n+   let x: Option<u32> = Some(42);\n+   m!(x, x.unwrap());\n+\n+   // These spans are not from the same context\n+   // x.is_some() is from inside the macro\n+   // x.unwrap() is from outside the macro\n+   assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n+   ```\n+\n+[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n [TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n [expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n [pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n [paths]: ../clippy_utils/src/paths.rs\n-[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs"}, {"sha": "0cbad2c09249c52275577d32db4b05c8a4741c73", "filename": "book/src/infrastructure/changelog_update.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md?ref=af385799e0d5483170973a79110bdb1ce2949579", "patch": "@@ -32,7 +32,7 @@ bullet points might be helpful:\n   need to check out the Rust release tag of the stable release.\n   [Link][rust_stable_tools]\n \n-Usually you want to wirte the changelog of the **upcoming stable release**. Make\n+Usually you want to write the changelog of the **upcoming stable release**. Make\n sure though, that `beta` was already branched in the Rust repository.\n \n To find the commit hash, issue the following command when in a `rust-lang/rust` checkout:"}, {"sha": "c4f8f989384280659f899f6f6d9820cf0087e8a6", "filename": "book/src/infrastructure/release.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Finfrastructure%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/af385799e0d5483170973a79110bdb1ce2949579/book%2Fsrc%2Finfrastructure%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Frelease.md?ref=af385799e0d5483170973a79110bdb1ce2949579", "patch": "@@ -121,4 +121,25 @@ happened a stable backport, make sure to re-merge those changes just as with the\n \n For this see the document on [how to update the changelog].\n \n+If you don't have time to do a complete changelog update right away, just update\n+the following parts:\n+\n+- Remove the `(beta)` from the new stable version:\n+\n+  ```markdown\n+  ## Rust 1.XX (beta) -> ## Rust 1.XX\n+  ```\n+\n+- Update the release date line of the new stable version:\n+\n+  ```markdown\n+  Current beta, release 20YY-MM-DD -> Current stable, released 20YY-MM-DD\n+  ```\n+\n+- Update the release date line of the previous stable version:\n+\n+  ```markdown\n+  Current stable, released 20YY-MM-DD -> Released 20YY-MM-DD\n+  ```\n+\n [how to update the changelog]: https://github.com/rust-lang/rust-clippy/blob/master/doc/changelog_update.md"}, {"sha": "3e0b1c5c4f782c3d55afab4ee2734b2451a1333c", "filename": "doc/adding_lints.md", "status": "removed", "additions": 0, "deletions": 697, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,697 +0,0 @@\n-# Adding a new lint\n-\n-You are probably here because you want to add a new lint to Clippy. If this is\n-the first time you're contributing to Clippy, this document guides you through\n-creating an example lint from scratch.\n-\n-To get started, we will create a lint that detects functions called `foo`,\n-because that's clearly a non-descriptive name.\n-\n-- [Adding a new lint](#adding-a-new-lint)\n-  - [Setup](#setup)\n-  - [Getting Started](#getting-started)\n-  - [Testing](#testing)\n-    - [Cargo lints](#cargo-lints)\n-  - [Rustfix tests](#rustfix-tests)\n-  - [Edition 2018 tests](#edition-2018-tests)\n-  - [Testing manually](#testing-manually)\n-  - [Lint declaration](#lint-declaration)\n-  - [Lint registration](#lint-registration)\n-  - [Lint passes](#lint-passes)\n-  - [Emitting a lint](#emitting-a-lint)\n-  - [Adding the lint logic](#adding-the-lint-logic)\n-  - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n-  - [Author lint](#author-lint)\n-  - [Print HIR lint](#print-hir-lint)\n-  - [Documentation](#documentation)\n-  - [Running rustfmt](#running-rustfmt)\n-  - [Debugging](#debugging)\n-  - [PR Checklist](#pr-checklist)\n-  - [Adding configuration to a lint](#adding-configuration-to-a-lint)\n-  - [Cheat Sheet](#cheat-sheet)\n-\n-## Setup\n-\n-See the [Basics](basics.md#get-the-code) documentation.\n-\n-## Getting Started\n-\n-There is a bit of boilerplate code that needs to be set up when creating a new\n-lint. Fortunately, you can use the clippy dev tools to handle this for you. We\n-are naming our new lint `foo_functions` (lints are generally written in snake\n-case), and we don't need type information so it will have an early pass type\n-(more on this later on). If you're not sure if the name you chose fits the lint,\n-take a look at our [lint naming guidelines][lint_naming]. To get started on this\n-lint you can run `cargo dev new_lint --name=foo_functions --pass=early\n---category=pedantic` (category will default to nursery if not provided). This\n-command will create two files: `tests/ui/foo_functions.rs` and\n-`clippy_lints/src/foo_functions.rs`, as well as\n-[registering the lint](#lint-registration). For cargo lints, two project\n-hierarchies (fail/pass) will be created by default under `tests/ui-cargo`.\n-\n-Next, we'll open up these files and add our lint!\n-\n-## Testing\n-\n-Let's write some tests first that we can execute while we iterate on our lint.\n-\n-Clippy uses UI tests for testing. UI tests check that the output of Clippy is\n-exactly as expected. Each test is just a plain Rust file that contains the code\n-we want to check. The output of Clippy is compared against a `.stderr` file.\n-Note that you don't have to create this file yourself, we'll get to\n-generating the `.stderr` files further down.\n-\n-We start by opening the test file created at `tests/ui/foo_functions.rs`.\n-\n-Update the file with some examples to get started:\n-\n-```rust\n-#![warn(clippy::foo_functions)]\n-\n-// Impl methods\n-struct A;\n-impl A {\n-    pub fn fo(&self) {}\n-    pub fn foo(&self) {}\n-    pub fn food(&self) {}\n-}\n-\n-// Default trait methods\n-trait B {\n-    fn fo(&self) {}\n-    fn foo(&self) {}\n-    fn food(&self) {}\n-}\n-\n-// Plain functions\n-fn fo() {}\n-fn foo() {}\n-fn food() {}\n-\n-fn main() {\n-    // We also don't want to lint method calls\n-    foo();\n-    let a = A;\n-    a.foo();\n-}\n-```\n-\n-Now we can run the test with `TESTNAME=foo_functions cargo uitest`,\n-currently this test is meaningless though.\n-\n-While we are working on implementing our lint, we can keep running the UI\n-test. That allows us to check if the output is turning into what we want.\n-\n-Once we are satisfied with the output, we need to run\n-`cargo dev bless` to update the `.stderr` file for our lint.\n-Please note that, we should run `TESTNAME=foo_functions cargo uitest`\n-every time before running `cargo dev bless`.\n-Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n-our lint, we need to commit the generated `.stderr` files, too. In general, you\n-should only commit files changed by `cargo dev bless` for the\n-specific lint you are creating/editing. Note that if the generated files are\n-empty, they should be removed.\n-\n-Note that you can run multiple test files by specifying a comma separated list:\n-`TESTNAME=foo_functions,test2,test3`.\n-\n-### Cargo lints\n-\n-For cargo lints, the process of testing differs in that we are interested in\n-the `Cargo.toml` manifest file. We also need a minimal crate associated\n-with that manifest.\n-\n-If our new lint is named e.g. `foo_categories`, after running `cargo dev new_lint`\n-we will find by default two new crates, each with its manifest file:\n-\n-* `tests/ui-cargo/foo_categories/fail/Cargo.toml`: this file should cause the new lint to raise an error.\n-* `tests/ui-cargo/foo_categories/pass/Cargo.toml`: this file should not trigger the lint.\n-\n-If you need more cases, you can copy one of those crates (under `foo_categories`) and rename it.\n-\n-The process of generating the `.stderr` file is the same, and prepending the `TESTNAME`\n-variable to `cargo uitest` works too.\n-\n-## Rustfix tests\n-\n-If the lint you are working on is making use of structured suggestions, the\n-test file should include a `// run-rustfix` comment at the top. This will\n-additionally run [rustfix] for that test. Rustfix will apply the suggestions\n-from the lint to the code of the test file and compare that to the contents of\n-a `.fixed` file.\n-\n-Use `cargo dev bless` to automatically generate the\n-`.fixed` file after running the tests.\n-\n-[rustfix]: https://github.com/rust-lang/rustfix\n-\n-## Edition 2018 tests\n-\n-Some features require the 2018 edition to work (e.g. `async_await`), but\n-compile-test tests run on the 2015 edition by default. To change this behavior\n-add `// edition:2018` at the top of the test file (note that it's space-sensitive).\n-\n-## Testing manually\n-\n-Manually testing against an example file can be useful if you have added some\n-`println!`s and the test suite output becomes unreadable. To try Clippy with\n-your local modifications, run\n-\n-```\n-cargo dev lint input.rs\n-```\n-\n-from the working copy root. With tests in place, let's have a look at\n-implementing our lint now.\n-\n-## Lint declaration\n-\n-Let's start by opening the new file created in the `clippy_lints` crate\n-at `clippy_lints/src/foo_functions.rs`. That's the crate where all the\n-lint code is. This file has already imported some initial things we will need:\n-\n-```rust\n-use rustc_lint::{EarlyLintPass, EarlyContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_ast::ast::*;\n-```\n-\n-The next step is to update the lint declaration. Lints are declared using the\n-[`declare_clippy_lint!`][declare_clippy_lint] macro, and we just need to update\n-the auto-generated lint declaration to have a real description, something like this:\n-\n-```rust\n-declare_clippy_lint! {\n-    /// ### What it does\n-    ///\n-    /// ### Why is this bad?\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // example code\n-    /// ```\n-    #[clippy::version = \"1.29.0\"]\n-    pub FOO_FUNCTIONS,\n-    pedantic,\n-    \"function named `foo`, which is not a descriptive name\"\n-}\n-```\n-\n-* The section of lines prefixed with `///` constitutes the lint documentation\n-  section. This is the default documentation style and will be displayed\n-  [like this][example_lint_page]. To render and open this documentation locally\n-  in a browser, run `cargo dev serve`.\n-* The `#[clippy::version]` attribute will be rendered as part of the lint documentation.\n-  The value should be set to the current Rust version that the lint is developed in,\n-  it can be retrieved by running `rustc -vV` in the rust-clippy directory. The version\n-  is listed under *release*. (Use the version without the `-nightly`) suffix.\n-* `FOO_FUNCTIONS` is the name of our lint. Be sure to follow the\n-  [lint naming guidelines][lint_naming] here when naming your lint.\n-  In short, the name should state the thing that is being checked for and\n-  read well when used with `allow`/`warn`/`deny`.\n-* `pedantic` sets the lint level to `Allow`.\n-  The exact mapping can be found [here][category_level_mapping]\n-* The last part should be a text that explains what exactly is wrong with the\n-  code\n-\n-The rest of this file contains an empty implementation for our lint pass,\n-which in this case is `EarlyLintPass` and should look like this:\n-\n-```rust\n-// clippy_lints/src/foo_functions.rs\n-\n-// .. imports and lint declaration ..\n-\n-declare_lint_pass!(FooFunctions => [FOO_FUNCTIONS]);\n-\n-impl EarlyLintPass for FooFunctions {}\n-```\n-\n-[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60\n-[example_lint_page]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n-[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n-[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L110\n-\n-## Lint registration\n-\n-When using `cargo dev new_lint`, the lint is automatically registered and\n-nothing more has to be done.\n-\n-When declaring a new lint by hand and `cargo dev update_lints` is used, the lint\n-pass may have to be registered manually in the `register_plugins` function in\n-`clippy_lints/src/lib.rs`:\n-\n-```rust\n-store.register_early_pass(|| Box::new(foo_functions::FooFunctions));\n-```\n-\n-As one may expect, there is a corresponding `register_late_pass` method\n-available as well. Without a call to one of `register_early_pass` or\n-`register_late_pass`, the lint pass in question will not be run.\n-\n-One reason that `cargo dev update_lints` does not automate this step is that\n-multiple lints can use the same lint pass, so registering the lint pass may\n-already be done when adding a new lint. Another reason that this step is not\n-automated is that the order that the passes are registered determines the order\n-the passes actually run, which in turn affects the order that any emitted lints\n-are output in.\n-\n-## Lint passes\n-\n-Writing a lint that only checks for the name of a function means that we only\n-have to deal with the AST and don't have to deal with the type system at all.\n-This is good, because it makes writing this particular lint less complicated.\n-\n-We have to make this decision with every new Clippy lint. It boils down to using\n-either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n-\n-In short, the `LateLintPass` has access to type information while the\n-`EarlyLintPass` doesn't. If you don't need access to type information, use the\n-`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n-hasn't really been a concern with Clippy so far.\n-\n-Since we don't need type information for checking the function name, we used\n-`--pass=early` when running the new lint automation and all the imports were\n-added accordingly.\n-\n-[early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html\n-[late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n-\n-## Emitting a lint\n-\n-With UI tests and the lint declaration in place, we can start working on the\n-implementation of the lint logic.\n-\n-Let's start by implementing the `EarlyLintPass` for our `FooFunctions`:\n-\n-```rust\n-impl EarlyLintPass for FooFunctions {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n-        // TODO: Emit lint here\n-    }\n-}\n-```\n-\n-We implement the [`check_fn`][check_fn] method from the\n-[`EarlyLintPass`][early_lint_pass] trait. This gives us access to various\n-information about the function that is currently being checked. More on that in\n-the next section. Let's worry about the details later and emit our lint for\n-*every* function definition first.\n-\n-Depending on how complex we want our lint message to be, we can choose from a\n-variety of lint emission functions. They can all be found in\n-[`clippy_utils/src/diagnostics.rs`][diagnostics].\n-\n-`span_lint_and_help` seems most appropriate in this case. It allows us to\n-provide an extra help message and we can't really suggest a better name\n-automatically. This is how it looks:\n-\n-```rust\n-impl EarlyLintPass for FooFunctions {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n-        span_lint_and_help(\n-            cx,\n-            FOO_FUNCTIONS,\n-            span,\n-            \"function named `foo`\",\n-            None,\n-            \"consider using a more meaningful name\"\n-        );\n-    }\n-}\n-```\n-\n-Running our UI test should now produce output that contains the lint message.\n-\n-According to [the rustc-dev-guide], the text should be matter of fact and avoid\n-capitalization and periods, unless multiple sentences are needed.\n-When code or an identifier must appear in a message or label, it should be\n-surrounded with single grave accents \\`.\n-\n-[check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n-[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs\n-[the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n-\n-## Adding the lint logic\n-\n-Writing the logic for your lint will most likely be different from our example,\n-so this section is kept rather short.\n-\n-Using the [`check_fn`][check_fn] method gives us access to [`FnKind`][fn_kind]\n-that has the [`FnKind::Fn`] variant. It provides access to the name of the\n-function/method via an [`Ident`][ident].\n-\n-With that we can expand our `check_fn` method to:\n-\n-```rust\n-impl EarlyLintPass for FooFunctions {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n-        if is_foo_fn(fn_kind) {\n-            span_lint_and_help(\n-                cx,\n-                FOO_FUNCTIONS,\n-                span,\n-                \"function named `foo`\",\n-                None,\n-                \"consider using a more meaningful name\"\n-            );\n-        }\n-    }\n-}\n-```\n-\n-We separate the lint conditional from the lint emissions because it makes the\n-code a bit easier to read. In some cases this separation would also allow to\n-write some unit tests (as opposed to only UI tests) for the separate function.\n-\n-In our example, `is_foo_fn` looks like:\n-\n-```rust\n-// use statements, impl EarlyLintPass, check_fn, ..\n-\n-fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n-    match fn_kind {\n-        FnKind::Fn(_, ident, ..) => {\n-            // check if `fn` name is `foo`\n-            ident.name.as_str() == \"foo\"\n-        }\n-        // ignore closures\n-        FnKind::Closure(..) => false\n-    }\n-}\n-```\n-\n-Now we should also run the full test suite with `cargo test`. At this point\n-running `cargo test` should produce the expected output. Remember to run\n-`cargo dev bless` to update the `.stderr` file.\n-\n-`cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n-implementation is not violating any Clippy lints itself.\n-\n-That should be it for the lint implementation. Running `cargo test` should now\n-pass.\n-\n-[fn_kind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html\n-[`FnKind::Fn`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn\n-[ident]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html\n-\n-## Specifying the lint's minimum supported Rust version (MSRV)\n-\n-Sometimes a lint makes suggestions that require a certain version of Rust. For example, the `manual_strip` lint suggests\n-using `str::strip_prefix` and `str::strip_suffix` which is only available after Rust 1.45. In such cases, you need to\n-ensure that the MSRV configured for the project is >= the MSRV of the required Rust feature. If multiple features are\n-required, just use the one with a lower MSRV.\n-\n-First, add an MSRV alias for the required feature in [`clippy_utils::msrvs`](/clippy_utils/src/msrvs.rs). This can be\n-accessed later as `msrvs::STR_STRIP_PREFIX`, for example.\n-\n-```rust\n-msrv_aliases! {\n-    ..\n-    1,45,0 { STR_STRIP_PREFIX }\n-}\n-```\n-\n-In order to access the project-configured MSRV, you need to have an `msrv` field in the LintPass struct, and a\n-constructor to initialize the field. The `msrv` value is passed to the constructor in `clippy_lints/lib.rs`.\n-\n-```rust\n-pub struct ManualStrip {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl ManualStrip {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-```\n-\n-The project's MSRV can then be matched against the feature MSRV in the LintPass\n-using the `meets_msrv` utility function.\n-\n-``` rust\n-if !meets_msrv(self.msrv, msrvs::STR_STRIP_PREFIX) {\n-    return;\n-}\n-```\n-\n-The project's MSRV can also be specified as an inner attribute, which overrides\n-the value from `clippy.toml`. This can be accounted for using the\n-`extract_msrv_attr!(LintContext)` macro and passing\n-`LateContext`/`EarlyContext`.\n-\n-```rust\n-impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        ...\n-    }\n-    extract_msrv_attr!(LateContext);\n-}\n-```\n-\n-Once the `msrv` is added to the lint, a relevant test case should be added to\n-`tests/ui/min_rust_version_attr.rs` which verifies that the lint isn't emitted\n-if the project's MSRV is lower.\n-\n-As a last step, the lint should be added to the lint documentation. This is done\n-in `clippy_lints/src/utils/conf.rs`:\n-\n-```rust\n-define_Conf! {\n-    /// Lint: LIST, OF, LINTS, <THE_NEWLY_ADDED_LINT>. The minimum rust version that the project supports\n-    (msrv: Option<String> = None),\n-    ...\n-}\n-```\n-\n-## Author lint\n-\n-If you have trouble implementing your lint, there is also the internal `author`\n-lint to generate Clippy code that detects the offending pattern. It does not\n-work for all of the Rust syntax, but can give a good starting point.\n-\n-The quickest way to use it, is the\n-[Rust playground: play.rust-lang.org][author_example].\n-Put the code you want to lint into the editor and add the `#[clippy::author]`\n-attribute above the item. Then run Clippy via `Tools -> Clippy` and you should\n-see the generated code in the output below.\n-\n-[Here][author_example] is an example on the playground.\n-\n-If the command was executed successfully, you can copy the code over to where\n-you are implementing your lint.\n-\n-[author_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9a12cb60e5c6ad4e3003ac6d5e63cf55\n-\n-## Print HIR lint\n-\n-To implement a lint, it's helpful to first understand the internal representation\n-that rustc uses. Clippy has the `#[clippy::dump]` attribute that prints the\n-[_High-Level Intermediate Representation (HIR)_] of the item, statement, or \n-expression that the attribute is attached to. To attach the attribute to expressions\n-you often need to enable `#![feature(stmt_expr_attributes)]`.\n-\n-[Here][print_hir_example] you can find an example, just select _Tools_ and run _Clippy_.\n-\n-[_High-Level Intermediate Representation (HIR)_]: https://rustc-dev-guide.rust-lang.org/hir.html\n-[print_hir_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=daf14db3a7f39ca467cd1b86c34b9afb\n-\n-## Documentation\n-\n-The final thing before submitting our PR is to add some documentation to our\n-lint declaration.\n-\n-Please document your lint with a doc comment akin to the following:\n-\n-```rust\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for ... (describe what the lint matches).\n-    ///\n-    /// ### Why is this bad?\n-    /// Supply the reason for linting the code.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,ignore\n-    /// // A short example of code that triggers the lint\n-    /// ```\n-    /// \n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// // A short example of improved code that doesn't trigger the lint\n-    /// ```\n-    #[clippy::version = \"1.29.0\"]\n-    pub FOO_FUNCTIONS,\n-    pedantic,\n-    \"function named `foo`, which is not a descriptive name\"\n-}\n-```\n-\n-Once your lint is merged, this documentation will show up in the [lint\n-list][lint_list].\n-\n-[lint_list]: https://rust-lang.github.io/rust-clippy/master/index.html\n-\n-## Running rustfmt\n-\n-[Rustfmt] is a tool for formatting Rust code according to style guidelines.\n-Your code has to be formatted by `rustfmt` before a PR can be merged.\n-Clippy uses nightly `rustfmt` in the CI.\n-\n-It can be installed via `rustup`:\n-\n-```bash\n-rustup component add rustfmt --toolchain=nightly\n-```\n-\n-Use `cargo dev fmt` to format the whole codebase. Make sure that `rustfmt` is\n-installed for the nightly toolchain.\n-\n-[Rustfmt]: https://github.com/rust-lang/rustfmt\n-\n-## Debugging\n-\n-If you want to debug parts of your lint implementation, you can use the [`dbg!`]\n-macro anywhere in your code. Running the tests should then include the debug\n-output in the `stdout` part.\n-\n-[`dbg!`]: https://doc.rust-lang.org/std/macro.dbg.html\n-\n-## PR Checklist\n-\n-Before submitting your PR make sure you followed all of the basic requirements:\n-\n-<!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->\n-\n-- \\[ ] Followed [lint naming conventions][lint_naming]\n-- \\[ ] Added passing UI tests (including committed `.stderr` file)\n-- \\[ ] `cargo test` passes locally\n-- \\[ ] Executed `cargo dev update_lints`\n-- \\[ ] Added lint documentation\n-- \\[ ] Run `cargo dev fmt`\n-\n-## Adding configuration to a lint\n-\n-Clippy supports the configuration of lints values using a `clippy.toml` file in the workspace\n-directory. Adding a configuration to a lint can be useful for thresholds or to constrain some\n-behavior that can be seen as a false positive for some users. Adding a configuration is done\n-in the following steps:\n-\n-1. Adding a new configuration entry to [clippy_lints::utils::conf](/clippy_lints/src/utils/conf.rs)\n-    like this:\n-    ```rust\n-    /// Lint: LINT_NAME.\n-    ///\n-    /// <The configuration field doc comment>\n-    (configuration_ident: Type = DefaultValue),\n-    ```\n-    The doc comment is automatically added to the documentation of the listed lints. The default\n-    value will be formatted using the `Debug` implementation of the type.\n-2. Adding the configuration value to the lint impl struct:\n-    1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n-        generated with the `declare_lint_pass!` macro. This struct needs to be defined manually\n-        to add some kind of metadata to it:\n-        ```rust\n-        // Generated struct definition\n-        declare_lint_pass!(StructName => [\n-            LINT_NAME\n-        ]);\n-\n-        // New manual definition struct\n-        #[derive(Copy, Clone)]\n-        pub struct StructName {}\n-\n-        impl_lint_pass!(StructName => [\n-            LINT_NAME\n-        ]);\n-        ```\n-\n-    2. Next add the configuration value and a corresponding creation method like this:\n-        ```rust\n-        #[derive(Copy, Clone)]\n-        pub struct StructName {\n-            configuration_ident: Type,\n-        }\n-\n-        // ...\n-\n-        impl StructName {\n-            pub fn new(configuration_ident: Type) -> Self {\n-                Self {\n-                    configuration_ident,\n-                }\n-            }\n-        }\n-        ```\n-3. Passing the configuration value to the lint impl struct:\n-\n-    First find the struct construction in the [clippy_lints lib file](/clippy_lints/src/lib.rs).\n-    The configuration value is now cloned or copied into a local value that is then passed to the\n-    impl struct like this:\n-    ```rust\n-    // Default generated registration:\n-    store.register_*_pass(|| box module::StructName);\n-\n-    // New registration with configuration value\n-    let configuration_ident = conf.configuration_ident.clone();\n-    store.register_*_pass(move || box module::StructName::new(configuration_ident));\n-    ```\n-\n-    Congratulations the work is almost done. The configuration value can now be accessed\n-    in the linting code via `self.configuration_ident`.\n-\n-4. Adding tests:\n-    1. The default configured value can be tested like any normal lint in [`tests/ui`](/tests/ui).\n-    2. The configuration itself will be tested separately in [`tests/ui-toml`](/tests/ui-toml).\n-        Simply add a new subfolder with a fitting name. This folder contains a `clippy.toml` file\n-        with the configuration value and a rust file that should be linted by Clippy. The test can\n-        otherwise be written as usual.\n-\n-## Cheat Sheet\n-\n-Here are some pointers to things you are likely going to need for every lint:\n-\n-* [Clippy utils][utils] - Various helper functions. Maybe the function you need\n-  is already in here ([`is_type_diagnostic_item`], [`implements_trait`], [`snippet`], etc)\n-* [Clippy diagnostics][diagnostics]\n-* [Let chains][let-chains]\n-* [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]\n-* [`Span`][span]\n-* [`Applicability`][applicability]\n-* [Common tools for writing lints](common_tools_writing_lints.md) helps with common operations\n-* [The rustc-dev-guide][rustc-dev-guide] explains a lot of internal compiler concepts\n-* [The nightly rustc docs][nightly_docs] which has been linked to throughout\n-  this guide\n-\n-For `EarlyLintPass` lints:\n-\n-* [`EarlyLintPass`][early_lint_pass]\n-* [`rustc_ast::ast`][ast]\n-\n-For `LateLintPass` lints:\n-\n-* [`LateLintPass`][late_lint_pass]\n-* [`Ty::TyKind`][ty]\n-\n-While most of Clippy's lint utils are documented, most of rustc's internals lack\n-documentation currently. This is unfortunate, but in most cases you can probably\n-get away with copying things from existing similar lints. If you are stuck,\n-don't hesitate to ask on [Zulip] or in the issue/PR.\n-\n-[utils]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/index.html\n-[`is_type_diagnostic_item`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.is_type_diagnostic_item.html\n-[`implements_trait`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.implements_trait.html\n-[`snippet`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/source/fn.snippet.html\n-[let-chains]: https://github.com/rust-lang/rust/pull/94927\n-[from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n-[in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html\n-[span]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html\n-[applicability]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html\n-[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n-[nightly_docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n-[ast]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html\n-[ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/index.html\n-[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/clippy"}, {"sha": "15f3d1f080604d7286cf870a66569b9f123e287d", "filename": "doc/backport.md", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fbackport.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fbackport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbackport.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,71 +0,0 @@\n-# Backport Changes\n-\n-Sometimes it is necessary to backport changes to the beta release of Clippy.\n-Backports in Clippy are rare and should be approved by the Clippy team. For\n-example, a backport is done, if a crucial ICE was fixed or a lint is broken to a\n-point, that it has to be disabled, before landing on stable.\n-\n-Backports are done to the `beta` branch of Clippy. Backports to stable Clippy\n-releases basically don't exist, since this would require a Rust point release,\n-which is almost never justifiable for a Clippy fix.\n-\n-\n-## Backport the changes\n-\n-Backports are done on the beta branch of the Clippy repository.\n-\n-```bash\n-# Assuming the current directory corresponds to the Clippy repository\n-$ git checkout beta\n-$ git checkout -b backport\n-$ git cherry-pick <SHA>  # `<SHA>` is the commit hash of the commit(s), that should be backported\n-$ git push origin backport\n-```\n-\n-Now you should test that the backport passes all the tests in the Rust\n-repository. You can do this with:\n-\n-```bash\n-# Assuming the current directory corresponds to the Rust repository\n-$ git checkout beta\n-$ git subtree pull -p src/tools/clippy https://github.com/<your-github-name>/rust-clippy backport\n-$ ./x.py test src/tools/clippy\n-```\n-\n-Should the test fail, you can fix Clippy directly in the Rust repository. This\n-has to be first applied to the Clippy beta branch and then again synced to the\n-Rust repository, though. The easiest way to do this is:\n-\n-```bash\n-# In the Rust repository\n-$ git diff --patch --relative=src/tools/clippy > clippy.patch\n-# In the Clippy repository\n-$ git apply /path/to/clippy.patch\n-$ git add -u\n-$ git commit -m \"Fix rustup fallout\"\n-$ git push origin backport\n-```\n-\n-After this, you can open a PR to the `beta` branch of the Clippy repository.\n-\n-\n-## Update Clippy in the Rust Repository\n-\n-This step must be done, **after** the PR of the previous step was merged.\n-\n-After the backport landed in the Clippy repository, the branch has to be synced\n-back to the beta branch of the Rust repository.\n-\n-```bash\n-# Assuming the current directory corresponds to the Rust repository\n-$ git checkout beta\n-$ git checkout -b clippy_backport\n-$ git subtree pull -p src/tools/clippy https://github.com/rust-lang/rust-clippy beta\n-$ git push origin clippy_backport\n-```\n-\n-Make sure to test the backport in the Rust repository before opening a PR. This\n-is done with `./x.py test src/tools/clippy`. If that passes all tests, open a PR\n-to the `beta` branch of the Rust repository. In this PR you should tag the\n-Clippy team member, that agreed to the backport or the `@rust-lang/clippy` team.\n-Make sure to add `[beta]` to the title of the PR."}, {"sha": "57a90a924ec3cf9fd0a58ab6d3d969a2b1b91ef8", "filename": "doc/basics.md", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,174 +0,0 @@\n-# Basics for hacking on Clippy\n-\n-This document explains the basics for hacking on Clippy. Besides others, this\n-includes how to build and test Clippy. For a more in depth description on\n-the codebase take a look at [Adding Lints] or [Common Tools].\n-\n-[Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n-[Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md\n-\n-- [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n-  - [Get the Code](#get-the-code)\n-  - [Building and Testing](#building-and-testing)\n-  - [`cargo dev`](#cargo-dev)\n-  - [lintcheck](#lintcheck)\n-  - [PR](#pr)\n-  - [Common Abbreviations](#common-abbreviations)\n-  - [Install from source](#install-from-source)\n-\n-## Get the Code\n-\n-First, make sure you have checked out the latest version of Clippy. If this is\n-your first time working on Clippy, create a fork of the repository and clone it\n-afterwards with the following command:\n-\n-```bash\n-git clone git@github.com:<your-username>/rust-clippy\n-```\n-\n-If you've already cloned Clippy in the past, update it to the latest version:\n-\n-```bash\n-# If the upstream remote has not been added yet\n-git remote add upstream https://github.com/rust-lang/rust-clippy\n-# upstream has to be the remote of the rust-lang/rust-clippy repo\n-git fetch upstream\n-# make sure that you are on the master branch\n-git checkout master\n-# rebase your master branch on the upstream master\n-git rebase upstream/master\n-# push to the master branch of your fork\n-git push\n-```\n-\n-## Building and Testing\n-\n-You can build and test Clippy like every other Rust project:\n-\n-```bash\n-cargo build  # builds Clippy\n-cargo test   # tests Clippy\n-```\n-\n-Since Clippy's test suite is pretty big, there are some commands that only run a\n-subset of Clippy's tests:\n-\n-```bash\n-# only run UI tests\n-cargo uitest\n-# only run UI tests starting with `test_`\n-TESTNAME=\"test_\" cargo uitest\n-# only run dogfood tests\n-cargo test --test dogfood\n-```\n-\n-If the output of a [UI test] differs from the expected output, you can update the\n-reference file with:\n-\n-```bash\n-cargo dev bless\n-```\n-\n-For example, this is necessary, if you fix a typo in an error message of a lint\n-or if you modify a test file to add a test case.\n-\n-_Note:_ This command may update more files than you intended. In that case only\n-commit the files you wanted to update.\n-\n-[UI test]: https://rustc-dev-guide.rust-lang.org/tests/adding.html#guide-to-the-ui-tests\n-\n-## `cargo dev`\n-\n-Clippy has some dev tools to make working on Clippy more convenient. These tools\n-can be accessed through the `cargo dev` command. Available tools are listed\n-below. To get more information about these commands, just call them with\n-`--help`.\n-\n-```bash\n-# formats the whole Clippy codebase and all tests\n-cargo dev fmt\n-# register or update lint names/groups/...\n-cargo dev update_lints\n-# create a new lint and register it\n-cargo dev new_lint\n-# automatically formatting all code before each commit\n-cargo dev setup git-hook\n-# (experimental) Setup Clippy to work with IntelliJ-Rust\n-cargo dev setup intellij\n-```\n-More about intellij command usage and reasons [here](../CONTRIBUTING.md#intellij-rust)\n-\n-## lintcheck\n-`cargo lintcheck` will build and run clippy on a fixed set of crates and generate a log of the results.  \n-You can `git diff` the updated log against its previous version and\n-see what impact your lint made on a small set of crates.  \n-If you add a new lint, please audit the resulting warnings and make sure\n-there are no false positives and that the suggestions are valid.\n-\n-Refer to the tools [README] for more details.\n-\n-[README]: https://github.com/rust-lang/rust-clippy/blob/master/lintcheck/README.md\n-## PR\n-\n-We follow a rustc no merge-commit policy.\n-See <https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr>.\n-\n-## Common Abbreviations\n-\n-| Abbreviation | Meaning                                |\n-| ------------ | -------------------------------------- |\n-| UB           | Undefined Behavior                     |\n-| FP           | False Positive                         |\n-| FN           | False Negative                         |\n-| ICE          | Internal Compiler Error                |\n-| AST          | Abstract Syntax Tree                   |\n-| MIR          | Mid-Level Intermediate Representation  |\n-| HIR          | High-Level Intermediate Representation |\n-| TCX          | Type context                           |\n-\n-This is a concise list of abbreviations that can come up during Clippy development. An extensive\n-general list can be found in the [rustc-dev-guide glossary][glossary]. Always feel free to ask if\n-an abbreviation or meaning is unclear to you.\n-\n-## Install from source\n-\n-If you are hacking on Clippy and want to install it from source, do the following:\n-\n-First, take note of the toolchain [override](https://rust-lang.github.io/rustup/overrides.html) in `/rust-toolchain`.\n-We will use this override to install Clippy into the right toolchain.\n-\n-> Tip: You can view the active toolchain for the current directory with `rustup show active-toolchain`.\n-\n-From the Clippy project root, run the following command to build the Clippy binaries and copy them into the\n-toolchain directory. This will override the currently installed Clippy component.\n-\n-```terminal\n-cargo build --release --bin cargo-clippy --bin clippy-driver -Zunstable-options --out-dir \"$(rustc --print=sysroot)/bin\"\n-```\n-\n-Now you may run `cargo clippy` in any project, using the toolchain where you just installed Clippy.\n-\n-```terminal\n-cd my-project\n-cargo +nightly-2021-07-01 clippy\n-```\n-\n-...or `clippy-driver`\n-\n-```terminal\n-clippy-driver +nightly-2021-07-01 <filename>\n-```\n-\n-If you need to restore the default Clippy installation, run the following (from the Clippy project root).\n-\n-```terminal\n-rustup component remove clippy\n-rustup component add clippy\n-```\n-\n-> **DO NOT** install using `cargo install --path . --force` since this will overwrite rustup\n-> [proxies](https://rust-lang.github.io/rustup/concepts/proxies.html). That is, `~/.cargo/bin/cargo-clippy` and\n-> `~/.cargo/bin/clippy-driver` should be hard or soft links to `~/.cargo/bin/rustup`. You can repair these by running\n-> `rustup update`.\n-\n-[glossary]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html"}, {"sha": "0cbad2c09249c52275577d32db4b05c8a4741c73", "filename": "doc/changelog_update.md", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fchangelog_update.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,97 +0,0 @@\n-# Changelog Update\n-\n-If you want to help with updating the [changelog][changelog], you're in the right place.\n-\n-## When to update\n-\n-Typos and other small fixes/additions are _always_ welcome.\n-\n-Special care needs to be taken when it comes to updating the changelog for a new\n-Rust release. For that purpose, the changelog is ideally updated during the week\n-before an upcoming stable release. You can find the release dates on the [Rust\n-Forge][forge].\n-\n-Most of the time we only need to update the changelog for minor Rust releases. It's\n-been very rare that Clippy changes were included in a patch release.\n-\n-## Changelog update walkthrough\n-\n-### 1. Finding the relevant Clippy commits\n-\n-Each Rust release ships with its own version of Clippy. The Clippy subtree can\n-be found in the `tools` directory of the Rust repository.\n-\n-Depending on the current time and what exactly you want to update, the following\n-bullet points might be helpful:\n-\n-* When writing the release notes for the **upcoming stable release** you need to check\n-  out the Clippy commit of the current Rust `beta` branch. [Link][rust_beta_tools]\n-* When writing the release notes for the **upcoming beta release**, you need to check\n-  out the Clippy commit of the current Rust `master`. [Link][rust_master_tools]\n-* When writing the (forgotten) release notes for a **past stable release**, you\n-  need to check out the Rust release tag of the stable release.\n-  [Link][rust_stable_tools]\n-\n-Usually you want to write the changelog of the **upcoming stable release**. Make\n-sure though, that `beta` was already branched in the Rust repository.\n-\n-To find the commit hash, issue the following command when in a `rust-lang/rust` checkout:\n-```\n-git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\"\n-```\n-\n-### 2. Fetching the PRs between those commits\n-\n-Once you've got the correct commit range, run\n-\n-    util/fetch_prs_between.sh commit1 commit2 > changes.txt\n-\n-and open that file in your editor of choice.\n-\n-When updating the changelog it's also a good idea to make sure that `commit1` is\n-already correct in the current changelog.\n-\n-### 3. Authoring the final changelog\n-\n-The above script should have dumped all the relevant PRs to the file you\n-specified. It should have filtered out most of the irrelevant PRs\n-already, but it's a good idea to do a manual cleanup pass where you look for\n-more irrelevant PRs. If you're not sure about some PRs, just leave them in for\n-the review and ask for feedback.\n-\n-With the PRs filtered, you can start to take each PR and move the\n-`changelog: ` content to `CHANGELOG.md`. Adapt the wording as you see fit but\n-try to keep it somewhat coherent.\n-\n-The order should roughly be:\n-\n-1. New lints\n-2. Moves or deprecations of lints\n-3. Changes that expand what code existing lints cover\n-4. False positive fixes\n-5. Suggestion fixes/improvements\n-6. ICE fixes\n-7. Documentation improvements\n-8. Others\n-\n-As section headers, we use:\n-\n-```\n-### New Lints\n-### Moves and Deprecations\n-### Enhancements\n-### False Positive Fixes\n-### Suggestion Fixes/Improvements\n-### ICE Fixes\n-### Documentation Improvements\n-### Others\n-```\n-\n-Please also be sure to update the Beta/Unreleased sections at the top with the\n-relevant commit ranges.\n-\n-[changelog]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md\n-[forge]: https://forge.rust-lang.org/\n-[rust_master_tools]: https://github.com/rust-lang/rust/tree/master/src/tools/clippy\n-[rust_beta_tools]: https://github.com/rust-lang/rust/tree/beta/src/tools/clippy\n-[rust_stable_tools]: https://github.com/rust-lang/rust/releases"}, {"sha": "1d1aee0da2cc7be9c0cd84ad8613f35322df7b81", "filename": "doc/common_tools_writing_lints.md", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,266 +0,0 @@\n-# Common tools for writing lints\n-\n-You may need following tooltips to catch up with common operations.\n-\n-- [Common tools for writing lints](#common-tools-for-writing-lints)\n-  - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n-  - [Checking if an expr is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n-  - [Checking for a specific type](#checking-for-a-specific-type)\n-  - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n-  - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n-  - [Dealing with macros](#dealing-with-macros-and-expansions)\n-\n-Useful Rustc dev guide links:\n-- [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n-- [Diagnostic items](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html)\n-- [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n-- [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n-\n-## Retrieving the type of an expression\n-\n-Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n-\n-- which type does this expression correspond to (using its [`TyKind`][TyKind])?\n-- is it a sized type?\n-- is it a primitive type?\n-- does it implement a trait?\n-\n-This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n-that gives you access to the underlying structure [`Ty`][Ty].\n-\n-Example of use:\n-```rust\n-impl LateLintPass<'_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // Get type of `expr`\n-        let ty = cx.typeck_results().expr_ty(expr);\n-        // Match its kind to enter its type\n-        match ty.kind {\n-            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n-            _ => ()\n-        }\n-    }\n-}\n-```\n-\n-Similarly in [`TypeckResults`][TypeckResults] methods, you have the [`pat_ty()`][pat_ty] method\n-to retrieve a type from a pattern.\n-\n-Two noticeable items here:\n-- `cx` is the lint context [`LateContext`][LateContext]. The two most useful\n-  data structures in this context are `tcx` and the `TypeckResults` returned by\n-  `LateContext::typeck_results`, allowing us to jump to type definitions and\n-  other compilation stages such as HIR.\n-- `typeck_results`'s return value is [`TypeckResults`][TypeckResults] and is\n-  created by type checking step, it includes useful information such as types\n-  of expressions, ways to resolve methods and so on.\n-\n-## Checking if an expr is calling a specific method\n-\n-Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n-\n-```rust\n-impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        // Check our expr is calling a method\n-        if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..]) = &expr.kind\n-            // Check the name of this method is `some_method`\n-            && path.ident.name == sym!(some_method)\n-            // Optionally, check the type of the self argument.\n-            // - See \"Checking for a specific type\"\n-        {\n-                // ...\n-        }\n-    }\n-}\n-```\n-\n-## Checking for a specific type\n-\n-There are three ways to check if an expression type is a specific type we want to check for.\n-All of these methods only check for the base type, generic arguments have to be checked separately.\n-\n-```rust\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n-use clippy_utils::{paths, match_def_path};\n-use rustc_span::symbol::sym;\n-use rustc_hir::LangItem;\n-\n-impl LateLintPass<'_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // Getting the expression type\n-        let ty = cx.typeck_results().expr_ty(expr);\n-\n-        // 1. Using diagnostic items\n-        // The last argument is the diagnostic item to check for\n-        if is_type_diagnostic_item(cx, ty, sym::Option) {\n-            // The type is an `Option`\n-        }\n-\n-        // 2. Using lang items\n-        if is_type_lang_item(cx, ty, LangItem::RangeFull) {\n-            // The type is a full range like `.drain(..)`\n-        }\n-\n-        // 3. Using the type path\n-        // This method should be avoided if possible\n-        if match_def_path(cx, def_id, &paths::RESULT) {\n-            // The type is a `core::result::Result`\n-        }\n-    }\n-}\n-```\n-\n-Prefer using diagnostic items and lang items where possible.\n-\n-## Checking if a type implements a specific trait\n-\n-There are three ways to do this, depending on if the target trait has a diagnostic item, lang item or neither.\n-\n-```rust\n-use clippy_utils::{implements_trait, is_trait_method, match_trait_method, paths};\n-use rustc_span::symbol::sym;\n-\n-impl LateLintPass<'_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // 1. Using diagnostic items with the expression\n-        // we use `is_trait_method` function from Clippy's utils\n-        if is_trait_method(cx, expr, sym::Iterator) {\n-            // method call in `expr` belongs to `Iterator` trait\n-        }\n-\n-        // 2. Using lang items with the expression type\n-        let ty = cx.typeck_results().expr_ty(expr);\n-        if cx.tcx.lang_items()\n-            // we are looking for the `DefId` of `Drop` trait in lang items\n-            .drop_trait()\n-            // then we use it with our type `ty` by calling `implements_trait` from Clippy's utils\n-            .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n-                // `expr` implements `Drop` trait\n-            }\n-\n-        // 3. Using the type path with the expression\n-        // we use `match_trait_method` function from Clippy's utils\n-        // (This method should be avoided if possible)\n-        if match_trait_method(cx, expr, &paths::INTO) {\n-            // `expr` implements `Into` trait\n-        }\n-    }\n-}\n-```\n-\n-> Prefer using diagnostic and lang items, if the target trait has one.\n-\n-We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n-A list of defined paths for Clippy can be found in [paths.rs][paths]\n-\n-## Checking if a type defines a specific method\n-\n-To check if our type defines a method called `some_method`:\n-\n-```rust\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::return_ty;\n-\n-impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n-        // Check if item is a method/function\n-        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind\n-            // Check the method is named `some_method`\n-            && impl_item.ident.name == sym!(some_method)\n-            // We can also check it has a parameter `self`\n-            && signature.decl.implicit_self.has_implicit_self()\n-            // We can go further and even check if its return type is `String`\n-            && is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type))\n-        {\n-            // ...\n-        }\n-    }\n-}\n-```\n-\n-## Dealing with macros and expansions\n-\n-Keep in mind that macros are already expanded and desugaring is already applied\n-to the code representation that you are working with in Clippy. This unfortunately causes a lot of\n-false positives because macro expansions are \"invisible\" unless you actively check for them.\n-Generally speaking, code with macro expansions should just be ignored by Clippy because that code can be\n-dynamic in ways that are difficult or impossible to see.\n-Use the following functions to deal with macros:\n-\n-- `span.from_expansion()`: detects if a span is from macro expansion or desugaring.\n-  Checking this is a common first step in a lint.\n-\n-   ```rust\n-   if expr.span.from_expansion() {\n-       // just forget it\n-       return;\n-   }\n-   ```\n-\n-- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, which macro call expanded it.\n-   It is sometimes useful to check if the context of two spans are equal.\n-\n-   ```rust\n-   // expands to `1 + 0`, but don't lint\n-   1 + mac!()\n-   ```\n-   ```rust\n-   if left.span.ctxt() != right.span.ctxt() {\n-       // the coder most likely cannot modify this expression\n-       return;\n-   }\n-   ```\n-  Note: Code that is not from expansion is in the \"root\" context. So any spans where `from_expansion` returns `true` can\n-  be assumed to have the same context. And so just using `span.from_expansion()` is often good enough.\n-\n-\n-- `in_external_macro(span)`: detect if the given span is from a macro defined in a foreign crate.\n-   If you want the lint to work with macro-generated code, this is the next line of defense to avoid macros\n-   not defined in the current crate. It doesn't make sense to lint code that the coder can't change.\n-\n-   You may want to use it for example to not start linting in macros from other crates\n-\n-   ```rust\n-   #[macro_use]\n-   extern crate a_crate_with_macros;\n-\n-   // `foo` is defined in `a_crate_with_macros`\n-   foo!(\"bar\");\n-\n-   // if we lint the `match` of `foo` call and test its span\n-   assert_eq!(in_external_macro(cx.sess(), match_span), true);\n-   ```\n-\n-- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, what expanded it\n-\n-One thing `SpanContext` is useful for is to check if two spans are in the same context. For example,\n-in `a == b`, `a` and `b` have the same context. In a `macro_rules!` with `a == $b`, `$b` is expanded to some\n-expression with a different context from `a`.\n-\n-   ```rust\n-   macro_rules! m {\n-       ($a:expr, $b:expr) => {\n-           if $a.is_some() {\n-               $b;\n-           }\n-       }\n-   }\n-\n-   let x: Option<u32> = Some(42);\n-   m!(x, x.unwrap());\n-\n-   // These spans are not from the same context\n-   // x.is_some() is from inside the macro\n-   // x.unwrap() is from outside the macro\n-   assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n-   ```\n-\n-[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n-[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n-[TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n-[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n-[LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n-[TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n-[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n-[paths]: ../clippy_utils/src/paths.rs"}, {"sha": "c4f8f989384280659f899f6f6d9820cf0087e8a6", "filename": "doc/release.md", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frelease.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,145 +0,0 @@\n-# Release a new Clippy Version\n-\n-_NOTE: This document is probably only relevant to you, if you're a member of the\n-Clippy team._\n-\n-Clippy is released together with stable Rust releases. The dates for these\n-releases can be found at the [Rust Forge]. This document explains the necessary\n-steps to create a Clippy release.\n-\n-1. [Remerge the `beta` branch](#remerge-the-beta-branch)\n-2. [Update the `beta` branch](#update-the-beta-branch)\n-3. [Find the Clippy commit](#find-the-clippy-commit)\n-4. [Tag the stable commit](#tag-the-stable-commit)\n-5. [Update `CHANGELOG.md`](#update-changelogmd)\n-\n-_NOTE: This document is for stable Rust releases, not for point releases. For\n-point releases, step 1. and 2. should be enough._\n-\n-[Rust Forge]: https://forge.rust-lang.org/\n-\n-\n-## Remerge the `beta` branch\n-\n-This step is only necessary, if since the last release something was backported\n-to the beta Rust release. The remerge is then necessary, to make sure that the\n-Clippy commit, that was used by the now stable Rust release, persists in the\n-tree of the Clippy repository.\n-\n-To find out if this step is necessary run\n-\n-```bash\n-# Assumes that the local master branch is up-to-date\n-$ git fetch upstream\n-$ git branch master --contains upstream/beta\n-```\n-\n-If this command outputs `master`, this step is **not** necessary.\n-\n-```bash\n-# Assuming `HEAD` is the current `master` branch of rust-lang/rust-clippy\n-$ git checkout -b backport_remerge\n-$ git merge upstream/beta\n-$ git diff  # This diff has to be empty, otherwise something with the remerge failed\n-$ git push origin backport_remerge  # This can be pushed to your fork\n-```\n-\n-After this, open a PR to the master branch. In this PR, the commit hash of the\n-`HEAD` of the `beta` branch must exists. In addition to that, no files should\n-be changed by this PR.\n-\n-\n-## Update the `beta` branch\n-\n-This step must be done **after** the PR of the previous step was merged.\n-\n-First, the Clippy commit of the `beta` branch of the Rust repository has to be\n-determined.\n-\n-```bash\n-# Assuming the current directory corresponds to the Rust repository\n-$ git checkout beta\n-$ BETA_SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n-```\n-\n-After finding the Clippy commit, the `beta` branch in the Clippy repository can\n-be updated.\n-\n-```bash\n-# Assuming the current directory corresponds to the Clippy repository\n-$ git checkout beta\n-$ git reset --hard $BETA_SHA\n-$ git push upstream beta\n-```\n-\n-\n-## Find the Clippy commit\n-\n-The first step is to tag the Clippy commit, that is included in the stable Rust\n-release. This commit can be found in the Rust repository.\n-\n-```bash\n-# Assuming the current directory corresponds to the Rust repository\n-$ git fetch upstream    # `upstream` is the `rust-lang/rust` remote\n-$ git checkout 1.XX.0   # XX should be exchanged with the corresponding version\n-$ SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n-```\n-\n-\n-## Tag the stable commit\n-\n-After finding the Clippy commit, it can be tagged with the release number.\n-\n-```bash\n-# Assuming the current directory corresponds to the Clippy repository\n-$ git checkout $SHA\n-$ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version\n-$ git push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote\n-```\n-\n-After this, the release should be available on the Clippy [release page].\n-\n-[release page]: https://github.com/rust-lang/rust-clippy/releases\n-\n-## Update the `stable` branch\n-\n-At this step you should have already checked out the commit of the `rust-1.XX.0`\n-tag. Updating the stable branch from here is as easy as:\n-\n-```bash\n-# Assuming the current directory corresponds to the Clippy repository and the\n-# commit of the just created rust-1.XX.0 tag is checked out.\n-$ git push upstream rust-1.XX.0:stable  # `upstream` is the `rust-lang/rust-clippy` remote\n-```\n-\n-_NOTE: Usually there are no stable backports for Clippy, so this update should\n-be possible without force pushing or anything like this. If there should have\n-happened a stable backport, make sure to re-merge those changes just as with the\n-`beta` branch._\n-\n-## Update `CHANGELOG.md`\n-\n-For this see the document on [how to update the changelog].\n-\n-If you don't have time to do a complete changelog update right away, just update\n-the following parts:\n-\n-- Remove the `(beta)` from the new stable version:\n-\n-  ```markdown\n-  ## Rust 1.XX (beta) -> ## Rust 1.XX\n-  ```\n-\n-- Update the release date line of the new stable version:\n-\n-  ```markdown\n-  Current beta, release 20YY-MM-DD -> Current stable, released 20YY-MM-DD\n-  ```\n-\n-- Update the release date line of the previous stable version:\n-\n-  ```markdown\n-  Current stable, released 20YY-MM-DD -> Released 20YY-MM-DD\n-  ```\n-\n-[how to update the changelog]: https://github.com/rust-lang/rust-clippy/blob/master/doc/changelog_update.md"}, {"sha": "fe8b080f56f2bc0c518c7b3e2049def4eed5b9f1", "filename": "doc/roadmap-2021.md", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Froadmap-2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/853d7eeed688eb8eab9cf88d8189006e712af6ca/doc%2Froadmap-2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Froadmap-2021.md?ref=853d7eeed688eb8eab9cf88d8189006e712af6ca", "patch": "@@ -1,235 +0,0 @@\n-# Roadmap 2021\n-\n-# Summary\n-\n-This Roadmap lays out the plans for Clippy in 2021:\n-\n-- Improving usability and reliability\n-- Improving experience of contributors and maintainers\n-- Develop and specify processes\n-\n-Members of the Clippy team will be assigned tasks from one or more of these\n-topics. The team member is then responsible to complete the assigned tasks. This\n-can either be done by implementing them or by providing mentorship to interested\n-contributors.\n-\n-# Motivation\n-\n-With the ongoing growth of the Rust language and with that of the whole\n-ecosystem, also Clippy gets more and more users and contributors. This is good\n-for the project, but also brings challenges along. Some of these challenges are:\n-\n-- More issues about reliability or usability are popping up\n-- Traffic is hard to handle for a small team\n-- Bigger projects don't get completed due to the lack of processes and/or time\n-  of the team members\n-\n-Additionally, according to the [Rust Roadmap 2021], clear processes should be\n-defined by every team and unified across teams. This Roadmap is the first step\n-towards this.\n-\n-[Rust Roadmap 2021]: https://github.com/rust-lang/rfcs/pull/3037\n-\n-# Explanation\n-\n-This section will explain the things that should be done in 2021. It is\n-important to note, that this document focuses on the \"What?\", not the \"How?\".\n-The later will be addressed in follow-up tracking issue, with an assigned team\n-member.\n-\n-The following is split up in two major sections. The first section covers the\n-user facing plans, the second section the internal plans.\n-\n-## User Facing\n-\n-Clippy should be as pleasant to use and configure as possible. This section\n-covers plans that should be implemented to improve the situation of Clippy in\n-this regard.\n-\n-### Usability\n-\n-In the following, plans to improve the usability are covered.\n-\n-#### No Output After `cargo check`\n-\n-Currently when `cargo clippy` is run after `cargo check`, it does not produce\n-any output. This is especially problematic since `rust-analyzer` is on the rise\n-and it uses `cargo check` for checking code. A fix is already implemented, but\n-it still has to be pushed over the finish line. This also includes the\n-stabilization of the `cargo clippy --fix` command or the support of multi-span\n-suggestions in `rustfix`.\n-\n-- [#4612](https://github.com/rust-lang/rust-clippy/issues/4612)\n-\n-#### `lints.toml` Configuration\n-\n-This is something that comes up every now and then: a reusable configuration\n-file, where lint levels can be defined. Discussions about this often lead to\n-nothing specific or to \"we need an RFC for this\". And this is exactly what needs\n-to be done. Get together with the cargo team and write an RFC and implement such\n-a configuration file somehow and somewhere.\n-\n-- [#3164](https://github.com/rust-lang/rust-clippy/issues/3164)\n-- [cargo#5034](https://github.com/rust-lang/cargo/issues/5034)\n-- [IRLO](https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8)\n-\n-#### Lint Groups\n-\n-There are more and more issues about managing lints in Clippy popping up. Lints\n-are hard to implement with a guarantee of no/few false positives (FPs). One way\n-to address this might be to introduce more lint groups to give users the ability\n-to better manage lints, or improve the process of classifying lints, so that\n-disabling lints due to FPs becomes rare. It is important to note, that Clippy\n-lints are less conservative than `rustc` lints, which won't change in the\n-future.\n-\n-- [#5537](https://github.com/rust-lang/rust-clippy/issues/5537)\n-- [#6366](https://github.com/rust-lang/rust-clippy/issues/6366)\n-\n-### Reliability\n-\n-In the following, plans to improve the reliability are covered.\n-\n-#### False Positive Rate\n-\n-In the worst case, new lints are only available in nightly for 2 weeks, before\n-hitting beta and ultimately stable. This and the fact that fewer people use\n-nightly Rust nowadays makes it more probable that a lint with many FPs hits\n-stable. This leads to annoyed users, that will disable these new lints in the\n-best case and to more annoyed users, that will stop using Clippy in the worst.\n-A process should be developed and implemented to prevent this from happening.\n-\n-- [#6429](https://github.com/rust-lang/rust-clippy/issues/6429)\n-\n-## Internal\n-\n-(The end of) 2020 has shown, that Clippy has to think about the available\n-resources, especially regarding management and maintenance of the project. This\n-section address issues affecting team members and contributors.\n-\n-### Management\n-\n-In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open\n-PRs. This is simultaneously a win and a loss. More issues and PRs means more\n-people are interested in Clippy and in contributing to it. On the other hand, it\n-means for team members more work and for contributors longer wait times for\n-reviews. The following will describe plans how to improve the situation for both\n-team members and contributors.\n-\n-#### Clear Expectations for Team Members\n-\n-According to the [Rust Roadmap 2021], a document specifying what it means to be\n-a member of the team should be produced. This should not put more pressure on\n-the team members, but rather help them and interested folks to know what the\n-expectations are. With this it should also be easier to recruit new team members\n-and may encourage people to get in touch, if they're interested to join.\n-\n-#### Scaling up the Team\n-\n-More people means less work for each individual. Together with the document\n-about expectations for team members, a document defining the process of how to\n-join the team should be produced. This can also increase the stability of the\n-team, in case of current members dropping out (temporarily). There can also be\n-different roles in the team, like people triaging vs. people reviewing.\n-\n-#### Regular Meetings\n-\n-Other teams have regular meetings. Clippy is big enough that it might be worth\n-to also do them. Especially if more people join the team, this can be important\n-for sync-ups. Besides the asynchronous communication, that works well for\n-working on separate lints, a meeting adds a synchronous alternative at a known\n-time. This is especially helpful if there are bigger things that need to be\n-discussed (like the projects in this roadmap). For starters bi-weekly meetings\n-before Rust syncs might make sense.\n-\n-#### Triaging\n-\n-To get a handle on the influx of open issues, a process for triaging issues and\n-PRs should be developed. Officially, Clippy follows the Rust triage process, but\n-currently no one enforces it. This can be improved by sharing triage teams\n-across projects or by implementing dashboards / tools which simplify triaging.\n-\n-### Development\n-\n-Improving the developer and contributor experience is something the Clippy team\n-works on regularly. Though, some things might need special attention and\n-planing. These topics are listed in the following.\n-\n-#### Process for New and Existing Lints\n-\n-As already mentioned above, classifying new lints gets quite hard, because the\n-probability of a buggy lint getting into stable is quite high. A process should\n-be implemented on how to classify lints. In addition, a test system should be\n-developed to find out which lints are currently problematic in real world code\n-to fix or disable them.\n-\n-- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379)\n-- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345)\n-\n-#### Processes\n-\n-Related to the point before, a process for suggesting and discussing major\n-changes should be implemented. It's also not clearly defined when a lint should\n-be enabled or disabled by default. This can also be improved by the test system\n-mentioned above.\n-\n-#### Dev-Tools\n-\n-There's already `cargo dev` which makes Clippy development easier and more\n-pleasant. This can still be expanded, so that it covers more areas of the\n-development process.\n-\n-- [#5394](https://github.com/rust-lang/rust-clippy/issues/5394)\n-\n-#### Contributor Guide\n-\n-Similar to a Clippy Book, which describes how to use Clippy, a book about how to\n-contribute to Clippy might be helpful for new and existing contributors. There's\n-already the `doc` directory in the Clippy repo, this can be turned into a\n-`mdbook`.\n-\n-#### `rustc` integration\n-\n-Recently Clippy was integrated with `git subtree` into the `rust-lang/rust`\n-repository. This made syncing between the two repositories easier. A\n-`#[non_exhaustive]` list of things that still can be improved is:\n-\n-1. Use the same `rustfmt` version and configuration as `rustc`.\n-2. Make `cargo dev` work in the Rust repo, just as it works in the Clippy repo.\n-   E.g. `cargo dev bless` or `cargo dev update_lints`. And even add more things\n-   to it that might be useful for the Rust repo, e.g. `cargo dev deprecate`.\n-3. Easier sync process. The `subtree` situation is not ideal.\n-\n-## Prioritization\n-\n-The most pressing issues for users of Clippy are of course the user facing\n-issues. So there should be a priority on those issues, but without losing track\n-of the internal issues listed in this document.\n-\n-Getting the FP rate of warn/deny-by-default lints under control should have the\n-highest priority. Other user facing issues should also get a high priority, but\n-shouldn't be in the way of addressing internal issues.\n-\n-To better manage the upcoming projects, the basic internal processes, like\n-meetings, tracking issues and documentation, should be established as soon as\n-possible. They might even be necessary to properly manage the projects,\n-regarding the user facing issues.\n-\n-# Prior Art\n-\n-## Rust Roadmap\n-\n-Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n-year a roadmap was published, that defined the bigger plans for the coming\n-years. This years roadmap can be found [here][Rust Roadmap 2021].\n-\n-[RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n-\n-# Drawbacks\n-\n-## Big Roadmap\n-\n-This roadmap is pretty big and not all items listed in this document might be\n-addressed during 2021. Because this is the first roadmap for Clippy, having open\n-tasks at the end of 2021 is fine, but they should be revisited in the 2022\n-roadmap."}]}