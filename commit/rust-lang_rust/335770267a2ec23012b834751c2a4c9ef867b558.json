{"sha": "335770267a2ec23012b834751c2a4c9ef867b558", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNTc3MDI2N2EyZWMyMzAxMmI4MzQ3NTFjMmE0YzllZjg2N2I1NTg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-28T21:13:34Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:32Z"}, "message": "Replace generics_require_inlining with generics.requires_monomorphization", "tree": {"sha": "98cba863cd53abdc3d9351b042789e4ea2415358", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98cba863cd53abdc3d9351b042789e4ea2415358"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/335770267a2ec23012b834751c2a4c9ef867b558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/335770267a2ec23012b834751c2a4c9ef867b558", "html_url": "https://github.com/rust-lang/rust/commit/335770267a2ec23012b834751c2a4c9ef867b558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/335770267a2ec23012b834751c2a4c9ef867b558/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d5b2f4b4e4f0a44606f17f2eb5120507b7ed1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d5b2f4b4e4f0a44606f17f2eb5120507b7ed1e", "html_url": "https://github.com/rust-lang/rust/commit/88d5b2f4b4e4f0a44606f17f2eb5120507b7ed1e"}], "stats": {"total": 28, "additions": 6, "deletions": 22}, "files": [{"sha": "d49df501672873430673eb0f63868bce9f727298", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/335770267a2ec23012b834751c2a4c9ef867b558/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335770267a2ec23012b834751c2a4c9ef867b558/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=335770267a2ec23012b834751c2a4c9ef867b558", "patch": "@@ -34,18 +34,6 @@ use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n-// Returns true if the given set of generics implies that the item it's\n-// associated with must be inlined.\n-fn generics_require_inlining(generics: &ty::Generics) -> bool {\n-    for param in &generics.params {\n-        match param.kind {\n-            GenericParamDefKind::Lifetime { .. } => {}\n-            GenericParamDefKind::Type { .. } => return true,\n-        }\n-    }\n-    false\n-}\n-\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n@@ -60,7 +48,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-            generics_require_inlining(generics)\n+            generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n     }\n@@ -71,7 +59,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n     let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n-    if codegen_fn_attrs.requests_inline() || generics_require_inlining(generics) {\n+    if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n@@ -189,8 +177,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n                         let generics = self.tcx.generics_of(def_id);\n-                        if generics_require_inlining(&generics) ||\n-                                attrs.requests_inline() {\n+                        if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -203,7 +190,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n-                                    generics_require_inlining(&generics)\n+                                    generics.requires_monomorphization(self.tcx)\n                                 }\n                                 _ => false\n                             }"}, {"sha": "7f07a82e311945c5e4e442c65057f5b6ade07e68", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/335770267a2ec23012b834751c2a4c9ef867b558/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335770267a2ec23012b834751c2a4c9ef867b558/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=335770267a2ec23012b834751c2a4c9ef867b558", "patch": "@@ -1262,12 +1262,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemKind::Fn(_, header, ..) => {\n                     let generics = tcx.generics_of(def_id);\n-                    let has_types = generics.params.iter().any(|param| match param.kind {\n-                        ty::GenericParamDefKind::Type { .. } => true,\n-                        _ => false,\n-                    });\n                     let needs_inline =\n-                        (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        (generics.requires_monomorphization(tcx) ||\n+                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline"}]}