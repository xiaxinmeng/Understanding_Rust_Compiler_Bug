{"sha": "45104397e5541b76e281ed9b72cb0a89a4c850eb", "node_id": "C_kwDOAAsO6NoAKDQ1MTA0Mzk3ZTU1NDFiNzZlMjgxZWQ5YjcyY2IwYTg5YTRjODUwZWI", "commit": {"author": {"name": "Michal Nazarewicz", "email": "mina86@mina86.com", "date": "2022-11-29T20:02:11Z"}, "committer": {"name": "Michal Nazarewicz", "email": "mina86@mina86.com", "date": "2023-04-05T17:09:55Z"}, "message": "Refactor core::char::EscapeDefault and co. structures\n\nChange core::char::{EscapeUnicode, EscapeDefault and EscapeDebug}\nstructures from using a state machine to computing escaped sequence\nupfront and during iteration just going through the characters.\n\nThis is arguably simpler since it\u2019s easier to think about having\na buffer and start..end range to iterate over rather than thinking\nabout a state machine.\n\nThis also harmonises implementation of aforementioned iterators and\ncore::ascii::EscapeDefault struct.  This is done by introducing a new\nhelper EscapeIterInner struct which holds the buffer and offers simple\nmethods for iterating over range.\n\nAs a side effect, this probably optimises Display implementation for\nthose types since rather than calling write_char repeatedly, write_str\nis invoked once.  On 64-bit platforms, it also reduces size of some of\nthe structs:\n\n    | Struct                     | Before | After |\n    |----------------------------+--------+-------+\n    | core::char::EscapeUnicode  |     16 |    12 |\n    | core::char::EscapeDefault  |     16 |    12 |\n    | core::char::EscapeDebug    |     16 |    16 |\n\nMy ulterior motive and reason why I started looking into this is\naddition of as_str method to the iterators.  With this change this\nwill became trivial.  It\u2019s also going to be trivial to implement\nDoubleEndedIterator if that\u2019s ever desired.", "tree": {"sha": "061d536123091249c38bad898087709dd7a13e8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061d536123091249c38bad898087709dd7a13e8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45104397e5541b76e281ed9b72cb0a89a4c850eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45104397e5541b76e281ed9b72cb0a89a4c850eb", "html_url": "https://github.com/rust-lang/rust/commit/45104397e5541b76e281ed9b72cb0a89a4c850eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45104397e5541b76e281ed9b72cb0a89a4c850eb/comments", "author": {"login": "mina86", "id": 32383, "node_id": "MDQ6VXNlcjMyMzgz", "avatar_url": "https://avatars.githubusercontent.com/u/32383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mina86", "html_url": "https://github.com/mina86", "followers_url": "https://api.github.com/users/mina86/followers", "following_url": "https://api.github.com/users/mina86/following{/other_user}", "gists_url": "https://api.github.com/users/mina86/gists{/gist_id}", "starred_url": "https://api.github.com/users/mina86/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mina86/subscriptions", "organizations_url": "https://api.github.com/users/mina86/orgs", "repos_url": "https://api.github.com/users/mina86/repos", "events_url": "https://api.github.com/users/mina86/events{/privacy}", "received_events_url": "https://api.github.com/users/mina86/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mina86", "id": 32383, "node_id": "MDQ6VXNlcjMyMzgz", "avatar_url": "https://avatars.githubusercontent.com/u/32383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mina86", "html_url": "https://github.com/mina86", "followers_url": "https://api.github.com/users/mina86/followers", "following_url": "https://api.github.com/users/mina86/following{/other_user}", "gists_url": "https://api.github.com/users/mina86/gists{/gist_id}", "starred_url": "https://api.github.com/users/mina86/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mina86/subscriptions", "organizations_url": "https://api.github.com/users/mina86/orgs", "repos_url": "https://api.github.com/users/mina86/repos", "events_url": "https://api.github.com/users/mina86/events{/privacy}", "received_events_url": "https://api.github.com/users/mina86/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cb92cc83ac6b24d83f8a30763b276cadb8dc41d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb92cc83ac6b24d83f8a30763b276cadb8dc41d", "html_url": "https://github.com/rust-lang/rust/commit/4cb92cc83ac6b24d83f8a30763b276cadb8dc41d"}], "stats": {"total": 477, "additions": 271, "deletions": 206}, "files": [{"sha": "065f1b3e70e689c360b408a8bf0c9bc1e9a6b162", "filename": "library/core/src/ascii.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fascii.rs?ref=45104397e5541b76e281ed9b72cb0a89a4c850eb", "patch": "@@ -9,10 +9,10 @@\n \n #![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n+use crate::escape;\n use crate::fmt;\n use crate::iter::FusedIterator;\n-use crate::ops::Range;\n-use crate::str::from_utf8_unchecked;\n+use crate::num::NonZeroUsize;\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -21,10 +21,7 @@ use crate::str::from_utf8_unchecked;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n-pub struct EscapeDefault {\n-    range: Range<u8>,\n-    data: [u8; 4],\n-}\n+pub struct EscapeDefault(escape::EscapeIterInner<4>);\n \n /// Returns an iterator that produces an escaped version of a `u8`.\n ///\n@@ -90,21 +87,9 @@ pub struct EscapeDefault {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn escape_default(c: u8) -> EscapeDefault {\n-    let (data, len) = match c {\n-        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n-        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n-        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n-        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n-        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n-        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20'..=b'\\x7e' => ([c, 0, 0, 0], 1),\n-        _ => {\n-            let hex_digits: &[u8; 16] = b\"0123456789abcdef\";\n-            ([b'\\\\', b'x', hex_digits[(c >> 4) as usize], hex_digits[(c & 0xf) as usize]], 4)\n-        }\n-    };\n-\n-    return EscapeDefault { range: 0..len, data };\n+    let mut data = [0; 4];\n+    let range = escape::escape_ascii_into(&mut data, c);\n+    EscapeDefault(escape::EscapeIterInner::new(data, range))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -113,33 +98,59 @@ impl Iterator for EscapeDefault {\n \n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n-        self.range.next().map(|i| self.data[i as usize])\n+        self.0.next()\n     }\n+\n+    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.range.size_hint()\n+        let n = self.0.len();\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.0.len()\n     }\n+\n+    #[inline]\n     fn last(mut self) -> Option<u8> {\n-        self.next_back()\n+        self.0.next_back()\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.0.advance_by(n)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {\n+    #[inline]\n     fn next_back(&mut self) -> Option<u8> {\n-        self.range.next_back().map(|i| self.data[i as usize])\n+        self.0.next_back()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.0.advance_back_by(n)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExactSizeIterator for EscapeDefault {}\n+impl ExactSizeIterator for EscapeDefault {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDefault {}\n \n #[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\n impl fmt::Display for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // SAFETY: ok because `escape_default` created only valid utf-8 data\n-        f.write_str(unsafe {\n-            from_utf8_unchecked(&self.data[(self.range.start as usize)..(self.range.end as usize)])\n-        })\n+        f.write_str(self.0.as_str())\n     }\n }\n "}, {"sha": "8f149a9ece2ae7d16736afc4d16e1b891de1b460", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=45104397e5541b76e281ed9b72cb0a89a4c850eb", "patch": "@@ -380,20 +380,7 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn escape_unicode(self) -> EscapeUnicode {\n-        let c = self as u32;\n-\n-        // or-ing 1 ensures that for c==0 the code computes that one\n-        // digit should be printed and (which is the same) avoids the\n-        // (31 - 32) underflow\n-        let msb = 31 - (c | 1).leading_zeros();\n-\n-        // the index of the most significant hex digit\n-        let ms_hex_digit = msb / 4;\n-        EscapeUnicode {\n-            c: self,\n-            state: EscapeUnicodeState::Backslash,\n-            hex_digit_idx: ms_hex_digit as usize,\n-        }\n+        EscapeUnicode::new(self)\n     }\n \n     /// An extended version of `escape_debug` that optionally permits escaping\n@@ -403,21 +390,20 @@ impl char {\n     /// characters, and double quotes in strings.\n     #[inline]\n     pub(crate) fn escape_debug_ext(self, args: EscapeDebugExtArgs) -> EscapeDebug {\n-        let init_state = match self {\n-            '\\0' => EscapeDefaultState::Backslash('0'),\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' => EscapeDefaultState::Backslash(self),\n-            '\"' if args.escape_double_quote => EscapeDefaultState::Backslash(self),\n-            '\\'' if args.escape_single_quote => EscapeDefaultState::Backslash(self),\n+        match self {\n+            '\\0' => EscapeDebug::backslash(b'0'),\n+            '\\t' => EscapeDebug::backslash(b't'),\n+            '\\r' => EscapeDebug::backslash(b'r'),\n+            '\\n' => EscapeDebug::backslash(b'n'),\n+            '\\\\' => EscapeDebug::backslash(self as u8),\n+            '\"' if args.escape_double_quote => EscapeDebug::backslash(self as u8),\n+            '\\'' if args.escape_single_quote => EscapeDebug::backslash(self as u8),\n             _ if args.escape_grapheme_extended && self.is_grapheme_extended() => {\n-                EscapeDefaultState::Unicode(self.escape_unicode())\n+                EscapeDebug::from_unicode(self.escape_unicode())\n             }\n-            _ if is_printable(self) => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n-        };\n-        EscapeDebug(EscapeDefault { state: init_state })\n+            _ if is_printable(self) => EscapeDebug::printable(self),\n+            _ => EscapeDebug::from_unicode(self.escape_unicode()),\n+        }\n     }\n \n     /// Returns an iterator that yields the literal escape code of a character\n@@ -515,15 +501,14 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn escape_default(self) -> EscapeDefault {\n-        let init_state = match self {\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20'..='\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n-        };\n-        EscapeDefault { state: init_state }\n+        match self {\n+            '\\t' => EscapeDefault::backslash(b't'),\n+            '\\r' => EscapeDefault::backslash(b'r'),\n+            '\\n' => EscapeDefault::backslash(b'n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefault::backslash(self as u8),\n+            '\\x20'..='\\x7e' => EscapeDefault::printable(self as u8),\n+            _ => EscapeDefault::from_unicode(self.escape_unicode()),\n+        }\n     }\n \n     /// Returns the number of bytes this `char` would need if encoded in UTF-8."}, {"sha": "6383a5b5ca9607ed4ce7e8e0b941e0d7f829f85b", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 111, "deletions": 140, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=45104397e5541b76e281ed9b72cb0a89a4c850eb", "patch": "@@ -39,8 +39,10 @@ pub use self::methods::encode_utf16_raw;\n pub use self::methods::encode_utf8_raw;\n \n use crate::error::Error;\n+use crate::escape;\n use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;\n+use crate::num::NonZeroUsize;\n \n pub(crate) use self::methods::EscapeDebugExtArgs;\n \n@@ -146,103 +148,52 @@ pub const fn from_digit(num: u32, radix: u32) -> Option<char> {\n /// [`escape_unicode`]: char::escape_unicode\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeUnicode {\n-    c: char,\n-    state: EscapeUnicodeState,\n-\n-    // The index of the next hex digit to be printed (0 if none),\n-    // i.e., the number of remaining hex digits to be printed;\n-    // increasing from the least significant digit: 0x543210\n-    hex_digit_idx: usize,\n-}\n+pub struct EscapeUnicode(escape::EscapeIterInner<10>);\n \n-// The enum values are ordered so that their representation is the\n-// same as the remaining length (besides the hexadecimal digits). This\n-// likely makes `len()` a single load from memory) and inline-worth.\n-#[derive(Clone, Debug)]\n-enum EscapeUnicodeState {\n-    Done,\n-    RightBrace,\n-    Value,\n-    LeftBrace,\n-    Type,\n-    Backslash,\n+impl EscapeUnicode {\n+    fn new(chr: char) -> Self {\n+        let mut data = [0; 10];\n+        let range = escape::escape_unicode_into(&mut data, chr);\n+        Self(escape::EscapeIterInner::new(data, range))\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeUnicode {\n     type Item = char;\n \n+    #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.state {\n-            EscapeUnicodeState::Backslash => {\n-                self.state = EscapeUnicodeState::Type;\n-                Some('\\\\')\n-            }\n-            EscapeUnicodeState::Type => {\n-                self.state = EscapeUnicodeState::LeftBrace;\n-                Some('u')\n-            }\n-            EscapeUnicodeState::LeftBrace => {\n-                self.state = EscapeUnicodeState::Value;\n-                Some('{')\n-            }\n-            EscapeUnicodeState::Value => {\n-                let hex_digit = ((self.c as u32) >> (self.hex_digit_idx * 4)) & 0xf;\n-                let c = char::from_digit(hex_digit, 16).unwrap();\n-                if self.hex_digit_idx == 0 {\n-                    self.state = EscapeUnicodeState::RightBrace;\n-                } else {\n-                    self.hex_digit_idx -= 1;\n-                }\n-                Some(c)\n-            }\n-            EscapeUnicodeState::RightBrace => {\n-                self.state = EscapeUnicodeState::Done;\n-                Some('}')\n-            }\n-            EscapeUnicodeState::Done => None,\n-        }\n+        self.0.next().map(char::from)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = self.len();\n+        let n = self.0.len();\n         (n, Some(n))\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        self.len()\n+        self.0.len()\n     }\n \n-    fn last(self) -> Option<char> {\n-        match self.state {\n-            EscapeUnicodeState::Done => None,\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        self.0.next_back().map(char::from)\n+    }\n \n-            EscapeUnicodeState::RightBrace\n-            | EscapeUnicodeState::Value\n-            | EscapeUnicodeState::LeftBrace\n-            | EscapeUnicodeState::Type\n-            | EscapeUnicodeState::Backslash => Some('}'),\n-        }\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.0.advance_by(n)\n     }\n }\n \n #[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n impl ExactSizeIterator for EscapeUnicode {\n     #[inline]\n     fn len(&self) -> usize {\n-        // The match is a single memory access with no branching\n-        self.hex_digit_idx\n-            + match self.state {\n-                EscapeUnicodeState::Done => 0,\n-                EscapeUnicodeState::RightBrace => 1,\n-                EscapeUnicodeState::Value => 2,\n-                EscapeUnicodeState::LeftBrace => 3,\n-                EscapeUnicodeState::Type => 4,\n-                EscapeUnicodeState::Backslash => 5,\n-            }\n+        self.0.len()\n     }\n }\n \n@@ -252,10 +203,7 @@ impl FusedIterator for EscapeUnicode {}\n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for EscapeUnicode {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for c in self.clone() {\n-            f.write_char(c)?;\n-        }\n-        Ok(())\n+        f.write_str(self.0.as_str())\n     }\n }\n \n@@ -267,90 +215,60 @@ impl fmt::Display for EscapeUnicode {\n /// [`escape_default`]: char::escape_default\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeDefault {\n-    state: EscapeDefaultState,\n-}\n+pub struct EscapeDefault(escape::EscapeIterInner<10>);\n \n-#[derive(Clone, Debug)]\n-enum EscapeDefaultState {\n-    Done,\n-    Char(char),\n-    Backslash(char),\n-    Unicode(EscapeUnicode),\n+impl EscapeDefault {\n+    fn printable(chr: u8) -> Self {\n+        let data = [chr, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n+        Self(escape::EscapeIterInner::new(data, 0..1))\n+    }\n+\n+    fn backslash(chr: u8) -> Self {\n+        let data = [b'\\\\', chr, 0, 0, 0, 0, 0, 0, 0, 0];\n+        Self(escape::EscapeIterInner::new(data, 0..2))\n+    }\n+\n+    fn from_unicode(esc: EscapeUnicode) -> Self {\n+        Self(esc.0)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = char;\n \n+    #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Backslash(c) => {\n-                self.state = EscapeDefaultState::Char(c);\n-                Some('\\\\')\n-            }\n-            EscapeDefaultState::Char(c) => {\n-                self.state = EscapeDefaultState::Done;\n-                Some(c)\n-            }\n-            EscapeDefaultState::Done => None,\n-            EscapeDefaultState::Unicode(ref mut iter) => iter.next(),\n-        }\n+        self.0.next().map(char::from)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = self.len();\n+        let n = self.0.len();\n         (n, Some(n))\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        self.len()\n+        self.0.len()\n     }\n \n-    fn nth(&mut self, n: usize) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Backslash(c) if n == 0 => {\n-                self.state = EscapeDefaultState::Char(c);\n-                Some('\\\\')\n-            }\n-            EscapeDefaultState::Backslash(c) if n == 1 => {\n-                self.state = EscapeDefaultState::Done;\n-                Some(c)\n-            }\n-            EscapeDefaultState::Backslash(_) => {\n-                self.state = EscapeDefaultState::Done;\n-                None\n-            }\n-            EscapeDefaultState::Char(c) => {\n-                self.state = EscapeDefaultState::Done;\n-\n-                if n == 0 { Some(c) } else { None }\n-            }\n-            EscapeDefaultState::Done => None,\n-            EscapeDefaultState::Unicode(ref mut i) => i.nth(n),\n-        }\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        self.0.next_back().map(char::from)\n     }\n \n-    fn last(self) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Unicode(iter) => iter.last(),\n-            EscapeDefaultState::Done => None,\n-            EscapeDefaultState::Backslash(c) | EscapeDefaultState::Char(c) => Some(c),\n-        }\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.0.advance_by(n)\n     }\n }\n \n #[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n impl ExactSizeIterator for EscapeDefault {\n+    #[inline]\n     fn len(&self) -> usize {\n-        match self.state {\n-            EscapeDefaultState::Done => 0,\n-            EscapeDefaultState::Char(_) => 1,\n-            EscapeDefaultState::Backslash(_) => 2,\n-            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n-        }\n+        self.0.len()\n     }\n }\n \n@@ -360,10 +278,7 @@ impl FusedIterator for EscapeDefault {}\n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n impl fmt::Display for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for c in self.clone() {\n-            f.write_char(c)?;\n-        }\n-        Ok(())\n+        f.write_str(self.0.as_str())\n     }\n }\n \n@@ -375,29 +290,85 @@ impl fmt::Display for EscapeDefault {\n /// [`escape_debug`]: char::escape_debug\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n #[derive(Clone, Debug)]\n-pub struct EscapeDebug(EscapeDefault);\n+pub struct EscapeDebug(EscapeDebugInner);\n+\n+#[derive(Clone, Debug)]\n+enum EscapeDebugInner {\n+    Bytes(escape::EscapeIterInner<10>),\n+    Char(char),\n+}\n+\n+impl EscapeDebug {\n+    fn printable(chr: char) -> Self {\n+        // Note: It\u2019s possible to manually encode the EscapeDebugInner inside of\n+        // EscapeIterInner (e.g. with alive=254..255 indicating that data[0..4]\n+        // holds a char) which would likely result in a more optimised code.\n+        // For now we use the option easier to implement.\n+        Self(EscapeDebugInner::Char(chr))\n+    }\n+\n+    fn backslash(chr: u8) -> Self {\n+        let data = [b'\\\\', chr, 0, 0, 0, 0, 0, 0, 0, 0];\n+        let iter = escape::EscapeIterInner::new(data, 0..2);\n+        Self(EscapeDebugInner::Bytes(iter))\n+    }\n+\n+    fn from_unicode(esc: EscapeUnicode) -> Self {\n+        Self(EscapeDebugInner::Bytes(esc.0))\n+    }\n+\n+    fn clear(&mut self) {\n+        let bytes = escape::EscapeIterInner::new([0; 10], 0..0);\n+        self.0 = EscapeDebugInner::Bytes(bytes);\n+    }\n+}\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl Iterator for EscapeDebug {\n     type Item = char;\n+\n+    #[inline]\n     fn next(&mut self) -> Option<char> {\n-        self.0.next()\n+        match self.0 {\n+            EscapeDebugInner::Bytes(ref mut bytes) => bytes.next().map(char::from),\n+            EscapeDebugInner::Char(chr) => {\n+                self.clear();\n+                Some(chr)\n+            }\n+        }\n     }\n+\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n+        let n = self.len();\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n     }\n }\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl ExactSizeIterator for EscapeDebug {}\n+impl ExactSizeIterator for EscapeDebug {\n+    fn len(&self) -> usize {\n+        match &self.0 {\n+            EscapeDebugInner::Bytes(bytes) => bytes.len(),\n+            EscapeDebugInner::Char(_) => 1,\n+        }\n+    }\n+}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl fmt::Display for EscapeDebug {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n+        match &self.0 {\n+            EscapeDebugInner::Bytes(bytes) => f.write_str(bytes.as_str()),\n+            EscapeDebugInner::Char(chr) => f.write_char(*chr),\n+        }\n     }\n }\n "}, {"sha": "66faa0316d1e52087bfb29aaeaf0c795e480c92e", "filename": "library/core/src/escape.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fescape.rs?ref=45104397e5541b76e281ed9b72cb0a89a4c850eb", "patch": "@@ -0,0 +1,97 @@\n+//! Helper code for character escaping.\n+\n+use crate::num::NonZeroUsize;\n+use crate::ops::Range;\n+\n+const HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n+\n+/// Escapes a byte into provided buffer; returns length of escaped\n+/// representation.\n+pub(super) fn escape_ascii_into(output: &mut [u8; 4], byte: u8) -> Range<u8> {\n+    let (data, len) = match byte {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20'..=b'\\x7e' => ([byte, 0, 0, 0], 1),\n+        _ => {\n+            ([b'\\\\', b'x', HEX_DIGITS[(byte >> 4) as usize], HEX_DIGITS[(byte & 0xf) as usize]], 4)\n+        }\n+    };\n+    *output = data;\n+    0..(len as u8)\n+}\n+\n+/// Escapes a character into provided buffer using `\\u{NNNN}` representation.\n+pub(super) fn escape_unicode_into(output: &mut [u8; 10], ch: char) -> Range<u8> {\n+    let ch = (ch as u32) & 0x1f_ffff;\n+\n+    output[9] = b'}';\n+\n+    output[3] = HEX_DIGITS[((ch >> 20) & 15) as usize];\n+    output[4] = HEX_DIGITS[((ch >> 16) & 15) as usize];\n+    output[5] = HEX_DIGITS[((ch >> 12) & 15) as usize];\n+    output[6] = HEX_DIGITS[((ch >> 8) & 15) as usize];\n+    output[7] = HEX_DIGITS[((ch >> 4) & 15) as usize];\n+    output[8] = HEX_DIGITS[((ch >> 0) & 15) as usize];\n+\n+    // or-ing 1 ensures that for ch==0 the code computes that one digit should\n+    // be printed.\n+    let start = (ch | 1).leading_zeros() as usize / 4 - 2;\n+    output[start..start + 3].copy_from_slice(b\"\\\\u{\");\n+\n+    (start as u8)..10\n+}\n+\n+/// An iterator over an fixed-size array.\n+///\n+/// This is essentially equivalent to array\u2019s IntoIter except that indexes are\n+/// limited to u8 to reduce size of the structure.\n+#[derive(Clone, Debug)]\n+pub(super) struct EscapeIterInner<const N: usize> {\n+    // Invariant: data[alive] is all ASCII.\n+    pub(super) data: [u8; N],\n+\n+    // Invariant: alive.start <= alive.end <= N.\n+    pub(super) alive: Range<u8>,\n+}\n+\n+impl<const N: usize> EscapeIterInner<N> {\n+    pub fn new(data: [u8; N], alive: Range<u8>) -> Self {\n+        debug_assert!(alive.start <= alive.end && usize::from(alive.end) <= N, \"{alive:?}\");\n+        let this = Self { data, alive };\n+        debug_assert!(this.as_bytes().is_ascii(), \"Expected ASCII, got {:?}\", this.as_bytes());\n+        this\n+    }\n+\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.data[(self.alive.start as usize)..(self.alive.end as usize)]\n+    }\n+\n+    pub fn as_str(&self) -> &str {\n+        // SAFETY: self.data[self.alive] is all ASCII characters.\n+        unsafe { crate::str::from_utf8_unchecked(self.as_bytes()) }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        usize::from(self.alive.end - self.alive.start)\n+    }\n+\n+    pub fn next(&mut self) -> Option<u8> {\n+        self.alive.next().map(|i| self.data[usize::from(i)])\n+    }\n+\n+    pub fn next_back(&mut self) -> Option<u8> {\n+        self.alive.next_back().map(|i| self.data[usize::from(i)])\n+    }\n+\n+    pub fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.alive.advance_by(n)\n+    }\n+\n+    pub fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n+        self.alive.advance_back_by(n)\n+    }\n+}"}, {"sha": "8842f92459bb3cfd5ae5df25c0188e7816a320d7", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45104397e5541b76e281ed9b72cb0a89a4c850eb/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=45104397e5541b76e281ed9b72cb0a89a4c850eb", "patch": "@@ -381,6 +381,7 @@ pub mod alloc;\n \n // note: does not need to be public\n mod bool;\n+mod escape;\n mod tuple;\n mod unit;\n "}]}