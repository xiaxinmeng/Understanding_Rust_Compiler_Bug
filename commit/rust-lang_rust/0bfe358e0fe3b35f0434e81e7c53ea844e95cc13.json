{"sha": "0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZmUzNThlMGZlM2IzNWYwNDM0ZTgxZTdjNTNlYTg0NGU5NWNjMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T04:07:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T04:07:03Z"}, "message": "Auto merge of #21936 - alexcrichton:fsv2, r=aturon\n\nThis commit is an implementation of [RFC 739][rfc] which adds a new `std::fs`\r\nmodule to the standard library. This module provides much of the same\r\nfunctionality as `std::old_io::fs` but it has many tweaked APIs as well as uses\r\nthe new `std::path` module.\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/pull/739", "tree": {"sha": "091fc970b94cf86a68fd62febef1c5648f5b0d9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/091fc970b94cf86a68fd62febef1c5648f5b0d9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "html_url": "https://github.com/rust-lang/rust/commit/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "134e00be7751a9fdc820981962e4fd7ea97bfff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/134e00be7751a9fdc820981962e4fd7ea97bfff6", "html_url": "https://github.com/rust-lang/rust/commit/134e00be7751a9fdc820981962e4fd7ea97bfff6"}, {"sha": "6bfbad937bdf578e35777d079f8dcfab49758041", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfbad937bdf578e35777d079f8dcfab49758041", "html_url": "https://github.com/rust-lang/rust/commit/6bfbad937bdf578e35777d079f8dcfab49758041"}], "stats": {"total": 2577, "additions": 2564, "deletions": 13}, "files": [{"sha": "45de67865a633321c19b55aedcdb356a735508cb", "filename": "src/libstd/fs.rs", "status": "added", "additions": 1501, "deletions": 0, "changes": 1501, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -0,0 +1,1501 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Filesystem manipulation operations\n+//!\n+//! This module contains basic methods to manipulate the contents of the local\n+//! filesystem. All methods in this module represent cross-platform filesystem\n+//! operations. Extra platform-specific functionality can be found in the\n+//! extension traits of `std::os::$platform`.\n+\n+#![unstable(feature = \"fs\")]\n+\n+use core::prelude::*;\n+\n+use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n+use path::{AsPath, Path, PathBuf};\n+use sys::fs2 as fs_imp;\n+use sys_common::{AsInnerMut, FromInner, AsInner};\n+use vec::Vec;\n+\n+/// A reference to an open file on the filesystem.\n+///\n+/// An instance of a `File` can be read and/or written depending on what options\n+/// it was opened with. Files also implement `Seek` to alter the logical cursor\n+/// that the file contains internally.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut f = try!(File::create(\"foo.txt\"));\n+/// try!(f.write_all(b\"Hello, world!\"));\n+///\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+/// let mut s = String::new();\n+/// try!(f.read_to_string(&mut s));\n+/// assert_eq!(s, \"Hello, world!\");\n+/// # Ok(())\n+/// # }\n+/// ```\n+pub struct File {\n+    inner: fs_imp::File,\n+    path: PathBuf,\n+}\n+\n+/// Metadata information about a file.\n+///\n+/// This structure is returned from the `metadata` function or method and\n+/// represents known metadata about a file such as its permissions, size,\n+/// modification times, etc.\n+pub struct Metadata(fs_imp::FileAttr);\n+\n+/// Iterator over the entries in a directory.\n+///\n+/// This iterator is returned from the `read_dir` function of this module and\n+/// will yield instances of `io::Result<DirEntry>`. Through a `DirEntry`\n+/// information like the entry's path and possibly other metadata can be\n+/// learned.\n+pub struct ReadDir(fs_imp::ReadDir);\n+\n+/// Entries returned by the `ReadDir` iterator.\n+///\n+/// An instance of `DirEntry` represents an entry inside of a directory on the\n+/// filesystem. Each entry can be inspected via methods to learn about the full\n+/// path or possibly other metadata through per-platform extension traits.\n+pub struct DirEntry(fs_imp::DirEntry);\n+\n+/// An iterator that recursively walks over the contents of a directory.\n+pub struct WalkDir {\n+    cur: Option<ReadDir>,\n+    stack: Vec<io::Result<ReadDir>>,\n+}\n+\n+/// Options and flags which can be used to configure how a file is opened.\n+///\n+/// This builder exposes the ability to configure how a `File` is opened and\n+/// what operations are permitted on the open file. The `File::open` and\n+/// `File::create` methods are aliases for commonly used options using this\n+/// builder.\n+#[derive(Clone)]\n+pub struct OpenOptions(fs_imp::OpenOptions);\n+\n+/// Representation of the various permissions on a file.\n+///\n+/// This module only currently provides one bit of information, `readonly`,\n+/// which is exposed on all currently supported platforms. Unix-specific\n+/// functionality, such as mode bits, is available through the\n+/// `os::unix::PermissionsExt` trait.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Permissions(fs_imp::FilePermissions);\n+\n+impl File {\n+    /// Attempts to open a file in read-only mode.\n+    ///\n+    /// See the `OpenOptions::open` method for more details.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error if `path` does not already exist.\n+    /// Other errors may also be returned according to `OpenOptions::open`.\n+    pub fn open<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n+        OpenOptions::new().read(true).open(path)\n+    }\n+\n+    /// Creates a open a file in write-only mode.\n+    ///\n+    /// This method will attempt to open a new file, truncating it if it already\n+    /// exists.\n+    ///\n+    /// See the `OpenOptions::open` function for more details.\n+    pub fn create<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n+        OpenOptions::new().write(true).create(true).truncate(true).open(path)\n+    }\n+\n+    /// Returns the original path that was used to open this file.\n+    pub fn path(&self) -> Option<&Path> {\n+        Some(&self.path)\n+    }\n+\n+    /// Attempt to sync all OS-internal metadata to disk.\n+    ///\n+    /// This function will attempt to ensure that all in-core data reaches the\n+    /// filesystem before returning.\n+    pub fn sync_all(&self) -> io::Result<()> {\n+        self.inner.fsync()\n+    }\n+\n+    /// This function is similar to `sync_all`, except that it may not\n+    /// synchronize file metadata to the filesystem.\n+    ///\n+    /// This is intended for use cases that must synchronize content, but don't\n+    /// need the metadata on disk. The goal of this method is to reduce disk\n+    /// operations.\n+    ///\n+    /// Note that some platforms may simply implement this in terms of\n+    /// `sync_all`.\n+    pub fn sync_data(&self) -> io::Result<()> {\n+        self.inner.datasync()\n+    }\n+\n+    /// Truncates or extends the underlying file, updating the size of\n+    /// this file to become `size`.\n+    ///\n+    /// If the `size` is less than the current file's size, then the file will\n+    /// be shrunk. If it is greater than the current file's size, then the file\n+    /// will be extended to `size` and have all of the intermediate data filled\n+    /// in with 0s.\n+    pub fn set_len(&self, size: u64) -> io::Result<()> {\n+        self.inner.truncate(size)\n+    }\n+\n+    /// Queries information about the underlying file.\n+    pub fn metadata(&self) -> io::Result<Metadata> {\n+        self.inner.file_attr().map(Metadata)\n+    }\n+}\n+\n+impl AsInner<fs_imp::File> for File {\n+    fn as_inner(&self) -> &fs_imp::File { &self.inner }\n+}\n+impl Read for File {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+impl Write for File {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}\n+impl Seek for File {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        self.inner.seek(pos)\n+    }\n+}\n+impl<'a> Read for &'a File {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+impl<'a> Write for &'a File {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}\n+impl<'a> Seek for &'a File {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        self.inner.seek(pos)\n+    }\n+}\n+\n+impl OpenOptions {\n+    /// Creates a blank net set of options ready for configuration.\n+    ///\n+    /// All options are initially set to `false`.\n+    pub fn new() -> OpenOptions {\n+        OpenOptions(fs_imp::OpenOptions::new())\n+    }\n+\n+    /// Set the option for read access.\n+    ///\n+    /// This option, when true, will indicate that the file should be\n+    /// `read`-able if opened.\n+    pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n+        self.0.read(read); self\n+    }\n+\n+    /// Set the option for write access.\n+    ///\n+    /// This option, when true, will indicate that the file should be\n+    /// `write`-able if opened.\n+    pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n+        self.0.write(write); self\n+    }\n+\n+    /// Set the option for the append mode.\n+    ///\n+    /// This option, when true, means that writes will append to a file instead\n+    /// of overwriting previous contents.\n+    pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n+        self.0.append(append); self\n+    }\n+\n+    /// Set the option for truncating a previous file.\n+    ///\n+    /// If a file is successfully opened with this option set it will truncate\n+    /// the file to 0 length if it already exists.\n+    pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n+        self.0.truncate(truncate); self\n+    }\n+\n+    /// Set the option for creating a new file.\n+    ///\n+    /// This option indicates whether a new file will be created if the file\n+    /// does not yet already exist.\n+    pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n+        self.0.create(create); self\n+    }\n+\n+    /// Open a file at `path` with the options specified by `self`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error under a number of different\n+    /// circumstances, to include but not limited to:\n+    ///\n+    /// * Opening a file that does not exist with read access.\n+    /// * Attempting to open a file with access that the user lacks\n+    ///   permissions for\n+    /// * Filesystem-level errors (full disk, etc)\n+    pub fn open<P: AsPath + ?Sized>(&self, path: &P) -> io::Result<File> {\n+        let path = path.as_path();\n+        let inner = try!(fs_imp::File::open(path, &self.0));\n+\n+        // On *BSD systems, we can open a directory as a file and read from\n+        // it: fd=open(\"/tmp\", O_RDONLY); read(fd, buf, N); due to an old\n+        // tradition before the introduction of opendir(3).  We explicitly\n+        // reject it because there are few use cases.\n+        if cfg!(not(any(target_os = \"linux\", target_os = \"android\"))) &&\n+           try!(inner.file_attr()).is_dir() {\n+            Err(Error::new(ErrorKind::InvalidInput, \"is a directory\", None))\n+        } else {\n+            Ok(File { path: path.to_path_buf(), inner: inner })\n+        }\n+    }\n+}\n+impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }\n+}\n+\n+impl Metadata {\n+    /// Returns whether this metadata is for a directory.\n+    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+\n+    /// Returns whether this metadata is for a regular file.\n+    pub fn is_file(&self) -> bool { self.0.is_file() }\n+\n+    /// Returns the size of the file, in bytes, this metadata is for.\n+    pub fn len(&self) -> u64 { self.0.size() }\n+\n+    /// Returns the permissions of the file this metadata is for.\n+    pub fn permissions(&self) -> Permissions {\n+        Permissions(self.0.perm())\n+    }\n+\n+    /// Returns the most recent access time for a file.\n+    ///\n+    /// The return value is in milliseconds since the epoch.\n+    pub fn accessed(&self) -> u64 { self.0.accessed() }\n+\n+    /// Returns the most recent modification time for a file.\n+    ///\n+    /// The return value is in milliseconds since the epoch.\n+    pub fn modified(&self) -> u64 { self.0.modified() }\n+}\n+\n+impl Permissions {\n+    /// Returns whether these permissions describe a readonly file.\n+    pub fn readonly(&self) -> bool { self.0.readonly() }\n+\n+    /// Modify the readonly flag for this set of permissions.\n+    ///\n+    /// This operation does **not** modify the filesystem. To modify the\n+    /// filesystem use the `fs::set_permissions` function.\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        self.0.set_readonly(readonly)\n+    }\n+}\n+\n+impl FromInner<fs_imp::FilePermissions> for Permissions {\n+    fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n+        Permissions(f)\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        self.0.next().map(|entry| entry.map(DirEntry))\n+    }\n+}\n+\n+impl DirEntry {\n+    /// Returns the full path to the file that this entry represents.\n+    ///\n+    /// The full path is created by joining the original path to `read_dir` or\n+    /// `walk_dir` with the filename of this entry.\n+    pub fn path(&self) -> PathBuf { self.0.path() }\n+}\n+\n+/// Remove a file from the underlying filesystem.\n+///\n+/// # Example\n+///\n+/// ```rust,no_run\n+/// use std::fs;\n+///\n+/// fs::remove_file(\"/some/file/path.txt\");\n+/// ```\n+///\n+/// Note that, just because an unlink call was successful, it is not\n+/// guaranteed that a file is immediately deleted (e.g. depending on\n+/// platform, other open file descriptors may prevent immediate removal).\n+///\n+/// # Errors\n+///\n+/// This function will return an error if `path` points to a directory, if the\n+/// user lacks permissions to remove the file, or if some other filesystem-level\n+/// error occurs.\n+pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+    let path = path.as_path();\n+    let e = match fs_imp::unlink(path) {\n+        Ok(()) => return Ok(()),\n+        Err(e) => e,\n+    };\n+    if !cfg!(windows) { return Err(e) }\n+\n+    // On unix, a readonly file can be successfully removed. On windows,\n+    // however, it cannot. To keep the two platforms in line with\n+    // respect to their behavior, catch this case on windows, attempt to\n+    // change it to read-write, and then remove the file.\n+    if e.kind() != ErrorKind::PermissionDenied { return Err(e) }\n+\n+    let attr = match metadata(path) { Ok(a) => a, Err(..) => return Err(e) };\n+    let mut perms = attr.permissions();\n+    if !perms.readonly() { return Err(e) }\n+    perms.set_readonly(false);\n+\n+    if set_permissions(path, perms).is_err() { return Err(e) }\n+    if fs_imp::unlink(path).is_ok() { return Ok(()) }\n+\n+    // Oops, try to put things back the way we found it\n+    let _ = set_permissions(path, attr.permissions());\n+    Err(e)\n+}\n+\n+/// Given a path, query the file system to get information about a file,\n+/// directory, etc.\n+///\n+/// This function will traverse soft links to query information about the\n+/// destination file.\n+///\n+/// # Example\n+///\n+/// ```rust,no_run\n+/// # fn foo() -> std::io::Result<()> {\n+/// use std::fs;\n+///\n+/// let attr = try!(fs::metadata(\"/some/file/path.txt\"));\n+/// // inspect attr ...\n+/// # Ok(())\n+/// # }\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the user lacks the requisite\n+/// permissions to perform a `metadata` call on the given `path` or if there\n+/// is no entry in the filesystem at the provided path.\n+pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> {\n+    fs_imp::stat(path.as_path()).map(Metadata)\n+}\n+\n+/// Rename a file or directory to a new name.\n+///\n+/// # Example\n+///\n+/// ```rust,no_run\n+/// use std::fs;\n+///\n+/// fs::rename(\"foo\", \"bar\");\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the provided `from` doesn't exist, if\n+/// the process lacks permissions to view the contents, if `from` and `to`\n+/// reside on separate filesystems, or if some other intermittent I/O error\n+/// occurs.\n+pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n+                                                      -> io::Result<()> {\n+    fs_imp::rename(from.as_path(), to.as_path())\n+}\n+\n+/// Copies the contents of one file to another. This function will also\n+/// copy the permission bits of the original file to the destination file.\n+///\n+/// This function will **overwrite** the contents of `to`.\n+///\n+/// Note that if `from` and `to` both point to the same file, then the file\n+/// will likely get truncated by this operation.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fs;\n+///\n+/// fs::copy(\"foo.txt\", \"bar.txt\");\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error in the following situations, but is not\n+/// limited to just these cases:\n+///\n+/// * The `from` path is not a file\n+/// * The `from` file does not exist\n+/// * The current process does not have the permission rights to access\n+///   `from` or write `to`\n+pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n+                                                    -> io::Result<u64> {\n+    let from = from.as_path();\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::MismatchedFileTypeForOperation,\n+                              \"the source path is not an existing file\",\n+                              None))\n+    }\n+\n+    let mut reader = try!(File::open(from));\n+    let mut writer = try!(File::create(to));\n+    let perm = try!(reader.metadata()).permissions();\n+\n+    let ret = try!(io::copy(&mut reader, &mut writer));\n+    try!(set_permissions(to, perm));\n+    Ok(ret)\n+}\n+\n+/// Creates a new hard link on the filesystem.\n+///\n+/// The `dst` path will be a link pointing to the `src` path. Note that systems\n+/// often require these two paths to both be located on the same filesystem.\n+pub fn hard_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n+                                                         -> io::Result<()> {\n+    fs_imp::link(src.as_path(), dst.as_path())\n+}\n+\n+/// Creates a new soft link on the filesystem.\n+///\n+/// The `dst` path will be a soft link pointing to the `src` path.\n+pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n+                                                         -> io::Result<()> {\n+    fs_imp::symlink(src.as_path(), dst.as_path())\n+}\n+\n+/// Reads a soft link, returning the file that the link points to.\n+///\n+/// # Errors\n+///\n+/// This function will return an error on failure. Failure conditions include\n+/// reading a file that does not exist or reading a file that is not a soft\n+/// link.\n+pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> {\n+    fs_imp::readlink(path.as_path())\n+}\n+\n+/// Create a new, empty directory at the provided path\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fs;\n+///\n+/// fs::create_dir(\"/some/dir\");\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the user lacks permissions to make a\n+/// new directory at the provided `path`, or if the directory already exists.\n+pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+    fs_imp::mkdir(path.as_path())\n+}\n+\n+/// Recursively create a directory and all of its parent components if they\n+/// are missing.\n+///\n+/// # Errors\n+///\n+/// This function will fail if any directory in the path specified by `path`\n+/// does not already exist and it could not be created otherwise. The specific\n+/// error conditions for when a directory is being created (after it is\n+/// determined to not exist) are outlined by `fs::create_dir`.\n+pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+    let path = path.as_path();\n+    if path.is_dir() { return Ok(()) }\n+    match path.parent() {\n+        Some(p) if p != path => try!(create_dir_all(p)),\n+        _ => {}\n+    }\n+    create_dir(path)\n+}\n+\n+/// Remove an existing, empty directory\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fs;\n+///\n+/// fs::remove_dir(\"/some/dir\");\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the user lacks permissions to remove\n+/// the directory at the provided `path`, or if the directory isn't empty.\n+pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+    fs_imp::rmdir(path.as_path())\n+}\n+\n+/// Removes a directory at this path, after removing all its contents. Use\n+/// carefully!\n+///\n+/// This function does **not** follow soft links and it will simply remove the\n+/// soft link itself.\n+///\n+/// # Errors\n+///\n+/// See `file::remove_file` and `fs::remove_dir`\n+pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+    let path = path.as_path();\n+    for child in try!(read_dir(path)) {\n+        let child = try!(child).path();\n+        let stat = try!(lstat(&*child));\n+        if stat.is_dir() {\n+            try!(remove_dir_all(&*child));\n+        } else {\n+            try!(remove_file(&*child));\n+        }\n+    }\n+    return remove_dir(path);\n+\n+    #[cfg(unix)]\n+    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::lstat(path) }\n+    #[cfg(windows)]\n+    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::stat(path) }\n+}\n+\n+/// Returns an iterator over the entries within a directory.\n+///\n+/// The iterator will yield instances of `io::Result<DirEntry>`. New errors may\n+/// be encountered after an iterator is initially constructed.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::io;\n+/// use std::fs::{self, PathExt, DirEntry};\n+/// use std::path::Path;\n+///\n+/// // one possible implementation of fs::walk_dir only visiting files\n+/// fn visit_dirs(dir: &Path, cb: &mut FnMut(DirEntry)) -> io::Result<()> {\n+///     if dir.is_dir() {\n+///         for entry in try!(fs::read_dir(dir)) {\n+///             let entry = try!(entry);\n+///             if entry.path().is_dir() {\n+///                 try!(visit_dirs(&entry.path(), cb));\n+///             } else {\n+///                 cb(entry);\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the provided `path` doesn't exist, if\n+/// the process lacks permissions to view the contents or if the `path` points\n+/// at a non-directory file\n+pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> {\n+    fs_imp::readdir(path.as_path()).map(ReadDir)\n+}\n+\n+/// Returns an iterator that will recursively walk the directory structure\n+/// rooted at `path`.\n+///\n+/// The path given will not be iterated over, and this will perform iteration in\n+/// some top-down order.  The contents of unreadable subdirectories are ignored.\n+///\n+/// The iterator will yield instances of `io::Result<DirEntry>`. New errors may\n+/// be encountered after an iterator is initially constructed.\n+pub fn walk_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<WalkDir> {\n+    let start = try!(read_dir(path));\n+    Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n+}\n+\n+impl Iterator for WalkDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        loop {\n+            if let Some(ref mut cur) = self.cur {\n+                match cur.next() {\n+                    Some(Err(e)) => return Some(Err(e)),\n+                    Some(Ok(next)) => {\n+                        let path = next.path();\n+                        if path.is_dir() {\n+                            self.stack.push(read_dir(&*path));\n+                        }\n+                        return Some(Ok(next))\n+                    }\n+                    None => {}\n+                }\n+            }\n+            self.cur = None;\n+            match self.stack.pop() {\n+                Some(Err(e)) => return Some(Err(e)),\n+                Some(Ok(next)) => self.cur = Some(next),\n+                None => return None,\n+            }\n+        }\n+    }\n+}\n+\n+/// Utility methods for paths.\n+pub trait PathExt {\n+    /// Get information on the file, directory, etc at this path.\n+    ///\n+    /// Consult the `fs::stat` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    fn metadata(&self) -> io::Result<Metadata>;\n+\n+    /// Boolean value indicator whether the underlying file exists on the local\n+    /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n+    fn exists(&self) -> bool;\n+\n+    /// Whether the underlying implementation (be it a file path, or something\n+    /// else) points at a \"regular file\" on the FS. Will return false for paths\n+    /// to non-existent locations or directories or other non-regular files\n+    /// (named pipes, etc). Follows links when making this determination.\n+    fn is_file(&self) -> bool;\n+\n+    /// Whether the underlying implementation (be it a file path, or something\n+    /// else) is pointing at a directory in the underlying FS. Will return\n+    /// false for paths to non-existent locations or if the item is not a\n+    /// directory (eg files, named pipes, etc). Follows links when making this\n+    /// determination.\n+    fn is_dir(&self) -> bool;\n+}\n+\n+impl PathExt for Path {\n+    fn metadata(&self) -> io::Result<Metadata> { metadata(self) }\n+\n+    fn exists(&self) -> bool { metadata(self).is_ok() }\n+\n+    fn is_file(&self) -> bool {\n+        metadata(self).map(|s| s.is_file()).unwrap_or(false)\n+    }\n+    fn is_dir(&self) -> bool {\n+        metadata(self).map(|s| s.is_dir()).unwrap_or(false)\n+    }\n+}\n+\n+/// Changes the timestamps for a file's last modification and access time.\n+///\n+/// The file at the path specified will have its last access time set to\n+/// `atime` and its modification time set to `mtime`. The times specified should\n+/// be in milliseconds.\n+pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,\n+                                          modified: u64) -> io::Result<()> {\n+    fs_imp::utimes(path.as_path(), accessed, modified)\n+}\n+\n+/// Changes the permissions found on a file or a directory.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # fn foo() -> std::io::Result<()> {\n+/// use std::fs;\n+///\n+/// let mut perms = try!(fs::metadata(\"foo.txt\")).permissions();\n+/// perms.set_readonly(true);\n+/// try!(fs::set_permissions(\"foo.txt\", perms));\n+/// # Ok(())\n+/// # }\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if the provided `path` doesn't exist, if\n+/// the process lacks permissions to change the attributes of the file, or if\n+/// some other I/O error is encountered.\n+pub fn set_permissions<P: AsPath + ?Sized>(path: &P, perm: Permissions)\n+                                           -> io::Result<()> {\n+    fs_imp::set_perm(path.as_path(), perm.0)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+\n+    use fs::{self, File, OpenOptions};\n+    use io::{ErrorKind, SeekFrom};\n+    use path::PathBuf;\n+    use path::Path as Path2;\n+    use os;\n+    use rand::{self, StdRng, Rng};\n+    use str;\n+\n+    macro_rules! check { ($e:expr) => (\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+        }\n+    ) }\n+\n+    macro_rules! error { ($e:expr, $s:expr) => (\n+        match $e {\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+            Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n+                                    format!(\"`{}` did not contain `{}`\", err, $s))\n+        }\n+    ) }\n+\n+    pub struct TempDir(PathBuf);\n+\n+    impl TempDir {\n+        fn join(&self, path: &str) -> PathBuf {\n+            let TempDir(ref p) = *self;\n+            p.join(path)\n+        }\n+\n+        fn path<'a>(&'a self) -> &'a Path2 {\n+            let TempDir(ref p) = *self;\n+            p\n+        }\n+    }\n+\n+    impl Drop for TempDir {\n+        fn drop(&mut self) {\n+            // Gee, seeing how we're testing the fs module I sure hope that we\n+            // at least implement this correctly!\n+            let TempDir(ref p) = *self;\n+            check!(fs::remove_dir_all(p));\n+        }\n+    }\n+\n+    pub fn tmpdir() -> TempDir {\n+        let s = os::tmpdir();\n+        let p = Path2::new(s.as_str().unwrap());\n+        let ret = p.join(&format!(\"rust-{}\", rand::random::<u32>()));\n+        check!(fs::create_dir(&ret));\n+        TempDir(ret)\n+    }\n+\n+    #[test]\n+    fn file_test_io_smoke_test() {\n+        let message = \"it's alright. have a good time\";\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n+        {\n+            let mut write_stream = check!(File::create(filename));\n+            check!(write_stream.write(message.as_bytes()));\n+        }\n+        {\n+            let mut read_stream = check!(File::open(filename));\n+            let mut read_buf = [0; 1028];\n+            let read_str = match check!(read_stream.read(&mut read_buf)) {\n+                -1|0 => panic!(\"shouldn't happen\"),\n+                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n+            };\n+            assert_eq!(read_str.as_slice(), message);\n+        }\n+        check!(fs::remove_file(filename));\n+    }\n+\n+    #[test]\n+    fn invalid_path_raises() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n+        let result = File::open(filename);\n+\n+        if cfg!(unix) {\n+            error!(result, \"o such file or directory\");\n+        }\n+        // error!(result, \"couldn't open path as file\");\n+        // error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n+    }\n+\n+    #[test]\n+    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n+\n+        let result = fs::remove_file(filename);\n+\n+        if cfg!(unix) {\n+            error!(result, \"o such file or directory\");\n+        }\n+        // error!(result, \"couldn't unlink path\");\n+        // error!(result, format!(\"path={}\", filename.display()));\n+    }\n+\n+    #[test]\n+    fn file_test_io_non_positional_read() {\n+        let message: &str = \"ten-four\";\n+        let mut read_mem = [0; 8];\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n+        {\n+            let mut rw_stream = check!(File::create(filename));\n+            check!(rw_stream.write(message.as_bytes()));\n+        }\n+        {\n+            let mut read_stream = check!(File::open(filename));\n+            {\n+                let read_buf = &mut read_mem[0..4];\n+                check!(read_stream.read(read_buf));\n+            }\n+            {\n+                let read_buf = &mut read_mem[4..8];\n+                check!(read_stream.read(read_buf));\n+            }\n+        }\n+        check!(fs::remove_file(filename));\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n+        assert_eq!(read_str, message);\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_and_tell_smoke_test() {\n+        let message = \"ten-four\";\n+        let mut read_mem = [0; 4];\n+        let set_cursor = 4 as u64;\n+        let mut tell_pos_pre_read;\n+        let mut tell_pos_post_read;\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n+        {\n+            let mut rw_stream = check!(File::create(filename));\n+            check!(rw_stream.write(message.as_bytes()));\n+        }\n+        {\n+            let mut read_stream = check!(File::open(filename));\n+            check!(read_stream.seek(SeekFrom::Start(set_cursor)));\n+            tell_pos_pre_read = check!(read_stream.seek(SeekFrom::Current(0)));\n+            check!(read_stream.read(&mut read_mem));\n+            tell_pos_post_read = check!(read_stream.seek(SeekFrom::Current(0)));\n+        }\n+        check!(fs::remove_file(filename));\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n+        assert_eq!(read_str, &message[4..8]);\n+        assert_eq!(tell_pos_pre_read, set_cursor);\n+        assert_eq!(tell_pos_post_read, message.len() as u64);\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_and_write() {\n+        let initial_msg =   \"food-is-yummy\";\n+        let overwrite_msg =    \"-the-bar!!\";\n+        let final_msg =     \"foo-the-bar!!\";\n+        let seek_idx = 3;\n+        let mut read_mem = [0; 13];\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n+        {\n+            let mut rw_stream = check!(File::create(filename));\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n+            check!(rw_stream.seek(SeekFrom::Start(seek_idx)));\n+            check!(rw_stream.write(overwrite_msg.as_bytes()));\n+        }\n+        {\n+            let mut read_stream = check!(File::open(filename));\n+            check!(read_stream.read(&mut read_mem));\n+        }\n+        check!(fs::remove_file(filename));\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n+        assert!(read_str == final_msg);\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_shakedown() {\n+        //                   01234567890123\n+        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let chunk_one: &str = \"qwer\";\n+        let chunk_two: &str = \"asdf\";\n+        let chunk_three: &str = \"zxcv\";\n+        let mut read_mem = [0; 4];\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n+        {\n+            let mut rw_stream = check!(File::create(filename));\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n+        }\n+        {\n+            let mut read_stream = check!(File::open(filename));\n+\n+            check!(read_stream.seek(SeekFrom::End(-4)));\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n+\n+            check!(read_stream.seek(SeekFrom::Current(-9)));\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n+\n+            check!(read_stream.seek(SeekFrom::Start(0)));\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n+        }\n+        check!(fs::remove_file(filename));\n+    }\n+\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_file() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n+        {\n+            let mut opts = OpenOptions::new();\n+            let mut fs = check!(opts.read(true).write(true)\n+                                    .create(true).open(filename));\n+            let msg = \"hw\";\n+            fs.write(msg.as_bytes()).unwrap();\n+\n+            let fstat_res = check!(fs.metadata());\n+            assert!(fstat_res.is_file());\n+        }\n+        let stat_res_fn = check!(fs::metadata(filename));\n+        assert!(stat_res_fn.is_file());\n+        let stat_res_meth = check!(filename.metadata());\n+        assert!(stat_res_meth.is_file());\n+        check!(fs::remove_file(filename));\n+    }\n+\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_dir() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n+        check!(fs::create_dir(filename));\n+        let stat_res_fn = check!(fs::metadata(filename));\n+        assert!(stat_res_fn.is_dir());\n+        let stat_res_meth = check!(filename.metadata());\n+        assert!(stat_res_meth.is_dir());\n+        check!(fs::remove_dir(filename));\n+    }\n+\n+    #[test]\n+    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n+        check!(fs::create_dir(dir));\n+        assert!(dir.is_file() == false);\n+        check!(fs::remove_dir(dir));\n+    }\n+\n+    #[test]\n+    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+        let tmpdir = tmpdir();\n+        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n+        check!(check!(File::create(file)).write(b\"foo\"));\n+        assert!(file.exists());\n+        check!(fs::remove_file(file));\n+        assert!(!file.exists());\n+    }\n+\n+    #[test]\n+    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"before_and_after_dir\");\n+        assert!(!dir.exists());\n+        check!(fs::create_dir(dir));\n+        assert!(dir.exists());\n+        assert!(dir.is_dir());\n+        check!(fs::remove_dir(dir));\n+        assert!(!dir.exists());\n+    }\n+\n+    #[test]\n+    fn file_test_directoryinfo_readdir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"di_readdir\");\n+        check!(fs::create_dir(dir));\n+        let prefix = \"foo\";\n+        for n in range(0, 3) {\n+            let f = dir.join(&format!(\"{}.txt\", n));\n+            let mut w = check!(File::create(&f));\n+            let msg_str = format!(\"{}{}\", prefix, n.to_string());\n+            let msg = msg_str.as_bytes();\n+            check!(w.write(msg));\n+        }\n+        let mut files = check!(fs::read_dir(dir));\n+        let mut mem = [0u8; 4];\n+        for f in files {\n+            let f = f.unwrap().path();\n+            {\n+                let n = f.file_stem().unwrap();\n+                check!(check!(File::open(&f)).read(&mut mem));\n+                let read_str = str::from_utf8(&mem).unwrap();\n+                let expected = format!(\"{}{}\", prefix, n.to_str().unwrap());\n+                assert_eq!(expected.as_slice(), read_str);\n+            }\n+            check!(fs::remove_file(&f));\n+        }\n+        check!(fs::remove_dir(dir));\n+    }\n+\n+    #[test]\n+    fn file_test_walk_dir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"walk_dir\");\n+        check!(fs::create_dir(dir));\n+\n+        let dir1 = &dir.join(\"01/02/03\");\n+        check!(fs::create_dir_all(dir1));\n+        check!(File::create(&dir1.join(\"04\")));\n+\n+        let dir2 = &dir.join(\"11/12/13\");\n+        check!(fs::create_dir_all(dir2));\n+        check!(File::create(&dir2.join(\"14\")));\n+\n+        let mut files = check!(fs::walk_dir(dir));\n+        let mut cur = [0u8; 2];\n+        for f in files {\n+            let f = f.unwrap().path();\n+            let stem = f.file_stem().unwrap().to_str().unwrap();\n+            let root = stem.as_bytes()[0] - b'0';\n+            let name = stem.as_bytes()[1] - b'0';\n+            assert!(cur[root as usize] < name);\n+            cur[root as usize] = name;\n+        }\n+\n+        check!(fs::remove_dir_all(dir));\n+    }\n+\n+    #[test]\n+    fn mkdir_path_already_exists_error() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"mkdir_error_twice\");\n+        check!(fs::create_dir(dir));\n+        let e = fs::create_dir(dir).err().unwrap();\n+        assert_eq!(e.kind(), ErrorKind::PathAlreadyExists);\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir() {\n+        let tmpdir = tmpdir();\n+        let dir = tmpdir.join(\"d1/d2\");\n+        check!(fs::create_dir_all(&dir));\n+        assert!(dir.is_dir())\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_failure() {\n+        let tmpdir = tmpdir();\n+        let dir = tmpdir.join(\"d1\");\n+        let file = dir.join(\"f1\");\n+\n+        check!(fs::create_dir_all(&dir));\n+        check!(File::create(&file));\n+\n+        let result = fs::create_dir_all(&file);\n+\n+        assert!(result.is_err());\n+        // error!(result, \"couldn't recursively mkdir\");\n+        // error!(result, \"couldn't create directory\");\n+        // error!(result, \"mode=0700\");\n+        // error!(result, format!(\"path={}\", file.display()));\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_slash() {\n+        check!(fs::create_dir_all(&Path2::new(\"/\")));\n+    }\n+\n+    // FIXME(#12795) depends on lstat to work on windows\n+    #[cfg(not(windows))]\n+    #[test]\n+    fn recursive_rmdir() {\n+        let tmpdir = tmpdir();\n+        let d1 = tmpdir.join(\"d1\");\n+        let dt = d1.join(\"t\");\n+        let dtt = dt.join(\"t\");\n+        let d2 = tmpdir.join(\"d2\");\n+        let canary = d2.join(\"do_not_delete\");\n+        check!(fs::create_dir_all(&dtt));\n+        check!(fs::create_dir_all(&d2));\n+        check!(check!(File::create(&canary)).write(b\"foo\"));\n+        check!(fs::soft_link(&d2, &dt.join(\"d2\")));\n+        check!(fs::remove_dir_all(&d1));\n+\n+        assert!(!d1.is_dir());\n+        assert!(canary.exists());\n+    }\n+\n+    #[test]\n+    fn unicode_path_is_dir() {\n+        assert!(Path2::new(\".\").is_dir());\n+        assert!(!Path2::new(\"test/stdtest/fs.rs\").is_dir());\n+\n+        let tmpdir = tmpdir();\n+\n+        let mut dirpath = tmpdir.path().to_path_buf();\n+        dirpath.push(&format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n+        check!(fs::create_dir(&dirpath));\n+        assert!(dirpath.is_dir());\n+\n+        let mut filepath = dirpath;\n+        filepath.push(\"unicode-file-\\u{ac00}\\u{4e00}\\u{30fc}\\u{4f60}\\u{597d}.rs\");\n+        check!(File::create(&filepath)); // ignore return; touch only\n+        assert!(!filepath.is_dir());\n+        assert!(filepath.exists());\n+    }\n+\n+    #[test]\n+    fn unicode_path_exists() {\n+        assert!(Path2::new(\".\").exists());\n+        assert!(!Path2::new(\"test/nonexistent-bogus-path\").exists());\n+\n+        let tmpdir = tmpdir();\n+        let unicode = tmpdir.path();\n+        let unicode = unicode.join(&format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        check!(fs::create_dir(&unicode));\n+        assert!(unicode.exists());\n+        assert!(!Path2::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+    }\n+\n+    #[test]\n+    fn copy_file_does_not_exist() {\n+        let from = Path2::new(\"test/nonexistent-bogus-path\");\n+        let to = Path2::new(\"test/other-bogus-path\");\n+\n+        match fs::copy(&from, &to) {\n+            Ok(..) => panic!(),\n+            Err(..) => {\n+                assert!(!from.exists());\n+                assert!(!to.exists());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn copy_file_ok() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        check!(check!(File::create(&input)).write(b\"hello\"));\n+        check!(fs::copy(&input, &out));\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&out)).read_to_end(&mut v));\n+        assert_eq!(v.as_slice(), b\"hello\");\n+\n+        assert_eq!(check!(input.metadata()).permissions(),\n+                   check!(out.metadata()).permissions());\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        check!(File::create(&out));\n+        match fs::copy(&*out, tmpdir.path()) {\n+            Ok(..) => panic!(), Err(..) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_exists() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in\");\n+        let output = tmpdir.join(\"out\");\n+\n+        check!(check!(File::create(&input)).write(\"foo\".as_bytes()));\n+        check!(check!(File::create(&output)).write(\"bar\".as_bytes()));\n+        check!(fs::copy(&input, &output));\n+\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&output)).read_to_end(&mut v));\n+        assert_eq!(v, b\"foo\".to_vec());\n+    }\n+\n+    #[test]\n+    fn copy_file_src_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        match fs::copy(tmpdir.path(), &out) {\n+            Ok(..) => panic!(), Err(..) => {}\n+        }\n+        assert!(!out.exists());\n+    }\n+\n+    #[test]\n+    fn copy_file_preserves_perm_bits() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        let attr = check!(check!(File::create(&input)).metadata());\n+        let mut p = attr.permissions();\n+        p.set_readonly(true);\n+        check!(fs::set_permissions(&input, p));\n+        check!(fs::copy(&input, &out));\n+        assert!(check!(out.metadata()).permissions().readonly());\n+    }\n+\n+    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n+    #[test]\n+    fn symlinks_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n+        check!(fs::soft_link(&input, &out));\n+        // if cfg!(not(windows)) {\n+        //     assert_eq!(check!(lstat(&out)).kind, FileType::Symlink);\n+        //     assert_eq!(check!(out.lstat()).kind, FileType::Symlink);\n+        // }\n+        assert_eq!(check!(fs::metadata(&out)).len(),\n+                   check!(fs::metadata(&input)).len());\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&out)).read_to_end(&mut v));\n+        assert_eq!(v, b\"foobar\".to_vec());\n+    }\n+\n+    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n+    #[test]\n+    fn symlink_noexist() {\n+        let tmpdir = tmpdir();\n+        // symlinks can point to things that don't exist\n+        check!(fs::soft_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n+        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))),\n+                   tmpdir.join(\"foo\"));\n+    }\n+\n+    #[test]\n+    fn readlink_not_symlink() {\n+        let tmpdir = tmpdir();\n+        match fs::read_link(tmpdir.path()) {\n+            Ok(..) => panic!(\"wanted a failure\"),\n+            Err(..) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn links_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n+        check!(fs::hard_link(&input, &out));\n+        assert_eq!(check!(fs::metadata(&out)).len(),\n+                   check!(fs::metadata(&input)).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(),\n+                   check!(input.metadata()).len());\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&out)).read_to_end(&mut v));\n+        assert_eq!(v, b\"foobar\".to_vec());\n+\n+        // can't link to yourself\n+        match fs::hard_link(&input, &input) {\n+            Ok(..) => panic!(\"wanted a failure\"),\n+            Err(..) => {}\n+        }\n+        // can't link to something that doesn't exist\n+        match fs::hard_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n+            Ok(..) => panic!(\"wanted a failure\"),\n+            Err(..) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn chmod_works() {\n+        let tmpdir = tmpdir();\n+        let file = tmpdir.join(\"in.txt\");\n+\n+        check!(File::create(&file));\n+        let attr = check!(fs::metadata(&file));\n+        assert!(!attr.permissions().readonly());\n+        let mut p = attr.permissions();\n+        p.set_readonly(true);\n+        check!(fs::set_permissions(&file, p.clone()));\n+        let attr = check!(fs::metadata(&file));\n+        assert!(attr.permissions().readonly());\n+\n+        match fs::set_permissions(&tmpdir.join(\"foo\"), p) {\n+            Ok(..) => panic!(\"wanted a panic\"),\n+            Err(..) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn sync_doesnt_kill_anything() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = check!(File::create(&path));\n+        check!(file.sync_all());\n+        check!(file.sync_data());\n+        check!(file.write(b\"foo\"));\n+        check!(file.sync_all());\n+        check!(file.sync_data());\n+    }\n+\n+    #[test]\n+    fn truncate_works() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = check!(File::create(&path));\n+        check!(file.write(b\"foo\"));\n+        check!(file.sync_all());\n+\n+        // Do some simple things with truncation\n+        assert_eq!(check!(file.metadata()).len(), 3);\n+        check!(file.set_len(10));\n+        assert_eq!(check!(file.metadata()).len(), 10);\n+        check!(file.write(b\"bar\"));\n+        check!(file.sync_all());\n+        assert_eq!(check!(file.metadata()).len(), 10);\n+\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&path)).read_to_end(&mut v));\n+        assert_eq!(v, b\"foobar\\0\\0\\0\\0\".to_vec());\n+\n+        // Truncate to a smaller length, don't seek, and then write something.\n+        // Ensure that the intermediate zeroes are all filled in (we're seeked\n+        // past the end of the file).\n+        check!(file.set_len(2));\n+        assert_eq!(check!(file.metadata()).len(), 2);\n+        check!(file.write(b\"wut\"));\n+        check!(file.sync_all());\n+        assert_eq!(check!(file.metadata()).len(), 9);\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&path)).read_to_end(&mut v));\n+        assert_eq!(v, b\"fo\\0\\0\\0\\0wut\".to_vec());\n+    }\n+\n+    #[test]\n+    fn open_flavors() {\n+        use fs::OpenOptions as OO;\n+        fn c<T: Clone>(t: &T) -> T { t.clone() }\n+\n+        let tmpdir = tmpdir();\n+\n+        let mut r = OO::new(); r.read(true);\n+        let mut w = OO::new(); w.write(true);\n+        let mut rw = OO::new(); rw.write(true).read(true);\n+\n+        match r.open(&tmpdir.join(\"a\")) {\n+            Ok(..) => panic!(), Err(..) => {}\n+        }\n+\n+        // Perform each one twice to make sure that it succeeds the second time\n+        // (where the file exists)\n+        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n+        assert!(tmpdir.join(\"b\").exists());\n+        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n+        check!(w.open(&tmpdir.join(\"b\")));\n+\n+        check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n+        assert!(tmpdir.join(\"c\").exists());\n+        check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n+        check!(rw.open(&tmpdir.join(\"c\")));\n+\n+        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n+        assert!(tmpdir.join(\"d\").exists());\n+        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n+        check!(c(&w).append(true).open(&tmpdir.join(\"d\")));\n+\n+        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n+        assert!(tmpdir.join(\"e\").exists());\n+        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n+        check!(c(&rw).append(true).open(&tmpdir.join(\"e\")));\n+\n+        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n+        assert!(tmpdir.join(\"f\").exists());\n+        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n+        check!(c(&w).truncate(true).open(&tmpdir.join(\"f\")));\n+\n+        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n+        assert!(tmpdir.join(\"g\").exists());\n+        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n+        check!(c(&rw).truncate(true).open(&tmpdir.join(\"g\")));\n+\n+        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foo\".as_bytes()));\n+        check!(r.open(&tmpdir.join(\"h\")));\n+        {\n+            let mut f = check!(r.open(&tmpdir.join(\"h\")));\n+            assert!(f.write(\"wut\".as_bytes()).is_err());\n+        }\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+        {\n+            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"bar\".as_bytes()));\n+        }\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 6);\n+        {\n+            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"bar\".as_bytes()));\n+        }\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+    }\n+\n+    #[test]\n+    fn utime() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"a\");\n+        check!(File::create(&path));\n+        // These numbers have to be bigger than the time in the day to account\n+        // for timezones Windows in particular will fail in certain timezones\n+        // with small enough values\n+        check!(fs::set_file_times(&path, 100000, 200000));\n+        assert_eq!(check!(path.metadata()).accessed(), 100000);\n+        assert_eq!(check!(path.metadata()).modified(), 200000);\n+    }\n+\n+    #[test]\n+    fn utime_noexist() {\n+        let tmpdir = tmpdir();\n+\n+        match fs::set_file_times(&tmpdir.join(\"a\"), 100, 200) {\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn binary_file() {\n+        let mut bytes = [0; 1024];\n+        StdRng::new().ok().unwrap().fill_bytes(&mut bytes);\n+\n+        let tmpdir = tmpdir();\n+\n+        check!(check!(File::create(&tmpdir.join(\"test\"))).write(&bytes));\n+        let mut v = Vec::new();\n+        check!(check!(File::open(&tmpdir.join(\"test\"))).read_to_end(&mut v));\n+        assert!(v == bytes.as_slice());\n+    }\n+\n+    #[test]\n+    fn unlink_readonly() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"file\");\n+        check!(File::create(&path));\n+        let mut perm = check!(fs::metadata(&path)).permissions();\n+        perm.set_readonly(true);\n+        check!(fs::set_permissions(&path, perm));\n+        check!(fs::remove_file(&path));\n+    }\n+}"}, {"sha": "637b1950985fd79f2e9e5c278192aead8c048157", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -22,6 +22,7 @@\n //! contained in this module.\n \n pub use super::{Read, ReadExt, Write, WriteExt, BufRead, BufReadExt};\n+pub use fs::PathExt;\n \n // FIXME: pub use as `Seek` when the name isn't in the actual prelude any more\n pub use super::Seek as NewSeek;"}, {"sha": "967789dd41144bcbec8ed4505724581f000b71e4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -249,6 +249,7 @@ pub mod dynamic_lib;\n pub mod ffi;\n pub mod old_io;\n pub mod io;\n+pub mod fs;\n pub mod os;\n pub mod env;\n pub mod path;"}, {"sha": "776fa27086781028d99ea8d73fb78824f8758e63", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -999,6 +999,12 @@ impl cmp::Ord for PathBuf {\n     }\n }\n \n+impl AsOsStr for PathBuf {\n+    fn as_os_str(&self) -> &OsStr {\n+        &self.inner[]\n+    }\n+}\n+\n /// A slice of a path (akin to `str`).\n ///\n /// This type supports a number of operations for inspecting a path, including"}, {"sha": "80fa5f64597e95c8091a1032b56fa9fab45b8a33", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -95,20 +95,30 @@ pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n }\n \n /// A trait for viewing representations from std types\n+#[doc(hidden)]\n pub trait AsInner<Inner: ?Sized> {\n     fn as_inner(&self) -> &Inner;\n }\n \n+/// A trait for viewing representations from std types\n+#[doc(hidden)]\n+pub trait AsInnerMut<Inner: ?Sized> {\n+    fn as_inner_mut(&mut self) -> &mut Inner;\n+}\n+\n /// A trait for extracting representations from std types\n+#[doc(hidden)]\n pub trait IntoInner<Inner> {\n     fn into_inner(self) -> Inner;\n }\n \n /// A trait for creating std types from internal representations\n+#[doc(hidden)]\n pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n \n+#[doc(hidden)]\n pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn program(&self) -> &CString;\n     fn args(&self) -> &[CString];"}, {"sha": "cf05733cc18af07040bf705984be954777e43ae9", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -154,6 +154,9 @@ extern {\n                       buf: *mut libc::c_char,\n                       buflen: libc::size_t,\n                       result: *mut *mut passwd) -> libc::c_int;\n+\n+    pub fn utimes(filename: *const libc::c_char,\n+                  times: *const libc::timeval) -> libc::c_int;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "689bbda83222997e9ff060974c49314327e41fe3", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -31,11 +31,14 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-use vec::Vec;\n-use sys::os_str::Buf;\n-use sys_common::{AsInner, IntoInner, FromInner};\n use ffi::{OsStr, OsString};\n+use fs::{Permissions, OpenOptions};\n+use fs;\n use libc;\n+use mem;\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, AsInnerMut, IntoInner, FromInner};\n+use vec::Vec;\n \n use old_io;\n \n@@ -54,6 +57,12 @@ impl AsRawFd for old_io::fs::File {\n     }\n }\n \n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> Fd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n impl AsRawFd for old_io::pipe::PipeStream {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n@@ -123,18 +132,49 @@ impl OsStringExt for OsString {\n \n // Unix-specific extensions to `OsStr`.\n pub trait OsStrExt {\n+    fn from_byte_slice(slice: &[u8]) -> &OsStr;\n     fn as_byte_slice(&self) -> &[u8];\n }\n \n impl OsStrExt for OsStr {\n+    fn from_byte_slice(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n     fn as_byte_slice(&self) -> &[u8] {\n         &self.as_inner().inner\n     }\n }\n \n+// Unix-specific extensions to `Permissions`\n+pub trait PermissionsExt {\n+    fn set_mode(&mut self, mode: i32);\n+}\n+\n+impl PermissionsExt for Permissions {\n+    fn set_mode(&mut self, mode: i32) {\n+        *self = FromInner::from_inner(FromInner::from_inner(mode));\n+    }\n+}\n+\n+// Unix-specific extensions to `OpenOptions`\n+pub trait OpenOptionsExt {\n+    /// Set the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    fn mode(&mut self, mode: i32) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n-    pub use super::{Fd, AsRawFd};\n+    #[doc(no_inline)]\n+    pub use super::{Fd, AsRawFd, OsStrExt, OsStringExt, PermissionsExt};\n }"}, {"sha": "f0943de5378093ae055fc28026eafcea94adf010", "filename": "src/libstd/sys/unix/fd.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+use io::prelude::*;\n+\n+use io;\n+use libc::{self, c_int, size_t, c_void};\n+use mem;\n+use sys::cvt;\n+\n+pub type fd_t = c_int;\n+\n+pub struct FileDesc {\n+    fd: c_int,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: c_int) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> c_int { self.fd }\n+\n+    /// Extract the actual filedescriptor without closing it.\n+    pub fn into_raw(self) -> c_int {\n+        let fd = self.fd;\n+        unsafe { mem::forget(self) };\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let ret = try!(cvt(unsafe {\n+            libc::read(self.fd,\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       buf.len() as size_t)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = try!(cvt(unsafe {\n+            libc::write(self.fd,\n+                        buf.as_ptr() as *const c_void,\n+                        buf.len() as size_t)\n+        }));\n+        Ok(ret as usize)\n+    }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.fd > libc::STDERR_FILENO {\n+            let _ = unsafe { libc::close(self.fd) };\n+        }\n+    }\n+}"}, {"sha": "070b32483499ac496ba3ec5fa62e695f28bab7af", "filename": "src/libstd/sys/unix/fs2.rs", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -0,0 +1,378 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+use io::prelude::*;\n+use os::unix::prelude::*;\n+\n+use ffi::{self, CString, OsString, AsOsStr, OsStr};\n+use io::{self, Error, Seek, SeekFrom};\n+use libc::{self, c_int, c_void, size_t, off_t, c_char, mode_t};\n+use mem;\n+use path::{Path, PathBuf};\n+use ptr;\n+use rc::Rc;\n+use sys::fd::FileDesc;\n+use sys::{c, cvt, cvt_r};\n+use sys_common::FromInner;\n+use vec::Vec;\n+\n+pub struct File(FileDesc);\n+\n+pub struct FileAttr {\n+    stat: libc::stat,\n+}\n+\n+pub struct ReadDir {\n+    dirp: *mut libc::DIR,\n+    root: Rc<PathBuf>,\n+}\n+\n+pub struct DirEntry {\n+    buf: Vec<u8>,\n+    dirent: *mut libc::dirent_t,\n+    root: Rc<PathBuf>,\n+}\n+\n+#[derive(Clone)]\n+pub struct OpenOptions {\n+    flags: c_int,\n+    read: bool,\n+    write: bool,\n+    mode: mode_t,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions { mode: mode_t }\n+\n+impl FileAttr {\n+    pub fn is_dir(&self) -> bool {\n+        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFDIR\n+    }\n+    pub fn is_file(&self) -> bool {\n+        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFREG\n+    }\n+    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n+    }\n+\n+    pub fn accessed(&self) -> u64 {\n+        self.mktime(self.stat.st_atime as u64, self.stat.st_atime_nsec as u64)\n+    }\n+    pub fn modified(&self) -> u64 {\n+        self.mktime(self.stat.st_mtime as u64, self.stat.st_mtime_nsec as u64)\n+    }\n+\n+    // times are in milliseconds (currently)\n+    fn mktime(&self, secs: u64, nsecs: u64) -> u64 {\n+        secs * 1000 + nsecs / 1000000\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            self.mode &= !0o222;\n+        } else {\n+            self.mode |= 0o222;\n+        }\n+    }\n+}\n+\n+impl FromInner<i32> for FilePermissions {\n+    fn from_inner(mode: i32) -> FilePermissions {\n+        FilePermissions { mode: mode as mode_t }\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        extern {\n+            fn rust_dirent_t_size() -> c_int;\n+        }\n+\n+        let mut buf: Vec<u8> = Vec::with_capacity(unsafe {\n+            rust_dirent_t_size() as usize\n+        });\n+        let ptr = buf.as_mut_ptr() as *mut libc::dirent_t;\n+\n+        let mut entry_ptr = ptr::null_mut();\n+        loop {\n+            if unsafe { libc::readdir_r(self.dirp, ptr, &mut entry_ptr) != 0 } {\n+                return Some(Err(Error::last_os_error()))\n+            }\n+            if entry_ptr.is_null() {\n+                return None\n+            }\n+\n+            let entry = DirEntry {\n+                buf: buf,\n+                dirent: entry_ptr,\n+                root: self.root.clone()\n+            };\n+            if entry.name_bytes() == b\".\" || entry.name_bytes() == b\"..\" {\n+                buf = entry.buf;\n+            } else {\n+                return Some(Ok(entry))\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for ReadDir {\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::closedir(self.dirp) };\n+        debug_assert_eq!(r, 0);\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        self.root.join(<OsStr as OsStrExt>::from_byte_slice(self.name_bytes()))\n+    }\n+\n+    fn name_bytes(&self) -> &[u8] {\n+        extern {\n+            fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n+        }\n+        unsafe {\n+            let ptr = rust_list_dir_val(self.dirent);\n+            ffi::c_str_to_bytes(mem::copy_lifetime(self, &ptr))\n+        }\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            flags: 0,\n+            read: false,\n+            write: false,\n+            mode: libc::S_IRUSR | libc::S_IWUSR,\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+\n+    pub fn append(&mut self, append: bool) {\n+        self.flag(libc::O_APPEND, append);\n+    }\n+\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.flag(libc::O_TRUNC, truncate);\n+    }\n+\n+    pub fn create(&mut self, create: bool) {\n+        self.flag(libc::O_CREAT, create);\n+    }\n+\n+    pub fn mode(&mut self, mode: i32) {\n+        self.mode = mode as mode_t;\n+    }\n+\n+    fn flag(&mut self, bit: c_int, on: bool) {\n+        if on {\n+            self.flags |= bit;\n+        } else {\n+            self.flags &= !bit;\n+        }\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let flags = opts.flags | match (opts.read, opts.write) {\n+            (true, true) => libc::O_RDWR,\n+            (false, true) => libc::O_WRONLY,\n+            (true, false) |\n+            (false, false) => libc::O_RDONLY,\n+        };\n+        let path = cstr(path);\n+        let fd = try!(cvt_r(|| unsafe {\n+            libc::open(path.as_ptr(), flags, opts.mode)\n+        }));\n+        Ok(File(FileDesc::new(fd)))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let mut stat: libc::stat = unsafe { mem::zeroed() };\n+        try!(cvt(unsafe { libc::fstat(self.0.raw(), &mut stat) }));\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        try!(cvt_r(|| unsafe { libc::fsync(self.0.raw()) }));\n+        Ok(())\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        try!(cvt_r(|| unsafe { os_datasync(self.0.raw()) }));\n+        return Ok(());\n+\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        unsafe fn os_datasync(fd: c_int) -> c_int {\n+            libc::fcntl(fd, libc::F_FULLFSYNC)\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }\n+        #[cfg(not(any(target_os = \"macos\",\n+                      target_os = \"ios\",\n+                      target_os = \"linux\")))]\n+        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }\n+    }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        try!(cvt_r(|| unsafe {\n+            libc::ftruncate(self.0.raw(), size as libc::off_t)\n+        }));\n+        Ok(())\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            SeekFrom::Start(off) => (libc::SEEK_SET, off as off_t),\n+            SeekFrom::End(off) => (libc::SEEK_END, off as off_t),\n+            SeekFrom::Current(off) => (libc::SEEK_CUR, off as off_t),\n+        };\n+        let n = try!(cvt(unsafe { libc::lseek(self.0.raw(), pos, whence) }));\n+        Ok(n as u64)\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+}\n+\n+fn cstr(path: &Path) -> CString {\n+    CString::from_slice(path.as_os_str().as_byte_slice())\n+}\n+\n+pub fn mkdir(p: &Path) -> io::Result<()> {\n+    let p = cstr(p);\n+    try!(cvt(unsafe { libc::mkdir(p.as_ptr(), 0o777) }));\n+    Ok(())\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let root = Rc::new(p.to_path_buf());\n+    let p = cstr(p);\n+    unsafe {\n+        let ptr = libc::opendir(p.as_ptr());\n+        if ptr.is_null() {\n+            Err(Error::last_os_error())\n+        } else {\n+            Ok(ReadDir { dirp: ptr, root: root })\n+        }\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    let p = cstr(p);\n+    try!(cvt(unsafe { libc::unlink(p.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    let old = cstr(old);\n+    let new = cstr(new);\n+    try!(cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    let p = cstr(p);\n+    try!(cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) }));\n+    Ok(())\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    let p = cstr(p);\n+    try!(cvt(unsafe { libc::rmdir(p.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn chown(p: &Path, uid: isize, gid: isize) -> io::Result<()> {\n+    let p = cstr(p);\n+    try!(cvt_r(|| unsafe {\n+        libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n+    }));\n+    Ok(())\n+}\n+\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    let c_path = cstr(p);\n+    let p = c_path.as_ptr();\n+    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n+    if len < 0 {\n+        len = 1024; // FIXME: read PATH_MAX from C ffi?\n+    }\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as usize);\n+    unsafe {\n+        let n = try!(cvt({\n+            libc::readlink(p, buf.as_ptr() as *mut c_char, len as size_t)\n+        }));\n+        buf.set_len(n as usize);\n+    }\n+    let s: OsString = OsStringExt::from_vec(buf);\n+    Ok(PathBuf::new(&s))\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n+    try!(cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n+    let src = cstr(src);\n+    let dst = cstr(dst);\n+    try!(cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p);\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe { libc::stat(p.as_ptr(), &mut stat) }));\n+    Ok(FileAttr { stat: stat })\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p);\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe { libc::lstat(p.as_ptr(), &mut stat) }));\n+    Ok(FileAttr { stat: stat })\n+}\n+\n+pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n+    let p = cstr(p);\n+    let buf = [super::ms_to_timeval(atime), super::ms_to_timeval(mtime)];\n+    try!(cvt(unsafe { c::utimes(p.as_ptr(), buf.as_ptr()) }));\n+    Ok(())\n+}"}, {"sha": "b5a24278a206edf8a9194c6860c1ef49c85648cc", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -23,6 +23,7 @@ use libc;\n use num::{Int, SignedInt};\n use num;\n use old_io::{self, IoResult, IoError};\n+use io;\n use str;\n use sys_common::mkerr_libc;\n \n@@ -39,9 +40,11 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n \n pub mod backtrace;\n pub mod c;\n-pub mod ext;\n pub mod condvar;\n-pub mod fs;\n+pub mod ext;\n+pub mod fd;\n+pub mod fs;  // support for std::old_io\n+pub mod fs2; // support for std::fs\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n@@ -176,6 +179,26 @@ pub fn retry<T, F> (mut f: F) -> T where\n     }\n }\n \n+pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n+    let one: T = Int::one();\n+    if t == -one {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+    where T: SignedInt, F: FnMut() -> T\n+{\n+    loop {\n+        match cvt(f()) {\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            other => return other,\n+        }\n+    }\n+}\n+\n pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     libc::timeval {\n         tv_sec: (ms / 1000) as libc::time_t,"}, {"sha": "dc874c2c7913ce6bf9cc72339fa69d7f7bcdb8a7", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -18,10 +18,11 @@\n \n pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n \n-use sys::os_str::Buf;\n-use sys_common::{AsInner, FromInner};\n use ffi::{OsStr, OsString};\n+use fs::{self, OpenOptions};\n use libc;\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, FromInner, AsInnerMut};\n \n use old_io;\n \n@@ -43,6 +44,12 @@ impl AsRawHandle for old_io::fs::File {\n     }\n }\n \n+impl AsRawHandle for fs::File {\n+    fn as_raw_handle(&self) -> Handle {\n+        self.as_inner().handle().raw()\n+    }\n+}\n+\n impl AsRawHandle for old_io::pipe::PipeStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n@@ -122,9 +129,57 @@ impl OsStrExt for OsStr {\n     }\n }\n \n+// Windows-specific extensions to `OpenOptions`\n+pub trait OpenOptionsExt {\n+    /// Override the `dwDesiredAccess` argument to the call to `CreateFile` with\n+    /// the specified value.\n+    fn desired_access(&mut self, access: i32) -> &mut Self;\n+\n+    /// Override the `dwCreationDisposition` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard `create` flags, for\n+    /// example.\n+    fn creation_disposition(&mut self, val: i32) -> &mut Self;\n+\n+    /// Override the `dwFlagsAndAttributes` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard flags on the `OpenOptions`\n+    /// structure.\n+    fn flags_and_attributes(&mut self, val: i32) -> &mut Self;\n+\n+    /// Override the `dwShareMode` argument to the call to `CreateFile` with the\n+    /// specified value.\n+    ///\n+    /// This will override any values of the standard flags on the `OpenOptions`\n+    /// structure.\n+    fn share_mode(&mut self, val: i32) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn desired_access(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().desired_access(access); self\n+    }\n+    fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().creation_disposition(access); self\n+    }\n+    fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().flags_and_attributes(access); self\n+    }\n+    fn share_mode(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().share_mode(access); self\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n-    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle, OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle};\n+    #[doc(no_inline)]\n+    pub use super::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::OpenOptionsExt;\n }"}, {"sha": "74bb509789b1854a96cb8fd1032a84f28b8f17ac", "filename": "src/libstd/sys/windows/fs2.rs", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -0,0 +1,428 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+use io::prelude::*;\n+use os::windows::prelude::*;\n+\n+use default::Default;\n+use ffi::{OsString, AsOsStr};\n+use io::{self, Error, SeekFrom};\n+use libc::{self, HANDLE};\n+use mem;\n+use path::{Path, PathBuf};\n+use ptr;\n+use sys::handle::Handle as RawHandle;\n+use sys::{c, cvt};\n+use vec::Vec;\n+\n+pub struct File { handle: RawHandle }\n+pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }\n+\n+pub struct ReadDir {\n+    handle: libc::HANDLE,\n+    root: PathBuf,\n+    first: Option<libc::WIN32_FIND_DATAW>,\n+}\n+\n+pub struct DirEntry { path: PathBuf }\n+\n+#[derive(Clone, Default)]\n+pub struct OpenOptions {\n+    create: bool,\n+    append: bool,\n+    read: bool,\n+    write: bool,\n+    truncate: bool,\n+    desired_access: Option<libc::DWORD>,\n+    share_mode: Option<libc::DWORD>,\n+    creation_disposition: Option<libc::DWORD>,\n+    flags_and_attributes: Option<libc::DWORD>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions { attrs: libc::DWORD }\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        if let Some(first) = self.first.take() {\n+            if let Some(e) = DirEntry::new(&self.root, &first) {\n+                return Some(Ok(e));\n+            }\n+        }\n+        unsafe {\n+            let mut wfd = mem::zeroed();\n+            loop {\n+                if libc::FindNextFileW(self.handle, &mut wfd) == 0 {\n+                    if libc::GetLastError() ==\n+                        c::ERROR_NO_MORE_FILES as libc::DWORD {\n+                        return None\n+                    } else {\n+                        return Some(Err(Error::last_os_error()))\n+                    }\n+                }\n+                if let Some(e) = DirEntry::new(&self.root, &wfd) {\n+                    return Some(Ok(e))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for ReadDir {\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::FindClose(self.handle) };\n+        debug_assert!(r != 0);\n+    }\n+}\n+\n+impl DirEntry {\n+    fn new(root: &Path, wfd: &libc::WIN32_FIND_DATAW) -> Option<DirEntry> {\n+        match &wfd.cFileName[0..3] {\n+            // check for '.' and '..'\n+            [46, 0, ..] |\n+            [46, 46, 0, ..] => return None,\n+            _ => {}\n+        }\n+\n+        let filename = super::truncate_utf16_at_nul(&wfd.cFileName);\n+        let filename: OsString = OsStringExt::from_wide(filename);\n+        Some(DirEntry { path: root.join(&filename) })\n+    }\n+\n+    pub fn path(&self) -> PathBuf {\n+        self.path.clone()\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions { Default::default() }\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn creation_disposition(&mut self, val: i32) {\n+        self.creation_disposition = Some(val as libc::DWORD);\n+    }\n+    pub fn flags_and_attributes(&mut self, val: i32) {\n+        self.flags_and_attributes = Some(val as libc::DWORD);\n+    }\n+    pub fn desired_access(&mut self, val: i32) {\n+        self.desired_access = Some(val as libc::DWORD);\n+    }\n+    pub fn share_mode(&mut self, val: i32) {\n+        self.share_mode = Some(val as libc::DWORD);\n+    }\n+\n+    fn get_desired_access(&self) -> libc::DWORD {\n+        self.desired_access.unwrap_or({\n+            let mut base = if self.read {libc::FILE_GENERIC_READ} else {0} |\n+                           if self.write {libc::FILE_GENERIC_WRITE} else {0};\n+            if self.append {\n+                base &= !libc::FILE_WRITE_DATA;\n+                base |= libc::FILE_APPEND_DATA;\n+            }\n+            base\n+        })\n+    }\n+\n+    fn get_share_mode(&self) -> libc::DWORD {\n+        // libuv has a good comment about this, but the basic idea is that\n+        // we try to emulate unix semantics by enabling all sharing by\n+        // allowing things such as deleting a file while it's still open.\n+        self.share_mode.unwrap_or(libc::FILE_SHARE_READ |\n+                                  libc::FILE_SHARE_WRITE |\n+                                  libc::FILE_SHARE_DELETE)\n+    }\n+\n+    fn get_creation_disposition(&self) -> libc::DWORD {\n+        self.creation_disposition.unwrap_or({\n+            match (self.create, self.truncate) {\n+                (true, true) => libc::CREATE_ALWAYS,\n+                (true, false) => libc::OPEN_ALWAYS,\n+                (false, false) => libc::OPEN_EXISTING,\n+                (false, true) => {\n+                    if self.write && !self.append {\n+                        libc::CREATE_ALWAYS\n+                    } else {\n+                        libc::TRUNCATE_EXISTING\n+                    }\n+                }\n+            }\n+        })\n+    }\n+\n+    fn get_flags_and_attributes(&self) -> libc::DWORD {\n+        self.flags_and_attributes.unwrap_or(libc::FILE_ATTRIBUTE_NORMAL)\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = to_utf16(path);\n+        let handle = unsafe {\n+            libc::CreateFileW(path.as_ptr(),\n+                              opts.get_desired_access(),\n+                              opts.get_share_mode(),\n+                              ptr::null_mut(),\n+                              opts.get_creation_disposition(),\n+                              opts.get_flags_and_attributes(),\n+                              ptr::null_mut())\n+        };\n+        if handle == libc::INVALID_HANDLE_VALUE {\n+            Err(Error::last_os_error())\n+        } else {\n+            Ok(File { handle: RawHandle::new(handle) })\n+        }\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        try!(cvt(unsafe { libc::FlushFileBuffers(self.handle.raw()) }));\n+        Ok(())\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> { self.fsync() }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        let mut info = c::FILE_END_OF_FILE_INFO {\n+            EndOfFile: size as libc::LARGE_INTEGER,\n+        };\n+        let size = mem::size_of_val(&info);\n+        try!(cvt(unsafe {\n+            c::SetFileInformationByHandle(self.handle.raw(),\n+                                          c::FileEndOfFileInfo,\n+                                          &mut info as *mut _ as *mut _,\n+                                          size as libc::DWORD)\n+        }));\n+        Ok(())\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        unsafe {\n+            let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n+            try!(cvt(c::GetFileInformationByHandle(self.handle.raw(),\n+                                                   &mut info)));\n+            Ok(FileAttr {\n+                data: c::WIN32_FILE_ATTRIBUTE_DATA {\n+                    dwFileAttributes: info.dwFileAttributes,\n+                    ftCreationTime: info.ftCreationTime,\n+                    ftLastAccessTime: info.ftLastAccessTime,\n+                    ftLastWriteTime: info.ftLastWriteTime,\n+                    nFileSizeHigh: info.nFileSizeHigh,\n+                    nFileSizeLow: info.nFileSizeLow,\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let mut read = 0;\n+        try!(cvt(unsafe {\n+            libc::ReadFile(self.handle.raw(),\n+                           buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD,\n+                           &mut read,\n+                           ptr::null_mut())\n+        }));\n+        Ok(read as usize)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let mut amt = 0;\n+        try!(cvt(unsafe {\n+            libc::WriteFile(self.handle.raw(),\n+                            buf.as_ptr() as libc::LPVOID,\n+                            buf.len() as libc::DWORD,\n+                            &mut amt,\n+                            ptr::null_mut())\n+        }));\n+        Ok(amt as usize)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            SeekFrom::Start(n) => (libc::FILE_BEGIN, n as i64),\n+            SeekFrom::End(n) => (libc::FILE_END, n),\n+            SeekFrom::Current(n) => (libc::FILE_CURRENT, n),\n+        };\n+        let pos = pos as libc::LARGE_INTEGER;\n+        let mut newpos = 0;\n+        try!(cvt(unsafe {\n+            libc::SetFilePointerEx(self.handle.raw(), pos,\n+                                   &mut newpos, whence)\n+        }));\n+        Ok(newpos as u64)\n+    }\n+\n+    pub fn handle(&self) -> &RawHandle { &self.handle }\n+}\n+\n+pub fn to_utf16(s: &Path) -> Vec<u16> {\n+    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()\n+}\n+\n+impl FileAttr {\n+    pub fn is_dir(&self) -> bool {\n+        self.data.dwFileAttributes & c::FILE_ATTRIBUTE_DIRECTORY != 0\n+    }\n+    pub fn is_file(&self) -> bool {\n+        !self.is_dir()\n+    }\n+    pub fn size(&self) -> u64 {\n+        ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64)\n+    }\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions { attrs: self.data.dwFileAttributes }\n+    }\n+\n+    pub fn accessed(&self) -> u64 { self.to_ms(&self.data.ftLastAccessTime) }\n+    pub fn modified(&self) -> u64 { self.to_ms(&self.data.ftLastWriteTime) }\n+\n+    fn to_ms(&self, ft: &libc::FILETIME) -> u64 {\n+        // FILETIME is in 100ns intervals and there are 10000 intervals in a\n+        // millisecond.\n+        let bits = (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32);\n+        bits / 10000\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        self.attrs & c::FILE_ATTRIBUTE_READONLY != 0\n+    }\n+\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            self.attrs |= c::FILE_ATTRIBUTE_READONLY;\n+        } else {\n+            self.attrs &= !c::FILE_ATTRIBUTE_READONLY;\n+        }\n+    }\n+}\n+\n+pub fn mkdir(p: &Path) -> io::Result<()> {\n+    let p = to_utf16(p);\n+    try!(cvt(unsafe {\n+        libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n+    }));\n+    Ok(())\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let root = p.to_path_buf();\n+    let star = p.join(\"*\");\n+    let path = to_utf16(&star);\n+\n+    unsafe {\n+        let mut wfd = mem::zeroed();\n+        let find_handle = libc::FindFirstFileW(path.as_ptr(), &mut wfd);\n+        if find_handle != libc::INVALID_HANDLE_VALUE {\n+            Ok(ReadDir { handle: find_handle, root: root, first: Some(wfd) })\n+        } else {\n+            Err(Error::last_os_error())\n+        }\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    let p_utf16 = to_utf16(p);\n+    try!(cvt(unsafe { libc::DeleteFileW(p_utf16.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    let old = to_utf16(old);\n+    let new = to_utf16(new);\n+    try!(cvt(unsafe {\n+        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n+                          libc::MOVEFILE_REPLACE_EXISTING)\n+    }));\n+    Ok(())\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    let p = to_utf16(p);\n+    try!(cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) }));\n+    Ok(())\n+}\n+\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n+    let mut opts = OpenOptions::new();\n+    opts.read(true);\n+    let file = try!(File::open(p, &opts));;\n+\n+    // Specify (sz - 1) because the documentation states that it's the size\n+    // without the null pointer\n+    //\n+    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n+    let ret: OsString = try!(super::fill_utf16_buf_new(|buf, sz| unsafe {\n+        GetFinalPathNameByHandleW(file.handle.raw(),\n+                                  buf as *const u16,\n+                                  sz - 1,\n+                                  libc::VOLUME_NAME_DOS)\n+    }, |s| OsStringExt::from_wide(s)));\n+    Ok(PathBuf::new(&ret))\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    use sys::c::compat::kernel32::CreateSymbolicLinkW;\n+    let src = to_utf16(src);\n+    let dst = to_utf16(dst);\n+    try!(cvt(unsafe {\n+        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n+    }));\n+    Ok(())\n+}\n+\n+pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n+    let src = to_utf16(src);\n+    let dst = to_utf16(dst);\n+    try!(cvt(unsafe {\n+        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n+    }));\n+    Ok(())\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let p = to_utf16(p);\n+    unsafe {\n+        let mut attr: FileAttr = mem::zeroed();\n+        try!(cvt(c::GetFileAttributesExW(p.as_ptr(),\n+                                         c::GetFileExInfoStandard,\n+                                         &mut attr.data as *mut _ as *mut _)));\n+        Ok(attr)\n+    }\n+}\n+\n+pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    let p = to_utf16(p);\n+    unsafe {\n+        try!(cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs)));\n+        Ok(())\n+    }\n+}\n+\n+pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n+    let atime = super::ms_to_filetime(atime);\n+    let mtime = super::ms_to_filetime(mtime);\n+\n+    let mut o = OpenOptions::new();\n+    o.write(true);\n+    let f = try!(File::open(p, &o));\n+    try!(cvt(unsafe {\n+        c::SetFileTime(f.handle.raw(), 0 as *const _, &atime, &mtime)\n+    }));\n+    Ok(())\n+}"}, {"sha": "52aa5fb036a9acc338291bdf136f9028b1e12547", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -21,6 +21,7 @@ impl Handle {\n     pub fn new(handle: HANDLE) -> Handle {\n         Handle(handle)\n     }\n+    pub fn raw(&self) -> HANDLE { self.0 }\n }\n \n impl Drop for Handle {"}, {"sha": "140bdb1450102f945b69d246360088224336d219", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -15,10 +15,11 @@\n use prelude::v1::*;\n \n use ffi::OsStr;\n-use io::ErrorKind;\n+use io::{self, ErrorKind};\n use libc;\n use mem;\n use old_io::{self, IoResult, IoError};\n+use num::Int;\n use os::windows::OsStrExt;\n use sync::{Once, ONCE_INIT};\n \n@@ -38,6 +39,7 @@ pub mod c;\n pub mod condvar;\n pub mod ext;\n pub mod fs;\n+pub mod fs2;\n pub mod handle;\n pub mod helper_signal;\n pub mod mutex;\n@@ -248,7 +250,7 @@ fn to_utf16_os(s: &OsStr) -> Vec<u16> {\n // Once the syscall has completed (errors bail out early) the second closure is\n // yielded the data which has been read from the syscall. The return value\n // from this closure is then the return value of the function.\n-fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> IoResult<T>\n+fn fill_utf16_buf_base<F1, F2, T>(mut f1: F1, f2: F2) -> Result<T, ()>\n     where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n           F2: FnOnce(&[u16]) -> T\n {\n@@ -280,7 +282,7 @@ fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> IoResult<T>\n             c::SetLastError(0);\n             let k = match f1(buf.as_mut_ptr(), n as libc::DWORD) {\n                 0 if libc::GetLastError() == 0 => 0,\n-                0 => return Err(IoError::last_error()),\n+                0 => return Err(()),\n                 n => n,\n             } as usize;\n             if k == n && libc::GetLastError() ==\n@@ -295,6 +297,20 @@ fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> IoResult<T>\n     }\n }\n \n+fn fill_utf16_buf<F1, F2, T>(f1: F1, f2: F2) -> IoResult<T>\n+    where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n+          F2: FnOnce(&[u16]) -> T\n+{\n+    fill_utf16_buf_base(f1, f2).map_err(|()| IoError::last_error())\n+}\n+\n+fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>\n+    where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n+          F2: FnOnce(&[u16]) -> T\n+{\n+    fill_utf16_buf_base(f1, f2).map_err(|()| io::Error::last_os_error())\n+}\n+\n fn os2path(s: &[u16]) -> Path {\n     // FIXME: this should not be a panicking conversion (aka path reform)\n     Path::new(String::from_utf16(s).unwrap())\n@@ -307,3 +323,21 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n         None => v\n     }\n }\n+\n+fn cvt<I: Int>(i: I) -> io::Result<I> {\n+    if i == Int::zero() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(i)\n+    }\n+}\n+\n+fn ms_to_filetime(ms: u64) -> libc::FILETIME {\n+    // A FILETIME is a count of 100 nanosecond intervals, so we multiply by\n+    // 10000 b/c there are 10000 intervals in 1 ms\n+    let ms = ms * 10000;\n+    libc::FILETIME {\n+        dwLowDateTime: ms as u32,\n+        dwHighDateTime: (ms >> 32) as u32,\n+    }\n+}"}, {"sha": "7e684c5234141aad1e15762f0fa6503ba2996ae6", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bfe358e0fe3b35f0434e81e7c53ea844e95cc13/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=0bfe358e0fe3b35f0434e81e7c53ea844e95cc13", "patch": "@@ -191,7 +191,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n     }\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>"}]}