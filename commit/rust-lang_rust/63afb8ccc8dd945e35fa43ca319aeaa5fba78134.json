{"sha": "63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYWZiOGNjYzhkZDk0NWUzNWZhNDNjYTMxOWFlYWE1ZmJhNzgxMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T22:01:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T22:01:58Z"}, "message": "auto merge of #7430 : huonw/rust/vec-kill, r=thestinger", "tree": {"sha": "4c0757e660bffe4cc557d8790fa6b359bc5542eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c0757e660bffe4cc557d8790fa6b359bc5542eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "html_url": "https://github.com/rust-lang/rust/commit/63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c86a0431b637edd23b91234765402bb41edcae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c86a0431b637edd23b91234765402bb41edcae8", "html_url": "https://github.com/rust-lang/rust/commit/4c86a0431b637edd23b91234765402bb41edcae8"}, {"sha": "366ca44cc8f79704f8781adb15e74d3c2a0e5572", "url": "https://api.github.com/repos/rust-lang/rust/commits/366ca44cc8f79704f8781adb15e74d3c2a0e5572", "html_url": "https://github.com/rust-lang/rust/commit/366ca44cc8f79704f8781adb15e74d3c2a0e5572"}], "stats": {"total": 1265, "additions": 546, "deletions": 719}, "files": [{"sha": "8f742d0d2100e92f57fd9caf338109567ae88d09", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -2620,7 +2620,7 @@ assert!(b != \"world\");\n \n The vector type constructor represents a homogeneous array of values of a given type.\n A vector has a fixed size.\n-(Operations like `vec::push` operate solely on owned vectors.)\n+(Operations like `vec.push` operate solely on owned vectors.)\n A vector type can be annotated with a _definite_ size,\n written with a trailing asterisk and integer literal, such as `[int * 10]`.\n Such a definite-sized vector type is a first-class type, since its size is known statically."}, {"sha": "d858003c353eb8664e300dded4fb4e3f8d9fc851", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -75,7 +75,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n          ];\n \n     assert!(!args.is_empty());\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let matches =\n         &match getopts::getopts(args_, opts) {\n           Ok(m) => m,"}, {"sha": "a31e0b961f7f2bad7e72b9a740ca620ebe6ba9f9", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -321,8 +321,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        vec::slice(props.error_patterns, next_err_idx,\n-                   props.error_patterns.len());\n+        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);"}, {"sha": "5e3b60bb3a8cc1fb25402de8a9db5900c0a9a8f9", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -517,7 +517,6 @@ mod tests {\n \n     use arc::*;\n \n-    use core::vec;\n     use core::cell::Cell;\n     use core::comm;\n     use core::task;"}, {"sha": "79ef5bf2b7eaf4a36f907a57123be788352bb986", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -159,8 +159,7 @@ mod tests {\n \n             assert!(mem as int != 0);\n \n-            return c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                   || unsafe { free(mem) });\n+            c_vec_with_dtor(mem as *mut u8, n as uint, || free(mem))\n         }\n     }\n "}, {"sha": "e9c6ac722124daa4a7d2f419681cd80f9d132556", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use core::uint;\n-use core::vec;\n \n use digest::Digest;\n \n@@ -118,7 +117,7 @@ impl Engine512 {\n         }\n \n         while in.len() - i >= 8 {\n-            let w = to_u64(vec::slice(in, i, i + 8));\n+            let w = to_u64(in.slice(i, i + 8));\n             self.process_word(w);\n             self.bit_counter.add_bytes(8);\n             i += 8;\n@@ -274,43 +273,43 @@ impl Engine512 {\n     fn result_512(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n-        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n-        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n-        from_u64(self.H6, vec::mut_slice(out, 48, 56));\n-        from_u64(self.H7, vec::mut_slice(out, 56, 64));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n+        from_u64(self.H6, out.mut_slice(48, 56));\n+        from_u64(self.H7, out.mut_slice(56, 64));\n     }\n \n     fn result_384(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n-        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n-        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n     }\n \n     fn result_256(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n     }\n \n     fn result_224(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n-        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n-        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n-        from_u32((self.H3 >> 32) as u32, vec::mut_slice(out, 24, 28));\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u32((self.H3 >> 32) as u32, out.mut_slice(24, 28));\n     }\n }\n \n@@ -400,7 +399,7 @@ impl Engine256 {\n         }\n \n         while in.len() - i >= 4 {\n-            let w = to_u32(vec::slice(in, i, i + 4));\n+            let w = to_u32(in.slice(i, i + 4));\n             self.process_word(w);\n             self.length_bytes += 4;\n             i += 4;\n@@ -556,26 +555,26 @@ impl Engine256 {\n     fn result_256(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n-        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n-        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n-        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n-        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n-        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n-        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n-        from_u32(self.H7, vec::mut_slice(out, 28, 32));\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n+        from_u32(self.H7, out.mut_slice(28, 32));\n     }\n \n     fn result_224(&mut self, out: &mut [u8]) {\n         self.finish();\n \n-        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n-        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n-        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n-        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n-        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n-        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n-        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n     }\n }\n "}, {"sha": "c70c87b6ea13b332e0482c52d0a8c4c14336486b", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -137,7 +137,7 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve(&mut self, n: uint) {\n-        vec::reserve(&mut self.elts, n);\n+        self.elts.reserve(n);\n     }\n \n     /// Reserve capacity for at least `n` elements in the given deque,\n@@ -151,7 +151,7 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.elts, n);\n+        self.elts.reserve_at_least(n);\n     }\n \n     /// Front-to-back iterator.\n@@ -256,7 +256,6 @@ mod tests {\n     use super::*;\n     use core::cmp::Eq;\n     use core::kinds::Copy;\n-    use core::vec::capacity;\n     use core;\n \n     #[test]\n@@ -442,23 +441,23 @@ mod tests {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n     fn test_reserve_at_least() {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n     }\n \n     #[test]"}, {"sha": "ee86340e47bed7e2ad974c762bbacb2d8b3ac2fa", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -526,8 +526,6 @@ mod tests {\n \n     use super::*;\n \n-    use core::vec;\n-\n     #[test]\n     fn test_dlist_concat() {\n         let a = from_vec([1,2]);"}, {"sha": "92a027100daf4ab63d3b8822bdc4e1847a59330b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -85,7 +85,6 @@ pub mod reader {\n     use core::ptr::offset;\n     use core::str;\n     use core::unstable::intrinsics::bswap32;\n-    use core::vec;\n \n     // ebml reading\n \n@@ -248,7 +247,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n-        f(vec::slice(*d.data, d.start, d.end))\n+        f(d.data.slice(d.start, d.end))\n     }\n \n "}, {"sha": "f3f6ffde6603ec9703ec0a60c83d41c111ad794d", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -976,9 +976,7 @@ impl io::Writer for TcpSocketBuf {\n         let socket_data_ptr: *TcpSocketData =\n             &(*((*(self.data)).sock).socket_data);\n         let w_result = write_common_impl(socket_data_ptr,\n-                                         vec::slice(data,\n-                                                    0,\n-                                                    data.len()).to_owned());\n+                                         data.slice(0, data.len()).to_owned());\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n             debug!(\n@@ -1459,33 +1457,23 @@ mod test {\n \n             #[test]\n             fn test_gl_tcp_server_and_client_ipv4() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_and_client();\n-                }\n+                impl_gl_tcp_ipv4_server_and_client();\n             }\n             #[test]\n             fn test_gl_tcp_get_peer_addr() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_get_peer_addr();\n-                }\n+                impl_gl_tcp_ipv4_get_peer_addr();\n             }\n             #[test]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_client_error_connection_refused();\n-                }\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n             #[test]\n             fn test_gl_tcp_server_address_in_use() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_address_in_use();\n-                }\n+                impl_gl_tcp_ipv4_server_address_in_use();\n             }\n             #[test]\n             fn test_gl_tcp_server_access_denied() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_access_denied();\n-                }\n+                impl_gl_tcp_ipv4_server_access_denied();\n             }\n             // Strange failure on Windows. --pcwalton\n             #[test]"}, {"sha": "1ac913e8a00d181ab4712dd6da80dec84bca26b8", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -298,9 +298,8 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n-            return (BigUint::from_slice(vec::slice(a.data, mid,\n-                                                   a.data.len())),\n-                    BigUint::from_slice(vec::slice(a.data, 0, mid)));\n+            return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n+                    BigUint::from_slice(a.data.slice(0, mid)));\n         }\n \n \n@@ -413,7 +412,7 @@ impl Integer for BigUint {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n             }\n \n-            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n+            let an = a.data.slice(a.data.len() - n, a.data.len());\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n@@ -578,7 +577,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n+            match uint::parse_bytes(buf.slice(start, end), radix) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // Some(d) => n += BigUint::from_uint(d) * power,\n                 Some(d) => n = n + BigUint::from_uint(d) * power,\n@@ -634,7 +633,7 @@ impl BigUint {\n         if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n-            vec::slice(self.data, n_unit, self.data.len())\n+            self.data.slice(n_unit, self.data.len())\n         );\n     }\n \n@@ -1132,7 +1131,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n+        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n@@ -1176,7 +1175,7 @@ mod biguint_tests {\n         let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n         for data.iter().enumerate().advance |(i, ni)| {\n-            for vec::slice(data, i, data.len()).iter().enumerate().advance |(j0, nj)| {\n+            for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1654,7 +1653,7 @@ mod bigint_tests {\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n         for nums.iter().enumerate().advance |(i, ni)| {\n-            for vec::slice(nums, i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n+            for nums.slice(i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);"}, {"sha": "fbb4be0febb3d45f5953cbfde85180e93f6b0b6c", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -52,12 +52,12 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    pub fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    pub fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+    pub fn reserve(&mut self, n: uint) { self.data.reserve(n) }\n \n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.data, n)\n+        self.data.reserve_at_least(n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty"}, {"sha": "5377dfadbaa1162125b36eaf4ae02eed43799879", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -57,8 +57,8 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n                 a_ix += 1;\n             } else { rs.push(copy b[b_ix]); b_ix += 1; }\n         }\n-        rs.push_all(vec::slice(a, a_ix, a_len));\n-        rs.push_all(vec::slice(b, b_ix, b_len));\n+        rs.push_all(a.slice(a_ix, a_len));\n+        rs.push_all(b.slice(b_ix, b_len));\n         rs\n     }\n }\n@@ -201,12 +201,12 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     loop {\n         let run_len: uint = {\n             // This scope contains the slice `arr` here:\n-            let arr = vec::mut_slice(array, idx, size);\n+            let arr = array.mut_slice(idx, size);\n             let mut run_len: uint = count_run_ascending(arr);\n \n             if run_len < min_run {\n                 let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = vec::mut_slice(arr, 0, force);\n+                let slice = arr.mut_slice(0, force);\n                 binarysort(slice, run_len);\n                 run_len = force;\n             }\n@@ -443,14 +443,14 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n \n         let k = { // constrain lifetime of slice below\n-            let slice = vec::slice(array, b1, b1+l1);\n+            let slice = array.slice(b1, b1+l1);\n             gallop_right(&array[b2], slice, 0)\n         };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n             let l2 = { // constrain lifetime of slice below\n-                let slice = vec::slice(array, b2, b2+l2);\n+                let slice = array.slice(b2, b2+l2);\n                 gallop_left(&array[b1+l1-1],slice,l2-1)\n             };\n             if l2 > 0 {\n@@ -526,7 +526,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len1 > 1 && len2 != 0);\n \n                 count1 = {\n-                    let tmp_view = vec::slice(tmp, c1, c1+len1);\n+                    let tmp_view = tmp.slice(c1, c1+len1);\n                     gallop_right(&array[c2], tmp_view, 0)\n                 };\n                 if count1 != 0 {\n@@ -539,7 +539,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 if len2 == 0 { break_outer = true; break; }\n \n                 count2 = {\n-                    let tmp_view = vec::slice(array, c2, c2+len2);\n+                    let tmp_view = array.slice(c2, c2+len2);\n                     gallop_left(&tmp[c1], tmp_view, 0)\n                 };\n                 if count2 != 0 {\n@@ -638,7 +638,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len2 > 1 && len1 != 0);\n \n                 { // constrain scope of tmp_view:\n-                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    let tmp_view = array.mut_slice(base1, base1+len1);\n                     count1 = len1 - gallop_right(\n                         &tmp[c2], tmp_view, len1-1);\n                 }\n@@ -655,7 +655,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n                 let count2;\n                 { // constrain scope of tmp_view\n-                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n+                    let tmp_view = tmp.mut_slice(0, len2);\n                     count2 = len2 - gallop_left(&array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n@@ -1111,7 +1111,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort\n@@ -1183,7 +1183,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort"}, {"sha": "817e1ab12261057ab701735b28cf91505db4f745", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -808,7 +808,6 @@ mod tests {\n     use core::comm;\n     use core::result;\n     use core::task;\n-    use core::vec;\n \n     /************************************************************************\n      * Semaphore tests"}, {"sha": "7b68298a8dddd7f779d617b13b655079a0b6650f", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -139,7 +139,7 @@ type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[~str]) -> OptRes {\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let opts = ~[getopts::optflag(\"ignored\"),\n                  getopts::optflag(\"test\"),\n                  getopts::optflag(\"bench\"),\n@@ -431,7 +431,7 @@ fn run_tests(opts: &TestOpts,\n     callback(TeFiltered(filtered_descs));\n \n     let (filtered_tests, filtered_benchs) =\n-        do vec::partition(filtered_tests) |e| {\n+        do filtered_tests.partition |e| {\n         match e.testfn {\n             StaticTestFn(_) | DynTestFn(_) => true,\n             StaticBenchFn(_) | DynBenchFn(_) => false"}, {"sha": "4622b8c7284841b2e065193796899580e3f6c374", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -695,7 +695,6 @@ mod test_treemap {\n \n     use core::rand::RngUtil;\n     use core::rand;\n-    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -848,7 +847,7 @@ mod test_treemap {\n \n             for 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n-                let (key, _) = vec::remove(&mut ctrl, r);\n+                let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);"}, {"sha": "f1dde1b8cb41dbceff1419cf827b3a1bfe82953f", "filename": "src/libextra/uv_global_loop.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_global_loop.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -150,9 +150,7 @@ mod test {\n             let hl_loop = &get_gl();\n             do iotask::interact(hl_loop) |_loop_ptr| {\n                 debug!(~\"closing timer\");\n-                unsafe {\n-                    ll::close(timer_ptr, simple_timer_close_cb);\n-                }\n+                ll::close(timer_ptr, simple_timer_close_cb);\n                 debug!(~\"about to deref exit_ch_ptr\");\n                 debug!(~\"after msg sent on deref'd exit_ch\");\n             };\n@@ -169,24 +167,22 @@ mod test {\n             let timer_handle = ll::timer_t();\n             let timer_ptr: *ll::uv_timer_t = &timer_handle;\n             do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    debug!(~\"user code inside interact loop!!!\");\n-                    let init_status = ll::timer_init(loop_ptr, timer_ptr);\n-                    if(init_status == 0i32) {\n-                        ll::set_data_for_uv_handle(\n-                            timer_ptr as *libc::c_void,\n-                            exit_ch_ptr);\n-                        let start_status = ll::timer_start(timer_ptr,\n-                                                           simple_timer_cb,\n-                                                           1u, 0u);\n-                        if(start_status != 0i32) {\n-                            fail!(\"failure on ll::timer_start()\");\n-                        }\n-                    }\n-                    else {\n-                        fail!(\"failure on ll::timer_init()\");\n+                debug!(~\"user code inside interact loop!!!\");\n+                let init_status = ll::timer_init(loop_ptr, timer_ptr);\n+                if(init_status == 0i32) {\n+                    ll::set_data_for_uv_handle(\n+                        timer_ptr as *libc::c_void,\n+                        exit_ch_ptr);\n+                    let start_status = ll::timer_start(timer_ptr,\n+                                                       simple_timer_cb,\n+                                                       1u, 0u);\n+                    if(start_status != 0i32) {\n+                        fail!(\"failure on ll::timer_start()\");\n                     }\n                 }\n+                else {\n+                    fail!(\"failure on ll::timer_init()\");\n+                }\n             };\n             exit_po.recv();\n             debug!("}, {"sha": "58b477d4ccf46197149d8d69fb2fa2f945fcef91", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -1767,9 +1767,7 @@ mod test {\n         mod impl64 {\n             #[test]\n             fn test_uv_ll_tcp_server_and_request() {\n-                unsafe {\n-                    super::super::impl_uv_tcp_server_and_request();\n-                }\n+                super::super::impl_uv_tcp_server_and_request();\n             }\n         }\n         #[cfg(target_arch=\"x86\")]"}, {"sha": "dce2b7fe3dfb009cb88e433d99f32519889ca2e9", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -154,7 +154,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let mut path = ~[];\n     for uint::range(start_idx, len1 - 1) |_i| { path.push(~\"..\"); };\n \n-    path.push_all(vec::slice(split2, start_idx, len2 - 1));\n+    path.push_all(split2.slice(start_idx, len2 - 1));\n \n     return if !path.is_empty() {\n         Path(\"\").push_many(path)"}, {"sha": "b11badd65cc8939cf7b86a5260dab9edad776be3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -60,7 +60,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n             return Some(reader::doc_at(d.data, pos).doc);\n         }\n     };\n@@ -72,7 +72,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::crate_num) -> cmd;\n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(\n-            vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n+            bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -754,8 +754,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n \n         if item_method_sort(mth) != 'p' { loop; }\n \n-        vec::push(&mut result,\n-                  @get_method(intr, cdata, did.node, tcx));\n+        result.push(@get_method(intr, cdata, did.node, tcx));\n     }\n \n     return result;"}, {"sha": "717a0ecd8dfe475cda8786ad848949c4f9a6abe7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -20,7 +20,6 @@ use middle::ty;\n \n use core::str;\n use core::uint;\n-use core::vec;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n@@ -518,8 +517,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n         fail!();\n     }\n \n-    let crate_part = vec::slice(buf, 0u, colon_idx);\n-    let def_part = vec::slice(buf, colon_idx + 1u, len);\n+    let crate_part = buf.slice(0u, colon_idx);\n+    let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,"}, {"sha": "93202f3fd558bb01bf72e66f79e2f487653f07b0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -132,7 +132,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let gens = vec::mut_slice(self.gens, start, end);\n+            let gens = self.gens.mut_slice(start, end);\n             set_bit(gens, bit);\n         }\n     }\n@@ -143,7 +143,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let kills = vec::mut_slice(self.kills, start, end);\n+            let kills = self.kills.mut_slice(start, end);\n             set_bit(kills, bit);\n         }\n     }\n@@ -216,7 +216,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -229,7 +229,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Only useful after `propagate()` has been called.\n \n         let (start, end) = self.compute_id_range(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -241,7 +241,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Iterates through each bit in the gen set for `id`.\n \n         let (start, end) = self.compute_id_range(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -255,7 +255,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -338,17 +338,17 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n \n             if self.nodeid_to_bitset.contains_key(&id) {\n                 let (start, end) = self.compute_id_range_frozen(id);\n-                let on_entry = vec::slice(self.on_entry, start, end);\n+                let on_entry = self.on_entry.slice(start, end);\n                 let entry_str = bits_to_str(on_entry);\n \n-                let gens = vec::slice(self.gens, start, end);\n+                let gens = self.gens.slice(start, end);\n                 let gens_str = if gens.iter().any_(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n-                let kills = vec::slice(self.kills, start, end);\n+                let kills = self.kills.slice(start, end);\n                 let kills_str = if kills.iter().any_(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n@@ -953,7 +953,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n@@ -970,7 +970,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n             copy_bits(reslice(on_entry), pred_bits);\n             changed"}, {"sha": "b839e22f9060f53a3cd976d8b9778f6fdc288012", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -4862,8 +4862,8 @@ impl Resolver {\n         while j != 0 {\n             j -= 1;\n             for this.value_ribs[j].bindings.each_key |&k| {\n-                vec::push(&mut maybes, this.session.str_of(k));\n-                vec::push(&mut values, uint::max_value);\n+                maybes.push(this.session.str_of(k));\n+                values.push(uint::max_value);\n             }\n         }\n \n@@ -4882,7 +4882,7 @@ impl Resolver {\n             values[smallest] <= max_distance &&\n             name != maybes[smallest] {\n \n-            Some(vec::swap_remove(&mut maybes, smallest))\n+            Some(maybes.swap_remove(smallest))\n \n         } else {\n             None"}, {"sha": "c2e9c7b194b211a393c25d9cea554593d72a5efb", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -388,9 +388,9 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n         match br.pats[col].node {\n             ast::pat_ident(_, path, Some(inner)) => {\n                 let pats = vec::append(\n-                    vec::slice(br.pats, 0u, col).to_owned(),\n+                    br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n-                                vec::slice(br.pats, col + 1u,\n+                                br.pats.slice(col + 1u,\n                                            br.pats.len())));\n \n                 let binding_info =\n@@ -437,8 +437,8 @@ pub fn enter_match<'r>(bcx: block,\n             Some(sub) => {\n                 let pats =\n                     vec::append(\n-                        vec::append(sub, vec::slice(br.pats, 0u, col)),\n-                        vec::slice(br.pats, col + 1u, br.pats.len()));\n+                        vec::append(sub, br.pats.slice(0u, col)),\n+                        br.pats.slice(col + 1u, br.pats.len()));\n \n                 let this = br.pats[col];\n                 match this.node {\n@@ -1290,7 +1290,7 @@ pub fn compile_submatch(bcx: block,\n         match data.arm.guard {\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx, guard_expr, m[0].data,\n-                                    vec::slice(m, 1, m.len()),\n+                                    m.slice(1, m.len()),\n                                     vals, chk);\n             }\n             _ => ()\n@@ -1309,8 +1309,8 @@ pub fn compile_submatch(bcx: block,\n         }\n     };\n \n-    let vals_left = vec::append(vec::slice(vals, 0u, col).to_owned(),\n-                                vec::slice(vals, col + 1u, vals.len()));\n+    let vals_left = vec::append(vals.slice(0u, col).to_owned(),\n+                                vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();"}, {"sha": "73323634c2b6c89c74f65f29d6efaf010b7ad77c", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -312,7 +312,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64());\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                let vec_len = llvec_len(cls.tailn(i + 1u)) * 2u;\n                 let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "064a457c712700c464121208ee6fb5355721569a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -47,7 +47,6 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n-use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n@@ -503,7 +502,7 @@ pub fn trans_call_inner(in_cx: block,\n     do base::with_scope(in_cx, call_info, \"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n-            args.len() > 0u && match vec::last(args).node {\n+            args.len() > 0u && match args.last().node {\n               ast::expr_loop_body(@ast::expr {\n                 node: ast::expr_fn_block(_, ref body),\n                 _"}, {"sha": "714dc8368e508d60edcaa95852c39e7647f4cb14", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -418,10 +418,9 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n             });\n         for cleanup_pos.iter().advance |i| {\n             scope_info.cleanups =\n-                vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_owned(),\n-                            vec::slice(scope_info.cleanups,\n-                                      *i + 1u,\n-                                      scope_info.cleanups.len()));\n+                vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n+                            scope_info.cleanups.slice(*i + 1u,\n+                                                      scope_info.cleanups.len()));\n             shrink_scope_clean(scope_info, *i);\n         }\n     }"}, {"sha": "4f7ce6381d857fc0c2bf0c2bc428fead0c998743", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -492,8 +492,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n-                      vec::tailn(node_substs,\n-                                 node_substs.len() - n_m_tps));\n+                      node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n     debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n@@ -528,7 +527,7 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     } = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_generics.type_param_defs.len(); // rcvr + method tps\n     let m_type_param_defs =\n-        vec::slice(*r_m_generics.type_param_defs, n_r_m_tps - n_m_tps, n_r_m_tps);\n+        r_m_generics.type_param_defs.slice(n_r_m_tps - n_m_tps, n_r_m_tps);\n \n     // Flatten out to find the number of vtables the method expects.\n     let m_vtables = ty::count_traits_and_supertraits(tcx, m_type_param_defs);\n@@ -540,7 +539,7 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     };\n \n     // Extract those that belong to method:\n-    let m_origins = vec::tailn(*r_m_origins, r_m_origins.len() - m_vtables);\n+    let m_origins = r_m_origins.tailn(r_m_origins.len() - m_vtables);\n \n     // Combine rcvr + method to find the final result:\n     @vec::append(/*bad*/copy *rcvr_origins, m_origins)"}, {"sha": "b53359abed4bb0b5fd7f5d2338d33e116cdc52b6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -3954,7 +3954,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(vec::to_owned(vec::init(*path)),\n+            vec::append_one(vec::to_owned(path.init()),\n                             ast_map::path_name((*variant).node.name))\n           }\n "}, {"sha": "c3abf47f9e2908a35b022510eb80160a8d973ae0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -788,7 +788,7 @@ impl CoherenceChecker {\n                              `%s` to impl\",\n                             provided_method.method_info\n                             .ident.repr(self.crate_context.tcx));\n-                        vec::push(all_methods, provided_method.method_info);\n+                        all_methods.push(provided_method.method_info);\n                     }\n                 }\n             }"}, {"sha": "a586cb83fa180056dace49f4b70f3d4d94707ffa", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -55,7 +55,7 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{libc, io, os, task, vec};\n+use std::{libc, io, os, task};\n use std::cell::Cell;\n use extra::rl;\n \n@@ -430,7 +430,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n-                    vec::slice(split, 1, len).to_owned()\n+                    split.slice(1, len).to_owned()\n                 } else { ~[] };\n \n                 match run_cmd(repl, in, out, cmd, args, use_rl) {"}, {"sha": "ebdea2537ac38e3828a40eb9b2e37e028dcb49d6", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -12,7 +12,7 @@ use target::*;\n use package_id::PkgId;\n use core::path::Path;\n use core::option::*;\n-use core::{os, run, str, vec};\n+use core::{os, run, str};\n use context::*;\n use crate::Crate;\n use messages::*;\n@@ -146,8 +146,7 @@ impl PkgSrc {\n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n-        for vec::slice(p.components, prefix,\n-                       p.components.len()).iter().advance |c| {\n+        for p.components.slice(prefix, p.components.len()).iter().advance |c| {\n             sub = sub.push(*c);\n         }\n         debug!(\"found crate %s\", sub.to_str());"}, {"sha": "36920bd248879e3951eb45e9ad5ab37f9c8f87a3", "filename": "src/libstd/io.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -65,7 +65,7 @@ use str::StrSlice;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n+use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n \n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n@@ -698,7 +698,7 @@ impl<T:Reader> ReaderUtil for T {\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                bytes = vec::slice(bytes, offset, bytes.len()).to_owned();\n+                bytes = bytes.slice(offset, bytes.len()).to_owned();\n             }\n         }\n         chars\n@@ -1053,7 +1053,7 @@ impl Reader for BytesReader {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - *self.pos);\n \n-        let view = vec::slice(self.bytes, *self.pos, self.bytes.len());\n+        let view = self.bytes.slice(*self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n \n         *self.pos += count;\n@@ -1658,12 +1658,12 @@ impl Writer for BytesWriter {\n \n         let bytes = &mut *self.bytes;\n         let count = uint::max(bytes.len(), *self.pos + v_len);\n-        vec::reserve(bytes, count);\n+        bytes.reserve(count);\n \n         unsafe {\n             vec::raw::set_len(bytes, count);\n \n-            let view = vec::mut_slice(*bytes, *self.pos, count);\n+            let view = bytes.mut_slice(*self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);\n         }\n \n@@ -1909,8 +1909,7 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                assert!(vec::slice(ivals, 0u, res.len()) ==\n-                             vec::map(res, |x| *x as int));\n+                assert!(ivals.slice(0u, res.len()) == vec::map(res, |x| *x as int));\n             }\n         }\n         let mut i = 0;"}, {"sha": "78940143f4e3df990cdf6c7bee519ecd7812e073", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -1030,7 +1030,6 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    use iter;\n     use uint;\n \n     #[test]"}, {"sha": "33b4e3f1963a99f1d6c71d00f5d7d475d72734f5", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -92,14 +92,12 @@ fn test_tls_multitask() {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"parent data\");\n         do task::spawn {\n-            unsafe {\n-                // TLS shouldn't carry over.\n-                assert!(local_data_get(my_key).is_none());\n-                local_data_set(my_key, @~\"child data\");\n-                assert!(*(local_data_get(my_key).get()) ==\n+            // TLS shouldn't carry over.\n+            assert!(local_data_get(my_key).is_none());\n+            local_data_set(my_key, @~\"child data\");\n+            assert!(*(local_data_get(my_key).get()) ==\n                     ~\"child data\");\n-                // should be cleaned up for us\n-            }\n+            // should be cleaned up for us\n         }\n         // Must work multiple times\n         assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n@@ -206,12 +204,11 @@ fn test_tls_cleanup_on_failure() {\n         local_data_set(str_key, @~\"parent data\");\n         local_data_set(box_key, @@());\n         do task::spawn {\n-            unsafe { // spawn_linked\n-                local_data_set(str_key, @~\"string data\");\n-                local_data_set(box_key, @@());\n-                local_data_set(int_key, @42);\n-                fail!();\n-            }\n+            // spawn_linked\n+            local_data_set(str_key, @~\"string data\");\n+            local_data_set(box_key, @@());\n+            local_data_set(int_key, @42);\n+            fail!();\n         }\n         // Not quite nondeterministic.\n         local_data_set(int_key, @31337);"}, {"sha": "7d848184493f8930faa2e70f59c517e88cb9d85a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -134,7 +134,7 @@ pub mod win32 {\n                     }\n                 }\n                 if k != 0 && done {\n-                    let sub = vec::slice(buf, 0u, k as uint);\n+                    let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n                 }\n             }\n@@ -1140,7 +1140,7 @@ pub fn set_exit_status(code: int) {\n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     let mut args = ~[];\n     for uint::range(0, argc as uint) |i| {\n-        vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n+        args.push(str::raw::from_c_str(*argv.offset(i)));\n     }\n     args\n }\n@@ -1186,8 +1186,7 @@ pub fn real_args() -> ~[~str] {\n             while *ptr.offset(len) != 0 { len += 1; }\n \n             // Push it onto the list.\n-            vec::push(&mut args,\n-                      vec::raw::buf_as_slice(ptr, len,\n+            args.push(vec::raw::buf_as_slice(ptr, len,\n                                              str::from_utf16));\n         }\n     }"}, {"sha": "1f82a9cd963356b82b8ddc630671654b6cb84628", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -292,13 +292,13 @@ impl<T: Reader> ReaderUtil for T {\n             let start_len = buf.len();\n             let mut total_read = 0;\n \n-            vec::reserve_at_least(buf, start_len + len);\n+            buf.reserve_at_least(start_len + len);\n             vec::raw::set_len(buf, start_len + len);\n \n             do (|| {\n                 while total_read < len {\n                     let len = buf.len();\n-                    let slice = vec::mut_slice(*buf, start_len + total_read, len);\n+                    let slice = buf.mut_slice(start_len + total_read, len);\n                     match self.read(slice) {\n                         Some(nread) => {\n                             total_read += nread;"}, {"sha": "c93945a6a9aa9eeddba2784b6b6b2c050122470b", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -86,7 +86,7 @@ impl Reader for MemReader {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = vec::mut_slice(buf, 0, write_len);\n+            let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n             vec::bytes::copy_memory(output, input, write_len);\n         }"}, {"sha": "14465eb7dfd3afade41774d752c0c5e18ee99955", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -160,14 +160,14 @@ mod test {\n                         let mut timer2 = TimerWatcher::new(&mut loop_);\n                         do timer2.start(10, 0) |timer2, _| {\n \n-                            unsafe { *count_ptr += 1; }\n+                            *count_ptr += 1;\n \n                             timer2.close(||());\n \n                             // Restart the original timer\n                             let mut timer = timer;\n                             do timer.start(1, 0) |timer, _| {\n-                                unsafe { *count_ptr += 1; }\n+                                *count_ptr += 1;\n                                 timer.close(||());\n                             }\n                         }"}, {"sha": "f8c8ffdbe35ce3cd8e6515aa6e32d337a03bbd83", "filename": "src/libstd/str.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -2081,7 +2081,7 @@ impl OwnedStr for ~str {\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n             let v: *mut ~[u8] = cast::transmute(self);\n-            vec::reserve(&mut *v, n + 1);\n+            (*v).reserve(n + 1);\n         }\n     }\n \n@@ -2115,8 +2115,8 @@ impl OwnedStr for ~str {\n      * reallocating\n      */\n     fn capacity(&self) -> uint {\n-        let buf: &const ~[u8] = unsafe { cast::transmute(self) };\n-        let vcap = vec::capacity(buf);\n+        let buf: &~[u8] = unsafe { cast::transmute(self) };\n+        let vcap = buf.capacity();\n         assert!(vcap > 0u);\n         vcap - 1u\n     }\n@@ -2249,7 +2249,7 @@ mod tests {\n         assert!(\"\" <= \"\");\n         assert!(\"\" <= \"foo\");\n         assert!(\"foo\" <= \"foo\");\n-        assert!(\"foo\" != ~\"bar\");\n+        assert!(\"foo\" != \"bar\");\n     }\n \n     #[test]\n@@ -3156,6 +3156,7 @@ mod tests {\n \n     #[test]\n     fn test_add() {\n+        #[allow(unnecessary_allocation)];\n         macro_rules! t (\n             ($s1:expr, $s2:expr, $e:expr) => {\n                 assert_eq!($s1 + $s2, $e);"}, {"sha": "b558b9d53a3ccb027c988842e62d4f1b2537fb6c", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -934,17 +934,15 @@ fn test_spawn_sched_blocking() {\n             let lock = testrt::rust_dbg_lock_create();\n \n             do spawn_sched(SingleThreaded) {\n-                unsafe {\n-                    testrt::rust_dbg_lock_lock(lock);\n+                testrt::rust_dbg_lock_lock(lock);\n \n-                    start_ch.send(());\n+                start_ch.send(());\n \n-                    // Block the scheduler thread\n-                    testrt::rust_dbg_lock_wait(lock);\n-                    testrt::rust_dbg_lock_unlock(lock);\n+                // Block the scheduler thread\n+                testrt::rust_dbg_lock_wait(lock);\n+                testrt::rust_dbg_lock_unlock(lock);\n \n-                    fin_ch.send(());\n-                }\n+                fin_ch.send(());\n             };\n \n             // Wait until the other task has its lock"}, {"sha": "8cbd9309cc6b1b351a9dd8dffcf66c03be05607d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 356, "deletions": 476, "changes": 832, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -68,63 +68,6 @@ pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n     xs.len() == ys.len()\n }\n \n-/**\n- * Reserves capacity for exactly `n` elements in the given vector.\n- *\n- * If the capacity for `v` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * v - A vector\n- * * n - The number of elements to reserve space for\n- */\n-#[inline]\n-pub fn reserve<T>(v: &mut ~[T], n: uint) {\n-    // Only make the (slow) call into the runtime if we have to\n-    use managed;\n-    if capacity(v) < n {\n-        unsafe {\n-            let ptr: **raw::VecRepr = cast::transmute(v);\n-            let td = get_tydesc::<T>();\n-            if ((**ptr).box_header.ref_count ==\n-                managed::raw::RC_MANAGED_UNIQUE) {\n-                rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n-            } else {\n-                rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Reserves capacity for at least `n` elements in the given vector.\n- *\n- * This function will over-allocate in order to amortize the allocation costs\n- * in scenarios where the caller may need to repeatedly reserve additional\n- * space.\n- *\n- * If the capacity for `v` is already equal to or greater than the requested\n- * capacity, then no action is taken.\n- *\n- * # Arguments\n- *\n- * * v - A vector\n- * * n - The number of elements to reserve space for\n- */\n-pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n-    reserve(v, uint::next_power_of_two(n));\n-}\n-\n-/// Returns the number of elements the vector can hold without reallocating\n-#[inline]\n-pub fn capacity<T>(v: &const ~[T]) -> uint {\n-    unsafe {\n-        let repr: **raw::VecRepr = transmute(v);\n-        (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n-    }\n-}\n-\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -179,7 +122,7 @@ pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n /// Creates a new vector with a capacity of `capacity`\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n-    reserve(&mut vec, capacity);\n+    vec.reserve(capacity);\n     vec\n }\n \n@@ -238,85 +181,6 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n // Accessors\n \n-/// Returns the first element of a vector\n-pub fn head<'r,T>(v: &'r [T]) -> &'r T {\n-    if v.len() == 0 { fail!(\"head: empty vector\") }\n-    &v[0]\n-}\n-\n-/// Returns `Some(x)` where `x` is the first element of the slice `v`,\n-/// or `None` if the vector is empty.\n-pub fn head_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n-    if v.len() == 0 { None } else { Some(&v[0]) }\n-}\n-\n-/// Returns a vector containing all but the first element of a slice\n-pub fn tail<'r,T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n-\n-/// Returns a vector containing all but the first `n` elements of a slice\n-pub fn tailn<'r,T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n-\n-/// Returns a vector containing all but the last element of a slice\n-pub fn init<'r,T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n-\n-/// Returns a vector containing all but the last `n' elements of a slice\n-pub fn initn<'r,T>(v: &'r [T], n: uint) -> &'r [T] {\n-    slice(v, 0, v.len() - n)\n-}\n-\n-/// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub fn last<'r,T>(v: &'r [T]) -> &'r T {\n-    if v.len() == 0 { fail!(\"last: empty vector\") }\n-    &v[v.len() - 1]\n-}\n-\n-/// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n-/// `None` if the vector is empty.\n-pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n-    if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n-}\n-\n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_imm_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n-                    -> &'r mut [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_mut_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::mut_offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n-/// Return a slice that points into another slice.\n-#[inline]\n-pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n-                      -> &'r const [T] {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    do as_const_buf(v) |p, _len| {\n-        unsafe {\n-            transmute((ptr::const_offset(p, start),\n-                       (end - start) * sys::nonzero_size_of::<T>()))\n-        }\n-    }\n-}\n-\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n@@ -330,12 +194,12 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_owned());\n+                result.push(v.slice(start, i).to_owned());\n                 start = i + 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_owned());\n+    result.push(v.slice(start, ln).to_owned());\n     result\n }\n \n@@ -354,14 +218,14 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_owned());\n+                result.push(v.slice(start, i).to_owned());\n                 // Make sure to skip the separator.\n                 start = i + 1u;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_owned());\n+    result.push(v.slice(start, ln).to_owned());\n     result\n }\n \n@@ -379,12 +243,12 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1, end).to_owned());\n+                result.push(v.slice(i + 1, end).to_owned());\n                 end = i;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_owned());\n+    result.push(v.slice(0u, end).to_owned());\n     reverse(result);\n     result\n }\n@@ -404,148 +268,18 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0u, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end).to_owned());\n+                result.push(v.slice(i + 1u, end).to_owned());\n                 // Make sure to skip the separator.\n                 end = i;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_owned());\n+    result.push(v.slice(0u, end).to_owned());\n     reverse(result);\n     result\n }\n \n-/**\n- * Partitions a vector into two new vectors: those that satisfies the\n- * predicate, and those that do not.\n- */\n-pub fn partition<T>(v: ~[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n-    let mut lefts  = ~[];\n-    let mut rights = ~[];\n-\n-    // FIXME (#4355 maybe): using v.consume here crashes\n-    // do v.consume |_, elt| {\n-    do consume(v) |_, elt| {\n-        if f(&elt) {\n-            lefts.push(elt);\n-        } else {\n-            rights.push(elt);\n-        }\n-    }\n-\n-    (lefts, rights)\n-}\n-\n-/**\n- * Partitions a vector into two new vectors: those that satisfies the\n- * predicate, and those that do not.\n- */\n-pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n-    let mut lefts  = ~[];\n-    let mut rights = ~[];\n-\n-    for v.iter().advance |elt| {\n-        if f(elt) {\n-            lefts.push(copy *elt);\n-        } else {\n-            rights.push(copy *elt);\n-        }\n-    }\n-\n-    (lefts, rights)\n-}\n-\n-// Mutators\n-\n-/// Removes the first element from a vector and return it\n-pub fn shift<T>(v: &mut ~[T]) -> T {\n-    unsafe {\n-        assert!(!v.is_empty());\n-\n-        if v.len() == 1 { return v.pop() }\n-\n-        if v.len() == 2 {\n-            let last = v.pop();\n-            let first = v.pop();\n-            v.push(last);\n-            return first;\n-        }\n-\n-        let ln = v.len();\n-        let next_ln = v.len() - 1;\n-\n-        // Save the last element. We're going to overwrite its position\n-        let work_elt = v.pop();\n-        // We still should have room to work where what last element was\n-        assert!(capacity(v) >= ln);\n-        // Pretend like we have the original length so we can use\n-        // the vector copy_memory to overwrite the hole we just made\n-        raw::set_len(&mut *v, ln);\n-\n-        // Memcopy the head element (the one we want) to the location we just\n-        // popped. For the moment it unsafely exists at both the head and last\n-        // positions\n-        {\n-            let first_slice = slice(*v, 0, 1);\n-            let last_slice = slice(*v, next_ln, ln);\n-            raw::copy_memory(transmute(last_slice), first_slice, 1);\n-        }\n-\n-        // Memcopy everything to the left one element\n-        {\n-            let init_slice = slice(*v, 0, next_ln);\n-            let tail_slice = slice(*v, 1, ln);\n-            raw::copy_memory(transmute(init_slice),\n-                             tail_slice,\n-                             next_ln);\n-        }\n-\n-        // Set the new length. Now the vector is back to normal\n-        raw::set_len(&mut *v, next_ln);\n-\n-        // Swap out the element we want from the end\n-        let vp = raw::to_mut_ptr(*v);\n-        let vp = ptr::mut_offset(vp, next_ln - 1);\n-\n-        ptr::replace_ptr(vp, work_elt)\n-    }\n-}\n-\n-/// Prepend an element to the vector\n-pub fn unshift<T>(v: &mut ~[T], x: T) {\n-    let vv = util::replace(v, ~[x]);\n-    v.push_all_move(vv);\n-}\n-\n-/// Insert an element at position i within v, shifting all\n-/// elements after position i one position to the right.\n-pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n-    let len = v.len();\n-    assert!(i <= len);\n-\n-    v.push(x);\n-    let mut j = len;\n-    while j > i {\n-        swap(*v, j, j - 1);\n-        j -= 1;\n-    }\n-}\n-\n-/// Remove and return the element at position i within v, shifting\n-/// all elements after position i one position to the left.\n-pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n-    let len = v.len();\n-    assert!(i < len);\n-\n-    let mut j = i;\n-    while j < len - 1 {\n-        swap(*v, j, j + 1);\n-        j += 1;\n-    }\n-    v.pop()\n-}\n-\n /// Consumes all elements, in a vector, moving them out into the / closure\n /// provided. The vector is traversed from the start to the end.\n ///\n@@ -607,131 +341,6 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     }\n }\n \n-/// Remove the last element from a vector and return it\n-pub fn pop<T>(v: &mut ~[T]) -> T {\n-    let ln = v.len();\n-    if ln == 0 {\n-        fail!(\"sorry, cannot vec::pop an empty vector\")\n-    }\n-    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n-    unsafe {\n-        let val = ptr::replace_ptr(valptr, intrinsics::init());\n-        raw::set_len(v, ln - 1u);\n-        val\n-    }\n-}\n-\n-/**\n- * Remove an element from anywhere in the vector and return it, replacing it\n- * with the last element. This does not preserve ordering, but is O(1).\n- *\n- * Fails if index >= length.\n- */\n-pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n-    let ln = v.len();\n-    if index >= ln {\n-        fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n-    }\n-    if index < ln - 1 {\n-        swap(*v, index, ln - 1);\n-    }\n-    v.pop()\n-}\n-\n-/// Append an element to a vector\n-#[inline]\n-pub fn push<T>(v: &mut ~[T], initval: T) {\n-    unsafe {\n-        let repr: **raw::VecRepr = transmute(&mut *v);\n-        let fill = (**repr).unboxed.fill;\n-        if (**repr).unboxed.alloc > fill {\n-            push_fast(v, initval);\n-        }\n-        else {\n-            push_slow(v, initval);\n-        }\n-    }\n-}\n-\n-// This doesn't bother to make sure we have space.\n-#[inline] // really pretty please\n-unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **mut raw::VecRepr = transmute(v);\n-    let fill = (**repr).unboxed.fill;\n-    (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n-    let p = to_unsafe_ptr(&((**repr).unboxed.data));\n-    let p = ptr::offset(p, fill) as *mut T;\n-    intrinsics::move_val_init(&mut(*p), initval);\n-}\n-\n-#[inline(never)]\n-fn push_slow<T>(v: &mut ~[T], initval: T) {\n-    let new_len = v.len() + 1;\n-    reserve_at_least(&mut *v, new_len);\n-    unsafe { push_fast(v, initval) }\n-}\n-\n-/// Iterates over the slice `rhs`, copies each element, and then appends it to\n-/// the vector provided `v`. The `rhs` vector is traversed in-order.\n-///\n-/// # Example\n-///\n-/// ~~~ {.rust}\n-/// let mut a = ~[1];\n-/// vec::push_all(&mut a, [2, 3, 4]);\n-/// assert!(a == ~[1, 2, 3, 4]);\n-/// ~~~\n-#[inline]\n-pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n-    let new_len = v.len() + rhs.len();\n-    reserve(&mut *v, new_len);\n-\n-    for uint::range(0u, rhs.len()) |i| {\n-        push(&mut *v, unsafe { raw::get(rhs, i) })\n-    }\n-}\n-\n-/// Takes ownership of the vector `rhs`, moving all elements into the specified\n-/// vector `v`. This does not copy any elements, and it is illegal to use the\n-/// `rhs` vector after calling this method (because it is moved here).\n-///\n-/// # Example\n-///\n-/// ~~~ {.rust}\n-/// let mut a = ~[~1];\n-/// vec::push_all_move(&mut a, ~[~2, ~3, ~4]);\n-/// assert!(a == ~[~1, ~2, ~3, ~4]);\n-/// ~~~\n-#[inline]\n-pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n-    let new_len = v.len() + rhs.len();\n-    reserve(&mut *v, new_len);\n-    unsafe {\n-        do as_mut_buf(rhs) |p, len| {\n-            for uint::range(0, len) |i| {\n-                let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n-                                         intrinsics::uninit());\n-                push(&mut *v, x);\n-            }\n-        }\n-        raw::set_len(&mut rhs, 0);\n-    }\n-}\n-\n-/// Shorten a vector, dropping excess elements.\n-pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n-    do as_mut_buf(*v) |p, oldlen| {\n-        assert!(newlen <= oldlen);\n-        unsafe {\n-            // This loop is optimized out for non-drop types.\n-            for uint::range(newlen, oldlen) |i| {\n-                ptr::replace_ptr(ptr::mut_offset(p, i), intrinsics::uninit());\n-            }\n-        }\n-    }\n-    unsafe { raw::set_len(&mut *v, newlen); }\n-}\n-\n /**\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n@@ -800,7 +409,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  */\n pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     let new_len = v.len() + n;\n-    reserve_at_least(&mut *v, new_len);\n+    v.reserve_at_least(new_len);\n     let mut i: uint = 0u;\n \n     while i < n {\n@@ -824,7 +433,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  */\n pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: &fn(uint) -> T) {\n     let new_len = v.len() + n;\n-    reserve_at_least(&mut *v, new_len);\n+    v.reserve_at_least(new_len);\n     let mut i: uint = 0u;\n     while i < n {\n         v.push(op(i));\n@@ -981,26 +590,6 @@ pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     result\n }\n \n-/**\n- * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n- */\n-pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n-    let len = v.len();\n-    let mut deleted: uint = 0;\n-\n-    for uint::range(0, len) |i| {\n-        if !f(&v[i]) {\n-            deleted += 1;\n-        } else if deleted > 0 {\n-            swap(*v, i - deleted, i);\n-        }\n-    }\n-\n-    if deleted > 0 {\n-        v.truncate(len - deleted);\n-    }\n-}\n-\n /// Flattens a vector of vectors of T into a single vector of T.\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n \n@@ -1652,13 +1241,11 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n-        let mut result = ~[];\n-        reserve(&mut result, self.len());\n+        let mut result = with_capacity(self.len());\n         for self.iter().advance |e| {\n             result.push(copy *e);\n         }\n         result\n-\n     }\n }\n \n@@ -1689,7 +1276,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n-        slice(*self, start, end)\n+    assert!(start <= end);\n+    assert!(end <= self.len());\n+        do as_imm_buf(*self) |p, _len| {\n+            unsafe {\n+                transmute((ptr::offset(p, start),\n+                           (end - start) * sys::nonzero_size_of::<T>()))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -1712,35 +1306,49 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n-    fn head(&self) -> &'self T { head(*self) }\n+    fn head(&self) -> &'self T {\n+        if self.len() == 0 { fail!(\"head: empty vector\") }\n+        &self[0]\n+    }\n \n-    /// Returns the first element of a vector\n+    /// Returns the first element of a vector, or `None` if it is empty\n     #[inline]\n-    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+    fn head_opt(&self) -> Option<&'self T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n+    }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    fn tail(&self) -> &'self [T] { tail(*self) }\n+    fn tail(&self) -> &'self [T] { self.slice(1, self.len()) }\n \n     /// Returns all but the first `n' elements of a vector\n     #[inline]\n-    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+    fn tailn(&self, n: uint) -> &'self [T] { self.slice(n, self.len()) }\n \n-    /// Returns all but the last elemnt of a vector\n+    /// Returns all but the last element of a vector\n     #[inline]\n-    fn init(&self) -> &'self [T] { init(*self) }\n+    fn init(&self) -> &'self [T] {\n+        self.slice(0, self.len() - 1)\n+    }\n \n     /// Returns all but the last `n' elemnts of a vector\n     #[inline]\n-    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+    fn initn(&self, n: uint) -> &'self [T] {\n+        self.slice(0, self.len() - n)\n+    }\n \n-    /// Returns the last element of a `v`, failing if the vector is empty.\n+    /// Returns the last element of a vector, failing if the vector is empty.\n     #[inline]\n-    fn last(&self) -> &'self T { last(*self) }\n+    fn last(&self) -> &'self T {\n+        if self.len() == 0 { fail!(\"last: empty vector\") }\n+        &self[self.len() - 1]\n+    }\n \n-    /// Returns the last element of a `v`, failing if the vector is empty.\n+    /// Returns the last element of a vector, or `None` if it is empty.\n     #[inline]\n-    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+    fn last_opt(&self) -> Option<&'self T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n \n     /**\n      * Find the last index matching some predicate\n@@ -1865,7 +1473,18 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n      */\n     #[inline]\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n-        partitioned(*self, f)\n+        let mut lefts  = ~[];\n+        let mut rights = ~[];\n+\n+        for self.iter().advance |elt| {\n+            if f(elt) {\n+                lefts.push(copy *elt);\n+            } else {\n+                rights.push(copy *elt);\n+            }\n+        }\n+\n+        (lefts, rights)\n     }\n \n     /// Returns the element at the given index, without doing bounds checking.\n@@ -1877,7 +1496,13 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n+    fn reserve(&mut self, n: uint);\n+    fn reserve_at_least(&mut self, n: uint);\n+    fn capacity(&self) -> uint;\n+\n     fn push(&mut self, t: T);\n+    unsafe fn push_fast(&mut self, t: T);\n+\n     fn push_all_move(&mut self, rhs: ~[T]);\n     fn pop(&mut self) -> T;\n     fn shift(&mut self) -> T;\n@@ -1895,54 +1520,276 @@ pub trait OwnedVector<T> {\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n+    /**\n+     * Reserves capacity for exactly `n` elements in the given vector.\n+     *\n+     * If the capacity for `self` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to reserve space for\n+     */\n     #[inline]\n-    fn push(&mut self, t: T) {\n-        push(self, t);\n+    fn reserve(&mut self, n: uint) {\n+        // Only make the (slow) call into the runtime if we have to\n+        use managed;\n+        if self.capacity() < n {\n+            unsafe {\n+                let ptr: **raw::VecRepr = cast::transmute(self);\n+                let td = get_tydesc::<T>();\n+                if ((**ptr).box_header.ref_count ==\n+                    managed::raw::RC_MANAGED_UNIQUE) {\n+                    rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n+                } else {\n+                    rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n+                }\n+            }\n+        }\n     }\n \n+    /**\n+     * Reserves capacity for at least `n` elements in the given vector.\n+     *\n+     * This function will over-allocate in order to amortize the allocation costs\n+     * in scenarios where the caller may need to repeatedly reserve additional\n+     * space.\n+     *\n+     * If the capacity for `self` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to reserve space for\n+     */\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.reserve(uint::next_power_of_two(n));\n+    }\n+\n+    /// Returns the number of elements the vector can hold without reallocating.\n     #[inline]\n-    fn push_all_move(&mut self, rhs: ~[T]) {\n-        push_all_move(self, rhs);\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            let repr: **raw::VecRepr = transmute(self);\n+            (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n+        }\n     }\n \n+    /// Append an element to a vector\n     #[inline]\n+    fn push(&mut self, t: T) {\n+        unsafe {\n+            let repr: **raw::VecRepr = transmute(&mut *self);\n+            let fill = (**repr).unboxed.fill;\n+            if (**repr).unboxed.alloc <= fill {\n+                // need more space\n+                reserve_no_inline(self);\n+            }\n+\n+            self.push_fast(t);\n+        }\n+\n+        // this peculiar function is because reserve_at_least is very\n+        // large (because of reserve), and will be inlined, which\n+        // makes push too large.\n+        #[inline(never)]\n+        fn reserve_no_inline<T>(v: &mut ~[T]) {\n+            let new_len = v.len() + 1;\n+            v.reserve_at_least(new_len);\n+        }\n+    }\n+\n+    // This doesn't bother to make sure we have space.\n+    #[inline] // really pretty please\n+    unsafe fn push_fast(&mut self, t: T) {\n+        let repr: **mut raw::VecRepr = transmute(self);\n+        let fill = (**repr).unboxed.fill;\n+        (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n+        let p = to_unsafe_ptr(&((**repr).unboxed.data));\n+        let p = ptr::offset(p, fill) as *mut T;\n+        intrinsics::move_val_init(&mut(*p), t);\n+    }\n+\n+    /// Takes ownership of the vector `rhs`, moving all elements into\n+    /// the current vector. This does not copy any elements, and it is\n+    /// illegal to use the `rhs` vector after calling this method\n+    /// (because it is moved here).\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let mut a = ~[~1];\n+    /// a.push_all_move(~[~2, ~3, ~4]);\n+    /// assert!(a == ~[~1, ~2, ~3, ~4]);\n+    /// ~~~\n+    #[inline]\n+    fn push_all_move(&mut self, mut rhs: ~[T]) {\n+        let new_len = self.len() + rhs.len();\n+        self.reserve(new_len);\n+        unsafe {\n+            do as_mut_buf(rhs) |p, len| {\n+                for uint::range(0, len) |i| {\n+                    let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n+                                             intrinsics::uninit());\n+                    self.push(x);\n+                }\n+            }\n+            raw::set_len(&mut rhs, 0);\n+        }\n+    }\n+\n+    /// Remove the last element from a vector and return it\n     fn pop(&mut self) -> T {\n-        pop(self)\n+        let ln = self.len();\n+        if ln == 0 {\n+            fail!(\"sorry, cannot pop an empty vector\")\n+        }\n+        let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n+        unsafe {\n+            let val = ptr::replace_ptr(valptr, intrinsics::init());\n+            raw::set_len(self, ln - 1u);\n+            val\n+        }\n     }\n \n-    #[inline]\n+    /// Removes the first element from a vector and return it\n     fn shift(&mut self) -> T {\n-        shift(self)\n+        unsafe {\n+            assert!(!self.is_empty());\n+\n+            if self.len() == 1 { return self.pop() }\n+\n+            if self.len() == 2 {\n+                let last = self.pop();\n+                let first = self.pop();\n+                self.push(last);\n+                return first;\n+            }\n+\n+            let ln = self.len();\n+            let next_ln = self.len() - 1;\n+\n+            // Save the last element. We're going to overwrite its position\n+            let work_elt = self.pop();\n+            // We still should have room to work where what last element was\n+            assert!(self.capacity() >= ln);\n+            // Pretend like we have the original length so we can use\n+            // the vector copy_memory to overwrite the hole we just made\n+            raw::set_len(self, ln);\n+\n+            // Memcopy the head element (the one we want) to the location we just\n+            // popped. For the moment it unsafely exists at both the head and last\n+            // positions\n+            {\n+                let first_slice = self.slice(0, 1);\n+                let last_slice = self.slice(next_ln, ln);\n+                raw::copy_memory(transmute(last_slice), first_slice, 1);\n+            }\n+\n+            // Memcopy everything to the left one element\n+            {\n+                let init_slice = self.slice(0, next_ln);\n+                let tail_slice = self.slice(1, ln);\n+                raw::copy_memory(transmute(init_slice),\n+                                 tail_slice,\n+                                 next_ln);\n+            }\n+\n+            // Set the new length. Now the vector is back to normal\n+            raw::set_len(self, next_ln);\n+\n+            // Swap out the element we want from the end\n+            let vp = raw::to_mut_ptr(*self);\n+            let vp = ptr::mut_offset(vp, next_ln - 1);\n+\n+            ptr::replace_ptr(vp, work_elt)\n+        }\n     }\n \n-    #[inline]\n+    /// Prepend an element to the vector\n     fn unshift(&mut self, x: T) {\n-        unshift(self, x)\n+        let v = util::replace(self, ~[x]);\n+        self.push_all_move(v);\n     }\n \n-    #[inline]\n+    /// Insert an element at position i within v, shifting all\n+    /// elements after position i one position to the right.\n     fn insert(&mut self, i: uint, x:T) {\n-        insert(self, i, x)\n+        let len = self.len();\n+        assert!(i <= len);\n+\n+        self.push(x);\n+        let mut j = len;\n+        while j > i {\n+            swap(*self, j, j - 1);\n+            j -= 1;\n+        }\n     }\n \n-    #[inline]\n+    /// Remove and return the element at position i within v, shifting\n+    /// all elements after position i one position to the left.\n     fn remove(&mut self, i: uint) -> T {\n-        remove(self, i)\n+        let len = self.len();\n+        assert!(i < len);\n+\n+        let mut j = i;\n+        while j < len - 1 {\n+            swap(*self, j, j + 1);\n+            j += 1;\n+        }\n+        self.pop()\n     }\n \n-    #[inline]\n+    /**\n+     * Remove an element from anywhere in the vector and return it, replacing it\n+     * with the last element. This does not preserve ordering, but is O(1).\n+     *\n+     * Fails if index >= length.\n+     */\n     fn swap_remove(&mut self, index: uint) -> T {\n-        swap_remove(self, index)\n+        let ln = self.len();\n+        if index >= ln {\n+            fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n+        }\n+        if index < ln - 1 {\n+            swap(*self, index, ln - 1);\n+        }\n+        self.pop()\n     }\n \n-    #[inline]\n+    /// Shorten a vector, dropping excess elements.\n     fn truncate(&mut self, newlen: uint) {\n-        truncate(self, newlen);\n+        do as_mut_buf(*self) |p, oldlen| {\n+            assert!(newlen <= oldlen);\n+            unsafe {\n+                // This loop is optimized out for non-drop types.\n+                for uint::range(newlen, oldlen) |i| {\n+                    ptr::replace_ptr(ptr::mut_offset(p, i), intrinsics::uninit());\n+                }\n+            }\n+        }\n+        unsafe { raw::set_len(self, newlen); }\n     }\n \n-    #[inline]\n+\n+    /**\n+     * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n+     */\n     fn retain(&mut self, f: &fn(t: &T) -> bool) {\n-        retain(self, f);\n+        let len = self.len();\n+        let mut deleted: uint = 0;\n+\n+        for uint::range(0, len) |i| {\n+            if !f(&self[i]) {\n+                deleted += 1;\n+            } else if deleted > 0 {\n+                swap(*self, i - deleted, i);\n+            }\n+        }\n+\n+        if deleted > 0 {\n+            self.truncate(len - deleted);\n+        }\n     }\n \n     #[inline]\n@@ -1966,7 +1813,18 @@ impl<T> OwnedVector<T> for ~[T] {\n      */\n     #[inline]\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n-        partition(self, f)\n+        let mut lefts  = ~[];\n+        let mut rights = ~[];\n+\n+        do self.consume |_, elt| {\n+            if f(&elt) {\n+                lefts.push(elt);\n+            } else {\n+                rights.push(elt);\n+            }\n+        }\n+\n+        (lefts, rights)\n     }\n \n     #[inline]\n@@ -1988,9 +1846,24 @@ pub trait OwnedCopyableVector<T:Copy> {\n }\n \n impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n+    /// Iterates over the slice `rhs`, copies each element, and then appends it to\n+    /// the vector provided `v`. The `rhs` vector is traversed in-order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let mut a = ~[1];\n+    /// a.push_all([2, 3, 4]);\n+    /// assert!(a == ~[1, 2, 3, 4]);\n+    /// ~~~\n     #[inline]\n     fn push_all(&mut self, rhs: &const [T]) {\n-        push_all(self, rhs);\n+        let new_len = self.len() + rhs.len();\n+        self.reserve(new_len);\n+\n+        for uint::range(0u, rhs.len()) |i| {\n+            self.push(unsafe { raw::get(rhs, i) })\n+        }\n     }\n \n     #[inline]\n@@ -2042,9 +1915,17 @@ pub trait MutableVector<'self, T> {\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n+    /// Return a slice that points into another slice.\n     #[inline]\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n-        mut_slice(self, start, end)\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do as_mut_buf(self) |p, _len| {\n+            unsafe {\n+                transmute((ptr::mut_offset(p, start),\n+                           (end - start) * sys::nonzero_size_of::<T>()))\n+            }\n+        }\n     }\n \n     #[inline]\n@@ -2713,30 +2594,30 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_owned();\n+        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_owned();\n         assert_eq!(v_a.len(), 3u);\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n-        let v_b = slice(vec_stack, 1u, 3u).to_owned();\n+        let v_b = vec_stack.slice(1u, 3u).to_owned();\n         assert_eq!(v_b.len(), 2u);\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n-        let v_c = slice(vec_managed, 0u, 3u).to_owned();\n+        let v_c = vec_managed.slice(0u, 3u).to_owned();\n         assert_eq!(v_c.len(), 3u);\n         assert_eq!(v_c[0], 1);\n         assert_eq!(v_c[1], 2);\n         assert_eq!(v_c[2], 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n-        let v_d = slice(vec_unique, 1u, 6u).to_owned();\n+        let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);\n@@ -3329,11 +3210,10 @@ mod tests {\n \n     #[test]\n     fn test_partition() {\n-        // FIXME (#4355 maybe): using v.partition here crashes\n-        assert_eq!(partition(~[], |x: &int| *x < 3), (~[], ~[]));\n-        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 4), (~[1, 2, 3], ~[]));\n-        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 2), (~[1], ~[2, 3]));\n-        assert_eq!(partition(~[1, 2, 3], |x: &int| *x < 0), (~[], ~[1, 2, 3]));\n+        assert_eq!((~[]).partition(|x: &int| *x < 3), (~[], ~[]));\n+        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 4), (~[1, 2, 3], ~[]));\n+        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 2), (~[1], ~[2, 3]));\n+        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 0), (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n@@ -3453,11 +3333,11 @@ mod tests {\n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n-        reserve(&mut v, 10u);\n-        assert_eq!(capacity(&v), 10u);\n+        v.reserve(10u);\n+        assert_eq!(v.capacity(), 10u);\n         let mut v = ~[0u32];\n-        reserve(&mut v, 10u);\n-        assert_eq!(capacity(&v), 10u);\n+        v.reserve(10u);\n+        assert_eq!(v.capacity(), 10u);\n     }\n \n     #[test]\n@@ -3981,11 +3861,11 @@ mod tests {\n     fn test_vec_zero() {\n         use num::Zero;\n         macro_rules! t (\n-            ($ty:ty) => {\n+            ($ty:ty) => {{\n                 let v: $ty = Zero::zero();\n                 assert!(v.is_empty());\n                 assert!(v.is_zero());\n-            }\n+            }}\n         );\n \n         t!(&[int]);"}, {"sha": "c7f33587f3157bfe67671901f7c6dc7a124620a1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -13,7 +13,6 @@ use codemap;\n \n use std::io;\n use std::uint;\n-use std::vec;\n use extra::term;\n \n pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, span)>,\n@@ -250,7 +249,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     let mut elided = false;\n     let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if display_lines.len() > max_lines {\n-        display_lines = vec::slice(display_lines, 0u, max_lines).to_owned();\n+        display_lines = display_lines.slice(0u, max_lines).to_owned();\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "787cf696cc34851fce7aa37b4bb7f085fd6e68e3", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -29,7 +29,7 @@ macro_rules! bench (\n \n fn main() {\n     let argv = os::args();\n-    let tests = vec::slice(argv, 1, argv.len());\n+    let tests = argv.slice(1, argv.len());\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "5ebcfe164ce77f17d36f22cb5d7c8dcc7c3b689f", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -96,7 +96,7 @@ impl RepeatFasta {\n \n             copy_memory(buf, alu, alu_len);\n             let buf_len = buf.len();\n-            copy_memory(vec::mut_slice(buf, alu_len, buf_len),\n+            copy_memory(buf.mut_slice(alu_len, buf_len),\n                         alu,\n                         LINE_LEN);\n "}, {"sha": "57683fa3dbf0c6eda9dd8fb6793dbf893d34b24b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -90,7 +90,7 @@ fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<~[u8], uint>, key: &[u8]) {\n-    let key = vec::slice(key, 0, key.len()).to_owned();\n+    let key = key.to_owned();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n@@ -107,11 +107,11 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(vec::slice(bb, ii, ii+nn));\n+      it(bb.slice(ii, ii+nn));\n       ii += 1u;\n    }\n \n-   return vec::slice(bb, len - (nn - 1u), len).to_owned();\n+   return bb.slice(len - (nn - 1u), len).to_owned();\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "405aa68c483ba74470405e99cad98a9f72be61c1", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -8,7 +8,7 @@ use std::libc::{STDIN_FILENO, c_int, fdopen, fgets, fileno, fopen, fstat};\n use std::libc::{stat, strlen};\n use std::ptr::null;\n use std::unstable::intrinsics::init;\n-use std::vec::{reverse, slice};\n+use std::vec::{reverse};\n use extra::sort::quick_sort3;\n \n static LINE_LEN: uint = 80;\n@@ -194,7 +194,7 @@ fn unpack_symbol(c: u8) -> u8 {\n \n fn next_char<'a>(mut buf: &'a [u8]) -> &'a [u8] {\n     loop {\n-        buf = slice(buf, 1, buf.len());\n+        buf = buf.slice(1, buf.len());\n         if buf.len() == 0 {\n             break;\n         }\n@@ -226,7 +226,7 @@ fn read_stdin() -> ~[u8] {\n                 fgets(transmute(&mut window[0]), LINE_LEN as c_int, stdin);\n \n                 {\n-                    if vec::slice(window, 0, 6) == header {\n+                    if window.slice(0, 6) == header {\n                         break;\n                     }\n                 }\n@@ -235,9 +235,7 @@ fn read_stdin() -> ~[u8] {\n             while fgets(transmute(&mut window[0]),\n                         LINE_LEN as c_int,\n                         stdin) != null() {\n-                window = vec::mut_slice(window,\n-                                        strlen(transmute(&window[0])) as uint,\n-                                        window.len());\n+                window = window.mut_slice(strlen(transmute(&window[0])) as uint, window.len());\n             }\n         }\n "}, {"sha": "295211e03a14b4439c040dad72071b5a51827a62", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -32,7 +32,6 @@ use std::str;\n use std::task;\n use std::u64;\n use std::uint;\n-use std::vec;\n \n fn fib(n: int) -> int {\n     fn pfib(c: &Chan<int>, n: int) {\n@@ -62,7 +61,7 @@ struct Config {\n fn parse_opts(argv: ~[~str]) -> Config {\n     let opts = ~[getopts::optflag(~\"stress\")];\n \n-    let opt_args = vec::slice(argv, 1, argv.len());\n+    let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts) {\n       Ok(ref m) => {"}, {"sha": "e57dee06c75bdc33077eaacac78b3176a1bf271d", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -5,7 +5,6 @@ use std::cast::transmute;\n use std::libc::{STDOUT_FILENO, c_int, fdopen, fgets, fopen, fputc, fwrite};\n use std::libc::{size_t};\n use std::ptr::null;\n-use std::vec::{capacity, reserve, reserve_at_least};\n use std::vec::raw::set_len;\n \n static LINE_LEN: u32 = 80;\n@@ -103,13 +102,13 @@ fn main() {\n         let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n \n         let mut out: ~[u8] = ~[];\n-        reserve(&mut out, 12777888);\n+        out.reserve(12777888);\n         let mut pos = 0;\n \n         loop {\n             let needed = pos + (LINE_LEN as uint) + 1;\n-            if capacity(&out) < needed {\n-                reserve_at_least(&mut out, needed);\n+            if out.capacity() < needed {\n+                out.reserve_at_least(needed);\n             }\n \n             let mut ptr = out.unsafe_mut_ref(pos);"}, {"sha": "c9f6733fa2587afdf6f0adb686d6cc44d4fc7d2b", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-// This doesn't work, and should.\n-//    v.slice(1, 5)\n-    vec::slice(v, 1, 5)\n+    v.slice(1, 5)\n }\n \n pub fn main() {}"}, {"sha": "e3012b0862145b30499f17f78f41a0232c117149", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63afb8ccc8dd945e35fa43ca319aeaa5fba78134/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=63afb8ccc8dd945e35fa43ca319aeaa5fba78134", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n pub fn main() {\n     let  v = ~[1,2,3,4,5];\n-    let v2 = vec::slice(v, 1, 3);\n+    let v2 = v.slice(1, 3);\n     assert_eq!(v2[0], 2);\n     assert_eq!(v2[1], 3);\n }"}]}