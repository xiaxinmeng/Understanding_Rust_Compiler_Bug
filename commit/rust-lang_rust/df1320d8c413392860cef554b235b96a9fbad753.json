{"sha": "df1320d8c413392860cef554b235b96a9fbad753", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMTMyMGQ4YzQxMzM5Mjg2MGNlZjU1NGIyMzViOTZhOWZiYWQ3NTM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-03T15:22:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-03T15:22:16Z"}, "message": "Rewrite reorder fields assist to use mutable syntax trees", "tree": {"sha": "82c40936cdb45126e620d2464bf21e3a9166e9ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82c40936cdb45126e620d2464bf21e3a9166e9ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df1320d8c413392860cef554b235b96a9fbad753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df1320d8c413392860cef554b235b96a9fbad753", "html_url": "https://github.com/rust-lang/rust/commit/df1320d8c413392860cef554b235b96a9fbad753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df1320d8c413392860cef554b235b96a9fbad753/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f87ee7f3f9c1efd726774511c9ce02caef73872", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f87ee7f3f9c1efd726774511c9ce02caef73872", "html_url": "https://github.com/rust-lang/rust/commit/2f87ee7f3f9c1efd726774511c9ce02caef73872"}], "stats": {"total": 89, "additions": 50, "deletions": 39}, "files": [{"sha": "1a95135ca1dca8982bf19eff04f0f96c022f0eea", "filename": "crates/ide_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/df1320d8c413392860cef554b235b96a9fbad753/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1320d8c413392860cef554b235b96a9fbad753/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=df1320d8c413392860cef554b235b96a9fbad753", "patch": "@@ -1,6 +1,8 @@\n+use either::Either;\n+use itertools::Itertools;\n use rustc_hash::FxHashMap;\n \n-use syntax::{algo, ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode};\n+use syntax::{ast, ted, AstNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -22,60 +24,70 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx\n         .find_node_at_offset::<ast::RecordExpr>()\n-        .map(|it| it.syntax().clone())\n-        .or_else(|| ctx.find_node_at_offset::<ast::RecordPat>().map(|it| it.syntax().clone()))?;\n-\n-    let path = record.children().find_map(ast::Path::cast)?;\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::RecordPat>().map(Either::Right))?;\n \n+    let path = record.as_ref().either(|it| it.path(), |it| it.path())?;\n     let ranks = compute_fields_ranks(&path, &ctx)?;\n+    let get_rank_of_field =\n+        |of: Option<_>| *ranks.get(&of.unwrap_or_default()).unwrap_or(&usize::MAX);\n \n-    let fields: Vec<SyntaxNode> = {\n-        let field_kind = match record.kind() {\n-            RECORD_EXPR => RECORD_EXPR_FIELD,\n-            RECORD_PAT => RECORD_PAT_FIELD,\n-            _ => {\n-                stdx::never!();\n-                return None;\n-            }\n-        };\n-        record.children().flat_map(|n| n.children()).filter(|n| n.kind() == field_kind).collect()\n+    let field_list = match &record {\n+        Either::Left(it) => Either::Left(it.record_expr_field_list()?),\n+        Either::Right(it) => Either::Right(it.record_pat_field_list()?),\n     };\n-\n-    let sorted_fields = {\n-        let mut fields = fields.clone();\n-        fields.sort_by_key(|node| *ranks.get(&get_field_name(node)).unwrap_or(&usize::max_value()));\n-        fields\n+    let fields = match field_list {\n+        Either::Left(it) => Either::Left((\n+            it.fields()\n+                .sorted_unstable_by_key(|field| {\n+                    get_rank_of_field(field.field_name().map(|it| it.to_string()))\n+                })\n+                .collect::<Vec<_>>(),\n+            it,\n+        )),\n+        Either::Right(it) => Either::Right((\n+            it.fields()\n+                .sorted_unstable_by_key(|field| {\n+                    get_rank_of_field(field.field_name().map(|it| it.to_string()))\n+                })\n+                .collect::<Vec<_>>(),\n+            it,\n+        )),\n     };\n \n-    if sorted_fields == fields {\n+    let is_sorted = fields.as_ref().either(\n+        |(sorted, field_list)| field_list.fields().zip(sorted).all(|(a, b)| a == *b),\n+        |(sorted, field_list)| field_list.fields().zip(sorted).all(|(a, b)| a == *b),\n+    );\n+    if is_sorted {\n         cov_mark::hit!(reorder_sorted_fields);\n         return None;\n     }\n-\n-    let target = record.text_range();\n+    let target = record.as_ref().either(AstNode::syntax, AstNode::syntax).text_range();\n     acc.add(\n         AssistId(\"reorder_fields\", AssistKind::RefactorRewrite),\n         \"Reorder record fields\",\n         target,\n-        |edit| {\n-            let mut rewriter = algo::SyntaxRewriter::default();\n-            for (old, new) in fields.iter().zip(&sorted_fields) {\n-                rewriter.replace(old, new);\n+        |builder| match fields {\n+            Either::Left((sorted, field_list)) => {\n+                replace(builder.make_ast_mut(field_list).fields(), sorted)\n+            }\n+            Either::Right((sorted, field_list)) => {\n+                replace(builder.make_ast_mut(field_list).fields(), sorted)\n             }\n-            edit.rewrite(rewriter);\n         },\n     )\n }\n \n-fn get_field_name(node: &SyntaxNode) -> String {\n-    let res = match_ast! {\n-        match node {\n-            ast::RecordExprField(field) => field.field_name().map(|it| it.to_string()),\n-            ast::RecordPatField(field) => field.field_name().map(|it| it.to_string()),\n-            _ => None,\n-        }\n-    };\n-    res.unwrap_or_default()\n+fn replace<T: AstNode + PartialEq>(\n+    fields: impl Iterator<Item = T>,\n+    sorted_fields: impl IntoIterator<Item = T>,\n+) {\n+    fields.zip(sorted_fields).filter(|(field, sorted)| field != sorted).for_each(\n+        |(field, sorted_field)| {\n+            ted::replace(field.syntax(), sorted_field.syntax().clone_for_update());\n+        },\n+    );\n }\n \n fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n@@ -86,7 +98,7 @@ fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashM\n \n     let res = strukt\n         .fields(ctx.db())\n-        .iter()\n+        .into_iter()\n         .enumerate()\n         .map(|(idx, field)| (field.name(ctx.db()).to_string(), idx))\n         .collect();\n@@ -137,7 +149,6 @@ const test: Foo = Foo { foo: 1, bar: 0 };\n \"#,\n         )\n     }\n-\n     #[test]\n     fn reorder_struct_pattern() {\n         check_assist("}]}