{"sha": "1482cf5ded3998fa8edb01999287d22594f1e4bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ODJjZjVkZWQzOTk4ZmE4ZWRiMDE5OTkyODdkMjI1OTRmMWU0YmI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-01T04:08:49Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-04T02:45:39Z"}, "message": "Base64 API changes\n\nThere's now an enum to pick the character set instead of a url_safe\nbool.\n\nfrom_base64 now returns a Result<~[u8], ~str> and returns an Err instead\nof killing the task when it is called on invalid input.\n\nFixed documentation examples.", "tree": {"sha": "d43341fa3826856a21d3619e41d129de11b814db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d43341fa3826856a21d3619e41d129de11b814db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1482cf5ded3998fa8edb01999287d22594f1e4bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1482cf5ded3998fa8edb01999287d22594f1e4bb", "html_url": "https://github.com/rust-lang/rust/commit/1482cf5ded3998fa8edb01999287d22594f1e4bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1482cf5ded3998fa8edb01999287d22594f1e4bb/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "html_url": "https://github.com/rust-lang/rust/commit/5a8a30f45bed02a33b2e0e11f0d07cda2f569533"}], "stats": {"total": 91, "additions": 57, "deletions": 34}, "files": [{"sha": "08a05d1d8a8870b052a3994153257d2466cb2674", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1482cf5ded3998fa8edb01999287d22594f1e4bb/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1482cf5ded3998fa8edb01999287d22594f1e4bb/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=1482cf5ded3998fa8edb01999287d22594f1e4bb", "patch": "@@ -10,28 +10,35 @@\n \n //! Base64 binary-to-text encoding\n \n+/// Available encoding character sets\n+pub enum CharacterSet {\n+    /// The standard character set (uses '+' and '/')\n+    Standard,\n+    /// The URL safe character set (uses '-' and '_')\n+    UrlSafe\n+}\n+\n /// Contains configuration parameters for to_base64\n pub struct Config {\n-    /// True to use the url-safe encoding format ('-' and '_'), false to use\n-    /// the standard encoding format ('+' and '/')\n-    pub url_safe: bool,\n+    /// Character set to use\n+    char_set: CharacterSet,\n     /// True to pad output with '=' characters\n-    pub pad: bool,\n+    pad: bool,\n     /// Some(len) to wrap lines at len, None to disable line wrapping\n-    pub line_length: Option<uint>\n+    line_length: Option<uint>\n }\n \n /// Configuration for RFC 4648 standard base64 encoding\n pub static standard: Config =\n-    Config {url_safe: false, pad: true, line_length: None};\n+    Config {char_set: Standard, pad: true, line_length: None};\n \n /// Configuration for RFC 4648 base64url encoding\n pub static url_safe: Config =\n-    Config {url_safe: true, pad: false, line_length: None};\n+    Config {char_set: UrlSafe, pad: false, line_length: None};\n \n /// Configuration for RFC 2045 MIME base64 encoding\n pub static mime: Config =\n-    Config {url_safe: false, pad: true, line_length: Some(76)};\n+    Config {char_set: Standard, pad: true, line_length: Some(76)};\n \n static STANDARD_CHARS: [char, ..64] = [\n     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n@@ -63,7 +70,8 @@ impl<'self> ToBase64 for &'self [u8] {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * use std::base64::{ToBase64, standard};\n+     * extern mod extra;\n+     * use extra::base64::{ToBase64, standard};\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64(standard);\n@@ -72,9 +80,9 @@ impl<'self> ToBase64 for &'self [u8] {\n      * ~~~\n      */\n     fn to_base64(&self, config: Config) -> ~str {\n-        let chars = match config.url_safe {\n-            true => URLSAFE_CHARS,\n-            false => STANDARD_CHARS\n+        let chars = match config.char_set {\n+            Standard => STANDARD_CHARS,\n+            UrlSafe => URLSAFE_CHARS\n         };\n \n         let mut s = ~\"\";\n@@ -151,7 +159,8 @@ impl<'self> ToBase64 for &'self str {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * use std::base64::{ToBase64, standard};\n+     * extern mod extra;\n+     * use extra::base64::{ToBase64, standard};\n      *\n      * fn main () {\n      *     let str = \"Hello, World\".to_base64(standard);\n@@ -169,7 +178,7 @@ impl<'self> ToBase64 for &'self str {\n pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n-    fn from_base64(&self) -> ~[u8];\n+    fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n impl<'self> FromBase64 for &'self [u8] {\n@@ -180,7 +189,8 @@ impl<'self> FromBase64 for &'self [u8] {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * use std::base64::{ToBase64, FromBase64, standard};\n+     * extern mod extra;\n+     * use extra::base64::{ToBase64, FromBase64, standard};\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64(standard);\n@@ -190,7 +200,7 @@ impl<'self> FromBase64 for &'self [u8] {\n      * }\n      * ~~~\n      */\n-    fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> Result<~[u8], ~str> {\n         let mut r = ~[];\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n@@ -208,7 +218,7 @@ impl<'self> FromBase64 for &'self [u8] {\n                 '/'|'_'   => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '='       => break,\n-                _         => fail!(\"Invalid Base64 character\")\n+                _         => return Err(~\"Invalid Base64 character\")\n             }\n \n             buf <<= 6;\n@@ -222,7 +232,7 @@ impl<'self> FromBase64 for &'self [u8] {\n         }\n \n         if !it.all(|&byte| {byte as char == '='}) {\n-            fail!(\"Invalid Base64 character\");\n+            return Err(~\"Invalid Base64 character\");\n         }\n \n         match modulus {\n@@ -234,10 +244,10 @@ impl<'self> FromBase64 for &'self [u8] {\n                 r.push((buf >> 8 ) as u8);\n             }\n             0 => (),\n-            _ => fail!(\"Invalid Base64 length\")\n+            _ => return Err(~\"Invalid Base64 length\")\n         }\n \n-        r\n+        Ok(r)\n     }\n }\n \n@@ -255,7 +265,8 @@ impl<'self> FromBase64 for &'self str {\n      * This converts a string literal to base64 and back.\n      *\n      * ~~~ {.rust}\n-     * use std::base64::{ToBase64, FromBase64, standard};\n+     * extern mod extra;\n+     * use extra::base64::{ToBase64, FromBase64, standard};\n      * use std::str;\n      *\n      * fn main () {\n@@ -268,7 +279,7 @@ impl<'self> FromBase64 for &'self str {\n      * }\n      * ~~~\n      */\n-    fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> Result<~[u8], ~str> {\n         self.as_bytes().from_base64()\n     }\n }\n@@ -306,36 +317,48 @@ fn test_to_base64_url_safe() {\n \n #[test]\n fn test_from_base64_basic() {\n-    assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n-    assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n-    assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n-    assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+    assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n+    assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n+    assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n }\n \n #[test]\n fn test_from_base64_newlines() {\n-    assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n+        \"foobar\".as_bytes().to_owned());\n }\n \n #[test]\n fn test_from_base64_urlsafe() {\n-    assert_eq!(\"-_8\".from_base64(), \"+/8=\".from_base64());\n+    assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n+}\n+\n+#[test]\n+fn test_from_base64_invalid_char() {\n+    assert!(\"Zm$=\".from_base64().is_err())\n+    assert!(\"Zg==$\".from_base64().is_err());\n+}\n+\n+#[test]\n+fn test_from_base64_invalid_padding() {\n+    assert!(\"Z===\".from_base64().is_err());\n }\n \n #[test]\n fn test_base64_random() {\n-    use std::rand::random;\n+    use std::rand::{task_rng, random, RngUtil};\n     use std::vec;\n \n     for 1000.times {\n         let v: ~[u8] = do vec::build |push| {\n-            for 100.times {\n+            for task_rng().gen_uint_range(1, 100).times {\n                 push(random());\n             }\n         };\n-        assert_eq!(v.to_base64(standard).from_base64(), v);\n+        assert_eq!(v.to_base64(standard).from_base64().get(), v);\n     }\n }"}]}