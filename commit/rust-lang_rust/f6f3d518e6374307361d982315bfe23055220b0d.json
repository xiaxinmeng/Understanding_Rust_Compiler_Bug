{"sha": "f6f3d518e6374307361d982315bfe23055220b0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZjNkNTE4ZTYzNzQzMDczNjFkOTgyMzE1YmZlMjMwNTUyMjBiMGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-01T05:52:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-01T05:54:16Z"}, "message": "rustdoc: Split the pruning of undocumented branches into two passes\n\nprune_undoc_details_pass strips arguments and return values that are\nundocumented. prune_undoc_items_pass prunes entire items.", "tree": {"sha": "5b067a55556b2998e2e8281afb029708d7fffed9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b067a55556b2998e2e8281afb029708d7fffed9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f3d518e6374307361d982315bfe23055220b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f3d518e6374307361d982315bfe23055220b0d", "html_url": "https://github.com/rust-lang/rust/commit/f6f3d518e6374307361d982315bfe23055220b0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f3d518e6374307361d982315bfe23055220b0d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e204aa281d093bd7de4214c45375949d197eb2ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e204aa281d093bd7de4214c45375949d197eb2ab", "html_url": "https://github.com/rust-lang/rust/commit/e204aa281d093bd7de4214c45375949d197eb2ab"}], "stats": {"total": 291, "additions": 187, "deletions": 104}, "files": [{"sha": "0dd66ffcdd86bfd2f90fb4592fb1a2ec9f97c272", "filename": "src/rustdoc/prune_undoc_details_pass.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_details_pass.rs?ref=f6f3d518e6374307361d982315bfe23055220b0d", "patch": "@@ -0,0 +1,162 @@\n+#[doc = \"Prunes args, retvals of the document tree that \\\n+         contain no documentation\"];\n+\n+export mk_pass;\n+\n+fn mk_pass() -> pass {\n+    run\n+}\n+\n+fn run(\n+    _srv: astsrv::srv,\n+    doc: doc::cratedoc\n+) -> doc::cratedoc {\n+    let fold = fold::fold({\n+        fold_fn: fold_fn,\n+        fold_res: fold_res,\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n+        with *fold::default_seq_fold(())\n+    });\n+    fold.fold_crate(fold, doc)\n+}\n+\n+fn fold_fn(\n+    fold: fold::fold<()>,\n+    doc: doc::fndoc\n+) -> doc::fndoc {\n+    let doc = fold::default_seq_fold_fn(fold, doc);\n+\n+    {\n+        args: prune_args(doc.args),\n+        return: prune_return(doc.return)\n+        with doc\n+    }\n+}\n+\n+fn prune_args(docs: [doc::argdoc]) -> [doc::argdoc] {\n+    vec::filter_map(docs) {|doc|\n+        if option::is_some(doc.desc) {\n+            some(doc)\n+        } else {\n+            none\n+        }\n+    }\n+}\n+\n+fn prune_return(doc: doc::retdoc) -> doc::retdoc {\n+    {\n+        ty: if option::is_some(doc.desc) {\n+            doc.ty\n+        } else {\n+            none\n+        }\n+        with doc\n+    }\n+}\n+\n+#[test]\n+fn should_elide_undocumented_arguments() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n+    assert vec::is_empty(doc.topmod.fns()[0].args);\n+}\n+\n+#[test]\n+fn should_elide_undocumented_return_values() {\n+    let source = \"#[doc = \\\"fonz\\\"] fn a() -> int { }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = tystr_pass::mk_pass()(srv, doc);\n+    let doc = attr_pass::mk_pass()(srv, doc);\n+    let doc = run(srv, doc);\n+    assert doc.topmod.fns()[0].return.ty == none;\n+}\n+\n+fn fold_res(\n+    fold: fold::fold<()>,\n+    doc: doc::resdoc\n+) -> doc::resdoc {\n+    let doc = fold::default_seq_fold_res(fold, doc);\n+\n+    {\n+        args: prune_args(doc.args)\n+        with doc\n+    }\n+}\n+\n+#[test]\n+fn should_elide_undocumented_resource_args() {\n+    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n+                            resource r(a: bool) { }\");\n+    assert vec::is_empty(doc.topmod.resources()[0].args);\n+}\n+\n+fn fold_iface(\n+    fold: fold::fold<()>,\n+    doc: doc::ifacedoc\n+) -> doc::ifacedoc {\n+    let doc = fold::default_seq_fold_iface(fold, doc);\n+\n+    {\n+        methods: prune_methods(doc.methods)\n+        with doc\n+    }\n+}\n+\n+fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n+    vec::map(docs) {|doc|\n+        {\n+            args: prune_args(doc.args),\n+            return: prune_return(doc.return)\n+            with doc\n+        }\n+    }\n+}\n+\n+#[test]\n+fn should_elide_undocumented_iface_method_args() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n+    assert vec::is_empty(doc.topmod.ifaces()[0].methods[0].args);\n+}\n+\n+#[test]\n+fn should_elide_undocumented_iface_method_return_values() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\");\n+    assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n+}\n+\n+fn fold_impl(\n+    fold: fold::fold<()>,\n+    doc: doc::impldoc\n+) -> doc::impldoc {\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+\n+    {\n+        methods: prune_methods(doc.methods)\n+        with doc\n+    }\n+}\n+\n+#[test]\n+fn should_elide_undocumented_impl_method_args() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n+    assert vec::is_empty(doc.topmod.impls()[0].methods[0].args);\n+}\n+\n+#[test]\n+fn should_elide_undocumented_impl_method_return_values() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"hey\\\"] impl i for int { fn a() -> int { } }\");\n+    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}"}, {"sha": "3fa3298bdc524318d15e3f070ef74f958e5e0d15", "filename": "src/rustdoc/prune_undoc_items_pass.rs", "status": "renamed", "additions": 21, "deletions": 102, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_items_pass.rs?ref=f6f3d518e6374307361d982315bfe23055220b0d", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Prunes branches of the document tree that contain no documentation\"];\n+#[doc = \"Prunes items of the document tree that contain no documentation\"];\n \n export mk_pass;\n \n@@ -109,46 +109,27 @@ fn fold_fn(\n     fold: fold::fold<ctxt>,\n     doc: doc::fndoc\n ) -> doc::fndoc {\n-    let doc = {\n-        args: prune_args(doc.args),\n-        return: prune_return(doc.return)\n-        with doc\n-    };\n+    let doc = fold::default_seq_fold_fn(fold, doc);\n \n     fold.ctxt.have_docs =\n         doc.brief != none\n         || doc.desc != none\n-        || vec::is_not_empty(doc.args)\n+        || args_have_docs(doc.args)\n         || doc.return.desc != none\n         || doc.failure != none;\n     ret doc;\n }\n \n-fn prune_args(docs: [doc::argdoc]) -> [doc::argdoc] {\n-    vec::filter_map(docs) {|doc|\n-        if option::is_some(doc.desc) {\n-            some(doc)\n-        } else {\n-            none\n-        }\n-    }\n-}\n-\n-fn prune_return(doc: doc::retdoc) -> doc::retdoc {\n-    {\n-        ty: if option::is_some(doc.desc) {\n-            doc.ty\n-        } else {\n-            none\n-        }\n-        with doc\n+fn args_have_docs(docs: [doc::argdoc]) -> bool {\n+    vec::foldl(false, docs) {|accum, doc|\n+        accum || doc.desc != none\n     }\n }\n \n #[test]\n-fn should_elide_undocumented_arguments() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n-    assert vec::is_empty(doc.topmod.fns()[0].args);\n+fn should_elide_fns_with_undocumented_arguments() {\n+    let doc = test::mk_doc(\"fn a(a: int) { }\");\n+    assert vec::is_empty(doc.topmod.fns());\n }\n \n #[test]\n@@ -157,17 +138,6 @@ fn should_not_elide_fns_with_documented_arguments() {\n     assert vec::is_not_empty(doc.topmod.fns());\n }\n \n-#[test]\n-fn should_elide_undocumented_return_values() {\n-    let source = \"#[doc = \\\"fonz\\\"] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = tystr_pass::mk_pass()(srv, doc);\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n-    assert doc.topmod.fns()[0].return.ty == none;\n-}\n-\n #[test]\n fn should_not_elide_fns_with_documented_failure_conditions() {\n     let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n@@ -252,20 +222,12 @@ fn should_not_elide_enums_with_documented_variants() {\n }\n \n fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n-    let doc = {\n-        args: vec::filter_map(doc.args) {|arg|\n-            if arg.desc != none {\n-                some(arg)\n-            } else {\n-                none\n-            }\n-        }\n-        with fold::default_seq_fold_res(fold, doc)\n-    };\n+    let doc = fold::default_seq_fold_res(fold, doc);\n+\n     fold.ctxt.have_docs =\n         doc.brief != none\n         || doc.desc != none\n-        || vec::is_not_empty(doc.args);\n+        || args_have_docs(doc.args);\n     ret doc;\n }\n \n@@ -275,13 +237,6 @@ fn should_elide_undocumented_resources() {\n     assert vec::is_empty(doc.topmod.resources());\n }\n \n-#[test]\n-fn should_elide_undocumented_resource_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n-                            resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.topmod.resources()[0].args);\n-}\n-\n #[test]\n fn should_not_elide_resources_with_documented_args() {\n     let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n@@ -294,33 +249,20 @@ fn fold_iface(\n     doc: doc::ifacedoc\n ) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n-    let doc = {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    };\n+\n     fold.ctxt.have_docs =\n         doc.brief != none\n         || doc.desc != none\n         || methods_have_docs(doc.methods);\n     ret doc;\n }\n \n-fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n-    vec::map(docs) {|doc|\n-        {\n-            args: prune_args(doc.args),\n-            return: prune_return(doc.return)\n-            with doc\n-        }\n-    }\n-}\n-\n fn methods_have_docs(docs: [doc::methoddoc]) -> bool {\n     vec::foldl(false, docs) {|accum, doc|\n         accum\n             || doc.brief != none\n             || doc.desc != none\n-            || vec::is_not_empty(doc.args)\n+            || args_have_docs(doc.args)\n             || doc.return.desc != none\n             || doc.failure != none\n     }\n@@ -338,6 +280,12 @@ fn should_not_elide_documented_ifaces() {\n     assert vec::is_not_empty(doc.topmod.ifaces());\n }\n \n+#[test]\n+fn should_elide_ifaces_with_undocumented_args() {\n+    let doc = test::mk_doc(\"iface i { fn a(b: bool); }\");\n+    assert vec::is_empty(doc.topmod.ifaces());\n+}\n+\n #[test]\n fn should_not_elide_ifaces_with_documented_methods() {\n     let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n@@ -350,27 +298,12 @@ fn should_not_elide_undocumented_iface_methods() {\n     assert vec::is_not_empty(doc.topmod.ifaces()[0].methods);\n }\n \n-#[test]\n-fn should_elide_undocumented_iface_method_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_empty(doc.topmod.ifaces()[0].methods[0].args);\n-}\n-\n-#[test]\n-fn should_elide_undocumented_iface_method_return_values() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\");\n-    assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n-}\n-\n fn fold_impl(\n     fold: fold::fold<ctxt>,\n     doc: doc::impldoc\n ) -> doc::impldoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n-    let doc = {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    };\n+\n     fold.ctxt.have_docs =\n         doc.brief != none\n         || doc.desc != none\n@@ -402,20 +335,6 @@ fn should_not_elide_undocumented_impl_methods() {\n     assert vec::is_not_empty(doc.topmod.impls()[0].methods);\n }\n \n-#[test]\n-fn should_elide_undocumented_impl_method_args() {\n-    let doc = test::mk_doc(\n-        \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n-    assert vec::is_empty(doc.topmod.impls()[0].methods[0].args);\n-}\n-\n-#[test]\n-fn should_elide_undocumented_impl_method_return_values() {\n-    let doc = test::mk_doc(\n-        \"#[doc = \\\"hey\\\"] impl i for int { fn a() -> int { } }\");\n-    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n-}\n-\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::cratedoc {", "previous_filename": "src/rustdoc/prune_undoc_pass.rs"}, {"sha": "a86692373687c7c214a9f6ba6ada00c6e0b2f5d1", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=f6f3d518e6374307361d982315bfe23055220b0d", "patch": "@@ -21,7 +21,8 @@ mod fold;\n mod path_pass;\n mod attr_pass;\n mod tystr_pass;\n-mod prune_undoc_pass;\n+mod prune_undoc_details_pass;\n+mod prune_undoc_items_pass;\n mod prune_unexported_pass;\n mod desc_to_brief_pass;\n mod desc_pass;"}, {"sha": "e117222aedf33b9fde6554874d928c1f9da0924f", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f3d518e6374307361d982315bfe23055220b0d/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=f6f3d518e6374307361d982315bfe23055220b0d", "patch": "@@ -100,8 +100,9 @@ fn run(source_file: str) {\n         tystr_pass::mk_pass(),\n         path_pass::mk_pass(),\n         attr_pass::mk_pass(),\n+        prune_undoc_details_pass::mk_pass(),\n         // FIXME: This pass should be optional\n-        prune_undoc_pass::mk_pass(),\n+        // prune_undoc_items_pass::mk_pass(),\n         desc_to_brief_pass::mk_pass(),\n         trim_pass::mk_pass(),\n         unindent_pass::mk_pass(),"}]}