{"sha": "57509709b4ecc31b04b765bd07cd5fe672667e43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTA5NzA5YjRlY2MzMWIwNGI3NjViZDA3Y2Q1ZmU2NzI2NjdlNDM=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-05-09T11:05:17Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-05-09T11:05:17Z"}, "message": "Make staged versions of the functions that use uninit", "tree": {"sha": "06fe9f2223bc168a5b862630f02b502d8d77a0f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06fe9f2223bc168a5b862630f02b502d8d77a0f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57509709b4ecc31b04b765bd07cd5fe672667e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57509709b4ecc31b04b765bd07cd5fe672667e43", "html_url": "https://github.com/rust-lang/rust/commit/57509709b4ecc31b04b765bd07cd5fe672667e43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57509709b4ecc31b04b765bd07cd5fe672667e43/comments", "author": null, "committer": null, "parents": [{"sha": "f5ab112e6b083ab20fdcf9e2fff7dde4a85940b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ab112e6b083ab20fdcf9e2fff7dde4a85940b0", "html_url": "https://github.com/rust-lang/rust/commit/f5ab112e6b083ab20fdcf9e2fff7dde4a85940b0"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "7451353458e28b776de06501421106c3ced93f20", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=57509709b4ecc31b04b765bd07cd5fe672667e43", "patch": "@@ -24,6 +24,7 @@ pub mod rusti {\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n+#[cfg(not(stage0))]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = unstable::intrinsics::uninit();\n     {\n@@ -36,6 +37,19 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     dest\n }\n \n+#[cfg(stage0)]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    let mut dest: U = unstable::intrinsics::init();\n+    {\n+        let dest_ptr: *mut u8 = rusti::transmute(&mut dest);\n+        let src_ptr: *u8 = rusti::transmute(src);\n+        unstable::intrinsics::memmove64(dest_ptr,\n+                                        src_ptr,\n+                                        sys::size_of::<U>() as u64);\n+    }\n+    dest\n+}\n+\n /**\n  * Move a thing into the void\n  *"}, {"sha": "137a573fb790de0f37aa911db4a7a665a2946951", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=57509709b4ecc31b04b765bd07cd5fe672667e43", "patch": "@@ -584,6 +584,7 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n }\n \n /// Remove the last element from a vector and return it\n+#[cfg(not(stage0))]\n pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n     if ln == 0 {\n@@ -598,6 +599,21 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n     }\n }\n \n+#[cfg(stage0)]\n+pub fn pop<T>(v: &mut ~[T]) -> T {\n+    let ln = v.len();\n+    if ln == 0 {\n+        fail!(~\"sorry, cannot vec::pop an empty vector\")\n+    }\n+    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n+    unsafe {\n+        let mut val = intrinsics::init();\n+        val <-> *valptr;\n+        raw::set_len(v, ln - 1u);\n+        val\n+    }\n+}\n+\n /**\n  * Remove an element from anywhere in the vector and return it, replacing it\n  * with the last element. This does not preserve ordering, but is O(1).\n@@ -659,6 +675,7 @@ pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n }\n \n #[inline(always)]\n+#[cfg(not(stage0))]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -674,7 +691,25 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     }\n }\n \n+#[inline(always)]\n+#[cfg(stage0)]\n+pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n+    let new_len = v.len() + rhs.len();\n+    reserve(&mut *v, new_len);\n+    unsafe {\n+        do as_mut_buf(rhs) |p, len| {\n+            for uint::range(0, len) |i| {\n+                let mut x = intrinsics::init();\n+                x <-> *ptr::mut_offset(p, i);\n+                push(&mut *v, x);\n+            }\n+        }\n+        raw::set_len(&mut rhs, 0);\n+    }\n+}\n+\n /// Shorten a vector, dropping excess elements.\n+#[cfg(not(stage0))]\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n         assert!(newlen <= oldlen);\n@@ -689,10 +724,27 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     unsafe { raw::set_len(&mut *v, newlen); }\n }\n \n+/// Shorten a vector, dropping excess elements.\n+#[cfg(stage0)]\n+pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n+    do as_mut_buf(*v) |p, oldlen| {\n+        assert!(newlen <= oldlen);\n+        unsafe {\n+            // This loop is optimized out for non-drop types.\n+            for uint::range(newlen, oldlen) |i| {\n+                let mut dropped = intrinsics::init();\n+                dropped <-> *ptr::mut_offset(p, i);\n+            }\n+        }\n+    }\n+    unsafe { raw::set_len(&mut *v, newlen); }\n+}\n+\n /**\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n+#[cfg(not(stage0))]\n pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     unsafe {\n         if v.len() < 1 { return; }\n@@ -726,6 +778,44 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     }\n }\n \n+/**\n+ * Remove consecutive repeated elements from a vector; if the vector is\n+ * sorted, this removes all duplicates.\n+ */\n+#[cfg(stage0)]\n+pub fn dedup<T:Eq>(v: &mut ~[T]) {\n+    unsafe {\n+        if v.len() < 1 { return; }\n+        let mut last_written = 0, next_to_read = 1;\n+        do as_const_buf(*v) |p, ln| {\n+            // We have a mutable reference to v, so we can make arbitrary\n+            // changes. (cf. push and pop)\n+            let p = p as *mut T;\n+            // last_written < next_to_read <= ln\n+            while next_to_read < ln {\n+                // last_written < next_to_read < ln\n+                if *ptr::mut_offset(p, next_to_read) ==\n+                    *ptr::mut_offset(p, last_written) {\n+                    let mut dropped = intrinsics::init();\n+                    dropped <-> *ptr::mut_offset(p, next_to_read);\n+                } else {\n+                    last_written += 1;\n+                    // last_written <= next_to_read < ln\n+                    if next_to_read != last_written {\n+                        *ptr::mut_offset(p, last_written) <->\n+                            *ptr::mut_offset(p, next_to_read);\n+                    }\n+                }\n+                // last_written <= next_to_read < ln\n+                next_to_read += 1;\n+                // last_written < next_to_read <= ln\n+            }\n+        }\n+        // last_written < next_to_read == ln\n+        raw::set_len(v, last_written + 1);\n+    }\n+}\n+\n \n // Appending\n #[inline(always)]"}, {"sha": "b5dd9e456a107ea9d3acfcf08e3c23cef34d7a34", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=57509709b4ecc31b04b765bd07cd5fe672667e43", "patch": "@@ -132,6 +132,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n     // vector over the junk element.  This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n \n+    #[cfg(not(stage0))]\n     priv fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n             let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n@@ -151,6 +152,28 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n+    #[cfg(stage0)]\n+    priv fn siftup(&mut self, start: uint, mut pos: uint) {\n+        unsafe {\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n+\n+            while pos > start {\n+                let parent = (pos - 1) >> 1;\n+                if new > self.data[parent] {\n+                    let mut x = rusti::init();\n+                    x <-> self.data[parent];\n+                    rusti::move_val_init(&mut self.data[pos], x);\n+                    pos = parent;\n+                    loop\n+                }\n+                break\n+            }\n+            rusti::move_val_init(&mut self.data[pos], new);\n+        }\n+    }\n+\n+\n+    #[cfg(not(stage0))]\n     priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n@@ -174,6 +197,30 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n+    #[cfg(stage0)]\n+    priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n+        unsafe {\n+            let start = pos;\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n+\n+            let mut child = 2 * pos + 1;\n+            while child < end {\n+                let right = child + 1;\n+                if right < end && !(self.data[child] > self.data[right]) {\n+                    child = right;\n+                }\n+                let mut x = rusti::init();\n+                x <-> self.data[child];\n+                rusti::move_val_init(&mut self.data[pos], x);\n+                pos = child;\n+                child = 2 * pos + 1;\n+            }\n+\n+            rusti::move_val_init(&mut self.data[pos], new);\n+            self.siftup(start, pos);\n+        }\n+    }\n+\n     priv fn siftdown(&mut self, pos: uint) {\n         let len = self.len();\n         self.siftdown_range(pos, len);"}, {"sha": "da90716316b2e862bfb67ad0555923e12a14c3a2", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57509709b4ecc31b04b765bd07cd5fe672667e43/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=57509709b4ecc31b04b765bd07cd5fe672667e43", "patch": "@@ -46,6 +46,7 @@ pub impl<T: Owned> Rc<T> {\n }\n \n #[unsafe_destructor]\n+#[cfg(not(stage0))]\n impl<T: Owned> Drop for Rc<T> {\n     fn finalize(&self) {\n         unsafe {\n@@ -59,6 +60,22 @@ impl<T: Owned> Drop for Rc<T> {\n     }\n }\n \n+#[unsafe_destructor]\n+#[cfg(stage0)]\n+impl<T: Owned> Drop for Rc<T> {\n+    fn finalize(&self) {\n+        unsafe {\n+            (*self.ptr).count -= 1;\n+            if (*self.ptr).count == 0 {\n+                let mut x = intrinsics::init();\n+                x <-> *self.ptr;\n+                free(self.ptr as *c_void)\n+            }\n+        }\n+    }\n+}\n+\n+\n impl<T: Owned> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n@@ -154,6 +171,7 @@ pub impl<T: Owned> RcMut<T> {\n }\n \n #[unsafe_destructor]\n+#[cfg(not(stage0))]\n impl<T: Owned> Drop for RcMut<T> {\n     fn finalize(&self) {\n         unsafe {\n@@ -167,6 +185,21 @@ impl<T: Owned> Drop for RcMut<T> {\n     }\n }\n \n+#[unsafe_destructor]\n+#[cfg(stage0)]\n+impl<T: Owned> Drop for RcMut<T> {\n+    fn finalize(&self) {\n+        unsafe {\n+            (*self.ptr).count -= 1;\n+            if (*self.ptr).count == 0 {\n+                let mut x = rusti::init();\n+                x <-> *self.ptr;\n+                free(self.ptr as *c_void)\n+            }\n+        }\n+    }\n+}\n+\n impl<T: Owned> Clone for RcMut<T> {\n     #[inline]\n     fn clone(&self) -> RcMut<T> {"}]}