{"sha": "40963c47f833f1c9a44861a5f7eb762c54257254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwOTYzYzQ3ZjgzM2YxYzlhNDQ4NjFhNWY3ZWI3NjJjNTQyNTcyNTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-25T06:49:17Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-25T06:49:17Z"}, "message": "save-analysis: remove dump spans stuff", "tree": {"sha": "4c10a8831b5f70389c18203bf61807dabf7c3847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c10a8831b5f70389c18203bf61807dabf7c3847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40963c47f833f1c9a44861a5f7eb762c54257254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40963c47f833f1c9a44861a5f7eb762c54257254", "html_url": "https://github.com/rust-lang/rust/commit/40963c47f833f1c9a44861a5f7eb762c54257254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40963c47f833f1c9a44861a5f7eb762c54257254/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253b7c1e1a919a6b722c29a04241d6f08ff8c79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/253b7c1e1a919a6b722c29a04241d6f08ff8c79a", "html_url": "https://github.com/rust-lang/rust/commit/253b7c1e1a919a6b722c29a04241d6f08ff8c79a"}], "stats": {"total": 311, "additions": 94, "deletions": 217}, "files": [{"sha": "69de5365c1409a088390dc6b2dcd6180e46fc1f7", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 23, "deletions": 146, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=40963c47f833f1c9a44861a5f7eb762c54257254", "patch": "@@ -19,13 +19,12 @@ use super::span_utils::SpanUtils;\n \n pub struct CsvDumper<'tcx, 'b, W: 'b> {\n     output: &'b mut W,\n-    dump_spans: bool,\n     span: SpanUtils<'tcx>\n }\n \n impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n     pub fn new(writer: &'b mut W, span: SpanUtils<'a>) -> CsvDumper<'a, 'b, W> {\n-        CsvDumper { output: writer, dump_spans: false, span: span }\n+        CsvDumper { output: writer, span: span }\n     }\n \n     fn record(&mut self, kind: &str, span: Span, values: String) {\n@@ -40,15 +39,6 @@ impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n             error!(\"Error writing output '{}'\", info);\n         }\n     }\n-\n-    pub fn dump_span(&mut self, kind: &str, span: Span) {\n-        assert!(self.dump_spans);\n-        let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n-                             kind,\n-                             self.span.extent_str(span),\n-                             escape(self.span.snippet(span)));\n-        self.record_raw(&result);\n-    }\n }\n \n impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n@@ -78,12 +68,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record_raw(\"end_external_crates\\n\");\n     }\n \n-    fn enum_data(&mut self, span: Span, data: EnumData) {\n-        if self.dump_spans {\n-            self.dump_span(\"enum\", span);\n-            return;\n-        }\n-\n+    fn enum_data(&mut self, data: EnumData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -96,12 +81,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"enum\", data.span, values);\n     }\n \n-    fn extern_crate(&mut self, span: Span, data: ExternCrateData) {\n-        if self.dump_spans {\n-            self.dump_span(\"extern_crate\", span);\n-            return;\n-        }\n-\n+    fn extern_crate(&mut self, data: ExternCrateData) {\n         let id = data.id.to_string();\n         let crate_num = data.crate_num.to_string();\n         let scope = data.scope.to_string();\n@@ -116,12 +96,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"extern_crate\", data.span, values);\n     }\n \n-    fn impl_data(&mut self, span: Span, data: ImplData) {\n-        if self.dump_spans {\n-            self.dump_span(\"impl\", span);\n-            return;\n-        }\n-\n+    fn impl_data(&mut self, data: ImplData) {\n         let self_ref = data.self_ref.unwrap_or(null_def_id());\n         let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n \n@@ -144,10 +119,6 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn inheritance(&mut self, data: InheritanceData) {\n-       if self.dump_spans {\n-           return;\n-       }\n-\n        let base_id = data.base_id.index.as_usize().to_string();\n        let base_crate = data.base_id.krate.to_string();\n        let deriv_id = data.deriv_id.to_string();\n@@ -162,12 +133,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n        self.record(\"inheritance\", data.span, values);\n     }\n \n-    fn function(&mut self, span: Span, data: FunctionData) {\n-        if self.dump_spans {\n-            self.dump_span(\"function\", span);\n-            return;\n-        }\n-\n+    fn function(&mut self, data: FunctionData) {\n         let (decl_id, decl_crate) = match data.declaration {\n             Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n             None => (String::new(), String::new())\n@@ -186,12 +152,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"function\", data.span, values);\n     }\n \n-    fn function_ref(&mut self, span: Span, data: FunctionRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"fn_ref\", span);\n-            return;\n-        }\n-\n+    fn function_ref(&mut self, data: FunctionRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let scope = data.scope.to_string();\n@@ -205,12 +166,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"fn_ref\", data.span, values);\n     }\n \n-    fn function_call(&mut self, span: Span, data: FunctionCallData) {\n-        if self.dump_spans {\n-            self.dump_span(\"fn_call\", span);\n-            return;\n-        }\n-\n+    fn function_call(&mut self, data: FunctionCallData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let qualname = String::new();\n@@ -225,12 +181,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"fn_call\", data.span, values);\n     }\n \n-    fn method(&mut self, span: Span, data: MethodData) {\n-        if self.dump_spans {\n-            self.dump_span(\"method_decl\", span);\n-            return;\n-        }\n-\n+    fn method(&mut self, data: MethodData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -239,15 +190,10 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n             (\"scopeid\", &scope)\n         ]);\n \n-        self.record(\"method_decl\", span, values);\n+        self.record(\"method_decl\", data.span, values);\n     }\n \n-    fn method_call(&mut self, span: Span, data: MethodCallData) {\n-        if self.dump_spans {\n-            self.dump_span(\"method_call\", span);\n-            return;\n-        }\n-\n+    fn method_call(&mut self, data: MethodCallData) {\n         let (dcn, dck) = match data.decl_id {\n             Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n             None => (String::new(), String::new()),\n@@ -269,12 +215,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"method_call\", data.span, values);\n     }\n \n-    fn macro_data(&mut self, span: Span, data: MacroData) {\n-        if self.dump_spans {\n-            self.dump_span(\"macro\", span);\n-            return;\n-        }\n-\n+    fn macro_data(&mut self, data: MacroData) {\n         let values = make_values_str(&[\n             (\"name\", &data.name),\n             (\"qualname\", &data.qualname)\n@@ -283,12 +224,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"macro\", data.span, values);\n     }\n \n-    fn macro_use(&mut self, span: Span, data: MacroUseData) {\n-        if self.dump_spans {\n-            self.dump_span(\"macro_use\", span);\n-            return;\n-        }\n-\n+    fn macro_use(&mut self, data: MacroUseData) {\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"callee_name\", &data.name),\n@@ -300,10 +236,6 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn mod_data(&mut self, data: ModData) {\n-        if self.dump_spans {\n-            return;\n-        }\n-\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -316,12 +248,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"module\", data.span, values);\n     }\n \n-    fn mod_ref(&mut self, span: Span, data: ModRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"mod_ref\", span);\n-            return;\n-        }\n-\n+    fn mod_ref(&mut self, data: ModRefData) {\n         let (ref_id, ref_crate) = match data.ref_id {\n             Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n             None => (0.to_string(), 0.to_string())\n@@ -338,12 +265,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"mod_ref\", data.span, values);\n     }\n \n-    fn struct_data(&mut self, span: Span, data: StructData) {\n-        if self.dump_spans {\n-            self.dump_span(\"struct\", span);\n-            return;\n-        }\n-\n+    fn struct_data(&mut self, data: StructData) {\n         let id = data.id.to_string();\n         let ctor_id = data.ctor_id.to_string();\n         let scope = data.scope.to_string();\n@@ -358,12 +280,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"struct\", data.span, values);\n     }\n \n-    fn struct_variant(&mut self, span: Span, data: StructVariantData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variant_struct\", span);\n-            return;\n-        }\n-\n+    fn struct_variant(&mut self, data: StructVariantData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -378,12 +295,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variant_struct\", data.span, values);\n     }\n \n-    fn trait_data(&mut self, span: Span, data: TraitData) {\n-        if self.dump_spans {\n-            self.dump_span(\"trait\", span);\n-            return;\n-        }\n-\n+    fn trait_data(&mut self, data: TraitData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -396,12 +308,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"trait\", data.span, values);\n     }\n \n-    fn tuple_variant(&mut self, span: Span, data: TupleVariantData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variant\", span);\n-            return;\n-        }\n-\n+    fn tuple_variant(&mut self, data: TupleVariantData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -416,12 +323,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variant\", data.span, values);\n     }\n \n-    fn type_ref(&mut self, span: Span, data: TypeRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"type_ref\", span);\n-            return;\n-        }\n-\n+    fn type_ref(&mut self, data: TypeRefData) {\n         let (ref_id, ref_crate) = match data.ref_id {\n             Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n             None => (0.to_string(), 0.to_string())\n@@ -438,12 +340,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"type_ref\", data.span, values);\n     }\n \n-    fn typedef(&mut self, span: Span, data: TypedefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"typedef\", span);\n-            return;\n-        }\n-\n+    fn typedef(&mut self, data: TypedefData) {\n         let id = data.id.to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n@@ -454,12 +351,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"typedef\", data.span, values);\n     }\n \n-    fn use_data(&mut self, span: Span, data: UseData) {\n-        if self.dump_spans {\n-            self.dump_span(\"use_alias\", span);\n-            return;\n-        }\n-\n+    fn use_data(&mut self, data: UseData) {\n         let mod_id = data.mod_id.unwrap_or(null_def_id());\n \n         let id = data.id.to_string();\n@@ -477,12 +369,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"use_alias\", data.span, values);\n     }\n \n-    fn use_glob(&mut self, span: Span, data: UseGlobData) {\n-        if self.dump_spans {\n-            self.dump_span(\"use_glob\", span);\n-            return;\n-        }\n-\n+    fn use_glob(&mut self, data: UseGlobData) {\n         let names = data.names.join(\", \");\n \n         let id = data.id.to_string();\n@@ -496,12 +383,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"use_glob\", data.span, values);\n     }\n \n-    fn variable(&mut self, span: Span, data: VariableData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variable\", span);\n-            return;\n-        }\n-\n+    fn variable(&mut self, data: VariableData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -516,12 +398,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variable\", data.span, values);\n     }\n \n-    fn variable_ref(&mut self, span: Span, data: VariableRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"var_ref\", span);\n-            return;\n-        }\n-\n+    fn variable_ref(&mut self, data: VariableRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let scope = data.scope.to_string();"}, {"sha": "69efa74c582f321a0b071dd04df86b7dce1b5513", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=40963c47f833f1c9a44861a5f7eb762c54257254", "patch": "@@ -14,27 +14,27 @@ use super::data::*;\n \n pub trait Dump {\n     fn crate_prelude(&mut self, _: Span, _: CratePreludeData) {}\n-    fn enum_data(&mut self, _: Span, _: EnumData) {}\n-    fn extern_crate(&mut self, _: Span, _: ExternCrateData) {}\n-    fn impl_data(&mut self, _: Span, _: ImplData) {}\n-    fn inheritance(&mut self, _: InheritanceData) {}\n-    fn function(&mut self, _: Span, _: FunctionData) {}\n-    fn function_ref(&mut self, _: Span, _: FunctionRefData) {}\n-    fn function_call(&mut self, _: Span, _: FunctionCallData) {}\n-    fn method(&mut self, _: Span, _: MethodData) {}\n-    fn method_call(&mut self, _: Span, _: MethodCallData) {}\n-    fn macro_data(&mut self, _: Span, _: MacroData) {}\n-    fn macro_use(&mut self, _: Span, _: MacroUseData) {}\n-    fn mod_data(&mut self, _: ModData) {}\n-    fn mod_ref(&mut self, _: Span, _: ModRefData) {}\n-    fn struct_data(&mut self, _: Span, _: StructData) {}\n-    fn struct_variant(&mut self, _: Span, _: StructVariantData) {}\n-    fn trait_data(&mut self, _: Span, _: TraitData) {}\n-    fn tuple_variant(&mut self, _: Span, _: TupleVariantData) {}\n-    fn type_ref(&mut self, _: Span, _: TypeRefData) {}\n-    fn typedef(&mut self, _: Span, _: TypedefData) {}\n-    fn use_data(&mut self, _: Span, _: UseData) {}\n-    fn use_glob(&mut self, _: Span, _: UseGlobData) {}\n-    fn variable(&mut self, _: Span, _: VariableData) {}\n-    fn variable_ref(&mut self, _: Span, _: VariableRefData) {}\n+    fn enum_data(&mut self, EnumData) {}\n+    fn extern_crate(&mut self, ExternCrateData) {}\n+    fn impl_data(&mut self, ImplData) {}\n+    fn inheritance(&mut self, InheritanceData) {}\n+    fn function(&mut self, FunctionData) {}\n+    fn function_ref(&mut self, FunctionRefData) {}\n+    fn function_call(&mut self, FunctionCallData) {}\n+    fn method(&mut self, MethodData) {}\n+    fn method_call(&mut self, MethodCallData) {}\n+    fn macro_data(&mut self, MacroData) {}\n+    fn macro_use(&mut self, MacroUseData) {}\n+    fn mod_data(&mut self, ModData) {}\n+    fn mod_ref(&mut self, ModRefData) {}\n+    fn struct_data(&mut self, StructData) {}\n+    fn struct_variant(&mut self, StructVariantData) {}\n+    fn trait_data(&mut self, TraitData) {}\n+    fn tuple_variant(&mut self, TupleVariantData) {}\n+    fn type_ref(&mut self, TypeRefData) {}\n+    fn typedef(&mut self, TypedefData) {}\n+    fn use_data(&mut self, UseData) {}\n+    fn use_glob(&mut self, UseGlobData) {}\n+    fn variable(&mut self, VariableData) {}\n+    fn variable_ref(&mut self, VariableRefData) {}\n }"}, {"sha": "c6513a8288b0b568c802ad61f07db0556170f16a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40963c47f833f1c9a44861a5f7eb762c54257254/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=40963c47f833f1c9a44861a5f7eb762c54257254", "patch": "@@ -197,7 +197,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             } else {\n                 qualname.clone()\n             };\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n@@ -222,7 +222,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             } else {\n                 qualname.clone()\n             };\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n@@ -243,7 +243,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n-        self.dumper.type_ref(path.span, TypeRefData {\n+        self.dumper.type_ref(TypeRefData {\n             ref_id: None,\n             span: *span,\n             qualname: qualname.to_owned(),\n@@ -256,7 +256,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n         let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths {\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname.to_owned(),\n                 scope: self.cur_scope,\n@@ -298,7 +298,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match def {\n             Def::Mod(_) |\n             Def::ForeignMod(_) => {\n-                self.dumper.mod_ref(span, ModRefData {\n+                self.dumper.mod_ref(ModRefData {\n                     span: sub_span.expect(\"No span found for mod ref\"),\n                     ref_id: Some(def_id),\n                     scope: scope,\n@@ -310,7 +310,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::TyAlias(..) |\n             Def::AssociatedTy(..) |\n             Def::Trait(_) => {\n-                self.dumper.type_ref(span, TypeRefData {\n+                self.dumper.type_ref(TypeRefData {\n                     span: sub_span.expect(\"No span found for type ref\"),\n                     ref_id: Some(def_id),\n                     scope: scope,\n@@ -323,15 +323,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::Local(..) |\n             Def::Variant(..) |\n             Def::Upvar(..) => {\n-                self.dumper.variable_ref(span, VariableRefData {\n+                self.dumper.variable_ref(VariableRefData {\n                     span: sub_span.expect(\"No span found for var ref\"),\n                     ref_id: def_id,\n                     scope: scope,\n                     name: String::new()\n                 }.normalize(&self.tcx));\n             }\n             Def::Fn(..) => {\n-                self.dumper.function_ref(span, FunctionRefData {\n+                self.dumper.function_ref(FunctionRefData {\n                     span: sub_span.expect(\"No span found for fn ref\"),\n                     ref_id: def_id,\n                     scope: scope\n@@ -362,7 +362,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n                 if !self.span.filter_generated(sub_span, p.span) {\n-                    self.dumper.variable(p.span, VariableData {\n+                    self.dumper.variable(VariableData {\n                         id: id,\n                         span: sub_span.expect(\"No span found for variable\"),\n                         name: path_to_string(p),\n@@ -388,12 +388,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(span, method_data.clone().normalize(&self.tcx));\n+                    self.dumper.function(method_data.clone().normalize(&self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.method(span, MethodData {\n+                    self.dumper.method(MethodData {\n                         id: method_data.id,\n                         span: method_data.span,\n                         scope: method_data.scope,\n@@ -423,7 +423,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n-                self.dumper.type_ref(trait_ref.path.span, trait_ref_data.normalize(&self.tcx));\n+                self.dumper.type_ref(trait_ref_data.normalize(&self.tcx));\n             }\n \n             visit::walk_path(self, &trait_ref.path);\n@@ -436,7 +436,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(Some(field_data.span), field.span) {\n                 field_data.scope = normalize_node_id(&self.tcx, field_data.scope) as u32;\n                 field_data.value = String::new();\n-                self.dumper.variable(field.span, field_data.normalize(&self.tcx));\n+                self.dumper.variable(field_data.normalize(&self.tcx));\n             }\n         }\n     }\n@@ -460,7 +460,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                escape(self.span.snippet(param_ss)),\n                                id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n-                self.dumper.typedef(full_span, TypedefData {\n+                self.dumper.typedef(TypedefData {\n                     span: param_ss,\n                     id: param.id,\n                     qualname: name,\n@@ -479,7 +479,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                self.dumper.function(item.span, fn_data.clone().normalize(&self.tcx));\n+                self.dumper.function(fn_data.clone().normalize(&self.tcx));\n             }\n \n             self.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -503,7 +503,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n                 let mut var_data = var_data;\n                 var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n-                self.dumper.variable(item.span, var_data.normalize(&self.tcx));\n+                self.dumper.variable(var_data.normalize(&self.tcx));\n             }\n         }\n         self.visit_ty(&typ);\n@@ -521,7 +521,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n \n         if !self.span.filter_generated(sub_span, span) {\n-            self.dumper.variable(span, VariableData {\n+            self.dumper.variable(VariableData {\n                 span: sub_span.expect(\"No span found for variable\"),\n                 id: id,\n                 name: name.to_string(),\n@@ -546,7 +546,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.struct_data(item.span, StructData {\n+            self.dumper.struct_data(StructData {\n                 span: sub_span.expect(\"No span found for struct\"),\n                 id: item.id,\n                 ctor_id: def.id(),\n@@ -578,7 +578,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         down_cast_data!(enum_data, EnumData, item.span);\n         let normalized = enum_data.clone().normalize(&self.tcx);\n         if !self.span.filter_generated(Some(normalized.span), item.span) {\n-            self.dumper.enum_data(item.span, normalized);\n+            self.dumper.enum_data(normalized);\n         }\n \n         for variant in &enum_definition.variants {\n@@ -592,7 +592,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::VariantData::Struct(..) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.struct_variant(variant.span, StructVariantData {\n+                        self.dumper.struct_variant(StructVariantData {\n                             span: sub_span.expect(\"No span found for struct variant\"),\n                             id: variant.node.data.id(),\n                             qualname: qualname,\n@@ -605,7 +605,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 _ => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.tuple_variant(variant.span, TupleVariantData {\n+                        self.dumper.tuple_variant(TupleVariantData {\n                             span: sub_span.expect(\"No span found for tuple variant\"),\n                             id: variant.node.data.id(),\n                             name: name.to_string(),\n@@ -639,19 +639,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n-                    self.dumper.type_ref(item.span, self_ref.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(self_ref.clone().normalize(&self.tcx));\n                 }\n             }\n             if let Some(ref trait_ref_data) = impl_data.trait_ref {\n                 if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n-                    self.dumper.type_ref(item.span, trait_ref_data.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(trait_ref_data.clone().normalize(&self.tcx));\n                 }\n \n                 visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n \n             if !self.span.filter_generated(Some(impl_data.span), item.span) {\n-                self.dumper.impl_data(item.span, ImplData {\n+                self.dumper.impl_data(ImplData {\n                     id: impl_data.id,\n                     span: impl_data.span,\n                     scope: impl_data.scope,\n@@ -678,7 +678,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.trait_data(item.span, TraitData {\n+            self.dumper.trait_data(TraitData {\n                 span: sub_span.expect(\"No span found for trait\"),\n                 id: item.id,\n                 qualname: qualname.clone(),\n@@ -702,7 +702,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(id) = self.lookup_type_ref(trait_ref.ref_id) {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    self.dumper.type_ref(trait_ref.path.span, TypeRefData {\n+                    self.dumper.type_ref(TypeRefData {\n                         span: sub_span.expect(\"No span found for trait ref\"),\n                         ref_id: Some(id),\n                         scope: self.cur_scope,\n@@ -759,47 +759,47 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 if !self.span.filter_generated(Some(vrd.span), path.span) {\n                     match ref_kind {\n                         Some(recorder::TypeRef) => {\n-                            self.dumper.type_ref(path.span, TypeRefData {\n+                            self.dumper.type_ref(TypeRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::FnRef) => {\n-                            self.dumper.function_ref(path.span, FunctionRefData {\n+                            self.dumper.function_ref(FunctionRefData {\n                                 span: vrd.span,\n                                 ref_id: vrd.ref_id,\n                                 scope: vrd.scope\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::ModRef) => {\n-                            self.dumper.mod_ref(path.span, ModRefData {\n+                            self.dumper.mod_ref( ModRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::VarRef) | None\n-                            => self.dumper.variable_ref(path.span, vrd.normalize(&self.tcx))\n+                            => self.dumper.variable_ref(vrd.normalize(&self.tcx))\n                     }\n                 }\n \n             }\n             Data::TypeRefData(trd) => {\n                 if !self.span.filter_generated(Some(trd.span), path.span) {\n-                    self.dumper.type_ref(path.span, trd.normalize(&self.tcx));\n+                    self.dumper.type_ref(trd.normalize(&self.tcx));\n                 }\n             }\n             Data::MethodCallData(mcd) => {\n                 if !self.span.filter_generated(Some(mcd.span), path.span) {\n-                    self.dumper.method_call(path.span, mcd.normalize(&self.tcx));\n+                    self.dumper.method_call(mcd.normalize(&self.tcx));\n                 }\n             }\n             Data::FunctionCallData(fcd) => {\n                 if !self.span.filter_generated(Some(fcd.span), path.span) {\n-                    self.dumper.function_call(path.span, fcd.normalize(&self.tcx));\n+                    self.dumper.function_call(fcd.normalize(&self.tcx));\n                 }\n             }\n             _ => {\n@@ -841,7 +841,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n-                self.dumper.type_ref(ex.span, struct_lit_data.normalize(&self.tcx));\n+                self.dumper.type_ref(struct_lit_data.normalize(&self.tcx));\n             }\n \n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n@@ -851,7 +851,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                               .get_field_ref_data(field, variant, scope) {\n \n                     if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n-                        self.dumper.variable_ref(field.ident.span, field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n                     }\n                 }\n \n@@ -866,7 +866,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n-                self.dumper.method_call(ex.span, mcd.normalize(&self.tcx));\n+                self.dumper.method_call(mcd.normalize(&self.tcx));\n             }\n         }\n \n@@ -886,7 +886,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n                         if !self.span.filter_generated(sub_span, span) {\n-                            self.dumper.variable_ref(span, VariableRefData {\n+                            self.dumper.variable_ref(VariableRefData {\n                                 span: sub_span.expect(\"No span fund for var ref\"),\n                                 ref_id: f.did,\n                                 scope: self.cur_scope,\n@@ -922,7 +922,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n             if !self.span.filter_generated(sub_span, p.span) {\n-                self.dumper.variable(p.span, VariableData {\n+                self.dumper.variable(VariableData {\n                     span: sub_span.expect(\"No span found for variable\"),\n                     id: id,\n                     name: path_to_string(p),\n@@ -956,7 +956,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             && !data.imported {\n             self.mac_defs.insert(data.callee_span);\n             if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-                self.dumper.macro_data(data.callee_span, MacroData {\n+                self.dumper.macro_data(MacroData {\n                     span: sub_span,\n                     name: data.name.clone(),\n                     qualname: qualname.clone()\n@@ -966,7 +966,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if !self.mac_uses.contains(&data.span) {\n             self.mac_uses.insert(data.span);\n             if let Some(sub_span) = self.span.span_for_macro_use_name(data.span) {\n-                self.dumper.macro_use(data.span, MacroUseData {\n+                self.dumper.macro_use(MacroUseData {\n                     span: sub_span,\n                     name: data.name,\n                     qualname: qualname,\n@@ -1007,7 +1007,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         };\n \n                         if !self.span.filter_generated(sub_span, path.span) {\n-                            self.dumper.use_data(path.span, UseData {\n+                            self.dumper.use_data(UseData {\n                                 span: sub_span.expect(\"No span found for use\"),\n                                 id: item.id,\n                                 mod_id: mod_id,\n@@ -1031,7 +1031,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         let sub_span = self.span\n                                            .sub_span_of_token(path.span, token::BinOp(token::Star));\n                         if !self.span.filter_generated(sub_span, path.span) {\n-                            self.dumper.use_glob(path.span, UseGlobData {\n+                            self.dumper.use_glob(UseGlobData {\n                                 span: sub_span.expect(\"No span found for use glob\"),\n                                 id: item.id,\n                                 names: names,\n@@ -1073,7 +1073,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 };\n \n                 if !self.span.filter_generated(alias_span, item.span) {\n-                    self.dumper.extern_crate(item.span, ExternCrateData {\n+                    self.dumper.extern_crate(ExternCrateData {\n                         id: item.id,\n                         name: item.ident.to_string(),\n                         crate_num: cnum,\n@@ -1109,7 +1109,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {\n-                    self.dumper.typedef(item.span, TypedefData {\n+                    self.dumper.typedef(TypedefData {\n                         span: sub_span.expect(\"No span found for typedef\"),\n                         id: item.id,\n                         qualname: qualname.clone(),\n@@ -1189,7 +1189,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(id) = self.lookup_type_ref(t.id) {\n                     let sub_span = self.span.sub_span_for_type_name(t.span);\n                     if !self.span.filter_generated(sub_span, t.span) {\n-                        self.dumper.type_ref(t.span, TypeRefData {\n+                        self.dumper.type_ref(TypeRefData {\n                             span: sub_span.expect(\"No span found for type ref\"),\n                             ref_id: Some(id),\n                             scope: self.cur_scope,\n@@ -1231,7 +1231,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n                     down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n-                        self.dumper.variable_ref(ex.span, field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n                     }\n                 }\n             }\n@@ -1244,7 +1244,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                         if !self.span.filter_generated(sub_span, ex.span) {\n-                            self.dumper.variable_ref(ex.span, VariableRefData {\n+                            self.dumper.variable_ref(VariableRefData {\n                                 span: sub_span.expect(\"No span found for var ref\"),\n                                 ref_id: def.struct_variant().fields[idx.node].did,\n                                 scope: self.cur_scope,\n@@ -1334,7 +1334,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                     assert!(p.segments.len() == 1,\n                             \"qualified path for local variable def in arm\");\n                     if !self.span.filter_generated(Some(p.span), p.span) {\n-                        self.dumper.variable(p.span, VariableData {\n+                        self.dumper.variable(VariableData {\n                             span: p.span,\n                             id: id,\n                             name: path_to_string(p),"}]}