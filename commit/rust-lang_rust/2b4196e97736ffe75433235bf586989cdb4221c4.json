{"sha": "2b4196e97736ffe75433235bf586989cdb4221c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNDE5NmU5NzczNmZmZTc1NDMzMjM1YmY1ODY5ODljZGI0MjIxYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T22:31:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T22:31:14Z"}, "message": "Auto merge of #84111 - bstrie:hashfrom, r=joshtriplett\n\nStabilize `impl From<[(K, V); N]> for HashMap` (and friends)\n\nIn addition to allowing HashMap to participate in Into/From conversion, this adds the long-requested ability to use constructor-like syntax for initializing a HashMap:\n```rust\nlet map = HashMap::from([\n    (1, 2),\n    (3, 4),\n    (5, 6)\n]);\n```\nThis addition is highly motivated by existing precedence, e.g. it is already possible to similarly construct a Vec from a fixed-size array:\n```rust\nlet vec = Vec::from([1, 2, 3]);\n```\n...and it is already possible to collect a Vec of tuples into a HashMap (and vice-versa):\n```rust\nlet vec = Vec::from([(1, 2)]);\nlet map: HashMap<_, _> = vec.into_iter().collect();\nlet vec: Vec<(_, _)> = map.into_iter().collect();\n```\n...and of course it is likewise possible to collect a fixed-size array of tuples into a HashMap ([but not vice-versa just yet](https://github.com/rust-lang/rust/issues/81615)):\n```rust\nlet arr = [(1, 2)];\nlet map: HashMap<_, _> = std::array::IntoIter::new(arr).collect();\n```\nTherefore this addition seems like a no-brainer.\n\nAs for any impl, this would be insta-stable.", "tree": {"sha": "b7a143f874afb6f4348b0161495b0e75799462e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7a143f874afb6f4348b0161495b0e75799462e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b4196e97736ffe75433235bf586989cdb4221c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4196e97736ffe75433235bf586989cdb4221c4", "html_url": "https://github.com/rust-lang/rust/commit/2b4196e97736ffe75433235bf586989cdb4221c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b4196e97736ffe75433235bf586989cdb4221c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9aa28767287670df6cf823b94629122e04442c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9aa28767287670df6cf823b94629122e04442c0", "html_url": "https://github.com/rust-lang/rust/commit/d9aa28767287670df6cf823b94629122e04442c0"}, {"sha": "1b83fedda46d0162952d00f25a60c22028c1e15a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b83fedda46d0162952d00f25a60c22028c1e15a", "html_url": "https://github.com/rust-lang/rust/commit/1b83fedda46d0162952d00f25a60c22028c1e15a"}], "stats": {"total": 270, "additions": 244, "deletions": 26}, "files": [{"sha": "8a29af3fe07e605e248e3a77c48e7a1af64f3882", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -209,6 +209,14 @@ use super::SpecExtend;\n /// assert!(heap.is_empty())\n /// ```\n ///\n+/// A `BinaryHeap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BinaryHeap;\n+///\n+/// let heap = BinaryHeap::from([1, 5, 2]);\n+/// ```\n+///\n /// ## Min-heap\n ///\n /// Either `std::cmp::Reverse` or a custom `Ord` implementation can be used to\n@@ -1465,6 +1473,22 @@ impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+impl<T: Ord, const N: usize> From<[T; N]> for BinaryHeap<T> {\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut h1 = BinaryHeap::from([1, 4, 2, 3]);\n+    /// let mut h2: BinaryHeap<_> = [1, 4, 2, 3].into();\n+    /// while let Some((a, b)) = h1.pop().zip(h2.pop()) {\n+    ///     assert_eq!(a, b);\n+    /// }\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T> From<BinaryHeap<T>> for Vec<T> {\n     /// Converts a `BinaryHeap<T>` into a `Vec<T>`."}, {"sha": "2affbc032dce544104a6c252b1471eaeb7c367bb", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -109,7 +109,20 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// }\n /// ```\n ///\n-/// `BTreeMap` also implements an [`Entry API`], which allows for more complex\n+/// A `BTreeMap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+///\n+/// let solar_distance = BTreeMap::from([\n+///     (\"Mercury\", 0.4),\n+///     (\"Venus\", 0.7),\n+///     (\"Earth\", 1.0),\n+///     (\"Mars\", 1.5),\n+/// ]);\n+/// ```\n+///\n+/// `BTreeMap` implements an [`Entry API`], which allows for complex\n /// methods of getting, setting, updating and removing keys and their values:\n ///\n /// [`Entry API`]: BTreeMap::entry\n@@ -2012,6 +2025,20 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+impl<K: Ord, V, const N: usize> From<[(K, V); N]> for BTreeMap<K, V> {\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let map1 = BTreeMap::from([(1, 2), (3, 4)]);\n+    /// let map2: BTreeMap<_, _> = [(1, 2), (3, 4)].into();\n+    /// assert_eq!(map1, map2);\n+    /// ```\n+    fn from(arr: [(K, V); N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///"}, {"sha": "1e61692b7c63cb65be66a7d3ea5c8d019e1fbee7", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -2173,3 +2173,10 @@ fn test_insert_remove_intertwined_ord_chaos() {\n     }\n     map.check_invariants();\n }\n+\n+#[test]\n+fn from_array() {\n+    let map = BTreeMap::from([(1, 2), (3, 4)]);\n+    let unordered_duplicates = BTreeMap::from([(3, 4), (1, 2), (1, 2)]);\n+    assert_eq!(map, unordered_duplicates);\n+}"}, {"sha": "0c268ad32b2612b4d0cd070ca99e2fbf2807e050", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -59,6 +59,14 @@ use super::Recover;\n ///     println!(\"{}\", book);\n /// }\n /// ```\n+///\n+/// A `BTreeSet` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::BTreeSet;\n+///\n+/// let set = BTreeSet::from([1, 2, 3]);\n+/// ```\n #[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n@@ -1057,6 +1065,20 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+impl<T: Ord, const N: usize> From<[T; N]> for BTreeSet<T> {\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set1 = BTreeSet::from([1, 2, 3, 4]);\n+    /// let set2: BTreeSet<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(set1, set2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for BTreeSet<T> {\n     type Item = T;"}, {"sha": "de7a10dca7b8c5ccfe1c80d3924c26a5d4a1703a", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -738,3 +738,10 @@ fn test_split_off_large_random_sorted() {\n     assert!(set.into_iter().eq(data.clone().into_iter().filter(|x| *x < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| *x >= key)));\n }\n+\n+#[test]\n+fn from_array() {\n+    let set = BTreeSet::from([1, 2, 3, 4]);\n+    let unordered_duplicates = BTreeSet::from([4, 1, 4, 3, 2]);\n+    assert_eq!(set, unordered_duplicates);\n+}"}, {"sha": "7aa24ff4afaeef919eb4c745b9d1e41da917dbdb", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -31,6 +31,13 @@ mod tests;\n /// The `LinkedList` allows pushing and popping elements at either end\n /// in constant time.\n ///\n+/// A `LinkedList` with a known list of items can be initialized from an array:\n+/// ```\n+/// use std::collections::LinkedList;\n+///\n+/// let list = LinkedList::from([1, 2, 3]);\n+/// ```\n+///\n /// NOTE: It is almost always better to use `Vec` or `VecDeque` because\n /// array-based containers are generally faster,\n /// more memory efficient, and make better use of CPU cache.\n@@ -1901,6 +1908,20 @@ impl<T: Hash> Hash for LinkedList<T> {\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+impl<T, const N: usize> From<[T; N]> for LinkedList<T> {\n+    /// ```\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let list1 = LinkedList::from([1, 2, 3, 4]);\n+    /// let list2: LinkedList<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(list1, list2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}, {"sha": "26c9415a4de751b02bccba11f9fa834062d03085", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -67,6 +67,14 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible\n /// push onto the back in this manner, and iterating over `VecDeque` goes front\n /// to back.\n ///\n+/// A `VecDeque` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::VecDeque;\n+///\n+/// let deq = VecDeque::from([-1, 0, 1]);\n+/// ```\n+///\n /// Since `VecDeque` is a ring buffer, its elements are not necessarily contiguous\n /// in memory. If you want to access the elements as a single slice, such as for\n /// efficient sorting, you can use [`make_contiguous`]. It rotates the `VecDeque`\n@@ -2915,3 +2923,17 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n+\n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+impl<T, const N: usize> From<[T; N]> for VecDeque<T> {\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deq1 = VecDeque::from([1, 2, 3, 4]);\n+    /// let deq2: VecDeque<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(deq1, deq2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        core::array::IntoIter::new(arr).collect()\n+    }\n+}"}, {"sha": "2b380c444b8abe332718f868c885fc4f506d953d", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -174,12 +174,13 @@ mod spec_extend;\n /// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n-/// The [`vec!`] macro is provided to make initialization more convenient:\n+/// The [`vec!`] macro is provided for convenient initialization:\n ///\n /// ```\n-/// let mut vec = vec![1, 2, 3];\n-/// vec.push(4);\n-/// assert_eq!(vec, [1, 2, 3, 4]);\n+/// let mut vec1 = vec![1, 2, 3];\n+/// vec1.push(4);\n+/// let vec2 = Vec::from([1, 2, 3, 4]);\n+/// assert_eq!(vec1, vec2);\n /// ```\n ///\n /// It can also initialize each element of a `Vec<T>` with a given value."}, {"sha": "b102fd9d5bfdc3a0bc917efeaa94fc1f6d947eab", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -124,8 +124,21 @@ use crate::sys;\n /// }\n /// ```\n ///\n-/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n-/// for more complex methods of getting, setting, updating and removing keys and\n+/// A `HashMap` with a known list of items can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// let solar_distance = HashMap::from([\n+///     (\"Mercury\", 0.4),\n+///     (\"Venus\", 0.7),\n+///     (\"Earth\", 1.0),\n+///     (\"Mars\", 1.5),\n+/// ]);\n+/// ```\n+///\n+/// `HashMap` implements an [`Entry API`](#method.entry), which allows\n+/// for complex methods of getting, setting, updating and removing keys and\n /// their values:\n ///\n /// ```\n@@ -179,27 +192,17 @@ use crate::sys;\n /// }\n ///\n /// // Use a HashMap to store the vikings' health points.\n-/// let mut vikings = HashMap::new();\n-///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n+/// let vikings = HashMap::from([\n+///     (Viking::new(\"Einar\", \"Norway\"), 25),\n+///     (Viking::new(\"Olaf\", \"Denmark\"), 24),\n+///     (Viking::new(\"Harald\", \"Iceland\"), 12),\n+/// ]);\n ///\n /// // Use derived implementation to print the status of the vikings.\n /// for (viking, health) in &vikings {\n ///     println!(\"{:?} has {} hp\", viking, health);\n /// }\n /// ```\n-///\n-/// A `HashMap` with fixed list of elements can be initialized from an array:\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n-///     .iter().cloned().collect();\n-/// // use the values stored in map\n-/// ```\n \n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashmap_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1148,6 +1151,37 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+// Note: as what is currently the most convenient built-in way to construct\n+// a HashMap, a simple usage of this function must not *require* the user\n+// to provide a type annotation in order to infer the third type parameter\n+// (the hasher parameter, conventionally \"S\").\n+// To that end, this impl is defined using RandomState as the concrete\n+// type of S, rather than being generic over `S: BuildHasher + Default`.\n+// It is expected that users who want to specify a hasher will manually use\n+// `with_capacity_and_hasher`.\n+// If type parameter defaults worked on impls, and if type parameter\n+// defaults could be mixed with const generics, then perhaps\n+// this could be generalized.\n+// See also the equivalent impl on HashSet.\n+impl<K, V, const N: usize> From<[(K, V); N]> for HashMap<K, V, RandomState>\n+where\n+    K: Eq + Hash,\n+{\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let map1 = HashMap::from([(1, 2), (3, 4)]);\n+    /// let map2: HashMap<_, _> = [(1, 2), (3, 4)].into();\n+    /// assert_eq!(map1, map2);\n+    /// ```\n+    fn from(arr: [(K, V); N]) -> Self {\n+        crate::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n /// An iterator over the entries of a `HashMap`.\n ///\n /// This `struct` is created by the [`iter`] method on [`HashMap`]. See its"}, {"sha": "def085e380b19953dfbb86d830f3a9591e438167", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -1085,3 +1085,15 @@ mod test_drain_filter {\n         assert_eq!(map.len(), 2);\n     }\n }\n+\n+#[test]\n+fn from_array() {\n+    let map = HashMap::from([(1, 2), (3, 4)]);\n+    let unordered_duplicates = HashMap::from([(3, 4), (1, 2), (1, 2)]);\n+    assert_eq!(map, unordered_duplicates);\n+\n+    // This next line must infer the hasher type parameter.\n+    // If you make a change that causes this line to no longer infer,\n+    // that's a problem!\n+    let _must_not_require_type_annotation = HashMap::from([(1, 2)]);\n+}"}, {"sha": "c381481e006a9e5e9f1dde7c6278d8d6d1d8281c", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -95,14 +95,12 @@ use super::map::{map_try_reserve_error, RandomState};\n /// }\n /// ```\n ///\n-/// A `HashSet` with fixed list of elements can be initialized from an array:\n+/// A `HashSet` with a known list of items can be initialized from an array:\n ///\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// let viking_names: HashSet<&'static str> =\n-///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n-/// // use the values stored in the set\n+/// let viking_names = HashSet::from([\"Einar\", \"Olaf\", \"Harald\"]);\n /// ```\n ///\n /// [hash set]: crate::collections#use-the-set-variant-of-any-of-these-maps-when\n@@ -997,6 +995,37 @@ where\n     }\n }\n \n+#[stable(feature = \"std_collections_from_array\", since = \"1.56.0\")]\n+// Note: as what is currently the most convenient built-in way to construct\n+// a HashSet, a simple usage of this function must not *require* the user\n+// to provide a type annotation in order to infer the third type parameter\n+// (the hasher parameter, conventionally \"S\").\n+// To that end, this impl is defined using RandomState as the concrete\n+// type of S, rather than being generic over `S: BuildHasher + Default`.\n+// It is expected that users who want to specify a hasher will manually use\n+// `with_capacity_and_hasher`.\n+// If type parameter defaults worked on impls, and if type parameter\n+// defaults could be mixed with const generics, then perhaps\n+// this could be generalized.\n+// See also the equivalent impl on HashMap.\n+impl<T, const N: usize> From<[T; N]> for HashSet<T, RandomState>\n+where\n+    T: Eq + Hash,\n+{\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let set1 = HashSet::from([1, 2, 3, 4]);\n+    /// let set2: HashSet<_> = [1, 2, 3, 4].into();\n+    /// assert_eq!(set1, set2);\n+    /// ```\n+    fn from(arr: [T; N]) -> Self {\n+        crate::array::IntoIter::new(arr).collect()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Extend<T> for HashSet<T, S>\n where"}, {"sha": "6a625e6243c2157f4416502f28b3240b56480e3b", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4196e97736ffe75433235bf586989cdb4221c4/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=2b4196e97736ffe75433235bf586989cdb4221c4", "patch": "@@ -484,3 +484,15 @@ fn test_drain_filter_pred_panic_leak() {\n     assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n     assert_eq!(set.len(), 0);\n }\n+\n+#[test]\n+fn from_array() {\n+    let set = HashSet::from([1, 2, 3, 4]);\n+    let unordered_duplicates = HashSet::from([4, 1, 4, 3, 2]);\n+    assert_eq!(set, unordered_duplicates);\n+\n+    // This next line must infer the hasher type parameter.\n+    // If you make a change that causes this line to no longer infer,\n+    // that's a problem!\n+    let _must_not_require_type_annotation = HashSet::from([1, 2]);\n+}"}]}