{"sha": "851066f57e19b645e2dd33392ee7f822cbb2e374", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MTA2NmY1N2UxOWI2NDVlMmRkMzMzOTJlZTdmODIyY2JiMmUzNzQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-17T23:28:20Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-22T23:29:29Z"}, "message": "let_chains: Fix bugs in pretty printing.", "tree": {"sha": "f87ee3c3ecf6ec822e06cae2a4cf8cf11b815425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f87ee3c3ecf6ec822e06cae2a4cf8cf11b815425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/851066f57e19b645e2dd33392ee7f822cbb2e374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/851066f57e19b645e2dd33392ee7f822cbb2e374", "html_url": "https://github.com/rust-lang/rust/commit/851066f57e19b645e2dd33392ee7f822cbb2e374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/851066f57e19b645e2dd33392ee7f822cbb2e374/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7465eb44f0288da9b48c86881b9e88e73d8f27dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7465eb44f0288da9b48c86881b9e88e73d8f27dd", "html_url": "https://github.com/rust-lang/rust/commit/7465eb44f0288da9b48c86881b9e88e73d8f27dd"}], "stats": {"total": 60, "additions": 46, "deletions": 14}, "files": [{"sha": "b2003e2d6bd66a18e3738bf41f0b502b3895359c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=851066f57e19b645e2dd33392ee7f822cbb2e374", "patch": "@@ -41,7 +41,7 @@ use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n-use crate::util::parser::{AssocOp, Fixity};\n+use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::parse::PResult;\n@@ -3208,7 +3208,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(\n             Restrictions::NO_STRUCT_LITERAL,\n-            |this| this.parse_assoc_expr_with(1 + AssocOp::LAnd.precedence(), None.into())\n+            |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n         self.sess.let_chains_spans.borrow_mut().push(span);"}, {"sha": "164fe2f36e1dae57660c3aa847bf9b2bd9a3950a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=851066f57e19b645e2dd33392ee7f822cbb2e374", "patch": "@@ -1715,14 +1715,19 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n+    /// Print a `let pats = scrutinee` expression.\n     pub fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) -> io::Result<()> {\n         self.s.word(\"let \")?;\n \n         self.print_pats(pats)?;\n         self.s.space()?;\n \n         self.word_space(\"=\")?;\n-        self.print_expr_as_cond(scrutinee)\n+        self.print_expr_cond_paren(\n+            scrutinee,\n+            Self::cond_needs_par(scrutinee)\n+            || parser::needs_par_as_let_scrutinee(scrutinee.precedence().order())\n+        )\n     }\n \n     fn print_else(&mut self, els: Option<&ast::Expr>) -> io::Result<()> {\n@@ -1794,30 +1799,30 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = expr.precedence().order() < prec;\n-        if needs_par {\n-            self.popen()?;\n-        }\n-        self.print_expr(expr)?;\n-        if needs_par {\n-            self.pclose()?;\n-        }\n-        Ok(())\n+        self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n     }\n \n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n     pub fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n-        let needs_par = match expr.node {\n+        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n+    }\n+\n+    /// Does `expr` need parenthesis when printed in a condition position?\n+    fn cond_needs_par(expr: &ast::Expr) -> bool {\n+        match expr.node {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             ast::ExprKind::Closure(..) |\n             ast::ExprKind::Ret(..) |\n             ast::ExprKind::Break(..) => true,\n \n             _ => parser::contains_exterior_struct_lit(expr),\n-        };\n+        }\n+    }\n \n+    /// Print `expr` or `(expr)` when `needs_par` holds.\n+    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) -> io::Result<()> {\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1949,6 +1954,17 @@ impl<'a> State<'a> {\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n             (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Lt) |\n             (&ast::ExprKind::Cast { .. }, ast::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n+            // We are given `(let _ = a) OP b`.\n+            //\n+            // - When `OP <= LAnd` we should print `let _ = a OP b` to avoid redundant parens\n+            //   as the parser will interpret this as `(let _ = a) OP b`.\n+            //\n+            // - Otherwise, e.g. when we have `(let a = b) < c` in AST,\n+            //   parens are required since the parser would interpret `let a = b < c` as\n+            //   `let a = (b < c)`. To achieve this, we force parens.\n+            (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n+                parser::PREC_FORCE_PAREN\n+            }\n             _ => left_prec,\n         };\n "}, {"sha": "1e52186a106c12f80753be3b183139b4bc78dbb7", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851066f57e19b645e2dd33392ee7f822cbb2e374/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=851066f57e19b645e2dd33392ee7f822cbb2e374", "patch": "@@ -318,6 +318,9 @@ impl ExprPrecedence {\n             ExprPrecedence::Box |\n             ExprPrecedence::AddrOf |\n             // Here `let pats = expr` has `let pats =` as a \"unary\" prefix of `expr`.\n+            // However, this is not exactly right. When `let _ = a` is the LHS of a binop we\n+            // need parens sometimes. E.g. we can print `(let _ = a) && b` as `let _ = a && b`\n+            // but we need to print `(let _ = a) < b` as-is with parens.\n             ExprPrecedence::Let |\n             ExprPrecedence::Unary => PREC_PREFIX,\n \n@@ -352,6 +355,19 @@ impl ExprPrecedence {\n     }\n }\n \n+/// In `let p = e`, operators with precedence `<=` this one requires parenthesis in `e`.\n+crate fn prec_let_scrutinee_needs_par() -> usize {\n+    AssocOp::LAnd.precedence()\n+}\n+\n+/// Suppose we have `let _ = e` and the `order` of `e`.\n+/// Is the `order` such that `e` in `let _ = e` needs parenthesis when it is on the RHS?\n+///\n+/// Conversely, suppose that we have `(let _ = a) OP b` and `order` is that of `OP`.\n+/// Can we print this as `let _ = a OP b`?\n+crate fn needs_par_as_let_scrutinee(order: i8) -> bool {\n+    order <= prec_let_scrutinee_needs_par() as i8\n+}\n \n /// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and"}]}