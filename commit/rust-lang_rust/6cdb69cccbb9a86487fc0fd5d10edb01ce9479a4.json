{"sha": "6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZGI2OWNjY2JiOWE4NjQ4N2ZjMGZkNWQxMGVkYjAxY2U5NDc5YTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T21:57:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:28Z"}, "message": "refactor trans into trans_closure; restore original closure repr", "tree": {"sha": "6cfd840f972b715e3d1c86ba5e9a26c3c1b79878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cfd840f972b715e3d1c86ba5e9a26c3c1b79878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "html_url": "https://github.com/rust-lang/rust/commit/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a5f33c7791b395a987a3a23a7c02017ede9ffe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5f33c7791b395a987a3a23a7c02017ede9ffe4", "html_url": "https://github.com/rust-lang/rust/commit/5a5f33c7791b395a987a3a23a7c02017ede9ffe4"}], "stats": {"total": 857, "additions": 442, "deletions": 415}, "files": [{"sha": "493c8a04c789dc278d11ca7b061f0bd4f631e63c", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "patch": "@@ -74,8 +74,8 @@ const fn_field_box: int = 1;\n \n const closure_elt_tydesc: int = 0;\n const closure_elt_bindings: int = 1;\n-const closure_elt_n_ty_params: int = 2;\n-const closure_elt_ty_params: int = 3;\n+//const closure_elt_n_ty_params: int = 2;\n+const closure_elt_ty_params: int = 2; // 3;\n \n const vec_elt_fill: int = 0;\n "}, {"sha": "ce106c78eace7bc47e8ff7f269d93e62a2f8f7a8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 412, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "patch": "@@ -1297,15 +1297,15 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n \n     fn take_fn_env(cx: @block_ctxt,\n                    v: ValueRef,\n-                   blk: block(@block_ctxt, ValueRef) -> @block_ctxt)\n+                   blk: block(@block_ctxt, ValueRef, ValueRef) -> @block_ctxt)\n         -> @block_ctxt {\n         let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n         let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n         let null_test = IsNull(cx, box_ptr_v);\n         CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        inner_cx = blk(inner_cx, box_ptr_v);\n+        inner_cx = blk(inner_cx, box_cell_v, box_ptr_v);\n         Br(inner_cx, next_cx.llbb);\n         ret next_cx;\n     }\n@@ -1336,7 +1336,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         bcx\n       }\n       ty::ty_fn(ast::proto_send., _, _, _, _) {\n-        take_fn_env(bcx, v, { |bcx, box_ptr_v|\n+        take_fn_env(bcx, v, { |bcx, _box_cell_v, box_ptr_v|\n             // Here, box_ptr_v is a unique pointer which\n             // must be cloned.\n             call_bound_data_glue_for_closure(\n@@ -1345,7 +1345,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         })\n       }\n       ty::ty_native_fn(_, _) | ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n-        take_fn_env(bcx, v, { |bcx, box_ptr_v|\n+        take_fn_env(bcx, v, { |bcx, _box_cell_v, box_ptr_v|\n             incr_refcnt_of_boxed(bcx, box_ptr_v)\n         })\n       }\n@@ -2232,42 +2232,6 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     }\n }\n \n-fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n-                 id: ast::node_id, dest: dest) -> @block_ctxt {\n-    if dest == ignore { ret bcx; }\n-    let ccx = bcx_ccx(bcx), bcx = bcx;\n-    let fty = node_id_type(ccx, id);\n-    check returns_non_ty_var(ccx, fty);\n-    let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n-    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n-    let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n-    let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n-\n-    let mode = alt f.proto {\n-      ast::proto_shared(_) { for_closure }\n-      ast::proto_send. { for_send }\n-      ast::proto_bare. | ast::proto_block. { for_block }\n-    };\n-    let env;\n-    alt f.proto {\n-      ast::proto_block. | ast::proto_shared(_) | ast::proto_send. {\n-        let upvars = get_freevars(ccx.tcx, id);\n-        let env_r = build_closure(bcx, upvars, mode);\n-        env = env_r.ptr;\n-        bcx = env_r.bcx;\n-        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n-            load_environment(bcx, fcx, env_r.ptrty, upvars, mode);\n-        });\n-      }\n-      ast::proto_bare. {\n-        env = C_null(T_opaque_closure_ptr(ccx));\n-        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n-      }\n-    };\n-    fill_fn_pair(bcx, get_dest_addr(dest), llfn, env);\n-    ret bcx;\n-}\n-\n fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n     if ty::type_is_scalar(bcx_tcx(cx), rhs_t) {\n@@ -2602,294 +2566,6 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     ret next_cx;\n }\n \n-\n-// Iterator translation\n-\n-tag environment_value {\n-    env_expr(@ast::expr);\n-    env_direct(ValueRef, ty::t, bool);\n-}\n-\n-// Given a block context and a list of tydescs and values to bind\n-// construct a closure out of them. If copying is true, it is a\n-// heap allocated closure that copies the upvars into environment.\n-// Otherwise, it is stack allocated and copies pointers to the upvars.\n-fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n-                     bound_values: [environment_value],\n-                     mode: closure_constr_mode) ->\n-   {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n-\n-    fn dummy_environment_box(bcx: @block_ctxt, r: result)\n-        -> (@block_ctxt, ValueRef, ValueRef) {\n-        // Prevent glue from trying to free this.\n-        let ccx = bcx_ccx(bcx);\n-        let ref_cnt = GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]);\n-        Store(r.bcx, C_int(ccx, 2), ref_cnt);\n-        let closure = GEPi(r.bcx, r.val, [0, abi::box_rc_field_body]);\n-        (r.bcx, closure, r.val)\n-    }\n-\n-    fn clone_tydesc(bcx: @block_ctxt,\n-                    mode: closure_constr_mode,\n-                    td: ValueRef) -> ValueRef {\n-        ret alt mode {\n-          for_block. | for_closure. { td }\n-          for_send. { Call(bcx, bcx_ccx(bcx).upcalls.clone_type_desc, [td]) }\n-        };\n-    }\n-\n-    let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n-\n-    // First, synthesize a tuple type containing the types of all the\n-    // bound expressions.\n-    // bindings_ty = [bound_ty1, bound_ty2, ...]\n-    let bound_tys = [];\n-    for bv in bound_values {\n-        bound_tys += [alt bv {\n-          env_direct(_, t, _) { t }\n-          env_expr(e) { ty::expr_ty(tcx, e) }\n-        }];\n-    }\n-    let bindings_ty: ty::t = ty::mk_tup(tcx, bound_tys);\n-\n-    // NB: keep this in sync with T_closure_ptr; we're making\n-    // a ty::t structure that has the same \"shape\" as the LLVM type\n-    // it constructs.\n-\n-    // Make a vector that contains ty_param_count copies of tydesc_ty.\n-    // (We'll need room for that many tydescs in the closure.)\n-    let ty_param_count = vec::len(lltydescs);\n-    let tydesc_ty: ty::t = ty::mk_type(tcx);\n-    let captured_tys: [ty::t] = vec::init_elt(tydesc_ty, ty_param_count);\n-\n-    // Get all the types we've got (some of which we synthesized\n-    // ourselves) into a vector.  The whole things ends up looking\n-    // like:\n-\n-    // closure_ty = (tydesc_ty, (bound_ty1, bound_ty2, ...), int, (tydesc_ty,\n-    // tydesc_ty, ...))\n-    let closure_tys: [ty::t] =\n-        [tydesc_ty, bindings_ty,\n-         ty::mk_uint(tcx), ty::mk_tup(tcx, captured_tys)];\n-    let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n-\n-    let temp_cleanups = [];\n-\n-    // Allocate a box that can hold something closure-sized.\n-    //\n-    // For now, no matter what kind of closure we have, we always allocate\n-    // space for a ref cnt in the closure.  If the closure is a block or\n-    // unique closure, this ref count isn't really used: we initialize it to 2\n-    // so that it will never drop to zero.  This is a hack and could go away\n-    // but then we'd have to modify the code to do the right thing when\n-    // casting from a shared closure to a block.\n-    let (bcx, closure, box) = alt mode {\n-      for_closure. {\n-        let r = trans_malloc_boxed(bcx, closure_ty);\n-        add_clean_free(bcx, r.box, false);\n-        temp_cleanups += [r.box];\n-        (r.bcx, r.body, r.box)\n-      }\n-      for_send. {\n-        // Dummy up a box in the exchange heap.\n-        let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n-        let box_ty = ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n-        check trans_uniq::type_is_unique_box(bcx, box_ty);\n-        let r = trans_uniq::alloc_uniq(bcx, box_ty);\n-        add_clean_free(bcx, r.val, true);\n-        dummy_environment_box(bcx, r)\n-      }\n-      for_block. {\n-        // Dummy up a box on the stack,\n-        let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n-        let r = alloc_ty(bcx, ty);\n-        dummy_environment_box(bcx, r)\n-      }\n-    };\n-\n-    // Store bindings tydesc.\n-    alt mode {\n-      for_closure. | for_send. {\n-        let bound_tydesc = GEPi(bcx, closure, [0, abi::closure_elt_tydesc]);\n-        let ti = none;\n-        let bindings_tydesc =\n-            get_tydesc(bcx, bindings_ty, true, tps_normal, ti).result;\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = bindings_tydesc.bcx;\n-        let td = clone_tydesc(bcx, mode, bindings_tydesc.val);\n-        Store(bcx, td, bound_tydesc);\n-      }\n-      for_block. {}\n-    }\n-\n-    // Copy expr values into boxed bindings.\n-    // Silly check\n-    check type_is_tup_like(bcx, closure_ty);\n-    let closure_box = box;\n-    let closure_box_ty = ty::mk_imm_box(bcx_tcx(bcx), closure_ty);\n-    let i = 0u;\n-    for bv in bound_values {\n-        let bound = GEP_tup_like_1(bcx, closure_box_ty, closure_box,\n-                                   [0, abi::box_rc_field_body,\n-                                    abi::closure_elt_bindings,\n-                                    i as int]);\n-        bcx = bound.bcx;\n-        alt bv {\n-          env_expr(e) {\n-            bcx = trans_expr_save_in(bcx, e, bound.val);\n-            add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n-            temp_cleanups += [bound.val];\n-          }\n-          env_direct(val, ty, is_mem) {\n-            alt mode {\n-              for_closure. | for_send. {\n-                let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n-                bcx = copy_val(bcx, INIT, bound.val, val1, ty);\n-              }\n-              for_block. {\n-                let addr = is_mem ? val : do_spill_noroot(bcx, val);\n-                Store(bcx, addr, bound.val);\n-              }\n-            }\n-          }\n-        }\n-        i += 1u;\n-    }\n-    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n-\n-    // If necessary, copy tydescs describing type parameters into the\n-    // appropriate slot in the closure.\n-    // Silly check as well\n-    check type_is_tup_like(bcx, closure_ty);\n-    let {bcx:bcx, val:n_ty_params_slot} =\n-        GEP_tup_like(bcx, closure_ty, closure,\n-                     [0, abi::closure_elt_n_ty_params]);\n-    Store(bcx, C_uint(ccx, vec::len(lltydescs)), n_ty_params_slot);\n-    check type_is_tup_like(bcx, closure_ty);\n-    let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like(bcx, closure_ty, closure,\n-                     [0, abi::closure_elt_ty_params]);\n-    i = 0u;\n-    for td: ValueRef in lltydescs {\n-        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n-        let cloned_td = clone_tydesc(bcx, mode, td);\n-        Store(bcx, cloned_td, ty_param_slot);\n-        i += 1u;\n-    }\n-\n-    ret {ptr: box, ptrty: closure_ty, bcx: bcx};\n-}\n-\n-tag closure_constr_mode {\n-    for_block;\n-    for_closure;\n-    for_send;\n-}\n-\n-// Given a context and a list of upvars, build a closure. This just\n-// collects the upvars and packages them up for build_environment.\n-fn build_closure(cx: @block_ctxt,\n-                 upvars: @[ast::def],\n-                 mode: closure_constr_mode)\n-    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n-    // If we need to, package up the iterator body to call\n-    let env_vals = [];\n-    // Package up the upvars\n-    for def in *upvars {\n-        let lv = trans_local_var(cx, def);\n-        let nid = ast_util::def_id_of_def(def).node;\n-        let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n-        alt mode {\n-          for_block. { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n-          for_send. | for_closure. {}\n-        }\n-        env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n-    }\n-    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, mode);\n-}\n-\n-// Return a pointer to the stored typarams in a closure.\n-// This is awful. Since the size of the bindings stored in the closure might\n-// be dynamically sized, we can't skip past them to get to the tydescs until\n-// we have loaded the tydescs. Thus we use the stored size of the bindings\n-// in the tydesc for the closure to skip over them. Ugh.\n-fn find_environment_tydescs(bcx: @block_ctxt, envty: ty::t, closure: ValueRef)\n-   -> ValueRef {\n-    ret if !ty::type_has_dynamic_size(bcx_tcx(bcx), envty) {\n-\n-            // If we can find the typarams statically, do it\n-            GEPi(bcx, closure,\n-                 [0, abi::box_rc_field_body, abi::closure_elt_ty_params])\n-        } else {\n-            // Ugh. We need to load the size of the bindings out of the\n-            // closure's tydesc and use that to skip over the bindings.\n-            let descsty =\n-                ty::get_element_type(bcx_tcx(bcx), envty,\n-                                     abi::closure_elt_ty_params as uint);\n-            let llenv = GEPi(bcx, closure, [0, abi::box_rc_field_body]);\n-            // Load the tydesc and find the size of the body\n-            let lldesc =\n-                Load(bcx, GEPi(bcx, llenv, [0, abi::closure_elt_tydesc]));\n-            let llsz =\n-                Load(bcx, GEPi(bcx, lldesc, [0, abi::tydesc_field_size]));\n-\n-            // Get the bindings pointer and add the size to it\n-            let llbinds = GEPi(bcx, llenv, [0, abi::closure_elt_bindings]);\n-            bump_ptr(bcx, descsty, llbinds, llsz)\n-        }\n-}\n-\n-// Given an enclosing block context, a new function context, a closure type,\n-// and a list of upvars, generate code to load and populate the environment\n-// with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n-                    upvars: @[ast::def], mode: closure_constr_mode) {\n-    let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n-\n-    let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n-\n-    let ccx = bcx_ccx(bcx);\n-    let sp = bcx.sp;\n-    // FIXME: should have postcondition on mk_imm_box,\n-    // so this check won't be necessary\n-    check (type_has_static_size(ccx, ty));\n-    let llty = type_of(ccx, sp, ty);\n-    let llclosure = PointerCast(bcx, fcx.llenv, llty);\n-\n-    // Populate the type parameters from the environment. We need to\n-    // do this first because the tydescs are needed to index into\n-    // the bindings if they are dynamically sized.\n-    let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n-    let lltydescs = find_environment_tydescs(bcx, envty, llclosure);\n-    let i = 0u;\n-    while i < tydesc_count {\n-        let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n-        fcx.lltydescs += [Load(bcx, lltydescptr)];\n-        i += 1u;\n-    }\n-\n-    // Populate the upvars from the environment.\n-    let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n-    i = 0u;\n-    // Load the actual upvars.\n-    for upvar_def in *upvars {\n-        // Silly check\n-        check type_is_tup_like(bcx, ty);\n-        let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n-        bcx = upvarptr.bcx;\n-        let llupvarptr = upvarptr.val;\n-        alt mode {\n-          for_block. { llupvarptr = Load(bcx, llupvarptr); }\n-          for_send. | for_closure. { }\n-        }\n-        let def_id = ast_util::def_id_of_def(upvar_def);\n-        fcx.llupvars.insert(def_id.node, llupvarptr);\n-        i += 1u;\n-    }\n-}\n-\n fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     -> @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n@@ -3292,8 +2968,8 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         let n_args = vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n         let args = vec::init_elt(none::<@ast::expr>, n_args);\n         let space = alloc_ty(c.bcx, ty);\n-        let bcx = trans_bind_1(space.bcx, ty, c, args, ty,\n-                               save_in(space.val));\n+        let bcx = trans_closure::trans_bind_1(space.bcx, ty, c, args, ty,\n+                                              save_in(space.val));\n         add_clean_temp(bcx, space.val, ty);\n         ret {bcx: bcx, val: space.val, kind: temporary};\n       }\n@@ -3580,86 +3256,6 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     ret {val: llthunk, ty: llthunk_ty};\n }\n \n-fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n-              id: ast::node_id, dest: dest) -> @block_ctxt {\n-    let f_res = trans_callee(cx, f);\n-    ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n-                     ty::node_id_to_type(bcx_tcx(cx), id), dest);\n-}\n-\n-fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n-                f_res: lval_maybe_callee,\n-                args: [option::t<@ast::expr>], pair_ty: ty::t,\n-                dest: dest) -> @block_ctxt {\n-    let bound: [@ast::expr] = [];\n-    for argopt: option::t<@ast::expr> in args {\n-        alt argopt { none. { } some(e) { bound += [e]; } }\n-    }\n-    let bcx = f_res.bcx;\n-    if dest == ignore {\n-        for ex in bound { bcx = trans_expr(bcx, ex, ignore); }\n-        ret bcx;\n-    }\n-\n-    // Figure out which tydescs we need to pass, if any.\n-    let outgoing_fty_real; // the type with typarams still in it\n-    let lltydescs: [ValueRef];\n-    alt f_res.generic {\n-      none. { outgoing_fty_real = outgoing_fty; lltydescs = []; }\n-      some(ginfo) {\n-        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-        outgoing_fty_real = ginfo.item_type;\n-        lltydescs = ginfo.tydescs;\n-      }\n-    }\n-\n-    let ty_param_count = vec::len(lltydescs);\n-    if vec::len(bound) == 0u && ty_param_count == 0u {\n-        // Trivial 'binding': just return the closure\n-        let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n-        bcx = lv.bcx;\n-        ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n-    }\n-    let closure = alt f_res.env {\n-      null_env. { none }\n-      _ { let (_, cl) = maybe_add_env(cx, f_res); some(cl) }\n-    };\n-\n-    // FIXME: should follow from a precondition on trans_bind_1\n-    let ccx = bcx_ccx(cx);\n-    check (type_has_static_size(ccx, outgoing_fty));\n-\n-    // Arrange for the bound function to live in the first binding spot\n-    // if the function is not statically known.\n-    let (env_vals, target_res) = alt closure {\n-      some(cl) {\n-        // Cast the function we are binding to be the type that the\n-        // closure will expect it to have. The type the closure knows\n-        // about has the type parameters substituted with the real types.\n-        let sp = cx.sp;\n-        let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n-        let src_loc = PointerCast(bcx, cl, llclosurety);\n-        ([env_direct(src_loc, pair_ty, true)], none)\n-      }\n-      none. { ([], some(f_res.val)) }\n-    };\n-\n-    // Actually construct the closure\n-    let closure = build_environment(bcx, lltydescs, env_vals +\n-                                    vec::map({|x| env_expr(x)}, bound),\n-                                    for_closure);\n-    bcx = closure.bcx;\n-\n-    // Make thunk\n-    let llthunk =\n-        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         closure.ptrty, ty_param_count, target_res);\n-\n-    // Fill the function pair\n-    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, closure.ptr);\n-    ret bcx;\n-}\n-\n fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n                   &to_zero: [{v: ValueRef, t: ty::t}],\n                   &to_revoke: [{v: ValueRef, t: ty::t}], e: @ast::expr) ->\n@@ -4166,8 +3762,12 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n       // NDM captures\n-      ast::expr_fn(f, cap) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n-      ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n+      ast::expr_fn(f, cap) {\n+        ret trans_closure::trans_expr_fn(bcx, f, e.span, e.id, dest);\n+      }\n+      ast::expr_bind(f, args) {\n+        ret trans_closure::trans_bind(bcx, f, args, e.id, dest);\n+      }\n       ast::expr_copy(a) {\n         if !ty::expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }\n         else { ret lval_to_dps(bcx, a, dest); }"}, {"sha": "852ee5e7b679427937ec3e57fb071d481719761d", "filename": "src/comp/middle/trans_closure.rs", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "patch": "@@ -0,0 +1,426 @@\n+import syntax::ast;\n+import syntax::ast_util;\n+import lib::llvm::llvm::ValueRef;\n+import trans_common::*;\n+import trans_build::*;\n+import trans::*;\n+import middle::freevars::get_freevars;\n+import option::{some, none};\n+import back::abi;\n+import syntax::codemap::span;\n+import back::link::mangle_internal_name_by_path;\n+import trans::{\n+    trans_shared_malloc,\n+    type_of_inner,\n+    size_of,\n+    node_id_type,\n+    INIT,\n+    trans_shared_free,\n+    drop_ty,\n+    new_sub_block_ctxt,\n+    load_if_immediate,\n+    dest\n+};\n+\n+tag environment_value {\n+    env_expr(@ast::expr);\n+    env_direct(ValueRef, ty::t, bool);\n+}\n+\n+// Given a block context and a list of tydescs and values to bind\n+// construct a closure out of them. If copying is true, it is a\n+// heap allocated closure that copies the upvars into environment.\n+// Otherwise, it is stack allocated and copies pointers to the upvars.\n+fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n+                     bound_values: [environment_value],\n+                     mode: closure_constr_mode) ->\n+   {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+\n+    fn dummy_environment_box(bcx: @block_ctxt, r: result)\n+        -> (@block_ctxt, ValueRef, ValueRef) {\n+        // Prevent glue from trying to free this.\n+        let ccx = bcx_ccx(bcx);\n+        let ref_cnt = GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]);\n+        Store(r.bcx, C_int(ccx, 2), ref_cnt);\n+        let closure = GEPi(r.bcx, r.val, [0, abi::box_rc_field_body]);\n+        (r.bcx, closure, r.val)\n+    }\n+\n+    fn clone_tydesc(bcx: @block_ctxt,\n+                    mode: closure_constr_mode,\n+                    td: ValueRef) -> ValueRef {\n+        ret alt mode {\n+          for_block. | for_closure. { td }\n+          for_send. { Call(bcx, bcx_ccx(bcx).upcalls.clone_type_desc, [td]) }\n+        };\n+    }\n+\n+    let ccx = bcx_ccx(bcx);\n+    let tcx = bcx_tcx(bcx);\n+\n+    // First, synthesize a tuple type containing the types of all the\n+    // bound expressions.\n+    // bindings_ty = [bound_ty1, bound_ty2, ...]\n+    let bound_tys = [];\n+    for bv in bound_values {\n+        bound_tys += [alt bv {\n+          env_direct(_, t, _) { t }\n+          env_expr(e) { ty::expr_ty(tcx, e) }\n+        }];\n+    }\n+    let bindings_ty: ty::t = ty::mk_tup(tcx, bound_tys);\n+\n+    // NB: keep this in sync with T_closure_ptr; we're making\n+    // a ty::t structure that has the same \"shape\" as the LLVM type\n+    // it constructs.\n+\n+    // Make a vector that contains ty_param_count copies of tydesc_ty.\n+    // (We'll need room for that many tydescs in the closure.)\n+    let ty_param_count = vec::len(lltydescs);\n+    let tydesc_ty: ty::t = ty::mk_type(tcx);\n+    let captured_tys: [ty::t] = vec::init_elt(tydesc_ty, ty_param_count);\n+\n+    // Get all the types we've got (some of which we synthesized\n+    // ourselves) into a vector.  The whole things ends up looking\n+    // like:\n+\n+    // closure_ty = (\n+    //   tydesc_ty, (bound_ty1, bound_ty2, ...),\n+    //   /*int,*/ (tydesc_ty, tydesc_ty, ...))\n+    let closure_tys: [ty::t] =\n+        [tydesc_ty, bindings_ty,\n+         /*ty::mk_uint(tcx),*/ ty::mk_tup(tcx, captured_tys)];\n+    let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n+\n+    let temp_cleanups = [];\n+\n+    // Allocate a box that can hold something closure-sized.\n+    //\n+    // For now, no matter what kind of closure we have, we always allocate\n+    // space for a ref cnt in the closure.  If the closure is a block or\n+    // unique closure, this ref count isn't really used: we initialize it to 2\n+    // so that it will never drop to zero.  This is a hack and could go away\n+    // but then we'd have to modify the code to do the right thing when\n+    // casting from a shared closure to a block.\n+    let (bcx, closure, box) = alt mode {\n+      for_closure. {\n+        let r = trans::trans_malloc_boxed(bcx, closure_ty);\n+        add_clean_free(bcx, r.box, false);\n+        temp_cleanups += [r.box];\n+        (r.bcx, r.body, r.box)\n+      }\n+      for_send. {\n+        // Dummy up a box in the exchange heap.\n+        let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n+        let box_ty = ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n+        check trans_uniq::type_is_unique_box(bcx, box_ty);\n+        let r = trans_uniq::alloc_uniq(bcx, box_ty);\n+        add_clean_free(bcx, r.val, true);\n+        dummy_environment_box(bcx, r)\n+      }\n+      for_block. {\n+        // Dummy up a box on the stack,\n+        let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n+        let r = trans::alloc_ty(bcx, ty);\n+        dummy_environment_box(bcx, r)\n+      }\n+    };\n+\n+    // Store bindings tydesc.\n+    alt mode {\n+      for_closure. | for_send. {\n+        let bound_tydesc = GEPi(bcx, closure, [0, abi::closure_elt_tydesc]);\n+        let ti = none;\n+        let {result:bindings_tydesc, _} =\n+            trans::get_tydesc(bcx, bindings_ty, true, trans::tps_normal, ti);\n+        trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+        bcx = bindings_tydesc.bcx;\n+        let td = clone_tydesc(bcx, mode, bindings_tydesc.val);\n+        Store(bcx, td, bound_tydesc);\n+      }\n+      for_block. {}\n+    }\n+\n+    // Copy expr values into boxed bindings.\n+    // Silly check\n+    check type_is_tup_like(bcx, closure_ty);\n+    let closure_box = box;\n+    let closure_box_ty = ty::mk_imm_box(bcx_tcx(bcx), closure_ty);\n+    let i = 0u;\n+    for bv in bound_values {\n+        let bound = trans::GEP_tup_like_1(bcx, closure_box_ty, closure_box,\n+                                          [0, abi::box_rc_field_body,\n+                                           abi::closure_elt_bindings,\n+                                           i as int]);\n+        bcx = bound.bcx;\n+        alt bv {\n+          env_expr(e) {\n+            bcx = trans::trans_expr_save_in(bcx, e, bound.val);\n+            add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n+            temp_cleanups += [bound.val];\n+          }\n+          env_direct(val, ty, is_mem) {\n+            alt mode {\n+              for_closure. | for_send. {\n+                let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n+                bcx = trans::copy_val(bcx, INIT, bound.val, val1, ty);\n+              }\n+              for_block. {\n+                let addr = is_mem ? val : do_spill_noroot(bcx, val);\n+                Store(bcx, addr, bound.val);\n+              }\n+            }\n+          }\n+        }\n+        i += 1u;\n+    }\n+    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+\n+    // If necessary, copy tydescs describing type parameters into the\n+    // appropriate slot in the closure.\n+    // Silly check as well\n+    //check type_is_tup_like(bcx, closure_ty);\n+    //let {bcx:bcx, val:n_ty_params_slot} =\n+    //    GEP_tup_like(bcx, closure_ty, closure,\n+    //                 [0, abi::closure_elt_n_ty_params]);\n+    //Store(bcx, C_uint(ccx, vec::len(lltydescs)), n_ty_params_slot);\n+    check type_is_tup_like(bcx, closure_ty);\n+    let {bcx:bcx, val:ty_params_slot} =\n+        GEP_tup_like(bcx, closure_ty, closure,\n+                     [0, abi::closure_elt_ty_params]);\n+    i = 0u;\n+    for td: ValueRef in lltydescs {\n+        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n+        let cloned_td = clone_tydesc(bcx, mode, td);\n+        Store(bcx, cloned_td, ty_param_slot);\n+        i += 1u;\n+    }\n+\n+    ret {ptr: box, ptrty: closure_ty, bcx: bcx};\n+}\n+\n+tag closure_constr_mode {\n+    for_block;\n+    for_closure;\n+    for_send;\n+}\n+\n+// Given a context and a list of upvars, build a closure. This just\n+// collects the upvars and packages them up for build_environment.\n+fn build_closure(cx: @block_ctxt,\n+                 upvars: @[ast::def],\n+                 mode: closure_constr_mode)\n+    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+    // If we need to, package up the iterator body to call\n+    let env_vals = [];\n+    // Package up the upvars\n+    for def in *upvars {\n+        let lv = trans_local_var(cx, def);\n+        let nid = ast_util::def_id_of_def(def).node;\n+        let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n+        alt mode {\n+          for_block. { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n+          for_send. | for_closure. {}\n+        }\n+        env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n+    }\n+    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, mode);\n+}\n+\n+// Return a pointer to the stored typarams in a closure.\n+// This is awful. Since the size of the bindings stored in the closure might\n+// be dynamically sized, we can't skip past them to get to the tydescs until\n+// we have loaded the tydescs. Thus we use the stored size of the bindings\n+// in the tydesc for the closure to skip over them. Ugh.\n+fn find_environment_tydescs(bcx: @block_ctxt, envty: ty::t, closure: ValueRef)\n+   -> ValueRef {\n+    ret if !ty::type_has_dynamic_size(bcx_tcx(bcx), envty) {\n+\n+            // If we can find the typarams statically, do it\n+            GEPi(bcx, closure,\n+                 [0, abi::box_rc_field_body, abi::closure_elt_ty_params])\n+        } else {\n+            // Ugh. We need to load the size of the bindings out of the\n+            // closure's tydesc and use that to skip over the bindings.\n+            let descsty =\n+                ty::get_element_type(bcx_tcx(bcx), envty,\n+                                     abi::closure_elt_ty_params as uint);\n+            let llenv = GEPi(bcx, closure, [0, abi::box_rc_field_body]);\n+            // Load the tydesc and find the size of the body\n+            let lldesc =\n+                Load(bcx, GEPi(bcx, llenv, [0, abi::closure_elt_tydesc]));\n+            let llsz =\n+                Load(bcx, GEPi(bcx, lldesc, [0, abi::tydesc_field_size]));\n+\n+            // Get the bindings pointer and add the size to it\n+            let llbinds = GEPi(bcx, llenv, [0, abi::closure_elt_bindings]);\n+            bump_ptr(bcx, descsty, llbinds, llsz)\n+        }\n+}\n+\n+// Given an enclosing block context, a new function context, a closure type,\n+// and a list of upvars, generate code to load and populate the environment\n+// with the upvars and type descriptors.\n+fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n+                    upvars: @[ast::def], mode: closure_constr_mode) {\n+    let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+\n+    let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n+\n+    let ccx = bcx_ccx(bcx);\n+    let sp = bcx.sp;\n+    // FIXME: should have postcondition on mk_imm_box,\n+    // so this check won't be necessary\n+    check (type_has_static_size(ccx, ty));\n+    let llty = type_of(ccx, sp, ty);\n+    let llclosure = PointerCast(bcx, fcx.llenv, llty);\n+\n+    // Populate the type parameters from the environment. We need to\n+    // do this first because the tydescs are needed to index into\n+    // the bindings if they are dynamically sized.\n+    let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n+    let lltydescs = find_environment_tydescs(bcx, envty, llclosure);\n+    let i = 0u;\n+    while i < tydesc_count {\n+        let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n+        fcx.lltydescs += [Load(bcx, lltydescptr)];\n+        i += 1u;\n+    }\n+\n+    // Populate the upvars from the environment.\n+    let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n+    i = 0u;\n+    // Load the actual upvars.\n+    for upvar_def in *upvars {\n+        // Silly check\n+        check type_is_tup_like(bcx, ty);\n+        let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n+        bcx = upvarptr.bcx;\n+        let llupvarptr = upvarptr.val;\n+        alt mode {\n+          for_block. { llupvarptr = Load(bcx, llupvarptr); }\n+          for_send. | for_closure. { }\n+        }\n+        let def_id = ast_util::def_id_of_def(upvar_def);\n+        fcx.llupvars.insert(def_id.node, llupvarptr);\n+        i += 1u;\n+    }\n+}\n+\n+fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n+                 id: ast::node_id, dest: dest) -> @block_ctxt {\n+    if dest == ignore { ret bcx; }\n+    let ccx = bcx_ccx(bcx), bcx = bcx;\n+    let fty = node_id_type(ccx, id);\n+    check returns_non_ty_var(ccx, fty);\n+    let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n+    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n+    let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n+    let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n+\n+    let mode = alt f.proto {\n+      ast::proto_shared(_) { for_closure }\n+      ast::proto_send. { for_send }\n+      ast::proto_bare. | ast::proto_block. { for_block }\n+    };\n+    let env;\n+    alt f.proto {\n+      ast::proto_block. | ast::proto_shared(_) | ast::proto_send. {\n+        let upvars = get_freevars(ccx.tcx, id);\n+        let env_r = build_closure(bcx, upvars, mode);\n+        env = env_r.ptr;\n+        bcx = env_r.bcx;\n+        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n+            load_environment(bcx, fcx, env_r.ptrty, upvars, mode);\n+        });\n+      }\n+      ast::proto_bare. {\n+        env = C_null(T_opaque_closure_ptr(ccx));\n+        trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n+      }\n+    };\n+    fill_fn_pair(bcx, get_dest_addr(dest), llfn, env);\n+    ret bcx;\n+}\n+\n+fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n+              id: ast::node_id, dest: dest) -> @block_ctxt {\n+    let f_res = trans_callee(cx, f);\n+    ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n+                     ty::node_id_to_type(bcx_tcx(cx), id), dest);\n+}\n+\n+fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n+                f_res: lval_maybe_callee,\n+                args: [option::t<@ast::expr>], pair_ty: ty::t,\n+                dest: dest) -> @block_ctxt {\n+    let bound: [@ast::expr] = [];\n+    for argopt: option::t<@ast::expr> in args {\n+        alt argopt { none. { } some(e) { bound += [e]; } }\n+    }\n+    let bcx = f_res.bcx;\n+    if dest == ignore {\n+        for ex in bound { bcx = trans_expr(bcx, ex, ignore); }\n+        ret bcx;\n+    }\n+\n+    // Figure out which tydescs we need to pass, if any.\n+    let outgoing_fty_real; // the type with typarams still in it\n+    let lltydescs: [ValueRef];\n+    alt f_res.generic {\n+      none. { outgoing_fty_real = outgoing_fty; lltydescs = []; }\n+      some(ginfo) {\n+        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n+        outgoing_fty_real = ginfo.item_type;\n+        lltydescs = ginfo.tydescs;\n+      }\n+    }\n+\n+    let ty_param_count = vec::len(lltydescs);\n+    if vec::len(bound) == 0u && ty_param_count == 0u {\n+        // Trivial 'binding': just return the closure\n+        let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n+        bcx = lv.bcx;\n+        ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n+    }\n+    let closure = alt f_res.env {\n+      null_env. { none }\n+      _ { let (_, cl) = maybe_add_env(cx, f_res); some(cl) }\n+    };\n+\n+    // FIXME: should follow from a precondition on trans_bind_1\n+    let ccx = bcx_ccx(cx);\n+    check (type_has_static_size(ccx, outgoing_fty));\n+\n+    // Arrange for the bound function to live in the first binding spot\n+    // if the function is not statically known.\n+    let (env_vals, target_res) = alt closure {\n+      some(cl) {\n+        // Cast the function we are binding to be the type that the\n+        // closure will expect it to have. The type the closure knows\n+        // about has the type parameters substituted with the real types.\n+        let sp = cx.sp;\n+        let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n+        let src_loc = PointerCast(bcx, cl, llclosurety);\n+        ([env_direct(src_loc, pair_ty, true)], none)\n+      }\n+      none. { ([], some(f_res.val)) }\n+    };\n+\n+    // Actually construct the closure\n+    let closure = build_environment(bcx, lltydescs, env_vals +\n+                                    vec::map({|x| env_expr(x)}, bound),\n+                                    for_closure);\n+    bcx = closure.bcx;\n+\n+    // Make thunk\n+    let llthunk =\n+        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n+                         closure.ptrty, ty_param_count, target_res);\n+\n+    // Fill the function pair\n+    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, closure.ptr);\n+    ret bcx;\n+}\n+"}, {"sha": "ff6de79399969c460eac093584d9c2e4d92736a3", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "patch": "@@ -695,7 +695,7 @@ fn T_closure_ptr(cx: @crate_ctxt, llbindings_ty: TypeRef,\n     // it constructs.\n     ret T_ptr(T_box(cx, T_struct([T_ptr(cx.tydesc_type),\n                                   llbindings_ty,\n-                                  cx.int_type,\n+                                  //cx.int_type,\n                                   T_captured_tydescs(cx, n_ty_params)])));\n }\n "}, {"sha": "51a01378fb3a9c95373fb165610af06a4ab20a9a", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=6cdb69cccbb9a86487fc0fd5d10edb01ce9479a4", "patch": "@@ -20,6 +20,7 @@ mod middle {\n     mod trans_alt;\n     mod trans_objects;\n     mod trans_uniq;\n+    mod trans_closure;\n     mod trans_vec;\n     mod ty;\n     mod ast_map;"}]}