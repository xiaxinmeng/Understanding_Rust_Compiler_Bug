{"sha": "c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "node_id": "C_kwDOAAsO6NoAKGMzMGQ3ZTk3YTgxM2NiZDljMDIyMjI3NTI4YjFiMjZjZTg4ZThkZGQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-04-10T08:43:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-10T08:43:13Z"}, "message": "Rollup merge of #109724 - lcnr:prioritize-env, r=compiler-errors\n\nprioritize param env candidates if they don't guide type inference\n\nintended to supersede #109579. We disable the prioritization during coherence to maintain completeness.\n\nLong term we can hopefully replace this hack with adding OR to external constraints at which point the only relevant part when merging responses is whether they guide type inference in the same way.\n\nReuses `try_merge_responses` for assembly and the cleanest way to impl that was to actually split that so that `try_merge_responses` returns `None` if we fail to merge them and then add `flounder` which is used afterwards which is allowed to lower the certainty of our responses.\n\nIf, in the future, we add the ability to merge candidates `YES: ?0 = Vec<u32>` and `YES: ?0 = Vec<i32>` to `AMBIG: ?0 = Vec<?1>`, this should happen in `flounder`.\n\nr? `@compiler-errors` `@BoxyUwU`", "tree": {"sha": "4272c1205e67132bb3e9f037109b907308dbc43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4272c1205e67132bb3e9f037109b907308dbc43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkM8whCRBK7hj4Ov3rIwAA2lEIAFighO9MGz6D92Qqd3UTTM34\nXRKlJ0gkLkkZ23c+GOzhvd5wQCIWR0zRZOcB4sui6sZAc4Oz35hf539iq5MbdZeL\nbGU0P0TVF9YE8h7KY93Oz6acR1HYCgNpRhX3g1j+grgzCKsg4diEWPEZQ1wkVu8M\nqY7B+WVCQbl6sr/NCCJ9gWp3O2h5OIjRgYpbDO0WuSI41DfhRvgdy4cZEpZj6x4+\nq2Lt5Xu8lPjlAFWWscx2m13ks6xfB/0q6TqgbPiPGwatgddBtPuDJj5NvThMZuc2\nCZHPue39OJMMvVkoteeb5tMgsgwxbRuN6P64C+KuDHFks5jxr4b31mMDY0Ep61Q=\n=DhM2\n-----END PGP SIGNATURE-----\n", "payload": "tree 4272c1205e67132bb3e9f037109b907308dbc43b\nparent 749b487be49b793dd713c429042b33262208f4f9\nparent 3fab7f7c13390217bf55d864b6e1efc3d0ec1528\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1681116193 +0530\ncommitter GitHub <noreply@github.com> 1681116193 +0530\n\nRollup merge of #109724 - lcnr:prioritize-env, r=compiler-errors\n\nprioritize param env candidates if they don't guide type inference\n\nintended to supersede #109579. We disable the prioritization during coherence to maintain completeness.\n\nLong term we can hopefully replace this hack with adding OR to external constraints at which point the only relevant part when merging responses is whether they guide type inference in the same way.\n\nReuses `try_merge_responses` for assembly and the cleanest way to impl that was to actually split that so that `try_merge_responses` returns `None` if we fail to merge them and then add `flounder` which is used afterwards which is allowed to lower the certainty of our responses.\n\nIf, in the future, we add the ability to merge candidates `YES: ?0 = Vec<u32>` and `YES: ?0 = Vec<i32>` to `AMBIG: ?0 = Vec<?1>`, this should happen in `flounder`.\n\nr? `@compiler-errors` `@BoxyUwU`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "html_url": "https://github.com/rust-lang/rust/commit/c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749b487be49b793dd713c429042b33262208f4f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/749b487be49b793dd713c429042b33262208f4f9", "html_url": "https://github.com/rust-lang/rust/commit/749b487be49b793dd713c429042b33262208f4f9"}, {"sha": "3fab7f7c13390217bf55d864b6e1efc3d0ec1528", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fab7f7c13390217bf55d864b6e1efc3d0ec1528", "html_url": "https://github.com/rust-lang/rust/commit/3fab7f7c13390217bf55d864b6e1efc3d0ec1528"}], "stats": {"total": 311, "additions": 205, "deletions": 106}, "files": [{"sha": "b5b712c367d08d36147ab99664e182d5516c116a", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -80,6 +80,18 @@ impl CanonicalVarValues<'_> {\n             }\n         })\n     }\n+\n+    pub fn is_identity_modulo_regions(&self) -> bool {\n+        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n+            ty::GenericArgKind::Lifetime(_) => true,\n+            ty::GenericArgKind::Type(ty) => {\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n+            }\n+            ty::GenericArgKind::Const(ct) => {\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+            }\n+        })\n+    }\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing"}, {"sha": "7602bea5a248907a4d3ed8cef97fccc3d354d032", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -56,9 +56,19 @@ pub enum Certainty {\n impl Certainty {\n     pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n \n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n+    /// Use this function to merge the certainty of multiple nested subgoals.\n+    ///\n+    /// Given an impl like `impl<T: Foo + Bar> Baz for T {}`, we have 2 nested\n+    /// subgoals whenever we use the impl as a candidate: `T: Foo` and `T: Bar`.\n+    /// If evaluating `T: Foo` results in ambiguity and `T: Bar` results in\n+    /// success, we merge these two responses. This results in ambiguity.\n+    ///\n+    /// If we unify ambiguity with overflow, we return overflow. This doesn't matter\n+    /// inside of the solver as we distinguish ambiguity from overflow. It does\n+    /// however matter for diagnostics. If `T: Foo` resulted in overflow and `T: Bar`\n+    /// in ambiguity without changing the inference state, we still want to tell the\n+    /// user that `T: Baz` results in overflow.\n+    pub fn unify_with(self, other: Certainty) -> Certainty {\n         match (self, other) {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,"}, {"sha": "12ee80b6722b1f571958baa3f770a33e7cb5b895", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "renamed", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,11 +1,9 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::search_graph::OverflowHandler;\n-#[cfg(doc)]\n-use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n+use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n-use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -16,6 +14,8 @@ use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n \n+pub(super) mod structural_traits;\n+\n /// A candidate is a possible way to prove a goal.\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n@@ -547,61 +547,41 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// If there are multiple ways to prove a trait or projection goal, we have\n+    /// to somehow try to merge the candidates into one. If that fails, we return\n+    /// ambiguity.\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n+        // First try merging all candidates. This is complete and fully sound.\n+        let responses = candidates.iter().map(|c| c.result).collect::<Vec<_>>();\n+        if let Some(result) = self.try_merge_responses(&responses) {\n+            return Ok(result);\n         }\n \n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n-                    {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n+        // We then check whether we should prioritize `ParamEnv` candidates.\n+        //\n+        // Doing so is incomplete and would therefore be unsound during coherence.\n+        match self.solver_mode() {\n+            SolverMode::Coherence => (),\n+            // Prioritize `ParamEnv` candidates only if they do not guide inference.\n+            //\n+            // This is still incomplete as we may add incorrect region bounds.\n+            SolverMode::Normal => {\n+                let param_env_responses = candidates\n+                    .iter()\n+                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .map(|c| c.result)\n+                    .collect::<Vec<_>>();\n+                if let Some(result) = self.try_merge_responses(&param_env_responses) {\n+                    if result.has_only_region_constraints() {\n+                        return Ok(result);\n                     }\n                 }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                i += 1;\n             }\n-\n-            // If there are *STILL* multiple candidates that have *different* response\n-            // results, give up and report ambiguity.\n-            if candidates.len() > 1 && !candidates.iter().map(|cand| cand.result).all_equal() {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => false,\n         }\n+        self.flounder(&responses)\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/assembly.rs"}, {"sha": "cbec39d82856e2862d6226c8be03e48dd5c970ea", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "renamed", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -11,7 +11,7 @@ use crate::solve::EvalCtxt;\n //\n // For types with an \"existential\" binder, i.e. generator witnesses, we also\n // instantiate the binder with placeholders eagerly.\n-pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -87,7 +87,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     }\n }\n \n-fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n+pub(in crate::solve) fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> ty::Binder<'tcx, Ty<'tcx>> {\n@@ -108,7 +108,7 @@ fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n     ty::Binder::bind_with_vars(ty, bound_vars)\n }\n \n-pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -158,7 +158,7 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     }\n }\n \n-pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -224,7 +224,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n }\n \n // Returns a binder of the tupled inputs types and output type from a builtin callable type.\n-pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+pub(in crate::solve) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     self_ty: Ty<'tcx>,\n     goal_kind: ty::ClosureKind,\n@@ -337,7 +337,13 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n /// additional step of eagerly folding the associated types in the where\n /// clauses of the impl. In this example, that means replacing\n /// `<Self as Foo>::Bar` with `Ty` in the first impl.\n-pub(crate) fn predicates_for_object_candidate<'tcx>(\n+///\n+// FIXME: This is only necessary as `<Self as Trait>::Assoc: ItemBound`\n+// bounds in impls are trivially proven using the item bound candidates.\n+// This is unsound in general and once that is fixed, we don't need to\n+// normalize eagerly here. See https://github.com/lcnr/solver-woes/issues/9\n+// for more details.\n+pub(in crate::solve) fn predicates_for_object_candidate<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,", "previous_filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs"}, {"sha": "28aca76cceb6696633ba7a725a1d4be9655c4c15", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                             // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n                                 Some(this.resolve_vars_if_possible(goal));\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n                             new_goals.goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }"}, {"sha": "861fa0a305ac0184c9beeeab91fa53d58f1e4a85", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         certainty: Certainty,\n     ) -> QueryResult<'tcx> {\n         let goals_certainty = self.try_evaluate_added_goals()?;\n-        let certainty = certainty.unify_and(goals_certainty);\n+        let certainty = certainty.unify_with(goals_certainty);\n \n         let external_constraints = self.compute_external_query_constraints()?;\n "}, {"sha": "19bcbd461447d75c915abbae9b7f8ada593cee9a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -46,6 +46,8 @@ enum SolverMode {\n \n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n+\n+    fn has_only_region_constraints(&self) -> bool;\n }\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n@@ -54,6 +56,11 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n             && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n+\n+    fn has_only_region_constraints(&self) -> bool {\n+        self.value.var_values.is_identity_modulo_regions()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -221,12 +228,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             (Some(alias_lhs), Some(alias_rhs)) => {\n                 debug!(\"both sides are aliases\");\n \n-                let candidates = vec![\n-                    // LHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n-                    // RHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n-                    // Relate via substs\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No).ok(),\n+                );\n+                // RHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n+                );\n+                // Relate via substs\n+                candidates.extend(\n                     self.probe(|ecx| {\n                         let span = tracing::span!(\n                             tracing::Level::DEBUG,\n@@ -247,11 +259,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         }\n \n                         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    }),\n-                ];\n+                    })\n+                    .ok(),\n+                );\n                 debug!(?candidates);\n \n-                self.try_merge_responses(candidates.into_iter())\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    self.flounder(&candidates)\n+                }\n             }\n         }\n     }\n@@ -289,43 +306,51 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n-    #[instrument(level = \"debug\", skip(self, responses))]\n+    /// Try to merge multiple possible ways to prove a goal, if that is not possible returns `None`.\n+    ///\n+    /// In this case we tend to flounder and return ambiguity by calling `[EvalCtxt::flounder]`.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn try_merge_responses(\n         &mut self,\n-        responses: impl Iterator<Item = QueryResult<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n-\n-        if candidates.is_empty() {\n-            return Err(NoSolution);\n+        responses: &[CanonicalResponse<'tcx>],\n+    ) -> Option<CanonicalResponse<'tcx>> {\n+        if responses.is_empty() {\n+            return None;\n         }\n \n         // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n-        let one = candidates[0];\n-        if candidates[1..].iter().all(|resp| resp == &one) {\n-            return Ok(one);\n+        let one = responses[0];\n+        if responses[1..].iter().all(|&resp| resp == one) {\n+            return Some(one);\n         }\n \n-        if let Some(response) = candidates.iter().find(|response| {\n-            response.value.certainty == Certainty::Yes\n-                && response.has_no_inference_or_external_constraints()\n-        }) {\n-            return Ok(*response);\n-        }\n+        responses\n+            .iter()\n+            .find(|response| {\n+                response.value.certainty == Certainty::Yes\n+                    && response.has_no_inference_or_external_constraints()\n+            })\n+            .copied()\n+    }\n \n-        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n-            certainty.unify_and(response.value.certainty)\n+    /// If we fail to merge responses we flounder and return overflow or ambiguity.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn flounder(&mut self, responses: &[CanonicalResponse<'tcx>]) -> QueryResult<'tcx> {\n+        if responses.is_empty() {\n+            return Err(NoSolution);\n+        }\n+        let certainty = responses.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+            certainty.unify_with(response.value.certainty)\n         });\n-        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n-        // responses and use that for the constraints of this ambiguous response.\n-        debug!(\">1 response, bailing with {certainty:?}\");\n+\n         let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n-        if let Ok(response) = &response {\n+        if let Ok(response) = response {\n             assert!(response.has_no_inference_or_external_constraints());\n+            Ok(response)\n+        } else {\n+            bug!(\"failed to make floundered response: {responses:?}\");\n         }\n-\n-        response\n     }\n }\n "}, {"sha": "2a47da81ec760aedea5abcdbd1f9543e7ccf7e89", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::specialization_graph;\n \n-use super::assembly;\n-use super::trait_goals::structural_traits;\n+use super::assembly::{self, structural_traits};\n use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;"}, {"sha": "81f89fd950c8d29e29f2f338ef84ec9ba8ce39d9", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,6 +1,7 @@\n //! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n \n-use super::{assembly, EvalCtxt, SolverMode};\n+use super::assembly::{self, structural_traits};\n+use super::{EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -11,8 +12,6 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n \n-pub mod structural_traits;\n-\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()"}, {"sha": "bcb201bf0c3796bb0a6c9ac3039ae436b86befcf", "filename": "tests/ui/higher-rank-trait-bounds/issue-95230.new.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.new.stderr?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -0,0 +1,18 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-95230.rs:9:13\n+   |\n+LL |     for<'a> &'a mut Self:;\n+   |             ^^^^^^^^^^^^ cannot infer type for mutable reference `&'a mut Bar`\n+   |\n+note: required by a bound in `Bar`\n+  --> $DIR/issue-95230.rs:9:13\n+   |\n+LL | pub struct Bar\n+   |            --- required by a bound in this struct\n+LL | where\n+LL |     for<'a> &'a mut Self:;\n+   |             ^^^^^^^^^^^^ required by this bound in `Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "769b6a9253769a44edf9b1fdc8aa04d3feac63fe", "filename": "tests/ui/higher-rank-trait-bounds/issue-95230.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-95230.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,4 +1,8 @@\n-// check-pass\n+// revisions: old new\n+//[new] compile-flags: -Ztrait-solver=next\n+//[old] check-pass\n+//[new] known-bug: #109764\n+\n \n pub struct Bar\n where"}, {"sha": "531203d9c64f7875366240e5a33d0a1dbf9cfd87", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Ztrait-solver=next\n \n // check that when computing `alias-eq(<() as Foo<u16, T>>::Assoc, <() as Foo<?0, T>>::Assoc)`\n-//  we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n+// we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n // relating substs as either could be a valid solution.\n \n trait Foo<T, STOP> {"}, {"sha": "6f8164f3a40f0aaffec91eb308f1571de92c42e9", "filename": "tests/ui/traits/new-solver/prefer-candidate-no-constraints.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo {}\n+\n+impl<T> Foo for T {}\n+\n+trait Bar {}\n+\n+struct Wrapper<'a, T>(&'a T);\n+\n+impl<'a, T> Bar for Wrapper<'a, T> where &'a T: Foo {}\n+// We need to satisfy `&'a T: Foo` when checking that this impl is WF\n+// that can either be satisfied via the param-env, or via an impl.\n+//\n+// When satisfied via the param-env, since each lifetime is canonicalized\n+// separately, we end up getting extra region constraints.\n+//\n+// However, when satisfied via the impl, there are no region constraints,\n+// and we can short-circuit a response with no external constraints.\n+\n+fn main() {}"}, {"sha": "909b33ec3d5a508b19c1a85c6cac37da9ba2f2b7", "filename": "tests/ui/traits/new-solver/prefer-param-env-on-ambiguity.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo<'a> {}\n+trait Bar<'a> {}\n+\n+impl<'a, T: Bar<'a>> Foo<'a> for T {}\n+impl<T> Bar<'static> for T {}\n+\n+fn main() {}"}, {"sha": "e3a92e85e17e4a846a965cda0d8c4ccf525c08b3", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n   --> $DIR/recursive-self-normalization-2.rs:15:5\n    |\n LL |     needs_bar::<T::Assoc1>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization-2.rs:12:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "773007aebaa63aa0d03236b81dbc7d8c771aae45", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c30d7e97a813cbd9c022227528b1b26ce88e8ddd/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr?ref=c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo>::Assoc: Bar`\n   --> $DIR/recursive-self-normalization.rs:11:5\n    |\n LL |     needs_bar::<T::Assoc>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo>::Assoc: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization.rs:8:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}]}