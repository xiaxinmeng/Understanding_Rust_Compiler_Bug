{"sha": "4961d724f8d02870087c1912a55378458b0d6a90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NjFkNzI0ZjhkMDI4NzAwODdjMTkxMmE1NTM3ODQ1OGIwZDZhOTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-27T13:17:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-27T13:17:55Z"}, "message": "Auto merge of #41507 - arielb1:symbol-cache, r=nikomatsakis\n\ncache symbol names in ty::maps\n\nthis fixes a performance regression introduced in commit 39a58c38a0b9ac9e822a1732f073abe8ddf65cfb.\n\nr? @nikomatsakis", "tree": {"sha": "791b835619b48f4effed28043c855968216cace6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/791b835619b48f4effed28043c855968216cace6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4961d724f8d02870087c1912a55378458b0d6a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4961d724f8d02870087c1912a55378458b0d6a90", "html_url": "https://github.com/rust-lang/rust/commit/4961d724f8d02870087c1912a55378458b0d6a90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4961d724f8d02870087c1912a55378458b0d6a90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79b05fee0fd1423a49e9655d554eec7bfebb0e87", "url": "https://api.github.com/repos/rust-lang/rust/commits/79b05fee0fd1423a49e9655d554eec7bfebb0e87", "html_url": "https://github.com/rust-lang/rust/commit/79b05fee0fd1423a49e9655d554eec7bfebb0e87"}, {"sha": "07b16cb50877b2244255fd3e4ede5bad21dfbce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07b16cb50877b2244255fd3e4ede5bad21dfbce1", "html_url": "https://github.com/rust-lang/rust/commit/07b16cb50877b2244255fd3e4ede5bad21dfbce1"}], "stats": {"total": 567, "additions": 220, "deletions": 347}, "files": [{"sha": "31e6a3106a438890a49d7f960e6b6aad12b1caaf", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -99,6 +99,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckTables(D),\n     UsedTraitImports(D),\n     ConstEval(D),\n+    SymbolName(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -236,6 +237,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             ConstEval(ref d) => op(d).map(ConstEval),\n+            SymbolName(ref d) => op(d).map(SymbolName),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "c80ae87d941ffa96dcc308acfc8d49c85ad364dd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -24,6 +24,7 @@ use std::cell::{RefCell, RefMut};\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax::symbol::Symbol;\n \n trait Key {\n     fn map_crate(&self) -> CrateNum;\n@@ -40,6 +41,16 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for ty::Instance<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl Key for CrateNum {\n     fn map_crate(&self) -> CrateNum {\n         *self\n@@ -108,13 +119,18 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-\n impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         Self::empty()\n     }\n }\n \n+impl<'tcx> Value<'tcx> for ty::SymbolName {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n+    }\n+}\n+\n pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -242,6 +258,12 @@ impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n+        format!(\"computing the symbol for `{}`\", instance)\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -513,7 +535,10 @@ define_maps! { <'tcx>\n \n     pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n+    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    pub def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    pub symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -532,6 +557,12 @@ fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }\n \n+fn symbol_name_dep_node(instance: ty::Instance) -> DepNode<DefId> {\n+    // symbol_name uses the substs only to traverse them to find the\n+    // hash, and that does not create any new dep-nodes.\n+    DepNode::SymbolName(instance.def.def_id())\n+}\n+\n fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::TypeckBodiesKrate\n }"}, {"sha": "de207df7d15eb0baf3aed24a42d7b84a2838843b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -38,6 +38,7 @@ use serialize::{self, Encodable, Encoder};\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n use std::cmp;\n+use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::ops::Deref;\n@@ -2745,3 +2746,22 @@ impl<'tcx> DtorckConstraint<'tcx> {\n         self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n     }\n }\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct SymbolName {\n+    // FIXME: we don't rely on interning or equality here - better have\n+    // this be a `&'tcx str`.\n+    pub name: InternedString\n+}\n+\n+impl Deref for SymbolName {\n+    type Target = str;\n+\n+    fn deref(&self) -> &str { &self.name }\n+}\n+\n+impl fmt::Display for SymbolName {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, fmt)\n+    }\n+}"}, {"sha": "dab2a0758a2176df55fce2128f6ddefc127800a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -225,8 +225,6 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    if ::std::env::var(\"SKIP_LLVM\").is_ok() { ::std::process::exit(0); }\n-\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -895,13 +893,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);"}, {"sha": "ddd86c4679934d79493a9d20e2755e6d0fd1b164", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -10,14 +10,11 @@\n \n use context::SharedCrateContext;\n use monomorphize::Instance;\n-use symbol_map::SymbolMap;\n-use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use syntax::attr;\n-use trans_item::TransItem;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -36,27 +33,24 @@ pub struct ExportedSymbols {\n }\n \n impl ExportedSymbols {\n-\n     pub fn empty() -> ExportedSymbols {\n         ExportedSymbols {\n             exports: FxHashMap(),\n         }\n     }\n \n-    pub fn compute_from<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                  symbol_map: &SymbolMap<'tcx>)\n-                                  -> ExportedSymbols {\n+    pub fn compute<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) -> ExportedSymbols {\n         let mut local_crate: Vec<_> = scx\n             .exported_symbols()\n             .iter()\n             .map(|&node_id| {\n                 scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n+                let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (name, export_level)\n+                (str::to_owned(&name), export_level)\n             })\n             .collect();\n \n@@ -108,7 +102,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx.tcx());\n+                    let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -117,9 +111,9 @@ impl ExportedSymbols {\n                         //\n                         // In general though we won't link right if these\n                         // symbols are stripped, and LTO currently strips them.\n-                        if name == \"rust_eh_personality\" ||\n-                           name == \"rust_eh_register_frames\" ||\n-                           name == \"rust_eh_unregister_frames\" {\n+                        if &*name == \"rust_eh_personality\" ||\n+                           &*name == \"rust_eh_register_frames\" ||\n+                           &*name == \"rust_eh_unregister_frames\" {\n                             SymbolExportLevel::C\n                         } else {\n                             SymbolExportLevel::Rust\n@@ -128,7 +122,7 @@ impl ExportedSymbols {\n                         export_level(scx, def_id)\n                     };\n                     debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (name, export_level)\n+                    (str::to_owned(&name), export_level)\n                 })\n                 .collect();\n \n@@ -213,22 +207,3 @@ pub fn is_below_threshold(level: SymbolExportLevel,\n         level == SymbolExportLevel::C\n     }\n }\n-\n-fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               def_id: DefId,\n-                               symbol_map: &SymbolMap<'tcx>)\n-                               -> String {\n-    // Just try to look things up in the symbol map. If nothing's there, we\n-    // recompute.\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n-            return sym.to_owned();\n-        }\n-    }\n-\n-    let instance = Instance::mono(tcx, def_id);\n-\n-    symbol_map.get(TransItem::Fn(instance))\n-              .map(str::to_owned)\n-              .unwrap_or_else(|| symbol_name(instance, tcx))\n-}"}, {"sha": "aef9140ba4556cf9b14f927daaf13d12bbadc4a7", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -105,14 +105,24 @@ use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n+use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n+use syntax_pos::symbol::Symbol;\n \n use std::fmt::Write;\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        def_symbol_name,\n+        symbol_name,\n+        ..*providers\n+    };\n+}\n+\n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n@@ -127,7 +137,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              // values for generic type parameters,\n                              // if any.\n                              substs: Option<&'tcx Substs<'tcx>>)\n-                             -> String {\n+                             -> u64 {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n     let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n@@ -162,11 +172,28 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    format!(\"h{:016x}\", hasher.finish())\n+    hasher.finish()\n+}\n+\n+fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                             -> ty::SymbolName\n+{\n+    let mut buffer = SymbolPathBuffer::new();\n+    item_path::with_forced_absolute_paths(|| {\n+        tcx.push_item_path(&mut buffer, def_id);\n+    });\n+    buffer.into_interned()\n }\n \n-pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n+                         -> ty::SymbolName\n+{\n+    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_str() }\n+}\n+\n+fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n+    -> String\n+{\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -253,11 +280,7 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    let mut buffer = SymbolPathBuffer::new();\n-    item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id);\n-    });\n-    buffer.finish(&hash)\n+    SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -288,10 +311,22 @@ impl SymbolPathBuffer {\n         result\n     }\n \n-    fn finish(mut self, hash: &str) -> String {\n-        // end name-sequence\n-        self.push(hash);\n-        self.result.push('E');\n+    fn from_interned(symbol: ty::SymbolName) -> Self {\n+        let mut result = SymbolPathBuffer {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16)\n+        };\n+        result.result.push_str(&symbol.name);\n+        result\n+    }\n+\n+    fn into_interned(self) -> ty::SymbolName {\n+        ty::SymbolName { name: Symbol::intern(&self.result).as_str() }\n+    }\n+\n+    fn finish(mut self, hash: u64) -> String {\n+        // E = end name-sequence\n+        let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n }\n@@ -320,7 +355,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let hash = get_symbol_hash(tcx, None, t, None);\n     let mut buffer = SymbolPathBuffer::new();\n     buffer.push(prefix);\n-    buffer.finish(&hash)\n+    buffer.finish(hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but"}, {"sha": "56ff5ebb069ea4a5f044a912fda677f656d726c1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -65,8 +65,6 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n-use symbol_cache::SymbolCache;\n-use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n@@ -804,7 +802,6 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  scx: &SharedCrateContext<'a, 'tcx>,\n                                  translation_items: &FxHashSet<TransItem<'tcx>>,\n                                  llvm_modules: &[ModuleLlvm],\n-                                 symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n         symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n@@ -856,7 +853,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n             let mut linkage_fixed_explicitly = FxHashSet();\n \n             for trans_item in translation_items {\n-                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_name = str::to_owned(&trans_item.symbol_name(tcx));\n                 if trans_item.explicit_linkage(tcx).is_some() {\n                     linkage_fixed_explicitly.insert(symbol_name.clone());\n                 }\n@@ -1110,7 +1107,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n-    let (translation_items, codegen_units, symbol_map) =\n+    let (translation_items, codegen_units) =\n         collect_and_partition_translation_items(&shared_ccx);\n \n     let mut all_stats = Stats::default();\n@@ -1139,8 +1136,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_cache = SymbolCache::new(scx.tcx());\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1175,11 +1171,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, &symbol_cache);\n+        let lcx = LocalCrateContext::new(scx, cgu);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx(), &symbol_cache);\n+                                 .items_in_deterministic_order(ccx.tcx());\n             for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n@@ -1271,8 +1267,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let sess = shared_ccx.sess();\n \n-    let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n-                                                         &symbol_map);\n+    let exported_symbols = ExportedSymbols::compute(&shared_ccx);\n \n     // Get the list of llvm modules we created. We'll do a few wacky\n     // transforms on them now.\n@@ -1292,7 +1287,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             &shared_ccx,\n                             &translation_items,\n                             &llvm_modules,\n-                            &symbol_map,\n                             &exported_symbols);\n     });\n \n@@ -1518,10 +1512,57 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n+    where I: Iterator<Item=&'a TransItem<'tcx>>\n+{\n+    let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n+        (trans_item, trans_item.symbol_name(tcx))\n+    }).collect();\n+\n+    (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n+        sym1.cmp(sym2)\n+    });\n+\n+    for pair in (&symbols[..]).windows(2) {\n+        let sym1 = &pair[0].1;\n+        let sym2 = &pair[1].1;\n+\n+        if *sym1 == *sym2 {\n+            let trans_item1 = pair[0].0;\n+            let trans_item2 = pair[1].0;\n+\n+            let span1 = trans_item1.local_span(tcx);\n+            let span2 = trans_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo.0 > span2.lo.0 {\n+                        span1\n+                    } else {\n+                        span2\n+                    })\n+                }\n+                (Some(span), None) |\n+                (None, Some(span)) => Some(span),\n+                _ => None\n+            };\n+\n+            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, &error_message)\n+            } else {\n+                tcx.sess.fatal(&error_message)\n+            }\n+        }\n+    }\n+}\n+\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (FxHashSet<TransItem<'tcx>>,\n-                                                         Vec<CodegenUnit<'tcx>>,\n-                                                         SymbolMap<'tcx>) {\n+                                                         Vec<CodegenUnit<'tcx>>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -1549,7 +1590,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n             collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n-    let symbol_map = SymbolMap::build(scx, items.iter().cloned());\n+    assert_symbols_are_distinct(scx.tcx(), items.iter());\n \n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n@@ -1622,5 +1663,5 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    (translation_items, codegen_units, symbol_map)\n+    (translation_items, codegen_units)\n }"}, {"sha": "dc788dc4b48342026eab14e1611ed38b2f6dbc39", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -23,7 +23,6 @@ use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use trans_item::TransItem;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -50,7 +49,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = ccx.symbol_cache().get(TransItem::Fn(instance));\n+    let sym = tcx.symbol_name(instance);\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast"}, {"sha": "6afb340107d6661aa1c3a5ad517319757942f887", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use back::symbol_names;\n use llvm;\n use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n@@ -93,8 +91,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = ccx.symbol_cache()\n-                             .get(TransItem::Static(id));\n+                let sym = TransItem::Static(id).symbol_name(ccx.tcx());\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n@@ -113,7 +110,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = symbol_names::symbol_name(instance, ccx.tcx());\n+                let sym = ccx.tcx().symbol_name(instance);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -173,7 +170,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = symbol_names::symbol_name(instance, ccx.tcx());\n+        let sym = ccx.tcx().symbol_name(instance);\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global"}, {"sha": "90cda2f5cad3d582378141b12184d4e5ea05b4a3", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -29,14 +29,14 @@ use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n-use symbol_cache::SymbolCache;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::iter;\n use std::str;\n+use std::marker::PhantomData;\n use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n@@ -94,7 +94,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llcx: ContextRef,\n     stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n-    needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -125,11 +124,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// Mapping from static definitions to their DefId's.\n     statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n-    impl_method_cache: RefCell<FxHashMap<(DefId, ast::Name), DefId>>,\n-\n-    /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<FxHashMap<ValueRef, ValueRef>>,\n-\n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n@@ -141,15 +135,11 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n     type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n \n-    /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n-\n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n@@ -164,7 +154,8 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n \n-    symbol_cache: &'a SymbolCache<'a, 'tcx>,\n+    /// A placeholder so we can add lifetimes\n+    placeholder: PhantomData<&'a ()>,\n }\n \n /// A CrateContext value binds together one LocalCrateContext with the\n@@ -366,8 +357,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>,\n-               symbol_cache: &'a SymbolCache<'a, 'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -396,7 +386,6 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 llcx: llcx,\n                 stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n-                needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -405,25 +394,21 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 const_values: RefCell::new(FxHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 statics: RefCell::new(FxHashMap()),\n-                impl_method_cache: RefCell::new(FxHashMap()),\n-                closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                llsizingtypes: RefCell::new(FxHashMap()),\n                 type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n-                closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 type_of_depth: Cell::new(0),\n                 local_gen_sym_counter: Cell::new(0),\n-                symbol_cache: symbol_cache,\n+                placeholder: PhantomData,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -515,10 +500,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n-        &self.local().needs_unwind_cleanup_cache\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n@@ -554,15 +535,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().statics\n     }\n \n-    pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FxHashMap<(DefId, ast::Name), DefId>> {\n-        &self.local().impl_method_cache\n-    }\n-\n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().closure_bare_wrapper_cache\n-    }\n-\n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n         &self.local().statics_to_rauw\n     }\n@@ -575,10 +547,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n-        &self.local().llsizingtypes\n-    }\n-\n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n@@ -599,10 +567,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().str_slice_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local().closure_vals\n-    }\n-\n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local().dbg_cx\n     }\n@@ -644,10 +608,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn symbol_cache(&self) -> &'b SymbolCache<'b, 'tcx> {\n-        self.local().symbol_cache\n-    }\n-\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {"}, {"sha": "111c2547721663decc75b17ae753e0576c5c204f", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -67,6 +67,7 @@ pub use rustc::lint;\n pub use rustc::util;\n \n pub use base::trans_crate;\n+pub use back::symbol_names::provide;\n \n pub mod back {\n     pub use rustc::hir::svh;\n@@ -125,8 +126,6 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n-mod symbol_cache;\n-mod symbol_map;\n mod symbol_names_test;\n mod trans_item;\n mod tvec;"}, {"sha": "2c76cdeb48cdf7cda90d2699399560d1f5a19057", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -113,10 +113,8 @@ use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc_incremental::IchHasher;\n-use std::cmp::Ordering;\n use std::hash::Hash;\n use std::sync::Arc;\n-use symbol_cache::SymbolCache;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -175,14 +173,13 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>,\n-                                        symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                        scx: &SharedCrateContext<'a, 'tcx>)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n-        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n+        let all_items = self.items_in_deterministic_order(scx.tcx());\n         for (item, _) in all_items {\n-            let symbol_name = symbol_cache.get(item);\n+            let symbol_name = item.symbol_name(scx.tcx());\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             let exported = match item {\n@@ -203,53 +200,30 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn items_in_deterministic_order<'a>(&self,\n-                                            tcx: TyCtxt,\n-                                            symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                             -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n-        let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n-            self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n-\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n-        items.sort_by(|&(trans_item1, _), &(trans_item2, _)| {\n-            let node_id1 = local_node_id(tcx, trans_item1);\n-            let node_id2 = local_node_id(tcx, trans_item2);\n-\n-            match (node_id1, node_id2) {\n-                (None, None) => {\n-                    let symbol_name1 = symbol_cache.get(trans_item1);\n-                    let symbol_name2 = symbol_cache.get(trans_item2);\n-                    symbol_name1.cmp(&symbol_name2)\n-                }\n-                // In the following two cases we can avoid looking up the symbol\n-                (None, Some(_)) => Ordering::Less,\n-                (Some(_), None) => Ordering::Greater,\n-                (Some(node_id1), Some(node_id2)) => {\n-                    let ordering = node_id1.cmp(&node_id2);\n-\n-                    if ordering != Ordering::Equal {\n-                        return ordering;\n-                    }\n-\n-                    let symbol_name1 = symbol_cache.get(trans_item1);\n-                    let symbol_name2 = symbol_cache.get(trans_item2);\n-                    symbol_name1.cmp(&symbol_name2)\n-                }\n-            }\n-        });\n-\n-        return items;\n+        #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+        pub struct ItemSortKey(Option<NodeId>, ty::SymbolName);\n \n-        fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n-            match trans_item {\n+        fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   item: TransItem<'tcx>) -> ItemSortKey {\n+            ItemSortKey(match item {\n                 TransItem::Fn(instance) => {\n                     tcx.hir.as_local_node_id(instance.def_id())\n                 }\n                 TransItem::Static(node_id) | TransItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n-            }\n+            }, item.symbol_name(tcx))\n         }\n+\n+        let items: Vec<_> = self.items.iter().map(|(&i, &l)| (i, l)).collect();\n+        let mut items : Vec<_> = items.iter()\n+            .map(|il| (il, item_sort_key(tcx, il.0))).collect();\n+        items.sort_by(|&(_, ref key1), &(_, ref key2)| key1.cmp(key2));\n+        items.into_iter().map(|(&item_linkage, _)| item_linkage).collect()\n     }\n }\n \n@@ -537,12 +511,11 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n-        let symbol_cache = SymbolCache::new(tcx);\n         for cgu in cgus {\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                let symbol_name = symbol_cache.get(*trans_item);\n+                let symbol_name = trans_item.symbol_name(tcx);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");"}, {"sha": "ddc1ef537a55fcdd4fd575579758efee882301f9", "filename": "src/librustc_trans/symbol_cache.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/79b05fee0fd1423a49e9655d554eec7bfebb0e87/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b05fee0fd1423a49e9655d554eec7bfebb0e87/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=79b05fee0fd1423a49e9655d554eec7bfebb0e87", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::ty::TyCtxt;\n-use std::cell::RefCell;\n-use syntax_pos::symbol::{InternedString, Symbol};\n-use trans_item::TransItem;\n-use util::nodemap::FxHashMap;\n-\n-// In the SymbolCache we collect the symbol names of translation items\n-// and cache them for later reference. This is just a performance\n-// optimization and the cache is populated lazilly; symbol names of\n-// translation items are deterministic and fully defined by the item.\n-// Thus they can always be recomputed if needed.\n-\n-pub struct SymbolCache<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    index: RefCell<FxHashMap<TransItem<'tcx>, Symbol>>,\n-}\n-\n-impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        SymbolCache {\n-            tcx: tcx,\n-            index: RefCell::new(FxHashMap())\n-        }\n-    }\n-\n-    pub fn get(&self, trans_item: TransItem<'tcx>) -> InternedString {\n-        let mut index = self.index.borrow_mut();\n-        index.entry(trans_item)\n-             .or_insert_with(|| Symbol::intern(&trans_item.compute_symbol_name(self.tcx)))\n-             .as_str()\n-    }\n-}"}, {"sha": "9d3e62888a2df1fadb22b8088c4d2a2de74875a2", "filename": "src/librustc_trans/symbol_map.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/79b05fee0fd1423a49e9655d554eec7bfebb0e87/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79b05fee0fd1423a49e9655d554eec7bfebb0e87/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=79b05fee0fd1423a49e9655d554eec7bfebb0e87", "patch": "@@ -1,131 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use context::SharedCrateContext;\n-use monomorphize::Instance;\n-use rustc::ty::TyCtxt;\n-use std::borrow::Cow;\n-use syntax::codemap::Span;\n-use trans_item::TransItem;\n-use util::nodemap::FxHashMap;\n-\n-// In the SymbolMap we collect the symbol names of all translation items of\n-// the current crate. This map exists as a performance optimization. Symbol\n-// names of translation items are deterministic and fully defined by the item.\n-// Thus they could also always be recomputed if needed.\n-\n-pub struct SymbolMap<'tcx> {\n-    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n-    arena: String,\n-}\n-\n-impl<'tcx> SymbolMap<'tcx> {\n-\n-    pub fn build<'a, I>(scx: &SharedCrateContext<'a, 'tcx>,\n-                        trans_items: I)\n-                        -> SymbolMap<'tcx>\n-        where I: Iterator<Item=TransItem<'tcx>>\n-    {\n-        // Check for duplicate symbol names\n-        let tcx = scx.tcx();\n-        let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.compute_symbol_name(tcx))\n-        }).collect();\n-\n-        (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n-            sym1.cmp(sym2)\n-        });\n-\n-        for pair in (&symbols[..]).windows(2) {\n-            let sym1 = &pair[0].1;\n-            let sym2 = &pair[1].1;\n-\n-            if *sym1 == *sym2 {\n-                let trans_item1 = pair[0].0;\n-                let trans_item2 = pair[1].0;\n-\n-                let span1 = get_span(scx.tcx(), trans_item1);\n-                let span2 = get_span(scx.tcx(), trans_item2);\n-\n-                // Deterministically select one of the spans for error reporting\n-                let span = match (span1, span2) {\n-                    (Some(span1), Some(span2)) => {\n-                        Some(if span1.lo.0 > span2.lo.0 {\n-                            span1\n-                        } else {\n-                            span2\n-                        })\n-                    }\n-                    (Some(span), None) |\n-                    (None, Some(span)) => Some(span),\n-                    _ => None\n-                };\n-\n-                let error_message = format!(\"symbol `{}` is already defined\", sym1);\n-\n-                if let Some(span) = span {\n-                    scx.sess().span_fatal(span, &error_message)\n-                } else {\n-                    scx.sess().fatal(&error_message)\n-                }\n-            }\n-        }\n-\n-        let mut symbol_map = SymbolMap {\n-            index: FxHashMap(),\n-            arena: String::with_capacity(1024),\n-        };\n-\n-        for (trans_item, symbol) in symbols {\n-            let start_index = symbol_map.arena.len();\n-            symbol_map.arena.push_str(&symbol[..]);\n-            let end_index = symbol_map.arena.len();\n-            let prev_entry = symbol_map.index.insert(trans_item,\n-                                                     (start_index, end_index));\n-            if prev_entry.is_some() {\n-                bug!(\"TransItem encountered twice?\")\n-            }\n-        }\n-\n-        fn get_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              trans_item: TransItem<'tcx>) -> Option<Span> {\n-            match trans_item {\n-                TransItem::Fn(Instance { def, .. }) => {\n-                    tcx.hir.as_local_node_id(def.def_id())\n-                }\n-                TransItem::Static(node_id) |\n-                TransItem::GlobalAsm(node_id) => {\n-                    Some(node_id)\n-                }\n-            }.map(|node_id| {\n-                tcx.hir.span(node_id)\n-            })\n-        }\n-\n-        symbol_map\n-    }\n-\n-    pub fn get(&self, trans_item: TransItem<'tcx>) -> Option<&str> {\n-        self.index.get(&trans_item).map(|&(start_index, end_index)| {\n-            &self.arena[start_index .. end_index]\n-        })\n-    }\n-\n-    pub fn get_or_compute<'map, 'scx>(&'map self,\n-                                      scx: &SharedCrateContext<'scx, 'tcx>,\n-                                      trans_item: TransItem<'tcx>)\n-                                      -> Cow<'map, str> {\n-        if let Some(sym) = self.get(trans_item) {\n-            Cow::from(sym)\n-        } else {\n-            Cow::from(trans_item.compute_symbol_name(scx.tcx()))\n-        }\n-    }\n-}"}, {"sha": "d96757be9f3a5e046f9ba0f1522e4d36bfe7e879", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -14,7 +14,6 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n@@ -52,7 +51,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = symbol_names::symbol_name(instance, self.tcx);\n+                let name = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "392ee71d52b44c751d44523928293f9549aa53fb", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4961d724f8d02870087c1912a55378458b0d6a90/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=4961d724f8d02870087c1912a55378458b0d6a90", "patch": "@@ -30,8 +30,9 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n use type_of;\n-use back::symbol_names;\n use std::fmt::Write;\n use std::iter;\n \n@@ -118,7 +119,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        let symbol_name = ccx.symbol_cache().get(*self);\n+        let symbol_name = self.symbol_name(ccx.tcx());\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -184,20 +185,34 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    pub fn compute_symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self {\n-            TransItem::Fn(instance) => symbol_names::symbol_name(instance, tcx),\n+            TransItem::Fn(instance) => tcx.symbol_name(instance),\n             TransItem::Static(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n-                symbol_names::symbol_name(Instance::mono(tcx, def_id), tcx)\n+                tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             TransItem::GlobalAsm(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n-                format!(\"global_asm_{:?}\", def_id)\n+                ty::SymbolName {\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n+                }\n             }\n         }\n     }\n \n+    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+        match *self {\n+            TransItem::Fn(Instance { def, .. }) => {\n+                tcx.hir.as_local_node_id(def.def_id())\n+            }\n+            TransItem::Static(node_id) |\n+            TransItem::GlobalAsm(node_id) => {\n+                Some(node_id)\n+            }\n+        }.map(|node_id| tcx.hir.span(node_id))\n+    }\n+\n     pub fn instantiation_mode(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> InstantiationMode {"}]}