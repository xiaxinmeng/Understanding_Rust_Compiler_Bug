{"sha": "ad260ffc884477686e8f6f52c97a417bf99e2f19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMjYwZmZjODg0NDc3Njg2ZThmNmY1MmM5N2E0MTdiZjk5ZTJmMTk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-15T03:42:24Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-15T15:45:24Z"}, "message": "Review comments\n\n- generate error instead of warning\n- remove `RewindPoint` and just keep a copy of `Parser` to rewind state.\n- `dont_parse_generics: bool` -> `parse_generics: bool`\n- remove `eat_lt`\n- move error handling code to separate method", "tree": {"sha": "7e8275f6d5122ca19f88d22d1539a7013ef52e17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e8275f6d5122ca19f88d22d1539a7013ef52e17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad260ffc884477686e8f6f52c97a417bf99e2f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad260ffc884477686e8f6f52c97a417bf99e2f19", "html_url": "https://github.com/rust-lang/rust/commit/ad260ffc884477686e8f6f52c97a417bf99e2f19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad260ffc884477686e8f6f52c97a417bf99e2f19/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46a6af12aa8d688aa52279647b01be6035adf22c", "url": "https://api.github.com/repos/rust-lang/rust/commits/46a6af12aa8d688aa52279647b01be6035adf22c", "html_url": "https://github.com/rust-lang/rust/commit/46a6af12aa8d688aa52279647b01be6035adf22c"}], "stats": {"total": 192, "additions": 83, "deletions": 109}, "files": [{"sha": "3e62f6e33e09a68638f52d6a883816fd06eed078", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 99, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -150,7 +150,7 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n     lhs\n }\n \n-#[derive(PartialEq)]\n+#[derive(Clone, PartialEq)]\n enum PrevTokenKind {\n     DocComment,\n     Comma,\n@@ -162,6 +162,7 @@ enum PrevTokenKind {\n \n /* ident is handled by common.rs */\n \n+#[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n     /// the current token:\n@@ -441,15 +442,6 @@ fn dummy_arg(span: Span) -> Arg {\n     Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n-struct RewindPoint {\n-    token: token::Token,\n-    span: Span,\n-    meta_var_span: Option<Span>,\n-    prev_span: Span,\n-    token_cursor: TokenCursor,\n-    expected_tokens: Vec<TokenType>,\n-}\n-\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n                tokens: TokenStream,\n@@ -798,13 +790,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_lt(&mut self) -> bool {\n-        match self.token {\n-            token::Lt | token::BinOp(token::Shl) => true,\n-            _ => false,\n-        }\n-    }\n-\n     /// Attempt to consume a `<`. If `<<` is seen, replace it with a single\n     /// `<` and continue. If a `<` is not seen, return false.\n     ///\n@@ -1743,7 +1728,7 @@ impl<'a> Parser<'a> {\n \n         let segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons(false)?\n+                self.parse_path_segments_without_colons(true)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1764,14 +1749,14 @@ impl<'a> Parser<'a> {\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, false)\n+        self.parse_path_common(mode, true)\n     }\n \n     pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, true)\n+        self.parse_path_common(mode, false)\n     }\n \n-    fn parse_path_common(&mut self, mode: PathStyle, dont_parse_generics: bool)\n+    fn parse_path_common(&mut self, mode: PathStyle, parse_generics: bool)\n         -> PResult<'a, ast::Path>\n     {\n         maybe_whole!(self, NtPath, |x| x);\n@@ -1784,7 +1769,7 @@ impl<'a> Parser<'a> {\n         // A bound set is a set of type parameter bounds.\n         let mut segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons(dont_parse_generics)?\n+                self.parse_path_segments_without_colons(parse_generics)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1829,7 +1814,7 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self, dont_parse_generics: bool)\n+    pub fn parse_path_segments_without_colons(&mut self, parse_generics: bool)\n         -> PResult<'a, Vec<PathSegment>>\n     {\n         let mut segments = Vec::new();\n@@ -1850,8 +1835,7 @@ impl<'a> Parser<'a> {\n             }\n \n             // Parse types, optionally.\n-            let parameters = if self.is_lt() && !dont_parse_generics {\n-                let _ = self.eat_lt();\n+            let parameters = if parse_generics && self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n                 ast::AngleBracketedParameterData {\n@@ -2832,60 +2816,7 @@ impl<'a> Parser<'a> {\n             if op == AssocOp::As {\n                 // Save the state of the parser before parsing type normally, in case there is a\n                 // LessThan comparison after this cast.\n-                let rp = self.get_rewind_point();\n-                match self.parse_ty_no_plus() {\n-                    Ok(rhs) => {\n-                        lhs = self.mk_expr(lhs_span.to(rhs.span),\n-                                           ExprKind::Cast(lhs, rhs), ThinVec::new());\n-                    }\n-                    Err(mut err) => {\n-                        // Rewind to before attempting to parse the type with generics, to get\n-                        // arround #22644.\n-                        let rp_err = self.get_rewind_point();\n-                        let sp = rp_err.span.clone();\n-                        self.rewind(rp);\n-                        let lo = self.span;\n-                        let path = match self.parse_path_without_generics(PathStyle::Type) {\n-                            Ok(path) => {\n-                                // Successfully parsed the type leaving a `<` yet to parse\n-                                err.cancel();\n-                                let codemap = self.sess.codemap();\n-                                let suggestion_span = lhs_span.to(self.prev_span);\n-                                let suggestion = match codemap.span_to_snippet(suggestion_span) {\n-                                    Ok(lstring) => format!(\"({})\", lstring),\n-                                    _ => format!(\"(<expression>)\")\n-                                };\n-                                let warn_message = match codemap.span_to_snippet(self.prev_span) {\n-                                    Ok(lstring) => format!(\"`{}`\", lstring),\n-                                    _ => \"a type\".to_string(),\n-                                };\n-                                let msg = format!(\"`<` is interpreted as a start of generic \\\n-                                                   arguments for {}, not a comparison\",\n-                                                  warn_message);\n-                                let mut warn = self.sess.span_diagnostic.struct_span_warn(sp, &msg);\n-                                warn.span_label(sp, \"interpreted as generic argument\");\n-                                warn.span_label(self.span, \"not interpreted as comparison\");\n-                                warn.span_suggestion(suggestion_span,\n-                                                    \"if you want to compare the casted value \\\n-                                                     then write:\",\n-                                                    suggestion);\n-                                warn.emit();\n-                                path\n-                            }\n-                            Err(mut path_err) => {\n-                                // Still couldn't parse, return original error and parser state\n-                                path_err.cancel();\n-                                self.rewind(rp_err);\n-                                return Err(err);\n-                            }\n-                        };\n-                        let path = TyKind::Path(None, path);\n-                        let span = lo.to(self.prev_span);\n-                        let rhs = P(Ty { node: path, span: span, id: ast::DUMMY_NODE_ID });\n-                        lhs = self.mk_expr(lhs_span.to(rhs.span),\n-                                           ExprKind::Cast(lhs, rhs), ThinVec::new());\n-                    }\n-                };\n+                lhs = self.parse_assoc_op_as(lhs, lhs_span)?;\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty_no_plus()?;\n@@ -2983,6 +2914,67 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n+    fn parse_assoc_op_as(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n+        let rp = self.clone();\n+        match self.parse_ty_no_plus() {\n+            Ok(rhs) => {\n+                Ok(self.mk_expr(lhs_span.to(rhs.span),\n+                                ExprKind::Cast(lhs, rhs),\n+                                ThinVec::new()))\n+            }\n+            Err(mut err) => {\n+                let rp_err = self.clone();\n+                let sp = rp_err.span.clone();\n+\n+                // Rewind to before attempting to parse the type with generics, to get\n+                // arround #22644.\n+                mem::replace(self, rp);\n+                let lo = self.span;\n+                match self.parse_path_without_generics(PathStyle::Type) {\n+                    Ok(path) => {\n+                        // Successfully parsed the type leaving a `<` yet to parse\n+                        err.cancel();\n+                        let codemap = self.sess.codemap();\n+                        let suggestion_span = lhs_span.to(self.prev_span);\n+                        let suggestion = match codemap.span_to_snippet(suggestion_span) {\n+                            Ok(lstring) => format!(\"({})\", lstring),\n+                            _ => format!(\"(<expression> as <type>)\")\n+                        };\n+                        let warn_message = match codemap.span_to_snippet(self.prev_span) {\n+                            Ok(lstring) => format!(\"`{}`\", lstring),\n+                            _ => \"a type\".to_string(),\n+                        };\n+                        let msg = format!(\"`<` is interpreted as a start of generic \\\n+                                           arguments for {}, not a comparison\",\n+                                          warn_message);\n+                        let mut err = self.sess.span_diagnostic.struct_span_err(sp, &msg);\n+                        err.span_label(sp, \"interpreted as generic argument\");\n+                        err.span_label(self.span, \"not interpreted as comparison\");\n+                        err.span_suggestion(suggestion_span,\n+                                            \"if you want to compare the casted value then write:\",\n+                                            suggestion);\n+                        err.emit();\n+\n+                        let path = TyKind::Path(None, path);\n+                        let span = lo.to(self.prev_span);\n+                        let rhs = P(Ty { node: path, span: span, id: ast::DUMMY_NODE_ID });\n+                        // Letting the parser accept the recovered type to avoid further errors,\n+                        // but the code will still not compile due to the error emitted above.\n+                        Ok(self.mk_expr(lhs_span.to(rhs.span),\n+                                        ExprKind::Cast(lhs, rhs),\n+                                        ThinVec::new()))\n+                    }\n+                    Err(mut path_err) => {\n+                        // Still couldn't parse, return original error and parser state\n+                        path_err.cancel();\n+                        mem::replace(self, rp_err);\n+                        Err(err)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n@@ -6264,24 +6256,4 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n-\n-    fn get_rewind_point(&mut self) -> RewindPoint {\n-        RewindPoint {\n-            token: self.token.clone(),\n-            span: self.span,\n-            meta_var_span: self.meta_var_span,\n-            prev_span: self.prev_span,\n-            token_cursor: self.token_cursor.clone(),\n-            expected_tokens: self.expected_tokens.clone(),\n-        }\n-    }\n-\n-    fn rewind(&mut self, rp: RewindPoint) {\n-        self.token = rp.token;\n-        self.span = rp.span;\n-        self.meta_var_span = rp.meta_var_span;\n-        self.prev_span = rp.prev_span;\n-        self.token_cursor = rp.token_cursor;\n-        self.expected_tokens = rp.expected_tokens;\n-    }\n }"}, {"sha": "b60201c251dcc4ac73ccb74db6718d9495753157", "filename": "src/test/parse-fail/better-expected.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbetter-expected.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let x: [isize 3]; //~ ERROR expected one of `!`, `(`, `+`, `::`, `;`, or `]`, found `3`\n+    let x: [isize 3]; //~ ERROR expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `3`\n }"}, {"sha": "9dc5d8277446da21481249c159983e2e0f6648ac", "filename": "src/test/parse-fail/bounds-type-where.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fbounds-type-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fbounds-type-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbounds-type-where.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -18,6 +18,6 @@ type A where T: Trait + Trait = u8; // OK\n type A where = u8; // OK\n type A where T: Trait + = u8; // OK\n type A where T, = u8;\n-//~^ ERROR expected one of `!`, `(`, `+`, `::`, `:`, `==`, or `=`, found `,`\n+//~^ ERROR expected one of `!`, `(`, `+`, `::`, `:`, `<`, `==`, or `=`, found `,`\n \n fn main() {}"}, {"sha": "1da6735918012f11be58ef6b620cbaec9b8ca17e", "filename": "src/test/parse-fail/closure-return-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -13,5 +13,5 @@\n \n fn main() {\n     let x = || -> i32 22;\n-    //~^ ERROR expected one of `!`, `(`, `::`, or `{`, found `22`\n+    //~^ ERROR expected one of `!`, `(`, `::`, `<`, or `{`, found `22`\n }"}, {"sha": "9939f1e36ea9dccc9a47437f5b01acc813e2006d", "filename": "src/test/parse-fail/empty-impl-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-impl Foo; //~ ERROR expected one of `!`, `(`, `+`, `::`, `for`, `where`, or `{`, found `;`\n+impl Foo; //~ ERROR expected one of `!`, `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `;`"}, {"sha": "b7c9b1658846627cc3d19b7fc55e209001334bd9", "filename": "src/test/parse-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmultitrait.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -15,7 +15,7 @@ struct S {\n }\n \n impl Cmp, ToString for S {\n-//~^ ERROR: expected one of `!`, `(`, `+`, `::`, `for`, `where`, or `{`, found `,`\n+//~^ ERROR: expected one of `!`, `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `,`\n   fn eq(&&other: S) { false }\n   fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "b305b1894a810f94f2caf7f7778a4a587c2e728b", "filename": "src/test/parse-fail/removed-syntax-closure-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-closure-lifetime.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -11,4 +11,4 @@\n // compile-flags: -Z parse-only\n \n type closure = Box<lt/fn()>;\n-//~^ ERROR expected one of `!`, `(`, `+`, `,`, `::`, or `>`, found `/`\n+//~^ ERROR expected one of `!`, `(`, `+`, `,`, `::`, `<`, or `>`, found `/`"}, {"sha": "0f34db08852022a42f6b942635c17aa1408cb417", "filename": "src/test/parse-fail/removed-syntax-fixed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-fixed-vec.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type v = [isize * 3]; //~ ERROR expected one of `!`, `(`, `+`, `::`, `;`, or `]`, found `*`\n+type v = [isize * 3]; //~ ERROR expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `*`"}, {"sha": "b91ab8730b3dccfb83e4be47a47f9ed1d2bac5b3", "filename": "src/test/parse-fail/removed-syntax-ptr-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type bptr = &lifetime/isize; //~ ERROR expected one of `!`, `(`, `::`, or `;`, found `/`\n+type bptr = &lifetime/isize; //~ ERROR expected one of `!`, `(`, `::`, `;`, or `<`, found `/`"}, {"sha": "a22496357d9915f12528a5839f563744fdfff490", "filename": "src/test/ui/issue-22644.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fui%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad260ffc884477686e8f6f52c97a417bf99e2f19/src%2Ftest%2Fui%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22644.stderr?ref=ad260ffc884477686e8f6f52c97a417bf99e2f19", "patch": "@@ -1,4 +1,4 @@\n-warning: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n+error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:16:33\n    |\n 16 |     println!(\"{}\", a as usize < b);\n@@ -9,7 +9,7 @@ warning: `<` is interpreted as a start of generic arguments for `usize`, not a c\n help: if you want to compare the casted value then write:\n    |     println!(\"{}\", (a as usize) < b);\n \n-warning: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n+error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:17:33\n    |\n 17 |     println!(\"{}\", a as usize < 4);\n@@ -20,3 +20,5 @@ warning: `<` is interpreted as a start of generic arguments for `usize`, not a c\n help: if you want to compare the casted value then write:\n    |     println!(\"{}\", (a as usize) < 4);\n \n+error: aborting due to previous error(s)\n+"}]}