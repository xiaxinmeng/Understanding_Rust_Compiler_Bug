{"sha": "3042321b3bf6bc9435c274f278798871959ce58b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDIzMjFiM2JmNmJjOTQzNWMyNzRmMjc4Nzk4ODcxOTU5Y2U1OGI=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-03-19T12:52:10Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-03-19T22:44:41Z"}, "message": "syntax: split deriving module into submodules for each trait", "tree": {"sha": "7208ab0a4b7ee893fb36dfe68392a81c598bb3e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7208ab0a4b7ee893fb36dfe68392a81c598bb3e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3042321b3bf6bc9435c274f278798871959ce58b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3042321b3bf6bc9435c274f278798871959ce58b", "html_url": "https://github.com/rust-lang/rust/commit/3042321b3bf6bc9435c274f278798871959ce58b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3042321b3bf6bc9435c274f278798871959ce58b/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a594f49af6c0541cd78146600b30f7208ed146", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a594f49af6c0541cd78146600b30f7208ed146", "html_url": "https://github.com/rust-lang/rust/commit/18a594f49af6c0541cd78146600b30f7208ed146"}], "stats": {"total": 2039, "additions": 1062, "deletions": 977}, "files": [{"sha": "447ca71dc6b9fa77bd1622c0150cfe0df0aee9c3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3042321b3bf6bc9435c274f278798871959ce58b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -153,13 +153,13 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::deriving::expand_meta_deriving)));\n     syntax_expanders.insert(@~\"deriving_eq\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_eq)));\n+                                ext::deriving::eq::expand_deriving_eq)));\n     syntax_expanders.insert(@~\"deriving_iter_bytes\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_iter_bytes)));\n+                                ext::deriving::iter_bytes::expand_deriving_iter_bytes)));\n     syntax_expanders.insert(@~\"deriving_clone\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_clone)));\n+                                ext::deriving::clone::expand_deriving_clone)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(@~\"quote_tokens\","}, {"sha": "072cd0f6c39b2f249732a50a01a4bea98f5b595d", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=3042321b3bf6bc9435c274f278798871959ce58b", "patch": "@@ -0,0 +1,289 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_clone(cx: @ext_ctxt,\n+                             span: span,\n+                             _: @meta_item,\n+                             in_items: ~[@item])\n+                          -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_clone_struct_def,\n+                    expand_deriving_clone_enum_def)\n+}\n+\n+fn create_derived_clone_impl(cx: @ext_ctxt,\n+                             span: span,\n+                             type_ident: ident,\n+                             generics: &Generics,\n+                             method: @method)\n+                          -> @item {\n+    let methods = [ method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"clone\"),\n+        cx.ident_of(~\"Clone\"),\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+// Creates a method from the given expression conforming to the signature of\n+// the `clone` method.\n+fn create_clone_method(cx: @ext_ctxt,\n+                       span: span,\n+                       +type_ident: ast::ident,\n+                       generics: &Generics,\n+                       expr: @ast::expr)\n+                    -> @method {\n+    // Create the type parameters of the return value.\n+    let mut output_ty_params = ~[];\n+    for generics.ty_params.each |ty_param| {\n+        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n+        output_ty_params.push(path);\n+    }\n+\n+    // Create the type of the return value.\n+    let output_type_path = build::mk_raw_path_(span,\n+                                               ~[ type_ident ],\n+                                               output_ty_params);\n+    let output_type = ast::ty_path(output_type_path, cx.next_id());\n+    let output_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: output_type,\n+        span: span\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = build::mk_fn_decl(~[], output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, expr);\n+\n+    // Create the self type and method identifier.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"clone\");\n+\n+    // Create the method.\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public,\n+    }\n+}\n+\n+fn call_substructure_clone_method(cx: @ext_ctxt,\n+                                  span: span,\n+                                  self_field: @expr)\n+                               -> @expr {\n+    // Call the substructure method.\n+    let clone_ident = cx.ident_of(~\"clone\");\n+    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n+    build::mk_call_(cx, span, self_method, ~[])\n+}\n+\n+fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    type_ident: ident,\n+                                    generics: &Generics)\n+                                 -> @item {\n+    // Create the method.\n+    let method = if !is_struct_tuple(struct_def) {\n+        expand_deriving_clone_struct_method(cx,\n+                                            span,\n+                                            struct_def,\n+                                            type_ident,\n+                                            generics)\n+    } else {\n+        expand_deriving_clone_tuple_struct_method(cx,\n+                                                  span,\n+                                                  struct_def,\n+                                                  type_ident,\n+                                                  generics)\n+    };\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n+fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  type_ident: ident,\n+                                  generics: &Generics)\n+                               -> @item {\n+    // Create the method.\n+    let method = expand_deriving_clone_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   type_ident,\n+                                                   generics);\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n+fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n+                                       span: span,\n+                                       struct_def: &struct_def,\n+                                       type_ident: ident,\n+                                       generics: &Generics)\n+                                    -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the new fields.\n+    let mut fields = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let call = call_substructure_clone_method(cx,\n+                                                          span,\n+                                                          self_field);\n+\n+                let field = build::Field { ident: ident, ex: call };\n+                fields.push(field);\n+            }\n+            unnamed_field => {\n+                cx.span_bug(span,\n+                            ~\"unnamed fields in \\\n+                              expand_deriving_clone_struct_method\");\n+            }\n+        }\n+    }\n+\n+    // Create the struct literal.\n+    let struct_literal = build::mk_struct_e(cx,\n+                                            span,\n+                                            ~[ type_ident ],\n+                                            fields);\n+    create_clone_method(cx, span, type_ident, generics, struct_literal)\n+}\n+\n+fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n+                                             span: span,\n+                                             struct_def: &struct_def,\n+                                             type_ident: ident,\n+                                             generics: &Generics)\n+                                          -> @method {\n+    // Create the pattern for the match.\n+    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n+    let field_count = struct_def.fields.len();\n+    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n+    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n+\n+    // Create the new fields.\n+    let mut subcalls = ~[];\n+    for uint::range(0, struct_def.fields.len()) |i| {\n+        // Create the expression for this field.\n+        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+        let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+        // Call the substructure method.\n+        let subcall = call_substructure_clone_method(cx, span, field);\n+        subcalls.push(subcall);\n+    }\n+\n+    // Create the call to the struct constructor.\n+    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n+\n+    // Create the pattern body.\n+    let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+    // Create the arm.\n+    let arm = ast::arm {\n+        pats: ~[ pat ],\n+        guard: None,\n+        body: match_body_block\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}\n+\n+fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n+                                     span: span,\n+                                     enum_definition: &enum_def,\n+                                     type_ident: ident,\n+                                     generics: &Generics)\n+                                  -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.map |variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Iterate over the variant arguments, creating the subcalls.\n+        let mut subcalls = ~[];\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let subcall = call_substructure_clone_method(cx, span, field);\n+            subcalls.push(subcall);\n+        }\n+\n+        // Create the call to the enum variant (if necessary).\n+        let call = if subcalls.len() > 0 {\n+            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n+        } else {\n+            build::mk_path(cx, span, ~[ variant.node.name ])\n+        };\n+\n+        // Create the pattern body.\n+        let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+        // Create the arm.\n+        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}"}, {"sha": "6213eeca13461e37f66c39557c0d9324d080c259", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=3042321b3bf6bc9435c274f278798871959ce58b", "patch": "@@ -0,0 +1,498 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+enum Junction {\n+    Conjunction,\n+    Disjunction,\n+}\n+\n+pub impl Junction {\n+    fn to_binop(self) -> binop {\n+        match self {\n+            Conjunction => and,\n+            Disjunction => or,\n+        }\n+    }\n+}\n+\n+pub fn expand_deriving_eq(cx: @ext_ctxt,\n+                          span: span,\n+                          _mitem: @meta_item,\n+                          in_items: ~[@item])\n+                       -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_eq_struct_def,\n+                    expand_deriving_eq_enum_def)\n+}\n+\n+/// Creates a method from the given expression, the signature of which\n+/// conforms to the `eq` or `ne` method.\n+fn create_eq_method(cx: @ext_ctxt,\n+                    span: span,\n+                    method_ident: ident,\n+                    type_ident: ident,\n+                    generics: &Generics,\n+                    body: @expr)\n+                 -> @method {\n+    // Create the type of the `other` parameter.\n+    let arg_path_type = create_self_type_with_params(cx,\n+                                                     span,\n+                                                     type_ident,\n+                                                     generics);\n+    let arg_type = ty_rptr(\n+        None,\n+        ast::mt { ty: arg_path_type, mutbl: m_imm }\n+    );\n+    let arg_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: arg_type,\n+        span: span,\n+    };\n+\n+    // Create the `other` parameter.\n+    let other_ident = cx.ident_of(~\"__other\");\n+    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n+\n+    // Create the type of the return value.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n+    let output_type = ty_path(output_type, cx.next_id());\n+    let output_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: output_type,\n+        span: span,\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, body);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn create_derived_eq_impl(cx: @ext_ctxt,\n+                          span: span,\n+                          type_ident: ident,\n+                          generics: &Generics,\n+                          eq_method: @method,\n+                          ne_method: @method)\n+                       -> @item {\n+    let methods = [ eq_method, ne_method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"cmp\"),\n+        cx.ident_of(~\"Eq\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+\n+fn call_substructure_eq_method(cx: @ext_ctxt,\n+                               span: span,\n+                               self_field: @expr,\n+                               other_field_ref: @expr,\n+                               method_ident: ident,\n+                               junction: Junction,\n+                               chain_expr: &mut Option<@expr>) {\n+    // Call the substructure method.\n+    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ other_field_ref ]);\n+\n+    // Connect to the outer expression if necessary.\n+    *chain_expr = match *chain_expr {\n+        None => Some(self_call),\n+        Some(copy old_outer_expr) => {\n+            let binop = junction.to_binop();\n+            let chain_expr = build::mk_binary(cx,\n+                                              span,\n+                                              binop,\n+                                              old_outer_expr,\n+                                              self_call);\n+            Some(chain_expr)\n+        }\n+    };\n+}\n+\n+fn finish_eq_chain_expr(cx: @ext_ctxt,\n+                        span: span,\n+                        chain_expr: Option<@expr>,\n+                        junction: Junction)\n+                     -> @expr {\n+    match chain_expr {\n+        None => {\n+            match junction {\n+                Conjunction => build::mk_bool(cx, span, true),\n+                Disjunction => build::mk_bool(cx, span, false),\n+            }\n+        }\n+        Some(ref outer_expr) => *outer_expr,\n+    }\n+}\n+\n+fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n+                                 span: span,\n+                                 struct_def: &struct_def,\n+                                 type_ident: ident,\n+                                 generics: &Generics)\n+                              -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+\n+    let derive_struct_fn = if is_struct_tuple(struct_def) {\n+        expand_deriving_eq_struct_tuple_method\n+    } else {\n+        expand_deriving_eq_struct_method\n+    };\n+\n+    let eq_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     eq_ident,\n+                                     type_ident,\n+                                     generics,\n+                                     Conjunction);\n+    let ne_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     ne_ident,\n+                                     type_ident,\n+                                     generics,\n+                                     Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  generics,\n+                                  eq_method,\n+                                  ne_method);\n+}\n+\n+fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n+                               span: span,\n+                               enum_definition: &enum_def,\n+                               type_ident: ident,\n+                               generics: &Generics)\n+                            -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+    let eq_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   eq_ident,\n+                                                   type_ident,\n+                                                   generics,\n+                                                   Conjunction);\n+    let ne_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   ne_ident,\n+                                                   type_ident,\n+                                                   generics,\n+                                                   Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  generics,\n+                                  eq_method,\n+                                  ne_method);\n+}\n+\n+fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    method_ident: ident,\n+                                    type_ident: ident,\n+                                    generics: &Generics,\n+                                    junction: Junction)\n+                                 -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    // Create the body of the method.\n+    let mut outer_expr = None;\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for the other field.\n+                let other_field = build::mk_access(cx,\n+                                                   span,\n+                                                   ~[ other_ident ],\n+                                                   ident);\n+                let other_field_ref = build::mk_addr_of(cx,\n+                                                        span,\n+                                                        other_field);\n+\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                call_substructure_eq_method(cx,\n+                                            span,\n+                                            self_field,\n+                                            other_field_ref,\n+                                            method_ident,\n+                                            junction,\n+                                            &mut outer_expr);\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            generics,\n+                            body);\n+}\n+\n+fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  method_ident: ident,\n+                                  type_ident: ident,\n+                                  generics: &Generics,\n+                                  junction: Junction)\n+                               -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    let is_eq;\n+    match junction {\n+        Conjunction => is_eq = true,\n+        Disjunction => is_eq = false,\n+    }\n+\n+    // Create the arms of the self match in the method body.\n+    let mut self_arms = ~[];\n+    for enum_definition.variants.each |self_variant| {\n+        let mut other_arms = ~[];\n+\n+        // Create the matching pattern.\n+        let matching_pat = create_enum_variant_pattern(cx,\n+                                                       span,\n+                                                       self_variant,\n+                                                       ~\"__other\");\n+\n+        // Create the matching pattern body.\n+        let mut matching_body_expr = None;\n+        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n+            // Create the expression for the other field.\n+            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n+            let other_field = build::mk_path(cx,\n+                                             span,\n+                                             ~[ other_field_ident ]);\n+\n+            // Create the expression for this field.\n+            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+            // Call the substructure method.\n+            call_substructure_eq_method(cx,\n+                                        span,\n+                                        self_field,\n+                                        other_field,\n+                                        method_ident,\n+                                        junction,\n+                                        &mut matching_body_expr);\n+        }\n+\n+        let matching_body_expr = finish_eq_chain_expr(cx,\n+                                                      span,\n+                                                      matching_body_expr,\n+                                                      junction);\n+        let matching_body_block = build::mk_simple_block(cx,\n+                                                         span,\n+                                                         matching_body_expr);\n+\n+        // Create the matching arm.\n+        let matching_arm = ast::arm {\n+            pats: ~[ matching_pat ],\n+            guard: None,\n+            body: matching_body_block\n+        };\n+        other_arms.push(matching_arm);\n+\n+        // Maybe generate a non-matching case. If there is only one\n+        // variant then there will always be a match.\n+        if enum_definition.variants.len() > 1 {\n+            // Create the nonmatching pattern.\n+            let nonmatching_pat = @ast::pat {\n+                id: cx.next_id(),\n+                node: pat_wild,\n+                span: span\n+            };\n+\n+            // Create the nonmatching pattern body.\n+            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n+            let nonmatching_body_block =\n+                build::mk_simple_block(cx,\n+                                       span,\n+                                       nonmatching_expr);\n+\n+            // Create the nonmatching arm.\n+            let nonmatching_arm = ast::arm {\n+                pats: ~[ nonmatching_pat ],\n+                guard: None,\n+                body: nonmatching_body_block,\n+            };\n+            other_arms.push(nonmatching_arm);\n+        }\n+\n+        // Create the self pattern.\n+        let self_pat = create_enum_variant_pattern(cx,\n+                                                   span,\n+                                                   self_variant,\n+                                                   ~\"__self\");\n+\n+        // Create the self pattern body.\n+        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n+        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+        let other_match_expr = expr_match(other_expr, other_arms);\n+        let other_match_expr = build::mk_expr(cx,\n+                                              span,\n+                                              other_match_expr);\n+        let other_match_body_block = build::mk_simple_block(cx,\n+                                                            span,\n+                                                            other_match_expr);\n+\n+        // Create the self arm.\n+        let self_arm = ast::arm {\n+            pats: ~[ self_pat ],\n+            guard: None,\n+            body: other_match_body_block,\n+        };\n+        self_arms.push(self_arm);\n+    }\n+\n+    // Create the method body.\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, self_arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+\n+    // Create the method.\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            generics,\n+                            self_match_expr);\n+}\n+\n+fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n+                                          span: span,\n+                                          struct_def: &struct_def,\n+                                          method_ident: ident,\n+                                          type_ident: ident,\n+                                          generics: &Generics,\n+                                          junction: Junction)\n+                                        -> @method {\n+    let self_str = ~\"self\";\n+    let other_str = ~\"__other\";\n+    let type_path = build::mk_raw_path(span, ~[type_ident]);\n+    let fields = copy struct_def.fields;\n+\n+    // Create comparison expression, comparing each of the fields\n+    let mut match_body = None;\n+    for fields.eachi |i, _| {\n+        let other_field_ident = cx.ident_of(other_str + i.to_str());\n+        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n+\n+        let self_field_ident = cx.ident_of(self_str + i.to_str());\n+        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+        call_substructure_eq_method(cx, span, self_field, other_field,\n+            method_ident, junction, &mut match_body);\n+    }\n+    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n+\n+    // Create arm for the '__other' match, containing the comparison expr\n+    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n+    let other_arm = ast::arm {\n+        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, match_body),\n+    };\n+\n+    // Create the match on '__other'\n+    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n+    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n+    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n+\n+    // Create arm for the 'self' match, which contains the '__other' match\n+    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n+    let self_arm = ast::arm {\n+        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, other_match_expr),\n+    };\n+\n+    // Create the match on 'self'\n+    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+\n+    create_eq_method(cx, span, method_ident,\n+        type_ident, generics, self_match_expr)\n+}"}, {"sha": "613e9c295eb74db978dbafe8986bea73b4dae6cb", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3042321b3bf6bc9435c274f278798871959ce58b", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n+                                  span: span,\n+                                  _mitem: @meta_item,\n+                                  in_items: ~[@item])\n+                               -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_iter_bytes_struct_def,\n+                    expand_deriving_iter_bytes_enum_def)\n+}\n+\n+fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n+                                  span: span,\n+                                  type_ident: ident,\n+                                  generics: &Generics,\n+                                  method: @method)\n+                               -> @item {\n+    let methods = [ method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"to_bytes\"),\n+        cx.ident_of(~\"IterBytes\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `iter_bytes` method.\n+fn create_iter_bytes_method(cx: @ext_ctxt,\n+                            span: span,\n+                            +statements: ~[@stmt])\n+                         -> @method {\n+    // Create the `lsb0` parameter.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n+\n+    // Create the `f` parameter.\n+    let core_ident = cx.ident_of(~\"core\");\n+    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n+    let cb_ident = cx.ident_of(~\"Cb\");\n+    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n+    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+\n+    // Create the function declaration.\n+    let inputs = ~[ lsb0_arg, f_arg ];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_block_(cx, span, statements);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"iter_bytes\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n+                                       span: span,\n+                                       self_field: @expr)\n+                                    -> @stmt {\n+    // Gather up the parameters we want to chain along.\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n+    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n+\n+    // Call the substructure method.\n+    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n+    let self_method = build::mk_access_(cx,\n+                                        span,\n+                                        self_field,\n+                                        iter_bytes_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ lsb0_expr, f_expr ]);\n+\n+    // Create a statement out of this expression.\n+    build::mk_stmt(cx, span, self_call)\n+}\n+\n+fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n+                                         span: span,\n+                                         struct_def: &struct_def,\n+                                         type_ident: ident,\n+                                         generics: &Generics)\n+                                      -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_struct_method(cx,\n+                                                          span,\n+                                                          struct_def);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          generics,\n+                                          method);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n+                                       span: span,\n+                                       enum_definition: &enum_def,\n+                                       type_ident: ident,\n+                                       generics: &Generics)\n+                                    -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_enum_method(cx,\n+                                                        span,\n+                                                        enum_definition);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          generics,\n+                                          method);\n+}\n+\n+fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n+                                            span: span,\n+                                            struct_def: &struct_def)\n+                                         -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the body of the method.\n+    let mut statements = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               self_field);\n+                statements.push(stmt);\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span,\n+                               ~\"unnamed fields with `deriving_iter_bytes`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    return create_iter_bytes_method(cx, span, statements);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n+                                          span: span,\n+                                          enum_definition: &enum_def)\n+                                       -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Determine the discriminant. We will feed this value to the byte\n+        // iteration function.\n+        let discriminant;\n+        match variant.node.disr_expr {\n+            Some(copy disr_expr) => discriminant = disr_expr,\n+            None => discriminant = build::mk_uint(cx, span, i),\n+        }\n+\n+        // Feed the discriminant to the byte iteration function.\n+        let mut stmts = ~[];\n+        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               discriminant);\n+        stmts.push(discrim_stmt);\n+\n+        // Feed each argument in this variant to the byte iteration function\n+        // as well.\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n+            stmts.push(stmt);\n+        }\n+\n+        // Create the pattern body.\n+        let match_body_block = build::mk_block_(cx, span, stmts);\n+\n+        // Create the arm.\n+        ast::arm {\n+            pats: ~[ pat ],\n+            guard: None,\n+            body: match_body_block,\n+        }\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n+    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n+\n+    // Create the method.\n+    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n+}"}, {"sha": "63bb4389999696101b98c551a7c3051aa247edb4", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 15, "deletions": 973, "changes": 988, "blob_url": "https://github.com/rust-lang/rust/blob/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3042321b3bf6bc9435c274f278798871959ce58b/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=3042321b3bf6bc9435c274f278798871959ce58b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -26,24 +26,13 @@ use ext::base::ext_ctxt;\n use ext::build;\n use codemap::{span, spanned};\n use parse::token::special_idents::clownshoes_extensions;\n-use ast_util;\n use opt_vec;\n \n use core::uint;\n \n-enum Junction {\n-    Conjunction,\n-    Disjunction,\n-}\n-\n-pub impl Junction {\n-    fn to_binop(self) -> binop {\n-        match self {\n-            Conjunction => and,\n-            Disjunction => or,\n-        }\n-    }\n-}\n+pub mod clone;\n+pub mod eq;\n+pub mod iter_bytes;\n \n type ExpandDerivingStructDefFn = &'self fn(@ext_ctxt,\n                                           span,\n@@ -79,11 +68,11 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                     meta_list(tname, _) |\n                     meta_word(tname) => {\n                         match *tname {\n-                            ~\"Clone\" => expand_deriving_clone(cx,\n+                            ~\"Clone\" => clone::expand_deriving_clone(cx,\n                                 titem.span, titem, in_items),\n-                            ~\"Eq\" => expand_deriving_eq(cx, titem.span,\n+                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n                                 titem, in_items),\n-                            ~\"IterBytes\" => expand_deriving_iter_bytes(cx,\n+                            ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n                                 titem.span, titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n@@ -98,43 +87,7 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n     }\n }\n \n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n-                          span: span,\n-                          _mitem: @meta_item,\n-                          in_items: ~[@item])\n-                       -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_eq_struct_def,\n-                    expand_deriving_eq_enum_def)\n-}\n-\n-pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n-                                  span: span,\n-                                  _mitem: @meta_item,\n-                                  in_items: ~[@item])\n-                               -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_iter_bytes_struct_def,\n-                    expand_deriving_iter_bytes_enum_def)\n-}\n-\n-pub fn expand_deriving_clone(cx: @ext_ctxt,\n-                             span: span,\n-                             _: @meta_item,\n-                             in_items: ~[@item])\n-                          -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_clone_struct_def,\n-                    expand_deriving_clone_enum_def)\n-}\n-\n-fn expand_deriving(cx: @ext_ctxt,\n+pub fn expand_deriving(cx: @ext_ctxt,\n                    span: span,\n                    in_items: ~[@item],\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n@@ -175,68 +128,7 @@ fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n     }\n }\n \n-/// Creates a method from the given expression, the signature of which\n-/// conforms to the `eq` or `ne` method.\n-fn create_eq_method(cx: @ext_ctxt,\n-                    span: span,\n-                    method_ident: ident,\n-                    type_ident: ident,\n-                    generics: &Generics,\n-                    body: @expr)\n-                 -> @method {\n-    // Create the type of the `other` parameter.\n-    let arg_path_type = create_self_type_with_params(cx,\n-                                                     span,\n-                                                     type_ident,\n-                                                     generics);\n-    let arg_type = ty_rptr(\n-        None,\n-        ast::mt { ty: arg_path_type, mutbl: m_imm }\n-    );\n-    let arg_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: arg_type,\n-        span: span,\n-    };\n-\n-    // Create the `other` parameter.\n-    let other_ident = cx.ident_of(~\"__other\");\n-    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n-\n-    // Create the type of the return value.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n-    let output_type = ty_path(output_type, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span,\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, body);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn create_self_type_with_params(cx: @ext_ctxt,\n+pub fn create_self_type_with_params(cx: @ext_ctxt,\n                                 span: span,\n                                 type_ident: ident,\n                                 generics: &Generics)\n@@ -258,7 +150,7 @@ fn create_self_type_with_params(cx: @ext_ctxt,\n     @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n }\n \n-fn create_derived_impl(cx: @ext_ctxt,\n+pub fn create_derived_impl(cx: @ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n                        generics: &Generics,\n@@ -320,154 +212,7 @@ fn create_derived_impl(cx: @ext_ctxt,\n     return create_impl_item(cx, span, impl_item);\n }\n \n-fn create_derived_eq_impl(cx: @ext_ctxt,\n-                          span: span,\n-                          type_ident: ident,\n-                          generics: &Generics,\n-                          eq_method: @method,\n-                          ne_method: @method)\n-                       -> @item {\n-    let methods = [ eq_method, ne_method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"cmp\"),\n-        cx.ident_of(~\"Eq\")\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n-                                  span: span,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  method: @method)\n-                               -> @item {\n-    let methods = [ method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"to_bytes\"),\n-        cx.ident_of(~\"IterBytes\")\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-fn create_derived_clone_impl(cx: @ext_ctxt,\n-                             span: span,\n-                             type_ident: ident,\n-                             generics: &Generics,\n-                             method: @method)\n-                          -> @item {\n-    let methods = [ method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"clone\"),\n-        cx.ident_of(~\"Clone\"),\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `iter_bytes` method.\n-fn create_iter_bytes_method(cx: @ext_ctxt,\n-                            span: span,\n-                            +statements: ~[@stmt])\n-                         -> @method {\n-    // Create the `lsb0` parameter.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n-\n-    // Create the `f` parameter.\n-    let core_ident = cx.ident_of(~\"core\");\n-    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n-    let cb_ident = cx.ident_of(~\"Cb\");\n-    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n-    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n-\n-    // Create the function declaration.\n-    let inputs = ~[ lsb0_arg, f_arg ];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_block_(cx, span, statements);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"iter_bytes\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-// Creates a method from the given expression conforming to the signature of\n-// the `clone` method.\n-fn create_clone_method(cx: @ext_ctxt,\n-                       span: span,\n-                       +type_ident: ast::ident,\n-                       generics: &Generics,\n-                       expr: @ast::expr)\n-                    -> @method {\n-    // Create the type parameters of the return value.\n-    let mut output_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n-        output_ty_params.push(path);\n-    }\n-\n-    // Create the type of the return value.\n-    let output_type_path = build::mk_raw_path_(span,\n-                                               ~[ type_ident ],\n-                                               output_ty_params);\n-    let output_type = ast::ty_path(output_type_path, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n-\n-    // Create the self type and method identifier.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"clone\");\n-\n-    // Create the method.\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public,\n-    }\n-}\n-\n-fn create_subpatterns(cx: @ext_ctxt,\n+pub fn create_subpatterns(cx: @ext_ctxt,\n                       span: span,\n                       prefix: ~str,\n                       n: uint)\n@@ -487,7 +232,7 @@ fn create_subpatterns(cx: @ext_ctxt,\n     return subpats;\n }\n \n-fn is_struct_tuple(struct_def: &struct_def) -> bool {\n+pub fn is_struct_tuple(struct_def: &struct_def) -> bool {\n     struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n         match f.node.kind {\n             named_field(*) => false,\n@@ -496,7 +241,7 @@ fn is_struct_tuple(struct_def: &struct_def) -> bool {\n     })\n }\n \n-fn create_enum_variant_pattern(cx: @ext_ctxt,\n+pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n                                span: span,\n                                variant: &variant,\n                                prefix: ~str)\n@@ -542,87 +287,7 @@ fn create_enum_variant_pattern(cx: @ext_ctxt,\n     }\n }\n \n-fn call_substructure_eq_method(cx: @ext_ctxt,\n-                               span: span,\n-                               self_field: @expr,\n-                               other_field_ref: @expr,\n-                               method_ident: ident,\n-                               junction: Junction,\n-                               chain_expr: &mut Option<@expr>) {\n-    // Call the substructure method.\n-    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ other_field_ref ]);\n-\n-    // Connect to the outer expression if necessary.\n-    *chain_expr = match *chain_expr {\n-        None => Some(self_call),\n-        Some(copy old_outer_expr) => {\n-            let binop = junction.to_binop();\n-            let chain_expr = build::mk_binary(cx,\n-                                              span,\n-                                              binop,\n-                                              old_outer_expr,\n-                                              self_call);\n-            Some(chain_expr)\n-        }\n-    };\n-}\n-\n-fn finish_eq_chain_expr(cx: @ext_ctxt,\n-                        span: span,\n-                        chain_expr: Option<@expr>,\n-                        junction: Junction)\n-                     -> @expr {\n-    match chain_expr {\n-        None => {\n-            match junction {\n-                Conjunction => build::mk_bool(cx, span, true),\n-                Disjunction => build::mk_bool(cx, span, false),\n-            }\n-        }\n-        Some(ref outer_expr) => *outer_expr,\n-    }\n-}\n-\n-fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       self_field: @expr)\n-                                    -> @stmt {\n-    // Gather up the parameters we want to chain along.\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n-    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n-\n-    // Call the substructure method.\n-    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n-    let self_method = build::mk_access_(cx,\n-                                        span,\n-                                        self_field,\n-                                        iter_bytes_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ lsb0_expr, f_expr ]);\n-\n-    // Create a statement out of this expression.\n-    build::mk_stmt(cx, span, self_call)\n-}\n-\n-fn call_substructure_clone_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  self_field: @expr)\n-                               -> @expr {\n-    // Call the substructure method.\n-    let clone_ident = cx.ident_of(~\"clone\");\n-    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n-    build::mk_call_(cx, span, self_method, ~[])\n-}\n-\n-fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n+pub fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n         tuple_variant_kind(ref args) => args.len(),\n         struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n@@ -632,530 +297,7 @@ fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n     }\n }\n \n-fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n-                                 span: span,\n-                                 struct_def: &struct_def,\n-                                 type_ident: ident,\n-                                 generics: &Generics)\n-                              -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-\n-    let derive_struct_fn = if is_struct_tuple(struct_def) {\n-        expand_deriving_eq_struct_tuple_method\n-    } else {\n-        expand_deriving_eq_struct_method\n-    };\n-\n-    let eq_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     eq_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Conjunction);\n-    let ne_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     ne_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               type_ident: ident,\n-                               generics: &Generics)\n-                            -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   eq_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Conjunction);\n-    let ne_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   ne_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n-                                         span: span,\n-                                         struct_def: &struct_def,\n-                                         type_ident: ident,\n-                                         generics: &Generics)\n-                                      -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_struct_method(cx,\n-                                                          span,\n-                                                          struct_def);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n-                                       span: span,\n-                                       enum_definition: &enum_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_enum_method(cx,\n-                                                        span,\n-                                                        enum_definition);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-                                 -> @item {\n-    // Create the method.\n-    let method = if !is_struct_tuple(struct_def) {\n-        expand_deriving_clone_struct_method(cx,\n-                                            span,\n-                                            struct_def,\n-                                            type_ident,\n-                                            generics)\n-    } else {\n-        expand_deriving_clone_tuple_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  type_ident,\n-                                                  generics)\n-    };\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  type_ident: ident,\n-                                  generics: &Generics)\n-                               -> @item {\n-    // Create the method.\n-    let method = expand_deriving_clone_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   type_ident,\n-                                                   generics);\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    method_ident: ident,\n-                                    type_ident: ident,\n-                                    generics: &Generics,\n-                                    junction: Junction)\n-                                 -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    // Create the body of the method.\n-    let mut outer_expr = None;\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for the other field.\n-                let other_field = build::mk_access(cx,\n-                                                   span,\n-                                                   ~[ other_ident ],\n-                                                   ident);\n-                let other_field_ref = build::mk_addr_of(cx,\n-                                                        span,\n-                                                        other_field);\n-\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                call_substructure_eq_method(cx,\n-                                            span,\n-                                            self_field,\n-                                            other_field_ref,\n-                                            method_ident,\n-                                            junction,\n-                                            &mut outer_expr);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            body);\n-}\n-\n-fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n-                                            span: span,\n-                                            struct_def: &struct_def)\n-                                         -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the body of the method.\n-    let mut statements = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                let stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               self_field);\n-                statements.push(stmt);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span,\n-                               ~\"unnamed fields with `deriving_iter_bytes`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    return create_iter_bytes_method(cx, span, statements);\n-}\n-\n-fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       struct_def: &struct_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the new fields.\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                let call = call_substructure_clone_method(cx,\n-                                                          span,\n-                                                          self_field);\n-\n-                let field = build::Field { ident: ident, ex: call };\n-                fields.push(field);\n-            }\n-            unnamed_field => {\n-                cx.span_bug(span,\n-                            ~\"unnamed fields in \\\n-                              expand_deriving_clone_struct_method\");\n-            }\n-        }\n-    }\n-\n-    // Create the struct literal.\n-    let struct_literal = build::mk_struct_e(cx,\n-                                            span,\n-                                            ~[ type_ident ],\n-                                            fields);\n-    create_clone_method(cx, span, type_ident, generics, struct_literal)\n-}\n-\n-fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n-                                             span: span,\n-                                             struct_def: &struct_def,\n-                                             type_ident: ident,\n-                                             generics: &Generics)\n-                                          -> @method {\n-    // Create the pattern for the match.\n-    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n-    let field_count = struct_def.fields.len();\n-    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n-    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n-\n-    // Create the new fields.\n-    let mut subcalls = ~[];\n-    for uint::range(0, struct_def.fields.len()) |i| {\n-        // Create the expression for this field.\n-        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-        let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-        // Call the substructure method.\n-        let subcall = call_substructure_clone_method(cx, span, field);\n-        subcalls.push(subcall);\n-    }\n-\n-    // Create the call to the struct constructor.\n-    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n-\n-    // Create the pattern body.\n-    let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-    // Create the arm.\n-    let arm = ast::arm {\n-        pats: ~[ pat ],\n-        guard: None,\n-        body: match_body_block\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  method_ident: ident,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  junction: Junction)\n-                               -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    let is_eq;\n-    match junction {\n-        Conjunction => is_eq = true,\n-        Disjunction => is_eq = false,\n-    }\n-\n-    // Create the arms of the self match in the method body.\n-    let mut self_arms = ~[];\n-    for enum_definition.variants.each |self_variant| {\n-        let mut other_arms = ~[];\n-\n-        // Create the matching pattern.\n-        let matching_pat = create_enum_variant_pattern(cx,\n-                                                       span,\n-                                                       self_variant,\n-                                                       ~\"__other\");\n-\n-        // Create the matching pattern body.\n-        let mut matching_body_expr = None;\n-        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n-            // Create the expression for the other field.\n-            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n-            let other_field = build::mk_path(cx,\n-                                             span,\n-                                             ~[ other_field_ident ]);\n-\n-            // Create the expression for this field.\n-            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-            // Call the substructure method.\n-            call_substructure_eq_method(cx,\n-                                        span,\n-                                        self_field,\n-                                        other_field,\n-                                        method_ident,\n-                                        junction,\n-                                        &mut matching_body_expr);\n-        }\n-\n-        let matching_body_expr = finish_eq_chain_expr(cx,\n-                                                      span,\n-                                                      matching_body_expr,\n-                                                      junction);\n-        let matching_body_block = build::mk_simple_block(cx,\n-                                                         span,\n-                                                         matching_body_expr);\n-\n-        // Create the matching arm.\n-        let matching_arm = ast::arm {\n-            pats: ~[ matching_pat ],\n-            guard: None,\n-            body: matching_body_block\n-        };\n-        other_arms.push(matching_arm);\n-\n-        // Maybe generate a non-matching case. If there is only one\n-        // variant then there will always be a match.\n-        if enum_definition.variants.len() > 1 {\n-            // Create the nonmatching pattern.\n-            let nonmatching_pat = @ast::pat {\n-                id: cx.next_id(),\n-                node: pat_wild,\n-                span: span\n-            };\n-\n-            // Create the nonmatching pattern body.\n-            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n-            let nonmatching_body_block =\n-                build::mk_simple_block(cx,\n-                                       span,\n-                                       nonmatching_expr);\n-\n-            // Create the nonmatching arm.\n-            let nonmatching_arm = ast::arm {\n-                pats: ~[ nonmatching_pat ],\n-                guard: None,\n-                body: nonmatching_body_block,\n-            };\n-            other_arms.push(nonmatching_arm);\n-        }\n-\n-        // Create the self pattern.\n-        let self_pat = create_enum_variant_pattern(cx,\n-                                                   span,\n-                                                   self_variant,\n-                                                   ~\"__self\");\n-\n-        // Create the self pattern body.\n-        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n-        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_match_expr = expr_match(other_expr, other_arms);\n-        let other_match_expr = build::mk_expr(cx,\n-                                              span,\n-                                              other_match_expr);\n-        let other_match_body_block = build::mk_simple_block(cx,\n-                                                            span,\n-                                                            other_match_expr);\n-\n-        // Create the self arm.\n-        let self_arm = ast::arm {\n-            pats: ~[ self_pat ],\n-            guard: None,\n-            body: other_match_body_block,\n-        };\n-        self_arms.push(self_arm);\n-    }\n-\n-    // Create the method body.\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            self_match_expr);\n-}\n-\n-fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          struct_def: &struct_def,\n-                                          method_ident: ident,\n-                                          type_ident: ident,\n-                                          generics: &Generics,\n-                                          junction: Junction)\n-                                        -> @method {\n-    let self_str = ~\"self\";\n-    let other_str = ~\"__other\";\n-    let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = copy struct_def.fields;\n-\n-    // Create comparison expression, comparing each of the fields\n-    let mut match_body = None;\n-    for fields.eachi |i, _| {\n-        let other_field_ident = cx.ident_of(other_str + i.to_str());\n-        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n-\n-        let self_field_ident = cx.ident_of(self_str + i.to_str());\n-        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-        call_substructure_eq_method(cx, span, self_field, other_field,\n-            method_ident, junction, &mut match_body);\n-    }\n-    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n-\n-    // Create arm for the '__other' match, containing the comparison expr\n-    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n-    let other_arm = ast::arm {\n-        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, match_body),\n-    };\n-\n-    // Create the match on '__other'\n-    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n-    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n-    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n-\n-    // Create arm for the 'self' match, which contains the '__other' match\n-    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n-    let self_arm = ast::arm {\n-        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, other_match_expr),\n-    };\n-\n-    // Create the match on 'self'\n-    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    create_eq_method(cx, span, method_ident,\n-        type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_enum_or_struct_match(cx: @ext_ctxt,\n+pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n@@ -1165,103 +307,3 @@ fn expand_enum_or_struct_match(cx: @ext_ctxt,\n     let self_match_expr = expr_match(self_expr, arms);\n     build::mk_expr(cx, span, self_match_expr)\n }\n-\n-fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          enum_definition: &enum_def)\n-                                       -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.mapi |i, variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Determine the discriminant. We will feed this value to the byte\n-        // iteration function.\n-        let discriminant;\n-        match variant.node.disr_expr {\n-            Some(copy disr_expr) => discriminant = disr_expr,\n-            None => discriminant = build::mk_uint(cx, span, i),\n-        }\n-\n-        // Feed the discriminant to the byte iteration function.\n-        let mut stmts = ~[];\n-        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               discriminant);\n-        stmts.push(discrim_stmt);\n-\n-        // Feed each argument in this variant to the byte iteration function\n-        // as well.\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n-            stmts.push(stmt);\n-        }\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_block_(cx, span, stmts);\n-\n-        // Create the arm.\n-        ast::arm {\n-            pats: ~[ pat ],\n-            guard: None,\n-            body: match_body_block,\n-        }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n-}\n-\n-fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n-                                     span: span,\n-                                     enum_definition: &enum_def,\n-                                     type_ident: ident,\n-                                     generics: &Generics)\n-                                  -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.map |variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Iterate over the variant arguments, creating the subcalls.\n-        let mut subcalls = ~[];\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let subcall = call_substructure_clone_method(cx, span, field);\n-            subcalls.push(subcall);\n-        }\n-\n-        // Create the call to the enum variant (if necessary).\n-        let call = if subcalls.len() > 0 {\n-            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n-        } else {\n-            build::mk_path(cx, span, ~[ variant.node.name ])\n-        };\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-        // Create the arm.\n-        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-"}]}