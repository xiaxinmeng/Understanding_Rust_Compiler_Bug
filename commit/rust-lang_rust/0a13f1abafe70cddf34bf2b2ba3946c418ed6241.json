{"sha": "0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTNmMWFiYWZlNzBjZGRmMzRiZjJiMmJhMzk0NmM0MThlZDYyNDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-31T15:51:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-12-09T15:19:17Z"}, "message": "std: Rename thread::catch_panic to panic::recover\n\nThis commit is an implementation of [RFC 1236] and [RFC 1323] which\nrename the `thread::catch_panic` function to `panic::recover` while also\nreplacing the `Send + 'static` bounds with a new `PanicSafe` bound.\n\n[RFC 1236]: https://github.com/rust-lang/rfcs/pull/1236\n[RFC 1323]: https://github.com/rust-lang/rfcs/pull/1323\n\ncc #27719", "tree": {"sha": "83dc0df06aa7029c29aa4655e332e15b5f47929e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83dc0df06aa7029c29aa4655e332e15b5f47929e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "html_url": "https://github.com/rust-lang/rust/commit/0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8864f2c83ac800881da34c3e835c931c081a8785", "url": "https://api.github.com/repos/rust-lang/rust/commits/8864f2c83ac800881da34c3e835c931c081a8785", "html_url": "https://github.com/rust-lang/rust/commit/8864f2c83ac800881da34c3e835c931c081a8785"}], "stats": {"total": 507, "additions": 462, "deletions": 45}, "files": [{"sha": "8e6c32ff2fce29b4514fd83e5b4a2159715e2bab", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -248,13 +248,15 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n+#![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n #![feature(range_inclusive)]\n #![feature(raw)]\n #![feature(reflect_marker)]\n+#![feature(shared)]\n #![feature(slice_bytes)]\n #![feature(slice_concat_ext)]\n #![feature(slice_patterns)]\n@@ -424,6 +426,7 @@ pub mod fs;\n pub mod io;\n pub mod net;\n pub mod os;\n+pub mod panic;\n pub mod path;\n pub mod process;\n pub mod sync;"}, {"sha": "6e4ba337b08ee4817eeb4af6a80680d9cf06f61a", "filename": "src/libstd/panic.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,255 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Panic support in the standard library\n+\n+#![unstable(feature = \"std_panic\", reason = \"awaiting feedback\",\n+            issue = \"27719\")]\n+\n+use cell::UnsafeCell;\n+use ops::{Deref, DerefMut};\n+use ptr::{Unique, Shared};\n+use rc::Rc;\n+use sync::{Arc, Mutex, RwLock};\n+use sys_common::unwind;\n+use thread::Result;\n+\n+/// A marker trait which represents \"panic safe\" types in Rust.\n+///\n+/// This trait is implemented by default for many types and behaves similarly in\n+/// terms of inference of implementation to the `Send` and `Sync` traits. The\n+/// purpose of this trait is to encode what types are safe to cross a `recover`\n+/// boundary with no fear of panic safety.\n+///\n+/// ## What is panic safety?\n+///\n+/// In Rust a function can \"return\" early if it either panics or calls a\n+/// function which transitively panics. This sort of control flow is not always\n+/// anticipated, and has the possibility of causing subtle bugs through a\n+/// combination of two cricial components:\n+///\n+/// 1. A data structure is in a temporarily invalid state when the thread\n+///    panics.\n+/// 2. This broken invariant is then later observed.\n+///\n+/// Typically in Rust it is difficult to perform step (2) because catching a\n+/// panic involves either spawning a thread (which in turns makes it difficult\n+/// to later witness broken invariants) or using the `recover` function in this\n+/// module. Additionally, even if an invariant is witness, it typically isn't a\n+/// problem in Rust because there's no uninitialized values (like in C or C++).\n+///\n+/// It is possible, however, for **logical** invariants to be broken in Rust,\n+/// which can end up causing behavioral bugs. Another key aspect of panic safety\n+/// in Rust is that in the absence of `unsafe` code, a panic cannot lead to\n+/// memory unsafety.\n+///\n+/// That was a bit of a whirlwind tour of panic safety, but for more information\n+/// about panic safety and how it applies to Rust, see an [associated RFC][rfc].\n+///\n+/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n+///\n+/// ## What is `RecoverSafe`?\n+///\n+/// Now that we've got an idea of what panic safety is in Rust, it's also\n+/// important to understand that this trait represents. As mentioned above, one\n+/// way to witness broken invariants is through the `recover` function in this\n+/// module as it allows catching a panic and then re-using the environment of\n+/// the closure.\n+///\n+/// Simply but, a type `T` implements `RecoverSafe` if it cannot easily allow\n+/// witnessing a broken invariant through the use of `recover` (catching a\n+/// panic). This trait is a marker trait, so it is automatically implemented for\n+/// many types, and it is also structurally composed (e.g. a struct is recover\n+/// safe if all of its components are recover safe).\n+///\n+/// Note, however, that this is not an unsafe trait, so there is not a succinct\n+/// contract that this trait is providing. Instead it is intended as more of a\n+/// \"speed bump\" to alert users of `recover` that broken invariants may be\n+/// witnessed and may need to be accounted for.\n+///\n+/// ## Who implements `RecoverSafe`?\n+///\n+/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n+/// recover safe. The general idea is that any mutable state which can be shared\n+/// across `recover` is not recover safe by default. This is because it is very\n+/// easy to witness a broken invariant outside of `recover` as the data is\n+/// simply accesed as usual.\n+///\n+/// Types like `&Mutex<T>`, however, are recover safe because they implement\n+/// poisoning by default. They still allow witnessing a broken invariant, but\n+/// they already provide their own \"speed bumps\" to do so.\n+///\n+/// ## When should `RecoverSafe` be used?\n+///\n+/// Is not intended that most types or functions need to worry about this trait.\n+/// It is only used as a bound on the `recover` function and as mentioned above,\n+/// the lack of `unsafe` means it is mostly an advisory. The `AssertRecoverSafe`\n+/// wrapper struct in this module can be used to force this trait to be\n+/// implemented for any closed over variables passed to the `recover` function\n+/// (more on this below).\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[rustc_on_unimplemented = \"the type {Self} may not be safely transferred \\\n+                            across a recover boundary\"]\n+pub trait RecoverSafe {}\n+\n+/// A marker trait representing types which do not contain an `UnsafeCell` by\n+/// value internally.\n+///\n+/// This is a \"helper marker trait\" used to provide impl blocks for the\n+/// `RecoverSafe` trait, for more information see that documentation.\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[rustc_on_unimplemented = \"the type {Self} contains interior mutability \\\n+                            and a reference may not be safely transferrable \\\n+                            across a recover boundary\"]\n+pub trait NoUnsafeCell {}\n+\n+/// A simple wrapper around a type to assert that it is panic safe.\n+///\n+/// When using `recover` it may be the case that some of the closed over\n+/// variables are not panic safe. For example if `&mut T` is captured the\n+/// compiler will generate a warning indicating that it is not panic safe. It\n+/// may not be the case, however, that this is actually a problem due to the\n+/// specific usage of `recover` if panic safety is specifically taken into\n+/// account. This wrapper struct is useful for a quick and lightweight\n+/// annotation that a variable is indeed panic safe.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(recover, std_panic)]\n+///\n+/// use std::panic::{self, AssertRecoverSafe};\n+///\n+/// let mut variable = 4;\n+///\n+/// // This code will not compile becuause the closure captures `&mut variable`\n+/// // which is not considered panic safe by default.\n+///\n+/// // panic::recover(|| {\n+/// //     variable += 3;\n+/// // });\n+///\n+/// // This, however, will compile due to the `AssertRecoverSafe` wrapper\n+/// let result = {\n+///     let mut wrapper = AssertRecoverSafe::new(&mut variable);\n+///     panic::recover(move || {\n+///         **wrapper += 3;\n+///     })\n+/// };\n+/// // ...\n+/// ```\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+pub struct AssertRecoverSafe<T>(T);\n+\n+// Implementations of the `RecoverSafe` trait:\n+//\n+// * By default everything is recover safe\n+// * pointers T contains mutability of some form are not recover safe\n+// * Unique, an owning pointer, lifts an implementation\n+// * Types like Mutex/RwLock which are explicilty poisoned are recover safe\n+// * Our custom AssertRecoverSafe wrapper is indeed recover safe\n+impl RecoverSafe for .. {}\n+impl<'a, T: ?Sized> !RecoverSafe for &'a mut T {}\n+impl<'a, T: NoUnsafeCell + ?Sized> RecoverSafe for &'a T {}\n+impl<T: NoUnsafeCell + ?Sized> RecoverSafe for *const T {}\n+impl<T: NoUnsafeCell + ?Sized> RecoverSafe for *mut T {}\n+impl<T: RecoverSafe> RecoverSafe for Unique<T> {}\n+impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Shared<T> {}\n+impl<T: ?Sized> RecoverSafe for Mutex<T> {}\n+impl<T: ?Sized> RecoverSafe for RwLock<T> {}\n+impl<T> RecoverSafe for AssertRecoverSafe<T> {}\n+\n+// not covered via the Shared impl above b/c the inner contents use\n+// Cell/AtomicUsize, but the usage here is recover safe so we can lift the\n+// impl up one level to Arc/Rc itself\n+impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Rc<T> {}\n+impl<T: NoUnsafeCell + ?Sized> RecoverSafe for Arc<T> {}\n+\n+// Pretty simple implementations for the `NoUnsafeCell` marker trait, basically\n+// just saying that this is a marker trait and `UnsafeCell` is the only thing\n+// which doesn't implement it (which then transitively applies to everything\n+// else.\n+impl NoUnsafeCell for .. {}\n+impl<T: ?Sized> !NoUnsafeCell for UnsafeCell<T> {}\n+\n+impl<T> AssertRecoverSafe<T> {\n+    /// Creates a new `AssertRecoverSafe` wrapper around the provided type.\n+    #[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+    pub fn new(t: T) -> AssertRecoverSafe<T> {\n+        AssertRecoverSafe(t)\n+    }\n+}\n+\n+impl<T> Deref for AssertRecoverSafe<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T> DerefMut for AssertRecoverSafe<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n+\n+/// Invokes a closure, capturing the cause of panic if one occurs.\n+///\n+/// This function will return `Ok` with the closure's result if the closure\n+/// does not panic, and will return `Err(cause)` if the closure panics. The\n+/// `cause` returned is the object with which panic was originally invoked.\n+///\n+/// It is currently undefined behavior to unwind from Rust code into foreign\n+/// code, so this function is particularly useful when Rust is called from\n+/// another language (normally C). This can run arbitrary Rust code, capturing a\n+/// panic and allowing a graceful handling of the error.\n+///\n+/// It is **not** recommended to use this function for a general try/catch\n+/// mechanism. The `Result` type is more appropriate to use for functions that\n+/// can fail on a regular basis.\n+///\n+/// The closure provided is required to adhere to the `RecoverSafe` to ensure\n+/// that all captured variables are safe to cross this recover boundary. The\n+/// purpose of this bound is to encode the concept of [exception safety][rfc] in\n+/// the type system. Most usage of this function should not need to worry about\n+/// this bound as programs are naturally panic safe without `unsafe` code. If it\n+/// becomes a problem the associated `AssertRecoverSafe` wrapper type in this\n+/// module can be used to quickly assert that the usage here is indeed exception\n+/// safe.\n+///\n+/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(recover, std_panic)]\n+///\n+/// use std::panic;\n+///\n+/// let result = panic::recover(|| {\n+///     println!(\"hello!\");\n+/// });\n+/// assert!(result.is_ok());\n+///\n+/// let result = panic::recover(|| {\n+///     panic!(\"oh no!\");\n+/// });\n+/// assert!(result.is_err());\n+/// ```\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+pub fn recover<F: FnOnce() -> R + RecoverSafe, R>(f: F) -> Result<R> {\n+    let mut result = None;\n+    unsafe {\n+        let result = &mut result;\n+        try!(unwind::try(move || *result = Some(f())))\n+    }\n+    Ok(result.unwrap())\n+}"}, {"sha": "63fb9b561ff32fc6fcf93c7c4ba6bbdde405eb0f", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -24,10 +24,11 @@\n \n use borrow::ToOwned;\n use mem;\n+use panic;\n use sys;\n use sys_common::thread_info::{self, NewThread};\n use sys_common;\n-use thread::{self, Thread};\n+use thread::Thread;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use sys_common::unwind::{begin_unwind, begin_unwind_fmt};\n@@ -57,7 +58,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         sys_common::args::init(argc, argv);\n \n         // Let's run some code!\n-        let res = thread::catch_panic(mem::transmute::<_, fn()>(main));\n+        let res = panic::recover(mem::transmute::<_, fn()>(main));\n         sys_common::cleanup();\n         res.is_err()\n     };"}, {"sha": "d4f04d5d94f1fa8cde373c471fb3ce60bac88d75", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -355,26 +355,9 @@ pub fn panicking() -> bool {\n /// with exception safety. Furthermore, a `Send` bound is also required,\n /// providing the same safety guarantees as `thread::spawn` (ensuring the\n /// closure is properly isolated from the parent).\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(catch_panic)]\n-///\n-/// use std::thread;\n-///\n-/// let result = thread::catch_panic(|| {\n-///     println!(\"hello!\");\n-/// });\n-/// assert!(result.is_ok());\n-///\n-/// let result = thread::catch_panic(|| {\n-///     panic!(\"oh no!\");\n-/// });\n-/// assert!(result.is_err());\n-/// ```\n #[unstable(feature = \"catch_panic\", reason = \"recent API addition\",\n            issue = \"27719\")]\n+#[rustc_deprecated(since = \"1.6.0\", reason = \"renamed to std::panic::recover\")]\n pub fn catch_panic<F, R>(f: F) -> Result<R>\n     where F: FnOnce() -> R + Send + 'static\n {"}, {"sha": "47a65505d8a3de0a6f342ab696e7763a91dcf9ac", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<Rc<RefCell<i32>>>(); //~ ERROR: is not implemented\n+    //~^ ERROR: is not implemented\n+}\n+"}, {"sha": "a0c7865eeb01c041cf86929ffb9295c96a4c7992", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::sync::Arc;\n+use std::cell::RefCell;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<Arc<RefCell<i32>>>(); //~ ERROR: is not implemented\n+    //~^ ERROR: is not implemented\n+}"}, {"sha": "9e716131525c968e65e8ede0d577f6b0ea6810b8", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::cell::RefCell;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<&RefCell<i32>>(); //~ ERROR: is not implemented\n+    //~^ ERROR is not implemented\n+}"}, {"sha": "1fa76c21f853d1923b7fad1067cfe1a0d6c0748b", "filename": "src/test/compile-fail/not-panic-safe-5.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::cell::UnsafeCell;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<*const UnsafeCell<i32>>(); //~ ERROR: is not implemented\n+}"}, {"sha": "90c730d37589b2c2a8e736c1713bdc2e910f87d2", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::cell::RefCell;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<*mut RefCell<i32>>(); //~ ERROR: is not implemented\n+    //~^ ERROR is not implemented\n+}\n+"}, {"sha": "f06464c5b1ab8067ea5664d7553d661a9302a5fa", "filename": "src/test/compile-fail/not-panic-safe.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<&mut i32>(); //~ ERROR: RecoverSafe` is not implemented\n+}"}, {"sha": "d85fd3a2b6b1c1bf3f87e4b4ab376e80d8eb9c31", "filename": "src/test/run-pass/binary-heap-panic-safe.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, binary_heap_extras, catch_panic, rand, sync_poison)]\n+#![feature(recover, rand, std_panic)]\n \n use std::__rand::{thread_rng, Rng};\n-use std::thread;\n+use std::panic::{self, AssertRecoverSafe};\n \n use std::collections::BinaryHeap;\n use std::cmp;\n-use std::sync::Arc;\n-use std::sync::Mutex;\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n@@ -66,31 +64,24 @@ fn test_integrity() {\n \n             // heapify the sane items\n             rng.shuffle(&mut panic_ords);\n-            let heap = Arc::new(Mutex::new(BinaryHeap::from_vec(panic_ords)));\n+            let mut heap = BinaryHeap::from(panic_ords);\n             let inner_data;\n \n             {\n-                let heap_ref = heap.clone();\n-\n-\n                 // push the panicking item to the heap and catch the panic\n-                let thread_result = thread::catch_panic(move || {\n-                    heap.lock().unwrap().push(panic_item);\n-                });\n+                let thread_result = {\n+                    let mut heap_ref = AssertRecoverSafe::new(&mut heap);\n+                    panic::recover(move || {\n+                        heap_ref.push(panic_item);\n+                    })\n+                };\n                 assert!(thread_result.is_err());\n \n                 // Assert no elements were dropped\n                 let drops = DROP_COUNTER.load(Ordering::SeqCst);\n-                //assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n-\n-                {\n-                    // now fetch the binary heap's data vector\n-                    let mutex_guard = match heap_ref.lock() {\n-                        Ok(x) => x,\n-                        Err(poison) => poison.into_inner(),\n-                    };\n-                    inner_data = mutex_guard.clone().into_vec();\n-                }\n+                assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n+                inner_data = heap.clone().into_vec();\n+                drop(heap);\n             }\n             let drops = DROP_COUNTER.load(Ordering::SeqCst);\n             assert_eq!(drops, DATASZ);"}, {"sha": "cd2457e8a52f765a0c9f138349640a6782ac28c1", "filename": "src/test/run-pass/panic-safe.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-safe.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(recover)]\n+\n+use std::panic::RecoverSafe;\n+use std::cell::RefCell;\n+use std::sync::{Mutex, RwLock, Arc};\n+use std::rc::Rc;\n+\n+struct Foo { a: i32 }\n+\n+fn assert<T: RecoverSafe + ?Sized>() {}\n+\n+fn main() {\n+    assert::<i32>();\n+    assert::<&i32>();\n+    assert::<*mut i32>();\n+    assert::<*const i32>();\n+    assert::<usize>();\n+    assert::<str>();\n+    assert::<&str>();\n+    assert::<Foo>();\n+    assert::<&Foo>();\n+    assert::<Vec<i32>>();\n+    assert::<String>();\n+    assert::<RefCell<i32>>();\n+    assert::<Box<i32>>();\n+    assert::<Mutex<i32>>();\n+    assert::<RwLock<i32>>();\n+    assert::<Rc<i32>>();\n+    assert::<Arc<i32>>();\n+\n+    fn bar<T>() {\n+        assert::<Mutex<T>>();\n+        assert::<RwLock<T>>();\n+    }\n+    fn baz<T: RecoverSafe>() {\n+        assert::<Box<T>>();\n+        assert::<Vec<T>>();\n+        assert::<RefCell<T>>();\n+    }\n+}"}, {"sha": "c67bc8c8368e8738191e24ed30e0fac935892095", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a13f1abafe70cddf34bf2b2ba3946c418ed6241/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=0a13f1abafe70cddf34bf2b2ba3946c418ed6241", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(catch_panic, start)]\n+#![feature(std_panic, recover, start)]\n \n use std::ffi::CStr;\n use std::process::{Command, Output};\n-use std::thread;\n+use std::panic;\n use std::str;\n \n #[start]\n@@ -22,8 +22,8 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n             match **argv.offset(1) as char {\n                 '1' => {}\n                 '2' => println!(\"foo\"),\n-                '3' => assert!(thread::catch_panic(|| {}).is_ok()),\n-                '4' => assert!(thread::catch_panic(|| panic!()).is_err()),\n+                '3' => assert!(panic::recover(|| {}).is_ok()),\n+                '4' => assert!(panic::recover(|| panic!()).is_err()),\n                 '5' => assert!(Command::new(\"test\").spawn().is_err()),\n                 _ => panic!()\n             }"}]}