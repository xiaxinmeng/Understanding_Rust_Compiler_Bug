{"sha": "cef9d4cbc1809bc29dee105fc8593d3e569155d7", "node_id": "C_kwDOAAsO6NoAKGNlZjlkNGNiYzE4MDliYzI5ZGVlMTA1ZmM4NTkzZDNlNTY5MTU1ZDc", "commit": {"author": {"name": "Florian Bartels", "email": "Florian.Bartels@elektrobit.com", "date": "2023-02-10T14:27:22Z"}, "committer": {"name": "Florian Bartels", "email": "Florian.Bartels@elektrobit.com", "date": "2023-02-28T14:59:53Z"}, "message": "Retry to spawn/fork up to 3 times when it failed because of an interruption", "tree": {"sha": "ba13d2a7bce2238b0d82353fdd86caa4fde91860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba13d2a7bce2238b0d82353fdd86caa4fde91860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cef9d4cbc1809bc29dee105fc8593d3e569155d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgfX4XtN64zVoKGqFPazFePRoZQU\nenyJI6x5SpvVPVSXUAAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQP247CSYzI7sAOL/NoihFF+Kx2SVqpI1TYt0OzaSKgbPBReF/ROzeZ5SFhxN2i7tPL\nl4+TnKPY1zF/Zp2+0GEgA=\n-----END SSH SIGNATURE-----", "payload": "tree ba13d2a7bce2238b0d82353fdd86caa4fde91860\nparent f1a399cc40dce94a0dca7324ac0a8d8d2fedb506\nauthor Florian Bartels <Florian.Bartels@elektrobit.com> 1676039242 +0100\ncommitter Florian Bartels <Florian.Bartels@elektrobit.com> 1677596393 +0100\n\nRetry to spawn/fork up to 3 times when it failed because of an interruption\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cef9d4cbc1809bc29dee105fc8593d3e569155d7", "html_url": "https://github.com/rust-lang/rust/commit/cef9d4cbc1809bc29dee105fc8593d3e569155d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cef9d4cbc1809bc29dee105fc8593d3e569155d7/comments", "author": {"login": "flba-eb", "id": 108917393, "node_id": "U_kgDOBn3ykQ", "avatar_url": "https://avatars.githubusercontent.com/u/108917393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flba-eb", "html_url": "https://github.com/flba-eb", "followers_url": "https://api.github.com/users/flba-eb/followers", "following_url": "https://api.github.com/users/flba-eb/following{/other_user}", "gists_url": "https://api.github.com/users/flba-eb/gists{/gist_id}", "starred_url": "https://api.github.com/users/flba-eb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flba-eb/subscriptions", "organizations_url": "https://api.github.com/users/flba-eb/orgs", "repos_url": "https://api.github.com/users/flba-eb/repos", "events_url": "https://api.github.com/users/flba-eb/events{/privacy}", "received_events_url": "https://api.github.com/users/flba-eb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flba-eb", "id": 108917393, "node_id": "U_kgDOBn3ykQ", "avatar_url": "https://avatars.githubusercontent.com/u/108917393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flba-eb", "html_url": "https://github.com/flba-eb", "followers_url": "https://api.github.com/users/flba-eb/followers", "following_url": "https://api.github.com/users/flba-eb/following{/other_user}", "gists_url": "https://api.github.com/users/flba-eb/gists{/gist_id}", "starred_url": "https://api.github.com/users/flba-eb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flba-eb/subscriptions", "organizations_url": "https://api.github.com/users/flba-eb/orgs", "repos_url": "https://api.github.com/users/flba-eb/repos", "events_url": "https://api.github.com/users/flba-eb/events{/privacy}", "received_events_url": "https://api.github.com/users/flba-eb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1a399cc40dce94a0dca7324ac0a8d8d2fedb506", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a399cc40dce94a0dca7324ac0a8d8d2fedb506", "html_url": "https://github.com/rust-lang/rust/commit/f1a399cc40dce94a0dca7324ac0a8d8d2fedb506"}], "stats": {"total": 66, "additions": 64, "deletions": 2}, "files": [{"sha": "ceaff5966846094815adc0130a43d4ddf66d3b03", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cef9d4cbc1809bc29dee105fc8593d3e569155d7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef9d4cbc1809bc29dee105fc8593d3e569155d7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=cef9d4cbc1809bc29dee105fc8593d3e569155d7", "patch": "@@ -31,6 +31,15 @@ use libc::{c_int, pid_t};\n #[cfg(not(any(target_os = \"vxworks\", target_os = \"l4re\")))]\n use libc::{gid_t, uid_t};\n \n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_os = \"nto\", target_env = \"nto71\"))] {\n+        use crate::thread;\n+        use libc::{c_char, posix_spawn_file_actions_t, posix_spawnattr_t};\n+        // arbitrary number of tries:\n+        const MAX_FORKSPAWN_TRIES: u32 = 4;\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -141,11 +150,31 @@ impl Command {\n \n     // Attempts to fork the process. If successful, returns Ok((0, -1))\n     // in the child, and Ok((child_pid, -1)) in the parent.\n-    #[cfg(not(target_os = \"linux\", target_os = \"nto\"))]\n+    #[cfg(not(any(target_os = \"linux\", all(target_os = \"nto\", target_env = \"nto71\"))))]\n     unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n         cvt(libc::fork()).map(|res| (res, -1))\n     }\n \n+    // On QNX Neutrino, fork can fail with EBADF in case \"another thread might have opened\n+    // or closed a file descriptor while the fork() was occurring\".\n+    // Documentation says \"... or try calling fork() again\". This is what we do here.\n+    // See also https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/f/fork.html\n+    #[cfg(all(target_os = \"nto\", target_env = \"nto71\"))]\n+    unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n+        use crate::sys::os::errno;\n+\n+        let mut tries_left = MAX_FORKSPAWN_TRIES;\n+        loop {\n+            let r = libc::fork();\n+            if r == -1 as libc::pid_t && tries_left > 0 && errno() as libc::c_int == libc::EBADF {\n+                thread::yield_now();\n+                tries_left -= 1;\n+            } else {\n+                return cvt(r).map(|res| (res, -1));\n+            }\n+        }\n+    }\n+\n     // Attempts to fork the process. If successful, returns Ok((0, -1))\n     // in the child, and Ok((child_pid, child_pidfd)) in the parent.\n     #[cfg(target_os = \"linux\")]\n@@ -439,6 +468,34 @@ impl Command {\n             }\n         }\n \n+        // On QNX Neutrino, posix_spawnp can fail with EBADF in case \"another thread might have opened\n+        // or closed a file descriptor while the posix_spawn() was occurring\".\n+        // Documentation says \"... or try calling posix_spawn() again\". This is what we do here.\n+        // See also http://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/p/posix_spawn.html\n+        #[cfg(all(target_os = \"nto\", target_env = \"nto71\"))]\n+        unsafe fn retrying_libc_posix_spawnp(\n+            pid: *mut pid_t,\n+            file: *const c_char,\n+            file_actions: *const posix_spawn_file_actions_t,\n+            attrp: *const posix_spawnattr_t,\n+            argv: *const *mut c_char,\n+            envp: *const *mut c_char,\n+        ) -> i32 {\n+            let mut tries_left = MAX_FORKSPAWN_TRIES;\n+            loop {\n+                match libc::posix_spawnp(pid, file, file_actions, attrp, argv, envp) {\n+                    libc::EBADF if tries_left > 0 => {\n+                        thread::yield_now();\n+                        tries_left -= 1;\n+                        continue;\n+                    }\n+                    r => {\n+                        return r;\n+                    }\n+                }\n+            }\n+        }\n+\n         // Solaris, glibc 2.29+, and musl 1.24+ can set a new working directory,\n         // and maybe others will gain this non-POSIX function too. We'll check\n         // for this weak symbol as soon as it's needed, so we can return early\n@@ -558,7 +615,12 @@ impl Command {\n             // Make sure we synchronize access to the global `environ` resource\n             let _env_lock = sys::os::env_read_lock();\n             let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::os::environ() as *const _);\n-            cvt_nz(libc::posix_spawnp(\n+\n+            #[cfg(not(target_os = \"nto\"))]\n+            let spawn_fn = libc::posix_spawnp;\n+            #[cfg(target_os = \"nto\")]\n+            let spawn_fn = retrying_libc_posix_spawnp;\n+            cvt_nz(spawn_fn(\n                 &mut p.pid,\n                 self.get_program_cstr().as_ptr(),\n                 file_actions.0.as_ptr(),"}]}