{"sha": "74a46ea74c6c50f5fa3ac35831101ea3007637fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YTQ2ZWE3NGM2YzUwZjVmYTNhYzM1ODMxMTAxZWEzMDA3NjM3ZmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-28T20:00:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-28T23:19:38Z"}, "message": "std: More demoding", "tree": {"sha": "f0e16dd7237e554b45712c85e16809003d643442", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0e16dd7237e554b45712c85e16809003d643442"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74a46ea74c6c50f5fa3ac35831101ea3007637fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74a46ea74c6c50f5fa3ac35831101ea3007637fd", "html_url": "https://github.com/rust-lang/rust/commit/74a46ea74c6c50f5fa3ac35831101ea3007637fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74a46ea74c6c50f5fa3ac35831101ea3007637fd/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "565b39b3024a16c3398286ebc4b34f09da50c8c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/565b39b3024a16c3398286ebc4b34f09da50c8c0", "html_url": "https://github.com/rust-lang/rust/commit/565b39b3024a16c3398286ebc4b34f09da50c8c0"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "bb556ed2ca398ea299b7b848a611b33fc2a1cfef", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=74a46ea74c6c50f5fa3ac35831101ea3007637fd", "patch": "@@ -137,17 +137,17 @@ impl BigBitv {\n     }\n \n     #[inline(always)]\n-     fn each_storage(op: fn(&v: uint) -> bool) {\n+     fn each_storage(op: fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n-            let b = !op(w);\n+            let b = !op(&mut w);\n             self.storage[i] = w;\n             if !b { break; }\n         }\n      }\n \n     #[inline(always)]\n-    fn invert() { for self.each_storage() |w| { w = !w } }\n+    fn invert() { for self.each_storage() |w| { *w = !*w } }\n \n     #[inline(always)]\n     fn union(b: &BigBitv, nbits: uint) -> bool {\n@@ -337,7 +337,7 @@ impl Bitv {\n      * bitvectors contain identical elements.\n      */\n     #[inline(always)]\n-    fn equal(v1: Bitv) -> bool {\n+    fn equal(v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n@@ -356,7 +356,7 @@ impl Bitv {\n     fn clear() {\n         match self.rep {\n           Small(ref b) => b.clear(),\n-          Big(ref s) => for s.each_storage() |w| { w = 0u }\n+          Big(ref s) => for s.each_storage() |w| { *w = 0u }\n         }\n     }\n \n@@ -365,15 +365,15 @@ impl Bitv {\n     fn set_all() {\n       match self.rep {\n         Small(ref b) => b.set_all(),\n-        Big(ref s) => for s.each_storage() |w| { w = !0u } }\n+        Big(ref s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n     fn invert() {\n       match self.rep {\n         Small(ref b) => b.invert(),\n-        Big(ref s) => for s.each_storage() |w| { w = !w } }\n+        Big(ref s) => for s.each_storage() |w| { *w = !*w } }\n     }\n \n     /**\n@@ -386,7 +386,7 @@ impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline(always)]\n-    fn difference(v: ~Bitv) -> bool { self.do_op(Difference, v) }\n+    fn difference(v: &Bitv) -> bool { self.do_op(Difference, v) }\n \n     /// Returns true if all bits are 1\n     #[inline(always)]\n@@ -863,14 +863,14 @@ mod tests {\n     fn test_equal_differing_sizes() {\n         let v0 = Bitv(10u, false);\n         let v1 = Bitv(11u, false);\n-        assert !v0.equal(v1);\n+        assert !v0.equal(&v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv(10u, false);\n         let v1 = Bitv(110u, false);\n-        assert !v0.equal(v1);\n+        assert !v0.equal(&v1);\n     }\n \n     #[test]\n@@ -881,7 +881,7 @@ mod tests {\n         let b = bitv::Bitv(1, true);\n         b.set(0, true);\n \n-        assert a.equal(b);\n+        assert a.equal(&b);\n     }\n \n     #[test]\n@@ -896,7 +896,7 @@ mod tests {\n             b.set(i, true);\n         }\n \n-        assert a.equal(b);\n+        assert a.equal(&b);\n     }\n \n     #[test]"}, {"sha": "f4df063a93d66e107eab133fa997d044ac553341", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=74a46ea74c6c50f5fa3ac35831101ea3007637fd", "patch": "@@ -117,7 +117,7 @@ fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n+fn set<T: Copy>(t: CVec<T>, ofs: uint, +v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }"}, {"sha": "22fdca3b0ab35d5aaeef51f1a77b6e4fd8fe5e6f", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=74a46ea74c6c50f5fa3ac35831101ea3007637fd", "patch": "@@ -8,8 +8,8 @@ use core::cmp::{Eq};\n \n trait Deque<T> {\n     fn size() -> uint;\n-    fn add_front(T);\n-    fn add_back(T);\n+    fn add_front(+v: T);\n+    fn add_back(+v: T);\n     fn pop_front() -> T;\n     fn pop_back() -> T;\n     fn peek_front() -> T;\n@@ -55,7 +55,7 @@ fn create<T: Copy>() -> Deque<T> {\n \n     impl <T: Copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n-        fn add_front(t: T) {\n+        fn add_front(+t: T) {\n             let oldlo: uint = self.lo;\n             if self.lo == 0u {\n                 self.lo = self.elts.len() - 1u;\n@@ -68,7 +68,7 @@ fn create<T: Copy>() -> Deque<T> {\n             self.elts.set_elt(self.lo, Some(t));\n             self.nelts += 1u;\n         }\n-        fn add_back(t: T) {\n+        fn add_back(+t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n                 self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n                 self.lo = 0u;"}, {"sha": "820c2bfcc4db9125bd3b0c6f9fdf4d8e1e72af09", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=74a46ea74c6c50f5fa3ac35831101ea3007637fd", "patch": "@@ -738,7 +738,7 @@ impl TcpSocket {\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(&self)\n     }\n-    fn read_stop(-read_port:\n+    fn read_stop(+read_port:\n                  comm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n         read_stop(&self, move read_port)"}, {"sha": "4168de60646d536f8acb60d3018024814c5958e5", "filename": "src/libstd/par.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a46ea74c6c50f5fa3ac35831101ea3007637fd/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=74a46ea74c6c50f5fa3ac35831101ea3007637fd", "patch": "@@ -72,21 +72,21 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n }\n \n /// A parallel version of map.\n-pub fn map<A: Copy Send, B: Copy Send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n+pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n-            vec::map(slice, |x| f(*x))\n+            vec::map(slice, |x| f(x))\n         }\n     }))\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A: Copy Send, B: Copy Send>(xs: ~[A],\n-                                    f: fn~(uint, A) -> B) -> ~[B] {\n+pub fn mapi<A: Copy Send, B: Copy Send>(xs: &[A],\n+                                    f: fn~(uint, (&A)) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n-                f(i + base, *x)\n+                f(i + base, x)\n             })\n         }\n     });\n@@ -119,21 +119,21 @@ pub fn mapi_factory<A: Copy Send, B: Copy Send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n+pub fn alli<A: Copy Send>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n-                f(i + base, *x)\n+                f(i + base, x)\n             })\n         }\n     })) |x| { *x }\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n+pub fn any<A: Copy Send>(xs: &[A], f: fn~(&(A)) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n-            vec::any(slice, |x| f(*x))\n+            vec::any(slice, |x| f(x))\n         }\n     })) |x| { *x }\n }"}]}