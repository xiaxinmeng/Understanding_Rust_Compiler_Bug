{"sha": "3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZWM1YjVlNTA5NmMzM2U5NzkwZDEzMzM3MmJjZDliYzJlZTg4ODk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T19:03:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T19:03:34Z"}, "message": "rustc: Remove uses of Unicode in type deserialization and fix vector-push operations", "tree": {"sha": "384a7bfae9247d4171f369b9b2cafecfb02f11ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384a7bfae9247d4171f369b9b2cafecfb02f11ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "html_url": "https://github.com/rust-lang/rust/commit/3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dec5b5e5096c33e9790d133372bcd9bc2ee8889/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84c0d8638ebf766cc4f6e442bbd4f01c5810795a", "url": "https://api.github.com/repos/rust-lang/rust/commits/84c0d8638ebf766cc4f6e442bbd4f01c5810795a", "html_url": "https://github.com/rust-lang/rust/commit/84c0d8638ebf766cc4f6e442bbd4f01c5810795a"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "42bc51304068946a6c30bb5f9ef15c4bca147f8f", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3dec5b5e5096c33e9790d133372bcd9bc2ee8889/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec5b5e5096c33e9790d133372bcd9bc2ee8889/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "patch": "@@ -35,18 +35,18 @@ type str_def = fn(str) -> ast.def_id;\n \n type pstate = rec(str rep, mutable uint pos, uint len);\n \n-fn peek(@pstate st) -> char {\n-    if (st.pos < st.len) {ret st.rep.(st.pos) as char;}\n-    else {ret ' ';}\n+fn peek(@pstate st) -> u8 {\n+    if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n+    else {ret ' ' as u8;}\n }\n-impure fn next(@pstate st) -> char { // ?? somehow not recognized as impure\n+impure fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n     if (st.pos >= st.len) {fail;}\n     auto ch = st.rep.(st.pos);\n     st.pos = st.pos + 1u;\n-    ret ch as char;\n+    ret ch as u8;\n }\n \n-fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n+impure fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n     auto len = _str.byte_len(rep);\n     auto st = @rec(rep=rep, mutable pos=0u, len=len);\n     auto result = parse_ty(st, sd);\n@@ -61,7 +61,7 @@ impure fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n \n impure fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n     auto mut;\n-    alt (peek(st)) {\n+    alt (peek(st) as char) {\n         case ('m') {next(st); mut = ast.mut;}\n         case ('?') {next(st); mut = ast.maybe_mut;}\n         case (_)   {mut=ast.imm;}\n@@ -70,13 +70,13 @@ impure fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n }\n \n impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n-    alt (next(st)) {\n+    alt (next(st) as char) {\n         case ('n') {ret ty.ty_nil;}\n         case ('b') {ret ty.ty_bool;}\n         case ('i') {ret ty.ty_int;}\n         case ('u') {ret ty.ty_uint;}\n         case ('M') {\n-            alt (next(st)) {\n+            alt (next(st) as char) {\n                 case ('b') {ret ty.ty_machine(common.ty_u8);}\n                 case ('w') {ret ty.ty_machine(common.ty_u16);}\n                 case ('l') {ret ty.ty_machine(common.ty_u32);}\n@@ -92,13 +92,15 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n         case ('c') {ret ty.ty_char;}\n         case ('s') {ret ty.ty_str;}\n         case ('t') {\n-            check(next(st) == '[');\n+            check(next(st) as char == '[');\n             auto def = \"\";\n-            while (peek(st) != '|') {def += _str.from_char(next(st));}\n+            while (peek(st) as char != '|') {\n+                def += _str.unsafe_from_byte(next(st));\n+            }\n             st.pos = st.pos + 1u;\n             let vec[@ty.t] params = vec();\n-            while (peek(st) != ']') {\n-                params = _vec.push[@ty.t](params, parse_ty(st, sd));\n+            while (peek(st) as char != ']') {\n+                params += vec(parse_ty(st, sd));\n             }\n             st.pos = st.pos + 1u;\n             ret ty.ty_tag(sd(def), params);\n@@ -108,23 +110,24 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n         case ('P') {ret ty.ty_port(parse_ty(st, sd));}\n         case ('C') {ret ty.ty_chan(parse_ty(st, sd));}\n         case ('T') {\n-            check(next(st) == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n-            while (peek(st) != ']') {\n-                params = _vec.push[ty.mt](params, parse_mt(st, sd));\n+            while (peek(st) as char != ']') {\n+                params += vec(parse_mt(st, sd));\n             }\n             st.pos = st.pos + 1u;\n             ret ty.ty_tup(params);\n         }\n         case ('R') {\n-            check(next(st) == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.field] fields = vec();\n-            while (peek(st) != ']') {\n+            while (peek(st) as char != ']') {\n                 auto name = \"\";\n-                while (peek(st) != '=') {name += _str.from_char(next(st));}\n+                while (peek(st) as char != '=') {\n+                    name += _str.unsafe_from_byte(next(st));\n+                }\n                 st.pos = st.pos + 1u;\n-                fields = _vec.push[ty.field]\n-                    (fields, rec(ident=name, mt=parse_mt(st, sd)));\n+                fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n             }\n             st.pos = st.pos + 1u;\n             ret ty.ty_rec(fields);\n@@ -139,30 +142,31 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n         }\n         case ('N') {\n             auto abi;\n-            alt (next(st)) {\n+            alt (next(st) as char) {\n                 case ('r') {abi = ast.native_abi_rust;}\n                 case ('c') {abi = ast.native_abi_cdecl;}\n             }\n             auto func = parse_ty_fn(st, sd);\n             ret ty.ty_native_fn(abi,func._0,func._1);\n         }\n         case ('O') {\n-            check(next(st) == '[');\n+            check(next(st) as char == '[');\n             let vec[ty.method] methods = vec();\n-            while (peek(st) != ']') {\n+            while (peek(st) as char != ']') {\n                 auto proto;\n-                alt (next(st)) {\n+                alt (next(st) as char) {\n                     case ('W') {proto = ast.proto_iter;}\n                     case ('F') {proto = ast.proto_fn;}\n                 }\n                 auto name = \"\";\n-                while (peek(st) != '[') {name += _str.from_char(next(st));}\n+                while (peek(st) as char != '[') {\n+                    name += _str.unsafe_from_byte(next(st));\n+                }\n                 auto func = parse_ty_fn(st, sd);\n-                methods = _vec.push[ty.method]\n-                    (methods, rec(proto=proto,\n-                                  ident=name,\n-                                  inputs=func._0,\n-                                  output=func._1));\n+                methods += vec(rec(proto=proto,\n+                                   ident=name,\n+                                   inputs=func._0,\n+                                   output=func._1));\n             }\n             ret ty.ty_obj(methods);\n         }\n@@ -174,7 +178,7 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n impure fn parse_int(@pstate st) -> int {\n     auto n = 0;\n     while (true) {\n-        auto cur = peek(st);\n+        auto cur = peek(st) as char;\n         if (cur < '0' || cur > '9') {break;}\n         st.pos = st.pos + 1u;\n         n *= 10;\n@@ -184,16 +188,15 @@ impure fn parse_int(@pstate st) -> int {\n }\n \n impure fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n-    check(next(st) == '[');\n+    check(next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n-    while (peek(st) != ']') {\n+    while (peek(st) as char != ']') {\n         auto mode = ast.val;\n-        if (peek(st) == '&') {\n+        if (peek(st) as char == '&') {\n             mode = ast.alias;\n             st.pos = st.pos + 1u;\n         }\n-        inputs = _vec.push[ty.arg]\n-            (inputs, rec(mode=mode, ty=parse_ty(st, sd)));\n+        inputs += vec(rec(mode=mode, ty=parse_ty(st, sd)));\n     }\n     st.pos = st.pos + 1u;\n     ret tup(inputs, parse_ty(st, sd));"}]}