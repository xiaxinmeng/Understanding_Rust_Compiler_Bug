{"sha": "bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDA5YzM5MjEyMjYwY2Q3NTAwYTJkYWIxYmZjMGI5NmVmNTNiNWI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-07-15T09:08:37Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-07-15T10:21:05Z"}, "message": "[debuginfo] Make use of spaces and separators in debuginfo names more uniform.", "tree": {"sha": "0990c7600df5121d93ce794cf8a5081d911abb87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0990c7600df5121d93ce794cf8a5081d911abb87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "html_url": "https://github.com/rust-lang/rust/commit/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6e1e095ffc3cd6f305a2470b1e162680e678014", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e1e095ffc3cd6f305a2470b1e162680e678014", "html_url": "https://github.com/rust-lang/rust/commit/e6e1e095ffc3cd6f305a2470b1e162680e678014"}], "stats": {"total": 153, "additions": 86, "deletions": 67}, "files": [{"sha": "ad0ee7ba40852c69e3e25e84c0d650cf97cb6427", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "patch": "@@ -85,25 +85,14 @@ pub fn push_debuginfo_type_name<'tcx>(\n \n             for component_type in component_types {\n                 push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n-                output.push(',');\n-\n-                // Natvis does not always like having spaces between parts of the type name\n-                // and this causes issues when we need to write a typename in natvis, for example\n-                // as part of a cast like the `HashMap` visualizer does.\n-                if !cpp_like_names {\n-                    output.push(' ');\n-                }\n+                push_arg_separator(cpp_like_names, output);\n             }\n             if !component_types.is_empty() {\n-                output.pop();\n-\n-                if !cpp_like_names {\n-                    output.pop();\n-                }\n+                pop_arg_separator(output);\n             }\n \n             if cpp_like_names {\n-                push_close_angle_bracket(tcx, output);\n+                push_close_angle_bracket(cpp_like_names, output);\n             } else {\n                 output.push(')');\n             }\n@@ -125,7 +114,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n             if cpp_like_names {\n-                push_close_angle_bracket(tcx, output);\n+                push_close_angle_bracket(cpp_like_names, output);\n             }\n         }\n         ty::Ref(_, inner_type, mutbl) => {\n@@ -151,7 +140,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n             if cpp_like_names && !is_slice_or_str {\n-                push_close_angle_bracket(tcx, output);\n+                push_close_angle_bracket(cpp_like_names, output);\n             }\n         }\n         ty::Array(inner_type, len) => {\n@@ -183,7 +172,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n-                push_close_angle_bracket(tcx, output);\n+                push_close_angle_bracket(cpp_like_names, output);\n             } else {\n                 output.push(']');\n             }\n@@ -196,7 +185,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 false\n             } else {\n                 if trait_data.len() > 1 && auto_traits.len() != 0 {\n-                    // We need enclosing parens\n+                    // We need enclosing parens because there is more than one trait\n                     output.push_str(\"(dyn \");\n                     true\n                 } else {\n@@ -209,7 +198,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 let principal =\n                     tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), principal);\n                 push_item_name(tcx, principal.def_id, qualified, output);\n-                push_generic_params_internal(tcx, principal.substs, output, visited);\n+                let principal_has_generic_params =\n+                    push_generic_params_internal(tcx, principal.substs, output, visited);\n \n                 let projection_bounds: SmallVec<[_; 4]> = trait_data\n                     .projection_bounds()\n@@ -220,25 +210,29 @@ pub fn push_debuginfo_type_name<'tcx>(\n                     .collect();\n \n                 if projection_bounds.len() != 0 {\n-                    pop_close_angle_bracket(output);\n+                    if principal_has_generic_params {\n+                        // push_generic_params_internal() above added a `>` but we actually\n+                        // want to add more items to that list, so remove that again.\n+                        pop_close_angle_bracket(output);\n+                    }\n \n                     for (item_def_id, ty) in projection_bounds {\n-                        output.push_str(\", \");\n+                        push_arg_separator(cpp_like_names, output);\n \n                         if cpp_like_names {\n                             output.push_str(\"assoc$<\");\n                             push_item_name(tcx, item_def_id, false, output);\n-                            output.push_str(\", \");\n+                            push_arg_separator(cpp_like_names, output);\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n-                            push_close_angle_bracket(tcx, output);\n+                            push_close_angle_bracket(cpp_like_names, output);\n                         } else {\n                             push_item_name(tcx, item_def_id, false, output);\n                             output.push('=');\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n                         }\n                     }\n \n-                    push_close_angle_bracket(tcx, output);\n+                    push_close_angle_bracket(cpp_like_names, output);\n                 }\n \n                 if auto_traits.len() != 0 {\n@@ -262,11 +256,11 @@ pub fn push_debuginfo_type_name<'tcx>(\n                     push_auto_trait_separator(cpp_like_names, output);\n                 }\n \n-                pop_auto_trait_separator(cpp_like_names, output);\n+                pop_auto_trait_separator(output);\n             }\n \n             if cpp_like_names {\n-                push_close_angle_bracket(tcx, output);\n+                push_close_angle_bracket(cpp_like_names, output);\n             } else if has_enclosing_parens {\n                 output.push(')');\n             }\n@@ -320,10 +314,9 @@ pub fn push_debuginfo_type_name<'tcx>(\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(tcx, parameter_type, true, output, visited);\n-                    output.push_str(\", \");\n+                    push_arg_separator(cpp_like_names, output);\n                 }\n-                output.pop();\n-                output.pop();\n+                pop_arg_separator(output);\n             }\n \n             if sig.c_variadic {\n@@ -429,21 +422,25 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 output.push_str(&format!(\", {}\", variant));\n             }\n         }\n-        push_close_angle_bracket(tcx, output);\n+        push_close_angle_bracket(true, output);\n     }\n \n-    fn auto_trait_separator(cpp_like_names: bool) -> &'static str {\n-        if cpp_like_names { \", \" } else { \" + \" }\n-    }\n+    const NON_CPP_AUTO_TRAIT_SEPARATOR: &str = \" + \";\n \n     fn push_auto_trait_separator(cpp_like_names: bool, output: &mut String) {\n-        output.push_str(auto_trait_separator(cpp_like_names));\n+        if cpp_like_names {\n+            push_arg_separator(cpp_like_names, output);\n+        } else {\n+            output.push_str(NON_CPP_AUTO_TRAIT_SEPARATOR);\n+        }\n     }\n \n-    fn pop_auto_trait_separator(cpp_like_names: bool, output: &mut String) {\n-        let sep = auto_trait_separator(cpp_like_names);\n-        assert!(output.ends_with(sep));\n-        output.truncate(output.len() - sep.len());\n+    fn pop_auto_trait_separator(output: &mut String) {\n+        if output.ends_with(NON_CPP_AUTO_TRAIT_SEPARATOR) {\n+            output.truncate(output.len() - NON_CPP_AUTO_TRAIT_SEPARATOR.len());\n+        } else {\n+            pop_arg_separator(output);\n+        }\n     }\n }\n \n@@ -504,13 +501,15 @@ fn push_generic_params_internal<'tcx>(\n     substs: SubstsRef<'tcx>,\n     output: &mut String,\n     visited: &mut FxHashSet<Ty<'tcx>>,\n-) {\n+) -> bool {\n     if substs.non_erasable_generics().next().is_none() {\n-        return;\n+        return false;\n     }\n \n     debug_assert_eq!(substs, tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substs));\n \n+    let cpp_like_names = cpp_like_names(tcx);\n+\n     output.push('<');\n \n     for type_parameter in substs.non_erasable_generics() {\n@@ -524,13 +523,12 @@ fn push_generic_params_internal<'tcx>(\n             other => bug!(\"Unexpected non-erasable generic: {:?}\", other),\n         }\n \n-        output.push_str(\", \");\n+        push_arg_separator(cpp_like_names, output);\n     }\n+    pop_arg_separator(output);\n+    push_close_angle_bracket(cpp_like_names, output);\n \n-    output.pop();\n-    output.pop();\n-\n-    push_close_angle_bracket(tcx, output);\n+    true\n }\n \n fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: &'tcx ty::Const<'tcx>, output: &mut String) {\n@@ -583,24 +581,45 @@ pub fn push_generic_params<'tcx>(tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>, out\n     push_generic_params_internal(tcx, substs, output, &mut visited);\n }\n \n-fn push_close_angle_bracket<'tcx>(tcx: TyCtxt<'tcx>, output: &mut String) {\n+fn push_close_angle_bracket(cpp_like_names: bool, output: &mut String) {\n     // MSVC debugger always treats `>>` as a shift, even when parsing templates,\n     // so add a space to avoid confusion.\n-    if cpp_like_names(tcx) && output.ends_with('>') {\n+    if cpp_like_names && output.ends_with('>') {\n         output.push(' ')\n     };\n \n     output.push('>');\n }\n \n fn pop_close_angle_bracket(output: &mut String) {\n-    assert!(output.ends_with('>'));\n+    assert!(output.ends_with('>'), \"'output' does not end with '>': {}\", output);\n     output.pop();\n     if output.ends_with(' ') {\n         output.pop();\n     }\n }\n \n+fn push_arg_separator(cpp_like_names: bool, output: &mut String) {\n+    // Natvis does not always like having spaces between parts of the type name\n+    // and this causes issues when we need to write a typename in natvis, for example\n+    // as part of a cast like the `HashMap` visualizer does.\n+    if cpp_like_names {\n+        output.push(',');\n+    } else {\n+        output.push_str(\", \");\n+    };\n+}\n+\n+fn pop_arg_separator(output: &mut String) {\n+    if output.ends_with(' ') {\n+        output.pop();\n+    }\n+\n+    assert!(output.ends_with(','));\n+\n+    output.pop();\n+}\n+\n fn cpp_like_names(tcx: TyCtxt<'_>) -> bool {\n     tcx.sess.target.is_like_msvc\n }"}, {"sha": "28ab176ba509acd2a70ec88ea483f86915ba59fb", "filename": "src/test/debuginfo/function-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs?ref=bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "patch": "@@ -52,21 +52,21 @@\n // cdb-command:x a!function_names::*::impl_function*\n // cdb-check:[...] a!function_names::Mod1::TestStruct2::impl_function (void)\n // cdb-check:[...] a!function_names::TestStruct1::impl_function (void)\n-// cdb-check:[...] a!function_names::GenericStruct<i32, i32>::impl_function<i32, i32> (void)\n+// cdb-check:[...] a!function_names::GenericStruct<i32,i32>::impl_function<i32,i32> (void)\n \n // Trait implementations\n // cdb-command:x a!function_names::*::trait_function*\n // cdb-check:[...] a!function_names::impl$3::trait_function<i32> (void)\n+// cdb-check:[...] a!function_names::impl$6::trait_function<i32,1> (void)\n // cdb-check:[...] a!function_names::impl$1::trait_function (void)\n-// cdb-check:[...] a!function_names::impl$6::trait_function<i32, 1> (void)\n // cdb-check:[...] a!function_names::impl$5::trait_function3<function_names::TestStruct1> (void)\n // cdb-check:[...] a!function_names::Mod1::impl$1::trait_function (void)\n \n // Closure\n // cdb-command:x a!function_names::*::closure*\n+// cdb-check:[...] a!function_names::impl$2::impl_function::closure$0<i32,i32> (void)\n // cdb-check:[...] a!function_names::main::closure$0 (void)\n // cdb-check:[...] a!function_names::generic_func::closure$0<i32> (void)\n-// cdb-check:[...] a!function_names::impl$2::impl_function::closure$0<i32, i32> (void)\n \n // Generator\n // cdb-command:x a!function_names::*::generator*"}, {"sha": "3497f0afb2cb0bd4447872ef8bb0ceb1f2d40111", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd09c39212260cd7500a2dab1bfc0b96ef53b5b/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=bdd09c39212260cd7500a2dab1bfc0b96ef53b5b", "patch": "@@ -173,7 +173,7 @@\n // 0-sized structs appear to be optimized away in some cases, so only check the structs that do\n // actually appear.\n // cdb-command:dv /t *_struct\n-// cdb-check:struct type_names::GenericStruct<enum$<type_names::mod1::Enum2>, f64> mut_generic_struct = [...]\n+// cdb-check:struct type_names::GenericStruct<enum$<type_names::mod1::Enum2>,f64> mut_generic_struct = [...]\n \n // ENUMS\n // cdb-command:dv /t *_enum_*\n@@ -190,15 +190,15 @@\n \n // BOX\n // cdb-command:dv /t box*\n-// cdb-check:struct tuple$<alloc::boxed::Box<f32, alloc::alloc::Global>,i32> box1 = [...]\n-// cdb-check:struct tuple$<alloc::boxed::Box<enum$<type_names::mod1::mod2::Enum3<f32> >, alloc::alloc::Global>,i32> box2 = [...]\n+// cdb-check:struct tuple$<alloc::boxed::Box<f32,alloc::alloc::Global>,i32> box1 = [...]\n+// cdb-check:struct tuple$<alloc::boxed::Box<enum$<type_names::mod1::mod2::Enum3<f32> >,alloc::alloc::Global>,i32> box2 = [...]\n \n // REFERENCES\n // cdb-command:dv /t *ref*\n // cdb-check:struct tuple$<ref$<type_names::Struct1>,i32> ref1 = [...]\n-// cdb-check:struct tuple$<ref$<type_names::GenericStruct<char, type_names::Struct1> >,i32> ref2 = [...]\n+// cdb-check:struct tuple$<ref$<type_names::GenericStruct<char,type_names::Struct1> >,i32> ref2 = [...]\n // cdb-check:struct tuple$<ref_mut$<type_names::Struct1>,i32> mut_ref1 = [...]\n-// cdb-check:struct tuple$<ref_mut$<type_names::GenericStruct<enum$<type_names::mod1::Enum2>, f64> >,i32> mut_ref2 = [...]\n+// cdb-check:struct tuple$<ref_mut$<type_names::GenericStruct<enum$<type_names::mod1::Enum2>,f64> >,i32> mut_ref2 = [...]\n \n // RAW POINTERS\n // cdb-command:dv /t *_ptr*\n@@ -213,31 +213,31 @@\n // cdb-command:dv /t *vec*\n // cdb-check:struct tuple$<array$<type_names::Struct1,3>,i16> fixed_size_vec1 = [...]\n // cdb-check:struct tuple$<array$<usize,3>,i16> fixed_size_vec2 = [...]\n-// cdb-check:struct alloc::vec::Vec<usize, alloc::alloc::Global> vec1 = [...]\n-// cdb-check:struct alloc::vec::Vec<enum$<type_names::mod1::Enum2>, alloc::alloc::Global> vec2 = [...]\n+// cdb-check:struct alloc::vec::Vec<usize,alloc::alloc::Global> vec1 = [...]\n+// cdb-check:struct alloc::vec::Vec<enum$<type_names::mod1::Enum2>,alloc::alloc::Global> vec2 = [...]\n // cdb-command:dv /t slice*\n // cdb-check:struct slice$<usize> slice1 = [...]\n // cdb-check:struct slice$<enum$<type_names::mod1::Enum2> > slice2 = [...]\n \n // TRAITS\n // cdb-command:dv /t *_trait\n-// cdb-check:struct ref_mut$<dyn$<type_names::Trait2<type_names::mod1::mod2::Struct3, type_names::GenericStruct<usize, isize> > > > generic_mut_ref_trait = [...]\n-// cdb-check:struct ref$<dyn$<type_names::Trait2<type_names::Struct1, type_names::Struct1> > > generic_ref_trait = [...]\n-// cdb-check:struct alloc::boxed::Box<dyn$<type_names::Trait2<i32, type_names::mod1::Struct2> >, alloc::alloc::Global> generic_box_trait = [...]\n-// cdb-check:struct alloc::boxed::Box<dyn$<type_names::Trait1>, alloc::alloc::Global> box_trait = [...]\n+// cdb-check:struct ref_mut$<dyn$<type_names::Trait2<type_names::mod1::mod2::Struct3,type_names::GenericStruct<usize,isize> > > > generic_mut_ref_trait = [...]\n+// cdb-check:struct ref$<dyn$<type_names::Trait2<type_names::Struct1,type_names::Struct1> > > generic_ref_trait = [...]\n+// cdb-check:struct alloc::boxed::Box<dyn$<type_names::Trait2<i32,type_names::mod1::Struct2> >,alloc::alloc::Global> generic_box_trait = [...]\n+// cdb-check:struct alloc::boxed::Box<dyn$<type_names::Trait1>,alloc::alloc::Global> box_trait = [...]\n // cdb-check:struct ref$<dyn$<type_names::Trait1> > ref_trait = [...]\n // cdb-check:struct ref_mut$<dyn$<type_names::Trait1> > mut_ref_trait = [...]\n-// cdb-check:struct alloc::boxed::Box<dyn$<core::marker::Send, core::marker::Sync>, alloc::alloc::Global> no_principal_trait = [...]\n-// cdb-check:struct ref$<dyn$<type_names::Trait3<u32, assoc$<AssocType, isize> >, core::marker::Send> > has_associated_type_trait = struct ref$<dyn$<type_names::Trait3<u32, assoc$<AssocType, isize> >, core::marker::Send> >\n+// cdb-check:struct alloc::boxed::Box<dyn$<core::marker::Send,core::marker::Sync>,alloc::alloc::Global> no_principal_trait = [...]\n+// cdb-check:struct ref$<dyn$<type_names::Trait3<u32,assoc$<AssocType,isize> >,core::marker::Send> > has_associated_type_trait = struct ref$<dyn$<type_names::Trait3<u32,assoc$<AssocType,isize> >,core::marker::Send> >\n \n // BARE FUNCTIONS\n // cdb-command:dv /t *_fn*\n-// cdb-check:struct tuple$<type_names::mod1::Struct2 (*)(type_names::GenericStruct<u16, u8>),usize> unsafe_fn_with_return_value = [...]\n+// cdb-check:struct tuple$<type_names::mod1::Struct2 (*)(type_names::GenericStruct<u16,u8>),usize> unsafe_fn_with_return_value = [...]\n // cdb-check:struct tuple$<type_names::Struct1 (*)(),usize> extern_c_fn_with_return_value = [...]\n // cdb-check:struct tuple$<usize (*)(f64),usize> rust_fn_with_return_value = [...]\n-// cdb-check:struct tuple$<void (*)(enum$<core::result::Result<char, f64> >),usize> unsafe_fn = [...]\n+// cdb-check:struct tuple$<void (*)(enum$<core::result::Result<char,f64> >),usize> unsafe_fn = [...]\n // cdb-check:struct tuple$<void (*)(isize),usize> extern_c_fn = [...]\n-// cdb-check:struct tuple$<void (*)(enum$<core::option::Option<isize> >, enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>),usize> rust_fn = [...]\n+// cdb-check:struct tuple$<void (*)(enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>),usize> rust_fn = [...]\n // cdb-command:dv /t *_function*\n // cdb-check:struct tuple$<isize (*)(ptr_const$<u8>, ...),usize> variadic_function = [...]\n // cdb-check:struct tuple$<type_names::mod1::mod2::Struct3 (*)(type_names::mod1::mod2::Struct3),usize> generic_function_struct3 = [...]"}]}