{"sha": "c8489069b43191c5298f17430933b3b88fb79c3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NDg5MDY5YjQzMTkxYzUyOThmMTc0MzA5MzNiM2I4OGZiNzljM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-17T00:46:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-17T00:46:39Z"}, "message": "auto merge of #12085 : alexcrichton/rust/issue-12082, r=brson\n\nThis just copies the libuv implementation for libnative which seems reasonable\r\nenough (uid/gid fail on windows).\r\n\r\nCloses #12082", "tree": {"sha": "f23c432774f94a6295fe9b37449fb339f888df00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23c432774f94a6295fe9b37449fb339f888df00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8489069b43191c5298f17430933b3b88fb79c3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8489069b43191c5298f17430933b3b88fb79c3c", "html_url": "https://github.com/rust-lang/rust/commit/c8489069b43191c5298f17430933b3b88fb79c3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8489069b43191c5298f17430933b3b88fb79c3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425f57477f3e1e4850c7e3c92954148e7585d2ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/425f57477f3e1e4850c7e3c92954148e7585d2ca", "html_url": "https://github.com/rust-lang/rust/commit/425f57477f3e1e4850c7e3c92954148e7585d2ca"}, {"sha": "74b42c646eb90ff267b131fcb2ac8d25428538c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b42c646eb90ff267b131fcb2ac8d25428538c5", "html_url": "https://github.com/rust-lang/rust/commit/74b42c646eb90ff267b131fcb2ac8d25428538c5"}], "stats": {"total": 355, "additions": 289, "deletions": 66}, "files": [{"sha": "1016c3cf0e61b55535d932f8f35cdb4ae5b60ea9", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -51,10 +51,7 @@ pub fn run(lib_path: &str,\n     let env = env + target_env(lib_path, prog);\n     let mut opt_process = run::Process::new(prog, args, run::ProcessOptions {\n         env: Some(env),\n-        dir: None,\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n+        .. run::ProcessOptions::new()\n     });\n \n     match opt_process {\n@@ -83,10 +80,7 @@ pub fn run_background(lib_path: &str,\n     let env = env + target_env(lib_path, prog);\n     let opt_process = run::Process::new(prog, args, run::ProcessOptions {\n         env: Some(env),\n-        dir: None,\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n+        .. run::ProcessOptions::new()\n     });\n \n     match opt_process {"}, {"sha": "affa3ebf54456537bb1d56f9262ed3942d3ea671", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -98,8 +98,8 @@ impl Process {\n \n         let env = config.env.map(|a| a.to_owned());\n         let cwd = config.cwd.map(|a| Path::new(a));\n-        let res = spawn_process_os(config.program, config.args, env,\n-                                   cwd.as_ref(), in_fd, out_fd, err_fd);\n+        let res = spawn_process_os(config, env, cwd.as_ref(), in_fd, out_fd,\n+                                   err_fd);\n \n         unsafe {\n             for pipe in in_pipe.iter() { let _ = libc::close(pipe.input); }\n@@ -180,7 +180,7 @@ struct SpawnProcessResult {\n }\n \n #[cfg(windows)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n+fn spawn_process_os(config: p::ProcessConfig,\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int,\n@@ -202,6 +202,14 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n     use std::mem;\n \n+    if config.gid.is_some() || config.uid.is_some() {\n+        return Err(io::IoError {\n+            kind: io::OtherIoError,\n+            desc: \"unsupported gid/uid requested on windows\",\n+            detail: None,\n+        })\n+    }\n+\n     unsafe {\n \n         let mut si = zeroed_startupinfo();\n@@ -237,16 +245,23 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n-        let cmd = make_command_line(prog, args);\n+        let cmd = make_command_line(config.program, config.args);\n         let mut pi = zeroed_process_information();\n         let mut create_err = None;\n \n+        // stolen from the libuv code.\n+        let mut flags = 0;\n+        if config.detach {\n+            flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+        }\n+\n         with_envp(env, |envp| {\n             with_dirp(dir, |dirp| {\n                 cmd.with_c_str(|cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n-                                                 0, envp, dirp, &mut si, &mut pi);\n+                                                 flags, envp, dirp, &mut si,\n+                                                 &mut pi);\n                     if created == FALSE {\n                         create_err = Some(super::last_error());\n                     }\n@@ -364,15 +379,14 @@ fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n }\n \n #[cfg(unix)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n+fn spawn_process_os(config: p::ProcessConfig,\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int,\n                     err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use std::libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use std::libc::funcs::bsd44::getdtablesize;\n     use std::libc::c_ulong;\n-    use std::unstable::intrinsics;\n \n     mod rustrt {\n         extern {\n@@ -441,22 +455,34 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         }\n         drop(input);\n \n+        fn fail(output: &mut file::FileDesc) -> ! {\n+            let errno = os::errno();\n+            let bytes = [\n+                (errno << 24) as u8,\n+                (errno << 16) as u8,\n+                (errno <<  8) as u8,\n+                (errno <<  0) as u8,\n+            ];\n+            assert!(output.inner_write(bytes).is_ok());\n+            unsafe { libc::_exit(1) }\n+        }\n+\n         rustrt::rust_unset_sigprocmask();\n \n         if in_fd == -1 {\n             let _ = libc::close(libc::STDIN_FILENO);\n         } else if retry(|| dup2(in_fd, 0)) == -1 {\n-            fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n+            fail(&mut output);\n         }\n         if out_fd == -1 {\n             let _ = libc::close(libc::STDOUT_FILENO);\n         } else if retry(|| dup2(out_fd, 1)) == -1 {\n-            fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n+            fail(&mut output);\n         }\n         if err_fd == -1 {\n             let _ = libc::close(libc::STDERR_FILENO);\n         } else if retry(|| dup2(err_fd, 2)) == -1 {\n-            fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n+            fail(&mut output);\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).rev() {\n@@ -465,9 +491,44 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             }\n         }\n \n+        match config.gid {\n+            Some(u) => {\n+                if libc::setgid(u as libc::gid_t) != 0 {\n+                    fail(&mut output);\n+                }\n+            }\n+            None => {}\n+        }\n+        match config.uid {\n+            Some(u) => {\n+                // When dropping privileges from root, the `setgroups` call will\n+                // remove any extraneous groups. If we don't call this, then\n+                // even though our uid has dropped, we may still have groups\n+                // that enable us to do super-user things. This will fail if we\n+                // aren't root, so don't bother checking the return value, this\n+                // is just done as an optimistic privilege dropping function.\n+                extern {\n+                    fn setgroups(ngroups: libc::c_int,\n+                                 ptr: *libc::c_void) -> libc::c_int;\n+                }\n+                let _ = setgroups(0, 0 as *libc::c_void);\n+\n+                if libc::setuid(u as libc::uid_t) != 0 {\n+                    fail(&mut output);\n+                }\n+            }\n+            None => {}\n+        }\n+        if config.detach {\n+            // Don't check the error of setsid because it fails if we're the\n+            // process leader already. We just forked so it shouldn't return\n+            // error, but ignore it anyway.\n+            let _ = libc::setsid();\n+        }\n+\n         with_dirp(dir, |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail!(\"failure in chdir: {}\", os::last_os_error());\n+                fail(&mut output);\n             }\n         });\n \n@@ -476,17 +537,9 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                 set_environ(envp);\n             }\n         });\n-        with_argv(prog, args, |argv| {\n+        with_argv(config.program, config.args, |argv| {\n             let _ = execvp(*argv, argv);\n-            let errno = os::errno();\n-            let bytes = [\n-                (errno << 24) as u8,\n-                (errno << 16) as u8,\n-                (errno <<  8) as u8,\n-                (errno <<  0) as u8,\n-            ];\n-            assert!(output.inner_write(bytes).is_ok());\n-            intrinsics::abort();\n+            fail(&mut output);\n         })\n     }\n }"}, {"sha": "a0623059bd71692e1253b713b9159a6c8eeb5c4b", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -58,6 +58,16 @@ impl Process {\n \n         let ret = with_argv(config.program, config.args, |argv| {\n             with_env(config.env, |envp| {\n+                let mut flags = 0;\n+                if config.uid.is_some() {\n+                    flags |= uvll::PROCESS_SETUID;\n+                }\n+                if config.gid.is_some() {\n+                    flags |= uvll::PROCESS_SETGID;\n+                }\n+                if config.detach {\n+                    flags |= uvll::PROCESS_DETACHED;\n+                }\n                 let options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n                     file: unsafe { *argv },\n@@ -67,11 +77,11 @@ impl Process {\n                         Some(ref cwd) => cwd.with_ref(|p| p),\n                         None => ptr::null(),\n                     },\n-                    flags: 0,\n+                    flags: flags as libc::c_uint,\n                     stdio_count: stdio.len() as libc::c_int,\n                     stdio: stdio.as_ptr(),\n-                    uid: 0,\n-                    gid: 0,\n+                    uid: config.uid.unwrap_or(0) as uvll::uv_uid_t,\n+                    gid: config.gid.unwrap_or(0) as uvll::uv_gid_t,\n                 };\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);"}, {"sha": "6540fcd85d3fd620ecc4c7c1608eebed470d6ee0", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 106, "deletions": 23, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -58,7 +58,21 @@ pub struct ProcessConfig<'a> {\n     ///     0 - stdin\n     ///     1 - stdout\n     ///     2 - stderr\n-    io: &'a [StdioContainer]\n+    io: &'a [StdioContainer],\n+\n+    /// Sets the child process's user id. This translates to a `setuid` call in\n+    /// the child process. Setting this value on windows will cause the spawn to\n+    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n+    /// fail.\n+    uid: Option<uint>,\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    gid: Option<uint>,\n+\n+    /// If true, the child process is spawned in a detached state. On unix, this\n+    /// means that the child is the leader of a new process group.\n+    detach: bool,\n }\n \n /// Describes what to do with a standard io stream for a child process.\n@@ -115,6 +129,36 @@ impl ProcessExit {\n     }\n }\n \n+impl<'a> ProcessConfig<'a> {\n+    /// Creates a new configuration with blanks as all of the defaults. This is\n+    /// useful when using functional struct updates:\n+    ///\n+    /// ```rust\n+    /// use std::io::process::{ProcessConfig, Process};\n+    ///\n+    /// let config = ProcessConfig {\n+    ///     program: \"/bin/sh\",\n+    ///     args: &'static [~\"-c\", ~\"echo hello\"],\n+    ///     .. ProcessConfig::new()\n+    /// };\n+    ///\n+    /// let p = Process::new(config);\n+    /// ```\n+    ///\n+    pub fn new() -> ProcessConfig<'static> {\n+        ProcessConfig {\n+            program: \"\",\n+            args: &'static [],\n+            env: None,\n+            cwd: None,\n+            io: &'static [],\n+            uid: None,\n+            gid: None,\n+            detach: false,\n+        }\n+    }\n+}\n+\n impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n@@ -175,13 +219,10 @@ mod tests {\n     // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn smoke() {\n-        let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"true\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n+            .. ProcessConfig::new()\n         };\n         let p = Process::new(args);\n         assert!(p.is_ok());\n@@ -192,13 +233,9 @@ mod tests {\n     // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn smoke_failure() {\n-        let io = ~[];\n         let args = ProcessConfig {\n             program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-            args: &[],\n-            env: None,\n-            cwd: None,\n-            io: io,\n+            .. ProcessConfig::new()\n         };\n         match Process::new(args) {\n             Ok(..) => fail!(),\n@@ -209,13 +246,10 @@ mod tests {\n     // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn exit_reported_right() {\n-        let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"exit 1\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n+            .. ProcessConfig::new()\n         };\n         let p = Process::new(args);\n         assert!(p.is_ok());\n@@ -225,13 +259,10 @@ mod tests {\n \n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn signal_reported_right() {\n-        let io = ~[];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"kill -1 $$\"],\n-            env: None,\n-            cwd: None,\n-            io: io,\n+            .. ProcessConfig::new()\n         };\n         let p = Process::new(args);\n         assert!(p.is_ok());\n@@ -264,9 +295,8 @@ mod tests {\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"echo foobar\"],\n-            env: None,\n-            cwd: None,\n             io: io,\n+            .. ProcessConfig::new()\n         };\n         assert_eq!(run_output(args), ~\"foobar\\n\");\n     })\n@@ -279,9 +309,9 @@ mod tests {\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"pwd\"],\n-            env: None,\n             cwd: cwd,\n             io: io,\n+            .. ProcessConfig::new()\n         };\n         assert_eq!(run_output(args), ~\"/\\n\");\n     })\n@@ -294,9 +324,8 @@ mod tests {\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"read line; echo $line\"],\n-            env: None,\n-            cwd: None,\n             io: io,\n+            .. ProcessConfig::new()\n         };\n         let mut p = Process::new(args).unwrap();\n         p.io[0].get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n@@ -306,4 +335,58 @@ mod tests {\n         assert_eq!(out, ~\"foobar\\n\");\n     })\n \n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn detach_works() {\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: &[~\"-c\", ~\"true\"],\n+            detach: true,\n+            .. ProcessConfig::new()\n+        };\n+        let mut p = Process::new(args).unwrap();\n+        assert!(p.wait().success());\n+    })\n+\n+    #[cfg(windows)]\n+    iotest!(fn uid_fails_on_windows() {\n+        let args = ProcessConfig {\n+            program: \"test\",\n+            uid: Some(10),\n+            .. ProcessConfig::new()\n+        };\n+        assert!(Process::new(args).is_err());\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn uid_works() {\n+        use libc;\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: &[~\"-c\", ~\"true\"],\n+            uid: Some(unsafe { libc::getuid() as uint }),\n+            gid: Some(unsafe { libc::getgid() as uint }),\n+            .. ProcessConfig::new()\n+        };\n+        let mut p = Process::new(args).unwrap();\n+        assert!(p.wait().success());\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn uid_to_root_fails() {\n+        use libc;\n+\n+        // if we're already root, this isn't a valid test. Most of the bots run\n+        // as non-root though (android is an exception).\n+        if unsafe { libc::getuid() == 0 } { return }\n+        let args = ProcessConfig {\n+            program: \"/bin/ls\",\n+            uid: Some(0),\n+            gid: Some(0),\n+            .. ProcessConfig::new()\n+        };\n+        assert!(Process::new(args).is_err());\n+    })\n }"}, {"sha": "7dc4c692f6319559909fb340fa295afd0f06d239", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -159,7 +159,7 @@ pub use libc::funcs::c95::stdio::{fread, freopen, fseek, fsetpos, ftell};\n pub use libc::funcs::c95::stdio::{fwrite, perror, puts, remove, rewind};\n pub use libc::funcs::c95::stdio::{setbuf, setvbuf, tmpfile, ungetc};\n \n-pub use libc::funcs::c95::stdlib::{abs, atof, atoi, calloc, exit};\n+pub use libc::funcs::c95::stdlib::{abs, atof, atoi, calloc, exit, _exit};\n pub use libc::funcs::c95::stdlib::{free, getenv, labs, malloc, rand};\n pub use libc::funcs::c95::stdlib::{realloc, srand, strtod, strtol};\n pub use libc::funcs::c95::stdlib::{strtoul, system};\n@@ -1769,6 +1769,9 @@ pub mod consts {\n             pub static MAX_PROTOCOL_CHAIN: DWORD = 7;\n             pub static WSAPROTOCOL_LEN: DWORD = 255;\n             pub static INVALID_SOCKET: DWORD = !0;\n+\n+            pub static DETACHED_PROCESS: DWORD = 0x00000008;\n+            pub static CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n         }\n         pub mod sysconf {\n         }\n@@ -3340,6 +3343,7 @@ pub mod funcs {\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n                 pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n+                pub fn _exit(status: c_int) -> !;\n                 // Omitted: atexit.\n                 pub fn system(s: *c_char) -> c_int;\n                 pub fn getenv(s: *c_char) -> *c_char;"}, {"sha": "9ea8f6447dd6a96828bb4dbcb4140fcc0a4b42f4", "filename": "src/libstd/run.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -88,6 +88,20 @@ pub struct ProcessOptions<'a> {\n      * and Process.error() will fail.\n      */\n     err_fd: Option<c_int>,\n+\n+    /// The uid to assume for the child process. For more information, see the\n+    /// documentation in `io::process::ProcessConfig` about this field.\n+    uid: Option<uint>,\n+\n+    /// The gid to assume for the child process. For more information, see the\n+    /// documentation in `io::process::ProcessConfig` about this field.\n+    gid: Option<uint>,\n+\n+    /// Flag as to whether the child process will be the leader of a new process\n+    /// group or not. This allows the parent process to exit while the child is\n+    /// still running. For more information, see the documentation in\n+    /// `io::process::ProcessConfig` about this field.\n+    detach: bool,\n }\n \n impl <'a> ProcessOptions<'a> {\n@@ -99,6 +113,9 @@ impl <'a> ProcessOptions<'a> {\n             in_fd: None,\n             out_fd: None,\n             err_fd: None,\n+            uid: None,\n+            gid: None,\n+            detach: false,\n         }\n     }\n }\n@@ -128,7 +145,9 @@ impl Process {\n      */\n     pub fn new(prog: &str, args: &[~str],\n                options: ProcessOptions) -> io::IoResult<Process> {\n-        let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n+        let ProcessOptions {\n+            env, dir, in_fd, out_fd, err_fd, uid, gid, detach\n+        } = options;\n         let env = env.as_ref().map(|a| a.as_slice());\n         let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n         fn rtify(fd: Option<c_int>, input: bool) -> process::StdioContainer {\n@@ -145,6 +164,9 @@ impl Process {\n             env: env,\n             cwd: cwd,\n             io: rtio,\n+            uid: uid,\n+            gid: gid,\n+            detach: detach,\n         };\n         process::Process::new(rtconfig).map(|p| Process { inner: p })\n     }\n@@ -302,11 +324,10 @@ impl Process {\n  */\n pub fn process_status(prog: &str, args: &[~str]) -> io::IoResult<ProcessExit> {\n     Process::new(prog, args, ProcessOptions {\n-        env: None,\n-        dir: None,\n         in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n         out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n-        err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n+        err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) }),\n+        .. ProcessOptions::new()\n     }).map(|mut p| p.finish())\n }\n \n@@ -396,11 +417,10 @@ mod tests {\n         let pipe_err = os::pipe();\n \n         let mut process = run::Process::new(\"cat\", [], run::ProcessOptions {\n-            dir: None,\n-            env: None,\n             in_fd: Some(pipe_in.input),\n             out_fd: Some(pipe_out.out),\n-            err_fd: Some(pipe_err.out)\n+            err_fd: Some(pipe_err.out),\n+            .. run::ProcessOptions::new()\n         }).unwrap();\n \n         os::close(pipe_in.input as int);"}, {"sha": "800b56fe6af21ffd8e56aee8cf12dd758f5bbdf1", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -1 +1 @@\n-Subproject commit fd5308383c575472edb2163d823dc6670bf59609\n+Subproject commit 800b56fe6af21ffd8e56aee8cf12dd758f5bbdf1"}, {"sha": "961455b9093bec909c45d1a1bd83f99b09b3b9f4", "filename": "src/rt/libuv-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Frt%2Flibuv-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Frt%2Flibuv-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv-auto-clean-trigger?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -1,2 +1,2 @@\n # Change the contents of this file to force a full rebuild of libuv\n-2013-12-23\n+2014-02-16"}, {"sha": "94964fbc89bc7b609c19ea3bdc4c1fa09d30ab2b", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -33,7 +33,10 @@ pub fn main () {\n         args : &[~\"child\"],\n         env : None,\n         cwd : None,\n-        io : &[]\n+        io : &[],\n+        uid: None,\n+        gid: None,\n+        detach: false,\n     };\n \n     let mut p = process::Process::new(config).unwrap();"}, {"sha": "91f77caf8a3d10deae6cbf5daf2d211732aacd39", "filename": "src/test/run-pass/process-detach.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8489069b43191c5298f17430933b3b88fb79c3c/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=c8489069b43191c5298f17430933b3b88fb79c3c", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+// ignore-win32\n+// ignore-android\n+\n+// This test ensures that the 'detach' field on processes does the right thing.\n+// By detaching the child process, they should be put into a separate process\n+// group. We test this by spawning a detached process, then killing our own\n+// group with a signal.\n+//\n+// Note that the first thing we do is put ourselves in our own process group so\n+// we don't interfere with other running tests.\n+\n+use std::libc;\n+use std::io::process;\n+use std::io::signal::{Listener, Interrupt};\n+\n+fn main() {\n+    unsafe { libc::setsid(); }\n+\n+    let config = process::ProcessConfig {\n+        program : \"/bin/sh\",\n+        args : &[~\"-c\", ~\"read a\"],\n+        io : &[process::CreatePipe(true, false)],\n+        detach: true,\n+        .. process::ProcessConfig::new()\n+    };\n+\n+    // we shouldn't die because of an interrupt\n+    let mut l = Listener::new();\n+    l.register(Interrupt).unwrap();\n+\n+    // spawn the child\n+    let mut p = process::Process::new(config).unwrap();\n+\n+    // send an interrupt to everyone in our process group\n+    unsafe { libc::funcs::posix88::signal::kill(0, libc::SIGINT); }\n+\n+    // Wait for the child process to die (terminate it's stdin and the read\n+    // should fail).\n+    drop(p.io[0].take());\n+    match p.wait() {\n+        process::ExitStatus(..) => {}\n+        process::ExitSignal(..) => fail!()\n+    }\n+}\n+"}]}