{"sha": "cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOThjM2Q5M2E0YzBlNzlhZTg3YTA0YTZkM2E0MzlhYzhlZDg3YjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-07T23:45:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-08T01:26:21Z"}, "message": "Normalize types of fields in struct literals during type-checking.\nFixes #20535.", "tree": {"sha": "0cd67e45ea49a554680a30488aae4b7f2b184369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd67e45ea49a554680a30488aae4b7f2b184369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "html_url": "https://github.com/rust-lang/rust/commit/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f426e647d05a422d0fcae65c8a87a8e4befb69", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f426e647d05a422d0fcae65c8a87a8e4befb69", "html_url": "https://github.com/rust-lang/rust/commit/18f426e647d05a422d0fcae65c8a87a8e4befb69"}], "stats": {"total": 129, "additions": 74, "deletions": 55}, "files": [{"sha": "3534d3ff3afabcc117650099059aab5069149486", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "patch": "@@ -52,7 +52,6 @@ use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n-use middle::subst::{VecPerParamSpace};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n@@ -244,7 +243,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n \n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n-fn ast_path_substs_for_ty<'tcx>(\n+pub fn ast_path_substs_for_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     decl_generics: &ty::Generics<'tcx>,\n@@ -762,50 +761,6 @@ pub fn ast_path_to_ty<'tcx>(\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n \n-/// Returns the type that this AST path refers to. If the path has no type\n-/// parameters and the corresponding type has type parameters, fresh type\n-/// and/or region variables are substituted.\n-///\n-/// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx>(\n-    this: &AstConv<'tcx>,\n-    rscope: &RegionScope,\n-    did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts<'tcx>\n-{\n-    let tcx = this.tcx();\n-    let ty::TypeScheme {\n-        generics,\n-        ty: decl_ty\n-    } = this.get_item_type_scheme(did);\n-\n-    let wants_params =\n-        generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n-\n-    let needs_defaults =\n-        wants_params &&\n-        path.segments.iter().all(|s| s.parameters.is_empty());\n-\n-    let substs = if needs_defaults {\n-        let type_params: Vec<_> = range(0, generics.types.len(TypeSpace))\n-                                      .map(|_| this.ty_infer(path.span)).collect();\n-        let region_params =\n-            rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n-                  .unwrap();\n-        Substs::new(VecPerParamSpace::params_from_type(type_params),\n-                    VecPerParamSpace::params_from_type(region_params))\n-    } else {\n-        ast_path_substs_for_ty(this, rscope, &generics, path)\n-    };\n-\n-    let ty = decl_ty.subst(tcx, &substs);\n-    TypeAndSubsts {\n-        substs: substs,\n-        ty: ty,\n-    }\n-}\n-\n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n pub fn ast_ty_to_builtin_ty<'tcx>("}, {"sha": "87175279bae1fb7d5c0995763518bd0a3f11c083", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "patch": "@@ -90,7 +90,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n use middle::region::CodeExtent;\n-use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n use middle::ty::{FnSig, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n@@ -1947,6 +1947,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Returns the type that this AST path refers to. If the path has no type\n+    /// parameters and the corresponding type has type parameters, fresh type\n+    /// and/or region variables are substituted.\n+    ///\n+    /// This is used when checking the constructor in struct literals.\n+    fn instantiate_struct_literal_ty(&self,\n+                                     did: ast::DefId,\n+                                     path: &ast::Path)\n+                                     -> TypeAndSubsts<'tcx>\n+    {\n+        let tcx = self.tcx();\n+\n+        let ty::TypeScheme { generics, ty: decl_ty } = ty::lookup_item_type(tcx, did);\n+\n+        let wants_params =\n+            generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n+\n+        let needs_defaults =\n+            wants_params &&\n+            path.segments.iter().all(|s| s.parameters.is_empty());\n+\n+        let substs = if needs_defaults {\n+            let tps =\n+                self.infcx().next_ty_vars(generics.types.len(TypeSpace));\n+            let rps =\n+                self.infcx().region_vars_for_defs(path.span,\n+                                                  generics.regions.get_slice(TypeSpace));\n+            Substs::new_type(tps, rps)\n+        } else {\n+            astconv::ast_path_substs_for_ty(self, self, &generics, path)\n+        };\n+\n+        let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n+\n+        TypeAndSubsts { substs: substs, ty: ty }\n+    }\n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n@@ -3490,17 +3527,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     expected_field_type =\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, substitutions);\n+                    expected_field_type =\n+                        fcx.normalize_associated_types_in(\n+                            field.span, &expected_field_type);\n                     class_field_map.insert(\n                         field.ident.node.name, (field_id, true));\n                     fields_found += 1;\n                 }\n             }\n+\n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            check_expr_coercable_to_type(\n-                    fcx,\n-                    &*field.expr,\n-                    expected_field_type);\n+            check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n         }\n \n         if error_happened {\n@@ -4149,10 +4187,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // parameters correctly.\n         let actual_structure_type = fcx.expr_ty(&*expr);\n         if !ty::type_is_error(actual_structure_type) {\n-            let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n-                                                                  fcx,\n-                                                                  struct_id,\n-                                                                  path);\n+            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,"}, {"sha": "b51d44a0c244bfb99bd7be0e42c42a21e25874dc", "filename": "src/test/run-pass/associated-types-ref-in-struct-literal.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-ref-in-struct-literal.rs?ref=cb98c3d93a4c0e79ae87a04a6d3a439ac8ed87b1", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test associated type references in a struct literal. Issue #20535.\n+\n+pub trait Foo {\n+    type Bar;\n+}\n+\n+impl Foo for int {\n+    type Bar = int;\n+}\n+\n+struct Thing<F: Foo> {\n+    a: F,\n+    b: F::Bar,\n+}\n+\n+fn main() {\n+    let thing = Thing{a: 1i, b: 2i};\n+    assert_eq!(thing.a + 1, thing.b);\n+}"}]}