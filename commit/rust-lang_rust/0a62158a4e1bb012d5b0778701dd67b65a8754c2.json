{"sha": "0a62158a4e1bb012d5b0778701dd67b65a8754c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNjIxNThhNGUxYmIwMTJkNWIwNzc4NzAxZGQ2N2I2NWE4NzU0YzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-21T21:30:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T09:35:00Z"}, "message": "Add helper methods that require tcx; these compute types of\nlvalues and operands", "tree": {"sha": "8aedae1f5d35add871746c21055c10ad87dea6ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aedae1f5d35add871746c21055c10ad87dea6ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a62158a4e1bb012d5b0778701dd67b65a8754c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a62158a4e1bb012d5b0778701dd67b65a8754c2", "html_url": "https://github.com/rust-lang/rust/commit/0a62158a4e1bb012d5b0778701dd67b65a8754c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a62158a4e1bb012d5b0778701dd67b65a8754c2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "044096b3e9a8d02461d49fb5559bb11c4308e701", "url": "https://api.github.com/repos/rust-lang/rust/commits/044096b3e9a8d02461d49fb5559bb11c4308e701", "html_url": "https://github.com/rust-lang/rust/commit/044096b3e9a8d02461d49fb5559bb11c4308e701"}], "stats": {"total": 127, "additions": 126, "deletions": 1}, "files": [{"sha": "5c52dfe2bd673cf5b721d81f107490e17f206a41", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a62158a4e1bb012d5b0778701dd67b65a8754c2/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a62158a4e1bb012d5b0778701dd67b65a8754c2/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0a62158a4e1bb012d5b0778701dd67b65a8754c2", "patch": "@@ -34,5 +34,5 @@ pub mod mir_map;\n mod hair;\n pub mod repr;\n mod graphviz;\n-\n+pub mod tcx;\n "}, {"sha": "3b9d9228a1680ff5f59ffcc996d1f2bd882ef313", "filename": "src/librustc_mir/tcx/mod.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0a62158a4e1bb012d5b0778701dd67b65a8754c2/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a62158a4e1bb012d5b0778701dd67b65a8754c2/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=0a62158a4e1bb012d5b0778701dd67b65a8754c2", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Methods for the various MIR types. These are intended for use after\n+ * building is complete.\n+ */\n+\n+use repr::*;\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{self, AdtDef, Ty};\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LvalueTy<'tcx> {\n+    /// Normal type.\n+    Ty { ty: Ty<'tcx> },\n+\n+    /// Downcast to a particular variant of an enum.\n+    Downcast { adt_def: AdtDef<'tcx>,\n+               substs: &'tcx Substs<'tcx>,\n+               variant_index: usize },\n+}\n+\n+impl<'tcx> LvalueTy<'tcx> {\n+    pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n+        LvalueTy::Ty { ty: ty }\n+    }\n+\n+    pub fn to_ty(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            LvalueTy::Ty { ty } =>\n+                ty,\n+            LvalueTy::Downcast { adt_def, substs, variant_index: _ } =>\n+                tcx.mk_enum(adt_def, substs),\n+        }\n+    }\n+\n+    pub fn projection_ty(self,\n+                         tcx: &ty::ctxt<'tcx>,\n+                         elem: &LvalueElem<'tcx>)\n+                         -> LvalueTy<'tcx>\n+    {\n+        match *elem {\n+            ProjectionElem::Deref =>\n+                LvalueTy::Ty {\n+                    ty: self.to_ty(tcx).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                          .unwrap()\n+                                          .ty\n+                },\n+            ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n+                LvalueTy::Ty {\n+                    ty: self.to_ty(tcx).builtin_index().unwrap()\n+                },\n+            ProjectionElem::Downcast(adt_def1, index) =>\n+                match self.to_ty(tcx).sty {\n+                    ty::TyEnum(adt_def, substs) => {\n+                        assert!(index < adt_def.variants.len());\n+                        assert_eq!(adt_def, adt_def1);\n+                        LvalueTy::Downcast { adt_def: adt_def,\n+                                             substs: substs,\n+                                             variant_index: index }\n+                    }\n+                    _ => {\n+                        tcx.sess.bug(&format!(\"cannot downcast non-enum type: `{:?}`\", self))\n+                    }\n+                },\n+            ProjectionElem::Field(field) => {\n+                let field_ty = match self {\n+                    LvalueTy::Ty { ty } => match ty.sty {\n+                        ty::TyStruct(adt_def, substs) =>\n+                            adt_def.struct_variant().fields[field.index()].ty(tcx, substs),\n+                        ty::TyTuple(ref tys) =>\n+                            tys[field.index()],\n+                        _ =>\n+                            tcx.sess.bug(&format!(\"cannot get field of type: `{:?}`\", ty)),\n+                    },\n+                    LvalueTy::Downcast { adt_def, substs, variant_index } =>\n+                        adt_def.variants[variant_index].fields[field.index()].ty(tcx, substs),\n+                };\n+                LvalueTy::Ty { ty: field_ty }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> Mir<'tcx> {\n+    pub fn operand_ty(&self,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      operand: &Operand<'tcx>)\n+                      -> Ty<'tcx>\n+    {\n+        match *operand {\n+            Operand::Consume(ref l) => self.lvalue_ty(tcx, l).to_ty(tcx),\n+            Operand::Constant(ref c) => c.ty,\n+        }\n+    }\n+\n+    pub fn lvalue_ty(&self,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     lvalue: &Lvalue<'tcx>)\n+                     -> LvalueTy<'tcx>\n+    {\n+        match *lvalue {\n+            Lvalue::Var(index) =>\n+                LvalueTy::Ty { ty: self.var_decls[index as usize].ty },\n+            Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: self.temp_decls[index as usize].ty },\n+            Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: self.arg_decls[index as usize].ty },\n+            Lvalue::Static(def_id) =>\n+                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+            Lvalue::ReturnPointer =>\n+                LvalueTy::Ty { ty: self.return_ty.unwrap() },\n+            Lvalue::Projection(ref proj) =>\n+                self.lvalue_ty(tcx, &proj.base).projection_ty(tcx, &proj.elem)\n+        }\n+    }\n+}"}]}