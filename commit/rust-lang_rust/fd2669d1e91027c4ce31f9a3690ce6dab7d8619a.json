{"sha": "fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "node_id": "C_kwDOAAsO6NoAKGZkMjY2OWQxZTkxMDI3YzRjZTMxZjlhMzY5MGNlNmRhYjdkODYxOWE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-25T13:17:53Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-25T13:17:53Z"}, "message": "Fix -Zpolymorphize", "tree": {"sha": "1cdd98003f065243a5ade19c6359aa30f7c52488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cdd98003f065243a5ade19c6359aa30f7c52488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "html_url": "https://github.com/rust-lang/rust/commit/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ef2ba8f7b2b3076d906567bb107b0437c45be48", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef2ba8f7b2b3076d906567bb107b0437c45be48", "html_url": "https://github.com/rust-lang/rust/commit/7ef2ba8f7b2b3076d906567bb107b0437c45be48"}], "stats": {"total": 62, "additions": 49, "deletions": 13}, "files": [{"sha": "944787612d8bc206e1a29a7ab130518696ecc410", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "patch": "@@ -99,9 +99,6 @@ rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n # ============\n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n \n-rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n-rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs"}, {"sha": "6c10baa53d415da6e32e64adebecab4d57a059d4", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "patch": "@@ -216,7 +216,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n-    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty, 16);\n     match arg_abi.mode {\n         PassMode::Ignore => smallvec![],\n         PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],"}, {"sha": "c83dab951bc471e8c7260da119b4a95f5fdffd9d", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "patch": "@@ -432,7 +432,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n-                    let func_id = crate::abi::import_function(tcx, module, instance);\n+                    let func_id =\n+                        crate::abi::import_function(tcx, module, instance.polymorphize(tcx));\n                     let local_func_id = module.declare_func_in_data(func_id, &mut data_ctx);\n                     data_ctx.write_function_addr(offset.bytes() as u32, local_func_id);\n                     continue;"}, {"sha": "c67b6e98b32c7daeeca8558ed2882f082cd0b103", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "patch": "@@ -109,7 +109,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n                 )\n                 .unwrap()\n-                .unwrap();\n+                .unwrap()\n+                .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n                 let report_sig = get_function_sig(tcx, m.isa().triple(), report);"}, {"sha": "6674099e9a23b8263d84e70e2cf22bf8637d2840", "filename": "src/value_and_place.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "patch": "@@ -426,7 +426,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n-        assert_assignable(fx, from.layout().ty, self.layout().ty);\n+        assert_assignable(fx, from.layout().ty, self.layout().ty, 16);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n@@ -788,18 +788,25 @@ pub(crate) fn assert_assignable<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n+    limit: usize,\n ) {\n+    if limit == 0 {\n+        // assert_assignable exists solely to catch bugs in cg_clif. it isn't necessary for\n+        // soundness. don't attempt to check deep types to avoid exponential behavior in certain\n+        // cases.\n+        return;\n+    }\n     match (from_ty.kind(), to_ty.kind()) {\n         (ty::Ref(_, a, _), ty::Ref(_, b, _))\n         | (\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n@@ -829,25 +836,55 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Tuple(types_a), &ty::Tuple(types_b)) => {\n+            let mut types_a = types_a.iter();\n+            let mut types_b = types_b.iter();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n             if adt_def_a.did() == adt_def_b.did() =>\n         {\n             let mut types_a = substs_a.types();\n             let mut types_b = substs_b.types();\n             loop {\n                 match (types_a.next(), types_b.next()) {\n-                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n                     (None, None) => return,\n                     (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n                 }\n             }\n         }\n-        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b),\n+        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b, limit - 1),\n+        (&ty::Closure(def_id_a, substs_a), &ty::Closure(def_id_b, substs_b))\n+            if def_id_a == def_id_b =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n+        (ty::Param(_), _) | (_, ty::Param(_)) if fx.tcx.sess.opts.unstable_opts.polymorphize => {\n+            // No way to check if it is correct or not with polymorphization enabled\n+        }\n         _ => {\n             assert_eq!(\n-                from_ty, to_ty,\n+                from_ty,\n+                to_ty,\n                 \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                from_ty, to_ty, fx,\n+                from_ty.kind(),\n+                to_ty.kind(),\n+                fx,\n             );\n         }\n     }"}]}