{"sha": "b3b1e62750bbce86833409ac59d9797fd5ba2964", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYjFlNjI3NTBiYmNlODY4MzM0MDlhYzU5ZDk3OTdmZDViYTI5NjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-18T23:48:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-18T23:48:58Z"}, "message": "rustdoc: Camel case", "tree": {"sha": "f40c9acec889747161195eb2ce9020018510c1e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f40c9acec889747161195eb2ce9020018510c1e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3b1e62750bbce86833409ac59d9797fd5ba2964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b1e62750bbce86833409ac59d9797fd5ba2964", "html_url": "https://github.com/rust-lang/rust/commit/b3b1e62750bbce86833409ac59d9797fd5ba2964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3b1e62750bbce86833409ac59d9797fd5ba2964/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86e8c16e6b10d2b58577d10e713149f7f8a97fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86e8c16e6b10d2b58577d10e713149f7f8a97fa", "html_url": "https://github.com/rust-lang/rust/commit/e86e8c16e6b10d2b58577d10e713149f7f8a97fa"}], "stats": {"total": 1860, "additions": 929, "deletions": 931}, "files": [{"sha": "b0edb14f9993ad0f08fe8a1a60998c5c6a119ab6", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -21,53 +21,53 @@ use rustc::back::link;\n use rustc::metadata::filesearch;\n use rustc::front;\n \n-export ctxt;\n-export ctxt_handler;\n-export srv;\n+export Ctxt;\n+export CtxtHandler;\n+export Srv;\n export from_str;\n export from_file;\n export exec;\n \n-type ctxt = {\n+type Ctxt = {\n     ast: @ast::crate,\n     ast_map: ast_map::map\n };\n \n-type srv_owner<T> = fn(srv: srv) -> T;\n-type ctxt_handler<T> = fn~(ctxt: ctxt) -> T;\n-type parser = fn~(session, ~str) -> @ast::crate;\n+type SrvOwner<T> = fn(srv: Srv) -> T;\n+type CtxtHandler<T> = fn~(ctxt: Ctxt) -> T;\n+type Parser = fn~(session, ~str) -> @ast::crate;\n \n-enum msg {\n-    handle_request(fn~(ctxt)),\n-    exit\n+enum Msg {\n+    HandleRequest(fn~(Ctxt)),\n+    Exit\n }\n \n-enum srv = {\n-    ch: comm::Chan<msg>\n+enum Srv = {\n+    ch: comm::Chan<Msg>\n };\n \n-fn from_str<T>(source: ~str, owner: srv_owner<T>) -> T {\n+fn from_str<T>(source: ~str, owner: SrvOwner<T>) -> T {\n     run(owner, source, parse::from_str_sess)\n }\n \n-fn from_file<T>(file: ~str, owner: srv_owner<T>) -> T {\n+fn from_file<T>(file: ~str, owner: SrvOwner<T>) -> T {\n     run(owner, file, |sess, f| parse::from_file_sess(sess, &Path(f)))\n }\n \n-fn run<T>(owner: srv_owner<T>, source: ~str, +parse: parser) -> T {\n+fn run<T>(owner: SrvOwner<T>, source: ~str, +parse: Parser) -> T {\n \n-    let srv_ = srv({\n+    let srv_ = Srv({\n         ch: do task::spawn_listener |po| {\n             act(po, source, parse);\n         }\n     });\n \n     let res = owner(srv_);\n-    comm::send(srv_.ch, exit);\n+    comm::send(srv_.ch, Exit);\n     return res;\n }\n \n-fn act(po: comm::Port<msg>, source: ~str, parse: parser) {\n+fn act(po: comm::Port<Msg>, source: ~str, parse: Parser) {\n     let sess = build_session();\n \n     let ctxt = build_ctxt(\n@@ -78,31 +78,31 @@ fn act(po: comm::Port<msg>, source: ~str, parse: parser) {\n     let mut keep_going = true;\n     while keep_going {\n         match comm::recv(po) {\n-          handle_request(f) => {\n+          HandleRequest(f) => {\n             f(ctxt);\n           }\n-          exit => {\n+          Exit => {\n             keep_going = false;\n           }\n         }\n     }\n }\n \n fn exec<T:Send>(\n-    srv: srv,\n-    +f: fn~(ctxt: ctxt) -> T\n+    srv: Srv,\n+    +f: fn~(ctxt: Ctxt) -> T\n ) -> T {\n     let po = comm::Port();\n     let ch = comm::Chan(po);\n-    let msg = handle_request(fn~(move f, ctxt: ctxt) {\n+    let msg = HandleRequest(fn~(move f, ctxt: Ctxt) {\n         comm::send(ch, f(ctxt))\n     });\n     comm::send(srv.ch, msg);\n     comm::recv(po)\n }\n \n fn build_ctxt(sess: session,\n-              ast: @ast::crate) -> ctxt {\n+              ast: @ast::crate) -> Ctxt {\n \n     use rustc::front::config;\n \n@@ -129,7 +129,7 @@ fn build_session() -> session {\n     session\n }\n \n-type error_handlers = {\n+type ErrorHandlers = {\n     emitter: diagnostic::emitter,\n     span_handler: diagnostic::span_handler\n };\n@@ -138,13 +138,13 @@ type error_handlers = {\n // errors\n fn build_error_handlers(\n     codemap: codemap::codemap\n-) -> error_handlers {\n+) -> ErrorHandlers {\n \n-    type diagnostic_handler = {\n+    type DiagnosticHandler = {\n         inner: diagnostic::handler,\n     };\n \n-    impl diagnostic_handler: diagnostic::handler {\n+    impl DiagnosticHandler: diagnostic::handler {\n         fn fatal(msg: ~str) -> ! { self.inner.fatal(msg) }\n         fn err(msg: ~str) { self.inner.err(msg) }\n         fn bump_err_count() {"}, {"sha": "f72c41df6da01810102771342791a614f9d731a5", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -9,11 +9,11 @@ use syntax::ast;\n use syntax::attr;\n use core::tuple;\n \n-export crate_attrs;\n+export CrateAttrs;\n export parse_crate, parse_desc;\n export parse_hidden;\n \n-type crate_attrs = {\n+type CrateAttrs = {\n     name: Option<~str>\n };\n \n@@ -59,7 +59,7 @@ fn doc_meta(\n     }\n }\n \n-fn parse_crate(attrs: ~[ast::attribute]) -> crate_attrs {\n+fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n \n     {"}, {"sha": "354332db0ff51f7e03efd04de5386fd6a02e460d", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -6,26 +6,26 @@\n      of the natural-language documentation for a crate.\"\n )];\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n use extract::to_str;\n use syntax::ast;\n use syntax::ast_map;\n use std::map::HashMap;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"attr\",\n         f: run\n     }\n }\n \n fn run(\n-    srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    srv: astsrv::Srv,\n+    doc: doc::Doc\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n@@ -37,9 +37,9 @@ fn run(\n }\n \n fn fold_crate(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::CrateDoc\n+) -> doc::CrateDoc {\n \n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_crate(fold, doc);\n@@ -50,7 +50,7 @@ fn fold_crate(\n     };\n \n     {\n-        topmod: doc::moddoc_({\n+        topmod: doc::ModDoc_({\n             item: {\n                 name: option::get_default(attrs.name, doc.topmod.name()),\n                 .. doc.topmod.item\n@@ -67,9 +67,9 @@ fn should_replace_top_module_name_with_crate_name() {\n }\n \n fn fold_item(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::itemdoc\n-) -> doc::itemdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::ItemDoc\n+) -> doc::ItemDoc {\n \n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_item(fold, doc);\n@@ -90,8 +90,8 @@ fn fold_item(\n }\n \n fn parse_item_attrs<T:Send>(\n-    srv: astsrv::srv,\n-    id: doc::ast_id,\n+    srv: astsrv::Srv,\n+    id: doc::AstId,\n     +parse_attrs: fn~(~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get(id) {\n@@ -134,9 +134,9 @@ fn should_extract_fn_attributes() {\n }\n \n fn fold_enum(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::enumdoc\n-) -> doc::enumdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::EnumDoc\n+) -> doc::EnumDoc {\n \n     let srv = fold.ctxt;\n     let doc_id = doc.id();\n@@ -184,9 +184,9 @@ fn should_extract_variant_docs() {\n }\n \n fn fold_trait(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::traitdoc\n-) -> doc::traitdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::TraitDoc\n+) -> doc::TraitDoc {\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n@@ -197,10 +197,10 @@ fn fold_trait(\n }\n \n fn merge_method_attrs(\n-    srv: astsrv::srv,\n-    item_id: doc::ast_id,\n-    docs: ~[doc::methoddoc]\n-) -> ~[doc::methoddoc] {\n+    srv: astsrv::Srv,\n+    item_id: doc::AstId,\n+    docs: ~[doc::MethodDoc]\n+) -> ~[doc::MethodDoc] {\n \n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n@@ -259,9 +259,9 @@ fn should_extract_trait_method_docs() {\n \n \n fn fold_impl(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::ImplDoc\n+) -> doc::ImplDoc {\n     let srv = fold.ctxt;\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n@@ -290,7 +290,7 @@ fn should_extract_impl_method_docs() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             run(srv, doc)"}, {"sha": "9c34b0629615c1f20845a30af7480e4a46c1d3d7", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,51 +1,51 @@\n use result::Result;\n use std::getopts;\n \n-export output_format;\n-export output_style;\n-export config;\n+export OutputFormat;\n+export OutputStyle;\n+export Config;\n export default_config;\n export parse_config;\n export usage;\n-export markdown, pandoc_html;\n-export doc_per_crate, doc_per_mod;\n+export Markdown, PandocHtml;\n+export DocPerCrate, DocPerMod;\n \n /// The type of document to output\n-enum output_format {\n+enum OutputFormat {\n     /// Markdown\n-    markdown,\n+    Markdown,\n     /// HTML, via markdown and pandoc\n-    pandoc_html\n+    PandocHtml\n }\n \n-impl output_format : cmp::Eq {\n-    pure fn eq(&&other: output_format) -> bool {\n+impl OutputFormat : cmp::Eq {\n+    pure fn eq(&&other: OutputFormat) -> bool {\n         (self as uint) == (other as uint)\n     }\n-    pure fn ne(&&other: output_format) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: OutputFormat) -> bool { !self.eq(other) }\n }\n \n /// How to organize the output\n-enum output_style {\n+enum OutputStyle {\n     /// All in a single document\n-    doc_per_crate,\n+    DocPerCrate,\n     /// Each module in its own document\n-    doc_per_mod\n+    DocPerMod\n }\n \n-impl output_style : cmp::Eq {\n-    pure fn eq(&&other: output_style) -> bool {\n+impl OutputStyle : cmp::Eq {\n+    pure fn eq(&&other: OutputStyle) -> bool {\n         (self as uint) == (other as uint)\n     }\n-    pure fn ne(&&other: output_style) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: OutputStyle) -> bool { !self.eq(other) }\n }\n \n /// The configuration for a rustdoc session\n-type config = {\n+type Config = {\n     input_crate: Path,\n     output_dir: Path,\n-    output_format: output_format,\n-    output_style: output_style,\n+    output_format: OutputFormat,\n+    output_style: OutputStyle,\n     pandoc_cmd: Option<~str>\n };\n \n@@ -81,17 +81,17 @@ fn usage() {\n     println(~\"\");\n }\n \n-fn default_config(input_crate: &Path) -> config {\n+fn default_config(input_crate: &Path) -> Config {\n     {\n         input_crate: *input_crate,\n         output_dir: Path(\".\"),\n-        output_format: pandoc_html,\n-        output_style: doc_per_mod,\n+        output_format: PandocHtml,\n+        output_style: DocPerMod,\n         pandoc_cmd: None\n     }\n }\n \n-type program_output = fn~((&str), (&[~str])) ->\n+type ProgramOutput = fn~((&str), (&[~str])) ->\n     {status: int, out: ~str, err: ~str};\n \n fn mock_program_output(_prog: &str, _args: &[~str]) -> {\n@@ -104,14 +104,14 @@ fn mock_program_output(_prog: &str, _args: &[~str]) -> {\n     }\n }\n \n-fn parse_config(args: ~[~str]) -> Result<config, ~str> {\n+fn parse_config(args: ~[~str]) -> Result<Config, ~str> {\n     parse_config_(args, run::program_output)\n }\n \n fn parse_config_(\n     args: ~[~str],\n-    program_output: program_output\n-) -> Result<config, ~str> {\n+    program_output: ProgramOutput\n+) -> Result<Config, ~str> {\n     let args = vec::tail(args);\n     let opts = vec::unzip(opts()).first();\n     match getopts::getopts(args, opts) {\n@@ -134,8 +134,8 @@ fn parse_config_(\n fn config_from_opts(\n     input_crate: &Path,\n     matches: getopts::Matches,\n-    program_output: program_output\n-) -> Result<config, ~str> {\n+    program_output: ProgramOutput\n+) -> Result<Config, ~str> {\n \n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n@@ -190,28 +190,28 @@ fn config_from_opts(\n     return result;\n }\n \n-fn parse_output_format(output_format: ~str) -> Result<output_format, ~str> {\n+fn parse_output_format(output_format: ~str) -> Result<OutputFormat, ~str> {\n     match output_format {\n-      ~\"markdown\" => result::Ok(markdown),\n-      ~\"html\" => result::Ok(pandoc_html),\n+      ~\"markdown\" => result::Ok(Markdown),\n+      ~\"html\" => result::Ok(PandocHtml),\n       _ => result::Err(fmt!(\"unknown output format '%s'\", output_format))\n     }\n }\n \n-fn parse_output_style(output_style: ~str) -> Result<output_style, ~str> {\n+fn parse_output_style(output_style: ~str) -> Result<OutputStyle, ~str> {\n     match output_style {\n-      ~\"doc-per-crate\" => result::Ok(doc_per_crate),\n-      ~\"doc-per-mod\" => result::Ok(doc_per_mod),\n+      ~\"doc-per-crate\" => result::Ok(DocPerCrate),\n+      ~\"doc-per-mod\" => result::Ok(DocPerMod),\n       _ => result::Err(fmt!(\"unknown output style '%s'\", output_style))\n     }\n }\n \n fn maybe_find_pandoc(\n-    config: config,\n+    config: Config,\n     maybe_pandoc_cmd: Option<~str>,\n-    program_output: program_output\n+    program_output: ProgramOutput\n ) -> Result<Option<~str>, ~str> {\n-    if config.output_format != pandoc_html {\n+    if config.output_format != PandocHtml {\n         return result::Ok(maybe_pandoc_cmd);\n     }\n \n@@ -243,7 +243,7 @@ fn maybe_find_pandoc(\n #[test]\n fn should_find_pandoc() {\n     let config = {\n-        output_format: pandoc_html,\n+        output_format: PandocHtml,\n         .. default_config(&Path(\"test\"))\n     };\n     let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n@@ -260,7 +260,7 @@ fn should_find_pandoc() {\n #[test]\n fn should_error_with_no_pandoc() {\n     let config = {\n-        output_format: pandoc_html,\n+        output_format: PandocHtml,\n         .. default_config(&Path(\"test\"))\n     };\n     let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n@@ -276,7 +276,7 @@ fn should_error_with_no_pandoc() {\n \n #[cfg(test)]\n mod test {\n-    fn parse_config(args: ~[~str]) -> Result<config, ~str> {\n+    fn parse_config(args: ~[~str]) -> Result<Config, ~str> {\n         parse_config_(args, mock_program_output)\n     }\n }\n@@ -311,23 +311,23 @@ fn should_set_output_dir_if_provided() {\n #[test]\n fn should_set_output_format_to_pandoc_html_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert result::get(config).output_format == pandoc_html;\n+    assert result::get(config).output_format == PandocHtml;\n }\n \n #[test]\n fn should_set_output_format_to_markdown_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n     ]);\n-    assert result::get(config).output_format == markdown;\n+    assert result::get(config).output_format == Markdown;\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n     ]);\n-    assert result::get(config).output_format == pandoc_html;\n+    assert result::get(config).output_format == PandocHtml;\n }\n \n #[test]\n@@ -341,23 +341,23 @@ fn should_error_on_bogus_format() {\n #[test]\n fn should_set_output_style_to_doc_per_mod_by_default() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert result::get(config).output_style == doc_per_mod;\n+    assert result::get(config).output_style == DocPerMod;\n }\n \n #[test]\n fn should_set_output_style_to_one_doc_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n     ]);\n-    assert result::get(config).output_style == doc_per_crate;\n+    assert result::get(config).output_style == DocPerCrate;\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n     ]);\n-    assert result::get(config).output_style == doc_per_mod;\n+    assert result::get(config).output_style == DocPerMod;\n }\n \n #[test]"}, {"sha": "cb50753d87e29aafe1b05980715950310a1364f5", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -14,21 +14,21 @@\n /// The base price of a muffin on a non-holiday\n const price_of_a_muffin: float = 70f;\n \n-type waitperson = {\n+type WaitPerson = {\n     hair_color: ~str\n };\n \n /// The type of things that produce omnomnom\n-enum omnomnomy {\n+enum OmNomNomy {\n     /// Delicious sugar cookies\n-    cookie,\n+    Cookie,\n     /// It's pizza\n-    pizza_pie(~[uint])\n+    PizzaPie(~[uint])\n }\n \n fn take_my_order_please(\n-    _waitperson: waitperson,\n-    _order: ~[omnomnomy]\n+    _waitperson: WaitPerson,\n+    _order: ~[OmNomNomy]\n ) -> uint {\n \n     /*!\n@@ -111,7 +111,7 @@ mod blade_runner {\n  * eget ante feugiat tortor congue auctor ac quis ante. Proin\n  * condimentum lacinia tincidunt.\n  */\n-struct bored {\n+struct Bored {\n   bored: bool,\n   drop { log(error, self.bored); }\n }\n@@ -132,7 +132,7 @@ struct bored {\n  * neighboring hillside churchyard of St. John's, whose hidden expanse of\n  * Eighteenth Century gravestones had for him a peculiar fascination.\n  */\n-trait the_shunned_house {\n+trait TheShunnedHouse {\n     /**\n      * Now the irony is this. In this walk, so many times repeated, the\n      * world's greatest master of the terrible and the bizarre was\n@@ -175,7 +175,7 @@ trait the_shunned_house {\n }\n \n /// Whatever\n-impl omnomnomy: the_shunned_house {\n+impl OmNomNomy: TheShunnedHouse {\n     fn dingy_house(_unkempt_yard: int) {\n     }\n "}, {"sha": "27548f40dfdb8fcab847eca3356780516f97bc04", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -5,22 +5,22 @@\n  * is interpreted as the brief description.\n  */\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"desc_to_brief\",\n         f: run\n     }\n }\n \n fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    _srv: astsrv::Srv,\n+    doc: doc::Doc\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_item: fold_item,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -29,7 +29,7 @@ fn run(\n     fold.fold_doc(fold, doc)\n }\n \n-fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n+fn fold_item(fold: fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     {\n@@ -38,7 +38,7 @@ fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n     }\n }\n \n-fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n+fn fold_trait(fold: fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc =fold::default_seq_fold_trait(fold, doc);\n \n     {\n@@ -50,7 +50,7 @@ fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n     }\n }\n \n-fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n+fn fold_impl(fold: fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n     {\n@@ -83,7 +83,7 @@ fn should_promote_impl_method_desc() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "b5ea6f187fa0810281e93716aa4b3914b6a9d249", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 229, "deletions": 229, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,175 +1,175 @@\n //! The document model\n \n-type ast_id = int;\n+type AstId = int;\n \n-type doc_ = {\n-    pages: ~[page]\n+type Doc_ = {\n+    pages: ~[Page]\n };\n \n-impl doc_ : cmp::Eq {\n-    pure fn eq(&&other: doc_) -> bool {\n+impl Doc_ : cmp::Eq {\n+    pure fn eq(&&other: Doc_) -> bool {\n         self.pages == other.pages\n     }\n-    pure fn ne(&&other: doc_) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: Doc_) -> bool { !self.eq(other) }\n }\n \n-enum doc {\n-    doc_(doc_)\n+enum Doc {\n+    Doc_(Doc_)\n }\n \n-impl doc : cmp::Eq {\n-    pure fn eq(&&other: doc) -> bool { *self == *other }\n-    pure fn ne(&&other: doc) -> bool { *self != *other }\n+impl Doc : cmp::Eq {\n+    pure fn eq(&&other: Doc) -> bool { *self == *other }\n+    pure fn ne(&&other: Doc) -> bool { *self != *other }\n }\n \n-enum page {\n-    cratepage(cratedoc),\n-    itempage(itemtag)\n+enum Page {\n+    CratePage(CrateDoc),\n+    ItemPage(ItemTag)\n }\n \n-impl page : cmp::Eq {\n-    pure fn eq(&&other: page) -> bool {\n+impl Page : cmp::Eq {\n+    pure fn eq(&&other: Page) -> bool {\n         match self {\n-            cratepage(e0a) => {\n+            CratePage(e0a) => {\n                 match other {\n-                    cratepage(e0b) => e0a == e0b,\n+                    CratePage(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            itempage(e0a) => {\n+            ItemPage(e0a) => {\n                 match other {\n-                    itempage(e0b) => e0a == e0b,\n+                    ItemPage(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: page) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: Page) -> bool { !self.eq(other) }\n }\n \n-enum implementation {\n-    required,\n-    provided,\n+enum Implementation {\n+    Required,\n+    Provided,\n }\n \n-impl implementation : cmp::Eq {\n-    pure fn eq(&&other: implementation) -> bool {\n+impl Implementation : cmp::Eq {\n+    pure fn eq(&&other: Implementation) -> bool {\n         (self as uint) == (other as uint)\n     }\n-    pure fn ne(&&other: implementation) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: Implementation) -> bool { !self.eq(other) }\n }\n \n \n /**\n  * Most rustdocs can be parsed into 'sections' according to their markdown\n  * headers\n  */\n-type section = {\n+type Section = {\n     header: ~str,\n     body: ~str\n };\n \n-impl section : cmp::Eq {\n-    pure fn eq(&&other: section) -> bool {\n+impl Section : cmp::Eq {\n+    pure fn eq(&&other: Section) -> bool {\n         self.header == other.header && self.body == other.body\n     }\n-    pure fn ne(&&other: section) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: Section) -> bool { !self.eq(other) }\n }\n \n // FIXME (#2596): We currently give topmod the name of the crate.  There\n // would probably be fewer special cases if the crate had its own name\n // and topmod's name was the empty string.\n-type cratedoc = {\n-    topmod: moddoc,\n+type CrateDoc = {\n+    topmod: ModDoc,\n };\n \n-impl cratedoc : cmp::Eq {\n-    pure fn eq(&&other: cratedoc) -> bool {\n+impl CrateDoc : cmp::Eq {\n+    pure fn eq(&&other: CrateDoc) -> bool {\n         self.topmod == other.topmod\n     }\n-    pure fn ne(&&other: cratedoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: CrateDoc) -> bool { !self.eq(other) }\n }\n \n-enum itemtag {\n-    modtag(moddoc),\n-    nmodtag(nmoddoc),\n-    consttag(constdoc),\n-    fntag(fndoc),\n-    enumtag(enumdoc),\n-    traittag(traitdoc),\n-    impltag(impldoc),\n-    tytag(tydoc)\n+enum ItemTag {\n+    ModTag(ModDoc),\n+    NmodTag(NmodDoc),\n+    ConstTag(ConstDoc),\n+    FnTag(FnDoc),\n+    EnumTag(EnumDoc),\n+    TraitTag(TraitDoc),\n+    ImplTag(ImplDoc),\n+    TyTag(TyDoc)\n }\n \n-impl itemtag : cmp::Eq {\n-    pure fn eq(&&other: itemtag) -> bool {\n+impl ItemTag : cmp::Eq {\n+    pure fn eq(&&other: ItemTag) -> bool {\n         match self {\n-            modtag(e0a) => {\n+            ModTag(e0a) => {\n                 match other {\n-                    modtag(e0b) => e0a == e0b,\n+                    ModTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            nmodtag(e0a) => {\n+            NmodTag(e0a) => {\n                 match other {\n-                    nmodtag(e0b) => e0a == e0b,\n+                    NmodTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            consttag(e0a) => {\n+            ConstTag(e0a) => {\n                 match other {\n-                    consttag(e0b) => e0a == e0b,\n+                    ConstTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            fntag(e0a) => {\n+            FnTag(e0a) => {\n                 match other {\n-                    fntag(e0b) => e0a == e0b,\n+                    FnTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            enumtag(e0a) => {\n+            EnumTag(e0a) => {\n                 match other {\n-                    enumtag(e0b) => e0a == e0b,\n+                    EnumTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            traittag(e0a) => {\n+            TraitTag(e0a) => {\n                 match other {\n-                    traittag(e0b) => e0a == e0b,\n+                    TraitTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            impltag(e0a) => {\n+            ImplTag(e0a) => {\n                 match other {\n-                    impltag(e0b) => e0a == e0b,\n+                    ImplTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n-            tytag(e0a) => {\n+            TyTag(e0a) => {\n                 match other {\n-                    tytag(e0b) => e0a == e0b,\n+                    TyTag(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: itemtag) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: ItemTag) -> bool { !self.eq(other) }\n }\n \n-type itemdoc = {\n-    id: ast_id,\n+type ItemDoc = {\n+    id: AstId,\n     name: ~str,\n     path: ~[~str],\n     brief: Option<~str>,\n     desc: Option<~str>,\n-    sections: ~[section],\n+    sections: ~[Section],\n     // Indicates that this node is a reexport of a different item\n     reexport: bool\n };\n \n-impl itemdoc : cmp::Eq {\n-    pure fn eq(&&other: itemdoc) -> bool {\n+impl ItemDoc : cmp::Eq {\n+    pure fn eq(&&other: ItemDoc) -> bool {\n         self.id == other.id &&\n         self.name == other.name &&\n         self.path == other.path &&\n@@ -178,152 +178,152 @@ impl itemdoc : cmp::Eq {\n         self.sections == other.sections &&\n         self.reexport == other.reexport\n     }\n-    pure fn ne(&&other: itemdoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: ItemDoc) -> bool { !self.eq(other) }\n }\n \n-type simpleitemdoc = {\n-    item: itemdoc,\n+type SimpleItemDoc = {\n+    item: ItemDoc,\n     sig: Option<~str>\n };\n \n-impl simpleitemdoc : cmp::Eq {\n-    pure fn eq(&&other: simpleitemdoc) -> bool {\n+impl SimpleItemDoc : cmp::Eq {\n+    pure fn eq(&&other: SimpleItemDoc) -> bool {\n         self.item == other.item && self.sig == other.sig\n     }\n-    pure fn ne(&&other: simpleitemdoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: SimpleItemDoc) -> bool { !self.eq(other) }\n }\n \n-type moddoc_ = {\n-    item: itemdoc,\n-    items: ~[itemtag],\n-    index: Option<index>\n+type ModDoc_ = {\n+    item: ItemDoc,\n+    items: ~[ItemTag],\n+    index: Option<Index>\n };\n \n-impl moddoc_ : cmp::Eq {\n-    pure fn eq(&&other: moddoc_) -> bool {\n+impl ModDoc_ : cmp::Eq {\n+    pure fn eq(&&other: ModDoc_) -> bool {\n         self.item == other.item &&\n         self.items == other.items &&\n         self.index == other.index\n     }\n-    pure fn ne(&&other: moddoc_) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: ModDoc_) -> bool { !self.eq(other) }\n }\n \n-enum moddoc {\n-    moddoc_(moddoc_)\n+enum ModDoc {\n+    ModDoc_(ModDoc_)\n }\n \n-impl moddoc : cmp::Eq {\n-    pure fn eq(&&other: moddoc) -> bool { *self == *other }\n-    pure fn ne(&&other: moddoc) -> bool { *self != *other }\n+impl ModDoc : cmp::Eq {\n+    pure fn eq(&&other: ModDoc) -> bool { *self == *other }\n+    pure fn ne(&&other: ModDoc) -> bool { *self != *other }\n }\n \n-type nmoddoc = {\n-    item: itemdoc,\n-    fns: ~[fndoc],\n-    index: Option<index>\n+type NmodDoc = {\n+    item: ItemDoc,\n+    fns: ~[FnDoc],\n+    index: Option<Index>\n };\n \n-impl nmoddoc : cmp::Eq {\n-    pure fn eq(&&other: nmoddoc) -> bool {\n+impl NmodDoc : cmp::Eq {\n+    pure fn eq(&&other: NmodDoc) -> bool {\n         self.item == other.item &&\n         self.fns == other.fns &&\n         self.index == other.index\n     }\n-    pure fn ne(&&other: nmoddoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: NmodDoc) -> bool { !self.eq(other) }\n }\n \n-type constdoc = simpleitemdoc;\n+type ConstDoc = SimpleItemDoc;\n \n-type fndoc = simpleitemdoc;\n+type FnDoc = SimpleItemDoc;\n \n-type enumdoc = {\n-    item: itemdoc,\n-    variants: ~[variantdoc]\n+type EnumDoc = {\n+    item: ItemDoc,\n+    variants: ~[VariantDoc]\n };\n \n-impl enumdoc : cmp::Eq {\n-    pure fn eq(&&other: enumdoc) -> bool {\n+impl EnumDoc : cmp::Eq {\n+    pure fn eq(&&other: EnumDoc) -> bool {\n         self.item == other.item && self.variants == other.variants\n     }\n-    pure fn ne(&&other: enumdoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: EnumDoc) -> bool { !self.eq(other) }\n }\n \n-type variantdoc = {\n+type VariantDoc = {\n     name: ~str,\n     desc: Option<~str>,\n     sig: Option<~str>\n };\n \n-impl variantdoc : cmp::Eq {\n-    pure fn eq(&&other: variantdoc) -> bool {\n+impl VariantDoc : cmp::Eq {\n+    pure fn eq(&&other: VariantDoc) -> bool {\n         self.name == other.name &&\n         self.desc == other.desc &&\n         self.sig == other.sig\n     }\n-    pure fn ne(&&other: variantdoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: VariantDoc) -> bool { !self.eq(other) }\n }\n \n-type traitdoc = {\n-    item: itemdoc,\n-    methods: ~[methoddoc]\n+type TraitDoc = {\n+    item: ItemDoc,\n+    methods: ~[MethodDoc]\n };\n \n-impl traitdoc : cmp::Eq {\n-    pure fn eq(&&other: traitdoc) -> bool {\n+impl TraitDoc : cmp::Eq {\n+    pure fn eq(&&other: TraitDoc) -> bool {\n         self.item == other.item && self.methods == other.methods\n     }\n-    pure fn ne(&&other: traitdoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: TraitDoc) -> bool { !self.eq(other) }\n }\n \n-type methoddoc = {\n+type MethodDoc = {\n     name: ~str,\n     brief: Option<~str>,\n     desc: Option<~str>,\n-    sections: ~[section],\n+    sections: ~[Section],\n     sig: Option<~str>,\n-    implementation: implementation,\n+    implementation: Implementation,\n };\n \n-impl methoddoc : cmp::Eq {\n-    pure fn eq(&&other: methoddoc) -> bool {\n+impl MethodDoc : cmp::Eq {\n+    pure fn eq(&&other: MethodDoc) -> bool {\n         self.name == other.name &&\n         self.brief == other.brief &&\n         self.desc == other.desc &&\n         self.sections == other.sections &&\n         self.sig == other.sig &&\n         self.implementation == other.implementation\n     }\n-    pure fn ne(&&other: methoddoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: MethodDoc) -> bool { !self.eq(other) }\n }\n \n-type impldoc = {\n-    item: itemdoc,\n+type ImplDoc = {\n+    item: ItemDoc,\n     trait_types: ~[~str],\n     self_ty: Option<~str>,\n-    methods: ~[methoddoc]\n+    methods: ~[MethodDoc]\n };\n \n-impl impldoc : cmp::Eq {\n-    pure fn eq(&&other: impldoc) -> bool {\n+impl ImplDoc : cmp::Eq {\n+    pure fn eq(&&other: ImplDoc) -> bool {\n         self.item == other.item &&\n         self.trait_types == other.trait_types &&\n         self.self_ty == other.self_ty &&\n         self.methods == other.methods\n     }\n-    pure fn ne(&&other: impldoc) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: ImplDoc) -> bool { !self.eq(other) }\n }\n \n-type tydoc = simpleitemdoc;\n+type TyDoc = SimpleItemDoc;\n \n-type index = {\n-    entries: ~[index_entry]\n+type Index = {\n+    entries: ~[IndexEntry]\n };\n \n-impl index : cmp::Eq {\n-    pure fn eq(&&other: index) -> bool {\n+impl Index : cmp::Eq {\n+    pure fn eq(&&other: Index) -> bool {\n         self.entries == other.entries\n     }\n-    pure fn ne(&&other: index) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: Index) -> bool { !self.eq(other) }\n }\n \n /**\n@@ -336,254 +336,254 @@ impl index : cmp::Eq {\n  * * brief - The brief description\n  * * link - A format-specific string representing the link target\n  */\n-type index_entry = {\n+type IndexEntry = {\n     kind: ~str,\n     name: ~str,\n     brief: Option<~str>,\n     link: ~str\n };\n \n-impl index_entry : cmp::Eq {\n-    pure fn eq(&&other: index_entry) -> bool {\n+impl IndexEntry : cmp::Eq {\n+    pure fn eq(&&other: IndexEntry) -> bool {\n         self.kind == other.kind &&\n         self.name == other.name &&\n         self.brief == other.brief &&\n         self.link == other.link\n     }\n-    pure fn ne(&&other: index_entry) -> bool { !self.eq(other) }\n+    pure fn ne(&&other: IndexEntry) -> bool { !self.eq(other) }\n }\n \n-impl doc {\n-    fn cratedoc() -> cratedoc {\n+impl Doc {\n+    fn CrateDoc() -> CrateDoc {\n         option::get(vec::foldl(None, self.pages, |_m, page| {\n             match page {\n-              doc::cratepage(doc) => Some(doc),\n+              doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n         }))\n     }\n \n-    fn cratemod() -> moddoc {\n-        self.cratedoc().topmod\n+    fn cratemod() -> ModDoc {\n+        self.CrateDoc().topmod\n     }\n }\n \n-/// Some helper methods on moddoc, mostly for testing\n-impl moddoc {\n+/// Some helper methods on ModDoc, mostly for testing\n+impl ModDoc {\n \n-    fn mods() -> ~[moddoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              modtag(moddoc) => Some(moddoc),\n+    fn mods() -> ~[ModDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              ModTag(ModDoc) => Some(ModDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn nmods() -> ~[nmoddoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              nmodtag(nmoddoc) => Some(nmoddoc),\n+    fn nmods() -> ~[NmodDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              NmodTag(nModDoc) => Some(nModDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn fns() -> ~[fndoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              fntag(fndoc) => Some(fndoc),\n+    fn fns() -> ~[FnDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              FnTag(FnDoc) => Some(FnDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn consts() -> ~[constdoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              consttag(constdoc) => Some(constdoc),\n+    fn consts() -> ~[ConstDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              ConstTag(ConstDoc) => Some(ConstDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn enums() -> ~[enumdoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              enumtag(enumdoc) => Some(enumdoc),\n+    fn enums() -> ~[EnumDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              EnumTag(EnumDoc) => Some(EnumDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn traits() -> ~[traitdoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              traittag(traitdoc) => Some(traitdoc),\n+    fn traits() -> ~[TraitDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              TraitTag(TraitDoc) => Some(TraitDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn impls() -> ~[impldoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              impltag(impldoc) => Some(impldoc),\n+    fn impls() -> ~[ImplDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              ImplTag(ImplDoc) => Some(ImplDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn types() -> ~[tydoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n-            match itemtag {\n-              tytag(tydoc) => Some(tydoc),\n+    fn types() -> ~[TyDoc] {\n+        do vec::filter_map(self.items) |ItemTag| {\n+            match ItemTag {\n+              TyTag(TyDoc) => Some(TyDoc),\n               _ => None\n             }\n         }\n     }\n }\n \n-trait page_utils {\n-    fn mods() -> ~[moddoc];\n-    fn nmods() -> ~[nmoddoc];\n-    fn fns() -> ~[fndoc];\n-    fn consts() -> ~[constdoc];\n-    fn enums() -> ~[enumdoc];\n-    fn traits() -> ~[traitdoc];\n-    fn impls() -> ~[impldoc];\n-    fn types() -> ~[tydoc];\n+trait PageUtils {\n+    fn mods() -> ~[ModDoc];\n+    fn nmods() -> ~[NmodDoc];\n+    fn fns() -> ~[FnDoc];\n+    fn consts() -> ~[ConstDoc];\n+    fn enums() -> ~[EnumDoc];\n+    fn traits() -> ~[TraitDoc];\n+    fn impls() -> ~[ImplDoc];\n+    fn types() -> ~[TyDoc];\n }\n \n-impl ~[page]: page_utils {\n+impl ~[Page]: PageUtils {\n \n-    fn mods() -> ~[moddoc] {\n+    fn mods() -> ~[ModDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(modtag(moddoc)) => Some(moddoc),\n+              ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn nmods() -> ~[nmoddoc] {\n+    fn nmods() -> ~[NmodDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(nmodtag(nmoddoc)) => Some(nmoddoc),\n+              ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn fns() -> ~[fndoc] {\n+    fn fns() -> ~[FnDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(fntag(fndoc)) => Some(fndoc),\n+              ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn consts() -> ~[constdoc] {\n+    fn consts() -> ~[ConstDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(consttag(constdoc)) => Some(constdoc),\n+              ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn enums() -> ~[enumdoc] {\n+    fn enums() -> ~[EnumDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(enumtag(enumdoc)) => Some(enumdoc),\n+              ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn traits() -> ~[traitdoc] {\n+    fn traits() -> ~[TraitDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(traittag(traitdoc)) => Some(traitdoc),\n+              ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn impls() -> ~[impldoc] {\n+    fn impls() -> ~[ImplDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(impltag(impldoc)) => Some(impldoc),\n+              ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n               _ => None\n             }\n         }\n     }\n \n-    fn types() -> ~[tydoc] {\n+    fn types() -> ~[TyDoc] {\n         do vec::filter_map(self) |page| {\n             match page {\n-              itempage(tytag(tydoc)) => Some(tydoc),\n+              ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n               _ => None\n             }\n         }\n     }\n }\n \n-trait item {\n-    pure fn item() -> itemdoc;\n+trait Item {\n+    pure fn item() -> ItemDoc;\n }\n \n-impl itemtag: item {\n-    pure fn item() -> itemdoc {\n+impl ItemTag: Item {\n+    pure fn item() -> ItemDoc {\n         match self {\n-          doc::modtag(doc) => doc.item,\n-          doc::nmodtag(doc) => doc.item,\n-          doc::fntag(doc) => doc.item,\n-          doc::consttag(doc) => doc.item,\n-          doc::enumtag(doc) => doc.item,\n-          doc::traittag(doc) => doc.item,\n-          doc::impltag(doc) => doc.item,\n-          doc::tytag(doc) => doc.item\n+          doc::ModTag(doc) => doc.item,\n+          doc::NmodTag(doc) => doc.item,\n+          doc::FnTag(doc) => doc.item,\n+          doc::ConstTag(doc) => doc.item,\n+          doc::EnumTag(doc) => doc.item,\n+          doc::TraitTag(doc) => doc.item,\n+          doc::ImplTag(doc) => doc.item,\n+          doc::TyTag(doc) => doc.item\n         }\n     }\n }\n \n-impl simpleitemdoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl SimpleItemDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-impl moddoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl ModDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-impl nmoddoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl NmodDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-impl enumdoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl EnumDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-impl traitdoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl TraitDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-impl impldoc: item {\n-    pure fn item() -> itemdoc { self.item }\n+impl ImplDoc: Item {\n+    pure fn item() -> ItemDoc { self.item }\n }\n \n-trait item_utils {\n-    pure fn id() -> ast_id;\n+trait ItemUtils {\n+    pure fn id() -> AstId;\n     pure fn name() -> ~str;\n     pure fn path() -> ~[~str];\n     pure fn brief() -> Option<~str>;\n     pure fn desc() -> Option<~str>;\n-    pure fn sections() -> ~[section];\n+    pure fn sections() -> ~[Section];\n }\n \n-impl<A:item> A: item_utils {\n-    pure fn id() -> ast_id {\n+impl<A:Item> A: ItemUtils {\n+    pure fn id() -> AstId {\n         self.item().id\n     }\n \n@@ -603,7 +603,7 @@ impl<A:item> A: item_utils {\n         self.item().desc\n     }\n \n-    pure fn sections() -> ~[section] {\n+    pure fn sections() -> ~[Section] {\n         self.item().sections\n     }\n }"}, {"sha": "eea09eb8d329786562c14d7673c8ede6afffd3e8", "filename": "src/rustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fescape_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -2,7 +2,7 @@\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"escape\", escape)\n }\n "}, {"sha": "6f1cdb10b7ca18a8221b8a3c67caddff9bab3253", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,7 +1,7 @@\n //! Converts the Rust AST to the rustdoc document model\n \n use syntax::ast;\n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export from_srv, extract, to_str, interner;\n \n@@ -26,9 +26,9 @@ fn interner() -> syntax::parse::token::ident_interner {\n }\n \n fn from_srv(\n-    srv: astsrv::srv,\n+    srv: astsrv::Srv,\n     default_name: ~str\n-) -> doc::doc {\n+) -> doc::Doc {\n \n     //! Use the AST service to create a document tree\n \n@@ -40,25 +40,25 @@ fn from_srv(\n fn extract(\n     crate: @ast::crate,\n     default_name: ~str\n-) -> doc::doc {\n-    doc::doc_({\n+) -> doc::Doc {\n+    doc::Doc_({\n         pages: ~[\n-            doc::cratepage({\n-                topmod: top_moddoc_from_crate(crate, default_name),\n+            doc::CratePage({\n+                topmod: top_ModDoc_from_crate(crate, default_name),\n             })\n         ]\n     })\n }\n \n-fn top_moddoc_from_crate(\n+fn top_ModDoc_from_crate(\n     crate: @ast::crate,\n     default_name: ~str\n-) -> doc::moddoc {\n-    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, default_name),\n+) -> doc::ModDoc {\n+    ModDoc_from_mod(mk_ItemDoc(ast::crate_node_id, default_name),\n                     crate.node.module)\n }\n \n-fn mk_itemdoc(id: ast::node_id, name: ~str) -> doc::itemdoc {\n+fn mk_ItemDoc(id: ast::node_id, name: ~str) -> doc::ItemDoc {\n     {\n         id: id,\n         name: name,\n@@ -70,53 +70,53 @@ fn mk_itemdoc(id: ast::node_id, name: ~str) -> doc::itemdoc {\n     }\n }\n \n-fn moddoc_from_mod(\n-    itemdoc: doc::itemdoc,\n+fn ModDoc_from_mod(\n+    ItemDoc: doc::ItemDoc,\n     module_: ast::_mod\n-) -> doc::moddoc {\n-    doc::moddoc_({\n-        item: itemdoc,\n+) -> doc::ModDoc {\n+    doc::ModDoc_({\n+        item: ItemDoc,\n         items: do vec::filter_map(module_.items) |item| {\n-            let itemdoc = mk_itemdoc(item.id, to_str(item.ident));\n+            let ItemDoc = mk_ItemDoc(item.id, to_str(item.ident));\n             match item.node {\n               ast::item_mod(m) => {\n-                Some(doc::modtag(\n-                    moddoc_from_mod(itemdoc, m)\n+                Some(doc::ModTag(\n+                    ModDoc_from_mod(ItemDoc, m)\n                 ))\n               }\n               ast::item_foreign_mod(nm) => {\n-                Some(doc::nmodtag(\n-                    nmoddoc_from_mod(itemdoc, nm)\n+                Some(doc::NmodTag(\n+                    nModDoc_from_mod(ItemDoc, nm)\n                 ))\n               }\n               ast::item_fn(*) => {\n-                Some(doc::fntag(\n-                    fndoc_from_fn(itemdoc)\n+                Some(doc::FnTag(\n+                    FnDoc_from_fn(ItemDoc)\n                 ))\n               }\n               ast::item_const(_, _) => {\n-                Some(doc::consttag(\n-                    constdoc_from_const(itemdoc)\n+                Some(doc::ConstTag(\n+                    ConstDoc_from_const(ItemDoc)\n                 ))\n               }\n               ast::item_enum(enum_definition, _) => {\n-                Some(doc::enumtag(\n-                    enumdoc_from_enum(itemdoc, enum_definition.variants)\n+                Some(doc::EnumTag(\n+                    EnumDoc_from_enum(ItemDoc, enum_definition.variants)\n                 ))\n               }\n               ast::item_trait(_, _, methods) => {\n-                Some(doc::traittag(\n-                    traitdoc_from_trait(itemdoc, methods)\n+                Some(doc::TraitTag(\n+                    TraitDoc_from_trait(ItemDoc, methods)\n                 ))\n               }\n               ast::item_impl(_, _, _, methods) => {\n-                Some(doc::impltag(\n-                    impldoc_from_impl(itemdoc, methods)\n+                Some(doc::ImplTag(\n+                    ImplDoc_from_impl(ItemDoc, methods)\n                 ))\n               }\n               ast::item_ty(_, _) => {\n-                Some(doc::tytag(\n-                    tydoc_from_ty(itemdoc)\n+                Some(doc::TyTag(\n+                    TyDoc_from_ty(ItemDoc)\n                 ))\n               }\n               _ => None\n@@ -126,37 +126,37 @@ fn moddoc_from_mod(\n     })\n }\n \n-fn nmoddoc_from_mod(\n-    itemdoc: doc::itemdoc,\n+fn nModDoc_from_mod(\n+    ItemDoc: doc::ItemDoc,\n     module_: ast::foreign_mod\n-) -> doc::nmoddoc {\n+) -> doc::NmodDoc {\n     let mut fns = ~[];\n     for module_.items.each |item| {\n-        let itemdoc = mk_itemdoc(item.id, to_str(item.ident));\n+        let ItemDoc = mk_ItemDoc(item.id, to_str(item.ident));\n         match item.node {\n           ast::foreign_item_fn(*) => {\n-            vec::push(fns, fndoc_from_fn(itemdoc));\n+            vec::push(fns, FnDoc_from_fn(ItemDoc));\n           }\n           ast::foreign_item_const(*) => {} // XXX: Not implemented.\n         }\n     }\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         fns: fns,\n         index: None\n     }\n }\n \n-fn fndoc_from_fn(itemdoc: doc::itemdoc) -> doc::fndoc {\n+fn FnDoc_from_fn(ItemDoc: doc::ItemDoc) -> doc::FnDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         sig: None\n     }\n }\n \n-fn constdoc_from_const(itemdoc: doc::itemdoc) -> doc::constdoc {\n+fn ConstDoc_from_const(ItemDoc: doc::ItemDoc) -> doc::ConstDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         sig: None\n     }\n }\n@@ -168,23 +168,23 @@ fn should_extract_const_name_and_id() {\n     assert doc.cratemod().consts()[0].name() == ~\"a\";\n }\n \n-fn enumdoc_from_enum(\n-    itemdoc: doc::itemdoc,\n+fn EnumDoc_from_enum(\n+    ItemDoc: doc::ItemDoc,\n     variants: ~[ast::variant]\n-) -> doc::enumdoc {\n+) -> doc::EnumDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         variants: variantdocs_from_variants(variants)\n     }\n }\n \n fn variantdocs_from_variants(\n     variants: ~[ast::variant]\n-) -> ~[doc::variantdoc] {\n+) -> ~[doc::VariantDoc] {\n     vec::map(variants, variantdoc_from_variant)\n }\n \n-fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n+fn variantdoc_from_variant(variant: ast::variant) -> doc::VariantDoc {\n \n     {\n         name: to_str(variant.node.name),\n@@ -206,12 +206,12 @@ fn should_extract_enum_variants() {\n     assert doc.cratemod().enums()[0].variants[0].name == ~\"v\";\n }\n \n-fn traitdoc_from_trait(\n-    itemdoc: doc::itemdoc,\n+fn TraitDoc_from_trait(\n+    ItemDoc: doc::ItemDoc,\n     methods: ~[ast::trait_method]\n-) -> doc::traitdoc {\n+) -> doc::TraitDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         methods: do vec::map(methods) |method| {\n             match method {\n               ast::required(ty_m) => {\n@@ -221,7 +221,7 @@ fn traitdoc_from_trait(\n                     desc: None,\n                     sections: ~[],\n                     sig: None,\n-                    implementation: doc::required,\n+                    implementation: doc::Required,\n                 }\n               }\n               ast::provided(m) => {\n@@ -231,7 +231,7 @@ fn traitdoc_from_trait(\n                     desc: None,\n                     sections: ~[],\n                     sig: None,\n-                    implementation: doc::provided,\n+                    implementation: doc::Provided,\n                 }\n               }\n             }\n@@ -251,12 +251,12 @@ fn should_extract_trait_methods() {\n     assert doc.cratemod().traits()[0].methods[0].name == ~\"f\";\n }\n \n-fn impldoc_from_impl(\n-    itemdoc: doc::itemdoc,\n+fn ImplDoc_from_impl(\n+    ItemDoc: doc::ItemDoc,\n     methods: ~[@ast::method]\n-) -> doc::impldoc {\n+) -> doc::ImplDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         trait_types: ~[],\n         self_ty: None,\n         methods: do vec::map(methods) |method| {\n@@ -266,7 +266,7 @@ fn impldoc_from_impl(\n                 desc: None,\n                 sections: ~[],\n                 sig: None,\n-                implementation: doc::provided,\n+                implementation: doc::Provided,\n             }\n         }\n     }\n@@ -278,11 +278,11 @@ fn should_extract_impl_methods() {\n     assert doc.cratemod().impls()[0].methods[0].name == ~\"f\";\n }\n \n-fn tydoc_from_ty(\n-    itemdoc: doc::itemdoc\n-) -> doc::tydoc {\n+fn TyDoc_from_ty(\n+    ItemDoc: doc::ItemDoc\n+) -> doc::TyDoc {\n     {\n-        item: itemdoc,\n+        item: ItemDoc,\n         sig: None\n     }\n }\n@@ -296,7 +296,7 @@ fn should_extract_tys() {\n #[cfg(test)]\n mod test {\n \n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }"}, {"sha": "26ab6cec95999abf19591457d22772c5e9064b90", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,4 +1,4 @@\n-export fold;\n+export Fold;\n export default_seq_fold;\n export default_seq_fold_doc;\n export default_seq_fold_crate;\n@@ -18,53 +18,53 @@ export default_any_fold;\n export default_any_fold_mod;\n export default_any_fold_nmod;\n \n-enum fold<T> = t<T>;\n+enum Fold<T> = Fold_<T>;\n \n-type fold_doc<T> = fn~(fold: fold<T>, doc: doc::doc) -> doc::doc;\n-type fold_crate<T> = fn~(fold: fold<T>, doc: doc::cratedoc) -> doc::cratedoc;\n-type fold_item<T> = fn~(fold: fold<T>, doc: doc::itemdoc) -> doc::itemdoc;\n-type fold_mod<T> = fn~(fold: fold<T>, doc: doc::moddoc) -> doc::moddoc;\n-type fold_nmod<T> = fn~(fold: fold<T>, doc: doc::nmoddoc) -> doc::nmoddoc;\n-type fold_fn<T> = fn~(fold: fold<T>, doc: doc::fndoc) -> doc::fndoc;\n-type fold_const<T> = fn~(fold: fold<T>, doc: doc::constdoc) -> doc::constdoc;\n-type fold_enum<T> = fn~(fold: fold<T>, doc: doc::enumdoc) -> doc::enumdoc;\n-type fold_trait<T> = fn~(fold: fold<T>, doc: doc::traitdoc) -> doc::traitdoc;\n-type fold_impl<T> = fn~(fold: fold<T>, doc: doc::impldoc) -> doc::impldoc;\n-type fold_type<T> = fn~(fold: fold<T>, doc: doc::tydoc) -> doc::tydoc;\n+type FoldDoc<T> = fn~(fold: Fold<T>, doc: doc::Doc) -> doc::Doc;\n+type FoldCrate<T> = fn~(fold: Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n+type FoldItem<T> = fn~(fold: Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n+type FoldMod<T> = fn~(fold: Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n+type FoldNmod<T> = fn~(fold: Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n+type FoldFn<T> = fn~(fold: Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n+type FoldConst<T> = fn~(fold: Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n+type FoldEnum<T> = fn~(fold: Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n+type FoldTrait<T> = fn~(fold: Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n+type FoldImpl<T> = fn~(fold: Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n+type FoldType<T> = fn~(fold: Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n \n-type t<T> = {\n+type Fold_<T> = {\n     ctxt: T,\n-    fold_doc: fold_doc<T>,\n-    fold_crate: fold_crate<T>,\n-    fold_item: fold_item<T>,\n-    fold_mod: fold_mod<T>,\n-    fold_nmod: fold_nmod<T>,\n-    fold_fn: fold_fn<T>,\n-    fold_const: fold_const<T>,\n-    fold_enum: fold_enum<T>,\n-    fold_trait: fold_trait<T>,\n-    fold_impl: fold_impl<T>,\n-    fold_type: fold_type<T>\n+    fold_doc: FoldDoc<T>,\n+    fold_crate: FoldCrate<T>,\n+    fold_item: FoldItem<T>,\n+    fold_mod: FoldMod<T>,\n+    fold_nmod: FoldNmod<T>,\n+    fold_fn: FoldFn<T>,\n+    fold_const: FoldConst<T>,\n+    fold_enum: FoldEnum<T>,\n+    fold_trait: FoldTrait<T>,\n+    fold_impl: FoldImpl<T>,\n+    fold_type: FoldType<T>\n };\n \n \n // This exists because fn types don't infer correctly as record\n // initializers, but they do as function arguments\n fn mk_fold<T:Copy>(\n     ctxt: T,\n-    +fold_doc: fold_doc<T>,\n-    +fold_crate: fold_crate<T>,\n-    +fold_item: fold_item<T>,\n-    +fold_mod: fold_mod<T>,\n-    +fold_nmod: fold_nmod<T>,\n-    +fold_fn: fold_fn<T>,\n-    +fold_const: fold_const<T>,\n-    +fold_enum: fold_enum<T>,\n-    +fold_trait: fold_trait<T>,\n-    +fold_impl: fold_impl<T>,\n-    +fold_type: fold_type<T>\n-) -> fold<T> {\n-    fold({\n+    +fold_doc: FoldDoc<T>,\n+    +fold_crate: FoldCrate<T>,\n+    +fold_item: FoldItem<T>,\n+    +fold_mod: FoldMod<T>,\n+    +fold_nmod: FoldNmod<T>,\n+    +fold_fn: FoldFn<T>,\n+    +fold_const: FoldConst<T>,\n+    +fold_enum: FoldEnum<T>,\n+    +fold_trait: FoldTrait<T>,\n+    +fold_impl: FoldImpl<T>,\n+    +fold_type: FoldType<T>\n+) -> Fold<T> {\n+    Fold({\n         ctxt: ctxt,\n         fold_doc: fold_doc,\n         fold_crate: fold_crate,\n@@ -80,7 +80,7 @@ fn mk_fold<T:Copy>(\n     })\n }\n \n-fn default_any_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n+fn default_any_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -97,7 +97,7 @@ fn default_any_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_seq_fold<T:Copy>(ctxt: T) -> fold<T> {\n+fn default_seq_fold<T:Copy>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -114,7 +114,7 @@ fn default_seq_fold<T:Copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_par_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n+fn default_par_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -131,15 +131,15 @@ fn default_par_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n-    doc::doc_({\n+fn default_seq_fold_doc<T>(fold: Fold<T>, doc: doc::Doc) -> doc::Doc {\n+    doc::Doc_({\n         pages: do vec::map(doc.pages) |page| {\n             match page {\n-              doc::cratepage(doc) => {\n-                doc::cratepage(fold.fold_crate(fold, doc))\n+              doc::CratePage(doc) => {\n+                doc::CratePage(fold.fold_crate(fold, doc))\n               }\n-              doc::itempage(doc) => {\n-                doc::itempage(fold_itemtag(fold, doc))\n+              doc::ItemPage(doc) => {\n+                doc::ItemPage(fold_ItemTag(fold, doc))\n               }\n             }\n         },\n@@ -148,182 +148,182 @@ fn default_seq_fold_doc<T>(fold: fold<T>, doc: doc::doc) -> doc::doc {\n }\n \n fn default_seq_fold_crate<T>(\n-    fold: fold<T>,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    fold: Fold<T>,\n+    doc: doc::CrateDoc\n+) -> doc::CrateDoc {\n     {\n         topmod: fold.fold_mod(fold, doc.topmod)\n     }\n }\n \n fn default_seq_fold_item<T>(\n-    _fold: fold<T>,\n-    doc: doc::itemdoc\n-) -> doc::itemdoc {\n+    _fold: Fold<T>,\n+    doc: doc::ItemDoc\n+) -> doc::ItemDoc {\n     doc\n }\n \n fn default_any_fold_mod<T:Send Copy>(\n-    fold: fold<T>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n-    doc::moddoc_({\n+    fold: Fold<T>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n+    doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n-        items: par::map(doc.items, |itemtag, copy fold| {\n-            fold_itemtag(fold, itemtag)\n+        items: par::map(doc.items, |ItemTag, copy fold| {\n+            fold_ItemTag(fold, ItemTag)\n         }),\n         .. *doc\n     })\n }\n \n fn default_seq_fold_mod<T>(\n-    fold: fold<T>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n-    doc::moddoc_({\n+    fold: Fold<T>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n+    doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n-        items: vec::map(doc.items, |itemtag| {\n-            fold_itemtag(fold, itemtag)\n+        items: vec::map(doc.items, |ItemTag| {\n+            fold_ItemTag(fold, ItemTag)\n         }),\n         .. *doc\n     })\n }\n \n fn default_par_fold_mod<T:Send Copy>(\n-    fold: fold<T>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n-    doc::moddoc_({\n+    fold: Fold<T>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n+    doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n-        items: par::map(doc.items, |itemtag, copy fold| {\n-            fold_itemtag(fold, itemtag)\n+        items: par::map(doc.items, |ItemTag, copy fold| {\n+            fold_ItemTag(fold, ItemTag)\n         }),\n         .. *doc\n     })\n }\n \n fn default_any_fold_nmod<T:Send Copy>(\n-    fold: fold<T>,\n-    doc: doc::nmoddoc\n-) -> doc::nmoddoc {\n+    fold: Fold<T>,\n+    doc: doc::NmodDoc\n+) -> doc::NmodDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::map(doc.fns, |fndoc, copy fold| {\n-            fold.fold_fn(fold, fndoc)\n+        fns: par::map(doc.fns, |FnDoc, copy fold| {\n+            fold.fold_fn(fold, FnDoc)\n         }),\n         .. doc\n     }\n }\n \n fn default_seq_fold_nmod<T>(\n-    fold: fold<T>,\n-    doc: doc::nmoddoc\n-) -> doc::nmoddoc {\n+    fold: Fold<T>,\n+    doc: doc::NmodDoc\n+) -> doc::NmodDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: vec::map(doc.fns, |fndoc| {\n-            fold.fold_fn(fold, fndoc)\n+        fns: vec::map(doc.fns, |FnDoc| {\n+            fold.fold_fn(fold, FnDoc)\n         }),\n         .. doc\n     }\n }\n \n fn default_par_fold_nmod<T:Send Copy>(\n-    fold: fold<T>,\n-    doc: doc::nmoddoc\n-) -> doc::nmoddoc {\n+    fold: Fold<T>,\n+    doc: doc::NmodDoc\n+) -> doc::NmodDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::map(doc.fns, |fndoc, copy fold| {\n-            fold.fold_fn(fold, fndoc)\n+        fns: par::map(doc.fns, |FnDoc, copy fold| {\n+            fold.fold_fn(fold, FnDoc)\n         }),\n         .. doc\n     }\n }\n \n-fn fold_itemtag<T>(fold: fold<T>, doc: doc::itemtag) -> doc::itemtag {\n+fn fold_ItemTag<T>(fold: Fold<T>, doc: doc::ItemTag) -> doc::ItemTag {\n     match doc {\n-      doc::modtag(moddoc) => {\n-        doc::modtag(fold.fold_mod(fold, moddoc))\n+      doc::ModTag(ModDoc) => {\n+        doc::ModTag(fold.fold_mod(fold, ModDoc))\n       }\n-      doc::nmodtag(nmoddoc) => {\n-        doc::nmodtag(fold.fold_nmod(fold, nmoddoc))\n+      doc::NmodTag(nModDoc) => {\n+        doc::NmodTag(fold.fold_nmod(fold, nModDoc))\n       }\n-      doc::fntag(fndoc) => {\n-        doc::fntag(fold.fold_fn(fold, fndoc))\n+      doc::FnTag(FnDoc) => {\n+        doc::FnTag(fold.fold_fn(fold, FnDoc))\n       }\n-      doc::consttag(constdoc) => {\n-        doc::consttag(fold.fold_const(fold, constdoc))\n+      doc::ConstTag(ConstDoc) => {\n+        doc::ConstTag(fold.fold_const(fold, ConstDoc))\n       }\n-      doc::enumtag(enumdoc) => {\n-        doc::enumtag(fold.fold_enum(fold, enumdoc))\n+      doc::EnumTag(EnumDoc) => {\n+        doc::EnumTag(fold.fold_enum(fold, EnumDoc))\n       }\n-      doc::traittag(traitdoc) => {\n-        doc::traittag(fold.fold_trait(fold, traitdoc))\n+      doc::TraitTag(TraitDoc) => {\n+        doc::TraitTag(fold.fold_trait(fold, TraitDoc))\n       }\n-      doc::impltag(impldoc) => {\n-        doc::impltag(fold.fold_impl(fold, impldoc))\n+      doc::ImplTag(ImplDoc) => {\n+        doc::ImplTag(fold.fold_impl(fold, ImplDoc))\n       }\n-      doc::tytag(tydoc) => {\n-        doc::tytag(fold.fold_type(fold, tydoc))\n+      doc::TyTag(TyDoc) => {\n+        doc::TyTag(fold.fold_type(fold, TyDoc))\n       }\n     }\n }\n \n fn default_seq_fold_fn<T>(\n-    fold: fold<T>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n+    fold: Fold<T>,\n+    doc: doc::FnDoc\n+) -> doc::FnDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc\n     }\n }\n \n fn default_seq_fold_const<T>(\n-    fold: fold<T>,\n-    doc: doc::constdoc\n-) -> doc::constdoc {\n+    fold: Fold<T>,\n+    doc: doc::ConstDoc\n+) -> doc::ConstDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc\n     }\n }\n \n fn default_seq_fold_enum<T>(\n-    fold: fold<T>,\n-    doc: doc::enumdoc\n-) -> doc::enumdoc {\n+    fold: Fold<T>,\n+    doc: doc::EnumDoc\n+) -> doc::EnumDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc\n     }\n }\n \n fn default_seq_fold_trait<T>(\n-    fold: fold<T>,\n-    doc: doc::traitdoc\n-) -> doc::traitdoc {\n+    fold: Fold<T>,\n+    doc: doc::TraitDoc\n+) -> doc::TraitDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc\n     }\n }\n \n fn default_seq_fold_impl<T>(\n-    fold: fold<T>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n+    fold: Fold<T>,\n+    doc: doc::ImplDoc\n+) -> doc::ImplDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc\n     }\n }\n \n fn default_seq_fold_type<T>(\n-    fold: fold<T>,\n-    doc: doc::tydoc\n-) -> doc::tydoc {\n+    fold: Fold<T>,\n+    doc: doc::TyDoc\n+) -> doc::TyDoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n         .. doc"}, {"sha": "ca2f352d15c1bd804ef77c99f60da3345973b379", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,24 +1,24 @@\n //! Build indexes as appropriate for the markdown pass\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass(config: config::config) -> pass {\n+fn mk_pass(config: config::Config) -> Pass {\n     {\n         name: ~\"markdown_index\",\n-        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, config)\n         }\n     }\n }\n \n fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc,\n-    config: config::config\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    _srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    config: config::Config\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n         .. *fold::default_any_fold(config)\n@@ -27,22 +27,22 @@ fn run(\n }\n \n fn fold_mod(\n-    fold: fold::fold<config::config>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n+    fold: fold::Fold<config::Config>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n \n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    doc::moddoc_({\n+    doc::ModDoc_({\n         index: Some(build_mod_index(doc, fold.ctxt)),\n         .. *doc\n     })\n }\n \n fn fold_nmod(\n-    fold: fold::fold<config::config>,\n-    doc: doc::nmoddoc\n-) -> doc::nmoddoc {\n+    fold: fold::Fold<config::Config>,\n+    doc: doc::NmodDoc\n+) -> doc::NmodDoc {\n \n     let doc = fold::default_any_fold_nmod(fold, doc);\n \n@@ -53,9 +53,9 @@ fn fold_nmod(\n }\n \n fn build_mod_index(\n-    doc: doc::moddoc,\n-    config: config::config\n-) -> doc::index {\n+    doc: doc::ModDoc,\n+    config: config::Config\n+) -> doc::Index {\n     {\n         entries: par::map(doc.items, |doc| {\n             item_to_entry(doc, config)\n@@ -64,24 +64,24 @@ fn build_mod_index(\n }\n \n fn build_nmod_index(\n-    doc: doc::nmoddoc,\n-    config: config::config\n-) -> doc::index {\n+    doc: doc::NmodDoc,\n+    config: config::Config\n+) -> doc::Index {\n     {\n         entries: par::map(doc.fns, |doc| {\n-            item_to_entry(doc::fntag(doc), config)\n+            item_to_entry(doc::FnTag(doc), config)\n         })\n     }\n }\n \n fn item_to_entry(\n-    doc: doc::itemtag,\n-    config: config::config\n-) -> doc::index_entry {\n+    doc: doc::ItemTag,\n+    config: config::Config\n+) -> doc::IndexEntry {\n     let link = match doc {\n-      doc::modtag(_) | doc::nmodtag(_)\n-      if config.output_style == config::doc_per_mod => {\n-        markdown_writer::make_filename(config, doc::itempage(doc)).to_str()\n+      doc::ModTag(_) | doc::NmodTag(_)\n+      if config.output_style == config::DocPerMod => {\n+        markdown_writer::make_filename(config, doc::ItemPage(doc)).to_str()\n       }\n       _ => {\n         ~\"#\" + pandoc_header_id(markdown_pass::header_text(doc))\n@@ -149,7 +149,7 @@ fn should_remove_punctuation_from_headers() {\n #[test]\n fn should_index_mod_contents() {\n     let doc = test::mk_doc(\n-        config::doc_per_crate,\n+        config::DocPerCrate,\n         ~\"mod a { } fn b() { }\"\n     );\n     assert option::get(doc.cratemod().index).entries[0] == {\n@@ -169,7 +169,7 @@ fn should_index_mod_contents() {\n #[test]\n fn should_index_mod_contents_multi_page() {\n     let doc = test::mk_doc(\n-        config::doc_per_mod,\n+        config::DocPerMod,\n         ~\"mod a { } fn b() { }\"\n     );\n     assert option::get(doc.cratemod().index).entries[0] == {\n@@ -189,7 +189,7 @@ fn should_index_mod_contents_multi_page() {\n #[test]\n fn should_index_foreign_mod_pages() {\n     let doc = test::mk_doc(\n-        config::doc_per_mod,\n+        config::DocPerMod,\n         ~\"extern mod a { }\"\n     );\n     assert option::get(doc.cratemod().index).entries[0] == {\n@@ -203,7 +203,7 @@ fn should_index_foreign_mod_pages() {\n #[test]\n fn should_add_brief_desc_to_index() {\n     let doc = test::mk_doc(\n-        config::doc_per_mod,\n+        config::DocPerMod,\n         ~\"#[doc = \\\"test\\\"] mod a { }\"\n     );\n     assert option::get(doc.cratemod().index).entries[0].brief\n@@ -213,7 +213,7 @@ fn should_add_brief_desc_to_index() {\n #[test]\n fn should_index_foreign_mod_contents() {\n     let doc = test::mk_doc(\n-        config::doc_per_crate,\n+        config::DocPerCrate,\n         ~\"extern mod a { fn b(); }\"\n     );\n     assert option::get(doc.cratemod().nmods()[0].index).entries[0] == {\n@@ -226,7 +226,7 @@ fn should_index_foreign_mod_contents() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(output_style: config::output_style, source: ~str) -> doc::doc {\n+    fn mk_doc(output_style: config::OutputStyle, source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let config = {\n                 output_style: output_style,"}, {"sha": "5b3df66862779bb9011fd61163c00a96a56585d2", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,15 +1,15 @@\n //! Generate markdown from a document tree\n \n-use doc::item_utils;\n-use markdown_writer::writer;\n-use markdown_writer::writer_utils;\n-use markdown_writer::writer_factory;\n+use doc::ItemUtils;\n+use markdown_writer::Writer;\n+use markdown_writer::WriterUtils;\n+use markdown_writer::WriterFactory;\n \n export mk_pass;\n export header_kind, header_name, header_text;\n \n-fn mk_pass(+writer_factory: writer_factory) -> pass {\n-    let f = fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+fn mk_pass(+writer_factory: WriterFactory) -> Pass {\n+    let f = fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n         run(srv, doc, copy writer_factory)\n     };\n \n@@ -20,15 +20,15 @@ fn mk_pass(+writer_factory: writer_factory) -> pass {\n }\n \n fn run(\n-    srv: astsrv::srv,\n-    doc: doc::doc,\n-    +writer_factory: writer_factory\n-) -> doc::doc {\n+    srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    +writer_factory: WriterFactory\n+) -> doc::Doc {\n \n-    pure fn mods_last(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n-        pure fn is_mod(item: &doc::itemtag) -> bool {\n+    pure fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+        pure fn is_mod(item: &doc::ItemTag) -> bool {\n             match *item {\n-              doc::modtag(_) => true,\n+              doc::ModTag(_) => true,\n               _ => false\n             }\n         }\n@@ -75,13 +75,13 @@ fn should_write_modules_last() {\n     assert idx_a < idx_c;\n }\n \n-type ctxt = {\n-    w: writer\n+type Ctxt = {\n+    w: Writer\n };\n \n fn write_markdown(\n-    doc: doc::doc,\n-    +writer_factory: writer_factory\n+    doc: doc::Doc,\n+    +writer_factory: WriterFactory\n ) {\n     // FIXME #2484: There is easy parallelism to be had here but\n     // we don't want to spawn too many pandoc processes\n@@ -93,13 +93,13 @@ fn write_markdown(\n     };\n }\n \n-fn write_page(ctxt: ctxt, page: doc::page) {\n+fn write_page(ctxt: Ctxt, page: doc::Page) {\n     write_title(ctxt, page);\n     match page {\n-      doc::cratepage(doc) => {\n+      doc::CratePage(doc) => {\n         write_crate(ctxt, doc);\n       }\n-      doc::itempage(doc) => {\n+      doc::ItemPage(doc) => {\n         // We don't write a header for item's pages because their\n         // header in the html output is created by the page title\n         write_item_no_header(ctxt, doc);\n@@ -115,26 +115,26 @@ fn should_request_new_writer_for_each_page() {\n     let (writer_factory, po) = markdown_writer::future_writer_factory();\n     let (srv, doc) = test::create_doc_srv(~\"mod a { }\");\n     // Split the document up into pages\n-    let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n+    let doc = page_pass::mk_pass(config::DocPerMod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n     // We expect two pages to have been written\n     for iter::repeat(2u) {\n         comm::recv(po);\n     }\n }\n \n-fn write_title(ctxt: ctxt, page: doc::page) {\n+fn write_title(ctxt: Ctxt, page: doc::Page) {\n     ctxt.w.write_line(fmt!(\"%% %s\", make_title(page)));\n     ctxt.w.write_line(~\"\");\n }\n \n-fn make_title(page: doc::page) -> ~str {\n+fn make_title(page: doc::Page) -> ~str {\n     let item = match page {\n-      doc::cratepage(cratedoc) => {\n-        doc::modtag(cratedoc.topmod)\n+      doc::CratePage(CrateDoc) => {\n+        doc::ModTag(CrateDoc.topmod)\n       }\n-      doc::itempage(itemtag) => {\n-        itemtag\n+      doc::ItemPage(ItemTag) => {\n+        ItemTag\n       }\n     };\n     let title = markdown_pass::header_text(item);\n@@ -147,82 +147,82 @@ fn should_write_title_for_each_page() {\n     let (writer_factory, po) = markdown_writer::future_writer_factory();\n     let (srv, doc) = test::create_doc_srv(\n         ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n-    let doc = page_pass::mk_pass(config::doc_per_mod).f(srv, doc);\n+    let doc = page_pass::mk_pass(config::DocPerMod).f(srv, doc);\n     write_markdown(doc, writer_factory);\n     for iter::repeat(2u) {\n         let (page, markdown) = comm::recv(po);\n         match page {\n-          doc::cratepage(_) => {\n+          doc::CratePage(_) => {\n             assert str::contains(markdown, ~\"% Crate core\");\n           }\n-          doc::itempage(_) => {\n+          doc::ItemPage(_) => {\n             assert str::contains(markdown, ~\"% Module a\");\n           }\n         }\n     }\n }\n \n-enum hlvl {\n-    h1 = 1,\n-    h2 = 2,\n-    h3 = 3,\n-    h4 = 4\n+enum Hlvl {\n+    H1 = 1,\n+    H2 = 2,\n+    H3 = 3,\n+    H4 = 4\n }\n \n-fn write_header(ctxt: ctxt, lvl: hlvl, doc: doc::itemtag) {\n+fn write_header(ctxt: Ctxt, lvl: Hlvl, doc: doc::ItemTag) {\n     let text = header_text(doc);\n     write_header_(ctxt, lvl, text);\n }\n \n-fn write_header_(ctxt: ctxt, lvl: hlvl, title: ~str) {\n+fn write_header_(ctxt: Ctxt, lvl: Hlvl, title: ~str) {\n     let hashes = str::from_chars(vec::from_elem(lvl as uint, '#'));\n     ctxt.w.write_line(fmt!(\"%s %s\", hashes, title));\n     ctxt.w.write_line(~\"\");\n }\n \n-fn header_kind(doc: doc::itemtag) -> ~str {\n+fn header_kind(doc: doc::ItemTag) -> ~str {\n     match doc {\n-      doc::modtag(_) => {\n+      doc::ModTag(_) => {\n         if doc.id() == syntax::ast::crate_node_id {\n             ~\"Crate\"\n         } else {\n             ~\"Module\"\n         }\n       }\n-      doc::nmodtag(_) => {\n+      doc::NmodTag(_) => {\n         ~\"Foreign module\"\n       }\n-      doc::fntag(_) => {\n+      doc::FnTag(_) => {\n         ~\"Function\"\n       }\n-      doc::consttag(_) => {\n+      doc::ConstTag(_) => {\n         ~\"Const\"\n       }\n-      doc::enumtag(_) => {\n+      doc::EnumTag(_) => {\n         ~\"Enum\"\n       }\n-      doc::traittag(_) => {\n+      doc::TraitTag(_) => {\n         ~\"Interface\"\n       }\n-      doc::impltag(_) => {\n+      doc::ImplTag(_) => {\n         ~\"Implementation\"\n       }\n-      doc::tytag(_) => {\n+      doc::TyTag(_) => {\n         ~\"Type\"\n       }\n     }\n }\n \n-fn header_name(doc: doc::itemtag) -> ~str {\n+fn header_name(doc: doc::ItemTag) -> ~str {\n     let fullpath = str::connect(doc.path() + ~[doc.name()], ~\"::\");\n     match doc {\n-      doc::modtag(_) if doc.id() != syntax::ast::crate_node_id => {\n+      doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n         fullpath\n       }\n-      doc::nmodtag(_) => {\n+      doc::NmodTag(_) => {\n         fullpath\n       }\n-      doc::impltag(doc) => {\n+      doc::ImplTag(doc) => {\n         assert option::is_some(doc.self_ty);\n         let self_ty = option::get(doc.self_ty);\n         let mut trait_part = ~\"\";\n@@ -242,15 +242,15 @@ fn header_name(doc: doc::itemtag) -> ~str {\n     }\n }\n \n-fn header_text(doc: doc::itemtag) -> ~str {\n+fn header_text(doc: doc::ItemTag) -> ~str {\n     match doc {\n-      doc::impltag(impldoc) => {\n+      doc::ImplTag(ImplDoc) => {\n         let header_kind = header_kind(doc);\n-        let desc = if impldoc.trait_types.is_empty() {\n-            fmt!(\"for `%s`\", impldoc.self_ty.get())\n+        let desc = if ImplDoc.trait_types.is_empty() {\n+            fmt!(\"for `%s`\", ImplDoc.self_ty.get())\n         } else {\n-            fmt!(\"of `%s` for `%s`\", impldoc.trait_types[0],\n-                 impldoc.self_ty.get())\n+            fmt!(\"of `%s` for `%s`\", ImplDoc.trait_types[0],\n+                 ImplDoc.self_ty.get())\n         };\n         fmt!(\"%s %s\", header_kind, desc)\n       }\n@@ -265,24 +265,24 @@ fn header_text_(kind: ~str, name: ~str) -> ~str {\n }\n \n fn write_crate(\n-    ctxt: ctxt,\n-    doc: doc::cratedoc\n+    ctxt: Ctxt,\n+    doc: doc::CrateDoc\n ) {\n     write_top_module(ctxt, doc.topmod);\n }\n \n fn write_top_module(\n-    ctxt: ctxt,\n-    moddoc: doc::moddoc\n+    ctxt: Ctxt,\n+    ModDoc: doc::ModDoc\n ) {\n-    write_mod_contents(ctxt, moddoc);\n+    write_mod_contents(ctxt, ModDoc);\n }\n \n fn write_mod(\n-    ctxt: ctxt,\n-    moddoc: doc::moddoc\n+    ctxt: Ctxt,\n+    ModDoc: doc::ModDoc\n ) {\n-    write_mod_contents(ctxt, moddoc);\n+    write_mod_contents(ctxt, ModDoc);\n }\n \n #[test]\n@@ -292,16 +292,16 @@ fn should_write_full_path_to_mod() {\n }\n \n fn write_common(\n-    ctxt: ctxt,\n+    ctxt: Ctxt,\n     desc: Option<~str>,\n-    sections: ~[doc::section]\n+    sections: ~[doc::Section]\n ) {\n     write_desc(ctxt, desc);\n     write_sections(ctxt, sections);\n }\n \n fn write_desc(\n-    ctxt: ctxt,\n+    ctxt: Ctxt,\n     desc: Option<~str>\n ) {\n     match desc {\n@@ -313,14 +313,14 @@ fn write_desc(\n     }\n }\n \n-fn write_sections(ctxt: ctxt, sections: ~[doc::section]) {\n+fn write_sections(ctxt: Ctxt, sections: ~[doc::Section]) {\n     do vec::iter(sections) |section| {\n         write_section(ctxt, section);\n     }\n }\n \n-fn write_section(ctxt: ctxt, section: doc::section) {\n-    write_header_(ctxt, h4, section.header);\n+fn write_section(ctxt: Ctxt, section: doc::Section) {\n+    write_header_(ctxt, H4, section.header);\n     ctxt.w.write_line(section.body);\n     ctxt.w.write_line(~\"\");\n }\n@@ -336,52 +336,52 @@ fn should_write_sections() {\n }\n \n fn write_mod_contents(\n-    ctxt: ctxt,\n-    doc: doc::moddoc\n+    ctxt: Ctxt,\n+    doc: doc::ModDoc\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if option::is_some(doc.index) {\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for doc.items.each |itemtag| {\n-        write_item(ctxt, itemtag);\n+    for doc.items.each |ItemTag| {\n+        write_item(ctxt, ItemTag);\n     }\n }\n \n-fn write_item(ctxt: ctxt, doc: doc::itemtag) {\n+fn write_item(ctxt: Ctxt, doc: doc::ItemTag) {\n     write_item_(ctxt, doc, true);\n }\n \n-fn write_item_no_header(ctxt: ctxt, doc: doc::itemtag) {\n+fn write_item_no_header(ctxt: Ctxt, doc: doc::ItemTag) {\n     write_item_(ctxt, doc, false);\n }\n \n-fn write_item_(ctxt: ctxt, doc: doc::itemtag, write_header: bool) {\n+fn write_item_(ctxt: Ctxt, doc: doc::ItemTag, write_header: bool) {\n     if write_header {\n         write_item_header(ctxt, doc);\n     }\n \n     match doc {\n-      doc::modtag(moddoc) => write_mod(ctxt, moddoc),\n-      doc::nmodtag(nmoddoc) => write_nmod(ctxt, nmoddoc),\n-      doc::fntag(fndoc) => write_fn(ctxt, fndoc),\n-      doc::consttag(constdoc) => write_const(ctxt, constdoc),\n-      doc::enumtag(enumdoc) => write_enum(ctxt, enumdoc),\n-      doc::traittag(traitdoc) => write_trait(ctxt, traitdoc),\n-      doc::impltag(impldoc) => write_impl(ctxt, impldoc),\n-      doc::tytag(tydoc) => write_type(ctxt, tydoc)\n+      doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n+      doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n+      doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n+      doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n+      doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n+      doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n+      doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n+      doc::TyTag(TyDoc) => write_type(ctxt, TyDoc)\n     }\n }\n \n-fn write_item_header(ctxt: ctxt, doc: doc::itemtag) {\n+fn write_item_header(ctxt: Ctxt, doc: doc::ItemTag) {\n     write_header(ctxt, item_header_lvl(doc), doc);\n }\n \n-fn item_header_lvl(doc: doc::itemtag) -> hlvl {\n+fn item_header_lvl(doc: doc::ItemTag) -> Hlvl {\n     match doc {\n-      doc::modtag(_) | doc::nmodtag(_) => h1,\n-      _ => h2\n+      doc::ModTag(_) | doc::NmodTag(_) => H1,\n+      _ => H2\n     }\n }\n \n@@ -391,7 +391,7 @@ fn should_write_crate_description() {\n     assert str::contains(markdown, ~\"this is the crate\");\n }\n \n-fn write_index(ctxt: ctxt, index: doc::index) {\n+fn write_index(ctxt: Ctxt, index: doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n     }\n@@ -440,15 +440,15 @@ fn should_write_index_for_foreign_mods() {\n     );\n }\n \n-fn write_nmod(ctxt: ctxt, doc: doc::nmoddoc) {\n+fn write_nmod(ctxt: Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if option::is_some(doc.index) {\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for doc.fns.each |fndoc| {\n-        write_item_header(ctxt, doc::fntag(fndoc));\n-        write_fn(ctxt, fndoc);\n+    for doc.fns.each |FnDoc| {\n+        write_item_header(ctxt, doc::FnTag(FnDoc));\n+        write_fn(ctxt, FnDoc);\n     }\n }\n \n@@ -474,8 +474,8 @@ fn should_write_foreign_fn_headers() {\n }\n \n fn write_fn(\n-    ctxt: ctxt,\n-    doc: doc::fndoc\n+    ctxt: Ctxt,\n+    doc: doc::FnDoc\n ) {\n     write_fnlike(\n         ctxt,\n@@ -486,16 +486,16 @@ fn write_fn(\n }\n \n fn write_fnlike(\n-    ctxt: ctxt,\n+    ctxt: Ctxt,\n     sig: Option<~str>,\n     desc: Option<~str>,\n-    sections: ~[doc::section]\n+    sections: ~[doc::Section]\n ) {\n     write_sig(ctxt, sig);\n     write_common(ctxt, desc, sections);\n }\n \n-fn write_sig(ctxt: ctxt, sig: Option<~str>) {\n+fn write_sig(ctxt: Ctxt, sig: Option<~str>) {\n     match sig {\n       Some(sig) => {\n         ctxt.w.write_line(code_block_indent(sig));\n@@ -532,17 +532,17 @@ fn should_insert_blank_line_after_fn_signature() {\n #[test]\n fn should_correctly_indent_fn_signature() {\n     let doc = test::create_doc(~\"fn a() { }\");\n-    let doc = doc::doc_({\n+    let doc = doc::Doc_({\n         pages: ~[\n-            doc::cratepage({\n-                topmod: doc::moddoc_({\n-                    items: ~[doc::fntag({\n+            doc::CratePage({\n+                topmod: doc::ModDoc_({\n+                    items: ~[doc::FnTag({\n                         sig: Some(~\"line 1\\nline 2\"),\n                         .. doc.cratemod().fns()[0]\n                     })],\n                     .. *doc.cratemod()\n                 }),\n-                .. doc.cratedoc()\n+                .. doc.CrateDoc()\n             })\n         ]\n     });\n@@ -557,8 +557,8 @@ fn should_leave_blank_line_between_fn_header_and_sig() {\n }\n \n fn write_const(\n-    ctxt: ctxt,\n-    doc: doc::constdoc\n+    ctxt: Ctxt,\n+    doc: doc::ConstDoc\n ) {\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -579,8 +579,8 @@ fn should_write_const_description() {\n }\n \n fn write_enum(\n-    ctxt: ctxt,\n-    doc: doc::enumdoc\n+    ctxt: Ctxt,\n+    doc: doc::EnumDoc\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_variants(ctxt, doc.variants);\n@@ -600,21 +600,21 @@ fn should_write_enum_description() {\n }\n \n fn write_variants(\n-    ctxt: ctxt,\n-    docs: ~[doc::variantdoc]\n+    ctxt: Ctxt,\n+    docs: ~[doc::VariantDoc]\n ) {\n     if vec::is_empty(docs) {\n         return;\n     }\n \n-    write_header_(ctxt, h4, ~\"Variants\");\n+    write_header_(ctxt, H4, ~\"Variants\");\n \n     vec::iter(docs, |variant| write_variant(ctxt, variant) );\n \n     ctxt.w.write_line(~\"\");\n }\n \n-fn write_variant(ctxt: ctxt, doc: doc::variantdoc) {\n+fn write_variant(ctxt: Ctxt, doc: doc::VariantDoc) {\n     assert option::is_some(doc.sig);\n     let sig = option::get(doc.sig);\n     match doc.desc {\n@@ -660,17 +660,17 @@ fn should_write_variant_list_with_signatures() {\n          \\n* `c(int)` - a\\n\\n\");\n }\n \n-fn write_trait(ctxt: ctxt, doc: doc::traitdoc) {\n+fn write_trait(ctxt: Ctxt, doc: doc::TraitDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n-fn write_methods(ctxt: ctxt, docs: ~[doc::methoddoc]) {\n+fn write_methods(ctxt: Ctxt, docs: ~[doc::MethodDoc]) {\n     do vec::iter(docs) |doc| { write_method(ctxt, doc) }\n }\n \n-fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n-    write_header_(ctxt, h3, header_text_(~\"Method\", doc.name));\n+fn write_method(ctxt: Ctxt, doc: doc::MethodDoc) {\n+    write_header_(ctxt, H3, header_text_(~\"Method\", doc.name));\n     write_fnlike(\n         ctxt,\n         doc.sig,\n@@ -706,7 +706,7 @@ fn should_write_trait_method_signature() {\n     assert str::contains(markdown, ~\"\\n    fn a()\");\n }\n \n-fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n+fn write_impl(ctxt: Ctxt, doc: doc::ImplDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n@@ -745,8 +745,8 @@ fn should_write_impl_method_signature() {\n }\n \n fn write_type(\n-    ctxt: ctxt,\n-    doc: doc::tydoc\n+    ctxt: Ctxt,\n+    doc: doc::TyDoc\n ) {\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -780,11 +780,11 @@ mod test {\n         markdown\n     }\n \n-    fn create_doc_srv(source: ~str) -> (astsrv::srv, doc::doc) {\n+    fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n         do astsrv::from_str(source) |srv| {\n \n             let config = {\n-                output_style: config::doc_per_crate,\n+                output_style: config::DocPerCrate,\n                 .. config::default_config(&Path(\"whatever\"))\n             };\n \n@@ -810,22 +810,22 @@ mod test {\n         }\n     }\n \n-    fn create_doc(source: ~str) -> doc::doc {\n+    fn create_doc(source: ~str) -> doc::Doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n     fn write_markdown_str(\n-        doc: doc::doc\n+        doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, writer_factory);\n         return comm::recv(po).second();\n     }\n \n     fn write_markdown_str_srv(\n-        srv: astsrv::srv,\n-        doc: doc::doc\n+        srv: astsrv::Srv,\n+        doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         let pass = mk_pass(writer_factory);"}, {"sha": "59d8f6d765715c20de24aa72e698c7d5c18d40d2", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,80 +1,79 @@\n-use doc::item_utils;\n+use doc::ItemUtils;\n use io::ReaderUtil;\n \n-export writeinstr;\n-export writer;\n-export writer_factory;\n-export writer_util;\n-export writer_utils;\n+export WriteInstr;\n+export Writer;\n+export WriterFactory;\n+export WriterUtils;\n export make_writer_factory;\n export future_writer_factory;\n export make_filename;\n \n-enum writeinstr {\n-    write(~str),\n-    done\n+enum WriteInstr {\n+    Write(~str),\n+    Done\n }\n \n-type writer = fn~(+writeinstr);\n-type writer_factory = fn~(page: doc::page) -> writer;\n+type Writer = fn~(+WriteInstr);\n+type WriterFactory = fn~(page: doc::Page) -> Writer;\n \n-trait writer_utils {\n+trait WriterUtils {\n     fn write_str(str: ~str);\n     fn write_line(str: ~str);\n     fn write_done();\n }\n \n-impl writer: writer_utils {\n+impl Writer: WriterUtils {\n     fn write_str(str: ~str) {\n-        self(write(str));\n+        self(Write(str));\n     }\n \n     fn write_line(str: ~str) {\n         self.write_str(str + ~\"\\n\");\n     }\n \n     fn write_done() {\n-        self(done)\n+        self(Done)\n     }\n }\n \n-fn make_writer_factory(config: config::config) -> writer_factory {\n+fn make_writer_factory(config: config::Config) -> WriterFactory {\n     match config.output_format {\n-      config::markdown => {\n+      config::Markdown => {\n         markdown_writer_factory(config)\n       }\n-      config::pandoc_html => {\n+      config::PandocHtml => {\n         pandoc_writer_factory(config)\n       }\n     }\n }\n \n-fn markdown_writer_factory(config: config::config) -> writer_factory {\n-    fn~(page: doc::page) -> writer {\n+fn markdown_writer_factory(config: config::Config) -> WriterFactory {\n+    fn~(page: doc::Page) -> Writer {\n         markdown_writer(config, page)\n     }\n }\n \n-fn pandoc_writer_factory(config: config::config) -> writer_factory {\n-    fn~(page: doc::page) -> writer {\n+fn pandoc_writer_factory(config: config::Config) -> WriterFactory {\n+    fn~(page: doc::Page) -> Writer {\n         pandoc_writer(config, page)\n     }\n }\n \n fn markdown_writer(\n-    config: config::config,\n-    page: doc::page\n-) -> writer {\n+    config: config::Config,\n+    page: doc::Page\n+) -> Writer {\n     let filename = make_local_filename(config, page);\n     do generic_writer |markdown| {\n         write_file(&filename, markdown);\n     }\n }\n \n fn pandoc_writer(\n-    config: config::config,\n-    page: doc::page\n-) -> writer {\n+    config: config::Config,\n+    page: doc::Page\n+) -> Writer {\n     assert option::is_some(config.pandoc_cmd);\n     let pandoc_cmd = option::get(config.pandoc_cmd);\n     let filename = make_local_filename(config, page);\n@@ -146,55 +145,55 @@ fn readclose(fd: libc::c_int) -> ~str {\n     return buf;\n }\n \n-fn generic_writer(+process: fn~(markdown: ~str)) -> writer {\n-    let ch = do task::spawn_listener |po: comm::Port<writeinstr>| {\n+fn generic_writer(+process: fn~(markdown: ~str)) -> Writer {\n+    let ch = do task::spawn_listener |po: comm::Port<WriteInstr>| {\n         let mut markdown = ~\"\";\n         let mut keep_going = true;\n         while keep_going {\n             match comm::recv(po) {\n-              write(s) => markdown += s,\n-              done => keep_going = false\n+              Write(s) => markdown += s,\n+              Done => keep_going = false\n             }\n         }\n         process(markdown);\n     };\n \n-    fn~(+instr: writeinstr) {\n+    fn~(+instr: WriteInstr) {\n         comm::send(ch, instr);\n     }\n }\n \n fn make_local_filename(\n-    config: config::config,\n-    page: doc::page\n+    config: config::Config,\n+    page: doc::Page\n ) -> Path {\n     let filename = make_filename(config, page);\n     config.output_dir.push_rel(&filename)\n }\n \n fn make_filename(\n-    config: config::config,\n-    page: doc::page\n+    config: config::Config,\n+    page: doc::Page\n ) -> Path {\n     let filename = {\n         match page {\n-          doc::cratepage(doc) => {\n-            if config.output_format == config::pandoc_html &&\n-                config.output_style == config::doc_per_mod {\n+          doc::CratePage(doc) => {\n+            if config.output_format == config::PandocHtml &&\n+                config.output_style == config::DocPerMod {\n                 ~\"index\"\n             } else {\n                 assert doc.topmod.name() != ~\"\";\n                 doc.topmod.name()\n             }\n           }\n-          doc::itempage(doc) => {\n+          doc::ItemPage(doc) => {\n             str::connect(doc.path() + ~[doc.name()], ~\"_\")\n           }\n         }\n     };\n     let ext = match config.output_format {\n-      config::markdown => ~\"md\",\n-      config::pandoc_html => ~\"html\"\n+      config::Markdown => ~\"md\",\n+      config::PandocHtml => ~\"html\"\n     };\n \n     Path(filename).with_filetype(ext)\n@@ -204,12 +203,12 @@ fn make_filename(\n fn should_use_markdown_file_name_based_off_crate() {\n     let config = {\n         output_dir: Path(\"output/dir\"),\n-        output_format: config::markdown,\n-        output_style: config::doc_per_crate,\n+        output_format: config::Markdown,\n+        output_style: config::DocPerCrate,\n         .. config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"test\", ~\"\");\n-    let page = doc::cratepage(doc.cratedoc());\n+    let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n     assert filename.to_str() == ~\"output/dir/test.md\";\n }\n@@ -218,12 +217,12 @@ fn should_use_markdown_file_name_based_off_crate() {\n fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n     let config = {\n         output_dir: Path(\"output/dir\"),\n-        output_format: config::pandoc_html,\n-        output_style: config::doc_per_mod,\n+        output_format: config::PandocHtml,\n+        output_style: config::DocPerMod,\n         .. config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"\", ~\"\");\n-    let page = doc::cratepage(doc.cratedoc());\n+    let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n     assert filename.to_str() == ~\"output/dir/index.html\";\n }\n@@ -232,20 +231,20 @@ fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n fn should_name_mod_file_names_by_path() {\n     let config = {\n         output_dir: Path(\"output/dir\"),\n-        output_format: config::pandoc_html,\n-        output_style: config::doc_per_mod,\n+        output_format: config::PandocHtml,\n+        output_style: config::DocPerMod,\n         .. config::default_config(&Path(\"input/test.rc\"))\n     };\n     let doc = test::mk_doc(~\"\", ~\"mod a { mod b { } }\");\n     let modb = doc.cratemod().mods()[0].mods()[0];\n-    let page = doc::itempage(doc::modtag(modb));\n+    let page = doc::ItemPage(doc::ModTag(modb));\n     let filename = make_local_filename(config, page);\n     assert  filename == Path(\"output/dir/a_b.html\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(name: ~str, source: ~str) -> doc::doc {\n+    fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, name);\n             let doc = path_pass::mk_pass().f(srv, doc);\n@@ -266,10 +265,10 @@ fn write_file(path: &Path, s: ~str) {\n }\n \n fn future_writer_factory(\n-) -> (writer_factory, comm::Port<(doc::page, ~str)>) {\n+) -> (WriterFactory, comm::Port<(doc::Page, ~str)>) {\n     let markdown_po = comm::Port();\n     let markdown_ch = comm::Chan(markdown_po);\n-    let writer_factory = fn~(page: doc::page) -> writer {\n+    let writer_factory = fn~(page: doc::Page) -> Writer {\n         let writer_po = comm::Port();\n         let writer_ch = comm::Chan(writer_po);\n         do task::spawn {\n@@ -284,17 +283,17 @@ fn future_writer_factory(\n     (writer_factory, markdown_po)\n }\n \n-fn future_writer() -> (writer, future::Future<~str>) {\n+fn future_writer() -> (Writer, future::Future<~str>) {\n     let (chan, port) = pipes::stream();\n-    let writer = fn~(+instr: writeinstr) {\n+    let writer = fn~(+instr: WriteInstr) {\n         chan.send(copy instr);\n     };\n     let future = do future::from_fn {\n         let mut res = ~\"\";\n         loop {\n             match port.recv() {\n-              write(s) => res += s,\n-              done => break\n+              Write(s) => res += s,\n+              Done => break\n             }\n         }\n         res"}, {"sha": "d67c615f6290ecf17f7d804bf4c4707187398717", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -5,27 +5,27 @@\n  * individual modules, pages for the crate, indexes, etc.\n  */\n \n-use doc::{item_utils, page_utils};\n+use doc::{ItemUtils, PageUtils};\n use syntax::ast;\n \n export mk_pass;\n \n-fn mk_pass(output_style: config::output_style) -> pass {\n+fn mk_pass(output_style: config::OutputStyle) -> Pass {\n     {\n         name: ~\"page\",\n-        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, output_style)\n         }\n     }\n }\n \n fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc,\n-    output_style: config::output_style\n-) -> doc::doc {\n+    _srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    output_style: config::OutputStyle\n+) -> doc::Doc {\n \n-    if output_style == config::doc_per_crate {\n+    if output_style == config::DocPerCrate {\n         return doc;\n     }\n \n@@ -38,10 +38,10 @@ fn run(\n     comm::recv(result_port)\n }\n \n-type page_port = comm::Port<Option<doc::page>>;\n-type page_chan = comm::Chan<Option<doc::page>>;\n+type PagePort = comm::Port<Option<doc::Page>>;\n+type PageChan = comm::Chan<Option<doc::Page>>;\n \n-fn make_doc_from_pages(page_port: page_port) -> doc::doc {\n+fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n     let mut pages = ~[];\n     loop {\n         let val = comm::recv(page_port);\n@@ -51,13 +51,13 @@ fn make_doc_from_pages(page_port: page_port) -> doc::doc {\n             break;\n         }\n     }\n-    doc::doc_({\n+    doc::Doc_({\n         pages: pages\n     })\n }\n \n-fn find_pages(doc: doc::doc, page_chan: page_chan) {\n-    let fold = fold::fold({\n+fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n+    let fold = fold::Fold({\n         fold_crate: fold_crate,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n@@ -69,13 +69,13 @@ fn find_pages(doc: doc::doc, page_chan: page_chan) {\n }\n \n fn fold_crate(\n-    fold: fold::fold<page_chan>,\n-    doc: doc::cratedoc\n-) -> doc::cratedoc {\n+    fold: fold::Fold<PageChan>,\n+    doc: doc::CrateDoc\n+) -> doc::CrateDoc {\n \n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n-    let page = doc::cratepage({\n+    let page = doc::CratePage({\n         topmod: strip_mod(doc.topmod),\n         .. doc\n     });\n@@ -86,28 +86,28 @@ fn fold_crate(\n }\n \n fn fold_mod(\n-    fold: fold::fold<page_chan>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n+    fold: fold::Fold<PageChan>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n \n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     if doc.id() != ast::crate_node_id {\n \n         let doc = strip_mod(doc);\n-        let page = doc::itempage(doc::modtag(doc));\n+        let page = doc::ItemPage(doc::ModTag(doc));\n         comm::send(fold.ctxt, Some(page));\n     }\n \n     doc\n }\n \n-fn strip_mod(doc: doc::moddoc) -> doc::moddoc {\n-    doc::moddoc_({\n+fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n+    doc::ModDoc_({\n         items: do vec::filter(doc.items) |item| {\n             match item {\n-              doc::modtag(_) => false,\n-              doc::nmodtag(_) => false,\n+              doc::ModTag(_) => false,\n+              doc::NmodTag(_) => false,\n               _ => true\n             }\n         },\n@@ -116,19 +116,19 @@ fn strip_mod(doc: doc::moddoc) -> doc::moddoc {\n }\n \n fn fold_nmod(\n-    fold: fold::fold<page_chan>,\n-    doc: doc::nmoddoc\n-) -> doc::nmoddoc {\n+    fold: fold::Fold<PageChan>,\n+    doc: doc::NmodDoc\n+) -> doc::NmodDoc {\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n-    let page = doc::itempage(doc::nmodtag(doc));\n+    let page = doc::ItemPage(doc::NmodTag(doc));\n     comm::send(fold.ctxt, Some(page));\n     return doc;\n }\n \n #[test]\n fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n     let doc = test::mk_doc_(\n-        config::doc_per_crate,\n+        config::DocPerCrate,\n         ~\"mod a { } mod b { mod c { } }\"\n     );\n     assert doc.pages.len() == 1u;\n@@ -161,16 +161,16 @@ fn should_remove_foreign_mods_from_containing_mods() {\n #[cfg(test)]\n mod test {\n     fn mk_doc_(\n-        output_style: config::output_style,\n+        output_style: config::OutputStyle,\n         source: ~str\n-    ) -> doc::doc {\n+    ) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             run(srv, doc, output_style)\n         }\n     }\n \n-    fn mk_doc(source: ~str) -> doc::doc {\n-        mk_doc_(config::doc_per_mod, source)\n+    fn mk_doc(source: ~str) -> doc::Doc {\n+        mk_doc_(config::DocPerMod, source)\n     }\n }"}, {"sha": "84b542f6bf0ddb7bfc3bcd2e1c9264858df3dd1a", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,29 +1,29 @@\n //! Records the full path to items\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n use syntax::ast;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"path\",\n         f: run\n     }\n }\n \n-type ctxt = {\n-    srv: astsrv::srv,\n+type Ctxt = {\n+    srv: astsrv::Srv,\n     mut path: ~[~str]\n };\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n     let ctxt = {\n         srv: srv,\n         mut path: ~[]\n     };\n-    let fold = fold::fold({\n+    let fold = fold::Fold({\n         fold_item: fold_item,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n@@ -32,28 +32,28 @@ fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     fold.fold_doc(fold, doc)\n }\n \n-fn fold_item(fold: fold::fold<ctxt>, doc: doc::itemdoc) -> doc::itemdoc {\n+fn fold_item(fold: fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     {\n         path: fold.ctxt.path,\n         .. doc\n     }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n+fn fold_mod(fold: fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n     let is_topmod = doc.id() == ast::crate_node_id;\n \n     if !is_topmod { vec::push(fold.ctxt.path, doc.name()); }\n     let doc = fold::default_any_fold_mod(fold, doc);\n     if !is_topmod { vec::pop(fold.ctxt.path); }\n \n-    doc::moddoc_({\n+    doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n         .. *doc\n     })\n }\n \n-fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n+fn fold_nmod(fold: fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n     vec::push(fold.ctxt.path, doc.name());\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     vec::pop(fold.ctxt.path);"}, {"sha": "597c0418c517e7dd29d24fbc10f2b99e452acf2f", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,39 +1,39 @@\n //! Prunes things with the #[doc(hidden)] attribute\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n use std::map::HashMap;\n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"prune_hidden\",\n         f: run\n     }\n }\n \n-fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n-    let fold = fold::fold({\n+fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_mod: fold_mod,\n         .. *fold::default_any_fold(srv)\n     });\n     fold.fold_doc(fold, doc)\n }\n \n fn fold_mod(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    doc::moddoc_({\n-        items: vec::filter(doc.items, |itemtag| {\n-            !is_hidden(fold.ctxt, itemtag.item())\n+    doc::ModDoc_({\n+        items: vec::filter(doc.items, |ItemTag| {\n+            !is_hidden(fold.ctxt, ItemTag.item())\n         }),\n         .. *doc\n     })\n }\n \n-fn is_hidden(srv: astsrv::srv, doc: doc::itemdoc) -> bool {\n+fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     use syntax::ast_map;\n \n     let id = doc.id;\n@@ -54,7 +54,7 @@ fn should_prune_hidden_items() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             run(srv, doc)"}, {"sha": "1ca4c347ba2b2c8de71782689a07eeab4a8a3493", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -15,7 +15,6 @@\n \n #[allow(vecs_implicitly_copyable,\n         non_implicitly_copyable_typarams)];\n-#[allow(non_camel_case_types)];\n \n extern mod core(vers = \"0.4\");\n extern mod std(vers = \"0.4\");"}, {"sha": "5643b434ab2fef14639ac0c1b87f3f1c282455bd", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,19 +1,19 @@\n // Some utility interfaces\n-use doc::item_utils;\n-use doc::item;\n+use doc::ItemUtils;\n+use doc::Item;\n use doc::util;\n \n /// A single operation on the document model\n-type pass = {\n+type Pass = {\n     name: ~str,\n-    f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc\n+    f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc\n };\n \n fn run_passes(\n-    srv: astsrv::srv,\n-    doc: doc::doc,\n-    passes: ~[pass]\n-) -> doc::doc {\n+    srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    passes: ~[Pass]\n+) -> doc::Doc {\n     let mut passno = 0;\n     do vec::foldl(doc, passes) |doc, pass| {\n         log(debug, fmt!(\"pass #%d\", passno));\n@@ -28,13 +28,13 @@ fn run_passes(\n #[test]\n fn test_run_passes() {\n     fn pass1(\n-        _srv: astsrv::srv,\n-        doc: doc::doc\n-    ) -> doc::doc {\n-        doc::doc_({\n+        _srv: astsrv::Srv,\n+        doc: doc::Doc\n+    ) -> doc::Doc {\n+        doc::Doc_({\n             pages: ~[\n-                doc::cratepage({\n-                    topmod: doc::moddoc_({\n+                doc::CratePage({\n+                    topmod: doc::ModDoc_({\n                         item: {\n                             name: doc.cratemod().name() + ~\"two\",\n                             .. doc.cratemod().item\n@@ -47,13 +47,13 @@ fn test_run_passes() {\n         })\n     }\n     fn pass2(\n-        _srv: astsrv::srv,\n-        doc: doc::doc\n-    ) -> doc::doc {\n-        doc::doc_({\n+        _srv: astsrv::Srv,\n+        doc: doc::Doc\n+    ) -> doc::Doc {\n+        doc::Doc_({\n             pages: ~[\n-                doc::cratepage({\n-                    topmod: doc::moddoc_({\n+                doc::CratePage({\n+                    topmod: doc::ModDoc_({\n                         item: {\n                             name: doc.cratemod().name() + ~\"three\",\n                             .. doc.cratemod().item\n@@ -110,7 +110,7 @@ fn time<T>(what: ~str, f: fn() -> T) -> T {\n }\n \n /// Runs rustdoc over the given file\n-fn run(config: config::config) {\n+fn run(config: config::Config) {\n \n     let source_file = config.input_crate;\n     do astsrv::from_file(source_file.to_str()) |srv| {"}, {"sha": "608f61fa48b6a2b47f35607a7724dc9aee116e20", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,18 +1,18 @@\n //! Breaks rustdocs into sections according to their headers\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"sectionalize\",\n         f: run\n     }\n }\n \n-fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n-    let fold = fold::fold({\n+fn run(_srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_item: fold_item,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -21,7 +21,7 @@ fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     fold.fold_doc(fold, doc)\n }\n \n-fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n+fn fold_item(fold: fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n     let (desc, sections) = sectionalize(doc.desc);\n \n@@ -32,7 +32,7 @@ fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n     }\n }\n \n-fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n+fn fold_trait(fold: fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     {\n@@ -49,7 +49,7 @@ fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n     }\n }\n \n-fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n+fn fold_impl(fold: fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     {\n@@ -66,7 +66,7 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n     }\n }\n \n-fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::section]) {\n+fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n \n     /*!\n      * Take a description of the form\n@@ -227,7 +227,7 @@ fn should_sectionalize_impl_methods() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "6bff185a3d252bff01ad3857b7553676ac7c640d", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,10 +1,10 @@\n //! Sorts items by name\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n export mk_pass;\n \n-fn mk_pass() -> pass {\n-    pure fn by_item_name(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+fn mk_pass() -> Pass {\n+    pure fn by_item_name(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         (*item1).name() <= (*item2).name()\n     }\n     sort_pass::mk_pass(~\"sort_item_name\", by_item_name)"}, {"sha": "ea53a2e3749ee29674b97b4bedd3ffc34c3f6760", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,21 +1,21 @@\n //! Sorts items by type\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n-    pure fn by_score(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n-        pure fn score(item: &doc::itemtag) -> int {\n+fn mk_pass() -> Pass {\n+    pure fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n+        pure fn score(item: &doc::ItemTag) -> int {\n             match *item {\n-              doc::consttag(_) => 0,\n-              doc::tytag(_) => 1,\n-              doc::enumtag(_) => 2,\n-              doc::traittag(_) => 3,\n-              doc::impltag(_) => 4,\n-              doc::fntag(_) => 5,\n-              doc::modtag(_) => 6,\n-              doc::nmodtag(_) => 7\n+              doc::ConstTag(_) => 0,\n+              doc::TyTag(_) => 1,\n+              doc::EnumTag(_) => 2,\n+              doc::TraitTag(_) => 3,\n+              doc::ImplTag(_) => 4,\n+              doc::FnTag(_) => 5,\n+              doc::ModTag(_) => 6,\n+              doc::NmodTag(_) => 7\n             }\n         }\n "}, {"sha": "497c076d3ab6c27814aeac3989807b3420dd6a67", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,28 +1,28 @@\n //! A general sorting pass\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n use std::sort;\n \n export item_lteq, mk_pass;\n \n-type item_lteq = pure fn~(v1: &doc::itemtag, v2:  &doc::itemtag) -> bool;\n+type ItemLtEq = pure fn~(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n \n-fn mk_pass(name: ~str, +lteq: item_lteq) -> pass {\n+fn mk_pass(name: ~str, +lteq: ItemLtEq) -> Pass {\n     {\n         name: name,\n-        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, lteq)\n         }\n     }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc,\n-    lteq: item_lteq\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    _srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    lteq: ItemLtEq\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_mod: fold_mod,\n         .. *fold::default_any_fold(lteq)\n     });\n@@ -31,19 +31,19 @@ fn run(\n \n #[allow(non_implicitly_copyable_typarams)]\n fn fold_mod(\n-    fold: fold::fold<item_lteq>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n+    fold: fold::Fold<ItemLtEq>,\n+    doc: doc::ModDoc\n+) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n-    doc::moddoc_({\n+    doc::ModDoc_({\n         items: sort::merge_sort(fold.ctxt, doc.items),\n         .. *doc\n     })\n }\n \n #[test]\n fn test() {\n-    pure fn name_lteq(item1: &doc::itemtag, item2: &doc::itemtag) -> bool {\n+    pure fn name_lteq(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         (*item1).name() <= (*item2).name()\n     }\n \n@@ -60,7 +60,7 @@ fn test() {\n \n #[test]\n fn should_be_stable() {\n-    pure fn always_eq(_item1: &doc::itemtag, _item2: &doc::itemtag) -> bool {\n+    pure fn always_eq(_item1: &doc::ItemTag, _item2: &doc::ItemTag) -> bool {\n         true\n     }\n "}, {"sha": "9f7d6fda18fa5612f6322cfc5d8acff7c8df7efd", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,27 +1,27 @@\n //! Generic pass for performing an operation on all descriptions\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass(name: ~str, +op: fn~(~str) -> ~str) -> pass {\n+fn mk_pass(name: ~str, +op: fn~(~str) -> ~str) -> Pass {\n     {\n         name: name,\n-        f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n+        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, op)\n         }\n     }\n }\n \n-type op = fn~(~str) -> ~str;\n+type Op = fn~(~str) -> ~str;\n \n #[allow(non_implicitly_copyable_typarams)]\n fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc,\n-    op: op\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    _srv: astsrv::Srv,\n+    doc: doc::Doc,\n+    op: Op\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n@@ -31,11 +31,11 @@ fn run(\n     fold.fold_doc(fold, doc)\n }\n \n-fn maybe_apply_op(op: op, s: Option<~str>) -> Option<~str> {\n+fn maybe_apply_op(op: Op, s: Option<~str>) -> Option<~str> {\n     option::map(s, |s| op(s) )\n }\n \n-fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n+fn fold_item(fold: fold::Fold<Op>, doc: doc::ItemDoc) -> doc::ItemDoc {\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     {\n@@ -46,14 +46,14 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n     }\n }\n \n-fn apply_to_sections(op: op, sections: ~[doc::section]) -> ~[doc::section] {\n+fn apply_to_sections(op: Op, sections: ~[doc::Section]) -> ~[doc::Section] {\n     par::map(sections, |section, copy op| {\n         header: op(section.header),\n         body: op(section.body)\n     })\n }\n \n-fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n+fn fold_enum(fold: fold::Fold<Op>, doc: doc::EnumDoc) -> doc::EnumDoc {\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n@@ -67,7 +67,7 @@ fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     }\n }\n \n-fn fold_trait(fold: fold::fold<op>, doc: doc::traitdoc) -> doc::traitdoc {\n+fn fold_trait(fold: fold::Fold<Op>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     {\n@@ -76,7 +76,7 @@ fn fold_trait(fold: fold::fold<op>, doc: doc::traitdoc) -> doc::traitdoc {\n     }\n }\n \n-fn apply_to_methods(op: op, docs: ~[doc::methoddoc]) -> ~[doc::methoddoc] {\n+fn apply_to_methods(op: Op, docs: ~[doc::MethodDoc]) -> ~[doc::MethodDoc] {\n     do par::map(docs) |doc, copy op| {\n         {\n             brief: maybe_apply_op(op, doc.brief),\n@@ -87,7 +87,7 @@ fn apply_to_methods(op: op, docs: ~[doc::methoddoc]) -> ~[doc::methoddoc] {\n     }\n }\n \n-fn fold_impl(fold: fold::fold<op>, doc: doc::impldoc) -> doc::impldoc {\n+fn fold_impl(fold: fold::Fold<Op>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     {\n@@ -252,7 +252,7 @@ fn should_execute_on_impl_method_section_bodies() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "dcbda1af9f690e0b9ff3ab28ee6d51a5d58f277d", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -5,11 +5,11 @@\n  * is interpreted as the brief description.\n  */\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"trim\", |s| str::trim(s) )\n }\n \n@@ -22,7 +22,7 @@ fn should_trim_text() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             let doc = attr_pass::mk_pass().f(srv, doc);"}, {"sha": "fa6e5c032df68d6f074f4905208bd8183545b091", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -1,6 +1,6 @@\n //! Pulls type information out of the AST and attaches it to the document\n \n-use doc::item_utils;\n+use doc::ItemUtils;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::ast_map;\n@@ -9,18 +9,18 @@ use extract::to_str;\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     {\n         name: ~\"tystr\",\n         f: run\n     }\n }\n \n fn run(\n-    srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let fold = fold::fold({\n+    srv: astsrv::Srv,\n+    doc: doc::Doc\n+) -> doc::Doc {\n+    let fold = fold::Fold({\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n@@ -33,9 +33,9 @@ fn run(\n }\n \n fn fold_fn(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::FnDoc\n+) -> doc::FnDoc {\n \n     let srv = fold.ctxt;\n \n@@ -45,7 +45,7 @@ fn fold_fn(\n     }\n }\n \n-fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> Option<~str> {\n+fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n         match ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n@@ -76,9 +76,9 @@ fn should_add_foreign_fn_sig() {\n }\n \n fn fold_const(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::constdoc\n-) -> doc::constdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::ConstDoc\n+) -> doc::ConstDoc {\n     let srv = fold.ctxt;\n \n     {\n@@ -103,9 +103,9 @@ fn should_add_const_types() {\n }\n \n fn fold_enum(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::enumdoc\n-) -> doc::enumdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::EnumDoc\n+) -> doc::EnumDoc {\n     let doc_id = doc.id();\n     let srv = fold.ctxt;\n \n@@ -143,20 +143,20 @@ fn should_add_variant_sigs() {\n }\n \n fn fold_trait(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::traitdoc\n-) -> doc::traitdoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::TraitDoc\n+) -> doc::TraitDoc {\n     {\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods),\n         .. doc\n     }\n }\n \n fn merge_methods(\n-    srv: astsrv::srv,\n-    item_id: doc::ast_id,\n-    docs: ~[doc::methoddoc]\n-) -> ~[doc::methoddoc] {\n+    srv: astsrv::Srv,\n+    item_id: doc::AstId,\n+    docs: ~[doc::MethodDoc]\n+) -> ~[doc::MethodDoc] {\n     do par::map(docs) |doc| {\n         {\n             sig: get_method_sig(srv, item_id, doc.name),\n@@ -166,8 +166,8 @@ fn merge_methods(\n }\n \n fn get_method_sig(\n-    srv: astsrv::srv,\n-    item_id: doc::ast_id,\n+    srv: astsrv::Srv,\n+    item_id: doc::AstId,\n     method_name: ~str\n ) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n@@ -234,9 +234,9 @@ fn should_add_trait_method_sigs() {\n }\n \n fn fold_impl(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::ImplDoc\n+) -> doc::ImplDoc {\n \n     let srv = fold.ctxt;\n \n@@ -289,9 +289,9 @@ fn should_add_impl_method_sigs() {\n }\n \n fn fold_type(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::tydoc\n-) -> doc::tydoc {\n+    fold: fold::Fold<astsrv::Srv>,\n+    doc: doc::TyDoc\n+) -> doc::TyDoc {\n \n     let srv = fold.ctxt;\n \n@@ -324,7 +324,7 @@ fn should_add_type_signatures() {\n \n #[cfg(test)]\n mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, ~\"\");\n             run(srv, doc)"}, {"sha": "e650b8eb907ec423210a39bff381bbb6f5d93912", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b1e62750bbce86833409ac59d9797fd5ba2964/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=b3b1e62750bbce86833409ac59d9797fd5ba2964", "patch": "@@ -11,7 +11,7 @@\n \n export mk_pass;\n \n-fn mk_pass() -> pass {\n+fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"unindent\", unindent)\n }\n "}]}