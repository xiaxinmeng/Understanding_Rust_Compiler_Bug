{"sha": "0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNWU0MTkxNjMyZGU0YmJjMWVmNGVmMmJlMjZiNTE3ODYxY2JmZjA=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-03-02T05:52:27Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-03-30T10:27:14Z"}, "message": "Add a generic CAS loop to std::sync::Atomic*\n\nThis adds a new method to all numeric `Atomic*` types with a\nsafe compare-and-set loop, so users will no longer need to write\ntheir own, except in *very* strange circumstances.\n\nThis solves #48384 with `x.fetch_max(_)`/`x.fetch_min(_)`. It\nalso relates to #48655 (which I misuse as tracking issue for now).\n\n*note* This *might* need a crater run because the functions could\nclash with third party extension traits.", "tree": {"sha": "9b9d20a2dbae25349839e421e4e2578c72d1958d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b9d20a2dbae25349839e421e4e2578c72d1958d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "html_url": "https://github.com/rust-lang/rust/commit/0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f5e4191632de4bbc1ef4ef2be26b517861cbff0/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e4603f99066eaf2c1cf19ac3afbac9057b1e177", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e4603f99066eaf2c1cf19ac3afbac9057b1e177", "html_url": "https://github.com/rust-lang/rust/commit/5e4603f99066eaf2c1cf19ac3afbac9057b1e177"}], "stats": {"total": 185, "additions": 185, "deletions": 0}, "files": [{"sha": "3d5f63f41b4df4e95af3d8f2e6556369cc277222", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/0f5e4191632de4bbc1ef4ef2be26b517861cbff0/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5e4191632de4bbc1ef4ef2be26b517861cbff0/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0f5e4191632de4bbc1ef4ef2be26b517861cbff0", "patch": "@@ -949,6 +949,7 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n      $extra_feature:expr,\n+     $min_fn:ident, $max_fn:ident,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -1418,6 +1419,128 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n+\n+            doc_comment! {\n+                concat!(\"Fetches the value, and applies a function to it that returns an optional\n+new value. Returns a `Result` (`Ok(_)` if the function returned `Some(_)`, else `Err(_)`) of the\n+previous value.\n+\n+Note: This may call the function multiple times if the value has been changed from other threads in\n+the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+but once to the stored value.\n+\n+# Examples\n+\n+```rust\n+#![feature(no_more_cas)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let x = \", stringify!($atomic_type), \"::new(7);\n+assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.load(Ordering::SeqCst), 9);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"no_more_cas\",\n+                       reason = \"no more CAS loops in user code\",\n+                       issue = \"48655\")]\n+                pub fn fetch_update<F>(&self,\n+                                       mut f: F,\n+                                       fetch_order: Ordering,\n+                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                where F: FnMut($int_type) -> Option<$int_type> {\n+                    let mut prev = self.load(fetch_order);\n+                    while let Some(next) = f(prev) {\n+                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                            x @ Ok(_) => return x,\n+                            Err(next_prev) => prev = next_prev\n+                        }\n+                    }\n+                    Err(prev)\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Maximum with the current value.\n+\n+Finds the maximum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+assert_eq!(foo.load(Ordering::SeqCst), 42);\n+```\n+\n+If you want to obtain the maximum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 42;\n+let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+assert!(max_foo == 42);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $max_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Minimum with the current value.\n+\n+Finds the minimum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 23);\n+assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 22);\n+```\n+\n+If you want to obtain the minimum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 12;\n+let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+assert_eq!(min_foo, 12);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $min_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n         }\n     }\n }\n@@ -1432,6 +1555,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1444,6 +1568,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1456,6 +1581,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1468,6 +1594,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1480,6 +1607,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1492,6 +1620,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1504,6 +1633,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1516,6 +1646,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1528,6 +1659,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n     \"\",\n+    atomic_min, atomic_max,\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1540,6 +1672,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n     \"\",\n+    atomic_umin, atomic_umax,\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1717,6 +1850,58 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_max(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_min(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umax(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umin(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n /// An atomic fence.\n ///\n /// Depending on the specified order, a fence prevents the compiler and CPU from"}]}