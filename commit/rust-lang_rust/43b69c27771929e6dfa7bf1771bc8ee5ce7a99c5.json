{"sha": "43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYjY5YzI3NzcxOTI5ZTZkZmE3YmYxNzcxYmM4ZWU1Y2U3YTk5YzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-15T04:28:26Z"}, "committer": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-19T17:45:26Z"}, "message": "make liveness generic over set of local variables\n\nWe used to hardcode that we wanted the liveness of *all* variables.\nThis can now be configured by selecting an alternative index type\nV and providing a (partial) map from locals to that new type V.", "tree": {"sha": "dbf59b2e7a55d248d0e81fd2e568f8ad51c3e067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbf59b2e7a55d248d0e81fd2e568f8ad51c3e067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "html_url": "https://github.com/rust-lang/rust/commit/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b5f0ba8c260d7c2e40c152bee11e8f329867c80", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5f0ba8c260d7c2e40c152bee11e8f329867c80", "html_url": "https://github.com/rust-lang/rust/commit/4b5f0ba8c260d7c2e40c152bee11e8f329867c80"}], "stats": {"total": 272, "additions": 170, "deletions": 102}, "files": [{"sha": "15ebb7a7a29f14b64a661d99aebf4682a1a4522d", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "patch": "@@ -22,7 +22,6 @@ use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir, Local};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::env;\n@@ -31,7 +30,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n use transform::MirSource;\n-use util::liveness::{LivenessResults, LocalSet};\n+use util::liveness::{IdentityMap, LivenessResults, LocalSet};\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -104,7 +103,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let elements = &Rc::new(RegionValueElements::new(mir, universal_regions.len()));\n \n     // Run the MIR type-checker.\n-    let liveness = &LivenessResults::compute(mir);\n+    let liveness = &LivenessResults::compute(mir, &IdentityMap::new(mir));\n     let constraint_sets = type_check::type_check(\n         infcx,\n         param_env,\n@@ -220,14 +219,16 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n+    let map = &IdentityMap::new(mir);\n+\n     let regular_liveness_per_location: FxHashMap<_, _> = mir\n         .basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n             liveness\n                 .regular\n-                .simulate_block(&mir, bb, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -241,7 +242,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             let mut results = vec![];\n             liveness\n                 .drop\n-                .simulate_block(&mir, bb, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results"}, {"sha": "0eb88b7bcbfd390d2ca8009f1fd5353c23bb43fd", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "patch": "@@ -20,9 +20,8 @@ use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n-use util::liveness::{LivenessResults, LiveVariableMap};\n+use util::liveness::{IdentityMap, LivenessResults};\n \n use super::TypeChecker;\n \n@@ -48,6 +47,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n         flow_inits,\n         move_data,\n         drop_data: FxHashMap(),\n+        map: &IdentityMap::new(mir),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -61,22 +61,22 @@ where\n     'flow: 'gen,\n     'tcx: 'typeck + 'flow,\n     'gcx: 'tcx,\n-    V: 'gen,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults<Local>,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+    map: &'gen IdentityMap<'gen, 'tcx>,\n }\n \n struct DropData<'tcx> {\n     dropck_result: DropckOutlivesResult<'tcx>,\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx, V:LiveVariableMap> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V> {\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n     /// Liveness constraints:\n     ///\n     /// > If a variable V is live at point P, then all regions R in the type of V\n@@ -86,17 +86,17 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx, V:LiveVariableMap> TypeLivenessGenerator<\n \n         self.liveness\n             .regular\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n                     Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n             });\n \n-        let mut all_live_locals: Vec<(Location, Vec<V::LiveVar>)> = vec![];\n+        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n         self.liveness\n             .drop\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n         debug!("}, {"sha": "7d4d561072e7a851d5e69366179c79c407874923", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "patch": "@@ -66,7 +66,7 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n-use util::liveness::{self, LivenessMode};\n+use util::liveness::{self, IdentityMap, LivenessMode};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use std::collections::HashMap;\n@@ -334,7 +334,7 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n \n struct BorrowedLocals(liveness::LocalSet<Local>);\n \n-fn mark_as_borrowed<'tcx, V: Idx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n+fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     match *place {\n         Place::Local(l) => { locals.0.add(&l); },\n         Place::Static(..) => (),\n@@ -397,11 +397,22 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let mut liveness = liveness::liveness_of_locals(mir, LivenessMode {\n-        include_regular_use: true,\n-        include_drops: true,\n-    });\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n+    let mut liveness = liveness::liveness_of_locals(\n+        mir,\n+        LivenessMode {\n+            include_regular_use: true,\n+            include_drops: true,\n+        },\n+        &IdentityMap::new(mir),\n+    );\n+    liveness::dump_mir(\n+        tcx,\n+        \"generator_liveness\",\n+        source,\n+        mir,\n+        &IdentityMap::new(mir),\n+        &liveness,\n+    );\n \n     let mut storage_liveness_map = HashMap::new();\n "}, {"sha": "ea8a180e3b618f87f4f6d4abc289187256978d23", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 139, "deletions": 83, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=43b69c27771929e6dfa7bf1771bc8ee5ce7a99c5", "patch": "@@ -33,46 +33,63 @@\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n \n-use rustc::mir::*;\n+use rustc::mir::visit::MirVisitable;\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc::mir::Local;\n+use rustc::mir::*;\n+use rustc::ty::item_path;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n-use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n-use rustc::ty::item_path;\n-use rustc::mir::Local;\n-use rustc::mir::visit::MirVisitable;\n-use std::path::{Path, PathBuf};\n use std::fs;\n-use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n+use std::path::{Path, PathBuf};\n use transform::MirSource;\n+use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LocalSet<V: LiveVariableMap> = IdxSetBuf<V::LiveVar>;\n+pub type LocalSet<V> = IdxSetBuf<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the\n /// intra-block results.\n-pub struct LivenessResult<V: LiveVariableMap> {\n+///\n+/// The `V` type defines the set of variables that we computed\n+/// liveness for. This is often `Local`, in which case we computed\n+/// liveness for all variables -- but it can also be some other type,\n+/// which indicates a subset of the variables within the graph.\n+pub struct LivenessResult<V: Idx> {\n     /// Liveness mode in use when these results were computed.\n     pub mode: LivenessMode,\n \n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LocalSet<V::LiveVar>>,\n+    pub outs: IndexVec<BasicBlock, LocalSet<V>>,\n }\n \n-pub(crate) trait LiveVariableMap {\n+/// Defines the mapping to/from the MIR local variables (`Local`) to\n+/// the \"live variable indices\" we are using in a particular\n+/// computation.\n+pub trait LiveVariableMap {\n     type LiveVar;\n \n     fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n     fn from_live_var(&self, local: Self::LiveVar) -> Local;\n+    fn num_variables(&self) -> usize;\n }\n \n-#[derive(Eq, PartialEq, Clone)]\n-struct IdentityMap;\n+#[derive(Debug)]\n+pub struct IdentityMap<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+}\n \n-impl LiveVariableMap for IdentityMap {\n+impl<'a, 'tcx> IdentityMap<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>) -> Self {\n+        Self { mir }\n+    }\n+}\n+\n+impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n     type LiveVar = Local;\n \n     fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n@@ -82,6 +99,10 @@ impl LiveVariableMap for IdentityMap {\n     fn from_live_var(&self, local: Self::LiveVar) -> Local {\n         local\n     }\n+\n+    fn num_variables(&self) -> usize {\n+        self.mir.local_decls.len()\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -103,7 +124,7 @@ pub struct LivenessMode {\n }\n \n /// A combination of liveness results, used in NLL.\n-pub struct LivenessResults<V> {\n+pub struct LivenessResults<V: Idx> {\n     /// Liveness results where a regular use makes a variable X live,\n     /// but not a drop.\n     pub regular: LivenessResult<V>,\n@@ -113,15 +134,19 @@ pub struct LivenessResults<V> {\n     pub drop: LivenessResult<V>,\n }\n \n-impl<V, M: LiveVariableMap<LiveVar = V>> LivenessResults<V> {\n-    pub fn compute<'tcx>(mir: &Mir<'tcx>, map: &M) -> LivenessResults<V> {\n+impl<V: Idx> LivenessResults<V> {\n+    pub fn compute<'tcx>(\n+        mir: &Mir<'tcx>,\n+        map: &impl LiveVariableMap<LiveVar = V>,\n+    ) -> LivenessResults<V> {\n         LivenessResults {\n             regular: liveness_of_locals(\n                 &mir,\n                 LivenessMode {\n                     include_regular_use: true,\n                     include_drops: false,\n                 },\n+                map,\n             ),\n \n             drop: liveness_of_locals(\n@@ -130,6 +155,7 @@ impl<V, M: LiveVariableMap<LiveVar = V>> LivenessResults<V> {\n                     include_regular_use: false,\n                     include_drops: true,\n                 },\n+                map,\n             ),\n         }\n     }\n@@ -138,14 +164,21 @@ impl<V, M: LiveVariableMap<LiveVar = V>> LivenessResults<V> {\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx, V>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult<V> {\n-    let locals = mir.local_decls.len();\n-    let def_use: IndexVec<_, _> = mir.basic_blocks()\n+pub fn liveness_of_locals<'tcx, V: Idx>(\n+    mir: &Mir<'tcx>,\n+    mode: LivenessMode,\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+) -> LivenessResult<V> {\n+    let locals = map.num_variables();\n+\n+    let def_use: IndexVec<_, DefsUses<V>> = mir\n+        .basic_blocks()\n         .iter()\n-        .map(|b| block(mode, b, locals))\n+        .map(|b| block(mode, map, b, locals))\n         .collect();\n \n-    let mut outs: IndexVec<_, _> = mir.basic_blocks()\n+    let mut outs: IndexVec<_, LocalSet<V>> = mir\n+        .basic_blocks()\n         .indices()\n         .map(|_| LocalSet::new_empty(locals))\n         .collect();\n@@ -179,14 +212,18 @@ pub fn liveness_of_locals<'tcx, V>(mir: &Mir<'tcx>, mode: LivenessMode) -> Liven\n     LivenessResult { mode, outs }\n }\n \n-impl<V: LiveVariableMap> LivenessResult<V>\n-{\n+impl<V: Idx> LivenessResult<V> {\n     /// Walks backwards through the statements/terminator in the given\n     /// basic block `block`.  At each point within `block`, invokes\n     /// the callback `op` with the current location and the set of\n     /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(&self, mir: &Mir<'tcx>, block: BasicBlock, mut callback: OP)\n-    where\n+    pub fn simulate_block<'tcx, OP>(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        block: BasicBlock,\n+        map: &impl LiveVariableMap<LiveVar = V>,\n+        mut callback: OP,\n+    ) where\n         OP: FnMut(Location, &LocalSet<V>),\n     {\n         let data = &mir[block];\n@@ -206,16 +243,20 @@ impl<V: LiveVariableMap> LivenessResult<V>\n         let locals = mir.local_decls.len();\n         let mut visitor = DefsUsesVisitor {\n             mode: self.mode,\n+            map,\n             defs_uses: DefsUses {\n                 defs: LocalSet::new_empty(locals),\n                 uses: LocalSet::new_empty(locals),\n-                map: &IdentityMap {},\n             },\n         };\n         // Visit the various parts of the basic block in reverse. If we go\n         // forward, the logic in `add_def` and `add_use` would be wrong.\n-        visitor.update_bits_and_do_callback(terminator_location, &data.terminator, &mut bits,\n-                                            &mut callback);\n+        visitor.update_bits_and_do_callback(\n+            terminator_location,\n+            &data.terminator,\n+            &mut bits,\n+            &mut callback,\n+        );\n \n         // Compute liveness before each statement (in rev order) and invoke callback.\n         for statement in data.statements.iter().rev() {\n@@ -225,8 +266,12 @@ impl<V: LiveVariableMap> LivenessResult<V>\n                 statement_index,\n             };\n             visitor.defs_uses.clear();\n-            visitor.update_bits_and_do_callback(statement_location, statement, &mut bits,\n-                                                &mut callback);\n+            visitor.update_bits_and_do_callback(\n+                statement_location,\n+                statement,\n+                &mut bits,\n+                &mut callback,\n+            );\n         }\n     }\n }\n@@ -306,30 +351,33 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n     }\n }\n \n-struct DefsUsesVisitor<'lv> {\n+struct DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V> + 'lv,\n+{\n     mode: LivenessMode,\n-    defs_uses: DefsUses<'lv>,\n+    map: &'lv M,\n+    defs_uses: DefsUses<V>,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses<'lv>\n-{\n-    defs: LocalSet<Local>,\n-    uses: LocalSet<Local>,\n-    map: &'lv dyn LiveVariableMap<LiveVar=Local>,\n+struct DefsUses<V: Idx> {\n+    defs: LocalSet<V>,\n+    uses: LocalSet<V>,\n }\n \n-impl<'lv> DefsUses<'lv> {\n+impl<V: Idx> DefsUses<V> {\n     fn clear(&mut self) {\n         self.uses.clear();\n         self.defs.clear();\n     }\n \n-    fn apply(&self, bits: &mut LocalSet<Local>) -> bool {\n+    fn apply(&self, bits: &mut LocalSet<V>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n-    fn add_def(&mut self, index: Local) {\n+    fn add_def(&mut self, index: V) {\n         // If it was used already in the block, remove that use\n         // now that we found a definition.\n         //\n@@ -339,13 +387,11 @@ impl<'lv> DefsUses<'lv> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        if let Some(v_index) = self.map.from_local(index) {\n-            self.uses.remove(&v_index);\n-            self.defs.add(&v_index);\n-        }\n+        self.uses.remove(&index);\n+        self.defs.add(&index);\n     }\n \n-    fn add_use(&mut self, index: Local) {\n+    fn add_use(&mut self, index: V) {\n         // Inverse of above.\n         //\n         // Example:\n@@ -356,53 +402,62 @@ impl<'lv> DefsUses<'lv> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        if let Some(v_index) = self.map.from_local(index) {\n-            self.defs.remove(&v_index);\n-            self.uses.add(&v_index);\n-        }\n+        self.defs.remove(&index);\n+        self.uses.add(&index);\n     }\n }\n \n-impl<'lv> DefsUsesVisitor<'lv>\n+impl<'lv, V, M> DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V>,\n {\n     /// Update `bits` with the effects of `value` and call `callback`. We\n     /// should always visit in reverse order. This method assumes that we have\n     /// not visited anything before; if you have, clear `bits` first.\n-    fn update_bits_and_do_callback<'tcx, OP>(&mut self, location: Location,\n-                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet<Local>,\n-                                             callback: &mut OP)\n-    where\n-        OP: FnMut(Location, &LocalSet<Local>),\n+    fn update_bits_and_do_callback<'tcx, OP>(\n+        &mut self,\n+        location: Location,\n+        value: &impl MirVisitable<'tcx>,\n+        bits: &mut LocalSet<V>,\n+        callback: &mut OP,\n+    ) where\n+        OP: FnMut(Location, &LocalSet<V>),\n     {\n         value.apply(location, self);\n         self.defs_uses.apply(bits);\n         callback(location, bits);\n     }\n }\n \n-impl<'tcx, 'lv> Visitor<'tcx> for DefsUsesVisitor<'lv> {\n+impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n+where\n+    V: Idx,\n+    M: LiveVariableMap<LiveVar = V>,\n+{\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        match categorize(context, self.mode) {\n-            Some(DefUse::Def) => {\n-                self.defs_uses.add_def(local);\n+        if let Some(v_index) = self.map.from_local(local) {\n+            match categorize(context, self.mode) {\n+                Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n+                Some(DefUse::Use) => self.defs_uses.add_use(v_index),\n+                None => (),\n             }\n-\n-            Some(DefUse::Use) => {\n-                self.defs_uses.add_use(local);\n-            }\n-\n-            None => {}\n         }\n     }\n }\n \n-fn block<'tcx, 'lv>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses<'lv> {\n+fn block<'tcx, V: Idx>(\n+    mode: LivenessMode,\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+    b: &BasicBlockData<'tcx>,\n+    locals: usize,\n+) -> DefsUses<V> {\n     let mut visitor = DefsUsesVisitor {\n         mode,\n+        map,\n         defs_uses: DefsUses {\n             defs: LocalSet::new_empty(locals),\n             uses: LocalSet::new_empty(locals),\n-            map: &IdentityMap {},\n         },\n     };\n \n@@ -421,13 +476,13 @@ fn block<'tcx, 'lv>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize)\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx, V: LiveVariableMap>(\n+pub fn dump_mir<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult<Local>,\n-    map: &impl LiveVariableMap<LiveVar = V>\n+    map: &impl LiveVariableMap<LiveVar = V>,\n+    result: &LivenessResult<V>,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -436,16 +491,17 @@ pub fn dump_mir<'a, 'tcx, V: LiveVariableMap>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, map, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx, V: LiveVariableMap>(\n+fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult<V::LiveVar>,\n+    map: &dyn LiveVariableMap<LiveVar = V>,\n+    result: &LivenessResult<V>,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -457,25 +513,25 @@ fn dump_matched_mir_node<'a, 'tcx, V: LiveVariableMap>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file, result)?;\n+        write_mir_fn(tcx, source, mir, map, &mut file, result)?;\n         Ok(())\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx, V: LiveVariableMap>(\n+pub fn write_mir_fn<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir<'tcx>,\n+    map: &dyn LiveVariableMap<LiveVar = V>,\n     w: &mut dyn Write,\n-    result: &LivenessResult<V::LiveVar>,\n+    result: &LivenessResult<V>,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet<Local>>| {\n-            let live: Vec<String> = mir.local_decls\n-                .indices()\n-                .filter(|i| result[block].contains(i))\n-                .map(|i| format!(\"{:?}\", i))\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet<V>>| {\n+            let live: Vec<String> = result[block].iter()\n+                .map(|v| map.from_live_var(v))\n+                .map(|local| format!(\"{:?}\", local))\n                 .collect();\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };"}]}