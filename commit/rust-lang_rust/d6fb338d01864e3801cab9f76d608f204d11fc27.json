{"sha": "d6fb338d01864e3801cab9f76d608f204d11fc27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZmIzMzhkMDE4NjRlMzgwMWNhYjlmNzZkNjA4ZjIwNGQxMWZjMjc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-05-17T23:38:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T00:39:36Z"}, "message": "syntax: ast_map: use borrowed references into the AST.", "tree": {"sha": "ce75b8e4f34abac7402e6dd2668375dc687dbff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce75b8e4f34abac7402e6dd2668375dc687dbff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6fb338d01864e3801cab9f76d608f204d11fc27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fb338d01864e3801cab9f76d608f204d11fc27", "html_url": "https://github.com/rust-lang/rust/commit/d6fb338d01864e3801cab9f76d608f204d11fc27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6fb338d01864e3801cab9f76d608f204d11fc27/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "html_url": "https://github.com/rust-lang/rust/commit/9259b022f8ec05072993fd5e3e9f2eba3afc0c95"}], "stats": {"total": 636, "additions": 367, "deletions": 269}, "files": [{"sha": "c0fd04401bcdaad97984405cdf1ce214ffa81dfb", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -70,7 +70,7 @@ DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n-DEPS_syntax := std term serialize log fmt_macros debug\n+DEPS_syntax := std term serialize log fmt_macros debug arena\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               time log graphviz debug rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std"}, {"sha": "5546f868ba08d4ccb3f1fbedc7bf1aa8c299199e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -1308,16 +1308,11 @@ pub enum UnboxedClosureKind {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n     IIItem(P<Item>),\n-    IITraitItem(DefId /* impl id */, InlinedTraitItem),\n+    IITraitItem(DefId /* impl id */, TraitItem),\n+    IIImplItem(DefId /* impl id */, ImplItem),\n     IIForeign(P<ForeignItem>),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum InlinedTraitItem {\n-    ProvidedInlinedTraitItem(P<Method>),\n-    RequiredInlinedTraitItem(P<Method>),\n-}\n-\n #[cfg(test)]\n mod test {\n     use serialize::json;"}, {"sha": "20594a428481ec0a21d7f3bb29f69835ab1d4685", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 343, "deletions": 251, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -11,18 +11,19 @@\n use abi;\n use ast::*;\n use ast_util;\n-use codemap::{Span, Spanned};\n+use ast_util::PostExpansionMethod;\n+use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n-use fold;\n use parse::token;\n use print::pprust;\n-use util::small_vector::SmallVector;\n+use visit::{mod, Visitor};\n \n+use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n-use std::gc::{Gc, GC};\n use std::io::IoResult;\n use std::iter;\n+use std::mem;\n use std::slice;\n \n pub mod blocks;\n@@ -95,62 +96,85 @@ pub fn path_to_string<PI: Iterator<PathElem>>(mut path: PI) -> String {\n     }).to_string()\n }\n \n-#[deriving(Clone)]\n-pub enum Node {\n-    NodeItem(Gc<Item>),\n-    NodeForeignItem(Gc<ForeignItem>),\n-    NodeTraitItem(Gc<TraitItem>),\n-    NodeImplItem(Gc<ImplItem>),\n-    NodeVariant(P<Variant>),\n-    NodeExpr(Gc<Expr>),\n-    NodeStmt(Gc<Stmt>),\n-    NodeArg(Gc<Pat>),\n-    NodeLocal(Gc<Pat>),\n-    NodePat(Gc<Pat>),\n-    NodeBlock(P<Block>),\n+pub enum Node<'ast> {\n+    NodeItem(&'ast Item),\n+    NodeForeignItem(&'ast ForeignItem),\n+    NodeTraitItem(&'ast TraitItem),\n+    NodeImplItem(&'ast ImplItem),\n+    NodeVariant(&'ast Variant),\n+    NodeExpr(&'ast Expr),\n+    NodeStmt(&'ast Stmt),\n+    NodeArg(&'ast Pat),\n+    NodeLocal(&'ast Pat),\n+    NodePat(&'ast Pat),\n+    NodeBlock(&'ast Block),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(Gc<StructDef>),\n+    NodeStructCtor(&'ast StructDef),\n \n-    NodeLifetime(Gc<Lifetime>),\n+    NodeLifetime(&'ast Lifetime),\n }\n \n /// Represents an entry and its parent Node ID\n /// The odd layout is to bring down the total size.\n-#[deriving(Clone)]\n-enum MapEntry {\n+#[deriving(Show)]\n+enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, Gc<Item>),\n-    EntryForeignItem(NodeId, Gc<ForeignItem>),\n-    EntryTraitItem(NodeId, Gc<TraitItem>),\n-    EntryImplItem(NodeId, Gc<ImplItem>),\n-    EntryVariant(NodeId, P<Variant>),\n-    EntryExpr(NodeId, Gc<Expr>),\n-    EntryStmt(NodeId, Gc<Stmt>),\n-    EntryArg(NodeId, Gc<Pat>),\n-    EntryLocal(NodeId, Gc<Pat>),\n-    EntryPat(NodeId, Gc<Pat>),\n-    EntryBlock(NodeId, P<Block>),\n-    EntryStructCtor(NodeId, Gc<StructDef>),\n-    EntryLifetime(NodeId, Gc<Lifetime>),\n+    EntryItem(NodeId, &'ast Item),\n+    EntryForeignItem(NodeId, &'ast ForeignItem),\n+    EntryTraitItem(NodeId, &'ast TraitItem),\n+    EntryImplItem(NodeId, &'ast ImplItem),\n+    EntryVariant(NodeId, &'ast Variant),\n+    EntryExpr(NodeId, &'ast Expr),\n+    EntryStmt(NodeId, &'ast Stmt),\n+    EntryArg(NodeId, &'ast Pat),\n+    EntryLocal(NodeId, &'ast Pat),\n+    EntryPat(NodeId, &'ast Pat),\n+    EntryBlock(NodeId, &'ast Block),\n+    EntryStructCtor(NodeId, &'ast StructDef),\n+    EntryLifetime(NodeId, &'ast Lifetime),\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(P<InlinedParent>)\n+    RootInlinedParent(&'ast InlinedParent)\n+}\n+\n+impl<'ast> Clone for MapEntry<'ast> {\n+    fn clone(&self) -> MapEntry<'ast> {\n+        *self\n+    }\n }\n \n+#[deriving(Show)]\n struct InlinedParent {\n-    path: Vec<PathElem> ,\n-    /// RequiredMethod by NodeTraitItem and NodeImplItem.\n-    def_id: DefId\n+    path: Vec<PathElem>,\n+    ii: InlinedItem\n }\n \n-impl MapEntry {\n-    fn parent(&self) -> Option<NodeId> {\n-        Some(match *self {\n+impl<'ast> MapEntry<'ast> {\n+    fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n+        match node {\n+            NodeItem(n) => EntryItem(p, n),\n+            NodeForeignItem(n) => EntryForeignItem(p, n),\n+            NodeTraitItem(n) => EntryTraitItem(p, n),\n+            NodeImplItem(n) => EntryImplItem(p, n),\n+            NodeVariant(n) => EntryVariant(p, n),\n+            NodeExpr(n) => EntryExpr(p, n),\n+            NodeStmt(n) => EntryStmt(p, n),\n+            NodeArg(n) => EntryArg(p, n),\n+            NodeLocal(n) => EntryLocal(p, n),\n+            NodePat(n) => EntryPat(p, n),\n+            NodeBlock(n) => EntryBlock(p, n),\n+            NodeStructCtor(n) => EntryStructCtor(p, n),\n+            NodeLifetime(n) => EntryLifetime(p, n)\n+        }\n+    }\n+\n+    fn parent(self) -> Option<NodeId> {\n+        Some(match self {\n             EntryItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n             EntryTraitItem(id, _) => id,\n@@ -168,29 +192,51 @@ impl MapEntry {\n         })\n     }\n \n-    fn to_node(&self) -> Option<Node> {\n-        Some(match *self {\n-            EntryItem(_, p) => NodeItem(p),\n-            EntryForeignItem(_, p) => NodeForeignItem(p),\n-            EntryTraitItem(_, p) => NodeTraitItem(p),\n-            EntryImplItem(_, p) => NodeImplItem(p),\n-            EntryVariant(_, p) => NodeVariant(p),\n-            EntryExpr(_, p) => NodeExpr(p),\n-            EntryStmt(_, p) => NodeStmt(p),\n-            EntryArg(_, p) => NodeArg(p),\n-            EntryLocal(_, p) => NodeLocal(p),\n-            EntryPat(_, p) => NodePat(p),\n-            EntryBlock(_, p) => NodeBlock(p),\n-            EntryStructCtor(_, p) => NodeStructCtor(p),\n-            EntryLifetime(_, p) => NodeLifetime(p),\n+    fn to_node(self) -> Option<Node<'ast>> {\n+        Some(match self {\n+            EntryItem(_, n) => NodeItem(n),\n+            EntryForeignItem(_, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, n) => NodeTraitItem(n),\n+            EntryImplItem(_, n) => NodeImplItem(n),\n+            EntryVariant(_, n) => NodeVariant(n),\n+            EntryExpr(_, n) => NodeExpr(n),\n+            EntryStmt(_, n) => NodeStmt(n),\n+            EntryArg(_, n) => NodeArg(n),\n+            EntryLocal(_, n) => NodeLocal(n),\n+            EntryPat(_, n) => NodePat(n),\n+            EntryBlock(_, n) => NodeBlock(n),\n+            EntryStructCtor(_, n) => NodeStructCtor(n),\n+            EntryLifetime(_, n) => NodeLifetime(n),\n             _ => return None\n         })\n     }\n }\n \n+/// Stores a crate and any number of inlined items from other crates.\n+pub struct Forest {\n+    krate: Crate,\n+    inlined_items: TypedArena<InlinedParent>\n+}\n+\n+impl Forest {\n+    pub fn new(krate: Crate) -> Forest {\n+        Forest {\n+            krate: krate,\n+            inlined_items: TypedArena::new()\n+        }\n+    }\n+\n+    pub fn krate<'ast>(&'ast self) -> &'ast Crate {\n+        &self.krate\n+    }\n+}\n+\n /// Represents a mapping from Node IDs to AST elements and their parent\n /// Node IDs\n-pub struct Map {\n+pub struct Map<'ast> {\n+    /// The backing storage for all the AST nodes.\n+    forest: &'ast Forest,\n+\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n     /// a NodeId is in the map, but empirically the occupancy is about\n@@ -200,26 +246,25 @@ pub struct Map {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry> >\n+    map: RefCell<Vec<MapEntry<'ast>>>\n }\n \n-impl Map {\n+impl<'ast> Map<'ast> {\n     fn entry_count(&self) -> uint {\n         self.map.borrow().len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n-        let map = self.map.borrow();\n-        if map.len() > id as uint {\n-            Some(*map.get(id as uint))\n-        } else {\n-            None\n-        }\n+    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n+        self.map.borrow().as_slice().get(id as uint).map(|e| *e)\n+    }\n+\n+    pub fn krate(&self) -> &'ast Crate {\n+        &self.forest.krate\n     }\n \n     /// Retrieve the Node corresponding to `id`, failing if it cannot\n     /// be found.\n-    pub fn get(&self, id: NodeId) -> Node {\n+    pub fn get(&self, id: NodeId) -> Node<'ast> {\n         match self.find(id) {\n             Some(node) => node,\n             None => fail!(\"couldn't find node id {} in the AST map\", id)\n@@ -228,7 +273,7 @@ impl Map {\n \n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<Node> {\n+    pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n@@ -241,18 +286,21 @@ impl Map {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(data)) => data.def_id,\n+            Some(RootInlinedParent(&InlinedParent {ii: IITraitItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: IIImplItem(did, _), ..})) => did,\n             _ => ast_util::local_def(parent)\n         }\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => match i.node {\n-                ItemForeignMod(ref nm) => Some(nm.abi),\n-                _ => None\n-            },\n+            Some(EntryItem(_, i)) => {\n+                match i.node {\n+                    ItemForeignMod(ref nm) => Some(nm.abi),\n+                    _ => None\n+                }\n+            }\n             /// Wrong but OK, because the only inlined foreign items are intrinsics.\n             Some(RootInlinedParent(_)) => Some(abi::RustIntrinsic),\n             _ => None\n@@ -272,45 +320,52 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_item(&self, id: NodeId) -> Gc<Item> {\n+    pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n             _ => fail!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> Gc<StructDef> {\n+    pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(struct_def, _) => struct_def,\n+                    ItemStruct(ref struct_def, _) => &**struct_def,\n                     _ => fail!(\"struct ID bound to non-struct\")\n                 }\n             }\n-            Some(NodeVariant(ref variant)) => {\n-                match (*variant).node.kind {\n-                    StructVariantKind(struct_def) => struct_def,\n+            Some(NodeVariant(variant)) => {\n+                match variant.node.kind {\n+                    StructVariantKind(ref struct_def) => &**struct_def,\n                     _ => fail!(\"struct ID bound to enum variant that isn't struct-like\"),\n                 }\n             }\n             _ => fail!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n         }\n     }\n \n-    pub fn expect_variant(&self, id: NodeId) -> P<Variant> {\n+    pub fn expect_variant(&self, id: NodeId) -> &'ast Variant {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n             _ => fail!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> Gc<ForeignItem> {\n+    pub fn expect_foreign_item(&self, id: NodeId) -> &'ast ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n             _ => fail!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n+    pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n+        match self.find(id) {\n+            Some(NodeExpr(expr)) => expr,\n+            _ => fail!(\"expected expr, found {}\", self.node_to_string(id))\n+        }\n+    }\n+\n     /// returns the name associated with the given NodeId's AST\n     pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n         let node = self.get(id);\n@@ -340,7 +395,7 @@ impl Map {\n             },\n             NodeTraitItem(tm) => match *tm {\n                 RequiredMethod(ref m) => PathName(m.ident.name),\n-                ProvidedMethod(m) => match m.node {\n+                ProvidedMethod(ref m) => match m.node {\n                     MethDecl(ident, _, _, _, _, _, _, _) => {\n                         PathName(ident.name)\n                     }\n@@ -399,10 +454,9 @@ impl Map {\n     /// Given a node ID and a closure, apply the closure to the array\n     /// of attributes associated with the AST corresponding to the Node ID\n     pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n-        let node = self.get(id);\n-        let attrs = match node {\n-            NodeItem(ref i) => Some(i.attrs.as_slice()),\n-            NodeForeignItem(ref fi) => Some(fi.attrs.as_slice()),\n+        let attrs = match self.get(id) {\n+            NodeItem(i) => Some(i.attrs.as_slice()),\n+            NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n             NodeTraitItem(ref tm) => match **tm {\n                 RequiredMethod(ref type_m) => Some(type_m.attrs.as_slice()),\n                 ProvidedMethod(ref m) => Some(m.attrs.as_slice())\n@@ -432,7 +486,7 @@ impl Map {\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n     pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S])\n-                                 -> NodesMatchingSuffix<'a,S> {\n+                                 -> NodesMatchingSuffix<'a, 'ast, S> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n@@ -478,14 +532,14 @@ impl Map {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, S:'a> {\n-    map: &'a Map,\n+pub struct NodesMatchingSuffix<'a, 'ast:'a, S:'a> {\n+    map: &'a Map<'ast>,\n     item_name: &'a S,\n     in_which: &'a [S],\n     idx: NodeId,\n }\n \n-impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n+impl<'a, 'ast, S:Str> NodesMatchingSuffix<'a, 'ast, S> {\n     /// Returns true only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n@@ -542,7 +596,7 @@ impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n     }\n }\n \n-impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n+impl<'a, 'ast, S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a, 'ast, S> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n@@ -551,11 +605,11 @@ impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n             }\n             self.idx += 1;\n             let (p, name) = match self.map.find_entry(idx) {\n-                Some(EntryItem(p, n))        => (p, n.name()),\n-                Some(EntryForeignItem(p, n)) => (p, n.name()),\n-                Some(EntryTraitItem(p, n))   => (p, n.name()),\n-                Some(EntryImplItem(p, n))    => (p, n.name()),\n-                Some(EntryVariant(p, n))     => (p, n.name()),\n+                Some(EntryItem(p, n))       => (p, n.name()),\n+                Some(EntryForeignItem(p, n))=> (p, n.name()),\n+                Some(EntryTraitItem(p, n))  => (p, n.name()),\n+                Some(EntryImplItem(p, n))   => (p, n.name()),\n+                Some(EntryVariant(p, n))    => (p, n.name()),\n                 _ => continue,\n             };\n             if self.matches_names(p, name) {\n@@ -578,7 +632,7 @@ impl Named for TraitItem {\n     fn name(&self) -> Name {\n         match *self {\n             RequiredMethod(ref tm) => tm.ident.name,\n-            ProvidedMethod(m) => m.name(),\n+            ProvidedMethod(ref m) => m.name(),\n         }\n     }\n }\n@@ -602,257 +656,292 @@ pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n         id\n     }\n+    fn new_def_id(&self, def_id: DefId) -> DefId {\n+        def_id\n+    }\n     fn new_span(&self, span: Span) -> Span {\n         span\n     }\n }\n \n-/// A Folder that walks over an AST and constructs a Node ID Map. Its\n-/// fold_ops argument has the opportunity to replace Node IDs and spans.\n-pub struct Ctx<'a, F> {\n-    map: &'a Map,\n-    /// The node in which we are currently mapping (an item or a method).\n-    /// When equal to DUMMY_NODE_ID, the next mapped node becomes the parent.\n-    parent: NodeId,\n+/// A Folder that updates IDs and Span's according to fold_ops.\n+struct IdAndSpanUpdater<F> {\n     fold_ops: F\n }\n \n-impl<'a, F> Ctx<'a, F> {\n-    fn insert(&self, id: NodeId, entry: MapEntry) {\n-        (*self.map.map.borrow_mut()).grow_set(id as uint, &NotPresent, entry);\n-    }\n-}\n-\n-impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n+impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-        if self.parent == DUMMY_NODE_ID {\n-            self.parent = id;\n-        }\n-        id\n+        self.fold_ops.new_id(id)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n         self.fold_ops.new_span(span)\n     }\n+}\n \n-    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n-        let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n+/// A Visitor that walks over an AST and collects Node's into an AST Map.\n+struct NodeCollector<'ast> {\n+    map: Vec<MapEntry<'ast>>,\n+    /// The node in which we are currently mapping (an item or a method).\n+    parent: NodeId\n+}\n \n-        let i = fold::noop_fold_item(&*i, self).expect_one(\"expected one item\");\n-        assert_eq!(self.parent, i.id);\n+impl<'ast> NodeCollector<'ast> {\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n+        self.map.grow_set(id as uint, &NotPresent, entry);\n+        debug!(\"ast_map: {} => {}\", id, entry);\n+    }\n+\n+    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+        let entry = MapEntry::from_node(self.parent, node);\n+        self.insert_entry(id, entry);\n+    }\n+\n+    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n+        for a in decl.inputs.iter() {\n+            self.insert(a.id, NodeArg(&*a.pat));\n+        }\n+    }\n+}\n \n+impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        self.insert(i.id, NodeItem(i));\n+        let parent = self.parent;\n+        self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n-                    match *impl_item {\n-                        MethodImplItem(m) => {\n-                            self.insert(m.id,\n-                                        EntryImplItem(self.parent,\n-                                                      box(GC) *impl_item));\n-                        }\n-                    }\n+                    let id = match *impl_item {\n+                        MethodImplItem(ref m) => m.id\n+                    };\n+                    self.insert(id, NodeImplItem(impl_item));\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                for &v in enum_definition.variants.iter() {\n-                    self.insert(v.node.id, EntryVariant(self.parent, v));\n+                for v in enum_definition.variants.iter() {\n+                    self.insert(v.node.id, NodeVariant(&**v));\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n                 for nitem in nm.items.iter() {\n-                    self.insert(nitem.id, EntryForeignItem(self.parent,\n-                                                           nitem.clone()));\n+                    self.insert(nitem.id, NodeForeignItem(&**nitem));\n                 }\n             }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n                     Some(ctor_id) => {\n-                        self.insert(ctor_id, EntryStructCtor(self.parent,\n-                                                             struct_def.clone()));\n+                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n                     }\n                     None => {}\n                 }\n             }\n             ItemTrait(_, _, _, ref methods) => {\n                 for tm in methods.iter() {\n-                    match *tm {\n-                        RequiredMethod(ref m) => {\n-                            self.insert(m.id, EntryTraitItem(self.parent,\n-                                                               box(GC) (*tm).clone()));\n-                        }\n-                        ProvidedMethod(m) => {\n-                            self.insert(m.id, EntryTraitItem(self.parent,\n-                                                               box(GC) ProvidedMethod(m)));\n-                        }\n-                    }\n+                    let id = match *tm {\n+                        RequiredMethod(ref m) => m.id,\n+                        ProvidedMethod(ref m) => m.id\n+                    };\n+                    self.insert(id, NodeTraitItem(tm));\n                 }\n             }\n             _ => {}\n         }\n-\n+        visit::walk_item(self, i);\n         self.parent = parent;\n-        self.insert(i.id, EntryItem(self.parent, i));\n-\n-        SmallVector::one(i)\n     }\n \n-    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n-        let pat = fold::noop_fold_pat(pat, self);\n-        match pat.node {\n-            PatIdent(..) => {\n-                // Note: this is at least *potentially* a pattern...\n-                self.insert(pat.id, EntryLocal(self.parent, pat));\n-            }\n-            _ => {\n-                self.insert(pat.id, EntryPat(self.parent, pat));\n-            }\n-        }\n-\n-        pat\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        self.insert(pat.id, match pat.node {\n+            // Note: this is at least *potentially* a pattern...\n+            PatIdent(..) => NodeLocal(pat),\n+            _ => NodePat(pat)\n+        });\n+        visit::walk_pat(self, pat);\n     }\n \n-    fn fold_expr(&mut self, expr: Gc<Expr>) -> Gc<Expr> {\n-        let expr = fold::noop_fold_expr(expr, self);\n-\n-        self.insert(expr.id, EntryExpr(self.parent, expr));\n-\n-        expr\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.insert(expr.id, NodeExpr(expr));\n+        visit::walk_expr(self, expr);\n     }\n \n-    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {\n-        let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));\n-        SmallVector::one(stmt)\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        visit::walk_stmt(self, stmt);\n     }\n \n-    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+    fn visit_ty_method(&mut self, m: &'ast TypeMethod) {\n         let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_type_method(m, self);\n-        assert_eq!(self.parent, m.id);\n+        self.parent = m.id;\n+        self.visit_fn_decl(&*m.decl);\n+        visit::walk_ty_method(self, m);\n         self.parent = parent;\n-        m\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>> {\n-        let parent = self.parent;\n-        self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(&*m, self).expect_one(\n-            \"noop_fold_method must produce exactly one method\");\n-        assert_eq!(self.parent, m.id);\n-        self.parent = parent;\n-        SmallVector::one(m)\n+    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        match fk {\n+            visit::FkMethod(..) => {\n+                let parent = self.parent;\n+                self.parent = id;\n+                self.visit_fn_decl(fd);\n+                visit::walk_fn(self, fk, fd, b, s);\n+                self.parent = parent;\n+            }\n+            _ => {\n+                self.visit_fn_decl(fd);\n+                visit::walk_fn(self, fk, fd, b, s);\n+            }\n+        }\n     }\n \n-    fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {\n-        let decl = fold::noop_fold_fn_decl(decl, self);\n-        for a in decl.inputs.iter() {\n-            self.insert(a.id, EntryArg(self.parent, a.pat));\n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        match ty.node {\n+            TyClosure(ref fd) | TyProc(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            TyBareFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            TyUnboxedFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            _ => {}\n         }\n-        decl\n+        visit::walk_ty(self, ty);\n     }\n \n-    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let block = fold::noop_fold_block(block, self);\n-        self.insert(block.id, EntryBlock(self.parent, block));\n-        block\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.insert(block.id, NodeBlock(block));\n+        visit::walk_block(self, block);\n     }\n \n-    fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n-        let lifetime = fold::noop_fold_lifetime(lifetime, self);\n-        self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n-        lifetime\n+    fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n+        self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n-    fn fold_mac(&mut self, mac: &Mac) -> Mac {\n-        fold::noop_fold_mac(mac, self)\n+    fn visit_lifetime_decl(&mut self, def: &'ast LifetimeDef) {\n+        self.visit_lifetime_ref(&def.lifetime);\n     }\n }\n \n-pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n-    let map = Map { map: RefCell::new(Vec::new()) };\n-    let krate = {\n-        let mut cx = Ctx {\n-            map: &map,\n-            parent: CRATE_NODE_ID,\n-            fold_ops: fold_ops\n-        };\n-        cx.insert(CRATE_NODE_ID, RootCrate);\n-        cx.fold_crate(krate)\n+pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map<'ast> {\n+    // Replace the crate with an empty one to take it out.\n+    let krate = mem::replace(&mut forest.krate, Crate {\n+        module: Mod {\n+            inner: DUMMY_SP,\n+            view_items: vec![],\n+            items: vec![],\n+        },\n+        attrs: vec![],\n+        config: vec![],\n+        exported_macros: vec![],\n+        span: DUMMY_SP\n+    });\n+    forest.krate = IdAndSpanUpdater { fold_ops: fold_ops }.fold_crate(krate);\n+\n+    let mut collector = NodeCollector {\n+        map: vec![],\n+        parent: CRATE_NODE_ID\n     };\n+    collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+    visit::walk_crate(&mut collector, &forest.krate);\n+    let map = collector.map;\n \n     if log_enabled!(::log::DEBUG) {\n-        let map = map.map.borrow();\n         // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, _) = (*map).iter().filter(|&x| {\n+        let (entries_less_1, _) = map.iter().filter(|&x| {\n             match *x {\n                 NotPresent => false,\n                 _ => true\n             }\n         }).enumerate().last().expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n-        let vector_length = (*map).len();\n+        let vector_length = map.len();\n         debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    (krate, map)\n+    Map {\n+        forest: forest,\n+        map: RefCell::new(map)\n+    }\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.  The `path` should be the path to the item but should not include\n /// the item itself.\n-pub fn map_decoded_item<F: FoldOps>(map: &Map,\n-                                    path: Vec<PathElem> ,\n-                                    fold_ops: F,\n-                                    fold: |&mut Ctx<F>| -> InlinedItem)\n-                                    -> InlinedItem {\n-    let mut cx = Ctx {\n-        map: map,\n-        parent: DUMMY_NODE_ID,\n-        fold_ops: fold_ops\n+pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n+                                          path: Vec<PathElem>,\n+                                          ii: InlinedItem,\n+                                          fold_ops: F)\n+                                          -> &'ast InlinedItem {\n+    let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n+    let ii = match ii {\n+        IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n+        IITraitItem(d, ti) => match ti {\n+            ProvidedMethod(m) => {\n+                IITraitItem(fld.fold_ops.new_def_id(d),\n+                            ProvidedMethod(fld.fold_method(m)\n+                                              .expect_one(\"expected one method\")))\n+            }\n+            RequiredMethod(ty_m) => {\n+                IITraitItem(fld.fold_ops.new_def_id(d),\n+                            RequiredMethod(fld.fold_type_method(ty_m)))\n+            }\n+        },\n+        IIImplItem(d, m) => match m {\n+            MethodImplItem(m) => {\n+                IIImplItem(fld.fold_ops.new_def_id(d),\n+                           MethodImplItem(fld.fold_method(m)\n+                                             .expect_one(\"expected one method\")))\n+            }\n+        },\n+        IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n     };\n \n-    // Generate a NodeId for the RootInlinedParent inserted below.\n-    cx.new_id(DUMMY_NODE_ID);\n+    let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n+        path: path,\n+        ii: ii\n+    });\n+\n+    let mut collector = NodeCollector {\n+        map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n+        parent: fld.new_id(DUMMY_NODE_ID)\n+    };\n+    let ii_parent_id = collector.parent;\n+    collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n+    visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n \n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n-    let mut def_id = DefId { krate: LOCAL_CRATE, node: DUMMY_NODE_ID };\n-    let ii = fold(&mut cx);\n-    match ii {\n+    match ii_parent.ii {\n         IIItem(_) => {}\n-        IITraitItem(impl_did, inlined_trait_item) => {\n-            let (trait_item_id, entry) = match inlined_trait_item {\n-                ProvidedInlinedTraitItem(m) => {\n-                    (m.id,\n-                     EntryTraitItem(cx.parent, box(GC) ProvidedMethod(m)))\n-                }\n-                RequiredInlinedTraitItem(m) => {\n-                    (m.id,\n-                     EntryImplItem(cx.parent, box(GC) MethodImplItem(m)))\n-                }\n+        IITraitItem(_, ref trait_item) => {\n+            let trait_item_id = match *trait_item {\n+                ProvidedMethod(ref m) => m.id,\n+                RequiredMethod(ref m) => m.id\n             };\n-            cx.insert(trait_item_id, entry);\n-            def_id = impl_did;\n+\n+            collector.insert(trait_item_id, NodeTraitItem(trait_item));\n         }\n-        IIForeign(i) => {\n-            cx.insert(i.id, EntryForeignItem(cx.parent, i));\n+        IIImplItem(_, ref impl_item) => {\n+            let impl_item_id = match *impl_item {\n+                MethodImplItem(ref m) => m.id\n+            };\n+\n+            collector.insert(impl_item_id, NodeImplItem(impl_item));\n+        }\n+        IIForeign(ref i) => {\n+            collector.insert(i.id, NodeForeignItem(&**i));\n         }\n     }\n-\n-    cx.insert(cx.parent, RootInlinedParent(P(InlinedParent {\n-        path: path,\n-        def_id: def_id\n-    })));\n-\n-    ii\n+    *map.map.borrow_mut() = collector.map;\n+    &ii_parent.ii\n }\n \n pub trait NodePrinter {\n@@ -920,10 +1009,13 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                 }\n             }\n         }\n-        Some(NodeTraitItem(ref tm)) => {\n-            let m = ast_util::trait_item_to_ty_method(&**tm);\n+        Some(NodeTraitItem(ref ti)) => {\n+            let ident = match **ti {\n+                ProvidedMethod(ref m) => m.pe_ident(),\n+                RequiredMethod(ref m) => m.ident\n+            };\n             format!(\"method {} in {} (id={})\",\n-                    token::get_ident(m.ident),\n+                    token::get_ident(ident),\n                     map.path_to_string(id), id)\n         }\n         Some(NodeVariant(ref variant)) => {"}, {"sha": "2a76bbf4e3b3ec72ed4b0d00fd92bc6b4a1754c9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -538,6 +538,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n         visit::walk_trait_item(self, tm);\n     }\n+\n+    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+        self.operation.visit_id(lifetime.id);\n+    }\n+\n+    fn visit_lifetime_decl(&mut self, def: &'v LifetimeDef) {\n+        self.visit_lifetime_ref(&def.lifetime);\n+    }\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,"}, {"sha": "e86ce6e868cddea98a8833fbb79185b43bb77958", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -469,7 +469,7 @@ pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, source, span}| Local {\n-        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        id: fld.new_id(id),\n         ty: fld.fold_ty(ty),\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n@@ -495,10 +495,12 @@ pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mu\n                                                      -> ExplicitSelf_ {\n     match es {\n         SelfStatic | SelfValue(_) => es,\n-        SelfRegion(lifetime, m, id) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, id)\n+        SelfRegion(lifetime, m, ident) => {\n+            SelfRegion(fld.fold_opt_lifetime(lifetime), m, ident)\n+        }\n+        SelfExplicit(typ, ident) => {\n+            SelfExplicit(fld.fold_ty(typ), ident)\n         }\n-        SelfExplicit(typ, id) => SelfExplicit(fld.fold_ty(typ), id),\n     }\n }\n \n@@ -537,7 +539,7 @@ pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaIte\n \n pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n     Arg {\n-        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        id: fld.new_id(id),\n         pat: fld.fold_pat(pat),\n         ty: fld.fold_ty(ty)\n     }\n@@ -808,7 +810,7 @@ pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewIte\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n-        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        id: folder.new_id(id),\n         view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         stmts: stmts.move_iter().flat_map(|s| folder.fold_stmt(s).move_iter()).collect(),\n         expr: expr.map(|x| folder.fold_expr(x)),\n@@ -886,7 +888,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n     let TypeMethod {id, ident, attrs, fn_style, abi, decl, generics, explicit_self, vis, span} = m;\n     TypeMethod {\n-        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        id: fld.new_id(id),\n         ident: fld.fold_ident(ident),\n         attrs: attrs.move_map(|a| fld.fold_attribute(a)),\n         fn_style: fn_style,\n@@ -926,7 +928,7 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n // fold one item into exactly one item\n pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n-    let id = folder.new_id(id); // Needs to be first, for ast_map.\n+    let id = folder.new_id(id);\n     let node = folder.fold_item_underscore(node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n@@ -948,7 +950,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n     ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n-        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        id: folder.new_id(id),\n         ident: folder.fold_ident(ident),\n         attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n         node: match node {\n@@ -973,7 +975,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n // Invariant: produces exactly one method.\n pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n     SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n-        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        id: folder.new_id(id),\n         attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n         node: match node {\n             MethDecl(ident,"}, {"sha": "146b5a5b34865670df3437d7fc281a9d7bd3a80d", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fb338d01864e3801cab9f76d608f204d11fc27/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d6fb338d01864e3801cab9f76d608f204d11fc27", "patch": "@@ -27,6 +27,7 @@\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n \n+extern crate arena;\n extern crate fmt_macros;\n extern crate debug;\n #[phase(plugin, link)] extern crate log;"}]}