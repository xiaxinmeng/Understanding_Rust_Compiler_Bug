{"sha": "73d73077febba921918b5611574bf514eae63006", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZDczMDc3ZmViYmE5MjE5MThiNTYxMTU3NGJmNTE0ZWFlNjMwMDY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T21:11:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T22:27:57Z"}, "message": "Separate creation and initialization of global state", "tree": {"sha": "602383421d3c1c624f9536e8b730216af4cf15f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602383421d3c1c624f9536e8b730216af4cf15f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73d73077febba921918b5611574bf514eae63006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73d73077febba921918b5611574bf514eae63006", "html_url": "https://github.com/rust-lang/rust/commit/73d73077febba921918b5611574bf514eae63006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73d73077febba921918b5611574bf514eae63006/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3615347fcebebaa58a5cbf675ae062aae149d9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3615347fcebebaa58a5cbf675ae062aae149d9c3", "html_url": "https://github.com/rust-lang/rust/commit/3615347fcebebaa58a5cbf675ae062aae149d9c3"}], "stats": {"total": 121, "additions": 65, "deletions": 56}, "files": [{"sha": "be5a3f8a792ea6fa343c6d5aa4231683d5bd7c0f", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 65, "deletions": 56, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/73d73077febba921918b5611574bf514eae63006/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d73077febba921918b5611574bf514eae63006/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=73d73077febba921918b5611574bf514eae63006", "patch": "@@ -81,7 +81,7 @@ pub(crate) struct GlobalState {\n     pub(crate) req_queue: ReqQueue,\n     latest_requests: Arc<RwLock<LatestRequests>>,\n     source_root_config: SourceRootConfig,\n-    _proc_macro_client: ProcMacroClient,\n+    proc_macro_client: ProcMacroClient,\n     workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n@@ -103,61 +103,14 @@ impl GlobalState {\n         config: Config,\n         req_queue: ReqQueue,\n     ) -> GlobalState {\n-        let mut change = AnalysisChange::new();\n-\n-        let project_folders = ProjectFolders::new(&workspaces);\n-\n         let (task_sender, task_receiver) = unbounded::<vfs::loader::Message>();\n-        let mut vfs = vfs::Vfs::default();\n-\n-        let proc_macro_client = match &config.proc_macro_srv {\n-            None => ProcMacroClient::dummy(),\n-            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n-                Ok(it) => it,\n-                Err(err) => {\n-                    log::error!(\n-                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n-                        path.display(),\n-                        err\n-                    );\n-                    ProcMacroClient::dummy()\n-                }\n-            },\n-        };\n \n-        let mut loader = {\n+        let loader = {\n             let loader = vfs_notify::NotifyHandle::spawn(Box::new(move |msg| {\n                 task_sender.send(msg).unwrap()\n             }));\n             Box::new(loader)\n         };\n-        let watch = match config.files.watcher {\n-            FilesWatcher::Client => vec![],\n-            FilesWatcher::Notify => project_folders.watch,\n-        };\n-        loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n-\n-        // Create crate graph from all the workspaces\n-        let mut crate_graph = CrateGraph::default();\n-        let mut load = |path: &AbsPath| {\n-            let contents = loader.load_sync(path);\n-            let path = vfs::VfsPath::from(path.to_path_buf());\n-            vfs.set_file_contents(path.clone(), contents);\n-            vfs.file_id(&path)\n-        };\n-        for ws in workspaces.iter() {\n-            crate_graph.extend(ws.to_crate_graph(\n-                config.cargo.target.as_deref(),\n-                &proc_macro_client,\n-                &mut load,\n-            ));\n-        }\n-        change.set_crate_graph(crate_graph);\n-\n-        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n-\n-        let mut analysis_host = AnalysisHost::new(lru_capacity);\n-        analysis_host.apply_change(change);\n \n         let task_pool = {\n             let (sender, receiver) = unbounded();\n@@ -168,24 +121,80 @@ impl GlobalState {\n             sender,\n             config,\n             task_pool,\n-            analysis_host,\n+            analysis_host: AnalysisHost::new(lru_capacity),\n             loader,\n             task_receiver,\n-            flycheck,\n+            flycheck: None,\n             diagnostics: Default::default(),\n             mem_docs: FxHashSet::default(),\n-            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n             status: Status::default(),\n             req_queue,\n             latest_requests: Default::default(),\n-            source_root_config: project_folders.source_root_config,\n-            _proc_macro_client: proc_macro_client,\n-            workspaces: Arc::new(workspaces),\n+            source_root_config: SourceRootConfig::default(),\n+            proc_macro_client: ProcMacroClient::dummy(),\n+            workspaces: Arc::new(Vec::new()),\n         };\n-        res.process_changes();\n+        res.reload(workspaces);\n         res\n     }\n \n+    pub(crate) fn reload(&mut self, workspaces: Vec<ProjectWorkspace>) {\n+        let mut change = AnalysisChange::new();\n+\n+        let project_folders = ProjectFolders::new(&workspaces);\n+\n+        self.proc_macro_client = match &self.config.proc_macro_srv {\n+            None => ProcMacroClient::dummy(),\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+                Ok(it) => it,\n+                Err(err) => {\n+                    log::error!(\n+                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n+                        path.display(),\n+                        err\n+                    );\n+                    ProcMacroClient::dummy()\n+                }\n+            },\n+        };\n+        let watch = match self.config.files.watcher {\n+            FilesWatcher::Client => vec![],\n+            FilesWatcher::Notify => project_folders.watch,\n+        };\n+        self.loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n+\n+        // Create crate graph from all the workspaces\n+        let crate_graph = {\n+            let mut crate_graph = CrateGraph::default();\n+            let vfs = &mut self.vfs.write().0;\n+            let loader = &mut self.loader;\n+            let mut load = |path: &AbsPath| {\n+                let contents = loader.load_sync(path);\n+                let path = vfs::VfsPath::from(path.to_path_buf());\n+                vfs.set_file_contents(path.clone(), contents);\n+                vfs.file_id(&path)\n+            };\n+            for ws in workspaces.iter() {\n+                crate_graph.extend(ws.to_crate_graph(\n+                    self.config.cargo.target.as_deref(),\n+                    &self.proc_macro_client,\n+                    &mut load,\n+                ));\n+            }\n+\n+            crate_graph\n+        };\n+        change.set_crate_graph(crate_graph);\n+\n+        self.flycheck = self.config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n+        self.source_root_config = project_folders.source_root_config;\n+        self.workspaces = Arc::new(workspaces);\n+\n+        self.analysis_host.apply_change(change);\n+        self.process_changes();\n+    }\n+\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         self.analysis_host.update_lru_capacity(config.lru_capacity);\n         if config.check != self.config.check {"}]}