{"sha": "7a16d25365b5f0aa815948237c46fb1843386d7a", "node_id": "C_kwDOAAsO6NoAKDdhMTZkMjUzNjViNWYwYWE4MTU5NDgyMzdjNDZmYjE4NDMzODZkN2E", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-27T23:06:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-28T08:34:54Z"}, "message": "Add some provided methods to `Encoder`/`Decoder`.\n\nThe methods for `i8`, `bool`, `char`, `str` are the same for all impls,\nbecause they layered on top of other methods.", "tree": {"sha": "a3d90080fd95337b23238cd73eca3ee6066bf95e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3d90080fd95337b23238cd73eca3ee6066bf95e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a16d25365b5f0aa815948237c46fb1843386d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a16d25365b5f0aa815948237c46fb1843386d7a", "html_url": "https://github.com/rust-lang/rust/commit/7a16d25365b5f0aa815948237c46fb1843386d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a16d25365b5f0aa815948237c46fb1843386d7a/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa133f5354ac29096d1577d5ba9c1400c2ad3b0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa133f5354ac29096d1577d5ba9c1400c2ad3b0f", "html_url": "https://github.com/rust-lang/rust/commit/fa133f5354ac29096d1577d5ba9c1400c2ad3b0f"}], "stats": {"total": 140, "additions": 56, "deletions": 84}, "files": [{"sha": "44d0cc8164da22843f704f8031777c15a744b7ed", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7a16d25365b5f0aa815948237c46fb1843386d7a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a16d25365b5f0aa815948237c46fb1843386d7a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=7a16d25365b5f0aa815948237c46fb1843386d7a", "patch": "@@ -51,13 +51,6 @@ macro_rules! write_leb128 {\n     }};\n }\n \n-/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n-/// This way we can skip validation and still be relatively sure that deserialization\n-/// did not desynchronize.\n-///\n-/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n-const STR_SENTINEL: u8 = 0xC1;\n-\n impl Encoder for MemEncoder {\n     #[inline]\n     fn emit_usize(&mut self, v: usize) {\n@@ -114,28 +107,6 @@ impl Encoder for MemEncoder {\n         self.data.extend_from_slice(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n@@ -480,28 +451,6 @@ impl Encoder for FileEncoder {\n         self.write_all(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.write_all(s);\n@@ -665,36 +614,11 @@ impl<'a> Decoder for MemDecoder<'a> {\n         i16::from_le_bytes(self.read_array())\n     }\n \n-    #[inline]\n-    fn read_i8(&mut self) -> i8 {\n-        self.read_byte() as i8\n-    }\n-\n     #[inline]\n     fn read_isize(&mut self) -> isize {\n         read_leb128!(self, read_isize_leb128)\n     }\n \n-    #[inline]\n-    fn read_bool(&mut self) -> bool {\n-        let value = self.read_u8();\n-        value != 0\n-    }\n-\n-    #[inline]\n-    fn read_char(&mut self) -> char {\n-        let bits = self.read_u32();\n-        std::char::from_u32(bits).unwrap()\n-    }\n-\n-    #[inline]\n-    fn read_str(&mut self) -> &str {\n-        let len = self.read_usize();\n-        let bytes = self.read_raw_bytes(len + 1);\n-        assert!(bytes[len] == STR_SENTINEL);\n-        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n-    }\n-\n     #[inline]\n     fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n         if bytes > self.remaining() {"}, {"sha": "e1bc598736fee7fc8aba85d26904cd5e20588f2f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7a16d25365b5f0aa815948237c46fb1843386d7a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a16d25365b5f0aa815948237c46fb1843386d7a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=7a16d25365b5f0aa815948237c46fb1843386d7a", "patch": "@@ -12,6 +12,13 @@ use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n+/// This way we can skip validation and still be relatively sure that deserialization\n+/// did not desynchronize.\n+///\n+/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n+const STR_SENTINEL: u8 = 0xC1;\n+\n /// A note about error handling.\n ///\n /// Encoders may be fallible, but in practice failure is rare and there are so\n@@ -40,10 +47,29 @@ pub trait Encoder {\n     fn emit_i64(&mut self, v: i64);\n     fn emit_i32(&mut self, v: i32);\n     fn emit_i16(&mut self, v: i16);\n-    fn emit_i8(&mut self, v: i8);\n-    fn emit_bool(&mut self, v: bool);\n-    fn emit_char(&mut self, v: char);\n-    fn emit_str(&mut self, v: &str);\n+\n+    #[inline]\n+    fn emit_i8(&mut self, v: i8) {\n+        self.emit_u8(v as u8);\n+    }\n+\n+    #[inline]\n+    fn emit_bool(&mut self, v: bool) {\n+        self.emit_u8(if v { 1 } else { 0 });\n+    }\n+\n+    #[inline]\n+    fn emit_char(&mut self, v: char) {\n+        self.emit_u32(v as u32);\n+    }\n+\n+    #[inline]\n+    fn emit_str(&mut self, v: &str) {\n+        self.emit_usize(v.len());\n+        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_u8(STR_SENTINEL);\n+    }\n+\n     fn emit_raw_bytes(&mut self, s: &[u8]);\n \n     fn emit_enum_variant<F>(&mut self, v_id: usize, f: F)\n@@ -79,10 +105,32 @@ pub trait Decoder {\n     fn read_i64(&mut self) -> i64;\n     fn read_i32(&mut self) -> i32;\n     fn read_i16(&mut self) -> i16;\n-    fn read_i8(&mut self) -> i8;\n-    fn read_bool(&mut self) -> bool;\n-    fn read_char(&mut self) -> char;\n-    fn read_str(&mut self) -> &str;\n+\n+    #[inline]\n+    fn read_i8(&mut self) -> i8 {\n+        self.read_u8() as i8\n+    }\n+\n+    #[inline]\n+    fn read_bool(&mut self) -> bool {\n+        let value = self.read_u8();\n+        value != 0\n+    }\n+\n+    #[inline]\n+    fn read_char(&mut self) -> char {\n+        let bits = self.read_u32();\n+        std::char::from_u32(bits).unwrap()\n+    }\n+\n+    #[inline]\n+    fn read_str(&mut self) -> &str {\n+        let len = self.read_usize();\n+        let bytes = self.read_raw_bytes(len + 1);\n+        assert!(bytes[len] == STR_SENTINEL);\n+        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n+    }\n+\n     fn read_raw_bytes(&mut self, len: usize) -> &[u8];\n \n     // Although there is an `emit_enum_variant` method in `Encoder`, the code"}]}