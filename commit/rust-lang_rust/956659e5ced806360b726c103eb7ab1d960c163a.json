{"sha": "956659e5ced806360b726c103eb7ab1d960c163a", "node_id": "C_kwDOAAsO6NoAKDk1NjY1OWU1Y2VkODA2MzYwYjcyNmMxMDNlYjdhYjFkOTYwYzE2M2E", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-07T00:09:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-07T00:09:22Z"}, "message": "move saturating_add/sub into (pub) helper method", "tree": {"sha": "31a187449d2aa08e3f3bd34fdd6068ac6b4e8371", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a187449d2aa08e3f3bd34fdd6068ac6b4e8371"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956659e5ced806360b726c103eb7ab1d960c163a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956659e5ced806360b726c103eb7ab1d960c163a", "html_url": "https://github.com/rust-lang/rust/commit/956659e5ced806360b726c103eb7ab1d960c163a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956659e5ced806360b726c103eb7ab1d960c163a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38a0b81b1c32764d6a583a5efb6f306b8c44c503", "url": "https://api.github.com/repos/rust-lang/rust/commits/38a0b81b1c32764d6a583a5efb6f306b8c44c503", "html_url": "https://github.com/rust-lang/rust/commit/38a0b81b1c32764d6a583a5efb6f306b8c44c503"}], "stats": {"total": 87, "additions": 48, "deletions": 39}, "files": [{"sha": "6578db04c07eb4364c0c9cb51299ef7700fb1d9d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/956659e5ced806360b726c103eb7ab1d960c163a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956659e5ced806360b726c103eb7ab1d960c163a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=956659e5ced806360b726c103eb7ab1d960c163a", "patch": "@@ -219,48 +219,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(&args[0])?;\n                 let r = self.read_immediate(&args[1])?;\n-                let is_add = intrinsic_name == sym::saturating_add;\n-                let (val, overflowed, _ty) = self.overflowing_binary_op(\n-                    if is_add { BinOp::Add } else { BinOp::Sub },\n+                let val = self.saturating_arith(\n+                    if intrinsic_name == sym::saturating_add { BinOp::Add } else { BinOp::Sub },\n                     &l,\n                     &r,\n                 )?;\n-                let val = if overflowed {\n-                    let size = l.layout.size;\n-                    let num_bits = size.bits();\n-                    if l.layout.abi.is_signed() {\n-                        // For signed ints the saturated value depends on the sign of the first\n-                        // term since the sign of the second term can be inferred from this and\n-                        // the fact that the operation has overflowed (if either is 0 no\n-                        // overflow can occur)\n-                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n-                        let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n-                        if first_term_positive {\n-                            // Negative overflow not possible since the positive first term\n-                            // can only increase an (in range) negative term for addition\n-                            // or corresponding negated positive term for subtraction\n-                            Scalar::from_uint(\n-                                (1u128 << (num_bits - 1)) - 1, // max positive\n-                                Size::from_bits(num_bits),\n-                            )\n-                        } else {\n-                            // Positive overflow not possible for similar reason\n-                            // max negative\n-                            Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n-                        }\n-                    } else {\n-                        // unsigned\n-                        if is_add {\n-                            // max unsigned\n-                            Scalar::from_uint(size.unsigned_int_max(), Size::from_bits(num_bits))\n-                        } else {\n-                            // underflow to 0\n-                            Scalar::from_uint(0u128, Size::from_bits(num_bits))\n-                        }\n-                    }\n-                } else {\n-                    val\n-                };\n                 self.write_scalar(val, dest)?;\n             }\n             sym::discriminant_value => {\n@@ -508,6 +471,52 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n     }\n \n+    pub fn saturating_arith(\n+        &self,\n+        mir_op: BinOp,\n+        l: &ImmTy<'tcx, M::PointerTag>,\n+        r: &ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        assert!(matches!(mir_op, BinOp::Add | BinOp::Sub));\n+        let (val, overflowed, _ty) = self.overflowing_binary_op(mir_op, l, r)?;\n+        Ok(if overflowed {\n+            let size = l.layout.size;\n+            let num_bits = size.bits();\n+            if l.layout.abi.is_signed() {\n+                // For signed ints the saturated value depends on the sign of the first\n+                // term since the sign of the second term can be inferred from this and\n+                // the fact that the operation has overflowed (if either is 0 no\n+                // overflow can occur)\n+                let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n+                if first_term_positive {\n+                    // Negative overflow not possible since the positive first term\n+                    // can only increase an (in range) negative term for addition\n+                    // or corresponding negated positive term for subtraction\n+                    Scalar::from_uint(\n+                        (1u128 << (num_bits - 1)) - 1, // max positive\n+                        Size::from_bits(num_bits),\n+                    )\n+                } else {\n+                    // Positive overflow not possible for similar reason\n+                    // max negative\n+                    Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n+                }\n+            } else {\n+                // unsigned\n+                if matches!(mir_op, BinOp::Add) {\n+                    // max unsigned\n+                    Scalar::from_uint(size.unsigned_int_max(), Size::from_bits(num_bits))\n+                } else {\n+                    // underflow to 0\n+                    Scalar::from_uint(0u128, Size::from_bits(num_bits))\n+                }\n+            }\n+        } else {\n+            val\n+        })\n+    }\n+\n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n     /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n     /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value."}]}