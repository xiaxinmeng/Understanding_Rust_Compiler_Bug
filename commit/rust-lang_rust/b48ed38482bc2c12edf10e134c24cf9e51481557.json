{"sha": "b48ed38482bc2c12edf10e134c24cf9e51481557", "node_id": "C_kwDOAAsO6NoAKGI0OGVkMzg0ODJiYzJjMTJlZGYxMGUxMzRjMjRjZjllNTE0ODE1NTc", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-25T14:27:19Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-25T14:30:07Z"}, "message": "Make bx.block non-optional", "tree": {"sha": "8eda84f33eade3f77b1c2e702b71370b1077acf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eda84f33eade3f77b1c2e702b71370b1077acf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b48ed38482bc2c12edf10e134c24cf9e51481557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b48ed38482bc2c12edf10e134c24cf9e51481557", "html_url": "https://github.com/rust-lang/rust/commit/b48ed38482bc2c12edf10e134c24cf9e51481557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b48ed38482bc2c12edf10e134c24cf9e51481557/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6b398f1b8c4b09b716742d7050c6d3c1d7252f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6b398f1b8c4b09b716742d7050c6d3c1d7252f", "html_url": "https://github.com/rust-lang/rust/commit/ff6b398f1b8c4b09b716742d7050c6d3c1d7252f"}], "stats": {"total": 62, "additions": 27, "deletions": 35}, "files": [{"sha": "0d5b534a1a22bd273900e8bc78ddb23ede4b7672", "filename": "src/builder.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b48ed38482bc2c12edf10e134c24cf9e51481557/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48ed38482bc2c12edf10e134c24cf9e51481557/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=b48ed38482bc2c12edf10e134c24cf9e51481557", "patch": "@@ -80,15 +80,15 @@ impl EnumClone for AtomicOrdering {\n \n pub struct Builder<'a: 'gcc, 'gcc, 'tcx> {\n     pub cx: &'a CodegenCx<'gcc, 'tcx>,\n-    pub block: Option<Block<'gcc>>,\n+    pub block: Block<'gcc>,\n     stack_var_count: Cell<usize>,\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n-    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>) -> Self {\n+    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n         Builder {\n             cx,\n-            block: None,\n+            block,\n             stack_var_count: Cell::new(0),\n         }\n     }\n@@ -243,7 +243,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     pub fn current_func(&self) -> Function<'gcc> {\n-        self.block.expect(\"block\").get_function()\n+        self.block.get_function()\n     }\n \n     fn function_call(&mut self, func: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n@@ -254,17 +254,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n         let return_type = func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+            self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n             result.to_rvalue()\n         }\n         else {\n-            current_block.add_eval(None, self.cx.context.new_call(None, func, &args));\n+            self.block.add_eval(None, self.cx.context.new_call(None, func, &args));\n             // Return dummy value when not having return value.\n             self.context.new_rvalue_from_long(self.isize_type, 0)\n         }\n@@ -277,9 +276,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // That's why we assign the result to a local or call add_eval().\n         let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n \n         // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n         if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n@@ -289,20 +287,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            current_block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n         else {\n             if gcc_func.get_param_count() == 0 {\n                 // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n             }\n             else {\n-                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             }\n             // Return dummy value when not having return value.\n             let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n-            current_block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n+            self.block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n             result.to_rvalue()\n         }\n     }\n@@ -311,12 +309,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local.\n         let return_type = self.context.new_type::<bool>();\n-        let current_block = self.current_block.borrow().expect(\"block\");\n-        let current_func = current_block.get_function();\n+        let current_func = self.block.get_function();\n         // TODO(antoyo): return the new_call() directly? Since the overflow function has no side-effects.\n         unsafe { RETURN_VALUE_COUNT += 1 };\n         let result = current_func.new_local(None, return_type, &format!(\"overflowReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-        current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+        self.block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n         result.to_rvalue()\n     }\n }\n@@ -382,14 +379,13 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n-        let mut bx = Builder::with_cx(cx);\n+        let bx = Builder::with_cx(cx, block);\n         *cx.current_block.borrow_mut() = Some(block);\n-        bx.block = Some(block);\n         bx\n     }\n \n     fn llbb(&self) -> Block<'gcc> {\n-        self.block.expect(\"block\")\n+        self.block\n     }\n \n     fn append_block(cx: &'a CodegenCx<'gcc, 'tcx>, func: RValue<'gcc>, name: &str) -> Block<'gcc> {\n@@ -404,7 +400,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn switch_to_block(&mut self, block: Self::BasicBlock) {\n         *self.cx.current_block.borrow_mut() = Some(block);\n-        self.block = Some(block);\n+        self.block = block;\n     }\n \n     fn ret_void(&mut self) {\n@@ -439,7 +435,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             let on_val = self.const_uint_big(typ, on_val);\n             gcc_cases.push(self.context.new_case(on_val, on_val, dest));\n         }\n-        self.block.expect(\"block\").end_with_switch(None, value, default_block, &gcc_cases);\n+        self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n     fn invoke(&mut self, _typ: Type<'gcc>, _func: RValue<'gcc>, _args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n@@ -452,17 +448,16 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn unreachable(&mut self) {\n         let func = self.context.get_builtin_function(\"__builtin_unreachable\");\n-        let block = self.block.expect(\"block\");\n-        block.add_eval(None, self.context.new_call(None, func, &[]));\n-        let return_type = block.get_function().get_return_type();\n+        self.block.add_eval(None, self.context.new_call(None, func, &[]));\n+        let return_type = self.block.get_function().get_return_type();\n         let void_type = self.context.new_type::<()>();\n         if return_type == void_type {\n-            block.end_with_void_return(None)\n+            self.block.end_with_void_return(None)\n         }\n         else {\n             let return_value = self.current_func()\n                 .new_local(None, return_type, \"unreachableReturn\");\n-            block.end_with_return(None, return_value)\n+            self.block.end_with_return(None, return_value)\n         }\n     }\n \n@@ -909,11 +904,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn ptrtoint(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.ptrtoint(self.block.expect(\"block\"), value, dest_ty)\n+        self.cx.ptrtoint(self.block, value, dest_ty)\n     }\n \n     fn inttoptr(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.cx.inttoptr(self.block.expect(\"block\"), value, dest_ty)\n+        self.cx.inttoptr(self.block, value, dest_ty)\n     }\n \n     fn bitcast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n@@ -965,9 +960,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let dst = self.pointercast(dst, self.type_i8p());\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n         let memcpy = self.context.get_builtin_function(\"memcpy\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle aligns and is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n     }\n \n     fn memmove(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n@@ -984,20 +978,18 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n \n         let memmove = self.context.get_builtin_function(\"memmove\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle is_volatile.\n-        block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n     }\n \n     fn memset(&mut self, ptr: RValue<'gcc>, fill_byte: RValue<'gcc>, size: RValue<'gcc>, _align: Align, flags: MemFlags) {\n         let _is_volatile = flags.contains(MemFlags::VOLATILE);\n         let ptr = self.pointercast(ptr, self.type_i8p());\n         let memset = self.context.get_builtin_function(\"memset\");\n-        let block = self.block.expect(\"block\");\n         // TODO(antoyo): handle align and is_volatile.\n         let fill_byte = self.context.new_cast(None, fill_byte, self.i32_type);\n         let size = self.intcast(size, self.type_size_t(), false);\n-        block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n+        self.block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n     }\n \n     fn select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, mut else_val: RValue<'gcc>) -> RValue<'gcc> {"}]}