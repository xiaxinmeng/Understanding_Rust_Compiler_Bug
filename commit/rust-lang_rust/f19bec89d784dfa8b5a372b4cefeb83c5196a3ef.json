{"sha": "f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOWJlYzg5ZDc4NGRmYThiNWEzNzJiNGNlZmViODNjNTE5NmEzZWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-23T08:25:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-23T08:25:12Z"}, "message": "Rollup merge of #58122 - matthieu-m:range_incl_perf, r=dtolnay\n\nRangeInclusive internal iteration performance improvement.\n\nSpecialize `Iterator::try_fold` and `DoubleEndedIterator::try_rfold` to improve code generation in all internal iteration scenarios.\n\nThis changes brings the performance of internal iteration with `RangeInclusive` on par with the performance of iteration with `Range`:\n\n - Single conditional jump in hot loop,\n - Unrolling and vectorization,\n - And even Closed Form substitution.\n\nUnfortunately, it only applies to internal iteration. Despite various attempts at stream-lining the implementation of `next` and `next_back`, LLVM has stubbornly refused to optimize external iteration appropriately, leaving me with a choice between:\n\n - The current implementation, for which Closed Form substitution is performed, but which uses 2 conditional jumps in the hot loop when optimization fail.\n - An implementation using a `is_done` boolean, which uses 1 conditional jump in the hot loop when optimization fail, allowing unrolling and vectorization, but for which Closed Form substitution fails.\n\nIn the absence of any conclusive evidence as to which usecase matters most, and with no assurance that the lack of Closed Form substitution is not indicative of other optimizations being foiled, there is no way\nto pick one implementation over the other, and thus I defer to the statu quo as far as `next` and `next_back` are concerned.", "tree": {"sha": "3a44d57869eb777599560b34c069e97aa4438ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a44d57869eb777599560b34c069e97aa4438ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJccQNpCRBK7hj4Ov3rIwAAdHIIAF1EhRe8yrscgQK9dwLZqqca\ndSU2MwzMO+IlndfOcP9VhpmZPkyMHmQwIrBp6xORCS6LnOOtc/jICi7g0n9rrayE\nr4wUa2Q6RTz1iqizhdveuBNk+h+2l3oW4BBLaWL8SRS1c7kBtRZn/cobhp/emHvh\nrQuG1Y9HiyMLJ9fJY70RvnENl7t3qVHzbmv6SDRsWrlsk9QDBFdHO5m8ssqLVR28\nBDnarlFb9yd+blXpZInpPx70gDFuek/Vrd3g66bziljneJmQ5EGqh6cH7Al4qWPa\ni/BfE0IhWRdbHzRkJSgrNXOjRLvaEnR1NDKB1njJgsxbr2Lwc2CGgBRXI1Fw7+U=\n=mjFS\n-----END PGP SIGNATURE-----\n", "payload": "tree 3a44d57869eb777599560b34c069e97aa4438ffd\nparent c49da5bfe510e74393cc70c0a7aebd5ddf21ae83\nparent 4fed67f94220351ffa60de1dca078c02a7c15734\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550910312 +0100\ncommitter GitHub <noreply@github.com> 1550910312 +0100\n\nRollup merge of #58122 - matthieu-m:range_incl_perf, r=dtolnay\n\nRangeInclusive internal iteration performance improvement.\n\nSpecialize `Iterator::try_fold` and `DoubleEndedIterator::try_rfold` to improve code generation in all internal iteration scenarios.\n\nThis changes brings the performance of internal iteration with `RangeInclusive` on par with the performance of iteration with `Range`:\n\n - Single conditional jump in hot loop,\n - Unrolling and vectorization,\n - And even Closed Form substitution.\n\nUnfortunately, it only applies to internal iteration. Despite various attempts at stream-lining the implementation of `next` and `next_back`, LLVM has stubbornly refused to optimize external iteration appropriately, leaving me with a choice between:\n\n - The current implementation, for which Closed Form substitution is performed, but which uses 2 conditional jumps in the hot loop when optimization fail.\n - An implementation using a `is_done` boolean, which uses 1 conditional jump in the hot loop when optimization fail, allowing unrolling and vectorization, but for which Closed Form substitution fails.\n\nIn the absence of any conclusive evidence as to which usecase matters most, and with no assurance that the lack of Closed Form substitution is not indicative of other optimizations being foiled, there is no way\nto pick one implementation over the other, and thus I defer to the statu quo as far as `next` and `next_back` are concerned.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "html_url": "https://github.com/rust-lang/rust/commit/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c49da5bfe510e74393cc70c0a7aebd5ddf21ae83", "url": "https://api.github.com/repos/rust-lang/rust/commits/c49da5bfe510e74393cc70c0a7aebd5ddf21ae83", "html_url": "https://github.com/rust-lang/rust/commit/c49da5bfe510e74393cc70c0a7aebd5ddf21ae83"}, {"sha": "4fed67f94220351ffa60de1dca078c02a7c15734", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fed67f94220351ffa60de1dca078c02a7c15734", "html_url": "https://github.com/rust-lang/rust/commit/4fed67f94220351ffa60de1dca078c02a7c15734"}], "stats": {"total": 87, "additions": 81, "deletions": 6}, "files": [{"sha": "e7efd9728b94ace02076a367598c883c6f46a45d", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "patch": "@@ -1,6 +1,6 @@\n use convert::TryFrom;\n use mem;\n-use ops::{self, Add, Sub};\n+use ops::{self, Add, Sub, Try};\n use usize;\n \n use super::{FusedIterator, TrustedLen};\n@@ -368,11 +368,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n                 Some(Less) => {\n                     self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 _ => {}\n             }\n@@ -382,6 +382,34 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         None\n     }\n \n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        if self.is_empty() {\n+            return Try::from_ok(init);\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.start.add_one();\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.is_empty = Some(true);\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        Try::from_ok(accum)\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -415,6 +443,33 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             self.end.clone()\n         })\n     }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        if self.is_empty() {\n+            return Try::from_ok(init);\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.end.sub_one();\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.is_empty = Some(true);\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        Try::from_ok(accum)\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "998b597d5e113a12a63e54436f5ec0e1d98e9211", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "patch": "@@ -334,12 +334,14 @@ pub struct RangeInclusive<Idx> {\n trait RangeInclusiveEquality: Sized {\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n }\n+\n impl<T> RangeInclusiveEquality for T {\n     #[inline]\n     default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n         range.is_empty.unwrap_or_default()\n     }\n }\n+\n impl<T: PartialOrd> RangeInclusiveEquality for T {\n     #[inline]\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {"}, {"sha": "d880abb181c20f20608155eb210d1ac8f6b4495b", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19bec89d784dfa8b5a372b4cefeb83c5196a3ef/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=f19bec89d784dfa8b5a372b4cefeb83c5196a3ef", "patch": "@@ -1741,19 +1741,37 @@ fn test_range_inclusive_folds() {\n     assert_eq!((1..=10).sum::<i32>(), 55);\n     assert_eq!((1..=10).rev().sum::<i32>(), 55);\n \n-    let mut it = 40..=50;\n+    let mut it = 44..=50;\n     assert_eq!(it.try_fold(0, i8::checked_add), None);\n-    assert_eq!(it, 44..=50);\n+    assert_eq!(it, 47..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it, 50..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(50));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n+\n+    let mut it = 40..=47;\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it, 40..=44);\n     assert_eq!(it.try_rfold(0, i8::checked_add), None);\n-    assert_eq!(it, 44..=47);\n+    assert_eq!(it, 40..=41);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(81));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(165));\n     assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(0));\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(165));\n     assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(0));\n+    assert!(it.is_empty());\n }\n \n #[test]"}]}