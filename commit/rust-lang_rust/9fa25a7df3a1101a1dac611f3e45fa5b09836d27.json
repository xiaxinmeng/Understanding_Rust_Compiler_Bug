{"sha": "9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYTI1YTdkZjNhMTEwMWExZGFjNjExZjNlNDVmYTViMDk4MzZkMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-23T07:14:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-23T07:14:42Z"}, "message": "Auto merge of #42015 - nikomatsakis:chalk-trait-env-2, r=eddyb\n\nremove interior mutability of type-flags\n\nWe were previously using the flags on `Ty<'tcx>` instances to do some ad-hoc caching schemes around things like `is_sized()`, `is_freeze()`, and `moves_by_default()`. This PR replaces those schemes with a proper query; the query key is based on the pair of a `(ParameterEnvironment<'tcx>, Ty<'tcx>)` pair. This is also intended to be a preliminary template for what trait-selection and projection will eventually look like.\n\nI did some performance measurements. In the past, I observed a noticeable speedup (6%) for building rustc, but since I've rebased, the numbers appear to be more of a wash:\n\n| Crate | Before | After | Percentage |\n| --- | --- | --- | -- |\n| syntax | 167s | 166s | 0.6% faster |\n| rustc | 376s | 382s | 1.5% slower |\n\nSome advantages of this new scheme:\n\n- `is_sized` etc are proper queries\n- we get caching across generic fns, so long as trait environment is identical\n- dependency tracking is correct", "tree": {"sha": "244059017b067ceb95421acdf461e8a12ede27d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/244059017b067ceb95421acdf461e8a12ede27d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "html_url": "https://github.com/rust-lang/rust/commit/9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "852b7cb91ed44f6cc77f855bd8281da4accbd2fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/852b7cb91ed44f6cc77f855bd8281da4accbd2fb", "html_url": "https://github.com/rust-lang/rust/commit/852b7cb91ed44f6cc77f855bd8281da4accbd2fb"}, {"sha": "83641a9b6d2a622f5705ab76152cffb41d60fa3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/83641a9b6d2a622f5705ab76152cffb41d60fa3a", "html_url": "https://github.com/rust-lang/rust/commit/83641a9b6d2a622f5705ab76152cffb41d60fa3a"}], "stats": {"total": 918, "additions": 427, "deletions": 491}, "files": [{"sha": "291d0d7c937ed6a3a15621ee013ab8952161d449", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -108,6 +108,10 @@ pub enum DepNode<D: Clone + Debug> {\n     SymbolName(D),\n     SpecializationGraph(D),\n     ObjectSafety(D),\n+    IsCopy(D),\n+    IsSized(D),\n+    IsFreeze(D),\n+    NeedsDrop(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -159,6 +163,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // not a hotspot.\n     ProjectionCache { def_ids: Vec<D> },\n \n+    ParamEnv(D),\n     DescribeDef(D),\n     DefSpan(D),\n     Stability(D),\n@@ -233,6 +238,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             // they are always absolute.\n             WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n \n+            IsCopy(ref d) => op(d).map(IsCopy),\n+            IsSized(ref d) => op(d).map(IsSized),\n+            IsFreeze(ref d) => op(d).map(IsFreeze),\n+            NeedsDrop(ref d) => op(d).map(NeedsDrop),\n             Hir(ref d) => op(d).map(Hir),\n             HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),\n@@ -284,6 +293,7 @@ impl<D: Clone + Debug> DepNode<D> {\n                 let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n                 def_ids.map(|d| ProjectionCache { def_ids: d })\n             }\n+            ParamEnv(ref d) => op(d).map(ParamEnv),\n             DescribeDef(ref d) => op(d).map(DescribeDef),\n             DefSpan(ref d) => op(d).map(DefSpan),\n             Stability(ref d) => op(d).map(Stability),"}, {"sha": "270430f40df02d145ed68321d5c50f35d0516126", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -161,7 +161,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n \n-    pub parameter_environment: ty::ParameterEnvironment<'gcx>,\n+    pub param_env: ty::ParamEnv<'gcx>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n@@ -406,41 +406,41 @@ pub trait InferEnv<'a, 'tcx> {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>);\n+                    Option<ty::ParamEnv<'tcx>>);\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>) {\n+                    Option<ty::ParamEnv<'tcx>>) {\n         (None, None, None)\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParameterEnvironment<'tcx> {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParamEnv<'tcx> {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>) {\n+                    Option<ty::ParamEnv<'tcx>>) {\n         (None, None, Some(self))\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::TypeckTables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>) {\n+                    Option<ty::ParamEnv<'tcx>>) {\n         (Some(self.0), None, Some(self.1))\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::TypeckTables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>) {\n+                    Option<ty::ParamEnv<'tcx>>) {\n         (None, Some(self.0), Some(self.1))\n     }\n }\n@@ -449,11 +449,11 @@ impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParameterEnvironment<'tcx>>) {\n+                    Option<ty::ParamEnv<'tcx>>) {\n         let def_id = tcx.hir.body_owner_def_id(self);\n         (Some(tcx.typeck_tables_of(def_id)),\n          None,\n-         Some(tcx.parameter_environment(def_id)))\n+         Some(tcx.param_env(def_id)))\n     }\n }\n \n@@ -465,7 +465,7 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     arena: DroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n     tables: Option<&'a ty::TypeckTables<'gcx>>,\n-    param_env: Option<ty::ParameterEnvironment<'gcx>>,\n+    param_env: Option<ty::ParamEnv<'gcx>>,\n     projection_mode: Reveal,\n }\n \n@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(self),\n-            parameter_environment: param_env.unwrap(),\n+            param_env: param_env.unwrap(),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n@@ -526,9 +526,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n             fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n         });\n-        let param_env = param_env.take().unwrap_or_else(|| {\n-            global_tcx.empty_parameter_environment()\n-        });\n+        let param_env = param_env.take().unwrap_or_else(|| ty::ParamEnv::empty());\n         global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n@@ -537,7 +535,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n-            parameter_environment: param_env,\n+            param_env: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n@@ -650,7 +648,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn normalize_associated_type_in_env<T>(\n-        self, value: &T, env: &'a ty::ParameterEnvironment<'tcx>\n+        self, value: &T, env: ty::ParamEnv<'tcx>\n     ) -> T\n         where T: TransNormalize<'tcx>\n     {\n@@ -662,7 +660,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(env.clone(), Reveal::All).enter(|infcx| {\n+        self.infer_ctxt(env, Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n        })\n     }\n@@ -1674,8 +1672,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'gcx> {\n-        &self.parameter_environment\n+    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n+        self.param_env\n     }\n \n     pub fn closure_kind(&self,"}, {"sha": "c49df4b1ad9ea8bd6f564ccb08a9eb546a3cea44", "filename": "src/librustc/traits/README.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2FREADME.md?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -418,16 +418,16 @@ before, and hence the cache lookup would succeed, yielding\n One subtle interaction is that the results of trait lookup will vary\n depending on what where clauses are in scope. Therefore, we actually\n have *two* caches, a local and a global cache. The local cache is\n-attached to the `ParameterEnvironment` and the global cache attached\n-to the `tcx`. We use the local cache whenever the result might depend\n-on the where clauses that are in scope. The determination of which\n-cache to use is done by the method `pick_candidate_cache` in\n-`select.rs`. At the moment, we use a very simple, conservative rule:\n-if there are any where-clauses in scope, then we use the local cache.\n-We used to try and draw finer-grained distinctions, but that led to a\n-serious of annoying and weird bugs like #22019 and #18290. This simple\n-rule seems to be pretty clearly safe and also still retains a very\n-high hit rate (~95% when compiling rustc).\n+attached to the `ParamEnv` and the global cache attached to the\n+`tcx`. We use the local cache whenever the result might depend on the\n+where clauses that are in scope. The determination of which cache to\n+use is done by the method `pick_candidate_cache` in `select.rs`. At\n+the moment, we use a very simple, conservative rule: if there are any\n+where-clauses in scope, then we use the local cache.  We used to try\n+and draw finer-grained distinctions, but that led to a serious of\n+annoying and weird bugs like #22019 and #18290. This simple rule seems\n+to be pretty clearly safe and also still retains a very high hit rate\n+(~95% when compiling rustc).\n \n # Specialization\n "}, {"sha": "e358f39bd9a3a1356fb2130b3ea15cb1b382bcb9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -437,9 +437,9 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               region_context: DefId,\n-                                              unnormalized_env: ty::ParameterEnvironment<'tcx>,\n+                                              unnormalized_env: ty::ParamEnv<'tcx>,\n                                               cause: ObligationCause<'tcx>)\n-                                              -> ty::ParameterEnvironment<'tcx>\n+                                              -> ty::ParamEnv<'tcx>\n {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n@@ -477,15 +477,15 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n \n-    let elaborated_env = unnormalized_env.with_caller_bounds(tcx.intern_predicates(&predicates));\n+    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates));\n \n     tcx.infer_ctxt(elaborated_env, Reveal::UserFacing).enter(|infcx| {\n         let predicates = match fully_normalize(\n                 &infcx, cause,\n-                // You would really want to pass infcx.parameter_environment.caller_bounds here,\n+                // You would really want to pass infcx.param_env.caller_bounds here,\n                 // but that is an interned slice, and fully_normalize takes &T and returns T, so\n                 // without further refactoring, a slice can't be used. Luckily, we still have the\n-                // predicate vector from which we created the ParameterEnvironment in infcx, so we\n+                // predicate vector from which we created the ParamEnv in infcx, so we\n                 // can pass that instead. It's roundabout and a bit brittle, but this code path\n                 // ought to be refactored anyway, and until then it saves us from having to copy.\n                 &predicates,\n@@ -494,7 +494,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Err(errors) => {\n                 infcx.report_fulfillment_errors(&errors);\n                 // An unnormalized env is better than nothing.\n-                return infcx.parameter_environment;\n+                return infcx.param_env;\n             }\n         };\n \n@@ -516,19 +516,19 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // all things considered.\n                 tcx.sess.span_err(span, &fixup_err.to_string());\n                 // An unnormalized env is better than nothing.\n-                return infcx.parameter_environment;\n+                return infcx.param_env;\n             }\n         };\n \n         let predicates = match tcx.lift_to_global(&predicates) {\n             Some(predicates) => predicates,\n-            None => return infcx.parameter_environment\n+            None => return infcx.param_env\n         };\n \n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n             predicates);\n \n-        infcx.parameter_environment.with_caller_bounds(tcx.intern_predicates(&predicates))\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates))\n     })\n }\n "}, {"sha": "7366ed45f31bd514f96279377cbd36433dfe1e26", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -315,7 +315,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'gcx> {\n+    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n         self.infcx.param_env()\n     }\n "}, {"sha": "e0f28e3b49e919832a56b8bc738e0b2f6d983fe2", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -180,7 +180,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let penv = tcx.parameter_environment(impl1_def_id);\n+    let penv = tcx.param_env(impl1_def_id);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n@@ -250,7 +250,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                        source_trait_ref,\n                        target_trait_ref,\n                        errors,\n-                       infcx.parameter_environment.caller_bounds);\n+                       infcx.param_env.caller_bounds);\n                 Err(())\n             }\n "}, {"sha": "5ee0b1c9e5ea44ba421bc9a29b03e29e84135709", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -138,7 +138,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             let flags = super::flags::FlagComputation::for_sty(&st);\n             let ty_struct = TyS {\n                 sty: st,\n-                flags: Cell::new(flags.flags),\n+                flags: flags.flags,\n                 region_depth: flags.depth,\n             };\n \n@@ -978,8 +978,8 @@ macro_rules! sty_debug_print {\n                         ty::TyError => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.get().intersects(ty::TypeFlags::HAS_RE_INFER);\n-                    let ty = t.flags.get().intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;"}, {"sha": "46afa6ee7d011d48053d892c02cd4cdc1ec65b83", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -167,7 +167,7 @@ impl FlagComputation {\n     }\n \n     fn add_ty(&mut self, ty: Ty) {\n-        self.add_flags(ty.flags.get());\n+        self.add_flags(ty.flags);\n         self.add_depth(ty.region_depth);\n     }\n "}, {"sha": "c17a54f4f69bbb98717992d487c0d0c8a1e7afba", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -625,9 +625,8 @@ struct HasTypeFlagsVisitor {\n \n impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_ty(&mut self, t: Ty) -> bool {\n-        let flags = t.flags.get();\n-        debug!(\"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\", t, flags, self.flags);\n-        flags.intersects(self.flags)\n+        debug!(\"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\", t, t.flags, self.flags);\n+        t.flags.intersects(self.flags)\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {"}, {"sha": "1a8c74ff1f94323db427711be1617d01c1100a48", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -1079,7 +1079,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n         let ptr_layout = |pointee: Ty<'gcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n             let pointee = infcx.normalize_projections(pointee);\n-            if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n+            if pointee.is_sized(tcx, infcx.param_env, DUMMY_SP) {\n                 Ok(Scalar { value: Pointer, non_zero: non_zero })\n             } else {\n                 let unsized_part = tcx.struct_tail(pointee);\n@@ -1268,11 +1268,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n                         StructKind::AlwaysSizedUnivariant\n                     } else {\n-                        let param_env = tcx.parameter_environment(def.did);\n+                        let param_env = tcx.param_env(def.did);\n                         let fields = &def.variants[0].fields;\n                         let last_field = &fields[fields.len()-1];\n                         let always_sized = tcx.type_of(last_field.did)\n-                          .is_sized(tcx, &param_env, DUMMY_SP);\n+                          .is_sized(tcx, param_env, DUMMY_SP);\n                         if !always_sized { StructKind::MaybeUnsizedUnivariant }\n                         else { StructKind::AlwaysSizedUnivariant }\n                     };"}, {"sha": "fb352e5be89383c4743522ba1abe85ab54217aea", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n use middle::const_val;\n@@ -136,6 +136,15 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n+impl<'tcx, T: Clone + Hash + Eq + Debug> Key for ty::ParamEnvAnd<'tcx, T> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -244,6 +253,30 @@ impl<M: DepTrackingMapConfig<Key=DefId>> QueryDescription for M {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Copy`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Sized`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is freeze\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` needs drop\", env.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n@@ -856,6 +889,15 @@ define_maps! { <'tcx>\n         -> ty::trait_def::TraitImpls,\n     [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] is_object_safe: ObjectSafety(DefId) -> bool,\n+\n+    [] param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+\n+    // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n+    // `ty.is_copy()`, etc, since that will prune the environment where possible.\n+    [] is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -899,3 +941,27 @@ fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepNode<DefId> {\n     DepNode::TraitImpls(def_id)\n }\n+\n+fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::IsCopy(def_id)\n+}\n+\n+fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::IsSized(def_id)\n+}\n+\n+fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::IsFreeze(def_id)\n+}\n+\n+fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::NeedsDrop(def_id)\n+}"}, {"sha": "fa731f6dde638f6fb97f3ff4acf282ad5e5239c9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 78, "deletions": 93, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -35,7 +35,6 @@ use util::common::ErrorReported;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n-use std::cell::{Cell, RefCell};\n use std::collections::BTreeMap;\n use std::cmp;\n use std::fmt;\n@@ -503,22 +502,12 @@ bitflags! {\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n                                   TypeFlags::HAS_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits,\n-\n-        // Caches for type_is_sized, type_moves_by_default\n-        const SIZEDNESS_CACHED  = 1 << 16,\n-        const IS_SIZED          = 1 << 17,\n-        const MOVENESS_CACHED   = 1 << 18,\n-        const MOVES_BY_DEFAULT  = 1 << 19,\n-        const FREEZENESS_CACHED = 1 << 20,\n-        const IS_FREEZE         = 1 << 21,\n-        const NEEDS_DROP_CACHED = 1 << 22,\n-        const NEEDS_DROP        = 1 << 23,\n     }\n }\n \n pub struct TyS<'tcx> {\n     pub sty: TypeVariants<'tcx>,\n-    pub flags: Cell<TypeFlags>,\n+    pub flags: TypeFlags,\n \n     // the maximal depth of any bound regions appearing in this type.\n     region_depth: u32,\n@@ -1249,46 +1238,58 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-/// When type checking, we use the `ParameterEnvironment` to track\n-/// details about the type/lifetime parameters that are in scope.\n-/// It primarily stores the bounds information.\n-///\n-/// Note: This information might seem to be redundant with the data in\n-/// `tcx.ty_param_defs`, but it is not. That table contains the\n-/// parameter definitions from an \"outside\" perspective, but this\n-/// struct will contain the bounds for a parameter as seen from inside\n-/// the function body. Currently the only real distinction is that\n-/// bound lifetime parameters are replaced with free ones, but in the\n-/// future I hope to refine the representation of types so as to make\n-/// more distinctions clearer.\n-#[derive(Clone)]\n-pub struct ParameterEnvironment<'tcx> {\n+/// When type checking, we use the `ParamEnv` to track\n+/// details about the set of where-clauses that are in scope at this\n+/// particular point.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ParamEnv<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n-    pub caller_bounds: &'tcx [ty::Predicate<'tcx>],\n-\n-    /// A cache for `moves_by_default`.\n-    pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+    pub caller_bounds: &'tcx Slice<ty::Predicate<'tcx>>,\n+}\n \n-    /// A cache for `type_is_sized`\n-    pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+impl<'tcx> ParamEnv<'tcx> {\n+    /// Creates a suitable environment in which to perform trait\n+    /// queries on the given value. This will either be `self` *or*\n+    /// the empty environment, depending on whether `value` references\n+    /// type parameters that are in scope. (If it doesn't, then any\n+    /// judgements should be completely independent of the context,\n+    /// and hence we can safely use the empty environment so as to\n+    /// enable more sharing across functions.)\n+    ///\n+    /// NB: This is a mildly dubious thing to do, in that a function\n+    /// (or other environment) might have wacky where-clauses like\n+    /// `where Box<u32>: Copy`, which are clearly never\n+    /// satisfiable. The code will at present ignore these,\n+    /// effectively, when type-checking the body of said\n+    /// function. This preserves existing behavior in any\n+    /// case. --nmatsakis\n+    pub fn and<T: TypeFoldable<'tcx>>(self, value: T) -> ParamEnvAnd<'tcx, T> {\n+        assert!(!value.needs_infer());\n+        if value.has_param_types() || value.has_self_ty() {\n+            ParamEnvAnd {\n+                param_env: self,\n+                value: value,\n+            }\n+        } else {\n+            ParamEnvAnd {\n+                param_env: ParamEnv::empty(),\n+                value: value,\n+            }\n+        }\n+    }\n+}\n \n-    /// A cache for `type_is_freeze`\n-    pub is_freeze_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ParamEnvAnd<'tcx, T> {\n+    pub param_env: ParamEnv<'tcx>,\n+    pub value: T,\n }\n \n-impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n-    pub fn with_caller_bounds(&self,\n-                              caller_bounds: &'tcx [ty::Predicate<'tcx>])\n-                              -> ParameterEnvironment<'tcx>\n-    {\n-        ParameterEnvironment {\n-            caller_bounds: caller_bounds,\n-            is_copy_cache: RefCell::new(FxHashMap()),\n-            is_sized_cache: RefCell::new(FxHashMap()),\n-            is_freeze_cache: RefCell::new(FxHashMap()),\n-        }\n+impl<'tcx, T> ParamEnvAnd<'tcx, T> {\n+    pub fn into_parts(self) -> (ParamEnv<'tcx>, T) {\n+        (self.param_env, self.value)\n     }\n }\n \n@@ -2357,54 +2358,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Construct a parameter environment suitable for static contexts or other contexts where there\n-    /// are no free type/lifetime parameters in scope.\n-    pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n-        ty::ParameterEnvironment {\n-            caller_bounds: Slice::empty(),\n-            is_copy_cache: RefCell::new(FxHashMap()),\n-            is_sized_cache: RefCell::new(FxHashMap()),\n-            is_freeze_cache: RefCell::new(FxHashMap()),\n-        }\n-    }\n-\n-    /// See `ParameterEnvironment` struct def'n for details.\n-    pub fn parameter_environment(self, def_id: DefId) -> ParameterEnvironment<'gcx> {\n-        //\n-        // Compute the bounds on Self and the type parameters.\n-        //\n-\n-        let tcx = self.global_tcx();\n-        let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-        let predicates = bounds.predicates;\n-\n-        // Finally, we have to normalize the bounds in the environment, in\n-        // case they contain any associated type projections. This process\n-        // can yield errors if the put in illegal associated types, like\n-        // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n-        // report these errors right here; this doesn't actually feel\n-        // right to me, because constructing the environment feels like a\n-        // kind of a \"idempotent\" action, but I'm not sure where would be\n-        // a better place. In practice, we construct environments for\n-        // every fn once during type checking, and we'll abort if there\n-        // are any errors at that point, so after type checking you can be\n-        // sure that this will succeed without errors anyway.\n-        //\n-\n-        let unnormalized_env = ty::ParameterEnvironment {\n-            caller_bounds: tcx.intern_predicates(&predicates),\n-            is_copy_cache: RefCell::new(FxHashMap()),\n-            is_sized_cache: RefCell::new(FxHashMap()),\n-            is_freeze_cache: RefCell::new(FxHashMap()),\n-        };\n-\n-        let body_id = self.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n-            self.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n-        });\n-        let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n-        traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n-    }\n-\n     pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n         self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n     }\n@@ -2564,14 +2517,45 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n         })\n }\n \n+/// See `ParamEnv` struct def'n for details.\n+fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> ParamEnv<'tcx> {\n+    // Compute the bounds on Self and the type parameters.\n+\n+    let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n+    let predicates = bounds.predicates;\n+\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+\n+    let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates));\n+\n+    let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n+        tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+    });\n+    let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n+    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n+}\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n+    util::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n         def_span,\n+        param_env,\n         trait_of_item,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n@@ -2585,6 +2569,7 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         adt_dtorck_constraint,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n+        param_env,\n         ..*providers\n     };\n }"}, {"sha": "01fed11fc97affd7e8ad22cb0f275e7b5ec1faef", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 143, "deletions": 253, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -15,29 +15,24 @@ use hir::map::DefPathData;\n use infer::InferCtxt;\n use ich::{StableHashingContext, NodeIdHashingMode};\n use traits::{self, Reveal};\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n-use ty::ParameterEnvironment;\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n-use util::nodemap::{FxHashMap, FxHashSet};\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n-use std::cell::RefCell;\n use std::cmp;\n use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use hir;\n-\n type Disr = ConstInt;\n \n pub trait IntTypeExt {\n@@ -152,7 +147,18 @@ pub enum Representability {\n     SelfRecursive(Vec<Span>),\n }\n \n-impl<'tcx> ParameterEnvironment<'tcx> {\n+impl<'tcx> ty::ParamEnv<'tcx> {\n+    /// Construct a trait environment suitable for contexts where\n+    /// there are no where clauses in scope.\n+    pub fn empty() -> Self {\n+        Self::new(ty::Slice::empty())\n+    }\n+\n+    /// Construct a trait environment with the given set of predicates.\n+    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>) -> Self {\n+        ty::ParamEnv { caller_bounds }\n+    }\n+\n     pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError> {\n@@ -711,152 +717,28 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n }\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n-    fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   param_env: &ParameterEnvironment<'tcx>,\n-                   def_id: DefId,\n-                   cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n-                   span: Span) -> bool\n-    {\n-        if self.has_param_types() || self.has_self_ty() {\n-            if let Some(result) = cache.borrow().get(self) {\n-                return *result;\n-            }\n-        }\n-        let result =\n-            tcx.infer_ctxt(param_env.clone(), Reveal::UserFacing)\n-            .enter(|infcx| {\n-                traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n-            });\n-        if self.has_param_types() || self.has_self_ty() {\n-            cache.borrow_mut().insert(self, result);\n-        }\n-        return result;\n-    }\n-\n-    // FIXME (@jroesch): I made this public to use it, not sure if should be private\n-    pub fn moves_by_default(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            param_env: &ParameterEnvironment<'tcx>,\n-                            span: Span) -> bool {\n-        if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n-        }\n-\n-        assert!(!self.needs_infer());\n-\n-        // Fast-path for primitive types\n-        let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyNever |\n-            TyRawPtr(..) | TyFnDef(..) | TyFnPtr(_) | TyRef(_, TypeAndMut {\n-                mutbl: hir::MutImmutable, ..\n-            }) => Some(false),\n-\n-            TyStr | TyRef(_, TypeAndMut {\n-                mutbl: hir::MutMutable, ..\n-            }) => Some(true),\n-\n-            TyArray(..) | TySlice(..) | TyDynamic(..) | TyTuple(..) |\n-            TyClosure(..) | TyAdt(..) | TyAnon(..) |\n-            TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n-        }.unwrap_or_else(|| {\n-            !self.impls_bound(tcx, param_env,\n-                              tcx.require_lang_item(lang_items::CopyTraitLangItem),\n-                              &param_env.is_copy_cache, span) });\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n-            } else {\n-                TypeFlags::MOVENESS_CACHED\n-            });\n-        }\n-\n-        result\n+    pub fn moves_by_default(&'tcx self,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            param_env: ty::ParamEnv<'tcx>,\n+                            span: Span)\n+                            -> bool {\n+        !tcx.at(span).is_copy_raw(param_env.and(self))\n     }\n \n-    #[inline]\n-    pub fn is_sized(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    param_env: &ParameterEnvironment<'tcx>,\n-                    span: Span) -> bool\n+    pub fn is_sized(&'tcx self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    param_env: ty::ParamEnv<'tcx>,\n+                    span: Span)-> bool\n     {\n-        if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::IS_SIZED);\n-        }\n-\n-        self.is_sized_uncached(tcx, param_env, span)\n-    }\n-\n-    fn is_sized_uncached(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         param_env: &ParameterEnvironment<'tcx>,\n-                         span: Span) -> bool {\n-        assert!(!self.needs_infer());\n-\n-        // Fast-path for primitive types\n-        let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n-\n-            TyStr | TyDynamic(..) | TySlice(_) => Some(false),\n-\n-            TyAdt(..) | TyProjection(..) | TyParam(..) |\n-            TyInfer(..) | TyAnon(..) | TyError => None\n-        }.unwrap_or_else(|| {\n-            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::SizedTraitLangItem),\n-                              &param_env.is_sized_cache, span) });\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n-            } else {\n-                TypeFlags::SIZEDNESS_CACHED\n-            });\n-        }\n-\n-        result\n+        tcx.at(span).is_sized_raw(param_env.and(self))\n     }\n \n-    /// Returns `true` if and only if there are no `UnsafeCell`s\n-    /// nested within the type (ignoring `PhantomData` or pointers).\n-    #[inline]\n-    pub fn is_freeze(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     param_env: &ParameterEnvironment<'tcx>,\n-                     span: Span) -> bool\n+    pub fn is_freeze(&'tcx self,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     param_env: ty::ParamEnv<'tcx>,\n+                     span: Span)-> bool\n     {\n-        if self.flags.get().intersects(TypeFlags::FREEZENESS_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::IS_FREEZE);\n-        }\n-\n-        self.is_freeze_uncached(tcx, param_env, span)\n-    }\n-\n-    fn is_freeze_uncached(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: &ParameterEnvironment<'tcx>,\n-                          span: Span) -> bool {\n-        assert!(!self.needs_infer());\n-\n-        // Fast-path for primitive types\n-        let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyStr | TyNever => Some(true),\n-\n-            TyArray(..) | TySlice(_) |\n-            TyTuple(..) | TyClosure(..) | TyAdt(..) |\n-            TyDynamic(..) | TyProjection(..) | TyParam(..) |\n-            TyInfer(..) | TyAnon(..) | TyError => None\n-        }.unwrap_or_else(|| {\n-            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::FreezeTraitLangItem),\n-                              &param_env.is_freeze_cache, span) });\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::FREEZENESS_CACHED | TypeFlags::IS_FREEZE\n-            } else {\n-                TypeFlags::FREEZENESS_CACHED\n-            });\n-        }\n-\n-        result\n+        tcx.at(span).is_freeze_raw(param_env.and(self))\n     }\n \n     /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n@@ -866,112 +748,11 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n     #[inline]\n-    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    param_env: &ty::ParameterEnvironment<'tcx>) -> bool {\n-        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n-        }\n-\n-        self.needs_drop_uncached(tcx, param_env, &mut FxHashSet())\n-    }\n-\n-    fn needs_drop_inner(&'tcx self,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: &ty::ParameterEnvironment<'tcx>,\n-                        stack: &mut FxHashSet<Ty<'tcx>>)\n-                        -> bool {\n-        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n-        }\n-\n-        // This should be reported as an error by `check_representable`.\n-        //\n-        // Consider the type as not needing drop in the meanwhile to avoid\n-        // further errors.\n-        if let Some(_) = stack.replace(self) {\n-            return false;\n-        }\n-\n-        let needs_drop = self.needs_drop_uncached(tcx, param_env, stack);\n-\n-        // \"Pop\" the cycle detection \"stack\".\n-        stack.remove(self);\n-\n-        needs_drop\n-    }\n-\n-    fn needs_drop_uncached(&'tcx self,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           param_env: &ty::ParameterEnvironment<'tcx>,\n-                           stack: &mut FxHashSet<Ty<'tcx>>)\n-                           -> bool {\n-        assert!(!self.needs_infer());\n-\n-        let result = match self.sty {\n-            // Fast-path for primitive types\n-            ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-            ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n-\n-            // Issue #22536: We first query type_moves_by_default.  It sees a\n-            // normalized version of the type, and therefore will definitely\n-            // know whether the type implements Copy (and thus needs no\n-            // cleanup/drop/zeroing) ...\n-            _ if !self.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n-\n-            // ... (issue #22536 continued) but as an optimization, still use\n-            // prior logic of asking for the structural \"may drop\".\n-\n-            // FIXME(#22815): Note that this is a conservative heuristic;\n-            // it may report that the type \"may drop\" when actual type does\n-            // not actually have a destructor associated with it. But since\n-            // the type absolutely did not have the `Copy` bound attached\n-            // (see above), it is sound to treat it as having a destructor.\n-\n-            // User destructors are the only way to have concrete drop types.\n-            ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n-\n-            // Can refer to a type which may drop.\n-            // FIXME(eddyb) check this against a ParameterEnvironment.\n-            ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n-            ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n-\n-            // Structural recursion.\n-            ty::TyArray(ty, _) | ty::TySlice(ty) => {\n-                ty.needs_drop_inner(tcx, param_env, stack)\n-            }\n-\n-            ty::TyClosure(def_id, ref substs) => {\n-                substs.upvar_tys(def_id, tcx)\n-                    .any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n-            }\n-\n-            ty::TyTuple(ref tys, _) => {\n-                tys.iter().any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n-            }\n-\n-            // unions don't have destructors regardless of the child types\n-            ty::TyAdt(def, _) if def.is_union() => false,\n-\n-            ty::TyAdt(def, substs) => {\n-                def.variants.iter().any(|v| {\n-                    v.fields.iter().any(|f| {\n-                        f.ty(tcx, substs).needs_drop_inner(tcx, param_env, stack)\n-                    })\n-                })\n-            }\n-        };\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::NEEDS_DROP_CACHED | TypeFlags::NEEDS_DROP\n-            } else {\n-                TypeFlags::NEEDS_DROP_CACHED\n-            });\n-        }\n-\n-        result\n+    pub fn needs_drop(&'tcx self,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>)\n+                      -> bool {\n+        tcx.needs_drop_raw(param_env.and(self))\n     }\n \n     #[inline]\n@@ -1158,3 +939,112 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         r\n     }\n }\n+\n+fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                         -> bool\n+{\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+}\n+\n+fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                          -> bool\n+{\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+}\n+\n+fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                           -> bool\n+{\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+}\n+\n+fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                            -> bool\n+{\n+    let (param_env, ty) = query.into_parts();\n+\n+    let needs_drop = |ty: Ty<'tcx>| -> bool {\n+        match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n+            Ok(v) => v,\n+            Err(_) => {\n+                // Cycles should be reported as an error by `check_representable`.\n+                //\n+                // Consider the type as not needing drop in the meanwhile to avoid\n+                // further errors.\n+                false\n+            }\n+        }\n+    };\n+\n+    assert!(!ty.needs_infer());\n+\n+    match ty.sty {\n+        // Fast-path for primitive types\n+        ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+        ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+\n+        // Issue #22536: We first query type_moves_by_default.  It sees a\n+        // normalized version of the type, and therefore will definitely\n+        // know whether the type implements Copy (and thus needs no\n+        // cleanup/drop/zeroing) ...\n+        _ if !ty.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n+\n+        // ... (issue #22536 continued) but as an optimization, still use\n+        // prior logic of asking for the structural \"may drop\".\n+\n+        // FIXME(#22815): Note that this is a conservative heuristic;\n+        // it may report that the type \"may drop\" when actual type does\n+        // not actually have a destructor associated with it. But since\n+        // the type absolutely did not have the `Copy` bound attached\n+        // (see above), it is sound to treat it as having a destructor.\n+\n+        // User destructors are the only way to have concrete drop types.\n+        ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+\n+        // Can refer to a type which may drop.\n+        // FIXME(eddyb) check this against a ParamEnv.\n+        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n+        ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+\n+        // Structural recursion.\n+        ty::TyArray(ty, _) | ty::TySlice(ty) => needs_drop(ty),\n+\n+        ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n+\n+        ty::TyTuple(ref tys, _) => tys.iter().cloned().any(needs_drop),\n+\n+        // unions don't have destructors regardless of the child types\n+        ty::TyAdt(def, _) if def.is_union() => false,\n+\n+        ty::TyAdt(def, substs) =>\n+            def.variants.iter().any(\n+                |variant| variant.fields.iter().any(\n+                    |field| needs_drop(field.ty(tcx, substs)))),\n+    }\n+}\n+\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_copy_raw,\n+        is_sized_raw,\n+        is_freeze_raw,\n+        needs_drop_raw,\n+        ..*providers\n+    };\n+}"}, {"sha": "340e4f2cfccbcdba96cacd9f1e35f786fcfad6e3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -504,13 +504,7 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ParameterEnvironment({:?})\", self.caller_bounds)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::RegionKind {\n+impl fmt::Display for ty::RegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n             return write!(f, \"{:?}\", *self);"}, {"sha": "722ec6424fecec3dc9c0393b1df4989b022e16f2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -90,7 +90,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: &'a ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -197,7 +197,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         dfcx_loans: dfcx_loans,\n         move_data: move_data,\n         all_loans: all_loans,\n-        param_env: &infcx.parameter_environment\n+        param_env: &infcx.param_env\n     };\n     euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx).consume_body(body);\n }"}, {"sha": "e0d86ff23f8621a6aae97415ee2919e2990055f8", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -44,8 +44,8 @@ impl MirPass for ElaborateDrops {\n             _ => return\n         }\n         let id = src.item_id();\n-        let param_env = tcx.parameter_environment(tcx.hir.local_def_id(id));\n-        let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n+        let param_env = tcx.param_env(tcx.hir.local_def_id(id));\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {\n@@ -196,7 +196,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         self.ctxt.tcx\n     }\n \n-    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.ctxt.param_env()\n     }\n \n@@ -289,8 +289,9 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n \n impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_data(&self) -> &'b MoveData<'tcx> { &self.env.move_data }\n-    fn param_env(&self) -> &'b ty::ParameterEnvironment<'tcx> {\n-        &self.env.param_env\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.env.param_env\n     }\n \n     fn initialization_data_at(&self, loc: Location) -> InitializationData {"}, {"sha": "931cdf4f6861208d048fad342af8256c502ae442", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n+use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n@@ -191,7 +191,7 @@ pub struct MovePathLookup<'tcx> {\n struct MoveDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: &'a ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     data: MoveData<'tcx>,\n }\n \n@@ -203,7 +203,7 @@ pub enum MovePathError {\n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn new(mir: &'a Mir<'tcx>,\n            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: &'a ParameterEnvironment<'tcx>)\n+           param_env: ty::ParamEnv<'tcx>)\n            -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n@@ -370,15 +370,15 @@ impl<'tcx> MovePathLookup<'tcx> {\n impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn gather_moves(mir: &Mir<'tcx>,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: &ParameterEnvironment<'tcx>)\n+                        param_env: ty::ParamEnv<'tcx>)\n                         -> Self {\n         gather_moves(mir, tcx, param_env)\n     }\n }\n \n fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: &ParameterEnvironment<'tcx>)\n+                          param_env: ty::ParamEnv<'tcx>)\n                           -> MoveData<'tcx> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n "}, {"sha": "2eb064305e87c0626999e4951acf956089148332", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -51,7 +51,7 @@ fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem>\n \n pub struct MoveDataParamEnv<'tcx> {\n     move_data: MoveData<'tcx>,\n-    param_env: ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n@@ -65,8 +65,8 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     // steals it, but it forces the `borrowck` query.\n     let mir = &tcx.mir_validated(def_id).borrow();\n \n-    let param_env = tcx.parameter_environment(def_id);\n-    let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n+    let param_env = tcx.param_env(def_id);\n+    let move_data = MoveData::gather_moves(mir, tcx, param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n@@ -325,7 +325,7 @@ fn on_all_drop_children_bits<'a, 'tcx, F>(\n         let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-        if ty.needs_drop(tcx, &ctxt.param_env) {\n+        if ty.needs_drop(tcx, ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")\n@@ -359,7 +359,7 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n     let move_data = &ctxt.move_data;\n-    let param_env = &ctxt.param_env;\n+    let param_env = ctxt.param_env;\n     debug!(\"drop_flag_effects_for_location({:?})\", loc);\n \n     // first, move out of the RHS"}, {"sha": "f7c20542cbf2e98c685bd4b56166d7efb22e2529", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -535,7 +535,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                      lp: &LoanPath<'tcx>,\n                                      the_move: &move_data::Move,\n                                      moved_lp: &LoanPath<'tcx>,\n-                                     _param_env: &ty::ParameterEnvironment<'tcx>) {\n+                                     _param_env: &ty::ParamEnv<'tcx>) {\n         let (verb, verb_participle) = match use_kind {\n             MovedInUse => (\"use\", \"used\"),\n             MovedInCapture => (\"capture\", \"captured\"),"}, {"sha": "7ed5f620816e11d5cca9c3ddf10fdabf3fdcb47c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n             region_maps: &self.tcx.region_maps(def_id),\n-            param_env: &self.tcx.parameter_environment(def_id)\n+            param_env: self.tcx.param_env(def_id)\n         }.visit_body(self.tcx.hir.body(b));\n     }\n }\n@@ -69,7 +69,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     region_maps: &'a RegionMaps,\n }\n \n@@ -518,7 +518,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::UserFacing).enter(|infcx| {\n+    cx.tcx.infer_ctxt((cx.tables, cx.param_env), Reveal::UserFacing).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };"}, {"sha": "39b8e568ab48d959f5a1e1a5a573c7b0a3b59a36", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -527,13 +527,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if def.has_dtor(cx.tcx) {\n             return;\n         }\n-        let parameter_environment = cx.tcx.empty_parameter_environment();\n-        // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n-        // method\n-        if !ty.moves_by_default(cx.tcx, &parameter_environment, item.span) {\n+        let param_env = ty::ParamEnv::empty();\n+        if !ty.moves_by_default(cx.tcx, param_env, item.span) {\n             return;\n         }\n-        if parameter_environment.can_type_implement_copy(cx.tcx, ty, item.span).is_ok() {\n+        if param_env.can_type_implement_copy(cx.tcx, ty, item.span).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\\n@@ -990,7 +988,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    let param_env = tcx.parameter_environment(method.def_id);\n+                    let param_env = tcx.param_env(method.def_id);\n                     tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n@@ -1258,7 +1256,8 @@ impl LintPass for UnionsWithDropFields {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n-            let param_env = &ctx.tcx.parameter_environment(ctx.tcx.hir.local_def_id(item.id));\n+            let item_def_id = ctx.tcx.hir.local_def_id(item.id);\n+            let param_env = ctx.tcx.param_env(item_def_id);\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, param_env) {"}, {"sha": "9e151596a1ab5da35de92a0d6d6bf6bd8792baec", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -172,7 +172,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = tcx.parameter_environment(tcx.hir.local_def_id(ctor_id));\n+        let pe = tcx.param_env(tcx.hir.local_def_id(ctor_id));\n         tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);"}, {"sha": "f61e2545f71fec7466433d5ccad2114c6f07ca21", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                   type with inference types/regions\",\n                  ty);\n         });\n-        ty.needs_drop(self.tcx.global_tcx(), &self.infcx.parameter_environment)\n+        ty.needs_drop(self.tcx.global_tcx(), self.infcx.param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "428685d7f5058cf1dbdaeabb0251eb9096352e3d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -40,8 +40,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                        -> &'tcx Mir<'tcx>\n {\n     debug!(\"make_shim({:?})\", instance);\n-    let did = instance.def_id();\n-    let param_env = tcx.parameter_environment(did);\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) =>\n@@ -98,7 +96,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             )\n         }\n         ty::InstanceDef::DropGlue(def_id, ty) => {\n-            build_drop_shim(tcx, &param_env, def_id, ty)\n+            build_drop_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n@@ -144,7 +142,6 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n }\n \n fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-                             param_env: &ty::ParameterEnvironment<'tcx>,\n                              def_id: DefId,\n                              ty: Option<Ty<'tcx>>)\n                              -> Mir<'tcx>\n@@ -189,10 +186,12 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(..) = ty {\n         let patch = {\n+            let param_env = tcx.param_env(def_id);\n             let mut elaborator = DropShimElaborator {\n                 mir: &mir,\n                 patch: MirPatch::new(&mir),\n-                tcx, param_env\n+                tcx,\n+                param_env\n             };\n             let dropee = Lvalue::Local(Local::new(1+0)).deref();\n             let resume_block = elaborator.patch.resume_block();\n@@ -218,7 +217,7 @@ pub struct DropShimElaborator<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     patch: MirPatch<'tcx>,\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> fmt::Debug for DropShimElaborator<'a, 'tcx> {\n@@ -233,7 +232,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n     fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n     fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n-    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> { self.param_env }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n         if let DropFlagMode::Shallow = mode {"}, {"sha": "edb2f44d18e35423afe37ec1bebed8a9bca2f5d8", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // FIXME: Give a bonus to functions with only a single caller\n \n         let def_id = tcx.hir.local_def_id(self.source.item_id());\n-        let param_env = tcx.parameter_environment(def_id);\n+        let param_env = tcx.param_env(def_id);\n \n         let mut first_block = true;\n         let mut cost = 0;\n@@ -253,7 +253,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     // a regular goto.\n                     let ty = location.ty(&callee_mir, tcx).subst(tcx, callsite.substs);\n                     let ty = ty.to_ty(tcx);\n-                    if ty.needs_drop(tcx, &param_env) {\n+                    if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n                             work_list.push(unwind);\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParameterEnvironment<'tcx>,\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n     tcx.infer_ctxt(param_env, traits::Reveal::All).enter(|infcx| {\n         ty.layout(&infcx).ok().map(|layout| {"}, {"sha": "4e84cbe6fecb130bfd268a39cdfab4c0edc345d2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> Qualif {\n     /// Remove flags which are impossible for the given type.\n     fn restrict(&mut self, ty: Ty<'tcx>,\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                param_env: &ty::ParameterEnvironment<'tcx>) {\n+                param_env: ty::ParamEnv<'tcx>) {\n         if ty.is_freeze(tcx, param_env, DUMMY_SP) {\n             *self = *self - Qualif::MUTABLE_INTERIOR;\n         }\n@@ -128,7 +128,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n@@ -139,7 +139,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParameterEnvironment<'tcx>,\n+           param_env: ty::ParamEnv<'tcx>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     /// Add the given type's qualification to self.qualif.\n     fn add_type(&mut self, ty: Ty<'tcx>) {\n         self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n-        self.qualif.restrict(ty, self.tcx, &self.param_env);\n+        self.qualif.restrict(ty, self.tcx, self.param_env);\n     }\n \n     /// Within the provided closure, self.qualif will start\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                            static, use a constant instead\");\n                             }\n                             let ty = lvalue.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            this.qualif.restrict(ty, this.tcx, &this.param_env);\n+                            this.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n \n                         ProjectionElem::ConstantIndex {..} |\n@@ -937,7 +937,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Qualif::NOT_CONST.bits();\n     }\n \n-    let param_env = tcx.parameter_environment(def_id);\n+    let param_env = tcx.param_env(def_id);\n \n     let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, Mode::Const);\n     qualifier.qualify_const().bits()\n@@ -965,7 +965,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };\n-        let param_env = tcx.parameter_environment(def_id);\n+        let param_env = tcx.param_env(def_id);\n \n         if mode == Mode::Fn || mode == Mode::ConstFn {\n             // This is ugly because Qualifier holds onto mir,"}, {"sha": "6d9603ea459d40941bc1225945f8d55ace1b1eef", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -751,7 +751,7 @@ impl MirPass for TypeckMir {\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let param_env = tcx.parameter_environment(def_id);\n+        let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, item_id);\n             {"}, {"sha": "585840ce1e509f17df1558be01671169b234710d", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -56,7 +56,7 @@ pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn mir(&self) -> &'a Mir<'tcx>;\n     fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx>;\n-    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx>;\n+    fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n     fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>>;"}, {"sha": "25845c5768e8c8629a12efee4bccc4d9894ef8c0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -58,7 +58,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     in_fn: bool,\n     promotable: bool,\n     mut_rvalue_borrows: NodeSet,\n-    param_env: ty::ParameterEnvironment<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -85,11 +85,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     // Adds the worst effect out of all the values of one type.\n     fn add_type(&mut self, ty: Ty<'gcx>) {\n-        if !ty.is_freeze(self.tcx, &self.param_env, DUMMY_SP) {\n+        if !ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n             self.promotable = false;\n         }\n \n-        if ty.needs_drop(self.tcx, &self.param_env) {\n+        if ty.needs_drop(self.tcx, self.param_env) {\n             self.promotable = false;\n         }\n     }\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-            let param_env = infcx.parameter_environment.clone();\n+            let param_env = infcx.param_env.clone();\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             let region_maps = &self.tcx.region_maps(item_def_id);;\n             euv::ExprUseVisitor::new(self, region_maps, &infcx).consume_body(body);\n@@ -466,7 +466,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         in_fn: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),\n-        param_env: tcx.empty_parameter_environment(),\n+        param_env: ty::ParamEnv::empty(),\n     }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "0dece586c930dabfd39226e4ec8e817161049536", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -79,7 +79,6 @@ impl Stats {\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     exported_symbols: NodeSet,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    empty_param_env: ty::ParameterEnvironment<'tcx>,\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n@@ -315,23 +314,22 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n         SharedCrateContext {\n             exported_symbols: exported_symbols,\n-            empty_param_env: tcx.empty_parameter_environment(),\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n         }\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, &self.empty_param_env)\n+        ty.needs_drop(self.tcx, ty::ParamEnv::empty())\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n+        ty.is_sized(self.tcx, ty::ParamEnv::empty(), DUMMY_SP)\n     }\n \n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, &self.empty_param_env, DUMMY_SP)\n+        ty.is_freeze(self.tcx, ty::ParamEnv::empty(), DUMMY_SP)\n     }\n \n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {"}, {"sha": "767cf8f48cfeabfc3989661bebb1ad150e7ed358", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -165,10 +165,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Finally we register each of these predicates as an obligation in\n     // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n \n-    // Create a parameter environment that represents the implementation's\n-    // method.\n-    let impl_param_env = tcx.parameter_environment(impl_m.def_id);\n-\n     // Create mapping from impl to skolemized.\n     let impl_to_skol_substs = Substs::identity_for_item(tcx, impl_m.def_id);\n \n@@ -216,19 +212,18 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n-    let trait_param_env = impl_param_env.with_caller_bounds(\n-        tcx.intern_predicates(&hybrid_preds.predicates));\n-    let trait_param_env = traits::normalize_param_env_or_error(tcx,\n-                                                               impl_m.def_id,\n-                                                               trait_param_env,\n-                                                               normalize_cause.clone());\n-\n-    tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n+    let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates));\n+    let param_env = traits::normalize_param_env_or_error(tcx,\n+                                                         impl_m.def_id,\n+                                                         param_env,\n+                                                         normalize_cause.clone());\n+\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n-               infcx.parameter_environment.caller_bounds);\n+               infcx.param_env.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n@@ -350,7 +345,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let region_maps = RegionMaps::new();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(\n-                &infcx.parameter_environment.caller_bounds);\n+                &infcx.param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n         } else {\n             let fcx = FnCtxt::new(&inh, impl_m_node_id);"}, {"sha": "3ed0da05dc2c2f800e8916017a22e047de4e2069", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -79,7 +79,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = tcx.parameter_environment(self_type_did);\n+    let impl_param_env = tcx.param_env(self_type_did);\n     tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|ref infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "9ad72b2a137ea2ea10112bfb7ddb61ed1a0b9f23", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n-        let bounds: Vec<_> = self.parameter_environment\n+        let bounds: Vec<_> = self.param_env\n             .caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n@@ -893,7 +893,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let caller_predicates = self.parameter_environment.caller_bounds.to_vec();\n+        let caller_predicates = self.param_env.caller_bounds.to_vec();\n         for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n             .filter_map(|p| p.to_opt_poly_trait_ref())\n             .filter(|b| b.def_id() == trait_def_id) {"}, {"sha": "24a88140cf041014af2370a1c5345beb4404f29d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = tcx.parameter_environment(def_id);\n+        let param_env = tcx.param_env(def_id);\n         InheritedBuilder {\n             infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing),\n             def_id,\n@@ -1561,7 +1561,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let index = generics.type_param_to_index[&def_id.index];\n         ty::GenericPredicates {\n             parent: None,\n-            predicates: self.parameter_environment.caller_bounds.iter().filter(|predicate| {\n+            predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n                 match **predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         data.0.self_ty().is_param(index)"}, {"sha": "b29bf01ba1996d472aba27ff1226c376583f2645", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let subject = self.tcx.hir.local_def_id(item_id);\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(subject));\n         rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.parameter_environment.caller_bounds);\n+            &self.param_env.caller_bounds);\n         rcx.relate_free_regions(wf_tys, item_id, span);\n         rcx.visit_region_obligations(item_id);\n         rcx.resolve_regions_and_report_errors();\n@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.parameter_environment.caller_bounds);\n+            &self.param_env.caller_bounds);\n \n         rcx.resolve_regions_and_report_errors();\n \n@@ -1682,7 +1682,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n                                         -> Vec<ty::Region<'tcx>>\n     {\n-        let param_env = &self.parameter_environment;\n+        let param_env = &self.param_env;\n \n         // To start, collect bounds from user:\n         let mut param_bounds = self.tcx.required_region_bounds(generic.to_ty(self.tcx),"}, {"sha": "ff5599fb1bdbf46c24a1dd0c8474360787035b79", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -105,7 +105,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            self_type);\n \n     let span = tcx.hir.span(impl_node_id);\n-    let param_env = tcx.parameter_environment(impl_did);\n+    let param_env = tcx.param_env(impl_did);\n     assert!(!self_type.has_escaping_regions());\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n@@ -199,7 +199,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            target);\n \n     let span = tcx.hir.span(impl_node_id);\n-    let param_env = tcx.parameter_environment(impl_did);\n+    let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -387,7 +387,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Finally, resolve all regions.\n         let region_maps = RegionMaps::new();\n         let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+        free_regions.relate_free_regions_from_predicates(&infcx.param_env\n             .caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n "}, {"sha": "b41e8e9226b326e43f87d5eacf0d83f2d27064c0", "filename": "src/test/run-make/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa25a7df3a1101a1dac611f3e45fa5b09836d27/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=9fa25a7df3a1101a1dac611f3e45fa5b09836d27", "patch": "@@ -20,6 +20,8 @@ extern \"rust-intrinsic\" {\n trait Sized {}\n #[lang = \"copy\"]\n trait Copy {}\n+#[lang = \"freeze\"]\n+trait Freeze {}\n \n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_u8(x: *mut u8) {"}]}