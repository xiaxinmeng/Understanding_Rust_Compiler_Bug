{"sha": "09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWEwY2E3ZTVmYjVkM2UxMjNkYzM4OTI3YjE1OGM3OThiNjg5YWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-29T15:23:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-29T15:23:57Z"}, "message": "rename world -> analysis impl", "tree": {"sha": "6e75f5a390d6b84e8d195ad2170d8876f118067c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e75f5a390d6b84e8d195ad2170d8876f118067c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "html_url": "https://github.com/rust-lang/rust/commit/09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f968ee43047af9d7bcf2953f1b367c38cb8bf1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f968ee43047af9d7bcf2953f1b367c38cb8bf1b", "html_url": "https://github.com/rust-lang/rust/commit/0f968ee43047af9d7bcf2953f1b367c38cb8bf1b"}], "stats": {"total": 583, "additions": 298, "deletions": 285}, "files": [{"sha": "6c06e0b32b318a6697f7525e5b3257b67602a9a2", "filename": "crates/libanalysis/src/api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fapi.rs?ref=09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "patch": "@@ -1,7 +1,7 @@\n use relative_path::RelativePathBuf;\n use libsyntax2::{File, TextRange, TextUnit, AtomEdit};\n use libeditor;\n-use {World, FileId, Query};\n+use {imp::AnalysisImpl, FileId, Query};\n \n pub use libeditor::{\n     LocalEdit, StructureNode, LineIndex, FileSymbol,\n@@ -49,7 +49,7 @@ pub struct Diagnostic {\n \n #[derive(Clone, Debug)]\n pub struct Analysis {\n-    pub(crate) imp: World\n+    pub(crate) imp: AnalysisImpl\n }\n \n impl Analysis {"}, {"sha": "76f0c0c872d54e304309844b4069b51996fa941f", "filename": "crates/libanalysis/src/imp.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "patch": "@@ -0,0 +1,291 @@\n+use std::{\n+    sync::{\n+        Arc,\n+        atomic::{AtomicBool, Ordering::SeqCst},\n+    },\n+    fmt,\n+    time::Instant,\n+    collections::HashMap,\n+    panic,\n+};\n+\n+use libsyntax2::{\n+    TextUnit, TextRange, SmolStr, File, AstNode,\n+    SyntaxKind::*,\n+    ast::{self, NameOwner},\n+};\n+use rayon::prelude::*;\n+use once_cell::sync::OnceCell;\n+use libeditor::{self, FileSymbol, LineIndex, find_node_at_offset};\n+\n+use {\n+    FileId, FileResolver, Query, Diagnostic, SourceChange, FileSystemEdit,\n+    module_map::Problem,\n+    symbol_index::FileSymbols,\n+    module_map::ModuleMap,\n+};\n+\n+\n+pub(crate) struct AnalysisImpl {\n+    pub(crate) needs_reindex: AtomicBool,\n+    pub(crate) file_resolver: Arc<FileResolver>,\n+    pub(crate) data: Arc<WorldData>,\n+}\n+\n+impl fmt::Debug for AnalysisImpl {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (&*self.data).fmt(f)\n+    }\n+}\n+\n+impl Clone for AnalysisImpl {\n+    fn clone(&self) -> AnalysisImpl {\n+        AnalysisImpl {\n+            needs_reindex: AtomicBool::new(self.needs_reindex.load(SeqCst)),\n+            file_resolver: Arc::clone(&self.file_resolver),\n+            data: Arc::clone(&self.data),\n+        }\n+    }\n+}\n+\n+impl AnalysisImpl {\n+    pub fn file_syntax(&self, file_id: FileId) -> File {\n+        self.file_data(file_id).syntax().clone()\n+    }\n+\n+    pub fn file_line_index(&self, id: FileId) -> LineIndex {\n+        let data = self.file_data(id);\n+        data\n+            .lines\n+            .get_or_init(|| LineIndex::new(&data.text))\n+            .clone()\n+    }\n+\n+    pub fn world_symbols(&self, mut query: Query) -> Vec<(FileId, FileSymbol)> {\n+        self.reindex();\n+        self.data.file_map.iter()\n+            .flat_map(move |(id, data)| {\n+                let symbols = data.symbols();\n+                query.process(symbols).into_iter().map(move |s| (*id, s))\n+            })\n+            .collect()\n+    }\n+\n+    pub fn parent_module(&self, id: FileId) -> Vec<(FileId, FileSymbol)> {\n+        let module_map = &self.data.module_map;\n+        let id = module_map.file2module(id);\n+        module_map\n+            .parent_modules(\n+                id,\n+                &*self.file_resolver,\n+                &|file_id| self.file_syntax(file_id),\n+            )\n+            .into_iter()\n+            .map(|(id, name, node)| {\n+                let id = module_map.module2file(id);\n+                let sym = FileSymbol {\n+                    name,\n+                    node_range: node.range(),\n+                    kind: MODULE,\n+                };\n+                (id, sym)\n+            })\n+            .collect()\n+    }\n+\n+    pub fn approximately_resolve_symbol(\n+        &self,\n+        id: FileId,\n+        offset: TextUnit,\n+    ) -> Vec<(FileId, FileSymbol)> {\n+        let file = self.file_syntax(id);\n+        let syntax = file.syntax();\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n+            return self.index_resolve(name_ref);\n+        }\n+        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n+            if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n+                if module.has_semi() {\n+                    let file_ids = self.resolve_module(id, module);\n+\n+                    let res = file_ids.into_iter().map(|id| {\n+                        let name = module.name()\n+                            .map(|n| n.text())\n+                            .unwrap_or_else(|| SmolStr::new(\"\"));\n+                        let symbol = FileSymbol {\n+                            name,\n+                            node_range: TextRange::offset_len(0.into(), 0.into()),\n+                            kind: MODULE,\n+                        };\n+                        (id, symbol)\n+                    }).collect();\n+\n+                    return res;\n+                }\n+            }\n+        }\n+        vec![]\n+    }\n+\n+    pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n+        let syntax = self.file_syntax(file_id);\n+        let mut res = libeditor::diagnostics(&syntax)\n+            .into_iter()\n+            .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n+            .collect::<Vec<_>>();\n+\n+        self.data.module_map.problems(\n+            file_id,\n+            &*self.file_resolver,\n+            &|file_id| self.file_syntax(file_id),\n+            |name_node, problem| {\n+                let diag = match problem {\n+                    Problem::UnresolvedModule { candidate } => {\n+                        let create_file = FileSystemEdit::CreateFile {\n+                            anchor: file_id,\n+                            path: candidate.clone(),\n+                        };\n+                        let fix = SourceChange {\n+                            label: \"create module\".to_string(),\n+                            source_file_edits: Vec::new(),\n+                            file_system_edits: vec![create_file],\n+                            cursor_position: None,\n+                        };\n+                        Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            message: \"unresolved module\".to_string(),\n+                            fix: Some(fix),\n+                        }\n+                    }\n+                    Problem::NotDirOwner { move_to, candidate } => {\n+                        let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n+                        let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n+                        let fix = SourceChange {\n+                            label: \"move file and create module\".to_string(),\n+                            source_file_edits: Vec::new(),\n+                            file_system_edits: vec![move_file, create_file],\n+                            cursor_position: None,\n+                        };\n+                        Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            message: \"can't declare module at this location\".to_string(),\n+                            fix: Some(fix),\n+                        }\n+                    }\n+                };\n+                res.push(diag)\n+            }\n+        );\n+        res\n+    }\n+\n+    pub fn assists(&self, file_id: FileId, offset: TextUnit) -> Vec<SourceChange> {\n+        let file = self.file_syntax(file_id);\n+        let actions = vec![\n+            (\"flip comma\", libeditor::flip_comma(&file, offset).map(|f| f())),\n+            (\"add `#[derive]`\", libeditor::add_derive(&file, offset).map(|f| f())),\n+            (\"add impl\", libeditor::add_impl(&file, offset).map(|f| f())),\n+        ];\n+        let mut res = Vec::new();\n+        for (name, local_edit) in actions {\n+            if let Some(local_edit) = local_edit {\n+                res.push(SourceChange::from_local_edit(\n+                    file_id, name, local_edit\n+                ))\n+            }\n+        }\n+        res\n+    }\n+\n+    fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {\n+        let name = name_ref.text();\n+        let mut query = Query::new(name.to_string());\n+        query.exact();\n+        query.limit(4);\n+        self.world_symbols(query)\n+    }\n+\n+    fn resolve_module(&self, id: FileId, module: ast::Module) -> Vec<FileId> {\n+        let name = match module.name() {\n+            Some(name) => name.text(),\n+            None => return Vec::new(),\n+        };\n+        let module_map = &self.data.module_map;\n+        let id = module_map.file2module(id);\n+        module_map\n+            .child_module_by_name(\n+                id, name.as_str(),\n+                &*self.file_resolver,\n+                &|file_id| self.file_syntax(file_id),\n+            )\n+            .into_iter()\n+            .map(|id| module_map.module2file(id))\n+            .collect()\n+    }\n+\n+    fn reindex(&self) {\n+        if self.needs_reindex.compare_and_swap(false, true, SeqCst) {\n+            let now = Instant::now();\n+            let data = &*self.data;\n+            data.file_map\n+                .par_iter()\n+                .for_each(|(_, data)| drop(data.symbols()));\n+            info!(\"parallel indexing took {:?}\", now.elapsed());\n+        }\n+    }\n+\n+    fn file_data(&self, file_id: FileId) -> Arc<FileData> {\n+        match self.data.file_map.get(&file_id) {\n+            Some(data) => data.clone(),\n+            None => panic!(\"unknown file: {:?}\", file_id),\n+        }\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n+pub(crate) struct WorldData {\n+    pub(crate) file_map: HashMap<FileId, Arc<FileData>>,\n+    pub(crate) module_map: ModuleMap,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct FileData {\n+    pub(crate) text: String,\n+    pub(crate) symbols: OnceCell<FileSymbols>,\n+    pub(crate) syntax: OnceCell<File>,\n+    pub(crate) lines: OnceCell<LineIndex>,\n+}\n+\n+impl FileData {\n+    pub(crate) fn new(text: String) -> FileData {\n+        FileData {\n+            text,\n+            symbols: OnceCell::new(),\n+            syntax: OnceCell::new(),\n+            lines: OnceCell::new(),\n+        }\n+    }\n+\n+    fn syntax(&self) -> &File {\n+        let text = &self.text;\n+        let syntax = &self.syntax;\n+        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n+            Ok(file) => file,\n+            Err(err) => {\n+                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", &self.text);\n+                panic::resume_unwind(err)\n+            }\n+        }\n+    }\n+\n+    fn syntax_transient(&self) -> File {\n+        self.syntax.get().map(|s| s.clone())\n+            .unwrap_or_else(|| File::parse(&self.text))\n+    }\n+\n+    fn symbols(&self) -> &FileSymbols {\n+        let syntax = self.syntax_transient();\n+        self.symbols\n+            .get_or_init(|| FileSymbols::new(&syntax))\n+    }\n+}"}, {"sha": "027d7439b3834a4d43c5a64ee6197ece6725db31", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 283, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ea0ca7e5fb5d3e123dc38927b158c798b689ad/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=09ea0ca7e5fb5d3e123dc38927b158c798b689ad", "patch": "@@ -1,4 +1,3 @@\n-#[macro_use]\n extern crate failure;\n extern crate parking_lot;\n #[macro_use]\n@@ -13,33 +12,20 @@ extern crate relative_path;\n mod symbol_index;\n mod module_map;\n mod api;\n+mod imp;\n \n use std::{\n-    fmt,\n-    panic,\n     sync::{\n         Arc,\n-        atomic::{AtomicBool, Ordering::SeqCst},\n+        atomic::{AtomicBool},\n     },\n-    collections::hash_map::HashMap,\n-    time::Instant,\n };\n \n use relative_path::RelativePath;\n-use once_cell::sync::OnceCell;\n-use rayon::prelude::*;\n-\n-use libsyntax2::{\n-    File,\n-    TextUnit, TextRange, SmolStr,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxKind::*,\n-};\n-use libeditor::{LineIndex, FileSymbol, find_node_at_offset};\n \n use self::{\n-    symbol_index::FileSymbols,\n-    module_map::{ModuleMap, ChangeKind, Problem},\n+    module_map::{ChangeKind},\n+    imp::{WorldData, FileData},\n };\n pub use self::symbol_index::Query;\n pub use self::api::{\n@@ -58,28 +44,6 @@ pub struct WorldState {\n     data: Arc<WorldData>\n }\n \n-pub(crate) struct World {\n-    needs_reindex: AtomicBool,\n-    file_resolver: Arc<FileResolver>,\n-    data: Arc<WorldData>,\n-}\n-\n-impl fmt::Debug for World {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (&*self.data).fmt(f)\n-    }\n-}\n-\n-impl Clone for World {\n-    fn clone(&self) -> World {\n-        World {\n-            needs_reindex: AtomicBool::new(self.needs_reindex.load(SeqCst)),\n-            file_resolver: Arc::clone(&self.file_resolver),\n-            data: Arc::clone(&self.data),\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n \n@@ -94,7 +58,7 @@ impl WorldState {\n         &self,\n         file_resolver: impl FileResolver,\n     ) -> Analysis {\n-        let imp = World {\n+        let imp = imp::AnalysisImpl {\n             needs_reindex: AtomicBool::new(false),\n             file_resolver: Arc::new(file_resolver),\n             data: self.data.clone()\n@@ -139,245 +103,3 @@ impl WorldState {\n         Arc::get_mut(&mut self.data).unwrap()\n     }\n }\n-\n-impl World {\n-    pub fn file_syntax(&self, file_id: FileId) -> File {\n-        self.file_data(file_id).syntax().clone()\n-    }\n-\n-    pub fn file_line_index(&self, id: FileId) -> LineIndex {\n-        let data = self.file_data(id);\n-        data\n-            .lines\n-            .get_or_init(|| LineIndex::new(&data.text))\n-            .clone()\n-    }\n-\n-    pub fn world_symbols(&self, mut query: Query) -> Vec<(FileId, FileSymbol)> {\n-        self.reindex();\n-        self.data.file_map.iter()\n-            .flat_map(move |(id, data)| {\n-                let symbols = data.symbols();\n-                query.process(symbols).into_iter().map(move |s| (*id, s))\n-            })\n-            .collect()\n-    }\n-\n-    pub fn parent_module(&self, id: FileId) -> Vec<(FileId, FileSymbol)> {\n-        let module_map = &self.data.module_map;\n-        let id = module_map.file2module(id);\n-        module_map\n-            .parent_modules(\n-                id,\n-                &*self.file_resolver,\n-                &|file_id| self.file_syntax(file_id),\n-            )\n-            .into_iter()\n-            .map(|(id, name, node)| {\n-                let id = module_map.module2file(id);\n-                let sym = FileSymbol {\n-                    name,\n-                    node_range: node.range(),\n-                    kind: MODULE,\n-                };\n-                (id, sym)\n-            })\n-            .collect()\n-    }\n-\n-    pub fn approximately_resolve_symbol(\n-        &self,\n-        id: FileId,\n-        offset: TextUnit,\n-    ) -> Vec<(FileId, FileSymbol)> {\n-        let file = self.file_syntax(id);\n-        let syntax = file.syntax();\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n-            return self.index_resolve(name_ref);\n-        }\n-        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n-            if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n-                if module.has_semi() {\n-                    let file_ids = self.resolve_module(id, module);\n-\n-                    let res = file_ids.into_iter().map(|id| {\n-                        let name = module.name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"\"));\n-                        let symbol = FileSymbol {\n-                            name,\n-                            node_range: TextRange::offset_len(0.into(), 0.into()),\n-                            kind: MODULE,\n-                        };\n-                        (id, symbol)\n-                    }).collect();\n-\n-                    return res;\n-                }\n-            }\n-        }\n-        vec![]\n-    }\n-\n-    pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n-        let syntax = self.file_syntax(file_id);\n-        let mut res = libeditor::diagnostics(&syntax)\n-            .into_iter()\n-            .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n-            .collect::<Vec<_>>();\n-\n-        self.data.module_map.problems(\n-            file_id,\n-            &*self.file_resolver,\n-            &|file_id| self.file_syntax(file_id),\n-            |name_node, problem| {\n-                let diag = match problem {\n-                    Problem::UnresolvedModule { candidate } => {\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            anchor: file_id,\n-                            path: candidate.clone(),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"unresolved module\".to_string(),\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                    Problem::NotDirOwner { move_to, candidate } => {\n-                        let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n-                        let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n-                        let fix = SourceChange {\n-                            label: \"move file and create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![move_file, create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"can't declare module at this location\".to_string(),\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                };\n-                res.push(diag)\n-            }\n-        );\n-        res\n-    }\n-\n-    pub fn assists(&self, file_id: FileId, offset: TextUnit) -> Vec<SourceChange> {\n-        let file = self.file_syntax(file_id);\n-        let actions = vec![\n-            (\"flip comma\", libeditor::flip_comma(&file, offset).map(|f| f())),\n-            (\"add `#[derive]`\", libeditor::add_derive(&file, offset).map(|f| f())),\n-            (\"add impl\", libeditor::add_impl(&file, offset).map(|f| f())),\n-        ];\n-        let mut res = Vec::new();\n-        for (name, local_edit) in actions {\n-            if let Some(local_edit) = local_edit {\n-                res.push(SourceChange::from_local_edit(\n-                    file_id, name, local_edit\n-                ))\n-            }\n-        }\n-        res\n-    }\n-\n-    fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {\n-        let name = name_ref.text();\n-        let mut query = Query::new(name.to_string());\n-        query.exact();\n-        query.limit(4);\n-        self.world_symbols(query)\n-    }\n-\n-    fn resolve_module(&self, id: FileId, module: ast::Module) -> Vec<FileId> {\n-        let name = match module.name() {\n-            Some(name) => name.text(),\n-            None => return Vec::new(),\n-        };\n-        let module_map = &self.data.module_map;\n-        let id = module_map.file2module(id);\n-        module_map\n-            .child_module_by_name(\n-                id, name.as_str(),\n-                &*self.file_resolver,\n-                &|file_id| self.file_syntax(file_id),\n-            )\n-            .into_iter()\n-            .map(|id| module_map.module2file(id))\n-            .collect()\n-    }\n-\n-    fn reindex(&self) {\n-        if self.needs_reindex.compare_and_swap(false, true, SeqCst) {\n-            let now = Instant::now();\n-            let data = &*self.data;\n-            data.file_map\n-                .par_iter()\n-                .for_each(|(_, data)| drop(data.symbols()));\n-            info!(\"parallel indexing took {:?}\", now.elapsed());\n-        }\n-    }\n-\n-    fn file_data(&self, file_id: FileId) -> Arc<FileData> {\n-        match self.data.file_map.get(&file_id) {\n-            Some(data) => data.clone(),\n-            None => panic!(\"unknown file: {:?}\", file_id),\n-        }\n-    }\n-}\n-\n-#[derive(Default, Debug)]\n-struct WorldData {\n-    file_map: HashMap<FileId, Arc<FileData>>,\n-    module_map: ModuleMap,\n-}\n-\n-#[derive(Debug)]\n-struct FileData {\n-    text: String,\n-    symbols: OnceCell<FileSymbols>,\n-    syntax: OnceCell<File>,\n-    lines: OnceCell<LineIndex>,\n-}\n-\n-impl FileData {\n-    fn new(text: String) -> FileData {\n-        FileData {\n-            text,\n-            symbols: OnceCell::new(),\n-            syntax: OnceCell::new(),\n-            lines: OnceCell::new(),\n-        }\n-    }\n-\n-    fn syntax(&self) -> &File {\n-        let text = &self.text;\n-        let syntax = &self.syntax;\n-        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n-            Ok(file) => file,\n-            Err(err) => {\n-                error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", &self.text);\n-                panic::resume_unwind(err)\n-            }\n-        }\n-    }\n-\n-    fn syntax_transient(&self) -> File {\n-        self.syntax.get().map(|s| s.clone())\n-            .unwrap_or_else(|| File::parse(&self.text))\n-    }\n-\n-    fn symbols(&self) -> &FileSymbols {\n-        let syntax = self.syntax_transient();\n-        self.symbols\n-            .get_or_init(|| FileSymbols::new(&syntax))\n-    }\n-}"}]}