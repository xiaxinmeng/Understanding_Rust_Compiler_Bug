{"sha": "7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "node_id": "C_kwDOAAsO6NoAKDdiYWI3NjliNThkYjI5MjcyMWRkY2I3M2NjNmE3ZTU2Y2IyYjA4YWI", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-25T12:02:39Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-27T10:24:27Z"}, "message": "lint: add bad opt access internal lint\n\nSome command-line options accessible through `sess.opts` are best\naccessed through wrapper functions on `Session`, `TyCtxt` or otherwise,\nrather than through field access on the option struct in the `Session`.\n\nAdds a new lint which triggers on those options that should be accessed\nthrough a wrapper function so that this is prohibited. Options are\nannotated with a new attribute `rustc_lint_opt_deny_field_access` which\ncan specify the error message (i.e. \"use this other function instead\")\nto be emitted.\n\nA simpler alternative would be to simply rename the options in the\noption type so that it is clear they should not be used, however this\ndoesn't prevent uses, just discourages them. Another alternative would\nbe to make the option fields private, and adding accessor functions on\nthe option types, however the wrapper functions sometimes rely on\nadditional state from `Session` or `TyCtxt` which wouldn't be available\nin an function on the option type, so the accessor would simply make the\nfield available and its use would be discouraged too.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "9eb60f7c5aade2fca70d32ce361d88bea0d823c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eb60f7c5aade2fca70d32ce361d88bea0d823c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "html_url": "https://github.com/rust-lang/rust/commit/7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5e005f0ca0b6fbc427315fa7e6943f4b738e12d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e005f0ca0b6fbc427315fa7e6943f4b738e12d", "html_url": "https://github.com/rust-lang/rust/commit/f5e005f0ca0b6fbc427315fa7e6943f4b738e12d"}], "stats": {"total": 897, "additions": 553, "deletions": 344}, "files": [{"sha": "53ae913f94f124f9dd1166c5eb723e177d21253b", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -123,8 +123,7 @@ impl Callbacks for TimePassesCallbacks {\n     fn config(&mut self, config: &mut interface::Config) {\n         // If a --prints=... option has been given, we don't print the \"total\"\n         // time because it will mess up the --prints output. See #64339.\n-        self.time_passes = config.opts.prints.is_empty()\n-            && (config.opts.unstable_opts.time_passes || config.opts.unstable_opts.time);\n+        self.time_passes = config.opts.prints.is_empty() && config.opts.time_passes();\n         config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n     }\n }"}, {"sha": "b17eb9c2d260e9a4a14b9eb07220b229ed5a6c7f", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -256,3 +256,9 @@ passes-unused-duplicate = unused attribute\n passes-unused-multiple = multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n+\n+passes-rustc-lint-opt-ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+    .label = not a struct\n+\n+passes-rustc-lint-opt-deny-field-access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+    .label = not a field"}, {"sha": "0e73d8fd7f600f284e2af7be4c7f08cf89c3d344", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -619,6 +619,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Used by the `rustc::untranslatable_diagnostic` and `rustc::diagnostic_outside_of_impl` lints\n     // to assist in changes to diagnostic APIs.\n     rustc_attr!(rustc_lint_diagnostics, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint to identify `DebuggingOptions` and `CodegenOptions`\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_ty, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint on fields\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_deny_field_access, Normal, template!(List: \"message\"), WarnFollowing, INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:"}, {"sha": "94f81b6607798f7027a227e67d1719858e2046eb", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -329,6 +329,8 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n     })\n }\n \n+// JUSTIFICATION: before session exists, only config\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n     tracing::trace!(\"run_compiler\");\n     util::run_in_thread_pool_with_globals("}, {"sha": "21d9eaccf67e7ccffa4397cf9ac79cc8edf5701e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -1,3 +1,4 @@\n+#![cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n use crate::interface::parse_cfgspecs;\n \n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "4c64e679b95711260a60efe5067daa0db50226d3", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -559,6 +559,8 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     // Only check command line flags if present. If no types are specified by\n     // command line, then reuse the empty `base` Vec to hold the types that\n     // will be found in crate attributes.\n+    // JUSTIFICATION: before wrapper fn is available\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     let mut base = session.opts.crate_types.clone();\n     if base.is_empty() {\n         base.extend(attr_types);"}, {"sha": "c26d7824758ef06f11b40692b10ff2a2d367ea49", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -432,3 +432,38 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n     }\n }\n+\n+declare_tool_lint! {\n+    pub rustc::BAD_OPT_ACCESS,\n+    Deny,\n+    \"prevent using options by field access when there is a wrapper function\",\n+    report_in_external_macro: true\n+}\n+\n+declare_lint_pass!(BadOptAccess => [ BAD_OPT_ACCESS ]);\n+\n+impl LateLintPass<'_> for BadOptAccess {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        let ExprKind::Field(base, target) = expr.kind else { return };\n+        let Some(adt_def) = cx.typeck_results().expr_ty(base).ty_adt_def() else { return };\n+        // Skip types without `#[rustc_lint_opt_ty]` - only so that the rest of the lint can be\n+        // avoided.\n+        if !cx.tcx.has_attr(adt_def.did(), sym::rustc_lint_opt_ty) {\n+            return;\n+        }\n+\n+        for field in adt_def.all_fields() {\n+            if field.name == target.name &&\n+                let Some(attr) = cx.tcx.get_attr(field.did, sym::rustc_lint_opt_deny_field_access) &&\n+                let Some(items) = attr.meta_item_list()  &&\n+                let Some(item) = items.first()  &&\n+                let Some(literal) = item.literal()  &&\n+                let ast::LitKind::Str(val, _) = literal.kind\n+            {\n+                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, |lint| {\n+                    lint.build(val.as_str()).emit(); }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "7b0702dad75dee9ae6d65420e01ea63f8ebc4fc0", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -509,6 +509,8 @@ fn register_internals(store: &mut LintStore) {\n     store.register_late_pass(|| Box::new(TyTyKind));\n     store.register_lints(&Diagnostics::get_lints());\n     store.register_late_pass(|| Box::new(Diagnostics));\n+    store.register_lints(&BadOptAccess::get_lints());\n+    store.register_late_pass(|| Box::new(BadOptAccess));\n     store.register_lints(&PassByValue::get_lints());\n     store.register_late_pass(|| Box::new(PassByValue));\n     // FIXME(davidtwco): deliberately do not include `UNTRANSLATABLE_DIAGNOSTIC` and\n@@ -527,6 +529,7 @@ fn register_internals(store: &mut LintStore) {\n             LintId::of(LINT_PASS_IMPL_WITHOUT_MACRO),\n             LintId::of(USAGE_OF_QUALIFIED_TY),\n             LintId::of(EXISTING_DOC_KEYWORD),\n+            LintId::of(BAD_OPT_ACCESS),\n         ],\n     );\n }"}, {"sha": "2f02d00ec9fb04854217d352b000d6c4957841d7", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -11,7 +11,7 @@ pub struct LowerSliceLenCalls;\n \n impl<'tcx> MirPass<'tcx> for LowerSliceLenCalls {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.opts.mir_opt_level() > 0\n+        sess.mir_opt_level() > 0\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "4919ad40098cb0f2ae58a211969cca08304d77c5", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -9,7 +9,7 @@ pub struct RevealAll;\n \n impl<'tcx> MirPass<'tcx> for RevealAll {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.opts.mir_opt_level() >= 3 || super::inline::Inline.is_enabled(sess)\n+        sess.mir_opt_level() >= 3 || super::inline::Inline.is_enabled(sess)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "fde12b9eee6b92d0ed4eee7f53f7f758ada4a020", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -121,6 +121,10 @@ impl CheckAttrVisitor<'_> {\n                 sym::rustc_lint_diagnostics => {\n                     self.check_rustc_lint_diagnostics(&attr, span, target)\n                 }\n+                sym::rustc_lint_opt_ty => self.check_rustc_lint_opt_ty(&attr, span, target),\n+                sym::rustc_lint_opt_deny_field_access => {\n+                    self.check_rustc_lint_opt_deny_field_access(&attr, span, target)\n+                }\n                 sym::rustc_clean\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n@@ -1382,6 +1386,35 @@ impl CheckAttrVisitor<'_> {\n         self.check_applied_to_fn_or_method(attr, span, target)\n     }\n \n+    /// Checks that the `#[rustc_lint_opt_ty]` attribute is only applied to a struct.\n+    fn check_rustc_lint_opt_ty(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::Struct => true,\n+            _ => {\n+                self.tcx.sess.emit_err(errors::RustcLintOptTy { attr_span: attr.span, span });\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks that the `#[rustc_lint_opt_deny_field_access]` attribute is only applied to a field.\n+    fn check_rustc_lint_opt_deny_field_access(\n+        &self,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Field => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .emit_err(errors::RustcLintOptDenyFieldAccess { attr_span: attr.span, span });\n+                false\n+            }\n+        }\n+    }\n+\n     /// Checks that the dep-graph debugging attributes are only present when the query-dep-graph\n     /// option is passed to the compiler.\n     fn check_rustc_dirty_clean(&self, attr: &Attribute) -> bool {"}, {"sha": "5feb0e2956b74fa55b24e1b0ee8fb7871a35cb78", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -625,3 +625,21 @@ pub struct UnusedMultiple {\n     pub other: Span,\n     pub name: Symbol,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_lint_opt_ty)]\n+pub struct RustcLintOptTy {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_lint_opt_deny_field_access)]\n+pub struct RustcLintOptDenyFieldAccess {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}"}, {"sha": "fe9ef6045415e332632fa39f7384018255cfc1b9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -948,6 +948,8 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     if sess.opts.debug_assertions {\n         ret.insert((sym::debug_assertions, None));\n     }\n+    // JUSTIFICATION: before wrapper fn is available\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     if sess.opts.crate_types.contains(&CrateType::ProcMacro) {\n         ret.insert((sym::proc_macro, None));\n     }\n@@ -2196,6 +2198,8 @@ fn parse_remap_path_prefix(\n     mapping\n }\n \n+// JUSTIFICATION: before wrapper fn is available\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let color = parse_color(matches);\n "}, {"sha": "501997679f4bf40858bfe05473b0fe81023747cb", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -102,28 +102,6 @@ macro_rules! top_level_options {\n     );\n }\n \n-impl Options {\n-    pub fn mir_opt_level(&self) -> usize {\n-        self.unstable_opts\n-            .mir_opt_level\n-            .unwrap_or_else(|| if self.optimize != OptLevel::No { 2 } else { 1 })\n-    }\n-\n-    pub fn instrument_coverage(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off) != InstrumentCoverage::Off\n-    }\n-\n-    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n-            == InstrumentCoverage::ExceptUnusedGenerics\n-    }\n-\n-    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n-            == InstrumentCoverage::ExceptUnusedFunctions\n-    }\n-}\n-\n top_level_options!(\n     /// The top-level command-line options struct.\n     ///\n@@ -149,9 +127,11 @@ top_level_options!(\n     /// `CodegenOptions`, think about how it influences incremental compilation. If in\n     /// doubt, specify `[TRACKED]`, which is always \"correct\" but might lead to\n     /// unnecessary re-compilation.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_ty)]\n     pub struct Options {\n         /// The crate config requested for the session, which may be combined\n         /// with additional crate configurations during the compile process.\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::crate_types` instead of this field\"))]\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n         /// Include the `debug_assertions` flag in dependency tracking, since it\n@@ -198,7 +178,9 @@ top_level_options!(\n         /// what rustc was invoked with, but massaged a bit to agree with\n         /// commands like `--emit llvm-ir` which they're often incompatible with\n         /// if we otherwise use the defaults of rustc.\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::codegen_units` instead of this field\"))]\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n         /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n@@ -249,11 +231,12 @@ macro_rules! options {\n      ),* ,) =>\n (\n     #[derive(Clone)]\n-    pub struct $struct_name { $(pub $opt: $t),* }\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_ty)]\n+    pub struct $struct_name { $( $( #[$attr] )* pub $opt: $t),* }\n \n     impl Default for $struct_name {\n         fn default() -> $struct_name {\n-            $struct_name { $( $( #[$attr] )* $opt: $init),* }\n+            $struct_name { $($opt: $init),* }\n         }\n     }\n \n@@ -297,6 +280,22 @@ macro_rules! options {\n \n ) }\n \n+impl Options {\n+    // JUSTIFICATION: defn of the suggested wrapper fn\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+    pub fn time_passes(&self) -> bool {\n+        self.unstable_opts.time_passes || self.unstable_opts.time\n+    }\n+}\n+\n+impl CodegenOptions {\n+    // JUSTIFICATION: defn of the suggested wrapper fn\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+    pub fn instrument_coverage(&self) -> InstrumentCoverage {\n+        self.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n+    }\n+}\n+\n // Sometimes different options need to build a common structure.\n // That structure can be kept in one of the options' fields, the others become dummy.\n macro_rules! redirect_field {\n@@ -1076,6 +1075,7 @@ options! {\n \n     ar: String = (String::new(), parse_string, [UNTRACKED],\n         \"this option is deprecated and does nothing\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::code_model` instead of this field\"))]\n     code_model: Option<CodeModel> = (None, parse_code_model, [TRACKED],\n         \"choose the code model to use (`rustc --print code-models` for details)\"),\n     codegen_units: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n@@ -1095,12 +1095,14 @@ options! {\n         \"extra data to put in each output filename\"),\n     force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"force use of the frame pointers\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::must_emit_unwind_tables` instead of this field\"))]\n     force_unwind_tables: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"force use of unwind tables\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"enable incremental compilation\"),\n     inline_threshold: Option<u32> = (None, parse_opt_number, [TRACKED],\n         \"set the threshold for inlining a function\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_coverage` instead of this field\"))]\n     instrument_coverage: Option<InstrumentCoverage> = (None, parse_instrument_coverage, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`); \\\n@@ -1113,6 +1115,7 @@ options! {\n         \"a single extra argument to append to the linker invocation (can be used several times)\"),\n     link_args: Vec<String> = (Vec::new(), parse_list, [UNTRACKED],\n         \"extra arguments to append to the linker invocation (space separated)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::link_dead_code` instead of this field\"))]\n     link_dead_code: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"keep dead code at link time (useful for code coverage) (default: no)\"),\n     link_self_contained: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n@@ -1127,6 +1130,7 @@ options! {\n         \"generate build artifacts that are compatible with linker-based LTO\"),\n     llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of arguments to pass to LLVM (space separated)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n     lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n     metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n@@ -1143,8 +1147,10 @@ options! {\n         \"disable LLVM's SLP vectorization pass\"),\n     opt_level: String = (\"0\".to_string(), parse_string, [TRACKED],\n         \"optimization level (0-3, s, or z; default: 0)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::overflow_checks` instead of this field\"))]\n     overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use overflow checks for integer arithmetic\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::panic_strategy` instead of this field\"))]\n     panic: Option<PanicStrategy> = (None, parse_opt_panic_strategy, [TRACKED],\n         \"panic strategy to compile crate with\"),\n     passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n@@ -1156,6 +1162,7 @@ options! {\n         \"compile the program with profiling instrumentation\"),\n     profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"use the given `.profdata` file for profile-guided optimization\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::relocation_model` instead of this field\"))]\n     relocation_model: Option<RelocModel> = (None, parse_relocation_model, [TRACKED],\n         \"control generation of position-independent code (PIC) \\\n         (`rustc --print relocation-models` for details)\"),\n@@ -1167,6 +1174,7 @@ options! {\n         \"save all temporary output files during compilation (default: no)\"),\n     soft_float: bool = (false, parse_bool, [TRACKED],\n         \"use soft float ABI (*eabihf targets only) (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::split_debuginfo` instead of this field\"))]\n     split_debuginfo: Option<SplitDebuginfo> = (None, parse_split_debuginfo, [TRACKED],\n         \"how to handle split-debuginfo, a platform-specific option\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n@@ -1202,11 +1210,13 @@ options! {\n         \"encode MIR of all functions into the crate metadata (default: no)\"),\n     assume_incomplete_release: bool = (false, parse_bool, [TRACKED],\n         \"make cfg(version) treat the current version as incomplete (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::asm_comments` instead of this field\"))]\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior) (default: no)\"),\n     assert_incr_state: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"assert that the incremental cache is in given state: \\\n          either `loaded` or `not-loaded`.\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::binary_dep_depinfo` instead of this field\"))]\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n         (default: no)\"),\n@@ -1284,6 +1294,7 @@ options! {\n         \"emit the bc module with thin LTO info (default: yes)\"),\n     export_executable_symbols: bool = (false, parse_bool, [TRACKED],\n         \"export symbols from executables, as if they were dynamic libraries\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::fewer_names` instead of this field\"))]\n     fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) \\\n         (default: no)\"),\n@@ -1326,6 +1337,7 @@ options! {\n         \"control whether `#[inline]` functions are in all CGUs\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_coverage` instead of this field\"))]\n     instrument_coverage: Option<InstrumentCoverage> = (None, parse_instrument_coverage, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`); \\\n@@ -1334,6 +1346,7 @@ options! {\n         `=except-unused-generics`\n         `=except-unused-functions`\n         `=off` (default)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_mcount` instead of this field\"))]\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n@@ -1356,6 +1369,7 @@ options! {\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking \\\n         the same values as the target option of the same name\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::meta_stats` instead of this field\"))]\n     meta_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather metadata statistics (default: no)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n@@ -1365,6 +1379,7 @@ options! {\n         \"use like `-Zmir-enable-passes=+DestProp,-InstCombine`. Forces the specified passes to be \\\n         enabled, overriding all other checks. Passes that are not specified are enabled or \\\n         disabled by other flags as usual.\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::mir_opt_level` instead of this field\"))]\n     mir_opt_level: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\"),\n     move_size_limit: Option<usize> = (None, parse_opt_number, [TRACKED],\n@@ -1431,6 +1446,7 @@ options! {\n         See #77382 and #74551.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make rustc print the total optimization fuel used by a crate\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::print_llvm_passes` instead of this field\"))]\n     print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"print the LLVM optimization passes being run (default: no)\"),\n     print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1505,6 +1521,7 @@ options! {\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::stack_protector` instead of this field\"))]\n     stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n     strict_init_checks: bool = (false, parse_bool, [TRACKED],\n@@ -1525,6 +1542,7 @@ options! {\n     symbol_mangling_version: Option<SymbolManglingVersion> = (None,\n         parse_symbol_mangling_version, [TRACKED],\n         \"which mangling version to use for symbol names ('legacy' (default) or 'v0')\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::teach` instead of this field\"))]\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help (default: no)\"),\n     temps_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1540,6 +1558,7 @@ options! {\n         \"emit directionality isolation markers in translated diagnostics\"),\n     tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     thir_unsafeck: bool = (false, parse_bool, [TRACKED],\n@@ -1548,14 +1567,19 @@ options! {\n     /// a sequential compiler for now. This'll likely be adjusted\n     /// in the future. Note that -Zthreads=0 is the way to get\n     /// the num_cpus behavior.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::threads` instead of this field\"))]\n     threads: usize = (1, parse_threads, [UNTRACKED],\n         \"use a thread pool with N threads\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_passes` instead of this field\"))]\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_llvm_passes` instead of this field\"))]\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each LLVM pass (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_passes` instead of this field\"))]\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::tls_model` instead of this field\"))]\n     tls_model: Option<TlsModel> = (None, parse_tls_model, [TRACKED],\n         \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n@@ -1590,14 +1614,17 @@ options! {\n         \"enable unsound and buggy MIR optimizations (default: no)\"),\n     /// This name is kind of confusing: Most unstable options enable something themselves, while\n     /// this just allows \"normal\" options to be feature-gated.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::unstable_options` instead of this field\"))]\n     unstable_options: bool = (false, parse_bool, [UNTRACKED],\n         \"adds unstable command line options to rustc interface (default: no)\"),\n     use_ctors_section: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use legacy .ctors section for initializers rather than .init_array\"),\n     validate_mir: bool = (false, parse_bool, [UNTRACKED],\n         \"validate MIR after each transformation\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::verbose` instead of this field\"))]\n     verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::verify_llvm_ir` instead of this field\"))]\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n         \"verify LLVM IR (default: no)\"),\n     virtual_function_elimination: bool = (false, parse_bool, [TRACKED],"}, {"sha": "9669287b3f37075f26563c344d84b005d3973d25", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 343, "deletions": 316, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -1,7 +1,7 @@\n use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n-use crate::config::{self, CrateType, OutputType, SwitchWithOptPath};\n+use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -583,11 +583,9 @@ impl Session {\n     pub fn source_map(&self) -> &SourceMap {\n         self.parse_sess.source_map()\n     }\n-    pub fn verbose(&self) -> bool {\n-        self.opts.unstable_opts.verbose\n-    }\n+\n     pub fn time_passes(&self) -> bool {\n-        self.opts.unstable_opts.time_passes || self.opts.unstable_opts.time\n+        self.opts.time_passes()\n     }\n \n     /// Returns `true` if internal lints should be added to the lint store - i.e. if\n@@ -597,44 +595,344 @@ impl Session {\n         self.unstable_options() && !self.opts.actually_rustdoc\n     }\n \n+    pub fn instrument_coverage(&self) -> bool {\n+        self.opts.cg.instrument_coverage() != InstrumentCoverage::Off\n+    }\n+\n+    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n+        self.opts.cg.instrument_coverage() == InstrumentCoverage::ExceptUnusedGenerics\n+    }\n+\n+    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n+        self.opts.cg.instrument_coverage() == InstrumentCoverage::ExceptUnusedFunctions\n+    }\n+\n+    /// Gets the features enabled for the current compilation session.\n+    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n+    /// dependency tracking. Use tcx.features() instead.\n+    #[inline]\n+    pub fn features_untracked(&self) -> &rustc_feature::Features {\n+        self.features.get().unwrap()\n+    }\n+\n+    pub fn init_features(&self, features: rustc_feature::Features) {\n+        match self.features.set(features) {\n+            Ok(()) => {}\n+            Err(_) => panic!(\"`features` was initialized twice\"),\n+        }\n+    }\n+\n+    pub fn is_sanitizer_cfi_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n+    }\n+\n+    /// Check whether this compile session and crate type use static crt.\n+    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n+        if !self.target.crt_static_respected {\n+            // If the target does not opt in to crt-static support, use its default.\n+            return self.target.crt_static_default;\n+        }\n+\n+        let requested_features = self.opts.cg.target_feature.split(',');\n+        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n+        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n+\n+        // JUSTIFICATION: necessary use of crate_types directly (see FIXME below)\n+        #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+        if found_positive || found_negative {\n+            found_positive\n+        } else if crate_type == Some(CrateType::ProcMacro)\n+            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n+        {\n+            // FIXME: When crate_type is not available,\n+            // we use compiler options to determine the crate_type.\n+            // We can't check `#![crate_type = \"proc-macro\"]` here.\n+            false\n+        } else {\n+            self.target.crt_static_default\n+        }\n+    }\n+\n+    pub fn is_wasi_reactor(&self) -> bool {\n+        self.target.options.os == \"wasi\"\n+            && matches!(\n+                self.opts.unstable_opts.wasi_exec_model,\n+                Some(config::WasiExecModel::Reactor)\n+            )\n+    }\n+\n+    pub fn target_can_use_split_dwarf(&self) -> bool {\n+        !self.target.is_like_windows && !self.target.is_like_osx\n+    }\n+\n+    pub fn generate_proc_macro_decls_symbol(&self, stable_crate_id: StableCrateId) -> String {\n+        format!(\"__rustc_proc_macro_decls_{:08x}__\", stable_crate_id.to_u64())\n+    }\n+\n+    pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n+        filesearch::FileSearch::new(\n+            &self.sysroot,\n+            self.opts.target_triple.triple(),\n+            &self.opts.search_paths,\n+            &self.target_tlib_path,\n+            kind,\n+        )\n+    }\n+    pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n+        filesearch::FileSearch::new(\n+            &self.sysroot,\n+            config::host_triple(),\n+            &self.opts.search_paths,\n+            &self.host_tlib_path,\n+            kind,\n+        )\n+    }\n+\n+    /// Returns a list of directories where target-specific tool binaries are located.\n+    pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n+        let rustlib_path = rustc_target::target_rustlib_path(&self.sysroot, &config::host_triple());\n+        let p = PathBuf::from_iter([\n+            Path::new(&self.sysroot),\n+            Path::new(&rustlib_path),\n+            Path::new(\"bin\"),\n+        ]);\n+        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n+    }\n+\n+    pub fn init_incr_comp_session(\n+        &self,\n+        session_dir: PathBuf,\n+        lock_file: flock::Lock,\n+        load_dep_graph: bool,\n+    ) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        if let IncrCompSession::NotInitialized = *incr_comp_session {\n+        } else {\n+            panic!(\"Trying to initialize IncrCompSession `{:?}`\", *incr_comp_session)\n+        }\n+\n+        *incr_comp_session =\n+            IncrCompSession::Active { session_directory: session_dir, lock_file, load_dep_graph };\n+    }\n+\n+    pub fn finalize_incr_comp_session(&self, new_directory_path: PathBuf) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        if let IncrCompSession::Active { .. } = *incr_comp_session {\n+        } else {\n+            panic!(\"trying to finalize `IncrCompSession` `{:?}`\", *incr_comp_session);\n+        }\n+\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::Finalized { session_directory: new_directory_path };\n+    }\n+\n+    pub fn mark_incr_comp_session_as_invalid(&self) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        let session_directory = match *incr_comp_session {\n+            IncrCompSession::Active { ref session_directory, .. } => session_directory.clone(),\n+            IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n+            _ => panic!(\"trying to invalidate `IncrCompSession` `{:?}`\", *incr_comp_session),\n+        };\n+\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n+    }\n+\n+    pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n+        let incr_comp_session = self.incr_comp_session.borrow();\n+        cell::Ref::map(incr_comp_session, |incr_comp_session| match *incr_comp_session {\n+            IncrCompSession::NotInitialized => panic!(\n+                \"trying to get session directory from `IncrCompSession`: {:?}\",\n+                *incr_comp_session,\n+            ),\n+            IncrCompSession::Active { ref session_directory, .. }\n+            | IncrCompSession::Finalized { ref session_directory }\n+            | IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n+                session_directory\n+            }\n+        })\n+    }\n+\n+    pub fn incr_comp_session_dir_opt(&self) -> Option<cell::Ref<'_, PathBuf>> {\n+        self.opts.incremental.as_ref().map(|_| self.incr_comp_session_dir())\n+    }\n+\n+    pub fn print_perf_stats(&self) {\n+        eprintln!(\n+            \"Total time spent computing symbol hashes:      {}\",\n+            duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n+        );\n+        eprintln!(\n+            \"Total queries canonicalized:                   {}\",\n+            self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n+        );\n+        eprintln!(\n+            \"normalize_generic_arg_after_erasing_regions:   {}\",\n+            self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n+        );\n+        eprintln!(\n+            \"normalize_projection_ty:                       {}\",\n+            self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed)\n+        );\n+    }\n+\n+    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n+    /// This expends fuel if applicable, and records fuel if applicable.\n+    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+        let mut ret = true;\n+        if let Some((ref c, _)) = self.opts.unstable_opts.fuel {\n+            if c == crate_name {\n+                assert_eq!(self.threads(), 1);\n+                let mut fuel = self.optimization_fuel.lock();\n+                ret = fuel.remaining != 0;\n+                if fuel.remaining == 0 && !fuel.out_of_fuel {\n+                    if self.diagnostic().can_emit_warnings() {\n+                        // We only call `msg` in case we can actually emit warnings.\n+                        // Otherwise, this could cause a `delay_good_path_bug` to\n+                        // trigger (issue #79546).\n+                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n+                    }\n+                    fuel.out_of_fuel = true;\n+                } else if fuel.remaining > 0 {\n+                    fuel.remaining -= 1;\n+                }\n+            }\n+        }\n+        if let Some(ref c) = self.opts.unstable_opts.print_fuel {\n+            if c == crate_name {\n+                assert_eq!(self.threads(), 1);\n+                self.print_fuel.fetch_add(1, SeqCst);\n+            }\n+        }\n+        ret\n+    }\n+\n+    pub fn rust_2015(&self) -> bool {\n+        self.edition() == Edition::Edition2015\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2018 edition?\n+    pub fn rust_2018(&self) -> bool {\n+        self.edition() >= Edition::Edition2018\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2021 edition?\n+    pub fn rust_2021(&self) -> bool {\n+        self.edition() >= Edition::Edition2021\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2024 edition?\n+    pub fn rust_2024(&self) -> bool {\n+        self.edition() >= Edition::Edition2024\n+    }\n+\n+    /// Returns `true` if we cannot skip the PLT for shared library calls.\n+    pub fn needs_plt(&self) -> bool {\n+        // Check if the current target usually needs PLT to be enabled.\n+        // The user can use the command line flag to override it.\n+        let needs_plt = self.target.needs_plt;\n+\n+        let dbg_opts = &self.opts.unstable_opts;\n+\n+        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.relro_level);\n+\n+        // Only enable this optimization by default if full relro is also enabled.\n+        // In this case, lazy binding was already unavailable, so nothing is lost.\n+        // This also ensures `-Wl,-z,now` is supported by the linker.\n+        let full_relro = RelroLevel::Full == relro_level;\n+\n+        // If user didn't explicitly forced us to use / skip the PLT,\n+        // then try to skip it where possible.\n+        dbg_opts.plt.unwrap_or(needs_plt || !full_relro)\n+    }\n+\n+    /// Checks if LLVM lifetime markers should be emitted.\n+    pub fn emit_lifetime_markers(&self) -> bool {\n+        self.opts.optimize != config::OptLevel::No\n+        // AddressSanitizer uses lifetimes to detect use after scope bugs.\n+        // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n+        // HWAddressSanitizer will use lifetimes to detect use after scope bugs in the future.\n+        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n+    }\n+\n+    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| attr.has_name(*kind))\n+    }\n+\n+    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n+        attrs.iter().any(|item| item.has_name(name))\n+    }\n+\n+    pub fn find_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> Option<&'a Attribute> {\n+        attrs.iter().find(|attr| attr.has_name(name))\n+    }\n+\n+    pub fn filter_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> impl Iterator<Item = &'a Attribute> {\n+        attrs.iter().filter(move |attr| attr.has_name(name))\n+    }\n+\n+    pub fn first_attr_value_str_by_name(\n+        &self,\n+        attrs: &[Attribute],\n+        name: Symbol,\n+    ) -> Option<Symbol> {\n+        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n+    }\n+}\n+\n+// JUSTIFICATION: defn of the suggested wrapper fns\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+impl Session {\n+    pub fn verbose(&self) -> bool {\n+        self.opts.unstable_opts.verbose\n+    }\n+\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.unstable_opts.instrument_mcount\n     }\n+\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.unstable_opts.time_llvm_passes\n     }\n+\n     pub fn meta_stats(&self) -> bool {\n         self.opts.unstable_opts.meta_stats\n     }\n+\n     pub fn asm_comments(&self) -> bool {\n         self.opts.unstable_opts.asm_comments\n     }\n+\n     pub fn verify_llvm_ir(&self) -> bool {\n         self.opts.unstable_opts.verify_llvm_ir || option_env!(\"RUSTC_VERIFY_LLVM_IR\").is_some()\n     }\n+\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.unstable_opts.print_llvm_passes\n     }\n+\n     pub fn binary_dep_depinfo(&self) -> bool {\n         self.opts.unstable_opts.binary_dep_depinfo\n     }\n-    pub fn mir_opt_level(&self) -> usize {\n-        self.opts.mir_opt_level()\n-    }\n-\n-    /// Gets the features enabled for the current compilation session.\n-    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n-    /// dependency tracking. Use tcx.features() instead.\n-    #[inline]\n-    pub fn features_untracked(&self) -> &rustc_feature::Features {\n-        self.features.get().unwrap()\n-    }\n \n-    pub fn init_features(&self, features: rustc_feature::Features) {\n-        match self.features.set(features) {\n-            Ok(()) => {}\n-            Err(_) => panic!(\"`features` was initialized twice\"),\n-        }\n+    pub fn mir_opt_level(&self) -> usize {\n+        self.opts\n+            .unstable_opts\n+            .mir_opt_level\n+            .unwrap_or_else(|| if self.opts.optimize != OptLevel::No { 2 } else { 1 })\n     }\n \n     /// Calculates the flavor of LTO to use for this compilation.\n@@ -710,6 +1008,7 @@ impl Session {\n     pub fn panic_strategy(&self) -> PanicStrategy {\n         self.opts.cg.panic.unwrap_or(self.target.panic_strategy)\n     }\n+\n     pub fn fewer_names(&self) -> bool {\n         if let Some(fewer_names) = self.opts.unstable_opts.fewer_names {\n             fewer_names\n@@ -721,43 +1020,17 @@ impl Session {\n             !more_names\n         }\n     }\n-\n-    pub fn unstable_options(&self) -> bool {\n-        self.opts.unstable_opts.unstable_options\n-    }\n-    pub fn is_nightly_build(&self) -> bool {\n-        self.opts.unstable_features.is_nightly_build()\n-    }\n-    pub fn is_sanitizer_cfi_enabled(&self) -> bool {\n-        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n-    }\n-    pub fn overflow_checks(&self) -> bool {\n-        self.opts.cg.overflow_checks.unwrap_or(self.opts.debug_assertions)\n-    }\n-\n-    /// Check whether this compile session and crate type use static crt.\n-    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n-        if !self.target.crt_static_respected {\n-            // If the target does not opt in to crt-static support, use its default.\n-            return self.target.crt_static_default;\n-        }\n-\n-        let requested_features = self.opts.cg.target_feature.split(',');\n-        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n-        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n-\n-        if found_positive || found_negative {\n-            found_positive\n-        } else if crate_type == Some(CrateType::ProcMacro)\n-            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n-        {\n-            // FIXME: When crate_type is not available,\n-            // we use compiler options to determine the crate_type.\n-            // We can't check `#![crate_type = \"proc-macro\"]` here.\n-            false\n-        } else {\n-            self.target.crt_static_default\n-        }\n+\n+    pub fn unstable_options(&self) -> bool {\n+        self.opts.unstable_opts.unstable_options\n+    }\n+\n+    pub fn is_nightly_build(&self) -> bool {\n+        self.opts.unstable_features.is_nightly_build()\n+    }\n+\n+    pub fn overflow_checks(&self) -> bool {\n+        self.opts.cg.overflow_checks.unwrap_or(self.opts.debug_assertions)\n     }\n \n     pub fn relocation_model(&self) -> RelocModel {\n@@ -772,14 +1045,6 @@ impl Session {\n         self.opts.unstable_opts.tls_model.unwrap_or(self.target.tls_model)\n     }\n \n-    pub fn is_wasi_reactor(&self) -> bool {\n-        self.target.options.os == \"wasi\"\n-            && matches!(\n-                self.opts.unstable_opts.wasi_exec_model,\n-                Some(config::WasiExecModel::Reactor)\n-            )\n-    }\n-\n     pub fn split_debuginfo(&self) -> SplitDebuginfo {\n         self.opts.cg.split_debuginfo.unwrap_or(self.target.split_debuginfo)\n     }\n@@ -792,10 +1057,6 @@ impl Session {\n         }\n     }\n \n-    pub fn target_can_use_split_dwarf(&self) -> bool {\n-        !self.target.is_like_windows && !self.target.is_like_osx\n-    }\n-\n     pub fn must_emit_unwind_tables(&self) -> bool {\n         // This is used to control the emission of the `uwtable` attribute on\n         // LLVM functions.\n@@ -823,151 +1084,6 @@ impl Session {\n             )\n     }\n \n-    pub fn generate_proc_macro_decls_symbol(&self, stable_crate_id: StableCrateId) -> String {\n-        format!(\"__rustc_proc_macro_decls_{:08x}__\", stable_crate_id.to_u64())\n-    }\n-\n-    pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n-        filesearch::FileSearch::new(\n-            &self.sysroot,\n-            self.opts.target_triple.triple(),\n-            &self.opts.search_paths,\n-            &self.target_tlib_path,\n-            kind,\n-        )\n-    }\n-    pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n-        filesearch::FileSearch::new(\n-            &self.sysroot,\n-            config::host_triple(),\n-            &self.opts.search_paths,\n-            &self.host_tlib_path,\n-            kind,\n-        )\n-    }\n-\n-    /// Returns a list of directories where target-specific tool binaries are located.\n-    pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n-        let rustlib_path = rustc_target::target_rustlib_path(&self.sysroot, &config::host_triple());\n-        let p = PathBuf::from_iter([\n-            Path::new(&self.sysroot),\n-            Path::new(&rustlib_path),\n-            Path::new(\"bin\"),\n-        ]);\n-        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n-    }\n-\n-    pub fn init_incr_comp_session(\n-        &self,\n-        session_dir: PathBuf,\n-        lock_file: flock::Lock,\n-        load_dep_graph: bool,\n-    ) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        if let IncrCompSession::NotInitialized = *incr_comp_session {\n-        } else {\n-            panic!(\"Trying to initialize IncrCompSession `{:?}`\", *incr_comp_session)\n-        }\n-\n-        *incr_comp_session =\n-            IncrCompSession::Active { session_directory: session_dir, lock_file, load_dep_graph };\n-    }\n-\n-    pub fn finalize_incr_comp_session(&self, new_directory_path: PathBuf) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        if let IncrCompSession::Active { .. } = *incr_comp_session {\n-        } else {\n-            panic!(\"trying to finalize `IncrCompSession` `{:?}`\", *incr_comp_session);\n-        }\n-\n-        // Note: this will also drop the lock file, thus unlocking the directory.\n-        *incr_comp_session = IncrCompSession::Finalized { session_directory: new_directory_path };\n-    }\n-\n-    pub fn mark_incr_comp_session_as_invalid(&self) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        let session_directory = match *incr_comp_session {\n-            IncrCompSession::Active { ref session_directory, .. } => session_directory.clone(),\n-            IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n-            _ => panic!(\"trying to invalidate `IncrCompSession` `{:?}`\", *incr_comp_session),\n-        };\n-\n-        // Note: this will also drop the lock file, thus unlocking the directory.\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n-    }\n-\n-    pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n-        let incr_comp_session = self.incr_comp_session.borrow();\n-        cell::Ref::map(incr_comp_session, |incr_comp_session| match *incr_comp_session {\n-            IncrCompSession::NotInitialized => panic!(\n-                \"trying to get session directory from `IncrCompSession`: {:?}\",\n-                *incr_comp_session,\n-            ),\n-            IncrCompSession::Active { ref session_directory, .. }\n-            | IncrCompSession::Finalized { ref session_directory }\n-            | IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n-                session_directory\n-            }\n-        })\n-    }\n-\n-    pub fn incr_comp_session_dir_opt(&self) -> Option<cell::Ref<'_, PathBuf>> {\n-        self.opts.incremental.as_ref().map(|_| self.incr_comp_session_dir())\n-    }\n-\n-    pub fn print_perf_stats(&self) {\n-        eprintln!(\n-            \"Total time spent computing symbol hashes:      {}\",\n-            duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n-        );\n-        eprintln!(\n-            \"Total queries canonicalized:                   {}\",\n-            self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n-        );\n-        eprintln!(\n-            \"normalize_generic_arg_after_erasing_regions:   {}\",\n-            self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n-        );\n-        eprintln!(\n-            \"normalize_projection_ty:                       {}\",\n-            self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed)\n-        );\n-    }\n-\n-    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n-    /// This expends fuel if applicable, and records fuel if applicable.\n-    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n-        let mut ret = true;\n-        if let Some((ref c, _)) = self.opts.unstable_opts.fuel {\n-            if c == crate_name {\n-                assert_eq!(self.threads(), 1);\n-                let mut fuel = self.optimization_fuel.lock();\n-                ret = fuel.remaining != 0;\n-                if fuel.remaining == 0 && !fuel.out_of_fuel {\n-                    if self.diagnostic().can_emit_warnings() {\n-                        // We only call `msg` in case we can actually emit warnings.\n-                        // Otherwise, this could cause a `delay_good_path_bug` to\n-                        // trigger (issue #79546).\n-                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n-                    }\n-                    fuel.out_of_fuel = true;\n-                } else if fuel.remaining > 0 {\n-                    fuel.remaining -= 1;\n-                }\n-            }\n-        }\n-        if let Some(ref c) = self.opts.unstable_opts.print_fuel {\n-            if c == crate_name {\n-                assert_eq!(self.threads(), 1);\n-                self.print_fuel.fetch_add(1, SeqCst);\n-            }\n-        }\n-        ret\n-    }\n-\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn threads(&self) -> usize {\n@@ -1048,109 +1164,17 @@ impl Session {\n         self.opts.unstable_opts.teach && self.diagnostic().must_teach(code)\n     }\n \n-    pub fn rust_2015(&self) -> bool {\n-        self.opts.edition == Edition::Edition2015\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2018 edition?\n-    pub fn rust_2018(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2018\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2021 edition?\n-    pub fn rust_2021(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2021\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2024 edition?\n-    pub fn rust_2024(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2024\n-    }\n-\n     pub fn edition(&self) -> Edition {\n         self.opts.edition\n     }\n \n-    /// Returns `true` if we cannot skip the PLT for shared library calls.\n-    pub fn needs_plt(&self) -> bool {\n-        // Check if the current target usually needs PLT to be enabled.\n-        // The user can use the command line flag to override it.\n-        let needs_plt = self.target.needs_plt;\n-\n-        let dbg_opts = &self.opts.unstable_opts;\n-\n-        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.relro_level);\n-\n-        // Only enable this optimization by default if full relro is also enabled.\n-        // In this case, lazy binding was already unavailable, so nothing is lost.\n-        // This also ensures `-Wl,-z,now` is supported by the linker.\n-        let full_relro = RelroLevel::Full == relro_level;\n-\n-        // If user didn't explicitly forced us to use / skip the PLT,\n-        // then try to skip it where possible.\n-        dbg_opts.plt.unwrap_or(needs_plt || !full_relro)\n-    }\n-\n-    /// Checks if LLVM lifetime markers should be emitted.\n-    pub fn emit_lifetime_markers(&self) -> bool {\n-        self.opts.optimize != config::OptLevel::No\n-        // AddressSanitizer uses lifetimes to detect use after scope bugs.\n-        // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n-        // HWAddressSanitizer will use lifetimes to detect use after scope bugs in the future.\n-        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n-    }\n-\n     pub fn link_dead_code(&self) -> bool {\n         self.opts.cg.link_dead_code.unwrap_or(false)\n     }\n-\n-    pub fn instrument_coverage(&self) -> bool {\n-        self.opts.instrument_coverage()\n-    }\n-\n-    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n-        self.opts.instrument_coverage_except_unused_generics()\n-    }\n-\n-    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n-        self.opts.instrument_coverage_except_unused_functions()\n-    }\n-\n-    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n-        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-            .iter()\n-            .any(|kind| attr.has_name(*kind))\n-    }\n-\n-    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| item.has_name(name))\n-    }\n-\n-    pub fn find_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| attr.has_name(name))\n-    }\n-\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| attr.has_name(name))\n-    }\n-\n-    pub fn first_attr_value_str_by_name(\n-        &self,\n-        attrs: &[Attribute],\n-        name: Symbol,\n-    ) -> Option<Symbol> {\n-        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n-    }\n }\n \n+// JUSTIFICATION: part of session construction\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n fn default_emitter(\n     sopts: &config::Options,\n     registry: rustc_errors::registry::Registry,\n@@ -1235,6 +1259,8 @@ pub enum DiagnosticOutput {\n     Raw(Box<dyn Write + Send>),\n }\n \n+// JUSTIFICATION: literally session construction\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn build_session(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n@@ -1356,11 +1382,8 @@ pub fn build_session(\n         CguReuseTracker::new_disabled()\n     };\n \n-    let prof = SelfProfilerRef::new(\n-        self_profiler,\n-        sopts.unstable_opts.time_passes || sopts.unstable_opts.time,\n-        sopts.unstable_opts.time_passes,\n-    );\n+    let prof =\n+        SelfProfilerRef::new(self_profiler, sopts.time_passes(), sopts.unstable_opts.time_passes);\n \n     let ctfe_backtrace = Lock::new(match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n         Ok(ref val) if val == \"immediate\" => CtfeBacktrace::Immediate,\n@@ -1409,8 +1432,12 @@ pub fn build_session(\n     sess\n }\n \n-// If it is useful to have a Session available already for validating a\n-// commandline argument, you can do so here.\n+/// Validate command line arguments with a `Session`.\n+///\n+/// If it is useful to have a Session available already for validating a commandline argument, you\n+/// can do so here.\n+// JUSTIFICATION: needs to access args to validate them\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n fn validate_commandline_args_with_session_available(sess: &Session) {\n     // Since we don't know if code in an rlib will be linked to statically or\n     // dynamically downstream, rustc generates `__imp_` symbols that help linkers"}, {"sha": "060e7a7b90aeeea7ebefc27679e0912efb05bdcc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -1238,6 +1238,8 @@ symbols! {\n         rustc_layout_scalar_valid_range_start,\n         rustc_legacy_const_generics,\n         rustc_lint_diagnostics,\n+        rustc_lint_opt_deny_field_access,\n+        rustc_lint_opt_ty,\n         rustc_lint_query_instability,\n         rustc_macro_transparency,\n         rustc_main,"}, {"sha": "d6bd6945e150ad09704dc0c0a1ff583365dcecf7", "filename": "src/test/ui-fulldeps/internal-lints/bad_opt_access.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Z unstable-options\n+\n+// Test that accessing command line options by field access triggers a lint for those fields\n+// that have wrapper functions which should be used.\n+\n+#![crate_type = \"lib\"]\n+#![feature(rustc_private)]\n+#![deny(rustc::bad_opt_access)]\n+\n+extern crate rustc_session;\n+use rustc_session::Session;\n+\n+pub fn access_bad_option(sess: Session) {\n+    let _ = sess.opts.cg.split_debuginfo;\n+    //~^ ERROR use `Session::split_debuginfo` instead of this field\n+\n+    let _ = sess.opts.crate_types;\n+    //~^ ERROR use `Session::crate_types` instead of this field\n+\n+    let _ = sess.opts.crate_name;\n+    // okay!\n+}"}, {"sha": "e4145bff8bee97ffc71043e6dfb612ace156dd15", "filename": "src/test/ui-fulldeps/internal-lints/bad_opt_access.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -0,0 +1,20 @@\n+error: use `Session::split_debuginfo` instead of this field\n+  --> $DIR/bad_opt_access.rs:14:13\n+   |\n+LL |     let _ = sess.opts.cg.split_debuginfo;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/bad_opt_access.rs:8:9\n+   |\n+LL | #![deny(rustc::bad_opt_access)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: use `Session::crate_types` instead of this field\n+  --> $DIR/bad_opt_access.rs:17:13\n+   |\n+LL |     let _ = sess.opts.crate_types;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c1ec2bd5bd665c659475866d3ba817ff37189aef", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bab769b58db292721ddcb73cc6a7e56cb2b08ab/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=7bab769b58db292721ddcb73cc6a7e56cb2b08ab", "patch": "@@ -94,6 +94,8 @@ struct ClippyCallbacks {\n }\n \n impl rustc_driver::Callbacks for ClippyCallbacks {\n+    // JUSTIFICATION: necessary in clippy driver to set `mir_opt_level`\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     fn config(&mut self, config: &mut interface::Config) {\n         let previous = config.register_lints.take();\n         let clippy_args_var = self.clippy_args_var.take();"}]}