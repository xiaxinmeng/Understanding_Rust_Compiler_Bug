{"sha": "1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMmRiYTFlN2NmMTU0NDIyNTdmMmNkM2RkZmU1ZDA0NjJlZTkxMDI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-08T19:39:13Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-19T04:54:42Z"}, "message": "Use `T::BITS` instead of `size_of::<T> * 8`.", "tree": {"sha": "402ea425d8883c2c501f563220fddf001d0f91c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/402ea425d8883c2c501f563220fddf001d0f91c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "html_url": "https://github.com/rust-lang/rust/commit/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c30a16fa03efaf87241b363f4323743746c12b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c30a16fa03efaf87241b363f4323743746c12b0", "html_url": "https://github.com/rust-lang/rust/commit/5c30a16fa03efaf87241b363f4323743746c12b0"}], "stats": {"total": 108, "additions": 44, "deletions": 64}, "files": [{"sha": "06718cc9803127f2e9e50a4011963c2eaf0db16a", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -14,6 +14,7 @@\n #![feature(generators)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n+#![feature(int_bits_const)]\n #![feature(min_specialization)]\n #![feature(optin_builtin_traits)]\n #![feature(nll)]"}, {"sha": "d63bcdb3c2b0425d4993010dccc6fb0aee679cab", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -48,7 +48,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n-    const TAG_BIT_SHIFT: usize = (8 * std::mem::size_of::<usize>()) - T::BITS;\n+    const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n     const ASSERTION: () = {\n         assert!(T::BITS <= P::BITS);\n         // Used for the transmute_copy's below"}, {"sha": "8a7dd9d4249a8b66a802cdb2e30db6abee59213e", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -146,7 +146,7 @@\n \n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n-use core::mem::{self, size_of, swap, ManuallyDrop};\n+use core::mem::{self, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -617,7 +617,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         #[inline(always)]\n         fn log2_fast(x: usize) -> usize {\n-            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+            (usize::BITS - x.leading_zeros() - 1) as usize\n         }\n \n         // `rebuild` takes O(len1 + len2) operations"}, {"sha": "f3c1eee47c7216ac1d1036e8b4d858326738e2e8", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -101,6 +101,7 @@\n #![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(inplace_iteration)]\n+#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(libc)]"}, {"sha": "62675665f037f39da3c680db2e7338f6fdc83071", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -528,7 +528,7 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n-    if mem::size_of::<usize>() < 8 && alloc_size > isize::MAX as usize {\n+    if usize::BITS < 64 && alloc_size > isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n         Ok(())"}, {"sha": "3ee0cfbe74759862a6da591141abb1b85a931808", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -18,6 +18,7 @@\n #![feature(deque_range)]\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n+#![feature(int_bits_const)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "a6e41b21b618c8d841d510c73fcba95e24028993", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n-use std::mem::size_of;\n use std::ops::Bound::*;\n \n pub trait IntoCow<'a, B: ?Sized>\n@@ -605,7 +604,7 @@ fn test_try_reserve() {\n     // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n     // Any platform that succeeds for these requests is technically broken with\n     // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         // Note: basic stuff is checked by test_reserve\n@@ -686,7 +685,7 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         let mut empty_string: String = String::new();"}, {"sha": "a49ca7c256a75697ff19c6c7aad7738e730a7cfa", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -1341,7 +1341,7 @@ fn test_try_reserve() {\n     // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n     // Any platform that succeeds for these requests is technically broken with\n     // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         // Note: basic stuff is checked by test_reserve"}, {"sha": "8558cb5a5e8a32ebadc1f8c3becb89f78f73f3c5", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -2086,7 +2086,7 @@ impl<T: ?Sized> Pointer for *const T {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n             if f.width.is_none() {\n-                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n+                f.width = Some((usize::BITS / 4) as usize + 2);\n             }\n         }\n         f.flags |= 1 << (FlagV1::Alternate as u32);"}, {"sha": "6a1a1e1976160077f340cf17664a8a8f4434cf85", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -20,7 +20,6 @@\n #![macro_use]\n \n use crate::intrinsics;\n-use crate::mem;\n \n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n@@ -58,25 +57,22 @@ macro_rules! impl_full_ops {\n                     // This cannot overflow;\n                     // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                     // FIXME: will LLVM optimize this into ADC or similar?\n-                    let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n-                    ((v >> nbits) as $ty, v as $ty)\n+                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                 }\n \n                 fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n                     // This cannot overflow;\n                     // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n-                    let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n                             (carry as $bigty);\n-                    ((v >> nbits) as $ty, v as $ty)\n+                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                 }\n \n                 fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n                     debug_assert!(borrow < other);\n                     // This cannot overflow; the output is between `0` and `other * (2^nbits - 1)`.\n-                    let nbits = mem::size_of::<$ty>() * 8;\n-                    let lhs = ((borrow as $bigty) << nbits) | (self as $bigty);\n+                    let lhs = ((borrow as $bigty) << <$ty>::BITS) | (self as $bigty);\n                     let rhs = other as $bigty;\n                     ((lhs / rhs) as $ty, (lhs % rhs) as $ty)\n                 }\n@@ -128,13 +124,11 @@ macro_rules! define_bignum {\n \n             /// Makes a bignum from `u64` value.\n             pub fn from_u64(mut v: u64) -> $name {\n-                use crate::mem;\n-\n                 let mut base = [0; $n];\n                 let mut sz = 0;\n                 while v > 0 {\n                     base[sz] = v as $ty;\n-                    v >>= mem::size_of::<$ty>() * 8;\n+                    v >>= <$ty>::BITS;\n                     sz += 1;\n                 }\n                 $name { size: sz, base: base }\n@@ -150,9 +144,7 @@ macro_rules! define_bignum {\n             /// Returns the `i`-th bit where bit 0 is the least significant one.\n             /// In other words, the bit with weight `2^i`.\n             pub fn get_bit(&self, i: usize) -> u8 {\n-                use crate::mem;\n-\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let d = i / digitbits;\n                 let b = i % digitbits;\n                 ((self.base[d] >> b) & 1) as u8\n@@ -166,8 +158,6 @@ macro_rules! define_bignum {\n             /// Returns the number of bits necessary to represent this value. Note that zero\n             /// is considered to need 0 bits.\n             pub fn bit_length(&self) -> usize {\n-                use crate::mem;\n-\n                 // Skip over the most significant digits which are zero.\n                 let digits = self.digits();\n                 let zeros = digits.iter().rev().take_while(|&&x| x == 0).count();\n@@ -180,7 +170,7 @@ macro_rules! define_bignum {\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;\n@@ -265,9 +255,7 @@ macro_rules! define_bignum {\n \n             /// Multiplies itself by `2^bits` and returns its own mutable reference.\n             pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n-                use crate::mem;\n-\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let digits = bits / digitbits;\n                 let bits = bits % digitbits;\n \n@@ -393,13 +381,11 @@ macro_rules! define_bignum {\n             /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n             /// remainder.\n             pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n-                use crate::mem;\n-\n                 // Stupid slow base-2 long division taken from\n                 // https://en.wikipedia.org/wiki/Division_algorithm\n                 // FIXME use a greater base ($ty) for the long division.\n                 assert!(!d.is_zero());\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 for digit in &mut q.base[..] {\n                     *digit = 0;\n                 }\n@@ -462,10 +448,8 @@ macro_rules! define_bignum {\n \n         impl crate::fmt::Debug for $name {\n             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n-                use crate::mem;\n-\n                 let sz = if self.size < 1 { 1 } else { self.size };\n-                let digitlen = mem::size_of::<$ty>() * 2;\n+                let digitlen = <$ty>::BITS as usize / 4;\n \n                 write!(f, \"{:#x}\", self.base[sz - 1])?;\n                 for &v in self.base[..sz - 1].iter().rev() {"}, {"sha": "71d2c2c9b2f4c2f3be43c3f9754ceec87f56c8dc", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -565,7 +565,7 @@ fn break_patterns<T>(v: &mut [T]) {\n             random\n         };\n         let mut gen_usize = || {\n-            if mem::size_of::<usize>() <= 4 {\n+            if usize::BITS <= 32 {\n                 gen_u32() as usize\n             } else {\n                 (((gen_u32() as u64) << 32) | (gen_u32() as u64)) as usize\n@@ -667,7 +667,7 @@ where\n ///\n /// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n /// this function will immediately switch to heapsort.\n-fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n+fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: u32)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -763,7 +763,7 @@ where\n     }\n \n     // Limit the number of imbalanced partitions to `floor(log2(len)) + 1`.\n-    let limit = mem::size_of::<usize>() * 8 - v.len().leading_zeros() as usize;\n+    let limit = usize::BITS - v.len().leading_zeros();\n \n     recurse(v, &mut is_less, None, limit);\n }"}, {"sha": "0eb9af3f454e986adb2eb73e2161a447eab939f8", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -474,7 +474,7 @@ fn test_iterator_step_by_nth_overflow() {\n     }\n \n     let mut it = Test(0);\n-    let root = usize::MAX >> (::std::mem::size_of::<usize>() * 8 / 2);\n+    let root = usize::MAX >> (usize::BITS / 2);\n     let n = root + 20;\n     (&mut it).step_by(n).nth(n);\n     assert_eq!(it.0, n as Bigger * n as Bigger);"}, {"sha": "4db391f3e567eb69c962c40b7c53264320c5057e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -52,6 +52,7 @@\n #![feature(partition_point)]\n #![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(int_bits_const)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "27e6760e7cbb9175e667dc50941b4828dec8ec0f", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -2,7 +2,6 @@ macro_rules! int_module {\n     ($T:ident, $T_i:ident) => {\n         #[cfg(test)]\n         mod tests {\n-            use core::mem;\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n             use core::$T_i::*;\n \n@@ -82,30 +81,27 @@ macro_rules! int_module {\n \n             #[test]\n             fn test_count_zeros() {\n-                let bits = mem::size_of::<$T>() * 8;\n-                assert_eq!(A.count_zeros(), bits as u32 - 3);\n-                assert_eq!(B.count_zeros(), bits as u32 - 2);\n-                assert_eq!(C.count_zeros(), bits as u32 - 5);\n+                assert_eq!(A.count_zeros(), $T::BITS - 3);\n+                assert_eq!(B.count_zeros(), $T::BITS - 2);\n+                assert_eq!(C.count_zeros(), $T::BITS - 5);\n             }\n \n             #[test]\n             fn test_leading_trailing_ones() {\n-                let bits = (mem::size_of::<$T>() * 8) as u32;\n-\n                 let a: $T = 0b0101_1111;\n                 assert_eq!(a.trailing_ones(), 5);\n-                assert_eq!((!a).leading_ones(), bits - 7);\n+                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n \n                 assert_eq!(a.reverse_bits().leading_ones(), 5);\n \n-                assert_eq!(_1.leading_ones(), bits);\n-                assert_eq!(_1.trailing_ones(), bits);\n+                assert_eq!(_1.leading_ones(), $T::BITS);\n+                assert_eq!(_1.trailing_ones(), $T::BITS);\n \n                 assert_eq!((_1 << 1).trailing_ones(), 0);\n                 assert_eq!(MAX.leading_ones(), 0);\n \n-                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n-                assert_eq!(MAX.trailing_ones(), bits - 1);\n+                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n+                assert_eq!(MAX.trailing_ones(), $T::BITS - 1);\n \n                 assert_eq!(_0.leading_ones(), 0);\n                 assert_eq!(_0.trailing_ones(), 0);"}, {"sha": "952ec188dc1385f9911e4665c237db2935feb2f4", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -4,7 +4,6 @@ macro_rules! uint_module {\n         mod tests {\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n             use core::$T_i::*;\n-            use std::mem;\n             use std::str::FromStr;\n \n             use crate::num;\n@@ -47,30 +46,27 @@ macro_rules! uint_module {\n \n             #[test]\n             fn test_count_zeros() {\n-                let bits = mem::size_of::<$T>() * 8;\n-                assert!(A.count_zeros() == bits as u32 - 3);\n-                assert!(B.count_zeros() == bits as u32 - 2);\n-                assert!(C.count_zeros() == bits as u32 - 5);\n+                assert!(A.count_zeros() == $T::BITS - 3);\n+                assert!(B.count_zeros() == $T::BITS - 2);\n+                assert!(C.count_zeros() == $T::BITS - 5);\n             }\n \n             #[test]\n             fn test_leading_trailing_ones() {\n-                let bits = (mem::size_of::<$T>() * 8) as u32;\n-\n                 let a: $T = 0b0101_1111;\n                 assert_eq!(a.trailing_ones(), 5);\n-                assert_eq!((!a).leading_ones(), bits - 7);\n+                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n \n                 assert_eq!(a.reverse_bits().leading_ones(), 5);\n \n-                assert_eq!(_1.leading_ones(), bits);\n-                assert_eq!(_1.trailing_ones(), bits);\n+                assert_eq!(_1.leading_ones(), $T::BITS);\n+                assert_eq!(_1.trailing_ones(), $T::BITS);\n \n                 assert_eq!((_1 << 1).trailing_ones(), 0);\n                 assert_eq!((_1 >> 1).leading_ones(), 0);\n \n-                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n-                assert_eq!((_1 >> 1).trailing_ones(), bits - 1);\n+                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n+                assert_eq!((_1 >> 1).trailing_ones(), $T::BITS - 1);\n \n                 assert_eq!(_0.leading_ones(), 0);\n                 assert_eq!(_0.trailing_ones(), 0);"}, {"sha": "652fbe95a14d195f39281a727d056b5f78aede60", "filename": "library/panic_unwind/src/dwarf/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -53,7 +53,7 @@ impl DwarfReader {\n     }\n \n     pub unsafe fn read_sleb128(&mut self) -> i64 {\n-        let mut shift: usize = 0;\n+        let mut shift: u32 = 0;\n         let mut result: u64 = 0;\n         let mut byte: u8;\n         loop {\n@@ -65,7 +65,7 @@ impl DwarfReader {\n             }\n         }\n         // sign-extend\n-        if shift < 8 * mem::size_of::<u64>() && (byte & 0x40) != 0 {\n+        if shift < u64::BITS && (byte & 0x40) != 0 {\n             result |= (!0 as u64) << shift;\n         }\n         result as i64"}, {"sha": "162f0386b6692c757e845c91f55e70babad28995", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=1e2dba1e7cf15442257f2cd3ddfe5d0462ee9102", "patch": "@@ -18,6 +18,7 @@\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\"\n )]\n #![feature(core_intrinsics)]\n+#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(nll)]"}]}