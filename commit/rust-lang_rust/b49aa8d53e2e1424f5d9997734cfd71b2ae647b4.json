{"sha": "b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "node_id": "C_kwDOAAsO6NoAKGI0OWFhOGQ1M2UyZTE0MjRmNWQ5OTk3NzM0Y2ZkNzFiMmFlNjQ3YjQ", "commit": {"author": {"name": "Mateusz Guzik", "email": "mjguzik@gmail.com", "date": "2023-01-10T02:08:07Z"}, "committer": {"name": "Mateusz Guzik", "email": "mjguzik@gmail.com", "date": "2023-01-11T17:10:08Z"}, "message": "Stop probing for statx unless necessary\n\nAs is the current toy program:\nfn main() -> std::io::Result<()> {\n    use std::fs;\n\n    let metadata = fs::metadata(\"foo.txt\")?;\n\n    assert!(!metadata.is_dir());\n    Ok(())\n}\n\n... observed under strace will issue:\n[snip]\nstatx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address)\nstatx(AT_FDCWD, \"foo.txt\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\n\nWhile statx is not necessarily always present, checking for it can be\ndelayed to the first error condition. Said condition may very well never\nhappen, in which case the check got avoided altogether.\n\nNote this is still suboptimal as there still will be programs issuing\nit, but bulk of the problem is removed.\n\nTested by forbidding the syscall for the binary and observing it\ncorrectly falls back to newfstatat.\n\nWhile here tidy up the commentary, in particular by denoting some\nproblems with the current approach.", "tree": {"sha": "1366592b15714196c761e575f19c810d0bd2eb1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1366592b15714196c761e575f19c810d0bd2eb1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "html_url": "https://github.com/rust-lang/rust/commit/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4/comments", "author": {"login": "mjguzik", "id": 9325157, "node_id": "MDQ6VXNlcjkzMjUxNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/9325157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjguzik", "html_url": "https://github.com/mjguzik", "followers_url": "https://api.github.com/users/mjguzik/followers", "following_url": "https://api.github.com/users/mjguzik/following{/other_user}", "gists_url": "https://api.github.com/users/mjguzik/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjguzik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjguzik/subscriptions", "organizations_url": "https://api.github.com/users/mjguzik/orgs", "repos_url": "https://api.github.com/users/mjguzik/repos", "events_url": "https://api.github.com/users/mjguzik/events{/privacy}", "received_events_url": "https://api.github.com/users/mjguzik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mjguzik", "id": 9325157, "node_id": "MDQ6VXNlcjkzMjUxNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/9325157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjguzik", "html_url": "https://github.com/mjguzik", "followers_url": "https://api.github.com/users/mjguzik/followers", "following_url": "https://api.github.com/users/mjguzik/following{/other_user}", "gists_url": "https://api.github.com/users/mjguzik/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjguzik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjguzik/subscriptions", "organizations_url": "https://api.github.com/users/mjguzik/orgs", "repos_url": "https://api.github.com/users/mjguzik/repos", "events_url": "https://api.github.com/users/mjguzik/events{/privacy}", "received_events_url": "https://api.github.com/users/mjguzik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "753e57672296e13c534f87b6e2672a73fff4965c", "url": "https://api.github.com/repos/rust-lang/rust/commits/753e57672296e13c534f87b6e2672a73fff4965c", "html_url": "https://github.com/rust-lang/rust/commit/753e57672296e13c534f87b6e2672a73fff4965c"}], "stats": {"total": 68, "additions": 41, "deletions": 27}, "files": [{"sha": "0e7d23a5c7c9d916bb9c4bdabe6329eee3c78088", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "patch": "@@ -149,12 +149,13 @@ cfg_has_statx! {{\n     ) -> Option<io::Result<FileAttr>> {\n         use crate::sync::atomic::{AtomicU8, Ordering};\n \n-        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in global to avoid unnecessary syscalls.\n-        // 0: Unknown\n-        // 1: Not available\n-        // 2: Available\n-        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n+        // We check for it on first failure and remember availability to avoid having to\n+        // do it again.\n+        #[repr(u8)]\n+        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n+        static STATX_SAVED_STATE: AtomicU8 = AtomicU8::new(STATX_STATE::Unknown as u8);\n+\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -165,31 +166,44 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        match STATX_STATE.load(Ordering::Relaxed) {\n-            0 => {\n-                // It is a trick to call `statx` with null pointers to check if the syscall\n-                // is available. According to the manual, it is expected to fail with EFAULT.\n-                // We do this mainly for performance, since it is nearly hundreds times\n-                // faster than a normal successful call.\n-                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n-                    .err()\n-                    .and_then(|e| e.raw_os_error());\n-                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n-                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n-                // See: https://github.com/rust-lang/rust/issues/65662\n-                if err != Some(libc::EFAULT) {\n-                    STATX_STATE.store(1, Ordering::Relaxed);\n-                    return None;\n-                }\n-                STATX_STATE.store(2, Ordering::Relaxed);\n-            }\n-            1 => return None,\n-            _ => {}\n+        if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Unavailable as u8 {\n+            return None;\n         }\n \n         let mut buf: libc::statx = mem::zeroed();\n         if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n-            return Some(Err(err));\n+            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n+                return Some(Err(err));\n+            }\n+\n+            // Availability not checked yet.\n+            //\n+            // First try the cheap way.\n+            if err.raw_os_error() == Some(libc::ENOSYS) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n+\n+            // Error other than `ENOSYS` is not a good enough indicator -- it is\n+            // known that `EPERM` can be returned as a result of using seccomp to\n+            // block the syscall.\n+            // Availability is checked by performing a call which expects `EFAULT`\n+            // if the syscall is usable.\n+            // See: https://github.com/rust-lang/rust/issues/65662\n+            // FIXME this can probably just do the call if `EPERM` was received, but\n+            // previous iteration of the code checked it for all errors and for now\n+            // this is retained.\n+            // FIXME what about transient conditions like `ENOMEM`?\n+            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                .err()\n+                .and_then(|e| e.raw_os_error());\n+            if err2 == Some(libc::EFAULT) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n+                return Some(Err(err));\n+            } else {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n         }\n \n         // We cannot fill `stat64` exhaustively because of private padding fields."}]}