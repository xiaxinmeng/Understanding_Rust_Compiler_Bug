{"sha": "8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTY1ZGE5MzVkN2UwMWRiYWM4OTdkY2ZiYjRmYjBmOWYyNGU0NDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-23T14:25:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-08-28T15:34:31Z"}, "message": "std: Remove the `wasm_syscall` feature\n\nThis commit removes the `wasm_syscall` feature from the\nwasm32-unknown-unknown build of the standard library. This feature was\noriginally intended to allow an opt-in way to interact with the\noperating system in a posix-like way but it was never stabilized.\nNowadays with the advent of the `wasm32-wasi` target that should\nentirely replace the intentions of the `wasm_syscall` feature.", "tree": {"sha": "b254c7ebfb19010383348d31d31b83e85445d644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b254c7ebfb19010383348d31d31b83e85445d644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "html_url": "https://github.com/rust-lang/rust/commit/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac21131f7859836cd3fcb39231c0162fd892d960", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac21131f7859836cd3fcb39231c0162fd892d960", "html_url": "https://github.com/rust-lang/rust/commit/ac21131f7859836cd3fcb39231c0162fd892d960"}], "stats": {"total": 398, "additions": 19, "deletions": 379}, "files": [{"sha": "30e2ee1b9babf4609e77ef6c663842e4fa68c2bd", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -382,11 +382,6 @@\n # This is the name of the directory in which codegen backends will get installed\n #codegen-backends-dir = \"codegen-backends\"\n \n-# Flag indicating whether `libstd` calls an imported function to handle basic IO\n-# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n-# target, as without this option the test output will not be captured.\n-#wasm-syscall = false\n-\n # Indicates whether LLD will be compiled and made available in the sysroot for\n # rustc to execute.\n #lld = false"}, {"sha": "43d9264eaca92ee6584485ed37a2e1e71a503762", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -122,7 +122,6 @@ pub struct Config {\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n-    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n@@ -318,7 +317,6 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n-    wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n@@ -558,7 +556,6 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n-            set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);"}, {"sha": "0982f2247339244dca24af4fa31ec62f2e6e47e6", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -498,9 +498,6 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        if self.config.wasm_syscall {\n-            features.push_str(\" wasm_syscall\");\n-        }\n         features\n     }\n "}, {"sha": "97b28ed9e96c81468f2dd877f775d3cbeff051af", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -1811,16 +1811,6 @@ impl Step for Crate {\n                     .expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            // Warn about running tests without the `wasm_syscall` feature enabled.\n-            // The javascript shim implements the syscall interface so that test\n-            // output can be correctly reported.\n-            if !builder.config.wasm_syscall {\n-                builder.info(\n-                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n-                     test output may not be visible.\"\n-                );\n-            }\n-\n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");"}, {"sha": "262a53eabe3c7bf3030eafc9c8c79a8d3000522c", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -15,113 +15,7 @@ const buffer = fs.readFileSync(process.argv[2]);\n Error.stackTraceLimit = 20;\n \n let m = new WebAssembly.Module(buffer);\n-\n-let memory = null;\n-\n-function viewstruct(data, fields) {\n-  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n-}\n-\n-function copystr(a, b) {\n-  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n-  return String.fromCharCode.apply(null, view);\n-}\n-\n-function syscall_write([fd, ptr, len]) {\n-  let s = copystr(ptr, len);\n-  switch (fd) {\n-    case 1: process.stdout.write(s); break;\n-    case 2: process.stderr.write(s); break;\n-  }\n-}\n-\n-function syscall_exit([code]) {\n-  process.exit(code);\n-}\n-\n-function syscall_args(params) {\n-  let [ptr, len] = params;\n-\n-  // Calculate total required buffer size\n-  let totalLen = -1;\n-  for (let i = 2; i < process.argv.length; ++i) {\n-    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n-  }\n-  if (totalLen < 0) { totalLen = 0; }\n-  params[2] = totalLen;\n-\n-  // If buffer is large enough, copy data\n-  if (len >= totalLen) {\n-    let view = new Uint8Array(memory.buffer);\n-    for (let i = 2; i < process.argv.length; ++i) {\n-      let value = process.argv[i];\n-      Buffer.from(value).copy(view, ptr);\n-      ptr += Buffer.byteLength(process.argv[i]) + 1;\n-    }\n-  }\n-}\n-\n-function syscall_getenv(params) {\n-  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n-\n-  let key = copystr(keyPtr, keyLen);\n-  let value = process.env[key];\n-\n-  if (value == null) {\n-    params[4] = 0xFFFFFFFF;\n-  } else {\n-    let view = new Uint8Array(memory.buffer);\n-    let totalLen = Buffer.byteLength(value);\n-    params[4] = totalLen;\n-    if (valueLen >= totalLen) {\n-      Buffer.from(value).copy(view, valuePtr);\n-    }\n-  }\n-}\n-\n-function syscall_time(params) {\n-  let t = Date.now();\n-  let secs = Math.floor(t / 1000);\n-  let millis = t % 1000;\n-  params[1] = Math.floor(secs / 0x100000000);\n-  params[2] = secs % 0x100000000;\n-  params[3] = Math.floor(millis * 1000000);\n-}\n-\n-let imports = {};\n-imports.env = {\n-  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n-  // one day this is not necessary and something will automatically do this.\n-  fmod: function(x, y) { return x % y; },\n-  exp2: function(x) { return Math.pow(2, x); },\n-  exp2f: function(x) { return Math.pow(2, x); },\n-  ldexp: function(x, y) { return x * Math.pow(2, y); },\n-  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n-  sin: Math.sin,\n-  sinf: Math.sin,\n-  cos: Math.cos,\n-  cosf: Math.cos,\n-  log: Math.log,\n-  log2: Math.log2,\n-  log10: Math.log10,\n-  log10f: Math.log10,\n-\n-  rust_wasm_syscall: function(index, data) {\n-    switch (index) {\n-      case 1: syscall_write(viewstruct(data, 3)); return true;\n-      case 2: syscall_exit(viewstruct(data, 1)); return true;\n-      case 3: syscall_args(viewstruct(data, 3)); return true;\n-      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n-      case 6: syscall_time(viewstruct(data, 4)); return true;\n-      default:\n-        console.log(\"Unsupported syscall: \" + index);\n-        return false;\n-    }\n-  }\n-};\n-\n-let instance = new WebAssembly.Instance(m, imports);\n-memory = instance.exports.memory;\n+let instance = new WebAssembly.Instance(m, {});\n try {\n   instance.exports.main();\n } catch (e) {"}, {"sha": "157faa0af9bca1858689201ecb05e977afc8a17b", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -70,11 +70,6 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n # Make panics and failed asserts immediately abort without formatting any message\n panic_immediate_abort = [\"core/panic_immediate_abort\"]\n \n-# An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n-# interoperate with the host environment. Currently not well documented and\n-# requires rebuilding the standard library to use it.\n-wasm_syscall = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "8279e5280e9249b2c53f69b1843ba5803b1882bd", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -1,7 +1,6 @@\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::vec;\n-use crate::sys::ArgsSysCall;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n@@ -11,9 +10,8 @@ pub unsafe fn cleanup() {\n }\n \n pub fn args() -> Args {\n-    let v = ArgsSysCall::perform();\n     Args {\n-        iter: v.into_iter(),\n+        iter: Vec::new().into_iter(),\n         _dont_send_or_sync_me: PhantomData,\n     }\n }"}, {"sha": "de0bb38dc319e7c9d0c0067700c39af650ef0888", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 221, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -15,11 +15,6 @@\n //! guaranteed to be a runtime error!\n \n use crate::os::raw::c_char;\n-use crate::ptr;\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{AsInner, FromInner};\n-use crate::ffi::{OsString, OsStr};\n-use crate::time::Duration;\n \n pub mod alloc;\n pub mod args;\n@@ -89,7 +84,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    ExitSysCall::perform(1)\n+    crate::arch::wasm32::unreachable()\n }\n \n // We don't have randomness yet, but I totally used a random number generator to\n@@ -100,218 +95,3 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     (1, 2)\n }\n-\n-// Implement a minimal set of system calls to enable basic IO\n-pub enum SysCallIndex {\n-    Read = 0,\n-    Write = 1,\n-    Exit = 2,\n-    Args = 3,\n-    GetEnv = 4,\n-    SetEnv = 5,\n-    Time = 6,\n-}\n-\n-#[repr(C)]\n-pub struct ReadSysCall {\n-    fd: usize,\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize,\n-}\n-\n-impl ReadSysCall {\n-    pub fn perform(fd: usize, buffer: &mut [u8]) -> usize {\n-        let mut call_record = ReadSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_mut_ptr(),\n-            result: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Read, &mut call_record) } {\n-            call_record.result\n-        } else {\n-            0\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct WriteSysCall {\n-    fd: usize,\n-    ptr: *const u8,\n-    len: usize,\n-}\n-\n-impl WriteSysCall {\n-    pub fn perform(fd: usize, buffer: &[u8]) {\n-        let mut call_record = WriteSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_ptr()\n-        };\n-        unsafe { syscall(SysCallIndex::Write, &mut call_record); }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct ExitSysCall {\n-    code: usize,\n-}\n-\n-impl ExitSysCall {\n-    pub fn perform(code: usize) -> ! {\n-        let mut call_record = ExitSysCall {\n-            code\n-        };\n-        unsafe {\n-            syscall(SysCallIndex::Exit, &mut call_record);\n-            crate::intrinsics::abort();\n-        }\n-    }\n-}\n-\n-fn receive_buffer<E, F: FnMut(&mut [u8]) -> Result<usize, E>>(estimate: usize, mut f: F)\n-    -> Result<Vec<u8>, E>\n-{\n-    let mut buffer = vec![0; estimate];\n-    loop {\n-        let result = f(&mut buffer)?;\n-        if result <= buffer.len() {\n-            buffer.truncate(result);\n-            break;\n-        }\n-        buffer.resize(result, 0);\n-    }\n-    Ok(buffer)\n-}\n-\n-#[repr(C)]\n-pub struct ArgsSysCall {\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize\n-}\n-\n-impl ArgsSysCall {\n-    pub fn perform() -> Vec<OsString> {\n-        receive_buffer(1024, |buffer| -> Result<usize, !> {\n-            let mut call_record = ArgsSysCall {\n-                len: buffer.len(),\n-                ptr: buffer.as_mut_ptr(),\n-                result: 0\n-            };\n-            if unsafe { syscall(SysCallIndex::Args, &mut call_record) } {\n-                Ok(call_record.result)\n-            } else {\n-                Ok(0)\n-            }\n-        })\n-            .unwrap()\n-            .split(|b| *b == 0)\n-            .map(|s| FromInner::from_inner(Buf { inner: s.to_owned() }))\n-            .collect()\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct GetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *mut u8,\n-    value_len: usize,\n-    result: usize\n-}\n-\n-impl GetEnvSysCall {\n-    pub fn perform(key: &OsStr) -> Option<OsString> {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        receive_buffer(64, |buffer| {\n-            let mut call_record = GetEnvSysCall {\n-                key_len: key_buf.len(),\n-                key_ptr: key_buf.as_ptr(),\n-                value_len: buffer.len(),\n-                value_ptr: buffer.as_mut_ptr(),\n-                result: !0usize\n-            };\n-            if unsafe { syscall(SysCallIndex::GetEnv, &mut call_record) } {\n-                if call_record.result == !0usize {\n-                    Err(())\n-                } else {\n-                    Ok(call_record.result)\n-                }\n-            } else {\n-                Err(())\n-            }\n-        }).ok().map(|s| {\n-            FromInner::from_inner(Buf { inner: s })\n-        })\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct SetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *const u8,\n-    value_len: usize\n-}\n-\n-impl SetEnvSysCall {\n-    pub fn perform(key: &OsStr, value: Option<&OsStr>) {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        let value_buf = value.map(|v| &AsInner::as_inner(v).inner);\n-        let mut call_record = SetEnvSysCall {\n-            key_len: key_buf.len(),\n-            key_ptr: key_buf.as_ptr(),\n-            value_len: value_buf.map(|v| v.len()).unwrap_or(!0usize),\n-            value_ptr: value_buf.map(|v| v.as_ptr()).unwrap_or(ptr::null())\n-        };\n-        unsafe { syscall(SysCallIndex::SetEnv, &mut call_record); }\n-    }\n-}\n-\n-pub enum TimeClock {\n-    Monotonic = 0,\n-    System = 1,\n-}\n-\n-#[repr(C)]\n-pub struct TimeSysCall {\n-    clock: usize,\n-    secs_hi: usize,\n-    secs_lo: usize,\n-    nanos: usize\n-}\n-\n-impl TimeSysCall {\n-    pub fn perform(clock: TimeClock) -> Duration {\n-        let mut call_record = TimeSysCall {\n-            clock: clock as usize,\n-            secs_hi: 0,\n-            secs_lo: 0,\n-            nanos: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Time, &mut call_record) } {\n-            Duration::new(\n-                ((call_record.secs_hi as u64) << 32) | (call_record.secs_lo as u64),\n-                call_record.nanos as u32\n-            )\n-        } else {\n-            panic!(\"Time system call is not implemented by WebAssembly host\");\n-        }\n-    }\n-}\n-\n-unsafe fn syscall<T>(index: SysCallIndex, data: &mut T) -> bool {\n-    #[cfg(feature = \"wasm_syscall\")]\n-    extern {\n-        #[no_mangle]\n-        fn rust_wasm_syscall(index: usize, data: *mut Void) -> usize;\n-    }\n-\n-    #[cfg(not(feature = \"wasm_syscall\"))]\n-    unsafe fn rust_wasm_syscall(_index: usize, _data: *mut Void) -> usize { 0 }\n-\n-    rust_wasm_syscall(index as usize, data as *mut T as *mut Void) != 0\n-}"}, {"sha": "890049e8bfae50f0fb7cc815730f4a72d7403efc", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -4,7 +4,7 @@ use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n use crate::str;\n-use crate::sys::{unsupported, Void, ExitSysCall, GetEnvSysCall, SetEnvSysCall};\n+use crate::sys::{unsupported, Void};\n \n pub fn errno() -> i32 {\n     0\n@@ -73,16 +73,16 @@ pub fn env() -> Env {\n     panic!(\"not supported on web assembly\")\n }\n \n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(GetEnvSysCall::perform(k))\n+pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(None)\n }\n \n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, Some(v)))\n+pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on wasm32-unknown-unknown\"))\n }\n \n-pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, None))\n+pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on wasm32-unknown-unknown\"))\n }\n \n pub fn temp_dir() -> PathBuf {\n@@ -94,7 +94,9 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(_code: i32) -> ! {\n-    ExitSysCall::perform(_code as isize as usize)\n+    unsafe {\n+        crate::arch::wasm32::unreachable();\n+    }\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "5a4e4505e93bddce1805a1f163e2df0c66bc7cfd", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -1,5 +1,4 @@\n use crate::io;\n-use crate::sys::{ReadSysCall, WriteSysCall};\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -12,8 +11,8 @@ impl Stdin {\n }\n \n impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        Ok(ReadSysCall::perform(0, buf))\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n     }\n }\n \n@@ -25,7 +24,6 @@ impl Stdout {\n \n impl io::Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(1, buf);\n         Ok(buf.len())\n     }\n \n@@ -42,7 +40,6 @@ impl Stderr {\n \n impl io::Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(2, buf);\n         Ok(buf.len())\n     }\n \n@@ -57,10 +54,6 @@ pub fn is_ebadf(_err: &io::Error) -> bool {\n     true\n }\n \n-pub fn panic_output() -> Option<impl io::Write> {\n-    if cfg!(feature = \"wasm_syscall\") {\n-        Stderr::new().ok()\n-    } else {\n-        None\n-    }\n+pub fn panic_output() -> Option<Vec<u8>> {\n+    None\n }"}, {"sha": "dd9ad3760b050799dbd200bbcacdfbb03429db83", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe65da935d7e01dbac897dcfbb4fb0f9f24e442/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=8fe65da935d7e01dbac897dcfbb4fb0f9f24e442", "patch": "@@ -1,5 +1,4 @@\n use crate::time::Duration;\n-use crate::sys::{TimeSysCall, TimeClock};\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -11,7 +10,7 @@ pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(TimeSysCall::perform(TimeClock::Monotonic))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub const fn zero() -> Instant {\n@@ -37,7 +36,7 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(TimeSysCall::perform(TimeClock::System))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub fn sub_time(&self, other: &SystemTime)"}]}