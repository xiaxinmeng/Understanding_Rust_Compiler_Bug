{"sha": "85363d18e819c34b31b107096e80113e2a7a5891", "node_id": "C_kwDOAAsO6NoAKDg1MzYzZDE4ZTgxOWMzNGIzMWIxMDcwOTZlODAxMTNlMmE3YTU4OTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T14:22:51Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T14:22:51Z"}, "message": "Simplify", "tree": {"sha": "2973a26c18d07d6739f425a4b852dd4291d91f3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2973a26c18d07d6739f425a4b852dd4291d91f3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85363d18e819c34b31b107096e80113e2a7a5891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85363d18e819c34b31b107096e80113e2a7a5891", "html_url": "https://github.com/rust-lang/rust/commit/85363d18e819c34b31b107096e80113e2a7a5891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85363d18e819c34b31b107096e80113e2a7a5891/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "url": "https://api.github.com/repos/rust-lang/rust/commits/f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "html_url": "https://github.com/rust-lang/rust/commit/f35a9a1dccc9a7a86820cbb688cebaba23f2da85"}], "stats": {"total": 160, "additions": 95, "deletions": 65}, "files": [{"sha": "e97545eae50d0482f4c9970c05c3189e6e479b2a", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=85363d18e819c34b31b107096e80113e2a7a5891", "patch": "@@ -2,7 +2,6 @@\n \n use hir::ScopeDef;\n use ide_db::FxHashSet;\n-use syntax::T;\n \n use crate::{\n     context::{NameRefContext, NameRefKind, PathCompletionCtx, PathKind, PathQualifierCtx},\n@@ -20,6 +19,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         is_func_update,\n         after_if_expr,\n         wants_mut_token,\n+        in_condition,\n     ) = match ctx.nameref_ctx() {\n         Some(&NameRefContext {\n             kind:\n@@ -29,6 +29,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                             in_block_expr,\n                             in_loop_body,\n                             after_if_expr,\n+                            in_condition,\n                             ref ref_expr_parent,\n                             ref is_func_update,\n                         },\n@@ -45,6 +46,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n             is_func_update.is_some(),\n             after_if_expr,\n             ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false),\n+            in_condition,\n         ),\n         _ => return,\n     };\n@@ -235,10 +237,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                 add_keyword(\"true\", \"true\");\n                 add_keyword(\"false\", \"false\");\n \n-                if ctx.previous_token_is(T![if])\n-                    || ctx.previous_token_is(T![while])\n-                    || in_block_expr\n-                {\n+                if (in_condition && !is_absolute_path) || in_block_expr {\n                     add_keyword(\"let\", \"let\");\n                 }\n "}, {"sha": "3b2e383a09d7cd63b1cc95da157ea8378de70efa", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=85363d18e819c34b31b107096e80113e2a7a5891", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 matches!(location, TypeLocation::GenericArgList(_))\n             }\n             ScopeDef::ImplSelfType(_) => {\n-                !ctx.previous_token_is(syntax::T![impl]) && !ctx.previous_token_is(syntax::T![for])\n+                !matches!(location, TypeLocation::ImplTarget | TypeLocation::ImplTrait)\n             }\n             // Don't suggest attribute macros and derives.\n             ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),"}, {"sha": "767ea5c20de25f7844905565a501d1c05687f617", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=85363d18e819c34b31b107096e80113e2a7a5891", "patch": "@@ -92,6 +92,8 @@ pub(super) enum PathKind {\n         in_block_expr: bool,\n         in_loop_body: bool,\n         after_if_expr: bool,\n+        /// Whether this expression is the direct condition of an if or while expression\n+        in_condition: bool,\n         ref_expr_parent: Option<ast::RefExpr>,\n         is_func_update: Option<ast::RecordExpr>,\n     },\n@@ -121,6 +123,8 @@ pub(crate) enum TypeLocation {\n     TypeAscription(TypeAscriptionTarget),\n     GenericArgList(Option<ast::GenericArgList>),\n     TypeBound,\n+    ImplTarget,\n+    ImplTrait,\n     Other,\n }\n "}, {"sha": "c672c2761a5198f4bb8ec2274d23edfcf322c86f", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85363d18e819c34b31b107096e80113e2a7a5891/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=85363d18e819c34b31b107096e80113e2a7a5891", "patch": "@@ -327,7 +327,8 @@ impl<'a> CompletionContext<'a> {\n             return None;\n         }\n \n-        self.previous_token = previous_token(syntax_element.clone());\n+        self.previous_token =\n+            syntax_element.clone().into_token().and_then(previous_non_trivia_token);\n \n         self.incomplete_let =\n             syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n@@ -647,8 +648,8 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n-        let type_location = |it: Option<SyntaxNode>| {\n-            let parent = it?;\n+        let type_location = |node: &SyntaxNode| {\n+            let parent = node.parent()?;\n             let res = match_ast! {\n                 match parent {\n                     ast::Const(it) => {\n@@ -690,6 +691,15 @@ impl<'a> CompletionContext<'a> {\n                         }\n                         TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n                     },\n+                    ast::Impl(it) => {\n+                        match it.trait_() {\n+                            Some(t) if t.syntax() == node => TypeLocation::ImplTrait,\n+                            _ => match it.self_ty() {\n+                                Some(t) if t.syntax() == node => TypeLocation::ImplTarget,\n+                                _ => return None,\n+                            },\n+                        }\n+                    },\n                     ast::TypeBound(_) => TypeLocation::TypeBound,\n                     // is this case needed?\n                     ast::TypeBoundList(_) => TypeLocation::TypeBound,\n@@ -703,16 +713,49 @@ impl<'a> CompletionContext<'a> {\n             Some(res)\n         };\n \n+        let is_in_condition = |it: &ast::Expr| {\n+            (|| {\n+                let parent = it.syntax().parent()?;\n+                if let Some(expr) = ast::WhileExpr::cast(parent.clone()) {\n+                    Some(expr.condition()? == *it)\n+                } else if let Some(expr) = ast::IfExpr::cast(parent) {\n+                    Some(expr.condition()? == *it)\n+                } else {\n+                    None\n+                }\n+            })()\n+            .unwrap_or(false)\n+        };\n+\n+        let make_path_kind_expr = |expr: ast::Expr| {\n+            let it = expr.syntax();\n+            let in_block_expr = is_in_block(it);\n+            let in_loop_body = is_in_loop_body(it);\n+            let after_if_expr = after_if_expr(it.clone());\n+            let ref_expr_parent =\n+                path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n+            let is_func_update = func_update_record(it);\n+            let in_condition = is_in_condition(&expr);\n+\n+            PathKind::Expr {\n+                in_block_expr,\n+                in_loop_body,\n+                after_if_expr,\n+                in_condition,\n+                ref_expr_parent,\n+                is_func_update,\n+            }\n+        };\n+        let make_path_kind_type = |ty: ast::Type| {\n+            let location = type_location(ty.syntax());\n+            PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n+        };\n+\n         // Infer the path kind\n         let kind = path.syntax().parent().and_then(|it| {\n             match_ast! {\n                 match it {\n-                    ast::PathType(it) => {\n-                        let location = type_location(it.syntax().parent());\n-                        Some(PathKind::Type {\n-                            location: location.unwrap_or(TypeLocation::Other),\n-                        })\n-                    },\n+                    ast::PathType(it) => Some(make_path_kind_type(it.into())),\n                     ast::PathExpr(it) => {\n                         if let Some(p) = it.syntax().parent() {\n                             if ast::ExprStmt::can_cast(p.kind()) {\n@@ -724,14 +767,8 @@ impl<'a> CompletionContext<'a> {\n                         }\n \n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-                        let in_block_expr = is_in_block(it.syntax());\n-                        let in_loop_body = is_in_loop_body(it.syntax());\n-                        let after_if_expr = after_if_expr(it.syntax().clone());\n-                        let ref_expr_parent = path.as_single_name_ref()\n-                            .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n-                        let is_func_update = func_update_record(it.syntax());\n-\n-                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update })\n+\n+                        Some(make_path_kind_expr(it.into()))\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n@@ -748,50 +785,41 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => {\n+                        // A macro call in this position is usually a result of parsing recovery, so check that\n                         if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n                             nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n                             return None;\n                         }\n \n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n-                        let parent = it.syntax().parent();\n-                        match parent.as_ref().map(|it| it.kind()) {\n-                            Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n-                            Some(SyntaxKind::MACRO_TYPE) => {\n-                                let location = type_location(parent.unwrap().parent());\n-                                Some(PathKind::Type {\n-                                    location: location.unwrap_or(TypeLocation::Other),\n-                                })\n-                            },\n-                            Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n-                            Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n-                                Some(it) => match_ast! {\n-                                    match it {\n-                                        ast::Trait(_) => ItemListKind::Trait,\n-                                        ast::Impl(it) => if it.trait_().is_some() {\n-                                            ItemListKind::TraitImpl\n-                                        } else {\n-                                            ItemListKind::Impl\n-                                        },\n-                                        _ => return None\n-                                    }\n-                                },\n-                                None => return None,\n-                            } }),\n-                            Some(SyntaxKind::EXTERN_ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n-                            Some(SyntaxKind::SOURCE_FILE) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n-                            _ => {\n-                               return parent.and_then(ast::MacroExpr::cast).map(|it| {\n-                                    let in_loop_body = is_in_loop_body(it.syntax());\n-                                    let in_block_expr = is_in_block(it.syntax());\n-                                    let after_if_expr = after_if_expr(it.syntax().clone());\n-                                    let ref_expr_parent = path.as_single_name_ref()\n-                                        .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n-                                    let is_func_update = func_update_record(it.syntax());\n-                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update }\n-                                });\n-                            },\n-                        }\n+                        let parent = it.syntax().parent()?;\n+                        // Any path in an item list will be treated as a macro call by the parser\n+                        let res = match_ast! {\n+                            match parent {\n+                                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                                ast::MacroPat(_) => PathKind::Pat,\n+                                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                                    Some(it) => match_ast! {\n+                                        match it {\n+                                            ast::Trait(_) => ItemListKind::Trait,\n+                                            ast::Impl(it) => if it.trait_().is_some() {\n+                                                ItemListKind::TraitImpl\n+                                            } else {\n+                                                ItemListKind::Impl\n+                                            },\n+                                            _ => return None\n+                                        }\n+                                    },\n+                                    None => return None,\n+                                } },\n+                                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n+                                _ => return None,\n+                            }\n+                        };\n+                        Some(res)\n                     },\n                     ast::Meta(meta) => (|| {\n                         let attr = meta.parent_attr()?;\n@@ -818,10 +846,13 @@ impl<'a> CompletionContext<'a> {\n \n         match kind {\n             Some(kind) => path_ctx.kind = kind,\n+            // unresolved path kind, so this isn't really a path we should be completing,\n+            // just some random identifier which might be in keyword position\n             None => return res,\n         }\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n+        // calculate the qualifier context\n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n             if !use_tree_parent {\n                 path_ctx.is_absolute_path =\n@@ -1034,10 +1065,6 @@ fn has_ref(token: &SyntaxToken) -> bool {\n     token.kind() == T![&]\n }\n \n-pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n-    element.into_token().and_then(previous_non_trivia_token)\n-}\n-\n pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n     // oh my ...\n     (|| {"}]}