{"sha": "81eeec0941f936f0f3de881c3991a74f32fe0625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZWVlYzA5NDFmOTM2ZjBmM2RlODgxYzM5OTFhNzRmMzJmZTA2MjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T23:16:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T23:16:48Z"}, "message": "auto merge of #18603 : brson/rust/stdchar, r=aturon\n\n* Deprecate the free functions in favor of methods, except the two ctors `from_u32` and `from_digit`, whose methods are deprecated.\r\n* Mark the `Char` and `UnicodeChar` traits experimental until we decide for sure that we won't have some sort of inherent methods for primitives.\r\n* The `UnicodeChar` methods related to numerics are now called e.g. `is_numeric` to match the 'numeric' unicode character class, and the `*_digit_radix` methods on `Char` now just called `*_digit`.\r\n* `len_utf8_bytes` -> `len_utf8`\r\n* Converted methods to take self by-value\r\n* Converted `escape_default` and `escape_unicode` to iterators over chars.\r\n* Renamed `is_XID_start`, `is_XID_continue` to `is_xid_start`, `is_xid_continue` to match conventions\r\n\r\nThis also converts `encode_utf8` and `encode_utf16` to return iterators. I suspect this is not the final form of these methods. Perf is worse (numbers in the commit). Many of the uses ended up being awkward, copying into a buffer then writing that buffer to a `Writer`. It might be more appropriate for these to return `Reader`s instead, but that type is defined in `std`.\r\n\r\nNote: although I *did* add the `from_u32` ctor to the `Char` trait, I deprecated it again later, preferring the free ctors.\r\n\r\nI've been sitting on this for a while.\r\n\r\ncc @aturon", "tree": {"sha": "ce9f2391bdab7d078dc510d7572a3116d4dbf44c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce9f2391bdab7d078dc510d7572a3116d4dbf44c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81eeec0941f936f0f3de881c3991a74f32fe0625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81eeec0941f936f0f3de881c3991a74f32fe0625", "html_url": "https://github.com/rust-lang/rust/commit/81eeec0941f936f0f3de881c3991a74f32fe0625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81eeec0941f936f0f3de881c3991a74f32fe0625/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd7584743710aa2355eb7e09146fea7c338a27e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7584743710aa2355eb7e09146fea7c338a27e5", "html_url": "https://github.com/rust-lang/rust/commit/cd7584743710aa2355eb7e09146fea7c338a27e5"}, {"sha": "75ffadf8b65495ababae49d8162f85c58cd2c2a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ffadf8b65495ababae49d8162f85c58cd2c2a9", "html_url": "https://github.com/rust-lang/rust/commit/75ffadf8b65495ababae49d8162f85c58cd2c2a9"}], "stats": {"total": 550, "additions": 379, "deletions": 171}, "files": [{"sha": "9bf45de0a17d45deba904d9e3aa1d73cdc372bce", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -1566,7 +1566,7 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     let mut exitcode: int = 0;\n     for c in exitcode_out.as_slice().chars() {\n-        if !c.is_digit() { break; }\n+        if !c.is_numeric() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' ... '9' => c as int - ('0' as int),\n             _ => 101,"}, {"sha": "0fe40081a46235f6d527f7b87c7df43e828930b3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -630,7 +630,9 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_default(|c| out.push(c));\n+            for c in c.escape_default() {\n+                out.push(c);\n+            }\n         }\n         out\n     }\n@@ -640,7 +642,9 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_unicode(|c| out.push(c));\n+            for c in c.escape_unicode() {\n+                out.push(c);\n+            }\n         }\n         out\n     }\n@@ -1189,7 +1193,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\");\n     }\n \n     #[test]\n@@ -1204,7 +1208,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\");\n     }\n \n     #[test]\n@@ -1219,7 +1223,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\");\n     }\n \n     #[test]"}, {"sha": "272b36847991f8eb97b4d746c7673e554bab8870", "filename": "src/libcore/char.rs", "status": "modified", "additions": 207, "deletions": 61, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -17,7 +17,7 @@\n \n use mem::transmute;\n use option::{None, Option, Some};\n-use iter::range_step;\n+use iter::{range_step, Iterator, RangeStep};\n use slice::SlicePrelude;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -63,10 +63,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n+#[stable]\n pub const MAX: char = '\\U0010ffff';\n \n /// Converts from `u32` to a `char`\n #[inline]\n+#[unstable = \"pending decisions about costructors for primitives\"]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -96,11 +98,9 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// This just wraps `to_digit()`.\n ///\n #[inline]\n+#[deprecated = \"use the Char::is_digit method\"]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n-    match to_digit(c, radix) {\n-        Some(_) => true,\n-        None    => false,\n-    }\n+    c.is_digit(radix)\n }\n \n ///\n@@ -118,18 +118,9 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n /// Panics if given a `radix` outside the range `[0..36]`.\n ///\n #[inline]\n+#[deprecated = \"use the Char::to_digit method\"]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n-    if radix > 36 {\n-        panic!(\"to_digit: radix is too high (maximum 36)\");\n-    }\n-    let val = match c {\n-      '0' ... '9' => c as uint - ('0' as uint),\n-      'a' ... 'z' => c as uint + 10u - ('a' as uint),\n-      'A' ... 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None,\n-    };\n-    if val < radix { Some(val) }\n-    else { None }\n+    c.to_digit(radix)\n }\n \n ///\n@@ -145,6 +136,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n+#[unstable = \"pending decisions about costructors for primitives\"]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is to high (maximum 36)\");\n@@ -171,23 +163,10 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n+#[deprecated = \"use the Char::escape_unicode method\"]\n pub fn escape_unicode(c: char, f: |char|) {\n-    // avoid calling str::to_str_radix because we don't really need to allocate\n-    // here.\n-    f('\\\\');\n-    let pad = match () {\n-        _ if c <= '\\x7f'    => { f('x'); 2 }\n-        _ if c <= '\\uffff'  => { f('u'); 4 }\n-        _                   => { f('U'); 8 }\n-    };\n-    for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n-        let offset = offset as uint;\n-        unsafe {\n-            match ((c as i32) >> offset) & 0xf {\n-                i @ 0 ... 9 => { f(transmute('0' as i32 + i)); }\n-                i => { f(transmute('a' as i32 + (i - 10))); }\n-            }\n-        }\n+    for char in c.escape_unicode() {\n+        f(char);\n     }\n }\n \n@@ -203,32 +182,22 @@ pub fn escape_unicode(c: char, f: |char|) {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex Unicode escapes; see `escape_unicode`.\n ///\n+#[deprecated = \"use the Char::escape_default method\"]\n pub fn escape_default(c: char, f: |char|) {\n-    match c {\n-        '\\t' => { f('\\\\'); f('t'); }\n-        '\\r' => { f('\\\\'); f('r'); }\n-        '\\n' => { f('\\\\'); f('n'); }\n-        '\\\\' => { f('\\\\'); f('\\\\'); }\n-        '\\'' => { f('\\\\'); f('\\''); }\n-        '\"'  => { f('\\\\'); f('\"'); }\n-        '\\x20' ... '\\x7e' => { f(c); }\n-        _ => c.escape_unicode(f),\n+    for c in c.escape_default() {\n+        f(c);\n     }\n }\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n #[inline]\n+#[deprecated = \"use the Char::len_utf8 method\"]\n pub fn len_utf8_bytes(c: char) -> uint {\n-    let code = c as u32;\n-    match () {\n-        _ if code < MAX_ONE_B   => 1u,\n-        _ if code < MAX_TWO_B   => 2u,\n-        _ if code < MAX_THREE_B => 3u,\n-        _  => 4u,\n-    }\n+    c.len_utf8()\n }\n \n /// Basic `char` manipulations.\n+#[experimental = \"trait organization may change\"]\n pub trait Char {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -243,7 +212,24 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    fn is_digit_radix(&self, radix: uint) -> bool;\n+    #[deprecated = \"use is_digit\"]\n+    fn is_digit_radix(self, radix: uint) -> bool;\n+\n+    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    ///\n+    /// Compared to `is_digit()`, this function only recognizes the characters\n+    /// `0-9`, `a-z` and `A-Z`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+    /// otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix > 36.\n+    #[unstable = \"pending error conventions\"]\n+    fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -256,7 +242,8 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    fn to_digit(&self, radix: uint) -> Option<uint>;\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Converts a number to the character representing it.\n     ///\n@@ -268,19 +255,26 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n+    #[deprecated = \"use the char::from_digit free function\"]\n     fn from_digit(num: uint, radix: uint) -> Option<Self>;\n \n-    /// Returns the hexadecimal Unicode escape of a character.\n+    /// Converts from `u32` to a `char`\n+    #[deprecated = \"use the char::from_u32 free function\"]\n+    fn from_u32(i: u32) -> Option<char>;\n+\n+    /// Returns an iterator that yields the hexadecimal Unicode escape\n+    /// of a character, as `char`s.\n     ///\n     /// The rules are as follows:\n     ///\n     /// * Characters in [0,0xff] get 2-digit escapes: `\\\\xNN`\n     /// * Characters in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`.\n     /// * Characters above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`.\n-    fn escape_unicode(&self, f: |char|);\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_unicode(self) -> UnicodeEscapedChars;\n \n-    /// Returns a 'default' ASCII and C++11-like literal escape of a\n-    /// character.\n+    /// Returns an iterator that yields the 'default' ASCII and\n+    /// C++11-like literal escape of a character, as `char`s.\n     ///\n     /// The default is chosen with a bias toward producing literals that are\n     /// legal in a variety of languages, including C++11 and similar C-family\n@@ -291,42 +285,121 @@ pub trait Char {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    fn escape_default(&self, f: |char|);\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_default(self) -> DefaultEscapedChars;\n+\n+    /// Returns the amount of bytes this character would need if encoded in\n+    /// UTF-8.\n+    #[deprecated = \"use len_utf8\"]\n+    fn len_utf8_bytes(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    fn len_utf8_bytes(&self) -> uint;\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf8(self) -> uint;\n+\n+    /// Returns the amount of bytes this character would need if encoded in\n+    /// UTF-16.\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n+    #[unstable = \"pending trait organization\"]\n     fn encode_utf8(&self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n+    #[unstable = \"pending trait organization\"]\n     fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint>;\n }\n \n+#[experimental = \"trait is experimental\"]\n impl Char for char {\n-    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n+    #[deprecated = \"use is_digit\"]\n+    fn is_digit_radix(self, radix: uint) -> bool { self.is_digit(radix) }\n+\n+    #[unstable = \"pending trait organization\"]\n+    fn is_digit(self, radix: uint) -> bool {\n+        match self.to_digit(radix) {\n+            Some(_) => true,\n+            None    => false,\n+        }\n+    }\n \n-    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n+    #[unstable = \"pending trait organization\"]\n+    fn to_digit(self, radix: uint) -> Option<uint> {\n+        if radix > 36 {\n+            panic!(\"to_digit: radix is too high (maximum 36)\");\n+        }\n+        let val = match self {\n+          '0' ... '9' => self as uint - ('0' as uint),\n+          'a' ... 'z' => self as uint + 10u - ('a' as uint),\n+          'A' ... 'Z' => self as uint + 10u - ('A' as uint),\n+          _ => return None,\n+        };\n+        if val < radix { Some(val) }\n+        else { None }\n+    }\n \n+    #[deprecated = \"use the char::from_digit free function\"]\n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n-    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n+    #[inline]\n+    #[deprecated = \"use the char::from_u32 free function\"]\n+    fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n+\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_unicode(self) -> UnicodeEscapedChars {\n+        UnicodeEscapedChars { c: self, state: UnicodeEscapedCharsState::Backslash }\n+    }\n+\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_default(self) -> DefaultEscapedChars {\n+        let init_state = match self {\n+            '\\t' => DefaultEscapedCharsState::Backslash('t'),\n+            '\\r' => DefaultEscapedCharsState::Backslash('r'),\n+            '\\n' => DefaultEscapedCharsState::Backslash('n'),\n+            '\\\\' => DefaultEscapedCharsState::Backslash('\\\\'),\n+            '\\'' => DefaultEscapedCharsState::Backslash('\\''),\n+            '\"'  => DefaultEscapedCharsState::Backslash('\"'),\n+            '\\x20' ... '\\x7e' => DefaultEscapedCharsState::Char(self),\n+            _ => DefaultEscapedCharsState::Unicode(self.escape_unicode())\n+        };\n+        DefaultEscapedChars { state: init_state }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"use len_utf8\"]\n+    fn len_utf8_bytes(self) -> uint { self.len_utf8() }\n \n-    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n+    #[inline]\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf8(self) -> uint {\n+        let code = self as u32;\n+        match () {\n+            _ if code < MAX_ONE_B   => 1u,\n+            _ if code < MAX_TWO_B   => 2u,\n+            _ if code < MAX_THREE_B => 3u,\n+            _  => 4u,\n+        }\n+    }\n \n     #[inline]\n-    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf16(self) -> uint {\n+        let ch = self as u32;\n+        if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n+    }\n \n     #[inline]\n+    #[unstable = \"pending error conventions, trait organization\"]\n     fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let code = *self as u32;\n@@ -354,6 +427,7 @@ impl Char for char {\n     }\n \n     #[inline]\n+    #[unstable = \"pending error conventions, trait organization\"]\n     fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let mut ch = *self as u32;\n@@ -372,3 +446,75 @@ impl Char for char {\n         }\n     }\n }\n+\n+/// An iterator over the characters that represent a `char`, as escaped by\n+/// Rust's unicode escaping rules.\n+pub struct UnicodeEscapedChars {\n+    c: char,\n+    state: UnicodeEscapedCharsState\n+}\n+\n+enum UnicodeEscapedCharsState {\n+    Backslash,\n+    Type,\n+    Value(RangeStep<i32>),\n+}\n+\n+impl Iterator<char> for UnicodeEscapedChars {\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            UnicodeEscapedCharsState::Backslash => {\n+                self.state = UnicodeEscapedCharsState::Type;\n+                Some('\\\\')\n+            }\n+            UnicodeEscapedCharsState::Type => {\n+                let (typechar, pad) = if self.c <= '\\x7f' { ('x', 2) }\n+                                      else if self.c <= '\\uffff' { ('u', 4) }\n+                                      else { ('U', 8) };\n+                self.state = UnicodeEscapedCharsState::Value(range_step(4 * (pad - 1), -1, -4i32));\n+                Some(typechar)\n+            }\n+            UnicodeEscapedCharsState::Value(ref mut range_step) => match range_step.next() {\n+                Some(offset) => {\n+                    let offset = offset as uint;\n+                    let v = match ((self.c as i32) >> offset) & 0xf {\n+                        i @ 0 ... 9 => '0' as i32 + i,\n+                        i => 'a' as i32 + (i - 10)\n+                    };\n+                    Some(unsafe { transmute(v) })\n+                }\n+                None => None\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the characters that represent a `char`, escaped\n+/// for maximum portability.\n+pub struct DefaultEscapedChars {\n+    state: DefaultEscapedCharsState\n+}\n+\n+enum DefaultEscapedCharsState {\n+    Backslash(char),\n+    Char(char),\n+    Done,\n+    Unicode(UnicodeEscapedChars),\n+}\n+\n+impl Iterator<char> for DefaultEscapedChars {\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            DefaultEscapedCharsState::Backslash(c) => {\n+                self.state = DefaultEscapedCharsState::Char(c);\n+                Some('\\\\')\n+            }\n+            DefaultEscapedCharsState::Char(c) => {\n+                self.state = DefaultEscapedCharsState::Done;\n+                Some(c)\n+            }\n+            DefaultEscapedCharsState::Done => None,\n+            DefaultEscapedCharsState::Unicode(ref mut iter) => iter.next()\n+        }\n+    }\n+}"}, {"sha": "1760c4d8e6616953953754f0f9572cce830ba2af", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -15,6 +15,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n@@ -222,7 +223,7 @@ pub fn float_to_str_bytes_common<T: Float, U>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "8d26a970eb8baa9edd129923f1efa3d805ccb71b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -1315,7 +1315,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n@@ -1336,7 +1336,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n@@ -1368,7 +1368,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n     /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n@@ -1386,7 +1386,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n@@ -1596,7 +1596,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\")\n     /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1612,7 +1612,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\")\n     /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1628,7 +1628,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\")\n     /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n "}, {"sha": "507ddf65e55b35c9dca1b4a6d72053bc68620346", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -105,12 +105,12 @@ fn test_is_control() {\n \n #[test]\n fn test_is_digit() {\n-   assert!('2'.is_digit());\n-   assert!('7'.is_digit());\n-   assert!(!'c'.is_digit());\n-   assert!(!'i'.is_digit());\n-   assert!(!'z'.is_digit());\n-   assert!(!'Q'.is_digit());\n+   assert!('2'.is_numeric());\n+   assert!('7'.is_numeric());\n+   assert!(!'c'.is_numeric());\n+   assert!(!'i'.is_numeric());\n+   assert!(!'z'.is_numeric());\n+   assert!(!'Q'.is_numeric());\n }\n \n #[test]\n@@ -197,6 +197,14 @@ fn test_encode_utf16() {\n     check('\\U0001f4a9', &[0xd83d, 0xdca9]);\n }\n \n+#[test]\n+fn test_len_utf16() {\n+    assert!('x'.len_utf16() == 1);\n+    assert!('\\u00e9'.len_utf16() == 1);\n+    assert!('\\ua66e'.len_utf16() == 1);\n+    assert!('\\U0001f4a9'.len_utf16() == 2);\n+}\n+\n #[test]\n fn test_width() {\n     assert_eq!('\\x00'.width(false),Some(0));"}, {"sha": "d3bee557220bf77d60c2f6d60dd76be5a39295b9", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -26,7 +26,6 @@ pub use self::Alignment::*;\n pub use self::Flag::*;\n pub use self::Count::*;\n \n-use std::char;\n use std::str;\n use std::string;\n \n@@ -221,7 +220,7 @@ impl<'a> Parser<'a> {\n     fn ws(&mut self) {\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n+                Some((_, c)) if c.is_whitespace() => { self.cur.next(); }\n                 Some(..) | None => { return }\n             }\n         }\n@@ -261,7 +260,7 @@ impl<'a> Parser<'a> {\n             Some(i) => { ArgumentIs(i) }\n             None => {\n                 match self.cur.clone().next() {\n-                    Some((_, c)) if char::is_alphabetic(c) => {\n+                    Some((_, c)) if c.is_alphabetic() => {\n                         ArgumentNamed(self.word())\n                     }\n                     _ => ArgumentNext\n@@ -384,7 +383,7 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.clone().next() {\n-            Some((pos, c)) if char::is_XID_start(c) => {\n+            Some((pos, c)) if c.is_xid_start() => {\n                 self.cur.next();\n                 pos\n             }\n@@ -393,7 +392,7 @@ impl<'a> Parser<'a> {\n         let mut end;\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_XID_continue(c) => {\n+                Some((_, c)) if c.is_xid_continue() => {\n                     self.cur.next();\n                 }\n                 Some((pos, _)) => { end = pos; break }\n@@ -411,7 +410,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) => {\n-                    match char::to_digit(c, 10) {\n+                    match c.to_digit(10) {\n                         Some(i) => {\n                             cur = cur * 10 + i;\n                             found = true;"}, {"sha": "a182f582b5f34bcd54d0aec013f5933f114e736d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -886,7 +886,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n     }\n \n     let machine: |&mut bool, (uint, char)| -> bool = |cont, (i, c)| {\n-        let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n         state = match (state, whitespace, limit) {"}, {"sha": "3ad546edf8de2d7b0225504cd6a73e501b5d67aa", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -431,7 +431,7 @@ impl<'a> LabelText<'a> {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above.\n             '\\\\' => f(c),\n-            _ => c.escape_default(f)\n+            _ => for c in c.escape_default() { f(c) }\n         }\n     }\n     fn escape_str(s: &str) -> String {"}, {"sha": "00c68f42c3249d4ba8168f3c0468906c6eeecb2b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -920,7 +920,7 @@ impl NonSnakeCase {\n             let mut allow_underscore = true;\n             ident.chars().all(|c| {\n                 allow_underscore = match c {\n-                    c if c.is_lowercase() || c.is_digit() => true,\n+                    c if c.is_lowercase() || c.is_numeric() => true,\n                     '_' if allow_underscore => false,\n                     _ => return false,\n                 };"}, {"sha": "3715256e3ec2be857107118321f4be110a725a99", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -27,7 +27,6 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::char;\n use std::io::fs::PathExtensions;\n use std::io::{fs, TempDir, Command};\n use std::io;\n@@ -262,7 +261,7 @@ pub fn sanitize(s: &str) -> String {\n \n             _ => {\n                 let mut tstr = String::new();\n-                char::escape_unicode(c, |c| tstr.push(c));\n+                for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n                 result.push_str(tstr.as_slice().slice_from(1));\n             }\n@@ -272,7 +271,7 @@ pub fn sanitize(s: &str) -> String {\n     // Underscore-qualify anything that didn't start as an ident.\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! char::is_XID_start(result.as_bytes()[0] as char) {\n+        ! (result.as_bytes()[0] as char).is_xid_start() {\n         return format!(\"_{}\", result.as_slice());\n     }\n "}, {"sha": "52aab752c57612087510094eff830c8550516e09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -2033,9 +2033,9 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         ast::LitBinary(ref data) => format!(\"{}\", data),\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n-            (b as char).escape_default(|c| {\n+            for c in (b as char).escape_default() {\n                 res.push(c);\n-            });\n+            }\n             res.push('\\'');\n             res\n         },"}, {"sha": "2a5972bb3d90b11d0fc6711ccda4d409f9805b85", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::char;\n use std::dynamic_lib::DynamicLibrary;\n use std::io::{Command, TempDir};\n use std::io;\n@@ -300,8 +299,8 @@ impl Collector {\n             // we use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n-                    if (i == 0 && char::is_XID_start(c)) ||\n-                        (i != 0 && char::is_XID_continue(c)) {\n+                    if (i == 0 && c.is_xid_start()) ||\n+                        (i != 0 && c.is_xid_continue()) {\n                         c\n                     } else {\n                         '_'"}, {"sha": "649298d9c0818dc294412e92e8bc787cf40a9773", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -17,6 +17,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n@@ -320,7 +321,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "81022994387493e41d8e573196b3f0945441a538", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -71,7 +71,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n         while valid {\n             let mut i = 0;\n             for c in chars {\n-                if c.is_digit() {\n+                if c.is_numeric() {\n                     i = i * 10 + c as uint - '0' as uint;\n                 } else {\n                     break\n@@ -101,7 +101,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                 first = false;\n             }\n             let mut rest = s;\n-            while rest.char_at(0).is_digit() {\n+            while rest.char_at(0).is_numeric() {\n                 rest = rest.slice_from(1);\n             }\n             let i: uint = from_str(s.slice_to(s.len() - rest.len())).unwrap();"}, {"sha": "a88029e087b155959b9e24bc405719595c09b671", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -193,7 +193,7 @@ impl<'a> StringReader<'a> {\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push(c));\n+        for c in c.escape_default() { m.push(c) }\n         self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -202,7 +202,7 @@ impl<'a> StringReader<'a> {\n     fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push(c));\n+        for c in c.escape_default() { m.push(c) }\n         self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n-            match c.and_then(|cc| char::to_digit(cc, radix)) {\n+            match c.and_then(|cc| cc.to_digit(radix)) {\n                 Some(_) => {\n                     debug!(\"{} in scan_digits\", c);\n                     len += 1;\n@@ -677,7 +677,7 @@ impl<'a> StringReader<'a> {\n                     return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n-        } else if c.is_digit_radix(10) {\n+        } else if c.is_digit(10) {\n             num_digits = self.scan_digits(10) + 1;\n         } else {\n             num_digits = 0;\n@@ -692,11 +692,11 @@ impl<'a> StringReader<'a> {\n         // integer literal followed by field/method access or a range pattern\n         // (`0..2` and `12.foo()`)\n         if self.curr_is('.') && !self.nextch_is('.') && !self.nextch().unwrap_or('\\0')\n-                                                             .is_XID_start() {\n+                                                             .is_xid_start() {\n             // might have stuff after the ., and if it does, it needs to start\n             // with a number\n             self.bump();\n-            if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n+            if self.curr.unwrap_or('\\0').is_digit(10) {\n                 self.scan_digits(10);\n                 self.scan_float_exponent();\n             }\n@@ -1385,7 +1385,7 @@ fn ident_start(c: Option<char>) -> bool {\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_start(c))\n+        || (c > '\\x7f' && c.is_xid_start())\n }\n \n fn ident_continue(c: Option<char>) -> bool {\n@@ -1395,7 +1395,7 @@ fn ident_continue(c: Option<char>) -> bool {\n         || (c >= 'A' && c <= 'Z')\n         || (c >= '0' && c <= '9')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_continue(c))\n+        || (c > '\\x7f' && c.is_xid_continue())\n }\n \n #[cfg(test)]"}, {"sha": "4ce0d74bd37f4e965e83cf282c8856a8ddcf2671", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -2756,7 +2756,9 @@ impl<'a> State<'a> {\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                ch.escape_default(|c| res.push(c));\n+                for c in ch.escape_default() {\n+                    res.push(c);\n+                }\n                 res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }"}, {"sha": "cfab6494900765d30f78440dd0c22900ccc3659a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -14,8 +14,6 @@ pub use self::Param::*;\n use self::States::*;\n use self::FormatState::*;\n use self::FormatOp::*;\n-\n-use std::char;\n use std::mem::replace;\n \n #[deriving(PartialEq)]\n@@ -298,7 +296,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(mparams[match char::to_digit(cur, 10) {\n+                stack.push(mparams[match cur.to_digit(10) {\n                     Some(d) => d - 1,\n                     None => return Err(\"bad param number\".to_string())\n                 }].clone());"}, {"sha": "369336639a7fe465b617b8c552cc0e42cffda939", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 101, "deletions": 51, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -20,12 +20,9 @@ use tables::{derived_property, property, general_category, conversions, charwidt\n \n /// Returns whether the specified `char` is considered a Unicode alphabetic\n /// code point\n+#[deprecated = \"use UnicodeChar::is_alphabetic\"]\n pub fn is_alphabetic(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' | 'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Alphabetic(c),\n-        _ => false\n-    }\n+    c.is_alphabetic()\n }\n \n /// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n@@ -34,6 +31,7 @@ pub fn is_alphabetic(c: char) -> bool {\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to ID_Start but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_start\"]\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n \n /// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n@@ -42,6 +40,7 @@ pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_continue\"]\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n ///\n@@ -50,12 +49,9 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n /// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_lowercase\"]\n pub fn is_lowercase(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' => true,\n-        c if c > '\\x7f' => derived_property::Lowercase(c),\n-        _ => false\n-    }\n+    c.is_lowercase()\n }\n \n ///\n@@ -64,12 +60,9 @@ pub fn is_lowercase(c: char) -> bool {\n /// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_uppercase\"]\n pub fn is_uppercase(c: char) -> bool {\n-    match c {\n-        'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Uppercase(c),\n-        _ => false\n-    }\n+    c.is_uppercase()\n }\n \n ///\n@@ -78,12 +71,9 @@ pub fn is_uppercase(c: char) -> bool {\n /// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_whitespace\"]\n pub fn is_whitespace(c: char) -> bool {\n-    match c {\n-        ' ' | '\\x09' ... '\\x0d' => true,\n-        c if c > '\\x7f' => property::White_Space(c),\n-        _ => false\n-    }\n+    c.is_whitespace()\n }\n \n ///\n@@ -93,9 +83,9 @@ pub fn is_whitespace(c: char) -> bool {\n /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_alphanumeric\"]\n pub fn is_alphanumeric(c: char) -> bool {\n-    is_alphabetic(c)\n-        || is_digit(c)\n+    c.is_alphanumeric()\n }\n \n ///\n@@ -105,16 +95,14 @@ pub fn is_alphanumeric(c: char) -> bool {\n /// 'Cc'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_control\"]\n pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n \n /// Indicates whether the `char` is numeric (Nd, Nl, or No)\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_numeric\"]\n pub fn is_digit(c: char) -> bool {\n-    match c {\n-        '0' ... '9' => true,\n-        c if c > '\\x7f' => general_category::N(c),\n-        _ => false\n-    }\n+    c.is_numeric()\n }\n \n /// Convert a char to its uppercase equivalent\n@@ -132,6 +120,7 @@ pub fn is_digit(c: char) -> bool {\n ///\n /// Returns the char itself if no conversion was made\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_uppercase\"]\n pub fn to_uppercase(c: char) -> char {\n     conversions::to_upper(c)\n }\n@@ -145,6 +134,7 @@ pub fn to_uppercase(c: char) -> char {\n ///\n /// Returns the char itself if no conversion if possible\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_lowercase\"]\n pub fn to_lowercase(c: char) -> char {\n     conversions::to_lower(c)\n }\n@@ -158,15 +148,17 @@ pub fn to_lowercase(c: char) -> char {\n /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n /// recommends that these characters be treated as 1 column (i.e.,\n /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+#[deprecated = \"use UnicodeChar::width\"]\n pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n     charwidth::width(c, is_cjk)\n }\n \n /// Useful functions for Unicode characters.\n+#[experimental = \"pending prelude organization\"]\n pub trait UnicodeChar {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n-    fn is_alphabetic(&self) -> bool;\n+    fn is_alphabetic(self) -> bool;\n \n     /// Returns whether the specified character satisfies the 'XID_Start'\n     /// Unicode property.\n@@ -175,7 +167,16 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_start(&self) -> bool;\n+    #[deprecated = \"use is_xid_start\"]\n+    fn is_XID_start(self) -> bool;\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    fn is_xid_start(self) -> bool;\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n     /// Unicode property.\n@@ -184,40 +185,48 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_continue(&self) -> bool;\n+    #[deprecated = \"use is_xid_continue\"]\n+    fn is_XID_continue(self) -> bool;\n \n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    fn is_xid_continue(self) -> bool;\n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n-    fn is_lowercase(&self) -> bool;\n+    fn is_lowercase(self) -> bool;\n \n     /// Indicates whether a character is in uppercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n-    fn is_uppercase(&self) -> bool;\n+    fn is_uppercase(self) -> bool;\n \n     /// Indicates whether a character is whitespace.\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    fn is_whitespace(&self) -> bool;\n+    fn is_whitespace(self) -> bool;\n \n     /// Indicates whether a character is alphanumeric.\n     ///\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    fn is_alphanumeric(&self) -> bool;\n+    fn is_alphanumeric(self) -> bool;\n \n     /// Indicates whether a character is a control code point.\n     ///\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n-    fn is_control(&self) -> bool;\n+    fn is_control(self) -> bool;\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    fn is_digit(&self) -> bool;\n+    fn is_numeric(self) -> bool;\n \n     /// Converts a character to its lowercase equivalent.\n     ///\n@@ -228,7 +237,7 @@ pub trait UnicodeChar {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    fn to_lowercase(&self) -> char;\n+    fn to_lowercase(self) -> char;\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n@@ -250,7 +259,7 @@ pub trait UnicodeChar {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    fn to_uppercase(&self) -> char;\n+    fn to_uppercase(self) -> char;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n     /// control character other than `'\\x00'`.\n@@ -261,31 +270,72 @@ pub trait UnicodeChar {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    fn width(&self, is_cjk: bool) -> Option<uint>;\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n+#[experimental = \"pending prelude organization\"]\n impl UnicodeChar for char {\n-    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n+    fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n+    #[deprecated = \"use is_xid_start\"]\n+    fn is_XID_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n+    #[deprecated = \"use is_xid_continue\"]\n+    fn is_XID_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n+    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n+    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+    fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+    fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_control(&self) -> bool { is_control(*self) }\n+    fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n+\n+    fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    fn is_digit(&self) -> bool { is_digit(*self) }\n+    fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n \n-    fn to_lowercase(&self) -> char { to_lowercase(*self) }\n+    fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    fn to_uppercase(&self) -> char { to_uppercase(*self) }\n+    fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n-    fn width(&self, is_cjk: bool) -> Option<uint> { width(*self, is_cjk) }\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "56b1f0907d5a4c4c4338042f23d87fc092316936", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eeec0941f936f0f3de881c3991a74f32fe0625/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=81eeec0941f936f0f3de881c3991a74f32fe0625", "patch": "@@ -24,13 +24,13 @@ use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n use core::kinds::Sized;\n use core::option::{Option, None, Some};\n use core::str::{CharSplits, StrPrelude};\n-use u_char;\n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n+/// FIXME: This should be opaque\n pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+    Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>>;\n \n /// Methods for Unicode string slices\n pub trait UnicodeStrPrelude for Sized? {\n@@ -143,14 +143,15 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn words(&self) -> Words {\n-        self.split(u_char::is_whitespace).filter(|s| !s.is_empty())\n+        let f = |c: char| c.is_whitespace();\n+        self.split(f).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(u_char::is_whitespace) }\n+    fn is_whitespace(&self) -> bool { self.chars().all(|c| c.is_whitespace()) }\n \n     #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(u_char::is_alphanumeric) }\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n     fn width(&self, is_cjk: bool) -> uint {\n@@ -164,12 +165,12 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn trim_left(&self) -> &str {\n-        self.trim_left_chars(u_char::is_whitespace)\n+        self.trim_left_chars(|c: char| c.is_whitespace())\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &str {\n-        self.trim_right_chars(u_char::is_whitespace)\n+        self.trim_right_chars(|c: char| c.is_whitespace())\n     }\n }\n "}]}