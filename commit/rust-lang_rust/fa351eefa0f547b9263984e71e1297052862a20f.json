{"sha": "fa351eefa0f547b9263984e71e1297052862a20f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMzUxZWVmYTBmNTQ3YjkyNjM5ODRlNzFlMTI5NzA1Mjg2MmEyMGY=", "commit": {"author": {"name": "Nathan Corbyn", "email": "me@nathancorbyn.com", "date": "2020-05-21T18:51:39Z"}, "committer": {"name": "Nathan Corbyn", "email": "me@nathancorbyn.com", "date": "2020-05-28T18:23:25Z"}, "message": "Fix ICE with explicit late-bound lifetimes", "tree": {"sha": "89a3b70c94076af19997650f09cdcdd3c929827e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a3b70c94076af19997650f09cdcdd3c929827e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa351eefa0f547b9263984e71e1297052862a20f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa351eefa0f547b9263984e71e1297052862a20f", "html_url": "https://github.com/rust-lang/rust/commit/fa351eefa0f547b9263984e71e1297052862a20f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa351eefa0f547b9263984e71e1297052862a20f/comments", "author": {"login": "doctorn", "id": 6421560, "node_id": "MDQ6VXNlcjY0MjE1NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6421560?v=4", "gravatar_id": "", "url": "https://api.github.com/users/doctorn", "html_url": "https://github.com/doctorn", "followers_url": "https://api.github.com/users/doctorn/followers", "following_url": "https://api.github.com/users/doctorn/following{/other_user}", "gists_url": "https://api.github.com/users/doctorn/gists{/gist_id}", "starred_url": "https://api.github.com/users/doctorn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/doctorn/subscriptions", "organizations_url": "https://api.github.com/users/doctorn/orgs", "repos_url": "https://api.github.com/users/doctorn/repos", "events_url": "https://api.github.com/users/doctorn/events{/privacy}", "received_events_url": "https://api.github.com/users/doctorn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "doctorn", "id": 6421560, "node_id": "MDQ6VXNlcjY0MjE1NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6421560?v=4", "gravatar_id": "", "url": "https://api.github.com/users/doctorn", "html_url": "https://github.com/doctorn", "followers_url": "https://api.github.com/users/doctorn/followers", "following_url": "https://api.github.com/users/doctorn/following{/other_user}", "gists_url": "https://api.github.com/users/doctorn/gists{/gist_id}", "starred_url": "https://api.github.com/users/doctorn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/doctorn/subscriptions", "organizations_url": "https://api.github.com/users/doctorn/orgs", "repos_url": "https://api.github.com/users/doctorn/repos", "events_url": "https://api.github.com/users/doctorn/events{/privacy}", "received_events_url": "https://api.github.com/users/doctorn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45127211566c53bac386b66909a830649182ab7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/45127211566c53bac386b66909a830649182ab7a", "html_url": "https://github.com/rust-lang/rust/commit/45127211566c53bac386b66909a830649182ab7a"}], "stats": {"total": 372, "additions": 241, "deletions": 131}, "files": [{"sha": "12edfed19c07e409606ec7c507d02cdedd41f487", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 187, "deletions": 123, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fa351eefa0f547b9263984e71e1297052862a20f", "patch": "@@ -123,7 +123,22 @@ enum ConvertedBindingKind<'a, 'tcx> {\n     Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n-#[derive(PartialEq)]\n+/// New-typed boolean indicating whether explicit late-bound lifetimes\n+/// are present in a set of generic arguments.\n+///\n+/// For example if we have some method `fn f<'a>(&'a self)` implemented\n+/// for some type `T`, although `f` is generic in the lifetime `'a`, `'a`\n+/// is late-bound so should not be provided explicitly. Thus, if `f` is\n+/// instantiated with some generic arguments providing `'a` explicitly,\n+/// we taint those arguments with `ExplicitLateBound::Yes` so that we\n+/// can provide an appropriate diagnostic later.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum ExplicitLateBound {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n enum GenericArgPosition {\n     Type,\n     Value, // e.g., functions\n@@ -132,13 +147,22 @@ enum GenericArgPosition {\n \n /// A marker denoting that the generic arguments that were\n /// provided did not match the respective generic parameters.\n+#[derive(Clone, Default)]\n pub struct GenericArgCountMismatch {\n     /// Indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n     pub reported: Option<ErrorReported>,\n     /// A list of spans of arguments provided that were not valid.\n     pub invalid_args: Vec<Span>,\n }\n \n+/// Decorates the result of a generic argument count mismatch\n+/// check with whether explicit late bounds were provided.\n+#[derive(Clone)]\n+pub struct GenericArgCountResult {\n+    pub explicit_late_bound: ExplicitLateBound,\n+    pub correct: Result<(), GenericArgCountMismatch>,\n+}\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -271,7 +295,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: &ty::Generics,\n         seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         let empty_args = hir::GenericArgs::none();\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n@@ -295,7 +319,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -320,112 +344,94 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n         }\n \n-        // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n-        let mut explicit_lifetimes = Ok(());\n-        if !infer_lifetimes {\n-            if let Some(span_late) = def.has_late_bound_regions {\n-                let msg = \"cannot specify lifetime arguments explicitly \\\n-                           if late bound lifetime parameters are present\";\n-                let note = \"the late bound lifetime parameter is introduced here\";\n-                let span = args.args[0].span();\n-                if position == GenericArgPosition::Value\n-                    && arg_counts.lifetimes != param_counts.lifetimes\n-                {\n-                    explicit_lifetimes = Err(true);\n-                    let mut err = tcx.sess.struct_span_err(span, msg);\n-                    err.span_note(span_late, note);\n-                    err.emit();\n-                } else {\n-                    explicit_lifetimes = Err(false);\n-                    let mut multispan = MultiSpan::from_span(span);\n-                    multispan.push_span_label(span_late, note.to_string());\n-                    tcx.struct_span_lint_hir(\n-                        LATE_BOUND_LIFETIME_ARGUMENTS,\n-                        args.args[0].id(),\n-                        multispan,\n-                        |lint| lint.build(msg).emit(),\n-                    );\n-                }\n+        let explicit_late_bound =\n+            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n+\n+        let check_kind_count = |kind,\n+                                required,\n+                                permitted,\n+                                provided,\n+                                offset,\n+                                unexpected_spans: &mut Vec<Span>,\n+                                silent| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind, required, permitted, provided, offset\n+            );\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return Ok(());\n             }\n-        }\n \n-        let check_kind_count =\n-            |kind, required, permitted, provided, offset, unexpected_spans: &mut Vec<Span>| {\n-                debug!(\n-                    \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                    kind, required, permitted, provided, offset\n-                );\n-                // We enforce the following: `required` <= `provided` <= `permitted`.\n-                // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-                // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-                if required <= provided && provided <= permitted {\n-                    return Ok(());\n-                }\n-\n-                // Unfortunately lifetime and type parameter mismatches are typically styled\n-                // differently in diagnostics, which means we have a few cases to consider here.\n-                let (bound, quantifier) = if required != permitted {\n-                    if provided < required {\n-                        (required, \"at least \")\n-                    } else {\n-                        // provided > permitted\n-                        (permitted, \"at most \")\n-                    }\n-                } else {\n-                    (required, \"\")\n-                };\n+            if silent {\n+                return Err(true);\n+            }\n \n-                let (spans, label) = if required == permitted && provided > permitted {\n-                    // In the case when the user has provided too many arguments,\n-                    // we want to point to the unexpected arguments.\n-                    let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span())\n-                        .collect();\n-                    unexpected_spans.extend(spans.clone());\n-                    (spans, format!(\"unexpected {} argument\", kind))\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \")\n                 } else {\n-                    (\n-                        vec![span],\n-                        format!(\n-                            \"expected {}{} {} argument{}\",\n-                            quantifier,\n-                            bound,\n-                            kind,\n-                            pluralize!(bound),\n-                        ),\n-                    )\n-                };\n-\n-                let mut err = tcx.sess.struct_span_err_with_code(\n-                    spans.clone(),\n-                    &format!(\n-                        \"wrong number of {} arguments: expected {}{}, found {}\",\n-                        kind, quantifier, bound, provided,\n-                    ),\n-                    DiagnosticId::Error(\"E0107\".into()),\n-                );\n-                for span in spans {\n-                    err.span_label(span, label.as_str());\n+                    // provided > permitted\n+                    (permitted, \"at most \")\n                 }\n-                err.emit();\n+            } else {\n+                (required, \"\")\n+            };\n \n-                Err(true)\n+            let (spans, label) = if required == permitted && provided > permitted {\n+                // In the case when the user has provided too many arguments,\n+                // we want to point to the unexpected arguments.\n+                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span())\n+                    .collect();\n+                unexpected_spans.extend(spans.clone());\n+                (spans, format!(\"unexpected {} argument\", kind))\n+            } else {\n+                (\n+                    vec![span],\n+                    format!(\n+                        \"expected {}{} {} argument{}\",\n+                        quantifier,\n+                        bound,\n+                        kind,\n+                        pluralize!(bound),\n+                    ),\n+                )\n             };\n \n-        let mut arg_count_correct = explicit_lifetimes;\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                spans.clone(),\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind, quantifier, bound, provided,\n+                ),\n+                DiagnosticId::Error(\"E0107\".into()),\n+            );\n+            for span in spans {\n+                err.span_label(span, label.as_str());\n+            }\n+            err.emit();\n+\n+            Err(true)\n+        };\n+\n+        let mut arg_count_correct = Ok(());\n         let mut unexpected_spans = vec![];\n \n-        if arg_count_correct.is_ok()\n-            && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes)\n-        {\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n             arg_count_correct = check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n                 arg_counts.lifetimes,\n                 0,\n                 &mut unexpected_spans,\n+                explicit_late_bound == ExplicitLateBound::Yes,\n             )\n             .and(arg_count_correct);\n         }\n@@ -438,6 +444,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 arg_counts.consts,\n                 arg_counts.lifetimes + arg_counts.types,\n                 &mut unexpected_spans,\n+                false,\n             )\n             .and(arg_count_correct);\n         }\n@@ -451,14 +458,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 arg_counts.types,\n                 arg_counts.lifetimes,\n                 &mut unexpected_spans,\n+                false,\n             )\n             .and(arg_count_correct);\n         }\n \n-        arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n-            reported: if reported_err { Some(ErrorReported) } else { None },\n-            invalid_args: unexpected_spans,\n-        })\n+        GenericArgCountResult {\n+            explicit_late_bound,\n+            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+                reported: if reported_err { Some(ErrorReported) } else { None },\n+                invalid_args: unexpected_spans,\n+            }),\n+        }\n     }\n \n     /// Report an error that a generic argument did not match the generic parameter that was\n@@ -512,7 +523,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count_correct: bool,\n+        arg_count: GenericArgCountResult,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n         mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n@@ -585,30 +596,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // input. We try to handle both sensibly.\n                 match (args.peek(), params.peek()) {\n                     (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. })\n-                            | (GenericArg::Const(_), GenericParamDefKind::Const) => {\n+                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n                                 substs.push(provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n                             }\n                             (\n                                 GenericArg::Type(_) | GenericArg::Const(_),\n                                 GenericParamDefKind::Lifetime,\n+                                _,\n                             ) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n                                 substs.push(inferred_kind(None, param, infer_args));\n                                 force_infer_lt = Some(arg);\n                                 params.next();\n                             }\n-                            (_, kind) => {\n+                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                                // We've come across a lifetime when we expected something else in\n+                                // the presence of explicit late bounds. This is most likely\n+                                // due to the presence of the explicit bound so we're just going to\n+                                // ignore it.\n+                                args.next();\n+                            }\n+                            (_, kind, _) => {\n                                 // We expected one kind of parameter, but the user provided\n                                 // another. This is an error. However, if we already know that\n                                 // the arguments don't match up with the parameters, we won't issue\n                                 // an additional error, as the user already knows what's wrong.\n-                                if arg_count_correct {\n+                                if arg_count.correct.is_ok()\n+                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                                {\n                                     Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n                                 }\n \n@@ -624,17 +645,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                     (Some(&arg), None) => {\n                         // We should never be able to reach this point with well-formed input.\n-                        // There are two situations in which we can encounter this issue.\n+                        // There are three situations in which we can encounter this issue.\n                         //\n                         //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it. This case\n-                        //      also occurs when late-bound lifetime parameters are present, yet\n-                        //      the lifetime arguments have also been explicitly specified by the\n+                        //      will already have been emitted, and we can ignore it.\n+                        //  2.  There are late-bound lifetime parameters present, yet the\n+                        //      lifetime arguments have also been explicitly specified by the\n                         //      user.\n-                        //  2.  We've inferred some lifetimes, which have been provided later (i.e.\n+                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n                         //      after a type or const). We want to throw an error in this case.\n \n-                        if arg_count_correct {\n+                        if arg_count.correct.is_ok()\n+                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                        {\n                             let kind = arg.descr();\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n@@ -699,8 +722,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n-    {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n@@ -726,7 +748,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none() && parent_substs.is_empty());\n         }\n \n-        let arg_count_correct = Self::check_generic_arg_count(\n+        let arg_count = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n@@ -761,7 +783,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count_correct.is_ok(),\n+            arg_count.clone(),\n             // Provide the generic args, and whether types should be inferred.\n             |did| {\n                 if did == def_id {\n@@ -880,7 +902,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_params, self_ty, substs\n         );\n \n-        (substs, assoc_bindings, arg_count_correct)\n+        (substs, assoc_bindings, arg_count)\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -1011,14 +1033,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings, arg_count_correct) = self.create_substs_for_ast_trait_ref(\n+        let (substs, assoc_bindings, arg_count) = self.create_substs_for_ast_trait_ref(\n             trait_ref.path.span,\n             trait_def_id,\n             self_ty,\n@@ -1048,7 +1070,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_ref, bounds, poly_trait_ref\n         );\n \n-        arg_count_correct\n+        arg_count\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -1076,7 +1098,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n@@ -1166,8 +1188,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n-    {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n@@ -1515,9 +1536,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         for trait_bound in trait_bounds.iter().rev() {\n-            if let Err(GenericArgCountMismatch {\n-                invalid_args: cur_potential_assoc_types, ..\n-            }) = self.instantiate_poly_trait_ref(\n+            if let GenericArgCountResult {\n+                correct:\n+                    Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n+                ..\n+            } = self.instantiate_poly_trait_ref(\n                 trait_bound,\n                 Constness::NotConst,\n                 dummy_self,\n@@ -2473,6 +2496,47 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n+    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+    /// are present. This is used both for datatypes and function calls.\n+    fn prohibit_explicit_late_bound_lifetimes(\n+        tcx: TyCtxt<'_>,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+    ) -> ExplicitLateBound {\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        if infer_lifetimes {\n+            ExplicitLateBound::No\n+        } else if let Some(span_late) = def.has_late_bound_regions {\n+            let msg = \"cannot specify lifetime arguments explicitly \\\n+                       if late bound lifetime parameters are present\";\n+            let note = \"the late bound lifetime parameter is introduced here\";\n+            let span = args.args[0].span();\n+            if position == GenericArgPosition::Value\n+                && arg_counts.lifetimes != param_counts.lifetimes\n+            {\n+                let mut err = tcx.sess.struct_span_err(span, msg);\n+                err.span_note(span_late, note);\n+                err.emit();\n+            } else {\n+                let mut multispan = MultiSpan::from_span(span);\n+                multispan.push_span_label(span_late, note.to_string());\n+                tcx.struct_span_lint_hir(\n+                    LATE_BOUND_LIFETIME_ARGUMENTS,\n+                    args.args[0].id(),\n+                    multispan,\n+                    |lint| lint.build(msg).emit(),\n+                );\n+            }\n+            ExplicitLateBound::Yes\n+        } else {\n+            ExplicitLateBound::No\n+        }\n+    }\n+\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,"}, {"sha": "35094c69037b6df25083c943cf003606b0c490ed", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fa351eefa0f547b9263984e71e1297052862a20f", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_correct.is_ok(),\n+            arg_count_correct,\n             // Provide the generic args, and whether types should be inferred.\n             |def_id| {\n                 // The last component of the returned tuple here is unimportant."}, {"sha": "91ebb10303764f84aa7a1f7dcfdf5b707fac54d3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa351eefa0f547b9263984e71e1297052862a20f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fa351eefa0f547b9263984e71e1297052862a20f", "patch": "@@ -87,7 +87,9 @@ mod upvar;\n mod wfcheck;\n pub mod writeback;\n \n-use crate::astconv::{AstConv, GenericArgCountMismatch, PathSeg};\n+use crate::astconv::{\n+    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n+};\n use rustc_ast::ast;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_attr as attr;\n@@ -5495,11 +5497,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            if let Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }) =\n-                AstConv::check_generic_arg_count_for_call(\n-                    tcx, span, &generics, &seg, false, // `is_method_call`\n-                )\n-            {\n+            if let GenericArgCountResult {\n+                correct: Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }),\n+                ..\n+            } = AstConv::check_generic_arg_count_for_call(\n+                tcx, span, &generics, &seg, false, // `is_method_call`\n+            ) {\n                 infer_args_for_err.insert(index);\n                 self.set_tainted_by_errors(); // See issue #53251.\n             }\n@@ -5555,14 +5558,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // escaping late-bound regions, and nor should the base type scheme.\n         let ty = tcx.type_of(def_id);\n \n+        let arg_count = GenericArgCountResult {\n+            explicit_late_bound: ExplicitLateBound::No,\n+            correct: if infer_args_for_err.is_empty() {\n+                Ok(())\n+            } else {\n+                Err(GenericArgCountMismatch::default())\n+            },\n+        };\n+\n         let substs = self_ctor_substs.unwrap_or_else(|| {\n             AstConv::create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                infer_args_for_err.is_empty(),\n+                arg_count,\n                 // Provide the generic args, and whether types should be inferred.\n                 |def_id| {\n                     if let Some(&PathSeg(_, index)) ="}, {"sha": "92fd1f73a937f78833a94caf97326a5897604d06", "filename": "src/test/ui/issues/issue-72278.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa351eefa0f547b9263984e71e1297052862a20f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa351eefa0f547b9263984e71e1297052862a20f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs?ref=fa351eefa0f547b9263984e71e1297052862a20f", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#![allow(unused)]\n+\n+struct S;\n+\n+impl S {\n+    fn func<'a, U>(&'a self) -> U {\n+        todo!()\n+    }\n+}\n+\n+fn dont_crash<'a, U>() -> U {\n+    S.func::<'a, U>()\n+    //~^ WARN cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "41dff686bc4aeff5864492a116228ea7074e3d0f", "filename": "src/test/ui/issues/issue-72278.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa351eefa0f547b9263984e71e1297052862a20f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa351eefa0f547b9263984e71e1297052862a20f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr?ref=fa351eefa0f547b9263984e71e1297052862a20f", "patch": "@@ -0,0 +1,15 @@\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/issue-72278.rs:14:14\n+   |\n+LL |     fn func<'a, U>(&'a self) -> U {\n+   |             -- the late bound lifetime parameter is introduced here\n+...\n+LL |     S.func::<'a, U>()\n+   |              ^^\n+   |\n+   = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+\n+warning: 1 warning emitted\n+"}]}