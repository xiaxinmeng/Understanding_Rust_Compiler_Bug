{"sha": "ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "node_id": "C_kwDOAAsO6NoAKGNjZjk5YmQ3NjkwYTMzYTI5NjQ3YjlkOTRjNjRjNGJkYzI2M2UyZDQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-06-01T05:39:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-01T05:39:43Z"}, "message": "Rollup merge of #111980 - compiler-errors:unmapped-substs, r=lcnr\n\nPreserve substs in opaques recorded in typeck results\n\nThis means that we now prepopulate MIR with opaques with the right substs.\n\nThe first commit is a hack that I think we discussed, having to do with `DefiningAnchor::Bubble` basically being equivalent to `DefiningAnchor::Error` in the new solver, so having to use `DefiningAnchor::Bind` instead, lol.\n\nr? `@lcnr`", "tree": {"sha": "bd74047ea5e1a48333ac5cc8106b368b13cdf913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd74047ea5e1a48333ac5cc8106b368b13cdf913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkeC8fCRBK7hj4Ov3rIwAACOkIAINAwPZtx7HSsPfGEhXib0jL\n6EA9FjsotdFGIYk7PvAWPCyOqoJCpVVEHKfUSTK/ogLQxV1b6H48Xhs3RxyvEnLo\ng8l2/rr330S+2F0Nm+Cq+ChK3tgVsfPu2Jv/z4WUf0tuPF7mQYejGOf0FYp+0o73\nAsH0wqRCbkwNz7A5ry92IwDezLpJke1CEl+x0d+3NLV9f3o8/afQ5CYEXzeDTUmQ\nDzI1k9ipxy/KjBqOH4X8PQQkBmRAeq2a6EM85W/eS8qQX4FoBB/1IWh83xdVae+V\noPSYrkCce6rOH+oT2+2pVOxV5uhVZQ/1TZD7ol+lxzwlvJQrCSiyV4CqNj86p2k=\n=PDkc\n-----END PGP SIGNATURE-----\n", "payload": "tree bd74047ea5e1a48333ac5cc8106b368b13cdf913\nparent 453fc0359752a074647f37eeb6c7abd4835e5915\nparent df1c1afdafcf8c9c46b18f274fc7f01f13ff05da\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1685597983 +0530\ncommitter GitHub <noreply@github.com> 1685597983 +0530\n\nRollup merge of #111980 - compiler-errors:unmapped-substs, r=lcnr\n\nPreserve substs in opaques recorded in typeck results\n\nThis means that we now prepopulate MIR with opaques with the right substs.\n\nThe first commit is a hack that I think we discussed, having to do with `DefiningAnchor::Bubble` basically being equivalent to `DefiningAnchor::Error` in the new solver, so having to use `DefiningAnchor::Bind` instead, lol.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "html_url": "https://github.com/rust-lang/rust/commit/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "453fc0359752a074647f37eeb6c7abd4835e5915", "url": "https://api.github.com/repos/rust-lang/rust/commits/453fc0359752a074647f37eeb6c7abd4835e5915", "html_url": "https://github.com/rust-lang/rust/commit/453fc0359752a074647f37eeb6c7abd4835e5915"}, {"sha": "df1c1afdafcf8c9c46b18f274fc7f01f13ff05da", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1c1afdafcf8c9c46b18f274fc7f01f13ff05da", "html_url": "https://github.com/rust-lang/rust/commit/df1c1afdafcf8c9c46b18f274fc7f01f13ff05da"}], "stats": {"total": 314, "additions": 127, "deletions": 187}, "files": [{"sha": "13e346b86bce315387bba6dd6bfeb94c3fed619f", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -279,8 +279,18 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // HACK This bubble is required for this tests to pass:\n         // nested-return-type2-tait2.rs\n         // nested-return-type2-tait3.rs\n-        let infcx =\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n+        // and prepopulate this `InferCtxt` with known opaque values, rather than\n+        // using the `Bind` anchor here. For now it's fine.\n+        let infcx = self\n+            .tcx\n+            .infer_ctxt()\n+            .with_opaque_type_inference(if self.tcx.trait_solver_next() {\n+                DefiningAnchor::Bind(def_id)\n+            } else {\n+                DefiningAnchor::Bubble\n+            })\n+            .build();\n         let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the"}, {"sha": "908ff3da5ca0b4388358879094f8b50147678e1c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -188,9 +188,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n-    // the HIR typeck map defining usages back to their definition params,\n-    // they won't actually match up with the usages in this body...\n     if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n@@ -1042,10 +1039,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .typeck(self.body.source.def_id().expect_local())\n             .concrete_opaque_types\n             .iter()\n-            .map(|(&def_id, &hidden_ty)| {\n-                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n-                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n-            })\n+            .map(|(k, v)| (*k, *v))\n             .collect();\n \n         let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {"}, {"sha": "4d96a7ff4c3d7de99c774c6ce0c1ff6b25787d65", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -1,3 +1,4 @@\n+use rustc_errors::StashKey;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n@@ -59,7 +60,20 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n         }\n     }\n \n-    let Some(hidden) = locator.found else {\n+    if let Some(hidden) = locator.found {\n+        // Only check against typeck if we didn't already error\n+        if !hidden.ty.references_error() {\n+            for concrete_type in locator.typeck_types {\n+                if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                    && !(concrete_type, hidden).references_error()\n+                {\n+                    hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+                }\n+            }\n+        }\n+\n+        hidden.ty\n+    } else {\n         let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n@@ -70,21 +84,8 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n+        tcx.ty_error(reported)\n     }\n-\n-    hidden.ty\n }\n \n struct TaitConstraintLocator<'tcx> {\n@@ -130,13 +131,28 @@ impl TaitConstraintLocator<'_> {\n             self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n             return;\n         }\n-        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+\n+        let mut constrained = false;\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != self.def_id {\n+                continue;\n+            }\n+            constrained = true;\n+            let concrete_type =\n+                self.tcx.erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx,\n+                    true,\n+                ));\n+            if self.typeck_types.iter().all(|prev| prev.ty != concrete_type.ty) {\n+                self.typeck_types.push(concrete_type);\n+            }\n+        }\n+\n+        if !constrained {\n             debug!(\"no constraints in typeck results\");\n             return;\n         };\n-        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-            self.typeck_types.push(typeck_hidden_ty);\n-        }\n \n         // Use borrowck to get the type with unerased regions.\n         let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n@@ -190,45 +206,74 @@ impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n     }\n }\n \n-pub(super) fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n+pub(super) fn find_opaque_ty_constraints_for_rpit<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     owner_def_id: LocalDefId,\n ) -> Ty<'_> {\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    let tables = tcx.typeck(owner_def_id);\n+\n+    // Check that all of the opaques we inferred during HIR are compatible.\n+    // FIXME: We explicitly don't check that the types inferred during HIR\n+    // typeck are compatible with the one that we infer during borrowck,\n+    // because that one actually sometimes has consts evaluated eagerly so\n+    // using strict type equality will fail.\n+    let mut hir_opaque_ty: Option<ty::OpaqueHiddenType<'tcx>> = None;\n+    if tables.tainted_by_errors.is_none() {\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != def_id {\n+                continue;\n+            }\n+            let concrete_type = tcx.erase_regions(\n+                hidden_type.remap_generic_params_to_declaration_params(opaque_type_key, tcx, true),\n+            );\n+            if let Some(prev) = &mut hir_opaque_ty {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    prev.report_mismatch(&concrete_type, def_id, tcx).stash(\n+                        tcx.def_span(opaque_type_key.def_id),\n+                        StashKey::OpaqueHiddenTypeMismatch,\n+                    );\n+                }\n+            } else {\n+                hir_opaque_ty = Some(concrete_type);\n+            }\n+        }\n+    }\n \n-    if let Some(concrete) = concrete {\n+    let mir_opaque_ty = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    if let Some(mir_opaque_ty) = mir_opaque_ty {\n         let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n         debug!(?scope);\n-        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: mir_opaque_ty };\n \n         match tcx.hir().get(scope) {\n             Node::Item(it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n         }\n-    }\n \n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n+        mir_opaque_ty.ty\n+    } else {\n+        if let Some(guar) = tables.tainted_by_errors {\n+            // Some error in the owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n             tcx.ty_error(guar)\n         } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+            // Fall back to the RPIT we inferred during HIR typeck\n+            if let Some(hir_opaque_ty) = hir_opaque_ty {\n+                hir_opaque_ty.ty\n+            } else {\n                 // We failed to resolve the opaque type or it\n                 // resolves to itself. We interpret this as the\n                 // no values of the hidden type ever being constructed,\n                 // so we can just make the hidden type be `!`.\n                 // For backwards compatibility reasons, we fall back to\n                 // `()` until we the diverging default is changed.\n                 tcx.mk_diverging_default()\n-            })\n+            }\n         }\n-    })\n+    }\n }\n \n struct RpitConstraintChecker<'tcx> {"}, {"sha": "964acc4eb77ef803a6741f4fce489302da8cd8c9", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -583,19 +583,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type =\n-                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n-                    opaque_type_key,\n-                    self.tcx(),\n-                    true,\n-                ));\n-\n+            // Here we only detect impl trait definition conflicts when they\n+            // are equal modulo regions.\n             if let Some(last_opaque_ty) = self\n                 .typeck_results\n                 .concrete_opaque_types\n-                .insert(opaque_type_key.def_id, hidden_type)\n+                .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n+                assert!(!self.tcx().trait_solver_next());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash("}, {"sha": "8cbffa14850fac3a5187fb83b6dbf1b6ef5674d5", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -155,11 +155,7 @@ pub struct TypeckResults<'tcx> {\n     /// We also store the type here, so that the compiler can use it as a hint\n     /// for figuring out hidden types, even if they are only set in dead code\n     /// (which doesn't show up in MIR).\n-    ///\n-    /// These types are mapped back to the opaque's identity substitutions\n-    /// (with erased regions), which is why we don't associated substs with any\n-    /// of these usages.\n-    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<ty::OpaqueTypeKey<'tcx>, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "e6d46b02706b1c523c13f4fb2b73e898c397498d", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -13,16 +13,9 @@ error: internal compiler error: projection clauses should be implied from elsewh\n LL | async fn foo(x: u32) -> u32 {\n    |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n-#1 [thir_body] building THIR for `foo`\n-#2 [check_match] match-checking `foo`\n-#3 [mir_built] building MIR for `foo`\n-#4 [unsafety_check_result] unsafety-checking `foo`\n-#5 [mir_const] preparing `foo` for borrow checking\n-#6 [mir_promoted] promoting constants in MIR for `foo`\n-#7 [mir_borrowck] borrow-checking `foo`\n-#8 [type_of] computing type of `foo::{opaque#0}`\n-#9 [check_mod_item_types] checking item types in top-level module\n-#10 [analysis] running analysis passes on this crate\n+#1 [type_of] computing type of `foo::{opaque#0}`\n+#2 [check_mod_item_types] checking item types in top-level module\n+#3 [analysis] running analysis passes on this crate\n end of query stack\n error: aborting due to 2 previous errors\n "}, {"sha": "408abecc30d4426929f583034ecf1b58a6c246ca", "filename": "tests/ui/dyn-star/param-env-infer.next.stderr", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -13,41 +13,6 @@ error[E0391]: cycle detected when computing type of `make_dyn_star::{opaque#0}`\n LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `make_dyn_star` for borrow checking...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `make_dyn_star`...\n   --> $DIR/param-env-infer.rs:11:1\n    |"}, {"sha": "c0c4cd5013e5fffaafe68a0f581fcd36b7d43cd5", "filename": "tests/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -4,41 +4,6 @@ error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle1` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n   --> $DIR/auto-trait-leak.rs:14:5\n    |\n@@ -50,41 +15,6 @@ note: ...which requires computing type of `cycle2::{opaque#0}`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle2` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n   --> $DIR/auto-trait-leak.rs:20:5\n    |"}, {"sha": "86661153a0d098a57e985b87256b0eb6e6d3e41a", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -4,9 +4,9 @@ impl Trait for () {}\n fn foo<T: Trait, U: Trait>() -> impl Trait {\n     //~^ WARN function cannot return without recursing [unconditional_recursion]\n     let a: T = foo::<T, U>();\n-    //~^ ERROR concrete type differs from previous defining opaque type use\n     loop {}\n     let _: T = foo::<U, T>();\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n }\n \n fn main() {}"}, {"sha": "f3c090408b42e804f89fde74ab66b82fb7d35d2f", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -11,15 +11,15 @@ LL |     let a: T = foo::<T, U>();\n    = note: `#[warn(unconditional_recursion)]` on by default\n \n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:8:16\n    |\n-LL |     let a: T = foo::<T, U>();\n-   |                ^^^^^^^^^^^^^ expected `U`, got `T`\n+LL |     let _: T = foo::<U, T>();\n+   |                ^^^^^^^^^^^^^ expected `T`, got `U`\n    |\n note: previous use here\n-  --> $DIR/multiple-defining-usages-in-body.rs:9:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n    |\n-LL |     let _: T = foo::<U, T>();\n+LL |     let a: T = foo::<T, U>();\n    |                ^^^^^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "028222f4e6dba451272373f4ed485bdce95aaf57", "filename": "tests/ui/traits/new-solver/dont-remap-tait-substs.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Makes sure we don't prepopulate the MIR typeck of `define`\n+// with `Foo<T, U> = T`, but instead, `Foo<B, A> = B`, so that\n+// the param-env predicates actually apply.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T: Send, U> = impl NeedsSend<T>;\n+\n+trait NeedsSend<T> {}\n+impl<T: Send> NeedsSend<T> for T {}\n+\n+fn define<A, B: Send>(a: A, b: B) {\n+    let y: Option<Foo<B, A>> = Some(b);\n+}\n+\n+fn main() {}"}, {"sha": "07f3dd1997bed87584b3bc001aa41c898cfe04cd", "filename": "tests/ui/type-alias-impl-trait/cross_inference.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -1,3 +1,5 @@\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n // check-pass\n \n #![feature(type_alias_impl_trait)]"}, {"sha": "da845e86147b7ffb620f880936aae59069a2095f", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -8,7 +8,6 @@ type X<A, B> = impl Into<&'static A>;\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n     //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n-    //~| ERROR concrete type differs from previous defining opaque type use\n     (a, a)\n }\n "}, {"sha": "66a6b0bbf743148407ae5faa5a4d9d00815da3aa", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf99bd7690a33a29647b9d94c64c4bdc263e2d4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=ccf99bd7690a33a29647b9d94c64c4bdc263e2d4", "patch": "@@ -10,15 +10,6 @@ help: consider introducing a `where` clause, but there might be an alternative b\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++\n \n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n-   |\n-LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n-   |                                             ^^^^^^^^^^^^^^^^^^\n-   |                                             |\n-   |                                             expected `&B`, got `&A`\n-   |                                             this expression supplies two conflicting concrete types for the same opaque type\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}]}