{"sha": "a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YzhjOGFlMjg2YjUxN2ZlMDBkYTlmNjhhNzc2Y2UxZTY4NDVmMGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-24T23:42:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-24T23:42:16Z"}, "message": "std: FIXME's and cleanups for uv", "tree": {"sha": "dd90e1a3d456b9e58abbbd0c6d2d32a5ffc68fa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd90e1a3d456b9e58abbbd0c6d2d32a5ffc68fa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "html_url": "https://github.com/rust-lang/rust/commit/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433e4ca5f166f2e3322b90bc53f32bc44d534640", "url": "https://api.github.com/repos/rust-lang/rust/commits/433e4ca5f166f2e3322b90bc53f32bc44d534640", "html_url": "https://github.com/rust-lang/rust/commit/433e4ca5f166f2e3322b90bc53f32bc44d534640"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "0f29b0c391efea07c5b5dd474144a9e52b5d3b15", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "patch": "@@ -2,6 +2,7 @@\n High-level interface to libuv's TCP functionality\n \"];\n \n+// FIXME: Fewer import *'s\n import ip = net_ip;\n import comm::*;\n import result::*;\n@@ -118,11 +119,11 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n     log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n-    log(debug, #fmt(\"stream_handl_ptr outside interact %?\",\n+    log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n     uv::hl::interact(hl_loop) {|loop_ptr|\n         log(debug, \"in interact cb for tcp client connect..\");\n-        log(debug, #fmt(\"stream_handl_ptr in interact %?\",\n+        log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n         alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n           0i32 {\n@@ -191,7 +192,7 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n }\n \n #[doc=\"\n-Write binary data to a tcp stream; Blocks until operatoin completes\n+Write binary data to a tcp stream; Blocks until operation completes\n \n # Arguments\n \n@@ -360,6 +361,8 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n                                                   tcp_err_data>>();\n     let new_conn_ch = comm::chan(new_conn_po);\n+    // FIXME: This shared box should not be captured in the i/o task\n+    // Make it a unique pointer.\n     let server_data: @tcp_conn_port_data = @{\n         server_stream: uv::ll::tcp_t(),\n         stream_closed_po: stream_closed_po,\n@@ -940,6 +943,10 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n           }\n         }\n     };\n+    // FIXME: Instead of passing unsafe pointers to local data, and waiting\n+    // here for the write to complete, we should transfer ownership of\n+    // everything to the I/O task and let it deal with the aftermath,\n+    // so we don't have to sit here blocking.\n     alt comm::recv(result_po) {\n       tcp_write_success { result::ok(()) }\n       tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n@@ -1181,6 +1188,7 @@ crust fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     let write_data_ptr = uv::ll::get_data_for_req(write_req)\n         as *write_req_data;\n+    // FIXME: if instead of alt\n     alt status {\n       0i32 {\n         log(debug, \"successful write complete\");"}, {"sha": "f6b88c810f40040d44ccce7caf3612dfc68a1ef4", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "patch": "@@ -23,6 +23,7 @@ for *at least* that period of time.\n \"]\n fn delayed_send<T: copy send>(hl_loop: uv::hl::high_level_loop,\n                               msecs: uint, ch: comm::chan<T>, val: T) {\n+    // FIME: Looks like we don't need to spawn here\n     task::spawn() {||\n         unsafe {\n             let timer_done_po = comm::port::<()>();\n@@ -103,6 +104,7 @@ fn recv_timeout<T: copy send>(hl_loop: uv::hl::high_level_loop,\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n     delayed_send(hl_loop, msecs, timeout_ch, ());\n+    // FIXME: This could be written clearer\n     either::either(\n         {|left_val|\n             log(debug, #fmt(\"recv_time .. left_val %?\","}, {"sha": "a803c04c80bb63bf61fc6fdeaec3ec93ec754023", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c8c8ae286b517fe00da9f68a776ce1e6845f0d/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=a8c8c8ae286b517fe00da9f68a776ce1e6845f0d", "patch": "@@ -11,6 +11,7 @@ export run_high_level_loop, interact;\n \n import ll = uv_ll;\n \n+// FIXME: Newtype syntax\n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \"]\n@@ -125,8 +126,10 @@ unsafe fn interact(hl_loop: high_level_loop,\n \n // INTERNAL API\n \n+// FIXME: Newtype syntax\n // data that lives for the lifetime of the high-evel oo\n enum hl_loop_data {\n+    // FIXME: hl, not gl?\n     default_gl_data({\n         async_handle: *ll::uv_async_t,\n         mut active: bool,\n@@ -135,6 +138,7 @@ enum hl_loop_data {\n         msg_po_ptr: *comm::port<high_level_msg>})\n }\n \n+// FIXME: This function can be much simpler\n unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n                               -msg: high_level_msg) {\n     let op_chan = alt hl_loop{simple_task_loop({async_handle, op_chan}){\n@@ -164,9 +168,12 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n                      async_handle, status));\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *hl_loop_data;\n+    // FIXME: What is this checking?\n+    // FIXME: Use if not alt\n     alt (*data).active {\n       true {\n         let msg_po = *((*data).msg_po_ptr);\n+        // FIXME: Convert to while loop\n         alt comm::peek(msg_po) {\n           true {\n             loop {"}]}