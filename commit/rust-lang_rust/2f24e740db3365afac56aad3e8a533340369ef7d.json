{"sha": "2f24e740db3365afac56aad3e8a533340369ef7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMjRlNzQwZGIzMzY1YWZhYzU2YWFkM2U4YTUzMzM0MDM2OWVmN2Q=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-10T15:19:50Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-10T15:48:29Z"}, "message": "Implement glob imports within the same crate\n\nFixes #231.", "tree": {"sha": "18084cb38cb0fe1faa621c3209a9f3f411faf5f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18084cb38cb0fe1faa621c3209a9f3f411faf5f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f24e740db3365afac56aad3e8a533340369ef7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f24e740db3365afac56aad3e8a533340369ef7d", "html_url": "https://github.com/rust-lang/rust/commit/2f24e740db3365afac56aad3e8a533340369ef7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f24e740db3365afac56aad3e8a533340369ef7d/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e1d739a8063307facf9ff098c26b02005092e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1d739a8063307facf9ff098c26b02005092e05", "html_url": "https://github.com/rust-lang/rust/commit/2e1d739a8063307facf9ff098c26b02005092e05"}], "stats": {"total": 93, "additions": 77, "deletions": 16}, "files": [{"sha": "94f7db0241df8674fc23d1db0229162e45f89baa", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2f24e740db3365afac56aad3e8a533340369ef7d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f24e740db3365afac56aad3e8a533340369ef7d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=2f24e740db3365afac56aad3e8a533340369ef7d", "patch": "@@ -61,7 +61,7 @@ impl ModuleScope {\n \n /// `Resolution` is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs<ModuleDef>,\n@@ -154,6 +154,8 @@ struct Resolver<'a, DB> {\n     krate: Crate,\n     module_tree: Arc<ModuleTree>,\n     processed_imports: FxHashSet<(ModuleId, ImportId)>,\n+    /// If module `a` has `use b::*`, then this contains the mapping b -> a (and the import)\n+    glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, ImportId)>>,\n     result: ItemMap,\n }\n \n@@ -173,6 +175,7 @@ where\n             krate,\n             module_tree,\n             processed_imports: FxHashSet::default(),\n+            glob_imports: FxHashMap::default(),\n             result: ItemMap::default(),\n         }\n     }\n@@ -281,12 +284,28 @@ where\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.item_map(m.krate);\n                         let scope = &item_map[m.module_id];\n-                        self.update(module_id, |items| {\n-                            // TODO: handle shadowing and visibility\n-                            items.items.extend(\n-                                scope.items.iter().map(|(name, res)| (name.clone(), res.clone())),\n-                            );\n-                        });\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                    } else {\n+                        // glob import from same crate => we do an initial\n+                        // import, and then need to propagate any further\n+                        // additions\n+                        let scope = &self.result[m.module_id];\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                        // record the glob import in case we add further items\n+                        self.glob_imports\n+                            .entry(m.module_id)\n+                            .or_default()\n+                            .push((module_id, import_id));\n                     }\n                 }\n                 Some(ModuleDef::Enum(e)) => {\n@@ -304,9 +323,7 @@ where\n                             Some((name, res))\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, |items| {\n-                        items.items.extend(resolutions);\n-                    });\n+                    self.update(module_id, Some(import_id), &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -328,17 +345,61 @@ where\n                     }\n                 }\n             }\n-            self.update(module_id, |items| {\n-                let res = Resolution { def, import: Some(import_id) };\n-                items.items.insert(name, res);\n-            });\n+            let resolution = Resolution { def, import: Some(import_id) };\n+            self.update(module_id, None, &[(name, resolution)]);\n         }\n         reached_fixedpoint\n     }\n \n-    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+    fn update(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+    ) {\n+        self.update_recursive(module_id, import, resolutions, 0)\n+    }\n+\n+    fn update_recursive(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+        depth: usize,\n+    ) {\n+        if depth > 100 {\n+            // prevent stack overflows (but this shouldn't be possible)\n+            panic!(\"infinite recursion in glob imports!\");\n+        }\n         let module_items = self.result.per_module.get_mut(module_id).unwrap();\n-        f(module_items)\n+        let mut changed = false;\n+        for (name, res) in resolutions {\n+            let existing = module_items.items.entry(name.clone()).or_default();\n+            if existing.def.types.is_none() && res.def.types.is_some() {\n+                existing.def.types = res.def.types;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.values.is_none() && res.def.values.is_some() {\n+                existing.def.values = res.def.values;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+        }\n+        if !changed {\n+            return;\n+        }\n+        let glob_imports = self\n+            .glob_imports\n+            .get(&module_id)\n+            .into_iter()\n+            .flat_map(|v| v.iter())\n+            .cloned()\n+            .collect::<Vec<_>>();\n+        for (glob_importing_module, glob_import) in glob_imports {\n+            // We pass the glob import so that the tracked import in those modules is that glob import\n+            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+        }\n     }\n }\n "}]}