{"sha": "9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNDcxNjA2YzA1NjIxZGI2YWI4NWY2YmI2NDVlNTJlMGY5YWQ1ZWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-08T02:10:26Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-13T22:45:59Z"}, "message": "Remove CSV format of save-analysis data", "tree": {"sha": "39a050cb0cdf2f556c95e851ab8752a1a51da5a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39a050cb0cdf2f556c95e851ab8752a1a51da5a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "html_url": "https://github.com/rust-lang/rust/commit/9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03abb1bd70ac56e4aba0684bab819892a0157843", "url": "https://api.github.com/repos/rust-lang/rust/commits/03abb1bd70ac56e4aba0684bab819892a0157843", "html_url": "https://github.com/rust-lang/rust/commit/03abb1bd70ac56e4aba0684bab819892a0157843"}], "stats": {"total": 453, "additions": 1, "deletions": 452}, "files": [{"sha": "9f950414219b5192001826c1b99822a489c78d1e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "patch": "@@ -935,8 +935,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information, in \\\n          addition to normal output\"),\n-    save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in CSV format) information, in addition to normal output\"),\n     save_analysis_api: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis information for opaque libraries (in JSON format), \\\n          in addition to normal output\"),\n@@ -2469,8 +2467,6 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.save_analysis_csv = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis_api = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.print_move_fragments = true;"}, {"sha": "995007eb16fed15b575ccc39105890bdf6959c8b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "patch": "@@ -534,15 +534,12 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n \n fn save_analysis(sess: &Session) -> bool {\n     sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv ||\n     sess.opts.debugging_opts.save_analysis_api\n }\n \n fn save_analysis_format(sess: &Session) -> save::Format {\n     if sess.opts.debugging_opts.save_analysis {\n         save::Format::Json\n-    } else if sess.opts.debugging_opts.save_analysis_csv {\n-        save::Format::Csv\n     } else if sess.opts.debugging_opts.save_analysis_api {\n         save::Format::JsonApi\n     } else {"}, {"sha": "4bab135ff12f70db54b2a65ef5007de61d07dcea", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/03abb1bd70ac56e4aba0684bab819892a0157843/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03abb1bd70ac56e4aba0684bab819892a0157843/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=03abb1bd70ac56e4aba0684bab819892a0157843", "patch": "@@ -1,436 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io::Write;\n-\n-use super::external_data::*;\n-use super::dump::Dump;\n-\n-use rls_data::{SpanData, CratePreludeData};\n-\n-pub struct CsvDumper<'b, W: 'b> {\n-    output: &'b mut W\n-}\n-\n-impl<'b, W: Write> CsvDumper<'b, W> {\n-    pub fn new(writer: &'b mut W) -> CsvDumper<'b, W> {\n-        CsvDumper { output: writer }\n-    }\n-\n-    fn record(&mut self, kind: &str, span: SpanData, values: String) {\n-        let span_str = span_extent_str(span);\n-        if let Err(_) = write!(self.output, \"{},{}{}\\n\", kind, span_str, values) {\n-            error!(\"Error writing output\");\n-        }\n-    }\n-\n-    fn record_raw(&mut self, info: &str) {\n-        if let Err(_) = write!(self.output, \"{}\", info) {\n-            error!(\"Error writing output '{}'\", info);\n-        }\n-    }\n-}\n-\n-impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n-    fn crate_prelude(&mut self, data: CratePreludeData) {\n-        let values = make_values_str(&[\n-            (\"name\", &data.crate_name),\n-            (\"crate_root\", &data.crate_root)\n-        ]);\n-\n-        self.record(\"crate\", data.span, values);\n-\n-        for c in data.external_crates {\n-            let num = c.num.to_string();\n-            let values = make_values_str(&[\n-                (\"name\", &c.name),\n-                (\"crate\", &num),\n-                (\"file_name\", &c.file_name)\n-            ]);\n-\n-            self.record_raw(&format!(\"external_crate{}\\n\", values));\n-        }\n-\n-        self.record_raw(\"end_external_crates\\n\");\n-    }\n-\n-    fn enum_data(&mut self, data: EnumData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"enum\", data.span, values);\n-    }\n-\n-    fn extern_crate(&mut self, data: ExternCrateData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let crate_num = data.crate_num.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"location\", &data.location),\n-            (\"crate\", &crate_num),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"extern_crate\", data.span, values);\n-    }\n-\n-    fn impl_data(&mut self, data: ImplData) {\n-        let self_ref = data.self_ref.unwrap_or(null_def_id());\n-        let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let ref_id = self_ref.index.as_usize().to_string();\n-        let ref_id_crate = self_ref.krate.to_string();\n-        let trait_id = trait_ref.index.as_usize().to_string();\n-        let trait_id_crate = trait_ref.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_id_crate),\n-            (\"traitid\", &trait_id),\n-            (\"traitidcrate\", &trait_id_crate),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"impl\", data.span, values);\n-    }\n-\n-    fn inheritance(&mut self, data: InheritanceData) {\n-       let base_id = data.base_id.index.as_usize().to_string();\n-       let base_crate = data.base_id.krate.to_string();\n-       let deriv_id = data.deriv_id.index.as_u32().to_string();\n-       let deriv_crate = data.deriv_id.krate.to_string();\n-       let values = make_values_str(&[\n-           (\"base\", &base_id),\n-           (\"basecrate\", &base_crate),\n-           (\"derived\", &deriv_id),\n-           (\"derivedcrate\", &deriv_crate)\n-       ]);\n-\n-       self.record(\"inheritance\", data.span, values);\n-    }\n-\n-    fn function(&mut self, data: FunctionData) {\n-        let (decl_id, decl_crate) = match data.declaration {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (String::new(), String::new())\n-        };\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"declid\", &decl_id),\n-            (\"declidcrate\", &decl_crate),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"function\", data.span, values);\n-    }\n-\n-    fn function_ref(&mut self, data: FunctionRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", \"\"),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"fn_ref\", data.span, values);\n-    }\n-\n-    fn function_call(&mut self, data: FunctionCallData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let qualname = String::new();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"fn_call\", data.span, values);\n-    }\n-\n-    fn method(&mut self, data: MethodData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"method_decl\", data.span, values);\n-    }\n-\n-    fn method_call(&mut self, data: MethodCallData) {\n-        let (dcn, dck) = match data.decl_id {\n-            Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n-            None => (String::new(), String::new()),\n-        };\n-\n-        let ref_id = data.ref_id.unwrap_or(null_def_id());\n-\n-        let def_id = ref_id.index.as_usize().to_string();\n-        let def_crate = ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &def_id),\n-            (\"refidcrate\", &def_crate),\n-            (\"declid\", &dcn),\n-            (\"declidcrate\", &dck),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"method_call\", data.span, values);\n-    }\n-\n-    fn macro_data(&mut self, data: MacroData) {\n-        let values = make_values_str(&[\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname)\n-        ]);\n-\n-        self.record(\"macro\", data.span, values);\n-    }\n-\n-    fn macro_use(&mut self, data: MacroUseData) {\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"callee_name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"macro_use\", data.span, values);\n-    }\n-\n-    fn mod_data(&mut self, data: ModData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"def_file\", &data.filename)\n-        ]);\n-\n-        self.record(\"module\", data.span, values);\n-    }\n-\n-    fn mod_ref(&mut self, data: ModRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n-\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"mod_ref\", data.span, values);\n-    }\n-\n-    fn struct_data(&mut self, data: StructData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let ctor_id = data.ctor_id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"ctor_id\", &ctor_id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"struct\", data.span, values);\n-    }\n-\n-    fn struct_variant(&mut self, data: StructVariantData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"ctor_id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"type\", &data.type_value),\n-            (\"value\", &data.value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variant_struct\", data.span, values);\n-    }\n-\n-    fn trait_data(&mut self, data: TraitData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"trait\", data.span, values);\n-    }\n-\n-    fn tuple_variant(&mut self, data: TupleVariantData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"type\", &data.type_value),\n-            (\"value\", &data.value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variant\", data.span, values);\n-    }\n-\n-    fn type_ref(&mut self, data: TypeRefData) {\n-        let (ref_id, ref_crate) = match data.ref_id {\n-            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n-            None => (0.to_string(), 0.to_string())\n-        };\n-\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", &data.qualname),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"type_ref\", data.span, values);\n-    }\n-\n-    fn typedef(&mut self, data: TypeDefData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"qualname\", &data.qualname),\n-            (\"value\", &data.value)\n-        ]);\n-\n-        self.record(\"typedef\", data.span, values);\n-    }\n-\n-    fn use_data(&mut self, data: UseData) {\n-        let mod_id = data.mod_id.unwrap_or(null_def_id());\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let ref_id = mod_id.index.as_usize().to_string();\n-        let ref_crate = mod_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"name\", &data.name),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"use_alias\", data.span, values);\n-    }\n-\n-    fn use_glob(&mut self, data: UseGlobData) {\n-        let names = data.names.join(\", \");\n-\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"value\", &names),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"use_glob\", data.span, values);\n-    }\n-\n-    fn variable(&mut self, data: VariableData) {\n-        let id = data.id.index.as_u32().to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"id\", &id),\n-            (\"name\", &data.name),\n-            (\"qualname\", &data.qualname),\n-            (\"value\", &data.value),\n-            (\"type\", &data.type_value),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"variable\", data.span, values);\n-    }\n-\n-    fn variable_ref(&mut self, data: VariableRefData) {\n-        let ref_id = data.ref_id.index.as_usize().to_string();\n-        let ref_crate = data.ref_id.krate.to_string();\n-        let scope = data.scope.index.as_u32().to_string();\n-        let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"refidcrate\", &ref_crate),\n-            (\"qualname\", \"\"),\n-            (\"scopeid\", &scope)\n-        ]);\n-\n-        self.record(\"var_ref\", data.span, values)\n-    }\n-}\n-\n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace(\"\\\"\", \"\\\"\\\"\")\n-}\n-\n-fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n-    let pairs = pairs.into_iter().map(|&(f, v)| {\n-        // Never take more than 1020 chars\n-        if v.len() > 1020 {\n-            (f, &v[..1020])\n-        } else {\n-            (f, v)\n-        }\n-    });\n-\n-    let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n-    strs.fold(String::new(), |mut s, ss| {\n-        s.push_str(&ss);\n-        s\n-    })\n-}\n-\n-fn span_extent_str(span: SpanData) -> String {\n-    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n-             file_line_end,{},file_col_end,{},byte_end,{}\",\n-             span.file_name.to_str().unwrap(), span.line_start.0, span.column_start.0,\n-             span.byte_start, span.line_end.0, span.column_end.0, span.byte_end)\n-}"}, {"sha": "be879a01fb8fb97b93137798beb5cb386df32660", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "patch": "@@ -35,7 +35,6 @@ extern crate rls_data;\n extern crate rls_span;\n \n \n-mod csv_dumper;\n mod json_api_dumper;\n mod json_dumper;\n mod data;\n@@ -68,7 +67,6 @@ use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n use syntax_pos::*;\n \n-pub use self::csv_dumper::CsvDumper;\n pub use self::json_api_dumper::JsonApiDumper;\n pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n@@ -866,17 +864,13 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n \n #[derive(Clone, Copy, Debug, RustcEncodable)]\n pub enum Format {\n-    Csv,\n     Json,\n     JsonApi,\n }\n \n impl Format {\n     fn extension(&self) -> &'static str {\n-        match *self {\n-            Format::Csv => \".csv\",\n-            Format::Json | Format::JsonApi => \".json\",\n-        }\n+        \".json\"\n     }\n }\n \n@@ -959,7 +953,6 @@ impl<'a> SaveHandler for DumpHandler<'a> {\n         let output = &mut self.output_file(&save_ctxt.tcx.sess);\n \n         match self.format {\n-            Format::Csv => dump!(CsvDumper::new(output)),\n             Format::Json => dump!(JsonDumper::new(output)),\n             Format::JsonApi => dump!(JsonApiDumper::new(output)),\n         }"}, {"sha": "9ebc40d4013cd9b60db7802d8475bfa3439467fc", "filename": "src/test/run-make/save-analysis/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9a471606c05621db6ab85f6bb645e52e0f9ad5eb/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=9a471606c05621db6ab85f6bb645e52e0f9ad5eb", "patch": "@@ -3,6 +3,5 @@ all: code\n krate2: krate2.rs\n \t$(RUSTC) $<\n code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis-csv\n \t$(RUSTC) foo.rs -Zsave-analysis\n \t$(RUSTC) foo.rs -Zsave-analysis-api"}]}