{"sha": "8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTMwZGIyYzVlNjNkYTJmZWQzZWMxYWMzYmJhMmZhMGZiNDM2M2M=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-25T15:52:03Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:36:43Z"}, "message": "Generalized base:codegen_crate", "tree": {"sha": "f60326e943c6dd42e3bc9deb7778b197936f9473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60326e943c6dd42e3bc9deb7778b197936f9473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "html_url": "https://github.com/rust-lang/rust/commit/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97825a36bec3bdad71669834178a85d7fdff43bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/97825a36bec3bdad71669834178a85d7fdff43bc", "html_url": "https://github.com/rust-lang/rust/commit/97825a36bec3bdad71669834178a85d7fdff43bc"}], "stats": {"total": 226, "additions": 160, "deletions": 66}, "files": [{"sha": "5eb2e28a2a86fbef6403cee079fdbe75ed02e72c", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -13,8 +13,7 @@ use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n use back::write::{self, DiagnosticHandlers, pre_lto_bitcode_filename};\n use errors::{FatalError, Handler};\n use llvm::archive_ro::ArchiveRO;\n-use llvm::{True, False};\n-use llvm;\n+use llvm::{self, True, False};\n use memmap;\n use rustc::dep_graph::WorkProduct;\n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n@@ -49,7 +48,7 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n \n pub(crate) enum LtoModuleCodegen {\n     Fat {\n-        module: Option<ModuleCodegen>,\n+        module: Option<ModuleCodegen<ModuleLlvm>>,\n         _serialized_bitcode: Vec<SerializedModule>,\n     },\n \n@@ -73,7 +72,7 @@ impl LtoModuleCodegen {\n     pub(crate) unsafe fn optimize(&mut self,\n                                   cgcx: &CodegenContext,\n                                   timeline: &mut Timeline)\n-        -> Result<ModuleCodegen, FatalError>\n+        -> Result<ModuleCodegen<ModuleLlvm>, FatalError>\n     {\n         match *self {\n             LtoModuleCodegen::Fat { ref mut module, .. } => {\n@@ -108,7 +107,7 @@ impl LtoModuleCodegen {\n /// the need optimization and another for modules that can simply be copied over\n /// from the incr. comp. cache.\n pub(crate) fn run(cgcx: &CodegenContext,\n-                  modules: Vec<ModuleCodegen>,\n+                  modules: Vec<ModuleCodegen<ModuleLlvm>>,\n                   cached_modules: Vec<(SerializedModule, WorkProduct)>,\n                   timeline: &mut Timeline)\n     -> Result<(Vec<LtoModuleCodegen>, Vec<WorkProduct>), FatalError>\n@@ -232,7 +231,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n \n fn fat_lto(cgcx: &CodegenContext,\n            diag_handler: &Handler,\n-           mut modules: Vec<ModuleCodegen>,\n+           mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n            mut serialized_modules: Vec<(SerializedModule, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n@@ -388,7 +387,7 @@ impl Drop for Linker<'a> {\n /// they all go out of scope.\n fn thin_lto(cgcx: &CodegenContext,\n             diag_handler: &Handler,\n-            modules: Vec<ModuleCodegen>,\n+            modules: Vec<ModuleCodegen<ModuleLlvm>>,\n             serialized_modules: Vec<(SerializedModule, CString)>,\n             cached_modules: Vec<(SerializedModule, WorkProduct)>,\n             symbol_white_list: &[*const libc::c_char],\n@@ -740,7 +739,7 @@ impl ThinModule {\n     }\n \n     unsafe fn optimize(&mut self, cgcx: &CodegenContext, timeline: &mut Timeline)\n-        -> Result<ModuleCodegen, FatalError>\n+        -> Result<ModuleCodegen<ModuleLlvm>, FatalError>\n     {\n         let diag_handler = cgcx.create_diag_handler();\n         let tm = (cgcx.tm_factory)().map_err(|e| {"}, {"sha": "72820f967afa338f13d75b3c6897ad40f3b9506d", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -26,7 +26,7 @@ use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use llvm_util;\n-use {CodegenResults, ModuleCodegen, CompiledModule, ModuleKind, // ModuleLlvm,\n+use {CodegenResults, ModuleCodegen, CompiledModule, ModuleKind, ModuleLlvm,\n      CachedModuleCodegen};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -408,7 +408,7 @@ impl CodegenContext {\n         }\n     }\n \n-    pub(crate) fn save_temp_bitcode(&self, module: &ModuleCodegen, name: &str) {\n+    pub(crate) fn save_temp_bitcode(&self, module: &ModuleCodegen<ModuleLlvm>, name: &str) {\n         if !self.save_temps {\n             return\n         }\n@@ -515,7 +515,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n // Unsafe due to LLVM calls.\n unsafe fn optimize(cgcx: &CodegenContext,\n                    diag_handler: &Handler,\n-                   module: &ModuleCodegen,\n+                   module: &ModuleCodegen<ModuleLlvm>,\n                    config: &ModuleConfig,\n                    timeline: &mut Timeline)\n     -> Result<(), FatalError>\n@@ -646,7 +646,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n }\n \n fn generate_lto_work(cgcx: &CodegenContext,\n-                     modules: Vec<ModuleCodegen>,\n+                     modules: Vec<ModuleCodegen<ModuleLlvm>>,\n                      import_only_modules: Vec<(SerializedModule, WorkProduct)>)\n     -> Vec<(WorkItem, u64)>\n {\n@@ -675,7 +675,7 @@ fn generate_lto_work(cgcx: &CodegenContext,\n \n unsafe fn codegen(cgcx: &CodegenContext,\n                   diag_handler: &Handler,\n-                  module: ModuleCodegen,\n+                  module: ModuleCodegen<ModuleLlvm>,\n                   config: &ModuleConfig,\n                   timeline: &mut Timeline)\n     -> Result<CompiledModule, FatalError>\n@@ -1284,7 +1284,7 @@ pub(crate) fn dump_incremental_data(_codegen_results: &CodegenResults) {\n \n enum WorkItem {\n     /// Optimize a newly codegened, totally unoptimized module.\n-    Optimize(ModuleCodegen),\n+    Optimize(ModuleCodegen<ModuleLlvm>),\n     /// Copy the post-LTO artifacts from the incremental cache to the output\n     /// directory.\n     CopyPostLtoArtifacts(CachedModuleCodegen),\n@@ -1312,7 +1312,7 @@ impl WorkItem {\n \n enum WorkItemResult {\n     Compiled(CompiledModule),\n-    NeedsLTO(ModuleCodegen),\n+    NeedsLTO(ModuleCodegen<ModuleLlvm>),\n }\n \n fn execute_work_item(cgcx: &CodegenContext,\n@@ -1336,7 +1336,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n }\n \n fn execute_optimize_work_item(cgcx: &CodegenContext,\n-                              module: ModuleCodegen,\n+                              module: ModuleCodegen<ModuleLlvm>,\n                               module_config: &ModuleConfig,\n                               timeline: &mut Timeline)\n     -> Result<WorkItemResult, FatalError>\n@@ -1480,7 +1480,7 @@ fn execute_lto_work_item(cgcx: &CodegenContext,\n enum Message {\n     Token(io::Result<Acquired>),\n     NeedsLTO {\n-        result: ModuleCodegen,\n+        result: ModuleCodegen<ModuleLlvm>,\n         worker_id: usize,\n     },\n     Done {\n@@ -2445,7 +2445,7 @@ impl OngoingCodegen {\n \n     pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n                                                       tcx: TyCtxt,\n-                                                      module: ModuleCodegen) {\n+                                                      module: ModuleCodegen<ModuleLlvm>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n \n@@ -2497,7 +2497,7 @@ impl OngoingCodegen {\n // }\n \n pub(crate) fn submit_codegened_module_to_llvm(tcx: TyCtxt,\n-                                              module: ModuleCodegen,\n+                                              module: ModuleCodegen<ModuleLlvm>,\n                                               cost: u64) {\n     let llvm_work_item = WorkItem::Optimize(module);\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone {"}, {"sha": "5fd413b4c7babf1d33bb5ec4fa3376c696e97393", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -29,7 +29,7 @@ use super::ModuleKind;\n use super::CachedModuleCodegen;\n \n use abi;\n-use back::write::{self, OngoingCodegen};\n+use back::write;\n use llvm;\n use metadata;\n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n@@ -48,7 +48,6 @@ use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, DebugInfo, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_incremental;\n-use allocator;\n use mir::place::PlaceRef;\n use builder::{Builder, MemFlags};\n use callee;\n@@ -584,9 +583,10 @@ fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                            llvm_module: &ModuleLlvm)\n-                            -> EncodedMetadata {\n+pub(crate) fn write_metadata<'a, 'gcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    llvm_module: &ModuleLlvm\n+) -> EncodedMetadata {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n@@ -713,10 +713,12 @@ fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               rx: mpsc::Receiver<Box<dyn Any + Send>>)\n-                               -> OngoingCodegen\n-{\n+pub fn codegen_crate<'a, 'tcx, B: BackendMethods>(\n+    backend: B,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>\n+) -> B::OngoingCodegen {\n+\n     check_for_rustc_errors_attr(tcx);\n \n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n@@ -728,9 +730,9 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                             &[\"crate\"],\n                                                             Some(\"metadata\")).as_str()\n                                                                              .to_string();\n-    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, &metadata_cgu_name);\n+    let metadata_llvm_module = backend.new_metadata(tcx.sess, &metadata_cgu_name);\n     let metadata = time(tcx.sess, \"write metadata\", || {\n-        write_metadata(tcx, &metadata_llvm_module)\n+        backend.write_metadata(tcx, &metadata_llvm_module)\n     });\n     tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n \n@@ -749,19 +751,19 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen ||\n        !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = write::start_async_codegen(\n+        let ongoing_codegen = backend.start_async_codegen(\n             tcx,\n             time_graph,\n             metadata,\n             rx,\n             1);\n \n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n-        ongoing_codegen.codegen_finished(tcx);\n+        backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, metadata_module);\n+        backend.codegen_finished(&ongoing_codegen, tcx);\n \n         assert_and_save_dep_graph(tcx);\n \n-        ongoing_codegen.check_for_errors(tcx.sess);\n+        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n \n         return ongoing_codegen;\n     }\n@@ -782,13 +784,13 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let ongoing_codegen = write::start_async_codegen(\n+    let ongoing_codegen = backend.start_async_codegen(\n         tcx,\n         time_graph.clone(),\n         metadata,\n         rx,\n         codegen_units.len());\n-    let ongoing_codegen = AbortCodegenOnDrop(Some(ongoing_codegen));\n+    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary.\n     //\n@@ -811,11 +813,9 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                        &[\"crate\"],\n                                                        Some(\"allocator\")).as_str()\n                                                                          .to_string();\n-        let modules = ModuleLlvm::new(tcx.sess, &llmod_id);\n+        let modules = backend.new_metadata(tcx.sess, &llmod_id);\n         time(tcx.sess, \"write allocator module\", || {\n-            unsafe {\n-                allocator::codegen(tcx, &modules, kind)\n-            }\n+            backend.codegen_allocator(tcx, &modules, kind)\n         });\n \n         Some(ModuleCodegen {\n@@ -828,10 +828,10 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     if let Some(allocator_module) = allocator_module {\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n+        backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, allocator_module);\n     }\n \n-    ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+    backend.submit_pre_codegened_module_to_llvm(&ongoing_codegen, tcx, metadata_module);\n \n     // We sort the codegen units by size. This way we can schedule work for LLVM\n     // a bit more efficiently.\n@@ -845,8 +845,8 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut all_stats = Stats::default();\n \n     for cgu in codegen_units.into_iter() {\n-        ongoing_codegen.wait_for_signal_to_codegen_item();\n-        ongoing_codegen.check_for_errors(tcx.sess);\n+        backend.wait_for_signal_to_codegen_item(&ongoing_codegen);\n+        backend.check_for_errors(&ongoing_codegen, tcx.sess);\n \n         let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n@@ -881,7 +881,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n     }\n \n-    ongoing_codegen.codegen_finished(tcx);\n+    backend.codegen_finished(&ongoing_codegen, tcx);\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n@@ -915,7 +915,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    ongoing_codegen.check_for_errors(tcx.sess);\n+    backend.check_for_errors(&ongoing_codegen, tcx.sess);\n \n     assert_and_save_dep_graph(tcx);\n     ongoing_codegen.into_inner()\n@@ -938,32 +938,32 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// If you see this comment in the code, then it means that this workaround\n /// worked! We may yet one day track down the mysterious cause of that\n /// segfault...\n-struct AbortCodegenOnDrop(Option<OngoingCodegen>);\n+struct AbortCodegenOnDrop<B: BackendMethods>(Option<B::OngoingCodegen>);\n \n-impl AbortCodegenOnDrop {\n-    fn into_inner(mut self) -> OngoingCodegen {\n+impl<B: BackendMethods> AbortCodegenOnDrop<B> {\n+    fn into_inner(mut self) -> B::OngoingCodegen {\n         self.0.take().unwrap()\n     }\n }\n \n-impl Deref for AbortCodegenOnDrop {\n-    type Target = OngoingCodegen;\n+impl<B: BackendMethods> Deref for AbortCodegenOnDrop<B> {\n+    type Target = B::OngoingCodegen;\n \n-    fn deref(&self) -> &OngoingCodegen {\n+    fn deref(&self) -> &B::OngoingCodegen {\n         self.0.as_ref().unwrap()\n     }\n }\n \n-impl DerefMut for AbortCodegenOnDrop {\n-    fn deref_mut(&mut self) -> &mut OngoingCodegen {\n+impl<B: BackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n+    fn deref_mut(&mut self) -> &mut B::OngoingCodegen {\n         self.0.as_mut().unwrap()\n     }\n }\n \n-impl Drop for AbortCodegenOnDrop {\n+impl<B: BackendMethods> Drop for AbortCodegenOnDrop<B> {\n     fn drop(&mut self) {\n         if let Some(codegen) = self.0.take() {\n-            codegen.codegen_aborted();\n+            B::codegen_aborted(codegen);\n         }\n     }\n }\n@@ -1092,7 +1092,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     fn module_codegen<'a, 'tcx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString)\n-        -> (Stats, ModuleCodegen)\n+        -> (Stats, ModuleCodegen<ModuleLlvm>)\n     {\n         let cgu = tcx.codegen_unit(cgu_name);\n \n@@ -1226,9 +1226,9 @@ pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n mod temp_stable_hash_impls {\n     use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n                                                HashStable};\n-    use ModuleCodegen;\n+    use {ModuleCodegen, ModuleLlvm};\n \n-    impl<HCX> HashStable<HCX> for ModuleCodegen {\n+    impl<HCX> HashStable<HCX> for ModuleCodegen<ModuleLlvm> {\n         fn hash_stable<W: StableHasherResult>(&self,\n                                               _: &mut HCX,\n                                               _: &mut StableHasher<W>) {"}, {"sha": "a5df7e5af6ff5a04980143690e08f592a5d0d527", "filename": "src/librustc_codegen_llvm/interfaces/backend.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -12,6 +12,14 @@ use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n use rustc::ty::Ty;\n \n use super::CodegenObject;\n+use rustc::middle::allocator::AllocatorKind;\n+use rustc::middle::cstore::EncodedMetadata;\n+use rustc::session::Session;\n+use rustc::ty::TyCtxt;\n+use std::any::Any;\n+use std::sync::mpsc::Receiver;\n+use time_graph::TimeGraph;\n+use ModuleCodegen;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -30,3 +38,35 @@ pub trait Backend<'tcx>:\n impl<'tcx, T> Backend<'tcx> for T where\n     Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n {}\n+\n+pub trait BackendMethods {\n+    type Metadata;\n+    type OngoingCodegen;\n+\n+    fn new_metadata(&self, sess: &Session, mod_name: &str) -> Self::Metadata;\n+    fn write_metadata<'a, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+        metadata: &Self::Metadata,\n+    ) -> EncodedMetadata;\n+    fn codegen_allocator(&self, tcx: TyCtxt, mods: &Self::Metadata, kind: AllocatorKind);\n+\n+    fn start_async_codegen(\n+        &self,\n+        tcx: TyCtxt,\n+        time_graph: Option<TimeGraph>,\n+        metadata: EncodedMetadata,\n+        coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+        total_cgus: usize,\n+    ) -> Self::OngoingCodegen;\n+    fn submit_pre_codegened_module_to_llvm(\n+        &self,\n+        codegen: &Self::OngoingCodegen,\n+        tcx: TyCtxt,\n+        module: ModuleCodegen<Self::Metadata>,\n+    );\n+    fn codegen_aborted(codegen: Self::OngoingCodegen);\n+    fn codegen_finished(&self, codegen: &Self::OngoingCodegen, tcx: TyCtxt);\n+    fn check_for_errors(&self, codegen: &Self::OngoingCodegen, sess: &Session);\n+    fn wait_for_signal_to_codegen_item(&self, codegen: &Self::OngoingCodegen);\n+}"}, {"sha": "e0ce05d0a8479f43dbb91eeb998be59c14f06c44", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -22,7 +22,7 @@ mod type_;\n \n pub use self::abi::{AbiBuilderMethods, AbiMethods};\n pub use self::asm::{AsmBuilderMethods, AsmMethods};\n-pub use self::backend::{Backend, BackendTypes};\n+pub use self::backend::{Backend, BackendMethods, BackendTypes};\n pub use self::builder::BuilderMethods;\n pub use self::consts::ConstMethods;\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};"}, {"sha": "d1be81f1224846bbeba58723829878eb6018cda7", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8d530db2c5e63da2fed3ec1ac3bba2fa0fb4363c", "patch": "@@ -68,6 +68,10 @@ extern crate tempfile;\n extern crate memmap;\n \n use back::bytecode::RLIB_BYTECODE_EXTENSION;\n+use interfaces::*;\n+use time_graph::TimeGraph;\n+use std::sync::mpsc::Receiver;\n+use back::write::{self, OngoingCodegen};\n \n pub use llvm_util::target_features;\n use std::any::Any;\n@@ -76,7 +80,8 @@ use rustc_data_structures::sync::Lrc;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::CrateNum;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::allocator::AllocatorKind;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n use rustc::middle::lang_items::LangItem;\n use rustc::session::{Session, CompileIncomplete};\n@@ -133,6 +138,56 @@ mod value;\n \n pub struct LlvmCodegenBackend(());\n \n+impl BackendMethods for LlvmCodegenBackend {\n+    type Metadata = ModuleLlvm;\n+    type OngoingCodegen = OngoingCodegen;\n+\n+    fn new_metadata(&self, sess: &Session, mod_name: &str) -> ModuleLlvm {\n+        ModuleLlvm::new(sess, mod_name)\n+    }\n+    fn write_metadata<'a, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+        metadata: &ModuleLlvm\n+    ) -> EncodedMetadata {\n+        base::write_metadata(tcx, metadata)\n+    }\n+    fn start_async_codegen(\n+        &self,\n+        tcx: TyCtxt,\n+        time_graph: Option<TimeGraph>,\n+        metadata: EncodedMetadata,\n+        coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+        total_cgus: usize\n+    ) -> OngoingCodegen {\n+        write::start_async_codegen(tcx, time_graph, metadata, coordinator_receive, total_cgus)\n+    }\n+    fn submit_pre_codegened_module_to_llvm(\n+        &self,\n+        codegen: &OngoingCodegen,\n+        tcx: TyCtxt,\n+        module: ModuleCodegen<ModuleLlvm>\n+    ) {\n+        codegen.submit_pre_codegened_module_to_llvm(tcx, module)\n+    }\n+    fn codegen_aborted(codegen: OngoingCodegen) {\n+        codegen.codegen_aborted();\n+    }\n+    fn codegen_finished(&self, codegen: &OngoingCodegen, tcx: TyCtxt) {\n+        codegen.codegen_finished(tcx)\n+    }\n+    fn check_for_errors(&self, codegen: &OngoingCodegen, sess: &Session) {\n+        codegen.check_for_errors(sess)\n+    }\n+    fn codegen_allocator(&self, tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+        unsafe { allocator::codegen(tcx, mods, kind) }\n+    }\n+    fn wait_for_signal_to_codegen_item(&self, codegen: &OngoingCodegen) {\n+        codegen.wait_for_signal_to_codegen_item()\n+    }\n+}\n+\n+\n impl !Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis\n impl !Sync for LlvmCodegenBackend {}\n \n@@ -212,7 +267,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any> {\n-        box base::codegen_crate(tcx, rx)\n+        box base::codegen_crate(LlvmCodegenBackend(()), tcx, rx)\n     }\n \n     fn join_codegen_and_link(\n@@ -265,15 +320,15 @@ pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n     LlvmCodegenBackend::new()\n }\n \n-struct ModuleCodegen {\n+pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n     /// We currently generate these names via CodegenUnit::build_cgu_name().\n     name: String,\n-    module_llvm: ModuleLlvm,\n+    module_llvm: M,\n     kind: ModuleKind,\n }\n \n@@ -282,7 +337,7 @@ struct CachedModuleCodegen {\n     source: WorkProduct,\n }\n \n-impl ModuleCodegen {\n+impl ModuleCodegen<ModuleLlvm> {\n     fn into_compiled_module(self,\n                             emit_obj: bool,\n                             emit_bc: bool,\n@@ -315,7 +370,7 @@ impl ModuleCodegen {\n     }\n }\n \n-struct ModuleLlvm {\n+pub struct ModuleLlvm {\n     llcx: &'static mut llvm::Context,\n     llmod_raw: *const llvm::Module,\n     tm: &'static mut llvm::TargetMachine,"}]}