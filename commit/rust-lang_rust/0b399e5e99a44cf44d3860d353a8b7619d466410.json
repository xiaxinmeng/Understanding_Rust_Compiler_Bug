{"sha": "0b399e5e99a44cf44d3860d353a8b7619d466410", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMzk5ZTVlOTlhNDRjZjQ0ZDM4NjBkMzUzYThiNzYxOWQ0NjY0MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-28T05:32:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-28T05:32:57Z"}, "message": "Auto merge of #37676 - eddyb:lazy-7, r=nikomatsakis\n\n[7/n] rustc: desugar UFCS in HIR and don't use DefMap for associated resolutions.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/37412) | [next](https://github.com/rust-lang/rust/pull/37688)) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nPreviously, a path like `T::Assoc::method`, while equivalent to `<<T>::Assoc>::method`, wasn't desugared in any way at the HIR level and everything inspecting it had to either deal with knowing only `T` (before typeck) or knowing only the definition of `method` (after typeck).\nSuch a path also had only one `NodeId` and associated resolution during typeck modified `DefMap`, in a way that would be hard for incremental recompilation to track, and inconvenient for partial type conversions from HIR to `Ty`, which are required to break faux-cycles in on-demand type collection.\n\nThe desugarings performed by this PR are as follows:\n* `use a::{b,c};` is flattened to `use a as _; use a::b; use a::c;`\n  * as resolution is complete, `use a as _;` doesn't do anything, except get checked for stability\n* `Vec::new` (an expression) becomes `Vec<..>::new<..>`, to distinguish it from `<Vec>::new<..>`\n  * the \"infer all parameters\" `<..>` form is internal and not even pretty-printed\n  * used when there are no type parameters at all, in an expression or pattern path segment\n* `T::A::B` becomes `<<T>::A>::B` in a type, and `<<T<..>>::A<..>>::B<..>` in an expression/pattern\n  * one additional `hir::Ty` node is created for each prefix, starting with the fully-resolved type (`T`) and extending it with each segment (e.g. `<T>::A`)\n* fully-resolved paths contain their `Def` in HIR, getting rid of the `DefMap` and absolving incremental recompilation of needing to manually look up nodes to handle that side information\n\nNot keeping the `DefMap` around meant that associated resolutions had to be stored somewhere else:\n* expressions and patterns use a new `NodeId -> Def` map in `ty::Tables`\n  * compatible with the future per-body (constant / `fn` / closure) `Tables`\n* types are accessible via `Ty` and the usual per-item generics / predicates / type\n  * `rustdoc` and `save-analysis` are the only situations which insist on mapping syntactical types to semantical ones, or at least understand the resolution of associated types, therefore the type conversion cache, i.e. a `NodeId -> Ty` map, is exposed by typeck for this purpose\n  * stability had to be split into a pass that runs on HIR and checks the results of name resolution, and impromptu checks triggered by `typeck` for associated paths, methods, fields, etc.\n  * privacy using semantic types results in accurate reachability for `impl Trait`, which fixes #35870, and thorough introspection of associated types, which may allow relaxing private-in-public checking on bounds, while keeping the intended ban on projections with private type parameters\n\ncc @petrochenkov", "tree": {"sha": "05970fb630a5d97e49e9a6f4230c70696cff2a4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05970fb630a5d97e49e9a6f4230c70696cff2a4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b399e5e99a44cf44d3860d353a8b7619d466410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b399e5e99a44cf44d3860d353a8b7619d466410", "html_url": "https://github.com/rust-lang/rust/commit/0b399e5e99a44cf44d3860d353a8b7619d466410", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b399e5e99a44cf44d3860d353a8b7619d466410/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7ddb8946bf041d89ba109ec8dd754492de78606", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ddb8946bf041d89ba109ec8dd754492de78606", "html_url": "https://github.com/rust-lang/rust/commit/c7ddb8946bf041d89ba109ec8dd754492de78606"}, {"sha": "372c6df564616dd461b82def5d75428940ca04ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/372c6df564616dd461b82def5d75428940ca04ae", "html_url": "https://github.com/rust-lang/rust/commit/372c6df564616dd461b82def5d75428940ca04ae"}], "stats": {"total": 7254, "additions": 4149, "deletions": 3105}, "files": [{"sha": "6642da858e551e2be5b4d6e552e3d4df58c1dfdd", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -37,8 +37,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n {error_deriving}\n struct Error;\n {code}\n@@ -106,7 +104,6 @@ def write_file(name, string):\n ALL = STRUCT | ENUM\n \n traits = {\n-    'Zero': (STRUCT, [], 1),\n     'Default': (STRUCT, [], 1),\n     'FromPrimitive': (0, [], 0), # only works for C-like enums\n \n@@ -116,7 +113,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 8),\n+                              ('PartialOrd', ['PartialEq'], 9),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "f21d98a0fc7f97a5eedbb2f9fc3d6b353b375517", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,8 +10,6 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n-use hir::def::Def;\n-use hir::pat_util;\n use ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::ptr::P;\n@@ -100,7 +98,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Binding(.., None) |\n-            PatKind::Path(..) |\n+            PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild => {\n@@ -284,15 +282,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprBreak(label, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -361,7 +359,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprClosure(..) |\n             hir::ExprLit(..) |\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }\n@@ -457,7 +455,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(&pat);\n+                    let this_has_bindings = pat.contains_bindings_or_wild();\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only\n@@ -570,23 +568,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<ast::Name>) -> LoopScope {\n-        if label.is_none() {\n-            return *self.loop_scopes.last().unwrap();\n-        }\n-\n-        match self.tcx.expect_def(expr.id) {\n-            Def::Label(loop_id) => {\n+                  label: Option<hir::Label>) -> LoopScope {\n+        match label {\n+            None => *self.loop_scopes.last().unwrap(),\n+            Some(label) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n+                    if l.loop_id == label.loop_id {\n                         return *l;\n                     }\n                 }\n-                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n-            }\n-\n-            r => {\n-                span_bug!(expr.span, \"bad entry `{:?}` in def_map for label\", r);\n+                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n             }\n         }\n     }"}, {"sha": "397d61d5372e025a80bafdde754dff7f1e36a5b1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -90,7 +90,7 @@ pub enum DepNode<D: Clone + Debug> {\n     RvalueCheck(D),\n     Reachability,\n     DeadCheck,\n-    StabilityCheck,\n+    StabilityCheck(D),\n     LateLintCheck,\n     TransCrate,\n     TransCrateItem(D),\n@@ -189,7 +189,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             Privacy => Some(Privacy),\n             Reachability => Some(Reachability),\n             DeadCheck => Some(DeadCheck),\n-            StabilityCheck => Some(StabilityCheck),\n             LateLintCheck => Some(LateLintCheck),\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n@@ -217,6 +216,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             Mir(ref d) => op(d).map(Mir),\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n+            StabilityCheck(ref d) => op(d).map(StabilityCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),"}, {"sha": "b6fce2d6ca0be1d6474c92e0a36ab43b4e04df75", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -83,14 +83,6 @@ impl PathResolution {\n         PathResolution { base_def: def, depth: 0 }\n     }\n \n-    /// Get the definition, if fully resolved, otherwise panic.\n-    pub fn full_def(&self) -> Def {\n-        if self.depth != 0 {\n-            bug!(\"path not fully resolved: {:?}\", self);\n-        }\n-        self.base_def\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         if self.depth != 0 {\n             \"associated item\""}, {"sha": "94da10d33f8187a11c0dba5f36d22b702420dc74", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::def::Def;\n use hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n@@ -155,6 +156,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_id(&mut self, _node_id: NodeId) {\n         // Nothing to do.\n     }\n+    fn visit_def_mention(&mut self, _def: Def) {\n+        // Nothing to do.\n+    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -244,12 +248,12 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n+    fn visit_qpath(&mut self, qpath: &'v QPath, id: NodeId, span: Span) {\n+        walk_qpath(self, qpath, id, span)\n+    }\n     fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n-        walk_path_list_item(self, prefix, item)\n-    }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n@@ -349,23 +353,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n-        ItemUse(ref vp) => {\n+        ItemUse(ref path, _) => {\n             visitor.visit_id(item.id);\n-            match vp.node {\n-                ViewPathSimple(name, ref path) => {\n-                    visitor.visit_name(vp.span, name);\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathGlob(ref path) => {\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathList(ref prefix, ref list) => {\n-                    visitor.visit_path(prefix, item.id);\n-                    for item in list {\n-                        visitor.visit_path_list_item(prefix, item)\n-                    }\n-                }\n-            }\n+            visitor.visit_path(path, item.id);\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n@@ -481,11 +471,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_decl(visitor, &function_declaration.decl);\n             walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n-        TyPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, typ.id);\n+        TyPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(ty);\n@@ -508,20 +495,28 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: NodeId, span: Span) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(qself);\n+            }\n+            visitor.visit_path(path, id)\n+        }\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n+            visitor.visit_path_segment(span, segment);\n+        }\n+    }\n+}\n+\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+    visitor.visit_def_mention(path.def);\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n-pub fn walk_path_list_item<'v, V>(visitor: &mut V, _prefix: &'v Path, item: &'v PathListItem)\n-    where V: Visitor<'v>,\n-{\n-    visitor.visit_id(item.node.id);\n-    visitor.visit_name(item.span, item.node.name);\n-    walk_opt_name(visitor, item.span, item.node.rename);\n-}\n-\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n@@ -555,18 +550,15 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     visitor.visit_id(pattern.id);\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref children, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::TupleStruct(ref qpath, ref children, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, pattern.id)\n+        PatKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n         }\n-        PatKind::Struct(ref path, ref fields, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n@@ -579,7 +571,8 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, def_id, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_def_mention(Def::Local(def_id));\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n@@ -840,8 +833,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(element);\n             visitor.visit_expr(count)\n         }\n-        ExprStruct(ref path, ref fields, ref optional_base) => {\n-            visitor.visit_path(path, expression.id);\n+        ExprStruct(ref qpath, ref fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_name(field.name.span, field.name.node);\n                 visitor.visit_expr(&field.expr)\n@@ -917,18 +910,21 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, expression.id)\n+        ExprPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(ref opt_sp_name, ref opt_expr) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(None, ref opt_expr) => {\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(ref opt_sp_name) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(Some(label), ref opt_expr) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprAgain(None) => {}\n+        ExprAgain(Some(label)) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "39d0ed9a67b09a2f8b9e77d4b065bc368df622d9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 418, "deletions": 307, "changes": 725, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -52,9 +52,10 @@ use std::iter;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned};\n+use syntax::codemap::{self, respan, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n+use syntax::util::small_vector::SmallVector;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -67,11 +68,16 @@ pub struct LoweringContext<'a> {\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n     resolver: &'a mut Resolver,\n+\n+    /// The items being lowered are collected here.\n+    items: BTreeMap<NodeId, hir::Item>,\n+\n+    impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n }\n \n pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n+    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n@@ -98,52 +104,65 @@ pub fn lower_crate(sess: &Session,\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,\n+        items: BTreeMap::new(),\n+        impl_items: BTreeMap::new(),\n     }.lower_crate(krate)\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum ParamMode {\n+    /// Any path in a type context.\n+    Explicit,\n+    /// The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n impl<'a> LoweringContext<'a> {\n-    fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n+    fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n-            items: BTreeMap<NodeId, hir::Item>,\n-            impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n         impl<'lcx, 'interner> Visitor for ItemLowerer<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &Item) {\n-                self.items.insert(item.id, self.lctx.lower_item(item));\n+                let hir_item = self.lctx.lower_item(item);\n+                self.lctx.items.insert(item.id, hir_item);\n                 visit::walk_item(self, item);\n             }\n \n             fn visit_impl_item(&mut self, item: &ImplItem) {\n                 let id = self.lctx.lower_impl_item_ref(item).id;\n-                self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n+                let hir_item = self.lctx.lower_impl_item(item);\n+                self.lctx.impl_items.insert(id, hir_item);\n                 visit::walk_impl_item(self, item);\n             }\n         }\n \n-        let (items, impl_items) = {\n-            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(),\n-                                                 impl_items: BTreeMap::new(),\n-                                                 lctx: self };\n-            visit::walk_crate(&mut item_lowerer, c);\n-            (item_lowerer.items, item_lowerer.impl_items)\n-        };\n+        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n \n         hir::Crate {\n             module: self.lower_mod(&c.module),\n             attrs: self.lower_attrs(&c.attrs),\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n-            items: items,\n-            impl_items: impl_items,\n+            items: self.items,\n+            impl_items: self.impl_items,\n         }\n     }\n \n     fn next_id(&self) -> NodeId {\n         self.sess.next_node_id()\n     }\n \n+    fn expect_full_def(&mut self, id: NodeId) -> Def {\n+        self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n+            if pr.depth != 0 {\n+                bug!(\"path not fully resolved: {:?}\", pr);\n+            }\n+            pr.base_def\n+        })\n+    }\n+\n     fn diagnostic(&self) -> &errors::Handler {\n         self.sess.diagnostic()\n     }\n@@ -152,6 +171,18 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n+    fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n+        span.expn_id = self.sess.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        });\n+        span\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -171,39 +202,21 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n-        attrs.clone().into()\n-    }\n-\n-    fn lower_view_path(&mut self, view_path: &ViewPath) -> P<hir::ViewPath> {\n-        P(Spanned {\n-            node: match view_path.node {\n-                ViewPathSimple(ident, ref path) => {\n-                    hir::ViewPathSimple(ident.name, self.lower_path(path))\n-                }\n-                ViewPathGlob(ref path) => {\n-                    hir::ViewPathGlob(self.lower_path(path))\n+    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n+        label.map(|sp_ident| {\n+            hir::Label {\n+                span: sp_ident.span,\n+                name: sp_ident.node.name,\n+                loop_id: match self.expect_full_def(id) {\n+                    Def::Label(loop_id) => loop_id,\n+                    _ => DUMMY_NODE_ID\n                 }\n-                ViewPathList(ref path, ref path_list_idents) => {\n-                    hir::ViewPathList(self.lower_path(path),\n-                                      path_list_idents.iter()\n-                                                      .map(|item| self.lower_path_list_item(item))\n-                                                      .collect())\n-                }\n-            },\n-            span: view_path.span,\n+            }\n         })\n     }\n \n-    fn lower_path_list_item(&mut self, path_list_ident: &PathListItem) -> hir::PathListItem {\n-        Spanned {\n-            node: hir::PathListItem_ {\n-                id: path_list_ident.node.id,\n-                name: path_list_ident.node.name.name,\n-                rename: path_list_ident.node.rename.map(|rename| rename.name),\n-            },\n-            span: path_list_ident.span,\n-        }\n+    fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+        attrs.clone().into()\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -250,13 +263,7 @@ impl<'a> LoweringContext<'a> {\n                     return self.lower_ty(ty);\n                 }\n                 TyKind::Path(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    hir::TyPath(qself, self.lower_path(path))\n+                    hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n                 }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n@@ -298,38 +305,145 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_path(&mut self, p: &Path) -> hir::Path {\n+    fn lower_qpath(&mut self,\n+                   id: NodeId,\n+                   qself: &Option<QSelf>,\n+                   p: &Path,\n+                   param_mode: ParamMode)\n+                   -> hir::QPath {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty));\n+\n+        let resolution = self.resolver.get_resolution(id)\n+                                      .unwrap_or(PathResolution::new(Def::Err));\n+\n+        let proj_start = p.segments.len() - resolution.depth;\n+        let path = P(hir::Path {\n+            global: p.global,\n+            def: resolution.base_def,\n+            segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n+                let param_mode = match (qself_position, param_mode) {\n+                    (Some(j), ParamMode::Optional) if i < j => {\n+                        // This segment is part of the trait path in a\n+                        // qualified path - one of `a`, `b` or `Trait`\n+                        // in `<X as a::b::Trait>::T::U::method`.\n+                        ParamMode::Explicit\n+                    }\n+                    _ => param_mode\n+                };\n+                self.lower_path_segment(segment, param_mode)\n+            }).collect(),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if resolution.depth == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g. `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let ty = self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)));\n+\n+            // Associate that innermost path type with the base Def.\n+            self.resolver.record_resolution(ty.id, resolution.base_def);\n+\n+            ty\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g. for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            ty = self.ty(p.span, hir::TyPath(qpath));\n+        }\n+\n+        // Should've returned in the for loop above.\n+        span_bug!(p.span, \"lower_qpath: no final extension segment in {}..{}\",\n+                  proj_start, p.segments.len())\n+    }\n+\n+    fn lower_path_extra(&mut self,\n+                        id: NodeId,\n+                        p: &Path,\n+                        name: Option<Name>,\n+                        param_mode: ParamMode)\n+                        -> hir::Path {\n         hir::Path {\n             global: p.global,\n-            segments: p.segments\n-                       .iter()\n-                       .map(|&PathSegment { identifier, ref parameters }| {\n-                           hir::PathSegment {\n-                               name: identifier.name,\n-                               parameters: self.lower_path_parameters(parameters),\n-                           }\n-                       })\n-                       .collect(),\n+            def: self.expect_full_def(id),\n+            segments: p.segments.iter().map(|segment| {\n+                self.lower_path_segment(segment, param_mode)\n+            }).chain(name.map(|name| {\n+                hir::PathSegment {\n+                    name: name,\n+                    parameters: hir::PathParameters::none()\n+                }\n+            })).collect(),\n             span: p.span,\n         }\n     }\n \n-    fn lower_path_parameters(&mut self, path_parameters: &PathParameters) -> hir::PathParameters {\n-        match *path_parameters {\n-            PathParameters::AngleBracketed(ref data) =>\n-                hir::AngleBracketedParameters(self.lower_angle_bracketed_parameter_data(data)),\n+    fn lower_path(&mut self,\n+                  id: NodeId,\n+                  p: &Path,\n+                  param_mode: ParamMode)\n+                  -> hir::Path {\n+        self.lower_path_extra(id, p, None, param_mode)\n+    }\n+\n+    fn lower_path_segment(&mut self,\n+                          segment: &PathSegment,\n+                          param_mode: ParamMode)\n+                          -> hir::PathSegment {\n+        let parameters = match segment.parameters {\n+            PathParameters::AngleBracketed(ref data) => {\n+                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                hir::AngleBracketedParameters(data)\n+            }\n             PathParameters::Parenthesized(ref data) =>\n                 hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        };\n+\n+        hir::PathSegment {\n+            name: segment.identifier.name,\n+            parameters: parameters,\n         }\n     }\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n-                                            data: &AngleBracketedParameterData)\n+                                            data: &AngleBracketedParameterData,\n+                                            param_mode: ParamMode)\n                                             -> hir::AngleBracketedParameterData {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n         hir::AngleBracketedParameterData {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n+            infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n         }\n     }\n@@ -493,7 +607,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(path),\n+                    path: self.lower_path(id, path, ParamMode::Explicit),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -523,7 +637,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(&p.path),\n+            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -568,12 +682,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n-        let mut stmts = Vec::new();\n         let mut expr = None;\n \n-        if let Some((last, rest)) = b.stmts.split_last() {\n-            stmts = rest.iter().map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n-            let last = self.lower_stmt(last);\n+        let mut stmts = b.stmts.iter().flat_map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n+        if let Some(last) = stmts.pop() {\n             if let hir::StmtExpr(e, _) = last.node {\n                 expr = Some(e);\n             } else {\n@@ -590,11 +702,66 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_item_kind(&mut self, i: &ItemKind) -> hir::Item_ {\n+    fn lower_item_kind(&mut self,\n+                       id: NodeId,\n+                       name: &mut Name,\n+                       attrs: &hir::HirVec<Attribute>,\n+                       vis: &mut hir::Visibility,\n+                       i: &ItemKind)\n+                       -> hir::Item_ {\n         match *i {\n             ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n             ItemKind::Use(ref view_path) => {\n-                hir::ItemUse(self.lower_view_path(view_path))\n+                let path = match view_path.node {\n+                    ViewPathSimple(_, ref path) => path,\n+                    ViewPathGlob(ref path) => path,\n+                    ViewPathList(ref path, ref path_list_idents) => {\n+                        for &Spanned { node: ref import, span } in path_list_idents {\n+                            // `use a::{self as x, b as y};` lowers to\n+                            // `use a as x; use a::b as y;`\n+                            let mut ident = import.name;\n+                            let suffix = if ident.name == keywords::SelfValue.name() {\n+                                if let Some(last) = path.segments.last() {\n+                                    ident = last.identifier;\n+                                }\n+                                None\n+                            } else {\n+                                Some(ident.name)\n+                            };\n+\n+                            let mut path = self.lower_path_extra(import.id, path, suffix,\n+                                                                 ParamMode::Explicit);\n+                            path.span = span;\n+                            self.items.insert(import.id, hir::Item {\n+                                id: import.id,\n+                                name: import.rename.unwrap_or(ident).name,\n+                                attrs: attrs.clone(),\n+                                node: hir::ItemUse(P(path), hir::UseKind::Single),\n+                                vis: vis.clone(),\n+                                span: span,\n+                            });\n+                        }\n+                        path\n+                    }\n+                };\n+                let path = P(self.lower_path(id, path, ParamMode::Explicit));\n+                let kind = match view_path.node {\n+                    ViewPathSimple(ident, _) => {\n+                        *name = ident.name;\n+                        hir::UseKind::Single\n+                    }\n+                    ViewPathGlob(_) => {\n+                        hir::UseKind::Glob\n+                    }\n+                    ViewPathList(..) => {\n+                        // Privatize the degenerate import base, used only to check\n+                        // the stability of `use a::{};`, to avoid it showing up as\n+                        // a reexport by accident when `pub`, e.g. in documentation.\n+                        *vis = hir::Inherited;\n+                        hir::UseKind::ListStem\n+                    }\n+                };\n+                hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 hir::ItemStatic(self.lower_ty(t),\n@@ -742,7 +909,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n         hir::Mod {\n             inner: m.inner,\n-            item_ids: m.items.iter().map(|x| self.lower_item_id(x)).collect(),\n+            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n         }\n     }\n \n@@ -758,21 +925,30 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_item_id(&mut self, i: &Item) -> hir::ItemId {\n-        hir::ItemId { id: i.id }\n+    fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n+        if let ItemKind::Use(ref view_path) = i.node {\n+            if let ViewPathList(_, ref imports) = view_path.node {\n+                return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n+                    .map(|id| hir::ItemId { id: id }).collect();\n+            }\n+        }\n+        SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n     pub fn lower_item(&mut self, i: &Item) -> hir::Item {\n+        let mut name = i.ident.name;\n+        let attrs = self.lower_attrs(&i.attrs);\n+        let mut vis = self.lower_visibility(&i.vis);\n         let node = self.with_parent_def(i.id, |this| {\n-            this.lower_item_kind(&i.node)\n+            this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n         hir::Item {\n             id: i.id,\n-            name: i.ident.name,\n-            attrs: self.lower_attrs(&i.attrs),\n+            name: name,\n+            attrs: attrs,\n             node: node,\n-            vis: self.lower_visibility(&i.vis),\n+            vis: vis,\n             span: i.span,\n         }\n     }\n@@ -875,29 +1051,41 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(p.id, |this| {\n                         match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n                             // `None` can occur in body-less function signatures\n-                            None | Some(Def::Local(..)) => {\n+                            def @ None | def @ Some(Def::Local(_)) => {\n+                                let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {\n+                                    this.resolver.definitions().local_def_id(p.id)\n+                                });\n                                 hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n+                                                      def_id,\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => hir::PatKind::Path(None, hir::Path::from_name(pth1.span,\n-                                                                               pth1.node.name))\n+                            Some(def) => {\n+                                hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                                    span: pth1.span,\n+                                    global: false,\n+                                    def: def,\n+                                    segments: hir_vec![\n+                                        hir::PathSegment::from_name(pth1.node.name)\n+                                    ],\n+                                })))\n+                            }\n                         }\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(path),\n-                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    hir::PatKind::TupleStruct(qpath,\n+                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                              ddpos)\n                 }\n-                PatKind::Path(ref opt_qself, ref path) => {\n-                    let opt_qself = opt_qself.as_ref().map(|qself| {\n-                        hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n-                    });\n-                    hir::PatKind::Path(opt_qself, self.lower_path(path))\n+                PatKind::Path(ref qself, ref path) => {\n+                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional))\n                 }\n-                PatKind::Struct(ref pth, ref fields, etc) => {\n-                    let pth = self.lower_path(pth);\n+                PatKind::Struct(ref path, ref fields, etc) => {\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+\n                     let fs = fields.iter()\n                                    .map(|f| {\n                                        Spanned {\n@@ -910,7 +1098,7 @@ impl<'a> LoweringContext<'a> {\n                                        }\n                                    })\n                                    .collect();\n-                    hir::PatKind::Struct(pth, fs, etc)\n+                    hir::PatKind::Struct(qpath, fs, etc)\n                 }\n                 PatKind::Tuple(ref elts, ddpos) => {\n                     hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n@@ -980,9 +1168,9 @@ impl<'a> LoweringContext<'a> {\n                     let move_val_init = [\"intrinsics\", \"move_val_init\"];\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n+                    let unstable_span = self.allow_internal_unstable(\"<-\", e.span);\n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.std_path(e.span, p);\n-                        let path = this.expr_path(path, ThinVec::new());\n+                        let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n                         P(this.expr_call(e.span, path, args))\n                     };\n \n@@ -996,11 +1184,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                   placer_expr,\n-                                                                   e.span,\n-                                                                   hir::PopUnstableBlock,\n-                                                                   ThinVec::new()));\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n@@ -1021,11 +1204,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                  value_expr,\n-                                                                  e.span,\n-                                                                  hir::PopUnstableBlock,\n-                                                                  ThinVec::new()));\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n@@ -1054,11 +1232,9 @@ impl<'a> LoweringContext<'a> {\n                                                  ThinVec::new()))\n                     };\n \n-                    return self.signal_block_expr(hir_vec![s1, s2, s3],\n-                                                  expr,\n-                                                  e.span,\n-                                                  hir::PushUnstableBlock,\n-                                                  e.attrs.clone());\n+                    let block = self.block_all(e.span, hir_vec![s1, s2, s3], Some(expr));\n+                    // add the attributes to the outer returned expr node\n+                    return self.expr_block(P(block), e.attrs.clone());\n                 }\n \n                 ExprKind::Vec(ref exprs) => {\n@@ -1176,33 +1352,23 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n-                        let struct_path = this.std_path(ast_expr.span,\n-                                                        &iter::once(&\"ops\").chain(path)\n-                                                                           .map(|s| *s)\n-                                                                           .collect::<Vec<_>>());\n+                        let struct_path = &iter::once(&\"ops\").chain(path).map(|s| *s)\n+                                                             .collect::<Vec<_>>();\n+                        let unstable_span = this.allow_internal_unstable(\"...\", ast_expr.span);\n \n-                        let hir_expr = if fields.len() == 0 {\n-                            this.expr_path(struct_path, ast_expr.attrs.clone())\n+                        if fields.len() == 0 {\n+                            this.expr_std_path(unstable_span, struct_path,\n+                                               ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = P(this.lower_expr(&e));\n-                                let signal_block = P(this.signal_block_expr(hir_vec![],\n-                                                                            expr,\n-                                                                            e.span,\n-                                                                            hir::PopUnstableBlock,\n-                                                                            ThinVec::new()));\n-                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n+                                let unstable_span = this.allow_internal_unstable(\"...\", e.span);\n+                                this.field(Symbol::intern(s), expr, unstable_span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_struct(ast_expr.span, struct_path, fields, None, attrs)\n-                        };\n-\n-                        this.signal_block_expr(hir_vec![],\n-                                               hir_expr,\n-                                               ast_expr.span,\n-                                               hir::PushUnstableBlock,\n-                                               ThinVec::new())\n+                            this.expr_std_struct(unstable_span, struct_path, fields, None, attrs)\n+                        }\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1236,19 +1402,13 @@ impl<'a> LoweringContext<'a> {\n                     };\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n-                    let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    hir::ExprPath(hir_qself, self.lower_path(path))\n+                    hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n+                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n                                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1275,7 +1435,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n                 }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(P(self.lower_path(path)),\n+                    hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n@@ -1475,10 +1635,10 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n-                        let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n                         let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n-                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                        let next_path = P(self.expr_std_path(e.span, next_path, ThinVec::new()));\n                         let next_expr = P(self.expr_call(e.span, next_path,\n                                           hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n@@ -1505,10 +1665,9 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n-                        let into_iter_path = self.std_path(e.span,\n-                                                           &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n-\n-                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                        let into_iter = P(self.expr_std_path(e.span, into_iter_path,\n+                                                             ThinVec::new()));\n                         P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n@@ -1534,32 +1693,20 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Try(ref sub_expr) => {\n                     // to:\n                     //\n-                    // {\n-                    //     match { Carrier::translate( { <expr> } ) } {\n-                    //         Ok(val) => val,\n-                    //         Err(err) => { return Carrier::from_error(From::from(err)); }\n-                    //     }\n+                    // match Carrier::translate(<expr>) {\n+                    //     Ok(val) => val,\n+                    //     Err(err) => return Carrier::from_error(From::from(err))\n                     // }\n+                    let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n-                    // { Carrier::translate( { <expr> } ) }\n+                    // Carrier::translate(<expr>)\n                     let discr = {\n                         // expand <expr>\n-                        let sub_expr = P(self.lower_expr(sub_expr));\n-                        let sub_expr = self.signal_block_expr(hir_vec![],\n-                                                              sub_expr,\n-                                                              e.span,\n-                                                              hir::PopUnstableBlock,\n-                                                              ThinVec::new());\n-\n-                        let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n-                        let path = self.expr_path(path, ThinVec::new());\n-                        let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n-\n-                        P(self.signal_block_expr(hir_vec![],\n-                                                 call,\n-                                                 e.span,\n-                                                 hir::PushUnstableBlock,\n-                                                 ThinVec::new()))\n+                        let sub_expr = self.lower_expr(sub_expr);\n+\n+                        let path = &[\"ops\", \"Carrier\", \"translate\"];\n+                        let path = P(self.expr_std_path(unstable_span, path, ThinVec::new()));\n+                        P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                     };\n \n                     // Ok(val) => val\n@@ -1572,33 +1719,30 @@ impl<'a> LoweringContext<'a> {\n                         self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n-                    // Err(err) => { return Carrier::from_error(From::from(err)); }\n+                    // Err(err) => return Carrier::from_error(From::from(err))\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = self.std_path(e.span, &[\"convert\", \"From\", \"from\"]);\n-                            let from = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"convert\", \"From\", \"from\"];\n+                            let from = P(self.expr_std_path(e.span, path, ThinVec::new()));\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let from_err_expr = {\n-                            let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n-                            let from_err = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"ops\", \"Carrier\", \"from_error\"];\n+                            let from_err = P(self.expr_std_path(unstable_span, path,\n+                                                                ThinVec::new()));\n                             P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n                         let ret_expr = P(self.expr(e.span,\n                                                    hir::Expr_::ExprRet(Some(from_err_expr)),\n                                                                        ThinVec::new()));\n-                        let ret_stmt = self.stmt_expr(ret_expr);\n-                        let block = P(self.signal_block_stmt(ret_stmt, e.span,\n-                                                             hir::PushUnstableBlock,\n-                                                             ThinVec::new()));\n \n                         let err_pat = self.pat_err(e.span, err_local);\n-                        self.arm(hir_vec![err_pat], block)\n+                        self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, discr, hir_vec![err_arm, ok_arm],\n@@ -1612,22 +1756,26 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n-        match s.node {\n+    fn lower_stmt(&mut self, s: &Stmt) -> SmallVector<hir::Stmt> {\n+        SmallVector::one(match s.node {\n             StmtKind::Local(ref l) => Spanned {\n                 node: hir::StmtDecl(P(Spanned {\n                     node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n                 }), s.id),\n                 span: s.span,\n             },\n-            StmtKind::Item(ref it) => Spanned {\n-                node: hir::StmtDecl(P(Spanned {\n-                    node: hir::DeclItem(self.lower_item_id(it)),\n+            StmtKind::Item(ref it) => {\n+                // Can only use the ID once.\n+                let mut id = Some(s.id);\n+                return self.lower_item_id(it).into_iter().map(|item_id| Spanned {\n+                    node: hir::StmtDecl(P(Spanned {\n+                        node: hir::DeclItem(item_id),\n+                        span: s.span,\n+                    }), id.take().unwrap_or_else(|| self.next_id())),\n                     span: s.span,\n-                }), s.id),\n-                span: s.span,\n-            },\n+                }).collect();\n+            }\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n                     node: hir::StmtExpr(P(self.lower_expr(e)), s.id),\n@@ -1641,7 +1789,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n-        }\n+        })\n     }\n \n     fn lower_capture_clause(&mut self, c: CaptureBy) -> hir::CaptureClause {\n@@ -1655,8 +1803,12 @@ impl<'a> LoweringContext<'a> {\n         match *v {\n             Visibility::Public => hir::Public,\n             Visibility::Crate(_) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id } =>\n-                hir::Visibility::Restricted { path: P(self.lower_path(path)), id: id },\n+            Visibility::Restricted { ref path, id } => {\n+                hir::Visibility::Restricted {\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n+                    id: id\n+                }\n+            }\n             Visibility::Inherited => hir::Inherited,\n         }\n     }\n@@ -1739,13 +1891,18 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n-        let expr = self.expr(span, expr_path, ThinVec::new());\n-\n         let def = {\n             let defs = self.resolver.definitions();\n             Def::Local(defs.local_def_id(binding))\n         };\n+\n+        let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n+            span: span,\n+            global: false,\n+            def: def,\n+            segments: hir_vec![hir::PathSegment::from_name(id)],\n+        })));\n+        let expr = self.expr(span, expr_path, ThinVec::new());\n         self.resolver.record_resolution(expr.id, def);\n \n         expr\n@@ -1755,9 +1912,14 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = P(self.expr(path.span, hir::ExprPath(None, path), attrs));\n+    fn expr_std_path(&mut self,\n+                     span: Span,\n+                     components: &[&str],\n+                     attrs: ThinVec<Attribute>)\n+                     -> hir::Expr {\n+        let path = self.std_path(span, components, true);\n+        let def = path.def;\n+        let expr = self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n@@ -1779,14 +1941,16 @@ impl<'a> LoweringContext<'a> {\n         P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n-    fn expr_struct(&mut self,\n-                   sp: Span,\n-                   path: hir::Path,\n-                   fields: hir::HirVec<hir::Field>,\n-                   e: Option<P<hir::Expr>>,\n-                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = P(self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs));\n+    fn expr_std_struct(&mut self,\n+                       span: Span,\n+                       components: &[&str],\n+                       fields: hir::HirVec<hir::Field>,\n+                       e: Option<P<hir::Expr>>,\n+                       attrs: ThinVec<Attribute>) -> hir::Expr {\n+        let path = self.std_path(span, components, false);\n+        let def = path.def;\n+        let qpath = hir::QPath::Resolved(None, P(path));\n+        let expr = self.expr(span, hir::ExprStruct(qpath, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n@@ -1820,15 +1984,6 @@ impl<'a> LoweringContext<'a> {\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n     }\n \n-    // Turns `<expr>` into `<expr>;`, note that this produces a StmtSemi, not a\n-    // StmtExpr.\n-    fn stmt_expr(&self, expr: P<hir::Expr>) -> hir::Stmt {\n-        hir::Stmt {\n-            span: expr.span,\n-            node: hir::StmtSemi(expr, self.next_id()),\n-        }\n-    }\n-\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n@@ -1845,32 +2000,33 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Ok\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Err\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"Some\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"None\"]);\n-        self.pat_enum(span, path, hir_vec![])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n     }\n \n-    fn pat_enum(&mut self, span: Span, path: hir::Path, subpats: hir::HirVec<P<hir::Pat>>)\n-                -> P<hir::Pat> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n+    fn pat_std_enum(&mut self,\n+                    span: Span,\n+                    components: &[&str],\n+                    subpats: hir::HirVec<P<hir::Pat>>)\n+                    -> P<hir::Pat> {\n+        let path = self.std_path(span, components, true);\n+        let def = path.def;\n+        let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(None, path)\n+            hir::PatKind::Path(qpath)\n         } else {\n-            hir::PatKind::TupleStruct(path, subpats, None)\n+            hir::PatKind::TupleStruct(qpath, subpats, None)\n         };\n         let pat = self.pat(span, pt);\n         self.resolver.record_resolution(pat.id, def);\n@@ -1883,25 +2039,27 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n-        let pat_ident = hir::PatKind::Binding(bm,\n-                                            Spanned {\n-                                                span: span,\n-                                                node: name,\n-                                            },\n-                                            None);\n-\n-        let pat = self.pat(span, pat_ident);\n-\n+        let id = self.next_id();\n         let parent_def = self.parent_def;\n-        let def = {\n+        let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index))\n+            let def_index = defs.create_def_with_parent(parent_def, id, def_path_data);\n+            DefId::local(def_index)\n         };\n-        self.resolver.record_resolution(pat.id, def);\n+        self.resolver.record_resolution(id, Def::Local(def_id));\n \n-        pat\n+        P(hir::Pat {\n+            id: id,\n+            node: hir::PatKind::Binding(bm,\n+                                        def_id,\n+                                        Spanned {\n+                                            span: span,\n+                                            node: name,\n+                                        },\n+                                        None),\n+            span: span,\n+        })\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n@@ -1916,63 +2074,25 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn path_ident(&mut self, span: Span, id: Name) -> hir::Path {\n-        self.path(span, vec![id])\n-    }\n-\n-    fn path(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n-\n-    fn path_global(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n+    /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+    /// The path is also resolved according to `is_value`.\n+    fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n+        let idents = self.crate_root.iter().chain(components);\n \n-    fn path_all(&mut self,\n-                sp: Span,\n-                global: bool,\n-                mut names: Vec<Name>,\n-                lifetimes: hir::HirVec<hir::Lifetime>,\n-                types: hir::HirVec<P<hir::Ty>>,\n-                bindings: hir::HirVec<hir::TypeBinding>)\n-                -> hir::Path {\n-        let last_identifier = names.pop().unwrap();\n-        let mut segments: Vec<hir::PathSegment> = names.into_iter().map(|name| {\n-            hir::PathSegment {\n-                name: name,\n-                parameters: hir::PathParameters::none(),\n-           }\n+        let segments: Vec<_> = idents.map(|name| {\n+            hir::PathSegment::from_name(Symbol::intern(name))\n         }).collect();\n \n-        segments.push(hir::PathSegment {\n-            name: last_identifier,\n-            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: types,\n-                bindings: bindings,\n-            }),\n-        });\n-        hir::Path {\n-            span: sp,\n-            global: global,\n+        let mut path = hir::Path {\n+            span: span,\n+            global: true,\n+            def: Def::Err,\n             segments: segments.into(),\n-        }\n-    }\n-\n-    fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n-        let mut v = Vec::new();\n-        if let Some(s) = self.crate_root {\n-            v.push(Symbol::intern(s));\n-        }\n-        v.extend(components.iter().map(|s| Symbol::intern(s)));\n-        return v;\n-    }\n+        };\n \n-    // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-    // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    fn std_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n-        let idents = self.std_path_components(components);\n-        self.path_global(span, idents)\n+        self.resolver.resolve_generated_global_path(&mut path, is_value);\n+        path\n     }\n \n     fn signal_block_expr(&mut self,\n@@ -1993,20 +2113,11 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn signal_block_stmt(&mut self,\n-                         stmt: hir::Stmt,\n-                         span: Span,\n-                         rule: hir::BlockCheckMode,\n-                         attrs: ThinVec<Attribute>)\n-                         -> hir::Expr {\n-        let id = self.next_id();\n-        let block = P(hir::Block {\n-            rules: rule,\n+    fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n+        P(hir::Ty {\n+            id: self.next_id(),\n+            node: node,\n             span: span,\n-            id: id,\n-            stmts: hir_vec![stmt],\n-            expr: None,\n-        });\n-        self.expr_block(block, attrs)\n+        })\n     }\n }"}, {"sha": "26fd2b736a42c29bdcba81874fb4835b0c8c3b65", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -124,23 +124,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                         this.insert(struct_def.id(), NodeStructCtor(struct_def));\n                     }\n                 }\n-                ItemTrait(.., ref bounds, _) => {\n-                    for b in bounds.iter() {\n-                        if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                            this.insert(t.trait_ref.ref_id, NodeItem(i));\n-                        }\n-                    }\n-                }\n-                ItemUse(ref view_path) => {\n-                    match view_path.node {\n-                        ViewPathList(_, ref paths) => {\n-                            for path in paths {\n-                                this.insert(path.node.id, NodeItem(i));\n-                            }\n-                        }\n-                        _ => ()\n-                    }\n-                }\n                 _ => {}\n             }\n             intravisit::walk_item(this, i);\n@@ -217,6 +200,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n+    fn visit_trait_ref(&mut self, tr: &'ast TraitRef) {\n+        self.insert(tr.ref_id, NodeTraitRef(tr));\n+\n+        self.with_parent(tr.ref_id, |this| {\n+            intravisit::walk_trait_ref(this, tr);\n+        });\n+    }\n+\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n                 b: &'ast Expr, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n@@ -234,7 +225,28 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n+    fn visit_vis(&mut self, visibility: &'ast Visibility) {\n+        match *visibility {\n+            Visibility::Public |\n+            Visibility::Crate |\n+            Visibility::Inherited => {}\n+            Visibility::Restricted { id, .. } => {\n+                self.insert(id, NodeVisibility(visibility));\n+                self.with_parent(id, |this| {\n+                    intravisit::walk_vis(this, visibility);\n+                });\n+            }\n+        }\n+    }\n+\n     fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n         self.insert_entry(macro_def.id, NotPresent);\n     }\n+\n+    fn visit_struct_field(&mut self, field: &'ast StructField) {\n+        self.insert(field.id, NodeField(field));\n+        self.with_parent(field.id, |this| {\n+            intravisit::walk_struct_field(this, field);\n+        });\n+    }\n }"}, {"sha": "a08060e792778bf93155b50aca82c7dcbe5b0b3c", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -155,7 +155,20 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n             ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n-            ItemKind::Use(..) => DefPathData::Misc,\n+            ItemKind::Use(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathGlob(..) => {}\n+\n+                    // FIXME(eddyb) Should use the real name. Which namespace?\n+                    ViewPathSimple(..) => {}\n+                    ViewPathList(_, ref imports) => {\n+                        for import in imports {\n+                            self.create_def(import.node.id, DefPathData::Misc);\n+                        }\n+                    }\n+                }\n+                DefPathData::Misc\n+            }\n         };\n         let def = self.create_def(i.id, def_data);\n \n@@ -423,7 +436,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Binding(_, name, _) = pat.node {\n+        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n             let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n             self.parent_def = Some(def);\n         }"}, {"sha": "b9763e6ea0dcb430a77eede0cd9c33acd73ff878", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -46,9 +46,11 @@ pub enum Node<'ast> {\n     NodeTraitItem(&'ast TraitItem),\n     NodeImplItem(&'ast ImplItem),\n     NodeVariant(&'ast Variant),\n+    NodeField(&'ast StructField),\n     NodeExpr(&'ast Expr),\n     NodeStmt(&'ast Stmt),\n     NodeTy(&'ast Ty),\n+    NodeTraitRef(&'ast TraitRef),\n     NodeLocal(&'ast Pat),\n     NodePat(&'ast Pat),\n     NodeBlock(&'ast Block),\n@@ -57,7 +59,8 @@ pub enum Node<'ast> {\n     NodeStructCtor(&'ast VariantData),\n \n     NodeLifetime(&'ast Lifetime),\n-    NodeTyParam(&'ast TyParam)\n+    NodeTyParam(&'ast TyParam),\n+    NodeVisibility(&'ast Visibility),\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -73,15 +76,18 @@ pub enum MapEntry<'ast> {\n     EntryTraitItem(NodeId, &'ast TraitItem),\n     EntryImplItem(NodeId, &'ast ImplItem),\n     EntryVariant(NodeId, &'ast Variant),\n+    EntryField(NodeId, &'ast StructField),\n     EntryExpr(NodeId, &'ast Expr),\n     EntryStmt(NodeId, &'ast Stmt),\n     EntryTy(NodeId, &'ast Ty),\n+    EntryTraitRef(NodeId, &'ast TraitRef),\n     EntryLocal(NodeId, &'ast Pat),\n     EntryPat(NodeId, &'ast Pat),\n     EntryBlock(NodeId, &'ast Block),\n     EntryStructCtor(NodeId, &'ast VariantData),\n     EntryLifetime(NodeId, &'ast Lifetime),\n     EntryTyParam(NodeId, &'ast TyParam),\n+    EntryVisibility(NodeId, &'ast Visibility),\n \n     /// Roots for node trees.\n     RootCrate,\n@@ -102,15 +108,18 @@ impl<'ast> MapEntry<'ast> {\n             NodeTraitItem(n) => EntryTraitItem(p, n),\n             NodeImplItem(n) => EntryImplItem(p, n),\n             NodeVariant(n) => EntryVariant(p, n),\n+            NodeField(n) => EntryField(p, n),\n             NodeExpr(n) => EntryExpr(p, n),\n             NodeStmt(n) => EntryStmt(p, n),\n             NodeTy(n) => EntryTy(p, n),\n+            NodeTraitRef(n) => EntryTraitRef(p, n),\n             NodeLocal(n) => EntryLocal(p, n),\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n             NodeStructCtor(n) => EntryStructCtor(p, n),\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n+            NodeVisibility(n) => EntryVisibility(p, n),\n         }\n     }\n \n@@ -121,15 +130,18 @@ impl<'ast> MapEntry<'ast> {\n             EntryTraitItem(id, _) => id,\n             EntryImplItem(id, _) => id,\n             EntryVariant(id, _) => id,\n+            EntryField(id, _) => id,\n             EntryExpr(id, _) => id,\n             EntryStmt(id, _) => id,\n             EntryTy(id, _) => id,\n+            EntryTraitRef(id, _) => id,\n             EntryLocal(id, _) => id,\n             EntryPat(id, _) => id,\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n             EntryTyParam(id, _) => id,\n+            EntryVisibility(id, _) => id,\n \n             NotPresent |\n             RootCrate |\n@@ -144,15 +156,18 @@ impl<'ast> MapEntry<'ast> {\n             EntryTraitItem(_, n) => NodeTraitItem(n),\n             EntryImplItem(_, n) => NodeImplItem(n),\n             EntryVariant(_, n) => NodeVariant(n),\n+            EntryField(_, n) => NodeField(n),\n             EntryExpr(_, n) => NodeExpr(n),\n             EntryStmt(_, n) => NodeStmt(n),\n             EntryTy(_, n) => NodeTy(n),\n+            EntryTraitRef(_, n) => NodeTraitRef(n),\n             EntryLocal(_, n) => NodeLocal(n),\n             EntryPat(_, n) => NodePat(n),\n             EntryBlock(_, n) => NodeBlock(n),\n             EntryStructCtor(_, n) => NodeStructCtor(n),\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n+            EntryVisibility(_, n) => NodeVisibility(n),\n             _ => return None\n         })\n     }\n@@ -240,16 +255,8 @@ impl<'ast> Map<'ast> {\n             loop {\n                 match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n-                        let def_id = self.local_def_id(item.id);\n-                        // NB                          ^~~~~~~\n-                        //\n-                        // You would expect that `item.id == id`, but this\n-                        // is not always the case. In particular, for a\n-                        // ViewPath item like `use self::{mem, foo}`, we\n-                        // map the ids for `mem` and `foo` to the\n-                        // enclosing view path item. This seems mega super\n-                        // ultra wrong, but then who am I to judge?\n-                        // -nmatsakis\n+                        assert_eq!(id, item.id);\n+                        let def_id = self.local_def_id(id);\n                         assert!(!self.is_inlined_def_id(def_id));\n                         return DepNode::Hir(def_id);\n                     }\n@@ -263,15 +270,18 @@ impl<'ast> Map<'ast> {\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n                     EntryVariant(p, _) |\n+                    EntryField(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n+                    EntryTraitRef(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n                     EntryStructCtor(p, _) |\n                     EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) =>\n+                    EntryTyParam(p, _) |\n+                    EntryVisibility(p, _) =>\n                         id = p,\n \n                     RootCrate =>\n@@ -304,15 +314,18 @@ impl<'ast> Map<'ast> {\n                     EntryTraitItem(p, _) |\n                     EntryImplItem(p, _) |\n                     EntryVariant(p, _) |\n+                    EntryField(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n+                    EntryTraitRef(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n                     EntryStructCtor(p, _) |\n                     EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) =>\n+                    EntryTyParam(p, _) |\n+                    EntryVisibility(p, _) =>\n                         id = p,\n \n                     RootInlinedParent(parent) => match *parent {\n@@ -650,9 +663,10 @@ impl<'ast> Map<'ast> {\n             NodeImplItem(ii) => ii.name,\n             NodeTraitItem(ti) => ti.name,\n             NodeVariant(v) => v.node.name,\n+            NodeField(f) => f.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Binding(_,l,_), .. }) => l.node,\n+            NodeLocal(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -668,6 +682,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n@@ -704,14 +719,17 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(trait_method)) => trait_method.span,\n             Some(NodeImplItem(ref impl_item)) => impl_item.span,\n             Some(NodeVariant(variant)) => variant.span,\n+            Some(NodeField(field)) => field.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n             Some(NodeTy(ty)) => ty.span,\n+            Some(NodeTraitRef(tr)) => tr.path.span,\n             Some(NodeLocal(pat)) => pat.span,\n             Some(NodePat(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n             Some(NodeTyParam(ty_param)) => ty_param.span,\n+            Some(NodeVisibility(&Visibility::Restricted { ref path, .. })) => path.span,\n             _ => return None,\n         };\n         Some(sp)\n@@ -823,6 +841,7 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n                 Some(EntryTraitItem(_, n))  => n.name(),\n                 Some(EntryImplItem(_, n))   => n.name(),\n                 Some(EntryVariant(_, n))    => n.name(),\n+                Some(EntryField(_, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -841,6 +860,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n+impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n@@ -926,10 +946,13 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeExpr(a)        => self.print_expr(&a),\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n+            NodeTraitRef(a)    => self.print_trait_ref(&a),\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => self.print_block(&a),\n             NodeLifetime(a)    => self.print_lifetime(&a),\n+            NodeVisibility(a)  => self.print_visibility(&a),\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n+            NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n@@ -1009,6 +1032,11 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     variant.node.name,\n                     path_str(), id_str)\n         }\n+        Some(NodeField(ref field)) => {\n+            format!(\"field {} in {}{}\",\n+                    field.name,\n+                    path_str(), id_str)\n+        }\n         Some(NodeExpr(ref expr)) => {\n             format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n         }\n@@ -1018,6 +1046,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeTy(ref ty)) => {\n             format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n         }\n+        Some(NodeTraitRef(ref tr)) => {\n+            format!(\"trait_ref {}{}\", pprust::path_to_string(&tr.path), id_str)\n+        }\n         Some(NodeLocal(ref pat)) => {\n             format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n@@ -1037,6 +1068,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)\n         }\n+        Some(NodeVisibility(ref vis)) => {\n+            format!(\"visibility {:?}{}\", vis, id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "d494299a3c38841232dd3d4dfc1771b683b64a09", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 86, "deletions": 82, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -27,7 +27,6 @@ pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::ViewPath_::*;\n pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n@@ -108,6 +107,8 @@ pub struct Path {\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     pub global: bool,\n+    /// The definition that the path resolved to.\n+    pub def: Def,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n@@ -124,21 +125,6 @@ impl fmt::Display for Path {\n     }\n }\n \n-impl Path {\n-    /// Convert a span and an identifier to the corresponding\n-    /// 1-segment path.\n-    pub fn from_name(s: Span, name: Name) -> Path {\n-        Path {\n-            span: s,\n-            global: false,\n-            segments: hir_vec![PathSegment {\n-                name: name,\n-                parameters: PathParameters::none()\n-            }],\n-        }\n-    }\n-}\n-\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -154,6 +140,16 @@ pub struct PathSegment {\n     pub parameters: PathParameters,\n }\n \n+impl PathSegment {\n+    /// Convert an identifier to the corresponding segment.\n+    pub fn from_name(name: Name) -> PathSegment {\n+        PathSegment {\n+            name: name,\n+            parameters: PathParameters::none()\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n@@ -167,6 +163,7 @@ impl PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: HirVec::new(),\n             types: HirVec::new(),\n+            infer_types: true,\n             bindings: HirVec::new(),\n         })\n     }\n@@ -241,6 +238,11 @@ pub struct AngleBracketedParameterData {\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: HirVec<P<Ty>>,\n+    /// Whether to infer remaining type parameters, if any.\n+    /// This only applies to expression and pattern paths, and\n+    /// out of those only the segments with no type parameters\n+    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    pub infer_types: bool,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n@@ -527,7 +529,7 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(..) |\n             PatKind::Binding(..) |\n-            PatKind::Path(..) => {\n+            PatKind::Path(_) => {\n                 true\n             }\n         }\n@@ -566,20 +568,20 @@ pub enum PatKind {\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n+    /// The `DefId` is for the definition of the variable being bound.\n+    Binding(BindingMode, DefId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// 0 <= position <= subpats.len()\n-    TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n+    TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n-    /// A possibly qualified path pattern.\n-    /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Option<QSelf>, Path),\n+    /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n+    Path(QPath),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -836,9 +838,6 @@ pub enum BlockCheckMode {\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n-    // Within this block (but outside a PopUnstableBlock), we suspend checking of stability.\n-    PushUnstableBlock,\n-    PopUnstableBlock,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -934,19 +933,15 @@ pub enum Expr_ {\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n \n-    /// Variable reference, possibly containing `::` and/or type\n-    /// parameters, e.g. foo::bar::<baz>.\n-    ///\n-    /// Optionally \"qualified\",\n-    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n-    ExprPath(Option<QSelf>, Path),\n+    /// Path to a definition, possibly containing lifetime or type parameters.\n+    ExprPath(QPath),\n \n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Name>>, Option<P<Expr>>),\n+    ExprBreak(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Spanned<Name>>),\n+    ExprAgain(Option<Label>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -957,7 +952,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(P<Path>, HirVec<Field>, Option<P<Expr>>),\n+    ExprStruct(QPath, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -966,22 +961,30 @@ pub enum Expr_ {\n     ExprRepeat(P<Expr>, P<Expr>),\n }\n \n-/// The explicit Self type in a \"qualified path\". The actual\n-/// path, including the trait and the associated item, is stored\n-/// separately. `position` represents the index of the associated\n-/// item qualified with this Self type.\n-///\n-///     <HirVec<T> as a::b::Trait>::AssociatedItem\n-///      ^~~~~     ~~~~~~~~~~~~~~^\n-///      ty        position = 3\n-///\n-///     <HirVec<T>>::AssociatedItem\n-///      ^~~~~    ^\n-///      ty       position = 0\n+/// Optionally `Self`-qualified value/type path or associated extension.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct QSelf {\n-    pub ty: P<Ty>,\n-    pub position: usize,\n+pub enum QPath {\n+    /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n+    /// type, if the path points to an associated item in a trait.\n+    ///\n+    /// E.g. an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n+    /// even though they both have the same two-segment `Clone::clone` `Path`.\n+    Resolved(Option<P<Ty>>, P<Path>),\n+\n+    /// Type-related paths, e.g. `<T>::default` or `<T>::Output`.\n+    /// Will be resolved by type-checking to an associated item.\n+    ///\n+    /// UFCS source paths can desugar into this, with `Vec::new` turning into\n+    /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n+    /// the `X` and `Y` nodes being each a `TyPath(QPath::TypeRelative(..))`.\n+    TypeRelative(P<Ty>, P<PathSegment>)\n+}\n+\n+impl fmt::Display for QPath {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", print::qpath_to_string(self))\n+    }\n }\n \n /// Hints at the original code for a `match _ { .. }`\n@@ -1014,6 +1017,13 @@ pub enum LoopSource {\n }\n \n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Label {\n+    pub span: Span,\n+    pub name: Name,\n+    pub loop_id: NodeId\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -1155,11 +1165,12 @@ pub enum Ty_ {\n     TyNever,\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(HirVec<P<Ty>>),\n-    /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n+    /// A path to a type definition (`module::module::...::Type`), or an\n+    /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n-    /// Type parameters are stored in the Path itself\n-    TyPath(Option<QSelf>, Path),\n+    /// Type parameters may be stored in each `PathSegment`.\n+    TyPath(QPath),\n+\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n@@ -1216,7 +1227,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Binding(BindByValue(mutbl), name, _) = self.pat.node {\n+        if let PatKind::Binding(BindByValue(mutbl), _, name, _) = self.pat.node {\n             if name.node == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1232,7 +1243,7 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Binding(_, name, _) = self.pat.node {\n+        if let PatKind::Binding(_, _, name, _) = self.pat.node {\n             name.node == keywords::SelfValue.name()\n         } else {\n             false\n@@ -1375,32 +1386,20 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct PathListItem_ {\n-    pub name: Name,\n-    /// renamed in list, eg `use foo::{bar as baz};`\n-    pub rename: Option<Name>,\n-    pub id: NodeId,\n-}\n-\n-pub type PathListItem = Spanned<PathListItem_>;\n-\n-pub type ViewPath = Spanned<ViewPath_>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ViewPath_ {\n-    /// `foo::bar::baz as quux`\n-    ///\n-    /// or just\n-    ///\n-    /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Name, Path),\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum UseKind {\n+    /// One import, e.g. `use foo::bar` or `use foo::bar as baz`.\n+    /// Also produced for each element of a list `use`, e.g.\n+    // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n+    Single,\n \n-    /// `foo::bar::*`\n-    ViewPathGlob(Path),\n+    /// Glob import, e.g. `use foo::*`.\n+    Glob,\n \n-    /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, HirVec<PathListItem>),\n+    /// Degenerate list import, e.g. `use foo::{a, b}` produces\n+    /// an additional `use foo::{}` for performing checks such as\n+    /// unstable feature gating. May be removed in the future.\n+    ListStem,\n }\n \n /// TraitRef's appear in impls.\n@@ -1534,8 +1533,13 @@ pub enum Item_ {\n     ///\n     /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ItemExternCrate(Option<Name>),\n-    /// A `use` or `pub use` item\n-    ItemUse(P<ViewPath>),\n+\n+    /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n+    ///\n+    /// or just\n+    ///\n+    /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n+    ItemUse(P<Path>, UseKind),\n \n     /// A `static` item\n     ItemStatic(P<Ty>, Mutability, P<Expr>),"}, {"sha": "0190e74df69533e0be712482fe9fe99a24c1d78e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 122, "deletions": 118, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::*;\n+use hir::def::Def;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n-use ty::TyCtxt;\n use syntax::ast;\n use syntax::codemap::Spanned;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n@@ -51,139 +50,144 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(Some(..), _) => true,\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n-                _ => false\n+impl hir::Pat {\n+    pub fn is_refutable(&self) -> bool {\n+        match self.node {\n+            PatKind::Lit(_) |\n+            PatKind::Range(..) |\n+            PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Variant(..) | Def::VariantCtor(..) => true,\n+                    _ => false\n+                }\n             }\n+            PatKind::Slice(..) => true,\n+            _ => false\n         }\n-        PatKind::Slice(..) => true,\n-        _ => false\n     }\n-}\n \n-pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n+    pub fn is_const(&self) -> bool {\n+        match self.node {\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Const(..) | Def::AssociatedConst(..) => true,\n+                    _ => false\n+                }\n             }\n+            _ => false\n         }\n-        _ => false\n     }\n-}\n \n-/// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n-/// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)\n-    where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n-{\n-    pat.walk(|p| {\n-        if let PatKind::Binding(binding_mode, ref pth, _) = p.node {\n-            f(binding_mode, p.id, p.span, pth);\n-        }\n-        true\n-    });\n-}\n-\n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        if let PatKind::Binding(..) = p.node {\n-            contains_bindings = true;\n-            false // there's at least one binding, can short circuit now.\n-        } else {\n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`\n+    pub fn each_binding<F>(&self, mut f: F)\n+        where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+    {\n+        self.walk(|p| {\n+            if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n+                f(binding_mode, p.id, p.span, pth);\n+            }\n             true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+    }\n \n-/// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-/// and if yes whether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(pat: &hir::Pat) -> Option<hir::Mutability> {\n-    let mut result = None;\n-    pat_bindings(pat, |mode, _, _, _| {\n-        if let hir::BindingMode::BindByRef(m) = mode {\n-            // Pick Mutable as maximum\n-            match result {\n-                None | Some(hir::MutImmutable) => result = Some(m),\n-                _ => (),\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n+    pub fn contains_bindings(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            if let PatKind::Binding(..) = p.node {\n+                contains_bindings = true;\n+                false // there's at least one binding, can short circuit now.\n+            } else {\n+                true\n             }\n-        }\n-    });\n-    result\n-}\n-\n-/// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-/// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(arm: &hir::Arm) -> Option<hir::Mutability> {\n-    arm.pats.iter()\n-            .filter_map(|pat| pat_contains_ref_binding(pat))\n-            .max_by_key(|m| match *m {\n-                hir::MutMutable => 1,\n-                hir::MutImmutable => 0,\n-            })\n-}\n+        });\n+        contains_bindings\n+    }\n \n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::Binding(..) | PatKind::Wild => {\n-                contains_bindings = true;\n-                false // there's at least one binding/wildcard, can short circuit now.\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+    pub fn contains_bindings_or_wild(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Binding(..) | PatKind::Wild => {\n+                    contains_bindings = true;\n+                    false // there's at least one binding/wildcard, can short circuit now.\n+                }\n+                _ => true\n             }\n-            _ => true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+        contains_bindings\n+    }\n \n-pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n-    match pat.node {\n-        PatKind::Binding(hir::BindByValue(..), ref path1, None) => {\n-            Some(path1.node)\n-        }\n-        _ => {\n-            None\n+    pub fn simple_name(&self) -> Option<ast::Name> {\n+        match self.node {\n+            PatKind::Binding(hir::BindByValue(..), _, ref path1, None) => {\n+                Some(path1.node)\n+            }\n+            _ => {\n+                None\n+            }\n         }\n     }\n-}\n \n-pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n-    hir::Path::from_name(DUMMY_SP, tcx.item_name(id))\n-}\n+    /// Return variants that are necessary to exist for the pattern to match.\n+    pub fn necessary_variants(&self) -> Vec<DefId> {\n+        let mut variants = vec![];\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                    match path.def {\n+                        Def::Variant(id) |\n+                        Def::VariantCtor(id, ..) => variants.push(id),\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+            true\n+        });\n+        variants.sort();\n+        variants.dedup();\n+        variants\n+    }\n \n-/// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n-    let mut variants = vec![];\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::TupleStruct(..) |\n-            PatKind::Path(..) |\n-            PatKind::Struct(..) => {\n-                match dm.get(&p.id).map(|d| d.full_def()) {\n-                    Some(Def::Variant(id)) |\n-                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n-                    _ => ()\n+    /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n+    /// and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        let mut result = None;\n+        self.each_binding(|mode, _, _, _| {\n+            if let hir::BindingMode::BindByRef(m) = mode {\n+                // Pick Mutable as maximum\n+                match result {\n+                    None | Some(hir::MutImmutable) => result = Some(m),\n+                    _ => (),\n                 }\n             }\n-            _ => ()\n-        }\n-        true\n-    });\n-    variants.sort();\n-    variants.dedup();\n-    variants\n+        });\n+        result\n+    }\n+}\n+\n+impl hir::Arm {\n+    /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n+    /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        self.pats.iter()\n+                 .filter_map(|pat| pat.contains_ref_binding())\n+                 .max_by_key(|m| match *m {\n+                    hir::MutMutable => 1,\n+                    hir::MutImmutable => 0,\n+                 })\n+    }\n }"}, {"sha": "31a8539119398b42c9995c2c48ba7b5196ad287a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 102, "deletions": 90, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -272,7 +272,11 @@ pub fn fn_block_to_string(p: &hir::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &hir::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n+    to_string(|s| s.print_path(p, false))\n+}\n+\n+pub fn qpath_to_string(p: &hir::QPath) -> String {\n+    to_string(|s| s.print_qpath(p, false))\n }\n \n pub fn name_to_string(name: ast::Name) -> String {\n@@ -528,11 +532,8 @@ impl<'a> State<'a> {\n                 };\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n-            hir::TyPath(None, ref path) => {\n-                self.print_path(path, false, 0)?;\n-            }\n-            hir::TyPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?\n+            hir::TyPath(ref qpath) => {\n+                self.print_qpath(qpath, false)?\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n                 self.print_type(&ty)?;\n@@ -668,10 +669,22 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemUse(ref vp) => {\n+            hir::ItemUse(ref path, kind) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n-                self.print_view_path(&vp)?;\n-                word(&mut self.s, \";\")?;\n+                self.print_path(path, false)?;\n+\n+                match kind {\n+                    hir::UseKind::Single => {\n+                        if path.segments.last().unwrap().name != item.name {\n+                            space(&mut self.s)?;\n+                            self.word_space(\"as\")?;\n+                            self.print_name(item.name)?;\n+                        }\n+                        word(&mut self.s, \";\")?;\n+                    }\n+                    hir::UseKind::Glob => word(&mut self.s, \"::*;\")?,\n+                    hir::UseKind::ListStem => word(&mut self.s, \"::{};\")?\n+                }\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -844,8 +857,8 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeItem(item))\n     }\n \n-    fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0)\n+    pub fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n+        self.print_path(&t.path, false)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n@@ -1115,8 +1128,6 @@ impl<'a> State<'a> {\n             hir::UnsafeBlock(..) => self.word_space(\"unsafe\")?,\n             hir::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\")?,\n             hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\")?,\n-            hir::PushUnstableBlock => self.word_space(\"push_unstable\")?,\n-            hir::PopUnstableBlock => self.word_space(\"pop_unstable\")?,\n             hir::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo)?;\n@@ -1237,11 +1248,11 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_struct(&mut self,\n-                         path: &hir::Path,\n+                         qpath: &hir::QPath,\n                          fields: &[hir::Field],\n                          wth: &Option<P<hir::Expr>>)\n                          -> io::Result<()> {\n-        self.print_path(path, true, 0)?;\n+        self.print_qpath(qpath, true)?;\n         word(&mut self.s, \"{\")?;\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n@@ -1345,8 +1356,8 @@ impl<'a> State<'a> {\n             hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, &count)?;\n             }\n-            hir::ExprStruct(ref path, ref fields, ref wth) => {\n-                self.print_expr_struct(path, &fields[..], wth)?;\n+            hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n+                self.print_expr_struct(qpath, &fields[..], wth)?;\n             }\n             hir::ExprTup(ref exprs) => {\n                 self.print_expr_tup(exprs)?;\n@@ -1465,29 +1476,26 @@ impl<'a> State<'a> {\n                 self.print_expr(&index)?;\n                 word(&mut self.s, \"]\")?;\n             }\n-            hir::ExprPath(None, ref path) => {\n-                self.print_path(path, true, 0)?\n+            hir::ExprPath(ref qpath) => {\n+                self.print_qpath(qpath, true)?\n             }\n-            hir::ExprPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, true)?\n-            }\n-            hir::ExprBreak(opt_name, ref opt_expr) => {\n+            hir::ExprBreak(opt_label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_name) => {\n+            hir::ExprAgain(opt_label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?\n                 }\n             }\n@@ -1622,13 +1630,12 @@ impl<'a> State<'a> {\n \n     fn print_path(&mut self,\n                   path: &hir::Path,\n-                  colons_before_params: bool,\n-                  depth: usize)\n+                  colons_before_params: bool)\n                   -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n         let mut first = !path.global;\n-        for segment in &path.segments[..path.segments.len() - depth] {\n+        for segment in &path.segments {\n             if first {\n                 first = false\n             } else {\n@@ -1644,31 +1651,61 @@ impl<'a> State<'a> {\n     }\n \n     fn print_qpath(&mut self,\n-                   path: &hir::Path,\n-                   qself: &hir::QSelf,\n+                   qpath: &hir::QPath,\n                    colons_before_params: bool)\n                    -> io::Result<()> {\n-        word(&mut self.s, \"<\")?;\n-        self.print_type(&qself.ty)?;\n-        if qself.position > 0 {\n-            space(&mut self.s)?;\n-            self.word_space(\"as\")?;\n-            let depth = path.segments.len() - qself.position;\n-            self.print_path(&path, false, depth)?;\n+        match *qpath {\n+            hir::QPath::Resolved(None, ref path) => {\n+                self.print_path(path, colons_before_params)\n+            }\n+            hir::QPath::Resolved(Some(ref qself), ref path) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                space(&mut self.s)?;\n+                self.word_space(\"as\")?;\n+\n+                let mut first = !path.global;\n+                for segment in &path.segments[..path.segments.len() - 1] {\n+                    if first {\n+                        first = false\n+                    } else {\n+                        word(&mut self.s, \"::\")?\n+                    }\n+                    self.print_name(segment.name)?;\n+                    self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                }\n+\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                let item_segment = path.segments.last().unwrap();\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n         }\n-        word(&mut self.s, \">\")?;\n-        word(&mut self.s, \"::\")?;\n-        let item_segment = path.segments.last().unwrap();\n-        self.print_name(item_segment.name)?;\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if parameters.is_empty() {\n-            return Ok(());\n+            let infer_types = match *parameters {\n+                hir::AngleBracketedParameters(ref data) => data.infer_types,\n+                hir::ParenthesizedParameters(_) => false\n+            };\n+\n+            // FIXME(eddyb) See the comment below about infer_types.\n+            if !(infer_types && false) {\n+                return Ok(());\n+            }\n         }\n \n         if colons_before_params {\n@@ -1696,6 +1733,16 @@ impl<'a> State<'a> {\n                     comma = true;\n                 }\n \n+                // FIXME(eddyb) This would leak into error messages, e.g.:\n+                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+                if data.infer_types && false {\n+                    if comma {\n+                        self.word_space(\",\")?\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    comma = true;\n+                }\n+\n                 for binding in data.bindings.iter() {\n                     if comma {\n                         self.word_space(\",\")?\n@@ -1733,7 +1780,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => word(&mut self.s, \"_\")?,\n-            PatKind::Binding(binding_mode, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -1750,8 +1797,8 @@ impl<'a> State<'a> {\n                     self.print_pat(&p)?;\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::TupleStruct(ref qpath, ref elts, ddpos) => {\n+                self.print_qpath(qpath, true)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n@@ -1768,14 +1815,11 @@ impl<'a> State<'a> {\n                 }\n                 self.pclose()?;\n             }\n-            PatKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::Path(ref qpath) => {\n+                self.print_qpath(qpath, true)?;\n             }\n-            PatKind::Path(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?;\n-            }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.print_qpath(qpath, true)?;\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(Consistent,\n@@ -2108,7 +2152,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    self.print_path(path, false, 0)?;\n+                    self.print_path(path, false)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&ty)?;\n@@ -2119,38 +2163,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_view_path(&mut self, vp: &hir::ViewPath) -> io::Result<()> {\n-        match vp.node {\n-            hir::ViewPathSimple(name, ref path) => {\n-                self.print_path(path, false, 0)?;\n-\n-                if path.segments.last().unwrap().name != name {\n-                    space(&mut self.s)?;\n-                    self.word_space(\"as\")?;\n-                    self.print_name(name)?;\n-                }\n-\n-                Ok(())\n-            }\n-\n-            hir::ViewPathGlob(ref path) => {\n-                self.print_path(path, false, 0)?;\n-                word(&mut self.s, \"::*\")\n-            }\n-\n-            hir::ViewPathList(ref path, ref segments) => {\n-                if path.segments.is_empty() {\n-                    word(&mut self.s, \"{\")?;\n-                } else {\n-                    self.print_path(path, false, 0)?;\n-                    word(&mut self.s, \"::{\")?;\n-                }\n-                self.commasep(Inconsistent, &segments[..], |s, w| s.print_name(w.node.name))?;\n-                word(&mut self.s, \"}\")\n-            }\n-        }\n-    }\n-\n     pub fn print_mutability(&mut self, mutbl: hir::Mutability) -> io::Result<()> {\n         match mutbl {\n             hir::MutMutable => self.word_nbsp(\"mut\"),\n@@ -2171,7 +2183,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Binding(_, name, _) = input.pat.node {\n+                    let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n                         name.node == keywords::Invalid.name()\n                     } else {\n                         false"}, {"sha": "90d752ae6ee297db8100658c6e236c59739d0b4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1440,8 +1440,8 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     }\n                     ty_queue.push(&mut_ty.ty);\n                 }\n-                hir::TyPath(ref maybe_qself, ref path) => {\n-                    match self.tcx.expect_def(cur_ty.id) {\n+                hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+                    match path.def {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n                             let generics = self.tcx.item_generics(did);\n@@ -1476,15 +1476,12 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n                             let qself = maybe_qself.as_ref().map(|qself| {\n-                                hir::QSelf {\n-                                    ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n-                                                                      anon_nums, region_names),\n-                                    position: qself.position\n-                                }\n+                                self.rebuild_arg_ty_or_output(qself, lifetime,\n+                                                              anon_nums, region_names)\n                             });\n                             let to = hir::Ty {\n                                 id: cur_ty.id,\n-                                node: hir::TyPath(qself, new_path),\n+                                node: hir::TyPath(hir::QPath::Resolved(qself, P(new_path))),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));\n@@ -1609,6 +1606,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                     lifetimes: new_lts.into(),\n                     types: new_types,\n+                    infer_types: data.infer_types,\n                     bindings: new_bindings,\n                })\n             }\n@@ -1623,6 +1621,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n+            def: path.def,\n             segments: new_segs.into()\n         }\n     }"}, {"sha": "78d5067b273a5db1ef56f2bbbe209d8428018b5b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -211,6 +211,12 @@ declare_lint! {\n      not named `mod.rs`\"\n }\n \n+declare_lint! {\n+    pub DEPRECATED,\n+    Warn,\n+    \"detects use of deprecated items\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -250,7 +256,8 @@ impl LintPass for HardwiredLints {\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n             EXTRA_REQUIREMENT_IN_IMPL,\n-            LEGACY_DIRECTORY_OWNERSHIP\n+            LEGACY_DIRECTORY_OWNERSHIP,\n+            DEPRECATED\n         )\n     }\n }"}, {"sha": "41c8d413486dc72c37bf4fcec4a64d26be0b733a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -948,11 +948,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n-        run_lints!(self, check_path_list_item, late_passes, item);\n-        hir_visit::walk_path_list_item(self, prefix, item);\n-    }\n-\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         check_lint_name_attribute(self, attr);\n         run_lints!(self, check_attribute, late_passes, attr);"}, {"sha": "4e06e0abf0148b6543348e1eac670a8c59a3274d", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -168,7 +168,6 @@ pub trait LateLintPass: LintPass {\n     fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n     fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_path_list_item(&mut self, _: &LateContext, _: &hir::PathListItem) { }\n     fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such"}, {"sha": "3418034b069d606c7b4f084b0fa6ce5035d6bb17", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,14 +14,14 @@\n  * Almost certainly this could (and should) be refactored out of existence.\n  */\n \n+use hir;\n use hir::def::Def;\n use ty::{Ty, TyCtxt};\n \n use syntax_pos::Span;\n-use hir as ast;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n+    pub fn prohibit_type_params(self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n             for typ in segment.parameters.types() {\n                 struct_span_err!(self.sess, typ.span, E0109,\n@@ -53,25 +53,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn prim_ty_to_ty(self,\n-                         segments: &[ast::PathSegment],\n-                         nty: ast::PrimTy)\n+                         segments: &[hir::PathSegment],\n+                         nty: hir::PrimTy)\n                          -> Ty<'tcx> {\n         self.prohibit_type_params(segments);\n         match nty {\n-            ast::TyBool => self.types.bool,\n-            ast::TyChar => self.types.char,\n-            ast::TyInt(it) => self.mk_mach_int(it),\n-            ast::TyUint(uit) => self.mk_mach_uint(uit),\n-            ast::TyFloat(ft) => self.mk_mach_float(ft),\n-            ast::TyStr => self.mk_str()\n+            hir::TyBool => self.types.bool,\n+            hir::TyChar => self.types.char,\n+            hir::TyInt(it) => self.mk_mach_int(it),\n+            hir::TyUint(uit) => self.mk_mach_uint(uit),\n+            hir::TyFloat(ft) => self.mk_mach_float(ft),\n+            hir::TyStr => self.mk_str()\n         }\n     }\n \n     /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n     /// to it.\n-    pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n-        if let ast::TyPath(None, ref path) = ast_ty.node {\n-            if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n+    pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n+        if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+            if let Def::PrimTy(nty) = path.def {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {\n                 None"}, {"sha": "618e2b05f13b7f61a249b73aefd2b79111c505e2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,7 +14,7 @@\n \n use dep_graph::DepNode;\n use hir::map as ast_map;\n-use hir::{self, pat_util, PatKind};\n+use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -86,9 +86,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        let def = self.tcx.expect_def(id);\n-\n+    fn handle_definition(&mut self, id: ast::NodeId, def: Def) {\n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n@@ -147,12 +145,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n-            ty::TyAdt(adt, _) => {\n-                adt.variant_of_def(self.tcx.expect_def(lhs.id))\n-            }\n+            ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -240,6 +236,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n+            hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                self.handle_definition(expr.id, def);\n+            }\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }\n@@ -257,8 +257,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n         if arm.pats.len() == 1 {\n-            let pat = &*arm.pats[0];\n-            let variants = pat_util::necessary_variants(&self.tcx.def_map.borrow(), pat);\n+            let variants = arm.pats[0].necessary_variants();\n \n             // Inside the body, ignore constructions of variants\n             // necessary for the pattern to match. Those construction sites\n@@ -273,14 +272,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n-        let def_map = &self.tcx.def_map;\n         match pat.node {\n-            PatKind::Struct(_, ref fields, _) => {\n-                self.handle_field_pattern_match(pat, fields);\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n+                self.handle_field_pattern_match(pat, path.def, fields);\n             }\n-            _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n-                // it might be the only use of a const\n-                self.lookup_and_handle_definition(pat.id)\n+            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                self.handle_definition(pat.id, def);\n             }\n             _ => ()\n         }\n@@ -291,14 +289,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(id);\n+        self.handle_definition(id, path.def);\n         intravisit::walk_path(self, path);\n     }\n-\n-    fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n-        self.lookup_and_handle_definition(item.node.id);\n-        intravisit::walk_path_list_item(self, path, item);\n-    }\n }\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {"}, {"sha": "1313a3504c0bddfe6010866c20bc22a421523356", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n             }\n-            hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock => {}\n+            hir::DefaultBlock => {}\n         }\n \n         intravisit::walk_block(self, block);\n@@ -186,8 +186,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             hir::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            hir::ExprPath(..) => {\n-                if let Def::Static(def_id, mutbl) = self.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Static(def_id, mutbl) = path.def {\n                     if mutbl {\n                         self.require_unsafe(expr.span, \"use of mutable static\");\n                     } else if match self.tcx.map.get_if_local(def_id) {"}, {"sha": "01d5792441f82455de973efc4509977151593921", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -19,7 +19,6 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use hir::pat_util;\n use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n@@ -374,7 +373,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprPath(..) => { }\n+            hir::ExprPath(_) => { }\n \n             hir::ExprType(ref subexpr, _) => {\n                 self.walk_expr(&subexpr)\n@@ -622,7 +621,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&local.pat, |_, id, span, _| {\n+                local.pat.each_binding(|_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n@@ -957,16 +956,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, ..) = pat.node {\n+            if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                    tcx.expect_def(pat.id)) {\n+                let def = Def::Local(def_id);\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -992,9 +991,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(variant_did)) |\n-                Some(Def::VariantCtor(variant_did, ..)) => {\n+            let qpath = match pat.node {\n+                PatKind::Path(ref qpath) |\n+                PatKind::TupleStruct(ref qpath, ..) |\n+                PatKind::Struct(ref qpath, ..) => qpath,\n+                _ => return\n+            };\n+            let def = tcx.tables().qpath_def(qpath, pat.id);\n+            match def {\n+                Def::Variant(variant_did) |\n+                Def::VariantCtor(variant_did, ..) => {\n                     let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n@@ -1006,14 +1012,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n+                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                None | Some(Def::Local(..)) |\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n-                def => bug!(\"unexpected definition: {:?}\", def)\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "0014d17abb7f27b7717f9aed1b557cff935c7a21", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -160,23 +160,26 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n \n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        if let hir::ExprPath(..) = expr.node {\n-            match self.infcx.tcx.expect_def(expr.id) {\n-                Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n-                    match typ.sty {\n-                        ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            let from = bare_fn_ty.sig.0.inputs[0];\n-                            let to = bare_fn_ty.sig.0.output;\n-                            self.check_transmute(expr.span, from, to, expr.id);\n-                        }\n-                        _ => {\n-                            span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                        }\n+        let def = if let hir::ExprPath(ref qpath) = expr.node {\n+            self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n+        } else {\n+            Def::Err\n+        };\n+        match def {\n+            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+                let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n+                match typ.sty {\n+                    ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        let from = bare_fn_ty.sig.0.inputs[0];\n+                        let to = bare_fn_ty.sig.0.output;\n+                        self.check_transmute(expr.span, from, to, expr.id);\n+                    }\n+                    _ => {\n+                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n                     }\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "eb00238492ee14dbe4ae4fecd79e791e84d60b16", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -111,7 +111,6 @@ use self::VarKind::*;\n \n use dep_graph::DepNode;\n use hir::def::*;\n-use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n@@ -379,7 +378,7 @@ fn visit_fn(ir: &mut IrMaps,\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in &decl.inputs {\n-        pat_util::pat_bindings(&arg.pat, |_bm, arg_id, _x, path1| {\n+        arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n@@ -412,7 +411,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&local.pat, |_, p_id, sp, path1| {\n+    local.pat.each_binding(|_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -426,7 +425,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&pat, |bm, p_id, sp, path1| {\n+        pat.each_binding(|bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -443,10 +442,9 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(..) => {\n-        let def = ir.tcx.expect_def(expr.id);\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if let Def::Local(..) = def {\n+      hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n@@ -495,7 +493,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -587,7 +585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        pat_util::pat_bindings(pat, |_bm, p_id, sp, _n| {\n+        pat.each_binding(|_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -684,22 +682,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<ast::Name>,\n-                       id: NodeId,\n+                       opt_label: Option<hir::Label>,\n                        sp: Span)\n                        -> NodeId {\n         match opt_label {\n-            Some(_) => {\n-                // Refers to a labeled loop. Use the results of resolve\n-                // to find with one\n-                match self.ir.tcx.expect_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => span_bug!(sp, \"label on break/loop \\\n-                                        doesn't refer to a loop\")\n-                }\n-            }\n+            Some(label) => label.loop_id,\n             None => {\n-                // Vanilla 'break' or 'loop', so use the enclosing\n+                // Vanilla 'break' or 'continue', so use the enclosing\n                 // loop scope\n                 if self.loop_scope.is_empty() {\n                     span_bug!(sp, \"break outside loop\");\n@@ -922,8 +911,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          hir::ExprPath(..) => {\n-              self.access_path(expr, succ, ACC_READ | ACC_USE)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n           }\n \n           hir::ExprField(ref e, _) => {\n@@ -1037,7 +1026,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(opt_label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1050,7 +1039,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1171,7 +1160,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(inputs, succ)\n           }\n \n-          hir::ExprLit(..) => {\n+          hir::ExprLit(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n             succ\n           }\n \n@@ -1235,7 +1224,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            hir::ExprPath(..) => succ,\n+            hir::ExprPath(_) => succ,\n             hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n             hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1246,8 +1235,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(..) => {\n-              self.access_path(expr, succ, acc)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, acc)\n           }\n \n           // We do not track other lvalues, so just propagate through\n@@ -1258,15 +1247,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n+    fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.expect_def(expr.id) {\n+        match path.def {\n           Def::Local(def_id) => {\n             let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(id, path.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n-                let var = self.variable(nid, expr.span);\n+                let var = self.variable(nid, path.span);\n                 self.acc(ln, var, acc);\n             }\n             ln\n@@ -1431,8 +1420,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprClosure(..) | hir::ExprPath(_) |\n+      hir::ExprBox(..) | hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }\n@@ -1482,8 +1471,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            hir::ExprPath(..) => {\n-                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Local(def_id) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n@@ -1513,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n-            pat_util::pat_bindings(&arg.pat, |_bm, p_id, sp, path1| {\n+            arg.pat.each_binding(|_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;"}, {"sha": "8d3e734f8c33f8e6735660caf23d152c91d32a25", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -488,8 +488,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(..) => {\n-            self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n+          hir::ExprPath(ref qpath) => {\n+            let def = self.infcx.tables.borrow().qpath_def(qpath, expr.id);\n+            self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -1062,24 +1063,32 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because PatKind::Struct can also refer to variants.\n-        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n-            Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(variant_did)) |\n-            Some(Def::VariantCtor(variant_did, ..)) => {\n-                // univariant enums do not need downcasts\n-                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n-                    self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n-                } else {\n-                    cmt\n+        let cmt = match pat.node {\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Err => return Err(()),\n+                    Def::Variant(variant_did) |\n+                    Def::VariantCtor(variant_did, ..) => {\n+                        // univariant enums do not need downcasts\n+                        let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                        if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n+                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                        } else {\n+                            cmt\n+                        }\n+                    }\n+                    _ => cmt\n                 }\n             }\n             _ => cmt\n         };\n \n         match pat.node {\n-          PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            let expected_len = match self.tcx().expect_def(pat.id) {\n+          PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+            let def = self.infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n@@ -1157,7 +1166,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::Binding(.., None) |\n+          PatKind::Path(_) | PatKind::Binding(.., None) |\n           PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n             // always ok\n           }"}, {"sha": "b17d41e0fa544da01b581b5c1748fa73bc401067", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -90,45 +90,40 @@ struct ReachableContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n-            hir::ExprPath(..) => {\n-                let def = self.tcx.expect_def(expr.id);\n-                let def_id = def.def_id();\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n-                    } else {\n-                        match def {\n-                            // If this path leads to a constant, then we need to\n-                            // recurse into the constant to continue finding\n-                            // items that are reachable.\n-                            Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n-                            }\n-\n-                            // If this wasn't a static, then the destination is\n-                            // surely reachable.\n-                            _ => {\n-                                self.reachable_symbols.insert(node_id);\n-                            }\n-                        }\n-                    }\n-                }\n+        let def = match expr.node {\n+            hir::ExprPath(ref qpath) => {\n+                Some(self.tcx.tables().qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                Some(Def::Method(def_id))\n+            }\n+            _ => None\n+        };\n+\n+        if let Some(def) = def {\n+            let def_id = def.def_id();\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                if self.def_id_represents_local_inlined_item(def_id) {\n+                    self.worklist.push(node_id);\n+                } else {\n+                    match def {\n+                        // If this path leads to a constant, then we need to\n+                        // recurse into the constant to continue finding\n+                        // items that are reachable.\n+                        Def::Const(..) | Def::AssociatedConst(..) => {\n+                            self.worklist.push(node_id);\n+                        }\n \n-                // Mark the trait item (and, possibly, its default impl) as reachable\n-                // Or mark inherent impl item as reachable\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id)\n+                        // If this wasn't a static, then the destination is\n+                        // surely reachable.\n+                        _ => {\n+                            self.reachable_symbols.insert(node_id);\n+                        }\n                     }\n-                    self.reachable_symbols.insert(node_id);\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)\n@@ -265,7 +260,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    hir::ItemExternCrate(_) | hir::ItemUse(_) |\n+                    hir::ItemExternCrate(_) | hir::ItemUse(..) |\n                     hir::ItemTy(..) | hir::ItemStatic(..) |\n                     hir::ItemMod(..) | hir::ItemForeignMod(..) |\n                     hir::ItemImpl(..) | hir::ItemTrait(..) |\n@@ -303,7 +298,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // Nothing to recurse on for these\n             ast_map::NodeForeignItem(_) |\n             ast_map::NodeVariant(_) |\n-            ast_map::NodeStructCtor(_) => {}\n+            ast_map::NodeStructCtor(_) |\n+            ast_map::NodeField(_) |\n+            ast_map::NodeTy(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.map.node_to_string(search_item))"}, {"sha": "d07062f98a9d14fad85ec64190ca1b92b0ff2bf1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -21,7 +21,7 @@ use self::ScopeChain::*;\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n-use hir::def::{Def, DefMap};\n+use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n@@ -65,7 +65,6 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n-    def_map: &'a DefMap,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -109,8 +108,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session,\n-             hir_map: &Map,\n-             def_map: &DefMap)\n+             hir_map: &Map)\n              -> Result<NamedRegionMap, usize> {\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n@@ -124,7 +122,6 @@ pub fn krate(sess: &Session,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: &ROOT_SCOPE,\n-            def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         }, krate);\n@@ -151,7 +148,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item);\n                 }\n                 hir::ItemExternCrate(_) |\n-                hir::ItemUse(_) |\n+                hir::ItemUse(..) |\n                 hir::ItemMod(..) |\n                 hir::ItemDefaultImpl(..) |\n                 hir::ItemForeignMod(..) |\n@@ -244,11 +241,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyPath(None, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n-                match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n-                    Some((Def::Trait(..), 0)) => {\n+                match path.def {\n+                    Def::Trait(..) => {\n                         self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n@@ -541,7 +538,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n-            def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n             labels_in_fn: self.labels_in_fn.clone(),\n         };\n@@ -944,13 +940,14 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     impl<'v> Visitor<'v> for ConstrainedCollector {\n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(Some(_), _) => {\n+                hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n+                hir::TyPath(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)\n                 }\n \n-                hir::TyPath(None, ref path) => {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "f5e18e13465d89f71cec22b6ddb7fff8162683eb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 213, "deletions": 305, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -15,11 +15,10 @@ pub use self::StabilityLevel::*;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use session::Session;\n use lint;\n use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n-use ty::{self, TyCtxt, AdtKind};\n+use ty::TyCtxt;\n use middle::privacy::AccessLevels;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -30,9 +29,9 @@ use syntax::attr::{self, Stability, Deprecation};\n use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n-use hir::{Item, Generics, StructField, Variant, PatKind};\n+use hir::{Item, Generics, StructField, Variant};\n use hir::intravisit::{self, Visitor};\n-use hir::pat_util::EnumerateAndAdjustIterator;\n+use hir::itemlikevisit::DeepVisitor;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -101,7 +100,13 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FxHashMap<CrateNum, bool>\n+    staged_api: FxHashMap<CrateNum, bool>,\n+\n+    /// Features enabled for this crate.\n+    active_features: FxHashSet<Symbol>,\n+\n+    /// Features used by this crate. Updated before and during typeck.\n+    used_features: FxHashMap<Symbol, attr::StabilityLevel>\n }\n \n // A private tree-walker for producing an Index.\n@@ -110,7 +115,6 @@ struct Annotator<'a, 'tcx: 'a> {\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n-    access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n }\n \n@@ -183,20 +187,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 self.parent_stab = orig_parent_stab;\n             } else {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n-                let mut is_error = kind == AnnotationKind::Required &&\n-                                   self.access_levels.is_reachable(id) &&\n-                                   !self.tcx.sess.opts.test;\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n                         let def_id = self.tcx.map.local_def_id(id);\n                         self.index.stab_map.insert(def_id, Some(stab));\n-                        is_error = false;\n                     }\n                 }\n-                if is_error {\n-                    self.tcx.sess.span_err(item_sp, \"This node does not have \\\n-                                                     a stability attribute\");\n-                }\n                 visit_children(self);\n             }\n         } else {\n@@ -313,17 +309,88 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n }\n \n+struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &'a AccessLevels,\n+}\n+\n+impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n+    fn check_missing_stability(&self, id: NodeId, span: Span) {\n+        let def_id = self.tcx.map.local_def_id(id);\n+        let is_error = !self.tcx.sess.opts.test &&\n+                        !self.tcx.stability.borrow().stab_map.contains_key(&def_id) &&\n+                        self.access_levels.is_reachable(id);\n+        if is_error {\n+            self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for MissingStabilityAnnotations<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &Item) {\n+        match i.node {\n+            // Inherent impls and foreign modules serve only as containers for other items,\n+            // they don't have their own stability. They still can be annotated as unstable\n+            // and propagate this unstability to children, but this annotation is completely\n+            // optional. They inherit stability from their parents when unannotated.\n+            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {}\n+\n+            _ => self.check_missing_stability(i.id, i.span)\n+        }\n+\n+        intravisit::walk_item(self, i)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+        self.check_missing_stability(ti.id, ti.span);\n+        intravisit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+        let impl_def_id = self.tcx.map.local_def_id(self.tcx.map.get_parent(ii.id));\n+        if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n+            self.check_missing_stability(ii.id, ii.span);\n+        }\n+        intravisit::walk_impl_item(self, ii);\n+    }\n+\n+    fn visit_variant(&mut self, var: &Variant, g: &Generics, item_id: NodeId) {\n+        self.check_missing_stability(var.node.data.id(), var.span);\n+        intravisit::walk_variant(self, var, g, item_id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &StructField) {\n+        self.check_missing_stability(s.id, s.span);\n+        intravisit::walk_struct_field(self, s);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+        self.check_missing_stability(i.id, i.span);\n+        intravisit::walk_foreign_item(self, i);\n+    }\n+\n+    fn visit_macro_def(&mut self, md: &hir::MacroDef) {\n+        if md.imported_from.is_none() {\n+            self.check_missing_stability(md.id, md.span);\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n+\n+        // Put the active features into a map for quick lookup\n+        self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n             parent_stab: None,\n             parent_depr: None,\n-            access_levels: access_levels,\n             in_trait_impl: false,\n         };\n         annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n@@ -348,347 +415,174 @@ impl<'a, 'tcx> Index<'tcx> {\n             staged_api: staged_api,\n             stab_map: DefIdMap(),\n             depr_map: DefIdMap(),\n+            active_features: FxHashSet(),\n+            used_features: FxHashMap(),\n         }\n     }\n }\n \n /// Cross-references the feature names of unstable APIs with enabled\n-/// features and possibly prints errors. Returns a list of all\n-/// features used.\n-pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FxHashMap<Symbol, attr::StabilityLevel> {\n-    let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n-    let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n-\n-    // Put the active features into a map for quick lookup\n-    let active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n-\n-    let mut checker = Checker {\n-        tcx: tcx,\n-        active_features: active_features,\n-        used_features: FxHashMap(),\n-        in_skip_block: 0,\n-    };\n-    intravisit::walk_crate(&mut checker, tcx.map.krate());\n-\n-    checker.used_features\n+/// features and possibly prints errors.\n+pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut checker = Checker { tcx: tcx };\n+    tcx.visit_all_item_likes_in_krate(DepNode::StabilityCheck,\n+                                      &mut DeepVisitor::new(&mut checker));\n }\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FxHashSet<Symbol>,\n-    used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n-    // Within a block where feature gate checking can be skipped.\n-    in_skip_block: u32,\n }\n \n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: DefId, span: Span,\n-             stab: &Option<&Stability>, _depr: &Option<DeprecationEntry>) {\n-        if !is_staged_api(self.tcx, id) {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n+        if self.sess.codemap().span_allows_unstable(span) {\n+            debug!(\"stability: \\\n+                    skipping span={:?} since it is internal\", span);\n+            return;\n+        }\n+\n+        let lint_deprecated = |note: Option<Symbol>| {\n+            let msg = if let Some(note) = note {\n+                format!(\"use of deprecated item: {}\", note)\n+            } else {\n+                format!(\"use of deprecated item\")\n+            };\n+\n+            self.sess.add_lint(lint::builtin::DEPRECATED, id, span, msg);\n+        };\n+\n+        // Deprecated attributes apply in-crate and cross-crate.\n+        if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n+            let skip = if id == ast::DUMMY_NODE_ID {\n+                true\n+            } else {\n+                let parent_def_id = self.map.local_def_id(self.map.get_parent(id));\n+                self.lookup_deprecation_entry(parent_def_id).map_or(false, |parent_depr| {\n+                    parent_depr.same_origin(&depr_entry)\n+                })\n+            };\n+\n+            if !skip {\n+                lint_deprecated(depr_entry.attr.note);\n+            }\n+        }\n+\n+        let is_staged_api = *self.stability.borrow_mut().staged_api.entry(def_id.krate)\n+            .or_insert_with(|| self.sess.cstore.is_staged_api(def_id.krate));\n+        if !is_staged_api {\n             return;\n         }\n+\n+        let stability = self.lookup_stability(def_id);\n+        debug!(\"stability: \\\n+                inspecting def_id={:?} span={:?} of stability={:?}\", def_id, span, stability);\n+\n+        if let Some(&Stability{rustc_depr: Some(attr::RustcDeprecation { reason, .. }), ..})\n+                = stability {\n+            if id != ast::DUMMY_NODE_ID {\n+                lint_deprecated(Some(reason));\n+            }\n+        }\n+\n         // Only the cross-crate scenario matters when checking unstable APIs\n-        let cross_crate = !id.is_local();\n+        let cross_crate = !def_id.is_local();\n         if !cross_crate {\n             return\n         }\n \n-        // We don't need to check for stability - presumably compiler generated code.\n-        if self.in_skip_block > 0 {\n-            return;\n+        if let Some(&Stability { ref level, ref feature, .. }) = stability {\n+            self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n         }\n \n-        match *stab {\n+        match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                self.used_features.insert(feature.clone(),\n-                                          attr::Unstable { reason: reason.clone(), issue: issue });\n-\n-                if !self.active_features.contains(feature) {\n+                if !self.stability.borrow().active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n                                                &feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-                    emit_feature_err(&self.tcx.sess.parse_sess, &feature.as_str(), span,\n+                    emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n-            Some(&Stability { ref level, ref feature, .. }) => {\n-                self.used_features.insert(feature.clone(), level.clone());\n-\n+            Some(_) => {\n                 // Stable APIs are always ok to call and deprecated APIs are\n-                // handled by a lint.\n+                // handled by the lint emitting logic above.\n             }\n             None => {\n                 // This is an 'unmarked' API, which should not exist\n                 // in the standard library.\n-                if self.tcx.sess.features.borrow().unmarked_api {\n-                    self.tcx.sess.struct_span_warn(span, \"use of unmarked library feature\")\n-                                 .span_note(span, \"this is either a bug in the library you are \\\n-                                                   using or a bug in the compiler - please \\\n-                                                   report it in both places\")\n-                                 .emit()\n+                if self.sess.features.borrow().unmarked_api {\n+                    self.sess.struct_span_warn(span, \"use of unmarked library feature\")\n+                             .span_note(span, \"this is either a bug in the library you are \\\n+                                               using or a bug in the compiler - please \\\n+                                               report it in both places\")\n+                             .emit()\n                 } else {\n-                    self.tcx.sess.struct_span_err(span, \"use of unmarked library feature\")\n-                                 .span_note(span, \"this is either a bug in the library you are \\\n-                                                   using or a bug in the compiler - please \\\n-                                                   report it in both places\")\n-                                 .span_note(span, \"use #![feature(unmarked_api)] in the \\\n-                                                   crate attributes to override this\")\n-                                 .emit()\n+                    self.sess.struct_span_err(span, \"use of unmarked library feature\")\n+                             .span_note(span, \"this is either a bug in the library you are \\\n+                                               using or a bug in the compiler - please \\\n+                                               report it in both places\")\n+                             .span_note(span, \"use #![feature(unmarked_api)] in the \\\n+                                               crate attributes to override this\")\n+                             .emit()\n                 }\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n-    /// Because stability levels are scoped lexically, we want to walk\n-    /// nested items in the context of the outer item, so enable\n-    /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n-    }\n-\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        // When compiling with --test we don't enforce stability on the\n-        // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n-        // name `__test`\n-        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n-\n-        check_item(self.tcx, item, true,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        check_expr(self.tcx, ex,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_expr(self, ex);\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n-        check_path(self.tcx, path, id,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_path(self, path)\n-    }\n-\n-    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n-        check_path_list_item(self.tcx, item,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_path_list_item(self, prefix, item)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        check_pat(self.tcx, pat,\n-                  &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_pat(self, pat)\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        let old_skip_count = self.in_skip_block;\n-        match b.rules {\n-            hir::BlockCheckMode::PushUnstableBlock => {\n-                self.in_skip_block += 1;\n-            }\n-            hir::BlockCheckMode::PopUnstableBlock => {\n-                self.in_skip_block = self.in_skip_block.checked_sub(1).unwrap();\n+        match item.node {\n+            hir::ItemExternCrate(_) => {\n+                // compiler-generated `extern crate` items have a dummy span.\n+                if item.span == DUMMY_SP { return }\n+\n+                let cnum = match self.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => return,\n+                };\n+                let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+                self.tcx.check_stability(def_id, item.id, item.span);\n             }\n-            _ => {}\n-        }\n-        intravisit::walk_block(self, b);\n-        self.in_skip_block = old_skip_count;\n-    }\n-}\n \n-/// Helper for discovering nodes to check for stability\n-pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            item: &hir::Item,\n-                            warn_about_defns: bool,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    match item.node {\n-        hir::ItemExternCrate(_) => {\n-            // compiler-generated `extern crate` items have a dummy span.\n-            if item.span == DUMMY_SP { return }\n-\n-            let cnum = match tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n-                Some(cnum) => cnum,\n-                None => return,\n-            };\n-            let id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-            maybe_do_stability_check(tcx, id, item.span, cb);\n-        }\n-\n-        // For implementations of traits, check the stability of each item\n-        // individually as it's possible to have a stable trait with unstable\n-        // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n-            let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for impl_item_ref in impl_item_refs {\n-                let impl_item = tcx.map.impl_item(impl_item_ref.id);\n-                let item = tcx.associated_items(trait_did)\n-                    .find(|item| item.name == impl_item.name).unwrap();\n-                if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id, impl_item.span, cb);\n-                }\n-            }\n-        }\n-\n-        _ => (/* pass */)\n-    }\n-}\n-\n-/// Helper for discovering nodes to check for stability\n-pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    let span;\n-    let id = match e.node {\n-        hir::ExprMethodCall(i, ..) => {\n-            span = i.span;\n-            let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables().method_map[&method_call].def_id\n-        }\n-        hir::ExprField(ref base_e, ref field) => {\n-            span = field.span;\n-            match tcx.tables().expr_ty_adjusted(base_e).sty {\n-                ty::TyAdt(def, _) => {\n-                    def.struct_variant().field_named(field.node).did\n-                }\n-                _ => span_bug!(e.span,\n-                               \"stability::check_expr: named field access on non-ADT\")\n-            }\n-        }\n-        hir::ExprTupField(ref base_e, ref field) => {\n-            span = field.span;\n-            match tcx.tables().expr_ty_adjusted(base_e).sty {\n-                ty::TyAdt(def, _) => {\n-                    def.struct_variant().fields[field.node].did\n-                }\n-                ty::TyTuple(..) => return,\n-                _ => span_bug!(e.span,\n-                               \"stability::check_expr: unnamed field access on \\\n-                                something other than a tuple or struct\")\n-            }\n-        }\n-        hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.tables().expr_ty(e).sty {\n-                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        // check the stability of each field that appears\n-                        // in the construction expression.\n-                        for field in expr_fields {\n-                            let did = adt.struct_variant().field_named(field.name.node).did;\n-                            maybe_do_stability_check(tcx, did, field.span, cb);\n+            // For implementations of traits, check the stability of each item\n+            // individually as it's possible to have a stable trait with unstable\n+            // items.\n+            hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n+                if let Def::Trait(trait_did) = t.path.def {\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                        let trait_item_def_id = self.tcx.associated_items(trait_did)\n+                            .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n+                        if let Some(def_id) = trait_item_def_id {\n+                            // Pass `DUMMY_NODE_ID` to skip deprecation warnings.\n+                            self.tcx.check_stability(def_id, ast::DUMMY_NODE_ID, impl_item.span);\n                         }\n-\n-                        // we're done.\n-                        return\n                     }\n-                    AdtKind::Enum => {\n-                        // we don't look at stability attributes on\n-                        // struct-like enums (yet...), but it's definitely not\n-                        // a bug to have construct one.\n-                        return\n-                    }\n-                },\n-                ref ty => span_bug!(e.span, \"stability::check_expr: struct \\\n-                                         construction of non-ADT type: {:?}\", ty)\n+                }\n             }\n-        }\n-        _ => return\n-    };\n \n-    maybe_do_stability_check(tcx, id, span, cb);\n-}\n-\n-pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            path: &hir::Path, id: ast::NodeId,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    // Paths in import prefixes may have no resolution.\n-    match tcx.expect_def_or_none(id) {\n-        None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => {}\n-        Some(def) => maybe_do_stability_check(tcx, def.def_id(), path.span, cb)\n+            _ => (/* pass */)\n+        }\n+        intravisit::walk_item(self, item);\n     }\n-}\n \n-pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      item: &hir::PathListItem,\n-                                      cb: &mut FnMut(DefId, Span,\n-                                                     &Option<&Stability>,\n-                                                     &Option<DeprecationEntry>)) {\n-    maybe_do_stability_check(tcx, tcx.expect_def(item.node.id).def_id(), item.span, cb);\n-}\n-\n-pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n-                           cb: &mut FnMut(DefId, Span,\n-                                          &Option<&Stability>,\n-                                          &Option<DeprecationEntry>)) {\n-    debug!(\"check_pat(pat = {:?})\", pat);\n-    if is_internal(tcx, pat.span) { return; }\n-\n-    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n-        Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n-        _ => return,\n-    };\n-    match pat.node {\n-        // Foo(a, b, c)\n-        PatKind::TupleStruct(_, ref pat_fields, ddpos) => {\n-            for (i, field) in pat_fields.iter().enumerate_and_adjust(v.fields.len(), ddpos) {\n-                maybe_do_stability_check(tcx, v.fields[i].did, field.span, cb)\n-            }\n-        }\n-        // Foo { a, b, c }\n-        PatKind::Struct(_, ref pat_fields, _) => {\n-            for field in pat_fields {\n-                let did = v.field_named(field.node.name).did;\n-                maybe_do_stability_check(tcx, did, field.span, cb);\n-            }\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n+        match path.def {\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n+            _ => self.tcx.check_stability(path.def.def_id(), id, path.span)\n         }\n-        // everything else is fine.\n-        _ => {}\n+        intravisit::walk_path(self, path)\n     }\n }\n \n-fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      id: DefId, span: Span,\n-                                      cb: &mut FnMut(DefId, Span,\n-                                                     &Option<&Stability>,\n-                                                     &Option<DeprecationEntry>)) {\n-    if is_internal(tcx, span) {\n-        debug!(\"maybe_do_stability_check: \\\n-                skipping span={:?} since it is internal\", span);\n-        return;\n-    }\n-    let (stability, deprecation) = if is_staged_api(tcx, id) {\n-        (tcx.lookup_stability(id), None)\n-    } else {\n-        (None, tcx.lookup_deprecation_entry(id))\n-    };\n-    debug!(\"maybe_do_stability_check: \\\n-            inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n-    cb(id, span, &stability, &deprecation);\n-}\n-\n-fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n-    tcx.sess.codemap().span_allows_unstable(span)\n-}\n-\n-fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n-    *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-        || tcx.sess.cstore.is_staged_api(id.krate))\n-}\n-\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Lookup the stability for a node, loading external crate\n     /// metadata as necessary.\n-    pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n+    pub fn lookup_stability(self, id: DefId) -> Option<&'gcx Stability> {\n         if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n             return *st;\n         }\n@@ -712,7 +606,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         depr\n     }\n \n-    fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n+    fn lookup_stability_uncached(self, id: DefId) -> Option<&'gcx Stability> {\n         debug!(\"lookup(id={:?})\", id);\n         if id.is_local() {\n             None // The stability cache is filled partially lazily\n@@ -734,9 +628,22 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FxHashMap<Symbol,\n-                                                                     attr::StabilityLevel>) {\n+pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 access_levels: &AccessLevels) {\n+    let sess = &tcx.sess;\n+\n+    if tcx.stability.borrow().staged_api[&LOCAL_CRATE] && tcx.sess.features.borrow().staged_api {\n+        let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n+        let krate = tcx.map.krate();\n+        let mut missing = MissingStabilityAnnotations {\n+            tcx: tcx,\n+            access_levels: access_levels,\n+        };\n+        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span);\n+        intravisit::walk_crate(&mut missing, krate);\n+        krate.visit_all_item_likes(&mut DeepVisitor::new(&mut missing));\n+    }\n+\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n     let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n@@ -754,7 +661,8 @@ pub fn check_unused_or_stable_features(sess: &Session,\n                       format_stable_since_msg(version));\n     }\n \n-    for (used_lib_feature, level) in lib_features_used {\n+    let index = tcx.stability.borrow();\n+    for (used_lib_feature, level) in &index.used_features {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n                 if let &attr::StabilityLevel::Stable { since: ref version } = level {"}, {"sha": "ea81c85ba6a53f96fe1280de57646157bb560dbf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,7 +14,7 @@ use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n use hir::TraitMap;\n-use hir::def::DefMap;\n+use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n@@ -201,6 +201,9 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct Tables<'tcx> {\n+    /// Resolved definitions for `<T>::X` associated paths.\n+    pub type_relative_path_defs: NodeMap<Def>,\n+\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n@@ -244,6 +247,7 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n+            type_relative_path_defs: NodeMap(),\n             node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n@@ -256,6 +260,16 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n         }\n     }\n \n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.def,\n+            hir::QPath::TypeRelative(..) => {\n+                self.type_relative_path_defs.get(&id).cloned().unwrap_or(Def::Err)\n+            }\n+        }\n+    }\n+\n     pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n@@ -379,11 +393,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-    /// Map from path id to the results from resolve; generated\n-    /// initially by resolve and updated during typeck in some cases\n-    /// (e.g., UFCS paths)\n-    pub def_map: RefCell<DefMap>,\n-\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n@@ -768,7 +777,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  def_map: DefMap,\n                                   trait_map: TraitMap,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n@@ -797,7 +805,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            def_map: RefCell::new(def_map),\n             trait_map: trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "10754825a8c1873c9b7100ea262ee5643daf09b7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -191,6 +191,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        trait_ref.super_visit_with(self)\n+    }\n+\n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.super_visit_with(self)\n     }"}, {"sha": "844fc58cec37b9864d2d7db4594c7a90570f9b79", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -19,7 +19,7 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n+use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -29,8 +29,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::NodeSet;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, NodeMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -111,12 +110,13 @@ pub type Disr = ConstInt;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n #[derive(Clone)]\n-pub struct CrateAnalysis<'a> {\n+pub struct CrateAnalysis<'tcx> {\n     pub export_map: ExportMap,\n     pub access_levels: middle::privacy::AccessLevels,\n     pub reachable: NodeSet,\n-    pub name: &'a str,\n+    pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n+    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n #[derive(Copy, Clone)]\n@@ -247,7 +247,7 @@ impl Visibility {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { id, .. } => match tcx.expect_def(id) {\n+            hir::Visibility::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n@@ -1280,8 +1280,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                if let hir::ExprClosure(..) = expr.node {\n-                    ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                if let hir::ExprClosure(.., ref body, _) = expr.node {\n+                    let def_id = tcx.map.local_def_id(id);\n+                    let base_def_id = tcx.closure_base_def_id(def_id);\n+                    tcx.construct_parameter_environment(\n+                        expr.span,\n+                        base_def_id,\n+                        tcx.region_maps.call_site_extent(id, body.id))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -2047,7 +2052,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2059,11 +2064,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(..) => {\n-                // This function can be used during type checking when not all paths are\n-                // fully resolved. Partially resolved paths in expressions can only legally\n-                // refer to associated items which are always rvalues.\n-                match self.expect_resolution(expr.id).base_def {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n@@ -2080,6 +2082,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 true\n             }\n \n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n+\n             hir::ExprCall(..) |\n             hir::ExprMethodCall(..) |\n             hir::ExprStruct(..) |\n@@ -2297,22 +2303,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns a path resolution for node id if it exists, panics otherwise.\n-    pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n-        *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, panics otherwise.\n-    pub fn expect_def(self, id: NodeId) -> Def {\n-        self.expect_resolution(id).full_def()\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, or none if no\n-    /// definition exists, panics on partial resolutions to catch errors.\n-    pub fn expect_def_or_none(self, id: NodeId) -> Option<Def> {\n-        self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n-    }\n-\n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {"}, {"sha": "c8618cd154781b8f3a848920da8a929e8d4c2ae8", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -599,6 +599,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.substs.visit_with(visitor)\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_trait_ref(*self)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n@@ -766,6 +770,36 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::Generics {\n+            parent: self.parent,\n+            parent_regions: self.parent_regions,\n+            parent_types: self.parent_types,\n+            regions: self.regions.fold_with(folder),\n+            types: self.types.fold_with(folder),\n+            has_self: self.has_self,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.regions.visit_with(visitor) || self.types.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GenericPredicates {\n+            parent: self.parent,\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicates.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "1dde8106ec6a602f587a3666829f83976ebb20bb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,7 +14,6 @@ use hir::def_id::DefId;\n use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n-use hir::pat_util;\n use traits::{self, Reveal};\n use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n@@ -180,14 +179,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(pat)\n-    }\n-\n-    pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(arm)\n-    }\n-\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::TyAdt(def, substs) => {"}, {"sha": "2c277c04a52e39568f7230e4c99876c64ec81468", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, ref path1, _) => {\n+        PatKind::Binding(_, _, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node})\n         },"}, {"sha": "db24ad0fd67ce36e8056bf913edafa925a0ea5f7", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def_id::{DefId};\n-use rustc::hir::pat_util::def_to_path;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::hir;\n@@ -324,6 +324,12 @@ impl Witness {\n \n                 ty::TyAdt(adt, _) => {\n                     let v = ctor.variant_for_adt(adt);\n+                    let qpath = hir::QPath::Resolved(None, P(hir::Path {\n+                        span: DUMMY_SP,\n+                        global: false,\n+                        def: Def::Err,\n+                        segments: vec![hir::PathSegment::from_name(v.name)].into(),\n+                    }));\n                     match v.ctor_kind {\n                         CtorKind::Fictive => {\n                             let field_pats: hir::HirVec<_> = v.fields.iter()\n@@ -338,16 +344,12 @@ impl Witness {\n                                     }\n                                 }).collect();\n                             let has_more_fields = field_pats.len() < arity;\n-                            PatKind::Struct(\n-                                def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                            PatKind::Struct(qpath, field_pats, has_more_fields)\n                         }\n                         CtorKind::Fn => {\n-                            PatKind::TupleStruct(\n-                                def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                        }\n-                        CtorKind::Const => {\n-                            PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                            PatKind::TupleStruct(qpath, pats.collect(), None)\n                         }\n+                        CtorKind::Const => PatKind::Path(qpath)\n                     }\n                 }\n "}, {"sha": "b67c2c8ec9cddf840c7736c85c1be06a73574992", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -19,8 +19,6 @@ use eval::report_const_eval_err;\n \n use rustc::dep_graph::DepNode;\n \n-use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n-\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -262,26 +260,22 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n+        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n             let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n-                if edef.is_enum() {\n-                    if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                        if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.ctor_kind == CtorKind::Const\n-                        }) {\n-                            let ty_path = cx.tcx.item_path_str(edef.did);\n-                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                                \"pattern binding `{}` is named the same as one \\\n-                                of the variants of the type `{}`\",\n-                                name.node, ty_path);\n-                            help!(err,\n-                                \"if you meant to match on a variant, \\\n-                                consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, name.node);\n-                            err.emit();\n-                        }\n-                    }\n+                if edef.is_enum() && edef.variants.iter().any(|variant| {\n+                    variant.name == name.node && variant.ctor_kind == CtorKind::Const\n+                }) {\n+                    let ty_path = cx.tcx.item_path_str(edef.did);\n+                    let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                        \"pattern binding `{}` is named the same as one \\\n+                         of the variants of the type `{}`\",\n+                        name.node, ty_path);\n+                    help!(err,\n+                        \"if you meant to match on a variant, \\\n+                        consider making the path in the pattern qualified: `{}::{}`\",\n+                        ty_path, name.node);\n+                    err.emit();\n                 }\n             }\n         }\n@@ -290,13 +284,13 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n+fn pat_is_catchall(pat: &Pat) -> bool {\n     match pat.node {\n         PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(dm, s),\n+        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n+        PatKind::Ref(ref s, _) => pat_is_catchall(s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n-            pat_is_catchall(dm, &p)\n+            pat_is_catchall(&p)\n         }),\n         _ => false\n     }\n@@ -374,7 +368,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n             if guard.is_none() {\n                 seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), hir_pat) {\n+                if catchall.is_none() && pat_is_catchall(hir_pat) {\n                     catchall = Some(pat.span);\n                 }\n             }\n@@ -454,7 +448,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(&pat, |bm, _, span, _path| {\n+        pat.each_binding(|bm, _, span, _path| {\n             if let hir::BindByRef(..) = bm {\n                 by_ref_span = Some(span);\n             }\n@@ -465,7 +459,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n+        if sub.map_or(false, |p| p.contains_bindings()) {\n             struct_span_err!(cx.tcx.sess, p.span, E0007,\n                              \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n@@ -486,7 +480,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n+            if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n                 let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));"}, {"sha": "053d3072ddf52281a4434c16d40f8dd99d61c091", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -19,9 +19,8 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n-use rustc::hir::def::{Def, CtorKind, PathResolution};\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n@@ -42,7 +41,6 @@ use syntax_pos::{self, Span};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n@@ -282,27 +280,37 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 .collect::<Result<_, _>>()?, None),\n \n         hir::ExprCall(ref callee, ref args) => {\n-            let def = tcx.expect_def(callee.id);\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.insert(PathResolution::new(def));\n-            }\n-            let path = match def {\n-                Def::StructCtor(def_id, CtorKind::Fn) |\n-                Def::VariantCtor(def_id, CtorKind::Fn) => def_to_path(tcx, def_id),\n-                Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n-                    id: expr.id,\n-                    node: PatKind::Lit(P(expr.clone())),\n-                    span: span,\n-                })),\n+            let qpath = match callee.node {\n+                hir::ExprPath(ref qpath) => qpath,\n                 _ => bug!()\n             };\n-            let pats = args.iter()\n-                           .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n-                           .collect::<Result<_, _>>()?;\n-            PatKind::TupleStruct(path, pats, None)\n+            let def = tcx.tables().qpath_def(qpath, callee.id);\n+            let ctor_path = if let hir::QPath::Resolved(_, ref path) = *qpath {\n+                match def {\n+                    Def::StructCtor(_, CtorKind::Fn) |\n+                    Def::VariantCtor(_, CtorKind::Fn) => {\n+                        Some(path.clone())\n+                    }\n+                    _ => None\n+                }\n+            } else {\n+                None\n+            };\n+            match (def, ctor_path) {\n+                (Def::Fn(..), None) | (Def::Method(..), None) => {\n+                    PatKind::Lit(P(expr.clone()))\n+                }\n+                (_, Some(ctor_path)) => {\n+                    let pats = args.iter()\n+                                   .map(|expr| const_expr_to_pat(tcx, expr, pat_id, span))\n+                                   .collect::<Result<_, _>>()?;\n+                    PatKind::TupleStruct(hir::QPath::Resolved(None, ctor_path), pats, None)\n+                }\n+                _ => bug!()\n+            }\n         }\n \n-        hir::ExprStruct(ref path, ref fields, None) => {\n+        hir::ExprStruct(ref qpath, ref fields, None) => {\n             let field_pats =\n                 fields.iter()\n                       .map(|field| Ok(codemap::Spanned {\n@@ -314,7 +322,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           },\n                       }))\n                       .collect::<Result<_, _>>()?;\n-            PatKind::Struct((**path).clone(), field_pats, false)\n+            PatKind::Struct(qpath.clone(), field_pats, false)\n         }\n \n         hir::ExprArray(ref exprs) => {\n@@ -324,10 +332,18 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             PatKind::Slice(pats, None, hir::HirVec::new())\n         }\n \n-        hir::ExprPath(_, ref path) => {\n-            match tcx.expect_def(expr.id) {\n+        hir::ExprPath(ref qpath) => {\n+            let def = tcx.tables().qpath_def(qpath, expr.id);\n+            match def {\n                 Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n+                Def::VariantCtor(_, CtorKind::Const) => {\n+                    match expr.node {\n+                        hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                            PatKind::Path(hir::QPath::Resolved(None, path.clone()))\n+                        }\n+                        _ => bug!()\n+                    }\n+                }\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n                         .unwrap_or_else(|| tcx.intern_substs(&[])));\n@@ -788,14 +804,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n-      hir::ExprPath(..) => {\n-          // This function can be used before type checking when not all paths are fully resolved.\n-          // FIXME: There's probably a better way to make sure we don't panic here.\n-          let resolution = tcx.expect_resolution(e.id);\n-          if resolution.depth != 0 {\n-              signal!(e, UnresolvedPath);\n-          }\n-          match resolution.base_def {\n+      hir::ExprPath(ref qpath) => {\n+          let def = tcx.tables().qpath_def(qpath, e.id);\n+          match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n@@ -845,6 +856,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               },\n               Def::Method(id) | Def::Fn(id) => Function(id),\n+              Def::Err => signal!(e, UnresolvedPath),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n@@ -873,8 +885,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              let old = call_args.insert(tcx.expect_def(arg.pat.id).def_id(), arg_val);\n-              assert!(old.is_none());\n+              if let PatKind::Binding(_, def_id, _, _) = arg.pat.node {\n+                assert!(call_args.insert(def_id, arg_val).is_none());\n+              }\n           }\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n@@ -1358,17 +1371,10 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let mut diag = report_const_eval_err(\n                 tcx, &err, count_expr.span, reason);\n \n-            match count_expr.node {\n-                hir::ExprPath(None, hir::Path {\n-                    global: false,\n-                    ref segments,\n-                    ..\n-                }) if segments.len() == 1 => {\n-                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n-                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n-                    }\n+            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n+                if let Def::Local(..) = path.def {\n+                    diag.note(&format!(\"`{}` is a variable\", path));\n                 }\n-                _ => {}\n             }\n \n             diag.emit();"}, {"sha": "8e803da98f89dc34c90c0a78d3675a73357c50b8", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -163,8 +163,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                match self.tcx.expect_def(pat.id) {\n+            PatKind::Path(ref qpath) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                match def {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n                         let substs = tcx.tables().node_id_item_substs(pat.id)\n@@ -188,7 +189,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    _ => self.lower_variant_or_leaf(pat, vec![])\n+                    _ => self.lower_variant_or_leaf(def, vec![])\n                 }\n             }\n \n@@ -242,8 +243,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = self.tcx.expect_def(pat.id).def_id();\n+            PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n@@ -281,13 +281,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -297,10 +298,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n \n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n@@ -310,7 +312,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             \"struct pattern not applied to an ADT\");\n                     }\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                     fields.iter()\n@@ -329,7 +331,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n         };\n \n@@ -418,11 +420,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n     fn lower_variant_or_leaf(\n         &mut self,\n-        pat: &hir::Pat,\n+        def: Def,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n     {\n-        match self.tcx.expect_def(pat.id) {\n+        match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.lookup_adt_def(enum_id);\n@@ -442,9 +444,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            def => {\n-                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n-            }\n+            _ => bug!()\n         }\n     }\n }"}, {"sha": "7dc71f8189b86f0d5f782ea08c676dbffad9d8cd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::time;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n@@ -332,31 +332,31 @@ impl<'a> PhaseController<'a> {\n /// State that is passed to a callback. What state is available depends on when\n /// during compilation the callback is made. See the various constructor methods\n /// (`state_*`) in the impl to see which data is provided for any given entry point.\n-pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n+pub struct CompileState<'a, 'tcx: 'a> {\n     pub input: &'a Input,\n-    pub session: &'ast Session,\n+    pub session: &'tcx Session,\n     pub krate: Option<ast::Crate>,\n     pub registry: Option<Registry<'a>>,\n     pub cstore: Option<&'a CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n     pub out_file: Option<&'a Path>,\n-    pub arenas: Option<&'ast ty::CtxtArenas<'ast>>,\n+    pub arenas: Option<&'tcx ty::CtxtArenas<'tcx>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n-    pub ast_map: Option<&'a hir_map::Map<'ast>>,\n+    pub ast_map: Option<&'a hir_map::Map<'tcx>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n-impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n+impl<'a, 'tcx> CompileState<'a, 'tcx> {\n     fn empty(input: &'a Input,\n-             session: &'ast Session,\n+             session: &'tcx Session,\n              out_dir: &'a Option<PathBuf>)\n-             -> CompileState<'a, 'b, 'ast, 'tcx> {\n+             -> Self {\n         CompileState {\n             input: input,\n             session: session,\n@@ -379,12 +379,12 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_parse(input: &'a Input,\n-                         session: &'ast Session,\n+                         session: &'tcx Session,\n                          out_dir: &'a Option<PathBuf>,\n                          out_file: &'a Option<PathBuf>,\n                          krate: ast::Crate,\n                          cstore: &'a CStore)\n-                         -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                         -> Self {\n         CompileState {\n             // Initialize the registry before moving `krate`\n             registry: Some(Registry::new(&session, krate.span)),\n@@ -396,13 +396,13 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_expand(input: &'a Input,\n-                          session: &'ast Session,\n+                          session: &'tcx Session,\n                           out_dir: &'a Option<PathBuf>,\n                           out_file: &'a Option<PathBuf>,\n                           cstore: &'a CStore,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n-                          -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                          -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             cstore: Some(cstore),\n@@ -413,18 +413,18 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_hir_lowering(input: &'a Input,\n-                                session: &'ast Session,\n+                                session: &'tcx Session,\n                                 out_dir: &'a Option<PathBuf>,\n                                 out_file: &'a Option<PathBuf>,\n-                                arenas: &'ast ty::CtxtArenas<'ast>,\n+                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                 cstore: &'a CStore,\n-                                hir_map: &'a hir_map::Map<'ast>,\n-                                analysis: &'a ty::CrateAnalysis,\n+                                hir_map: &'a hir_map::Map<'tcx>,\n+                                analysis: &'a ty::CrateAnalysis<'static>,\n                                 resolutions: &'a Resolutions,\n                                 krate: &'a ast::Crate,\n                                 hir_crate: &'a hir::Crate,\n                                 crate_name: &'a str)\n-                                -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                                -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             arenas: Some(arenas),\n@@ -440,15 +440,15 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_analysis(input: &'a Input,\n-                            session: &'ast Session,\n+                            session: &'tcx Session,\n                             out_dir: &'a Option<PathBuf>,\n                             out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'a>,\n-                            tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n-                            -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                            -> Self {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n@@ -462,11 +462,11 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n \n \n     fn state_after_llvm(input: &'a Input,\n-                        session: &'ast Session,\n+                        session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n                         out_file: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n-                        -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                        -> Self {\n         CompileState {\n             trans: Some(trans),\n             out_file: out_file.as_ref().map(|s| &**s),\n@@ -475,10 +475,10 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_when_compilation_done(input: &'a Input,\n-                                    session: &'ast Session,\n+                                    session: &'tcx Session,\n                                     out_dir: &'a Option<PathBuf>,\n                                     out_file: &'a Option<PathBuf>)\n-                                    -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                                    -> Self {\n         CompileState {\n             out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n@@ -532,10 +532,10 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n // For continuing compilation after a parsed crate has been\n // modified\n \n-pub struct ExpansionResult<'a> {\n+pub struct ExpansionResult {\n     pub expanded_crate: ast::Crate,\n     pub defs: hir_map::Definitions,\n-    pub analysis: ty::CrateAnalysis<'a>,\n+    pub analysis: ty::CrateAnalysis<'static>,\n     pub resolutions: Resolutions,\n     pub hir_forest: hir_map::Forest,\n }\n@@ -547,15 +547,15 @@ pub struct ExpansionResult<'a> {\n /// standard library and prelude, and name resolution.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n-                                           cstore: &CStore,\n-                                           krate: ast::Crate,\n-                                           registry: Option<Registry>,\n-                                           crate_name: &'a str,\n-                                           addl_plugins: Option<Vec<String>>,\n-                                           make_glob_map: MakeGlobMap,\n-                                           after_expand: F)\n-                                           -> Result<ExpansionResult<'a>, usize>\n+pub fn phase_2_configure_and_expand<F>(sess: &Session,\n+                                       cstore: &CStore,\n+                                       krate: ast::Crate,\n+                                       registry: Option<Registry>,\n+                                       crate_name: &str,\n+                                       addl_plugins: Option<Vec<String>>,\n+                                       make_glob_map: MakeGlobMap,\n+                                       after_expand: F)\n+                                       -> Result<ExpansionResult, usize>\n     where F: FnOnce(&ast::Crate) -> CompileResult,\n {\n     let time_passes = sess.time_passes();\n@@ -789,8 +789,9 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             export_map: resolver.export_map,\n             access_levels: AccessLevels::default(),\n             reachable: NodeSet(),\n-            name: crate_name,\n+            name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+            hir_ty_to_ty: NodeMap(),\n         },\n         resolutions: Resolutions {\n             def_map: resolver.def_map,\n@@ -807,14 +808,14 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n-                                               mut analysis: ty::CrateAnalysis,\n+                                               mut analysis: ty::CrateAnalysis<'tcx>,\n                                                resolutions: Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty::CrateAnalysis,\n+                            ty::CrateAnalysis<'tcx>,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n@@ -840,9 +841,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess,\n-                                                                   &hir_map,\n-                                                                   &resolutions.def_map))?;\n+                                || middle::resolve_lifetime::krate(sess, &hir_map))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -859,17 +858,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, &resolutions.def_map, &hir_map));\n+         || loops::check_crate(sess, &hir_map));\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &resolutions.def_map, &hir_map))?;\n+              || static_recursion::check_crate(sess, &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map,\n                              hir_map,\n@@ -888,8 +886,17 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n+        time(time_passes, \"stability index\", || {\n+            tcx.stability.borrow_mut().build(tcx)\n+        });\n+\n+        time(time_passes,\n+             \"stability checking\",\n+             || stability::check_unstable_api_usage(tcx));\n+\n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n+        analysis.hir_ty_to_ty =\n+            try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -900,11 +907,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                 rustc_privacy::check_crate(tcx, &analysis.export_map)\n             });\n \n-        // Do not move this check past lint\n-        time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx, &analysis.access_levels)\n-        });\n-\n         time(time_passes,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n@@ -973,14 +975,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             middle::dead::check_crate(tcx, &analysis.access_levels);\n         });\n \n-        let ref lib_features_used =\n-            time(time_passes,\n-                 \"stability checking\",\n-                 || stability::check_unstable_api_usage(tcx));\n-\n         time(time_passes, \"unused lib feature checking\", || {\n-            stability::check_unused_or_stable_features(&tcx.sess,\n-                                                       lib_features_used)\n+            stability::check_unused_or_stable_features(tcx, &analysis.access_levels)\n         });\n \n         time(time_passes,"}, {"sha": "4759394aff169f37693a6e1f1c44f6698cb231ea", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -200,7 +200,7 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis,\n+                                               analysis: &ty::CrateAnalysis<'tcx>,\n                                                resolutions: &Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -817,7 +817,7 @@ pub fn print_after_parsing(sess: &Session,\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 ast_map: &hir_map::Map<'tcx>,\n-                                                analysis: &ty::CrateAnalysis,\n+                                                analysis: &ty::CrateAnalysis<'tcx>,\n                                                 resolutions: &Resolutions,\n                                                 input: &Input,\n                                                 krate: &ast::Crate,\n@@ -934,7 +934,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        ast_map: &hir_map::Map<'tcx>,\n-                                       analysis: &ty::CrateAnalysis,\n+                                       analysis: &ty::CrateAnalysis<'tcx>,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n                                        arenas: &'tcx ty::CtxtArenas<'tcx>,"}, {"sha": "464e15faeaf75ca4a63fad4f080e9b9bdd0596b6", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -131,12 +131,11 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map);\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map);\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map.unwrap(),\n                              ast_map,"}, {"sha": "e2b141f2ea62d5f35afb774f9b47823d3cfc34ff", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -23,7 +23,7 @@ use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n@@ -185,10 +185,10 @@ enum SawAbiComponent<'a> {\n     SawImplItem(SawTraitOrImplItemComponent),\n     SawStructField,\n     SawVariant,\n+    SawQPath,\n     SawPath(bool),\n     SawPathSegment,\n     SawPathParameters,\n-    SawPathListItem,\n     SawBlock,\n     SawPat(SawPatComponent),\n     SawLocal,\n@@ -259,7 +259,7 @@ enum SawExprComponent<'a> {\n     SawExprAssign,\n     SawExprAssignOp(hir::BinOp_),\n     SawExprIndex,\n-    SawExprPath(Option<usize>),\n+    SawExprPath,\n     SawExprAddrOf(hir::Mutability),\n     SawExprRet,\n     SawExprInlineAsm(&'a hir::InlineAsm),\n@@ -333,10 +333,10 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n         ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n         ExprIndex(..)            => (SawExprIndex, true),\n-        ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n+        ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(id, _)         => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n-        ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n+        ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n+        ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n         ExprStruct(..)           => (SawExprStruct, false),\n@@ -356,7 +356,7 @@ fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n #[derive(Hash)]\n enum SawItemComponent {\n     SawItemExternCrate,\n-    SawItemUse,\n+    SawItemUse(UseKind),\n     SawItemStatic(Mutability),\n     SawItemConst,\n     SawItemFn(Unsafety, Constness, Abi),\n@@ -374,7 +374,7 @@ enum SawItemComponent {\n fn saw_item(node: &Item_) -> SawItemComponent {\n     match *node {\n         ItemExternCrate(..) => SawItemExternCrate,\n-        ItemUse(..) => SawItemUse,\n+        ItemUse(_, kind) => SawItemUse(kind),\n         ItemStatic(_, mutability, _) => SawItemStatic(mutability),\n         ItemConst(..) =>SawItemConst,\n         ItemFn(_, unsafety, constness, abi, _, _) => SawItemFn(unsafety, constness, abi),\n@@ -411,7 +411,7 @@ fn saw_pat(node: &PatKind) -> SawPatComponent {\n         PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n         PatKind::Struct(..) => SawPatStruct,\n         PatKind::TupleStruct(..) => SawPatTupleStruct,\n-        PatKind::Path(..) => SawPatPath,\n+        PatKind::Path(_) => SawPatPath,\n         PatKind::Tuple(..) => SawPatTuple,\n         PatKind::Box(..) => SawPatBox,\n         PatKind::Ref(_, mutability) => SawPatRef(mutability),\n@@ -447,7 +447,7 @@ fn saw_ty(node: &Ty_) -> SawTyComponent {\n       TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n       TyNever => SawTyNever,\n       TyTup(..) => SawTyTup,\n-      TyPath(..) => SawTyPath,\n+      TyPath(_) => SawTyPath,\n       TyObjectSum(..) => SawTyObjectSum,\n       TyPolyTraitRef(..) => SawTyPolyTraitRef,\n       TyImplTrait(..) => SawTyImplTrait,\n@@ -655,13 +655,24 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_struct_field(self, s)\n     }\n \n+    fn visit_qpath(&mut self, qpath: &'tcx QPath, id: NodeId, span: Span) {\n+        debug!(\"visit_qpath: st={:?}\", self.st);\n+        SawQPath.hash(self.st);\n+        self.hash_discriminant(qpath);\n+        visit::walk_qpath(self, qpath, id, span)\n+    }\n+\n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n         SawPath(path.global).hash(self.st);\n         hash_span!(self, path.span);\n         visit::walk_path(self, path)\n     }\n \n+    fn visit_def_mention(&mut self, def: Def) {\n+        self.hash_def(def);\n+    }\n+\n     fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n         SawBlock.hash(self.st);\n@@ -739,14 +750,6 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_poly_trait_ref(self, t, m)\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &'tcx Path, item: &'tcx PathListItem) {\n-        debug!(\"visit_path_list_item: st={:?}\", self.st);\n-        SawPathListItem.hash(self.st);\n-        self.hash_discriminant(&item.node);\n-        hash_span!(self, item.span);\n-        visit::walk_path_list_item(self, prefix, item)\n-    }\n-\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n         debug!(\"visit_path_segment: st={:?}\", self.st);\n         SawPathSegment.hash(self.st);\n@@ -800,11 +803,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         // or not an entry was present (we are already hashing what\n         // variant it is above when we visit the HIR).\n \n-        if let Some(def) = self.tcx.def_map.borrow().get(&id) {\n-            debug!(\"hash_resolve: id={:?} def={:?} st={:?}\", id, def, self.st);\n-            self.hash_partial_def(def);\n-        }\n-\n         if let Some(traits) = self.tcx.trait_map.get(&id) {\n             debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n             traits.len().hash(self.st);\n@@ -826,11 +824,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         self.compute_def_id_hash(def_id).hash(self.st);\n     }\n \n-    fn hash_partial_def(&mut self, def: &PathResolution) {\n-        self.hash_def(def.base_def);\n-        def.depth.hash(self.st);\n-    }\n-\n     fn hash_def(&mut self, def: Def) {\n         match def {\n             // Crucial point: for all of these variants, the variant +"}, {"sha": "7c3ea656124bcdb4fb0e0120d45cad49da75a4ed", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -288,12 +288,17 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, ref path1, _) = &p.node {\n-            // Exclude parameter names from foreign functions (they have no `Def`)\n-            if cx.tcx.expect_def_or_none(p.id).is_some() {\n-                self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n+        // Exclude parameter names from foreign functions\n+        let parent_node = cx.tcx.map.get_parent_node(p.id);\n+        if let hir::map::NodeForeignItem(item) = cx.tcx.map.get(parent_node) {\n+            if let hir::ForeignItemFn(..) = item.node {\n+                return;\n             }\n         }\n+\n+        if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n+            self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n+        }\n     }\n \n     fn check_struct_def(&mut self,\n@@ -376,9 +381,9 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(None, ref path) = p.node {\n+        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n+                if let Def::Const(..) = path.def {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n                                                           path.segments[0].name,"}, {"sha": "f14fa7d4fdc23905040fae8defb277249456fcd1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 152, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -30,22 +30,20 @@\n \n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use middle::stability;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n-use lint::{Level, LateContext, LintContext, LintArray, Lint};\n+use lint::{Level, LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n \n use std::collections::HashSet;\n \n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n@@ -167,7 +165,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n-                if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n                     if ident.node == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n@@ -391,7 +389,7 @@ impl LateLintPass for MissingDoc {\n             hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n+                let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n@@ -607,142 +605,6 @@ impl LateLintPass for MissingDebugImplementations {\n     }\n }\n \n-declare_lint! {\n-    DEPRECATED,\n-    Warn,\n-    \"detects use of deprecated items\"\n-}\n-\n-/// Checks for use of items with `#[deprecated]` or `#[rustc_deprecated]` attributes\n-#[derive(Clone)]\n-pub struct Deprecated {\n-    /// Tracks the `NodeId` of the current item.\n-    ///\n-    /// This is required since not all node ids are present in the hir map.\n-    current_item: ast::NodeId,\n-}\n-\n-impl Deprecated {\n-    pub fn new() -> Deprecated {\n-        Deprecated { current_item: ast::CRATE_NODE_ID }\n-    }\n-\n-    fn lint(&self,\n-            cx: &LateContext,\n-            _id: DefId,\n-            span: Span,\n-            stability: &Option<&attr::Stability>,\n-            deprecation: &Option<stability::DeprecationEntry>) {\n-        // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{reason, ..}), ..})\n-                = *stability {\n-            output(cx, DEPRECATED, span, Some(reason))\n-        } else if let Some(ref depr_entry) = *deprecation {\n-            if let Some(parent_depr) = cx.tcx.lookup_deprecation_entry(self.parent_def(cx)) {\n-                if parent_depr.same_origin(depr_entry) {\n-                    return;\n-                }\n-            }\n-\n-            output(cx, DEPRECATED, span, depr_entry.attr.note)\n-        }\n-\n-        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<Symbol>) {\n-            let msg = if let Some(note) = note {\n-                format!(\"use of deprecated item: {}\", note)\n-            } else {\n-                format!(\"use of deprecated item\")\n-            };\n-\n-            cx.span_lint(lint, span, &msg);\n-        }\n-    }\n-\n-    fn push_item(&mut self, item_id: ast::NodeId) {\n-        self.current_item = item_id;\n-    }\n-\n-    fn item_post(&mut self, cx: &LateContext, item_id: ast::NodeId) {\n-        assert_eq!(self.current_item, item_id);\n-        self.current_item = cx.tcx.map.get_parent(item_id);\n-    }\n-\n-    fn parent_def(&self, cx: &LateContext) -> DefId {\n-        cx.tcx.map.local_def_id(self.current_item)\n-    }\n-}\n-\n-impl LintPass for Deprecated {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED)\n-    }\n-}\n-\n-impl LateLintPass for Deprecated {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        self.push_item(item.id);\n-        stability::check_item(cx.tcx,\n-                              item,\n-                              false,\n-                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n-    }\n-\n-    fn check_item_post(&mut self, cx: &LateContext, item: &hir::Item) {\n-        self.item_post(cx, item.id);\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        stability::check_expr(cx.tcx,\n-                              e,\n-                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n-    }\n-\n-    fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx,\n-                              path,\n-                              id,\n-                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n-    }\n-\n-    fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n-        stability::check_path_list_item(cx.tcx,\n-                                        item,\n-                                        &mut |id, sp, stab, depr| {\n-                                            self.lint(cx, id, sp, &stab, &depr)\n-                                        });\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        stability::check_pat(cx.tcx,\n-                             pat,\n-                             &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n-    }\n-\n-    fn check_impl_item(&mut self, _: &LateContext, item: &hir::ImplItem) {\n-        self.push_item(item.id);\n-    }\n-\n-    fn check_impl_item_post(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n-        self.item_post(cx, item.id);\n-    }\n-\n-    fn check_trait_item(&mut self, _: &LateContext, item: &hir::TraitItem) {\n-        self.push_item(item.id);\n-    }\n-\n-    fn check_trait_item_post(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        self.item_post(cx, item.id);\n-    }\n-\n-    fn check_foreign_item(&mut self, _: &LateContext, item: &hir::ForeignItem) {\n-        self.push_item(item.id);\n-    }\n-\n-    fn check_foreign_item_post(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n-        self.item_post(cx, item.id);\n-    }\n-}\n-\n declare_lint! {\n     DEPRECATED_ATTR,\n     Warn,\n@@ -928,8 +790,12 @@ impl LateLintPass for UnconditionalRecursion {\n         fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.expect_def_or_none(callee.id)\n-                        .map_or(false, |def| def.def_id() == tcx.map.local_def_id(fn_id))\n+                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                        tcx.tables().qpath_def(qpath, callee.id)\n+                    } else {\n+                        return false;\n+                    };\n+                    def.def_id() == tcx.map.local_def_id(fn_id)\n                 }\n                 _ => false,\n             }\n@@ -967,10 +833,13 @@ impl LateLintPass for UnconditionalRecursion {\n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    // The callee is an arbitrary expression,\n-                    // it doesn't necessarily have a definition.\n-                    match tcx.expect_def_or_none(callee.id) {\n-                        Some(Def::Method(def_id)) => {\n+                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                        tcx.tables().qpath_def(qpath, callee.id)\n+                    } else {\n+                        return false;\n+                    };\n+                    match def {\n+                        Def::Method(def_id) => {\n                             let substs = tcx.tables().node_id_item_substs(callee.id)\n                                 .unwrap_or_else(|| tcx.intern_substs(&[]));\n                             method_call_refers_to_method(\n@@ -1203,11 +1072,12 @@ impl LateLintPass for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n-            match expr.node {\n-                hir::ExprPath(..) => (),\n-                _ => return None,\n-            }\n-            if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n+            let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                cx.tcx.tables().qpath_def(qpath, expr.id)\n+            } else {\n+                return None;\n+            };\n+            if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "ec0a124770c48b91f04d969c5411a6e0f308439f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -111,6 +111,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n \n     add_early_builtin!(sess,\n                        UnusedParens,\n+                       UnusedImportBraces,\n                        );\n \n     add_early_builtin_with_new!(sess,\n@@ -129,7 +130,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  NonCamelCaseTypes,\n                  NonSnakeCase,\n                  NonUpperCaseGlobals,\n-                 UnusedImportBraces,\n                  NonShorthandFieldPatterns,\n                  UnusedUnsafe,\n                  UnsafeCode,\n@@ -145,7 +145,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  );\n \n     add_builtin_with_new!(sess,\n-                          Deprecated,\n                           TypeLimits,\n                           MissingDoc,\n                           MissingDebugImplementations,"}, {"sha": "873c141065ec37dc41bf3014f37afdd0e248c321", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::pat_util;\n use rustc::ty;\n use rustc::ty::adjustment;\n use util::nodemap::FxHashMap;\n@@ -44,7 +43,7 @@ impl UnusedMut {\n \n         let mut mutables = FxHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(p, |mode, id, _, path1| {\n+            p.each_binding(|mode, id, _, path1| {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n@@ -218,7 +217,7 @@ impl LintPass for PathStatements {\n impl LateLintPass for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n-            if let hir::ExprPath(..) = expr.node {\n+            if let hir::ExprPath(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n@@ -406,11 +405,11 @@ impl LintPass for UnusedImportBraces {\n     }\n }\n \n-impl LateLintPass for UnusedImportBraces {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if let hir::ItemUse(ref view_path) = item.node {\n-            if let hir::ViewPathList(_, ref items) = view_path.node {\n-                if items.len() == 1 && items[0].node.name != keywords::SelfValue.name() {\n+impl EarlyLintPass for UnusedImportBraces {\n+    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+        if let ast::ItemKind::Use(ref view_path) = item.node {\n+            if let ast::ViewPathList(_, ref items) = view_path.node {\n+                if items.len() == 1 && items[0].node.name.name != keywords::SelfValue.name() {\n                     let msg = format!(\"braces around {} is unnecessary\", items[0].node.name);\n                     cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n                 }"}, {"sha": "806d20c72dcd92c21e80b9e9c3723de7bab3443a", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -18,7 +18,7 @@ use schema::*;\n \n use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n use rustc::middle::const_qualif::ConstQualif;\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt, Ty};\n \n@@ -35,7 +35,7 @@ pub struct Ast<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n enum TableEntry<'tcx> {\n-    Def(Def),\n+    TypeRelativeDef(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::Adjustment<'tcx>),\n@@ -93,7 +93,8 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n             }\n         };\n \n-        encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n+        encode(tcx.tables().type_relative_path_defs.get(&id).cloned()\n+                  .map(TableEntry::TypeRelativeDef));\n         encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n         encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n         encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n@@ -140,8 +141,8 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n \n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n-            TableEntry::Def(def) => {\n-                tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n+            TableEntry::TypeRelativeDef(def) => {\n+                tcx.tables.borrow_mut().type_relative_path_defs.insert(id, def);\n             }\n             TableEntry::NodeType(ty) => {\n                 tcx.tables.borrow_mut().node_types.insert(id, ty);"}, {"sha": "a243962b4eef886f01bfeb40b3c4e93996856344", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_fn_arg_names(&mut self, decl: &hir::FnDecl) -> LazySeq<ast::Name> {\n         self.lazy_seq(decl.inputs.iter().map(|arg| {\n-            if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n+            if let PatKind::Binding(_, _, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n                 Symbol::intern(\"\")\n@@ -729,7 +729,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Trait(self.lazy(&data))\n             }\n             hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) => bug!(\"cannot encode info for item {:?}\", item),\n+            hir::ItemUse(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n@@ -982,7 +982,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         let def_id = self.index.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) => (), // ignore these\n+            hir::ItemUse(..) => (), // ignore these\n             _ => self.index.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);"}, {"sha": "0e4dbb0477716a246acaa97d24c15c02c4d2860d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -182,7 +182,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(var_id) {\n-                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n             }\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n             let mut name = None;\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     name = Some(ident.node);\n                 }\n             }"}, {"sha": "a148ae08c53a4a1270c576141f227e6bd49e43cf", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -18,7 +18,6 @@ use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n-use rustc::middle::region::CodeExtent;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -265,10 +264,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     args: vec![fun.to_ref(), tupled_args.to_ref()]\n                 }\n             } else {\n-                let adt_data = if let hir::ExprPath(..) = fun.node {\n+                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n-                        match cx.tcx.expect_def(fun.id) {\n+                        match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n@@ -456,7 +455,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprStruct(_, ref fields, ref base) => {\n+        hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n                 ty::TyAdt(adt, substs) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n@@ -476,7 +475,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         }\n                     }\n                     AdtKind::Enum => {\n-                        match cx.tcx.expect_def(expr.id) {\n+                        let def = match *qpath {\n+                            hir::QPath::Resolved(_, ref path) => path.def,\n+                            hir::QPath::TypeRelative(..) => Def::Err\n+                        };\n+                        match def {\n                             Def::Variant(variant_id) => {\n                                 assert!(base.is_none());\n \n@@ -490,7 +493,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     base: None\n                                 }\n                             }\n-                            ref def => {\n+                            _ => {\n                                 span_bug!(\n                                     expr.span,\n                                     \"unexpected def: {:?}\",\n@@ -531,8 +534,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprPath(..) => {\n-            convert_path_expr(cx, expr)\n+        hir::ExprPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, expr.id);\n+            convert_path_expr(cx, expr, def)\n         }\n \n         hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n@@ -559,10 +563,18 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRet(ref v) =>\n             ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) =>\n-            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)),\n-                              value: value.to_ref() },\n+            ExprKind::Break {\n+                label: label.map(|label| {\n+                    cx.tcx.region_maps.node_extent(label.loop_id)\n+                }),\n+                value: value.to_ref()\n+            },\n         hir::ExprAgain(label) =>\n-            ExprKind::Continue { label: label.map(|_| loop_label(cx, expr)) },\n+            ExprKind::Continue {\n+                label: label.map(|label| {\n+                    cx.tcx.region_maps.node_extent(label.loop_id)\n+                })\n+            },\n         hir::ExprMatch(ref discr, ref arms, _) =>\n             ExprKind::Match { discriminant: discr.to_ref(),\n                               arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n@@ -661,11 +673,11 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                     expr: &'tcx hir::Expr)\n+                                     expr: &'tcx hir::Expr,\n+                                     def: Def)\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-    let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) | Def::Method(def_id) |\n@@ -990,14 +1002,6 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                              expr: &'tcx hir::Expr) -> CodeExtent {\n-    match cx.tcx.expect_def(expr.id) {\n-        Def::Label(loop_id) => cx.tcx.region_maps.node_extent(loop_id),\n-        d => span_bug!(expr.span, \"loop scope resolved to {:?}\", d),\n-    }\n-}\n-\n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n                     fields: &'tcx [hir::Field])"}, {"sha": "d9b1f247c7270e0cc17123e9e1da41318a487ce9", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -487,8 +487,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 _ => {}\n             }\n         }\n-        hir::ExprPath(..) => {\n-            match v.tcx.expect_def(e.id) {\n+        hir::ExprPath(ref qpath) => {\n+            let def = v.tcx.tables().qpath_def(qpath, e.id);\n+            match def {\n                 Def::VariantCtor(_, CtorKind::Const) => {\n                     // Size is determined by the whole enum, may be non-zero.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n@@ -531,17 +532,22 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let is_const = match v.tcx.expect_def_or_none(callee.id) {\n-                Some(Def::StructCtor(_, CtorKind::Fn)) |\n-                Some(Def::VariantCtor(_, CtorKind::Fn)) => {\n+            let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                v.tcx.tables().qpath_def(qpath, callee.id)\n+            } else {\n+                Def::Err\n+            };\n+            let is_const = match def {\n+                Def::StructCtor(_, CtorKind::Fn) |\n+                Def::VariantCtor(_, CtorKind::Fn) => {\n                     // `NON_ZERO_SIZED` is about the call result, not about the ctor itself.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     true\n                 }\n-                Some(Def::Fn(did)) => {\n+                Def::Fn(did) => {\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n-                Some(Def::Method(did)) => {\n+                Def::Method(did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)"}, {"sha": "ba236ea93a4bc37df3c71b5a4e5fa83ed0979256", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -218,23 +218,20 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"LifetimeDef\", Id::None, lifetime);\n         hir_visit::walk_lifetime_def(self, lifetime)\n     }\n+    fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: NodeId, span: Span) {\n+        self.record(\"QPath\", Id::None, qpath);\n+        hir_visit::walk_qpath(self, qpath, id, span)\n+    }\n     fn visit_path(&mut self, path: &'v hir::Path, _id: NodeId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self,\n-                            prefix: &'v hir::Path,\n-                            item: &'v hir::PathListItem) {\n-        self.record(\"PathListItem\", Id::Node(item.node.id), item);\n-        hir_visit::walk_path_list_item(self, prefix, item)\n-    }\n     fn visit_path_segment(&mut self,\n                           path_span: Span,\n                           path_segment: &'v hir::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n-\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)"}, {"sha": "a622a3faf7098dc31326ec7a91f496892eeb683b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -12,10 +12,10 @@ use self::Context::*;\n use rustc::session::Session;\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::def::{Def, DefMap};\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n+use syntax::ast;\n use syntax_pos::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -45,17 +45,15 @@ enum Context {\n #[derive(Copy, Clone)]\n struct CheckLoopVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a DefMap,\n     hir_map: &'a Map<'ast>,\n     cx: Context,\n }\n \n-pub fn check_crate(sess: &Session, def_map: &DefMap, map: &Map) {\n+pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n     krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n-        def_map: def_map,\n         hir_map: map,\n         cx: Normal,\n     }.as_deep_visitor());\n@@ -84,21 +82,18 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n             hir::ExprClosure(.., ref b, _) => {\n                 self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n-            hir::ExprBreak(ref opt_label, ref opt_expr) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {\n-                    let loop_kind = if opt_label.is_some() {\n-                        let loop_def = self.def_map.get(&e.id).unwrap().full_def();\n-                        if loop_def == Def::Err {\n+                    let loop_kind = if let Some(label) = label {\n+                        if label.loop_id == ast::DUMMY_NODE_ID {\n                             None\n-                        } else if let Def::Label(loop_id) = loop_def {\n-                            Some(match self.hir_map.expect_expr(loop_id).node {\n+                        } else {\n+                            Some(match self.hir_map.expect_expr(label.loop_id).node {\n                                 hir::ExprWhile(..) => LoopKind::WhileLoop,\n                                 hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n                                 ref r => span_bug!(e.span,\n                                                    \"break label resolved to a non-loop: {:?}\", r),\n                             })\n-                        } else {\n-                            span_bug!(e.span, \"break resolved to a non-label\")\n                         }\n                     } else if let Loop(kind) = self.cx {\n                         Some(kind)"}, {"sha": "b5daf0284e1d6a4e8b6b2606a79c0496a2d46b0a", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,7 +14,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n use rustc::session::{CompileResult, Session};\n-use rustc::hir::def::{Def, CtorKind, DefMap};\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::util::nodemap::NodeMap;\n \n use syntax::ast;\n@@ -27,7 +27,6 @@ use std::cell::RefCell;\n \n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a DefMap,\n     ast_map: &'a ast_map::Map<'ast>,\n     // `discriminant_map` is a cache that associates the `NodeId`s of local\n     // variant definitions with the discriminant expression that applies to\n@@ -88,14 +87,12 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>)\n                          -> CompileResult {\n     let _task = ast_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n \n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n-        def_map: def_map,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n@@ -109,7 +106,6 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n-    def_map: &'a DefMap,\n     discriminant_map: &'a RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n     idstack: Vec<ast::NodeId>,\n }\n@@ -122,7 +118,6 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n             root_span: span,\n             sess: v.sess,\n             ast_map: v.ast_map,\n-            def_map: v.def_map,\n             discriminant_map: &v.discriminant_map,\n             idstack: Vec::new(),\n         }\n@@ -250,11 +245,11 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n \n     fn visit_expr(&mut self, e: &'ast hir::Expr) {\n         match e.node {\n-            hir::ExprPath(..) => {\n-                match self.def_map.get(&e.id).map(|d| d.base_def) {\n-                    Some(Def::Static(def_id, _)) |\n-                    Some(Def::AssociatedConst(def_id)) |\n-                    Some(Def::Const(def_id)) => {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Static(def_id, _) |\n+                    Def::AssociatedConst(def_id) |\n+                    Def::Const(def_id) => {\n                         if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n                             match self.ast_map.get(node_id) {\n                                 ast_map::NodeItem(item) => self.visit_item(item),\n@@ -273,7 +268,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::VariantCtor(variant_id, CtorKind::Const)) => {\n+                    Def::VariantCtor(variant_id, CtorKind::Const) => {\n                         if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n                             let variant = self.ast_map.expect_variant(variant_id);\n                             let enum_id = self.ast_map.get_parent(variant_id);"}, {"sha": "ee18968ff35e3b61bb3099eff84d675c5e084af8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 320, "deletions": 264, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -31,11 +31,12 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n+use rustc::ty::fold::TypeVisitor;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -62,36 +63,32 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+    item_def_id: DefId,\n     ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n-        if let hir::TyPath(..) = ty.node {\n-            match self.tcx.expect_def(ty.id) {\n-                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n-                    Some(AccessLevel::Public)\n-                }\n-                def => {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                        self.get(node_id)\n-                    } else {\n-                        Some(AccessLevel::Public)\n-                    }\n-                }\n-            }\n+    fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n+        let ty_def_id = match self.tcx.item_type(item_def_id).sty {\n+            ty::TyAdt(adt, _) => adt.did,\n+            ty::TyTrait(ref obj) => obj.principal.def_id(),\n+            ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n+            _ => return Some(AccessLevel::Public)\n+        };\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(ty_def_id) {\n+            self.get(node_id)\n         } else {\n             Some(AccessLevel::Public)\n         }\n     }\n \n-    fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n-        let did = self.tcx.expect_def(trait_ref.ref_id).def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            self.get(node_id)\n-        } else {\n-            Some(AccessLevel::Public)\n+    fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n+                return self.get(node_id);\n+            }\n         }\n+        Some(AccessLevel::Public)\n     }\n \n     fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n@@ -111,8 +108,12 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn reach<'b>(&'b mut self) -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-        ReachEverythingInTheInterfaceVisitor { ev: self }\n+    fn reach<'b>(&'b mut self, item_id: ast::NodeId)\n+                 -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor {\n+            item_def_id: self.tcx.map.local_def_id(item_id),\n+            ev: self,\n+        }\n     }\n }\n \n@@ -126,14 +127,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n-            hir::ItemImpl(.., None, ref ty, _) => {\n-                self.ty_level(&ty)\n+            hir::ItemImpl(..) => {\n+                let def_id = self.tcx.map.local_def_id(item.id);\n+                cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n-            hir::ItemImpl(.., Some(ref trait_ref), ref ty, _) => {\n-                cmp::min(self.ty_level(&ty), self.trait_level(trait_ref))\n-            }\n-            hir::ItemDefaultImpl(_, ref trait_ref) => {\n-                self.trait_level(trait_ref)\n+            hir::ItemDefaultImpl(..) => {\n+                let def_id = self.tcx.map.local_def_id(item.id);\n+                self.impl_trait_level(def_id)\n             }\n             // Foreign mods inherit level from parents\n             hir::ItemForeignMod(..) => {\n@@ -205,22 +205,54 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemMod(..) => {}\n             // Reexports are handled in visit_mod\n             hir::ItemUse(..) => {}\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n             // Visit everything\n-            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemTrait(..) | hir::ItemTy(..) | hir::ItemImpl(.., Some(..), _, _) => {\n+            hir::ItemConst(..) | hir::ItemStatic(..) |\n+            hir::ItemFn(..) | hir::ItemTy(..) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_item(item);\n+                    self.reach(item.id).generics().predicates().item_type();\n                 }\n             }\n+            hir::ItemTrait(.., ref trait_items) => {\n+                if item_level.is_some() {\n+                    self.reach(item.id).generics().predicates();\n+\n+                    for trait_item in trait_items {\n+                        let mut reach = self.reach(trait_item.id);\n+                        reach.generics().predicates();\n+\n+                        if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                            // No type to visit.\n+                        } else {\n+                            reach.item_type();\n+                        }\n+                    }\n+                }\n+            }\n+            // Visit everything except for private impl items\n+            hir::ItemImpl(.., ref trait_ref, _, ref impl_items) => {\n+                if item_level.is_some() {\n+                    self.reach(item.id).generics().predicates().impl_trait_ref();\n+\n+                    for impl_item in impl_items {\n+                        let id = impl_item.id.node_id;\n+                        if trait_ref.is_some() || self.get(id).is_some() {\n+                            self.reach(id).generics().predicates().item_type();\n+                        }\n+                    }\n+                }\n+            }\n+\n             // Visit everything, but enum variants have their own levels\n-            hir::ItemEnum(ref def, ref generics) => {\n+            hir::ItemEnum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n+                    self.reach(item.id).generics().predicates();\n                 }\n                 for variant in &def.variants {\n                     if self.get(variant.node.data.id()).is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach().visit_struct_field(field);\n+                            self.reach(field.id).item_type();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n@@ -232,32 +264,18 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n-                        self.reach().visit_foreign_item(foreign_item);\n+                        self.reach(foreign_item.id).generics().predicates().item_type();\n                     }\n                 }\n             }\n             // Visit everything except for private fields\n-            hir::ItemStruct(ref struct_def, ref generics) |\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n+                    self.reach(item.id).generics().predicates();\n                     for field in struct_def.fields() {\n                         if self.get(field.id).is_some() {\n-                            self.reach().visit_struct_field(field);\n-                        }\n-                    }\n-                }\n-            }\n-            // The interface is empty\n-            hir::ItemDefaultImpl(..) => {}\n-            // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_item_refs) => {\n-                if item_level.is_some() {\n-                    self.reach().visit_generics(generics);\n-                    for impl_item_ref in impl_item_refs {\n-                        if self.get(impl_item_ref.id.node_id).is_some() {\n-                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                            self.reach().visit_impl_item(impl_item);\n+                            self.reach(field.id).item_type();\n                         }\n                     }\n                 }\n@@ -302,79 +320,69 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         self.update(md.id, Some(AccessLevel::Public));\n     }\n-}\n \n-impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, path: &'tcx hir::Path) {\n-        if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            // See `fn is_public_type_alias` for details\n-            self.visit_ty(ty);\n-            let provided_params = path.segments.last().unwrap().parameters.types().len();\n-            for ty_param in &generics.ty_params[provided_params..] {\n-                if let Some(ref default_ty) = ty_param.default {\n-                    self.visit_ty(default_ty);\n-                }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            if self.get(ty.id).is_some() {\n+                // Reach the (potentially private) type and the API being exposed.\n+                self.reach(ty.id).item_type().predicates();\n             }\n         }\n+\n+        intravisit::walk_ty(self, ty);\n     }\n }\n \n-impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n-        // when we visit an impl, its methods and items are part of its \"interface\"\n-        let impl_item = self.ev.tcx.map.impl_item(item_id);\n-        self.visit_impl_item(impl_item)\n+impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn generics(&mut self) -> &mut Self {\n+        self.ev.tcx.item_generics(self.item_def_id).visit_with(self);\n+        self\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyPath(_, ref path) = ty.node {\n-            let def = self.ev.tcx.expect_def(ty.id);\n-            match def {\n-                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n-                    if let Some(mut node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n-                        // Check the trait for associated types.\n-                        if let hir::map::NodeTraitItem(_) = self.ev.tcx.map.get(node_id) {\n-                            node_id = self.ev.tcx.map.get_parent(node_id);\n-                        }\n+    fn predicates(&mut self) -> &mut Self {\n+        self.ev.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self\n+    }\n \n-                        let item = self.ev.tcx.map.expect_item(node_id);\n-                        if let Def::TyAlias(..) = def {\n-                            // Type aliases are substituted. Associated type aliases are not\n-                            // substituted yet, but ideally they should be.\n-                            if self.ev.get(item.id).is_none() {\n-                                self.reach_aliased_type(item, path);\n-                            }\n-                        } else {\n-                            self.ev.update(item.id, Some(AccessLevel::Reachable));\n-                        }\n-                    }\n-                }\n+    fn item_type(&mut self) -> &mut Self {\n+        self.ev.tcx.item_type(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.ev.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        self\n+    }\n+}\n \n-                _ => {}\n+impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty_def_id = match ty.sty {\n+            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+            ty::TyFnDef(def_id, ..) |\n+            ty::TyAnon(def_id, _) => Some(def_id),\n+            _ => None\n+        };\n+\n+        if let Some(def_id) = ty_def_id {\n+            if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                self.ev.update(node_id, Some(AccessLevel::Reachable));\n             }\n         }\n \n-        intravisit::walk_ty(self, ty);\n+        ty.super_visit_with(self)\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n-        let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n-        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(trait_ref.def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n         }\n \n-        intravisit::walk_trait_ref(self, trait_ref);\n+        trait_ref.super_visit_with(self)\n     }\n-\n-    // Don't recurse into function bodies\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    // Don't recurse into expressions in array sizes or const initializers\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n-    // Don't recurse into patterns in function arguments\n-    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -441,9 +449,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                 let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n-            hir::ExprStruct(_, ref expr_fields, _) => {\n+            hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n                 let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n+                let variant = adt.variant_of_def(def);\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all,\n@@ -461,9 +470,9 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprPath(..) => {\n-                if let def @ Def::StructCtor(_, CtorKind::Fn) = self.tcx.expect_def(expr.id) {\n-                    let adt_def = self.tcx.expect_variant_def(def);\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::StructCtor(_, CtorKind::Fn) = path.def {\n+                    let adt_def = self.tcx.expect_variant_def(path.def);\n                     let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n                         !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n                     }).map(|(i, _)| i).collect::<Vec<_>>();\n@@ -502,9 +511,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         if self.in_foreign { return }\n \n         match pattern.node {\n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pattern.id);\n                 let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n+                let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n@@ -564,8 +574,8 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.expect_def(path_id) {\n+    fn path_is_private_type(&self, path: &hir::Path) -> bool {\n+        let did = match path.def {\n             Def::PrimTy(..) | Def::SelfTy(..) => return false,\n             def => def.def_id(),\n         };\n@@ -593,7 +603,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn check_ty_param_bound(&mut self,\n                             ty_param_bound: &hir::TyParamBound) {\n         if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n-            if self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+            if self.path_is_private_type(&trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n             }\n         }\n@@ -606,13 +616,16 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(..) = ty.node {\n-            if self.inner.path_is_private_type(ty.id) {\n+        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = ty.node {\n+            if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n                 // working.\n                 return\n-            } else if self.at_outer_type {\n+            }\n+        }\n+        if let hir::TyPath(_) = ty.node {\n+            if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n         }\n@@ -682,7 +695,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = self.tcx.expect_def(tr.ref_id).def_id();\n+                        let did = tr.path.def.def_id();\n \n                         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n@@ -844,8 +857,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyPath(..) = t.node {\n-            if self.path_is_private_type(t.id) {\n+        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = t.node {\n+            if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.id);\n             }\n         }\n@@ -886,181 +899,174 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item_def_id: DefId,\n+    span: Span,\n     /// The visitor checks that each component type is at least this visible\n     required_visibility: ty::Visibility,\n     /// The visibility of the least visible component that has been visited\n     min_visibility: ty::Visibility,\n-    old_error_set: &'a NodeSet,\n+    has_old_errors: bool,\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n-        SearchInterfaceForPrivateItemsVisitor {\n-            tcx: tcx,\n-            min_visibility: ty::Visibility::Public,\n-            required_visibility: ty::Visibility::PrivateExternal,\n-            old_error_set: old_error_set,\n-        }\n+    fn generics(&mut self) -> &mut Self {\n+        self.tcx.item_generics(self.item_def_id).visit_with(self);\n+        self\n     }\n-}\n \n-impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    // Return the visibility of the type alias's least visible component type when substituted\n-    fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n-                                    -> Option<ty::Visibility> {\n-        // Type alias is considered public if the aliased type is\n-        // public, even if the type alias itself is private. So, something\n-        // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n-        if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx,\n-                                                                       self.old_error_set);\n-            check.visit_ty(ty);\n-            // If a private type alias with default type parameters is used in public\n-            // interface we must ensure, that the defaults are public if they are actually used.\n-            // ```\n-            // type Alias<T = Private> = T;\n-            // pub fn f() -> Alias {...} // `Private` is implicitly used here, so it must be public\n-            // ```\n-            let provided_params = path.segments.last().unwrap().parameters.types().len();\n-            for ty_param in &generics.ty_params[provided_params..] {\n-                if let Some(ref default_ty) = ty_param.default {\n-                    check.visit_ty(default_ty);\n-                }\n-            }\n-            Some(check.min_visibility)\n-        } else {\n-            None\n-        }\n+    fn predicates(&mut self) -> &mut Self {\n+        self.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn item_type(&mut self) -> &mut Self {\n+        self.tcx.item_type(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        self\n     }\n }\n \n-impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(_, ref path) = ty.node {\n-            match self.tcx.expect_def(ty.id) {\n-                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n-                    // Public\n-                }\n-                Def::AssociatedTy(..)\n-                    if self.required_visibility == ty::Visibility::PrivateExternal => {\n+impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty_def_id = match ty.sty {\n+            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyProjection(ref proj) => {\n+                if self.required_visibility == ty::Visibility::PrivateExternal {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n                     // even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n-                    return\n+                    return false;\n                 }\n-                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n-                    // Non-local means public (private items can't leave their crate, modulo bugs)\n-                    if let Some(mut node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                        // Check the trait for associated types.\n-                        if let hir::map::NodeTraitItem(_) = self.tcx.map.get(node_id) {\n-                            node_id = self.tcx.map.get_parent(node_id);\n-                        }\n \n-                        let item = self.tcx.map.expect_item(node_id);\n-                        let vis = match self.substituted_alias_visibility(item, path) {\n-                            Some(vis) => vis,\n-                            None => ty::Visibility::from_hir(&item.vis, node_id, self.tcx),\n-                        };\n+                Some(proj.trait_ref.def_id)\n+            }\n+            _ => None\n+        };\n \n-                        if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n-                            self.min_visibility = vis;\n-                        }\n-                        if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                            if self.tcx.sess.features.borrow().pub_restricted ||\n-                               self.old_error_set.contains(&ty.id) {\n-                                let mut err = struct_span_err!(self.tcx.sess, ty.span, E0446,\n-                                          \"private type in public interface\");\n-                                err.span_label(ty.span, &format!(\"can't leak private type\"));\n-                                err.emit();\n-                            } else {\n-                                self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       node_id,\n-                                                       ty.span,\n-                                                       format!(\"private type in public \\\n-                                                                interface (error E0446)\"));\n-                            }\n-                        }\n+        if let Some(def_id) = ty_def_id {\n+            // Non-local means public (private items can't leave their crate, modulo bugs)\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                let item = self.tcx.map.expect_item(node_id);\n+                let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n+\n+                if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                    self.min_visibility = vis;\n+                }\n+                if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                    if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n+                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n+                            \"private type `{}` in public interface\", ty);\n+                        err.span_label(self.span, &format!(\"can't leak private type\"));\n+                        err.emit();\n+                    } else {\n+                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               node_id,\n+                                               self.span,\n+                                               format!(\"private type `{}` in public \\\n+                                                        interface (error E0446)\", ty));\n                     }\n                 }\n-                _ => {}\n             }\n         }\n \n-        intravisit::walk_ty(self, ty);\n+        if let ty::TyProjection(ref proj) = ty.sty {\n+            // Avoid calling `visit_trait_ref` below on the trait,\n+            // as we have already checked the trait itself above.\n+            proj.trait_ref.super_visit_with(self)\n+        } else {\n+            ty.super_visit_with(self)\n+        }\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        let def_id = self.tcx.expect_def(trait_ref.ref_id).def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n             if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n                 self.min_visibility = vis;\n             }\n             if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                if self.tcx.sess.features.borrow().pub_restricted ||\n-                   self.old_error_set.contains(&trait_ref.ref_id) {\n-                    struct_span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                     \"private trait in public interface\")\n-                        .span_label(trait_ref.path.span, &format!(\n+                if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n+                    struct_span_err!(self.tcx.sess, self.span, E0445,\n+                                     \"private trait `{}` in public interface\", trait_ref)\n+                        .span_label(self.span, &format!(\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {\n                     self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n                                            node_id,\n-                                           trait_ref.path.span,\n-                                           \"private trait in public interface (error E0445)\"\n-                                                .to_string());\n+                                           self.span,\n+                                           format!(\"private trait `{}` in public \\\n+                                                    interface (error E0445)\", trait_ref));\n                 }\n             }\n         }\n \n-        intravisit::walk_trait_ref(self, trait_ref);\n+        trait_ref.super_visit_with(self)\n     }\n-\n-    // Don't recurse into function bodies\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    // Don't recurse into expressions in array sizes or const initializers\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n-    // Don't recurse into patterns in function arguments\n-    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     old_error_set: &'a NodeSet,\n+    inner_visibility: ty::Visibility,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    // A type is considered public if it doesn't contain any private components\n-    fn ty_visibility(&self, ty: &hir::Ty) -> ty::Visibility {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        check.visit_ty(ty);\n-        check.min_visibility\n-    }\n+    fn check(&self, item_id: ast::NodeId, required_visibility: ty::Visibility)\n+             -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+        let mut has_old_errors = false;\n+\n+        // Slow path taken only if there any errors in the crate.\n+        for &id in self.old_error_set {\n+            // Walk up the nodes until we find `item_id` (or we hit a root).\n+            let mut id = id;\n+            loop {\n+                if id == item_id {\n+                    has_old_errors = true;\n+                    break;\n+                }\n+                let parent = self.tcx.map.get_parent_node(id);\n+                if parent == id {\n+                    break;\n+                }\n+                id = parent;\n+            }\n \n-    // A trait reference is considered public if it doesn't contain any private components\n-    fn trait_ref_visibility(&self, trait_ref: &hir::TraitRef) -> ty::Visibility {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        check.visit_trait_ref(trait_ref);\n-        check.min_visibility\n+            if has_old_errors {\n+                break;\n+            }\n+        }\n+\n+        SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx,\n+            item_def_id: self.tcx.map.local_def_id(item_id),\n+            span: self.tcx.map.span(item_id),\n+            min_visibility: ty::Visibility::Public,\n+            required_visibility: required_visibility,\n+            has_old_errors: has_old_errors,\n+        }\n     }\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        let tcx = self.tcx;\n         let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n+            if vis1.is_at_least(vis2, &tcx.map) { vis2 } else { vis1 }\n         };\n \n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, self.tcx);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n \n         match item.node {\n             // Crates are always public\n@@ -1071,56 +1077,87 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             hir::ItemUse(..) => {}\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n-                check.required_visibility = item_visibility;\n-                check.visit_item(item);\n+            hir::ItemTy(..) => {\n+                self.check(item.id, item_visibility).generics().predicates().item_type();\n+\n+                // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                self.inner_visibility = item_visibility;\n+                intravisit::walk_item(self, item);\n+            }\n+            hir::ItemTrait(.., ref trait_items) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n+\n+                for trait_item in trait_items {\n+                    let mut check = self.check(trait_item.id, item_visibility);\n+                    check.generics().predicates();\n+\n+                    if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                        // No type to visit.\n+                    } else {\n+                        check.item_type();\n+                    }\n+                }\n+            }\n+            hir::ItemEnum(ref def, _) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n+\n+                for variant in &def.variants {\n+                    for field in variant.node.data.fields() {\n+                        self.check(field.id, item_visibility).item_type();\n+                    }\n+                }\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    check.required_visibility =\n-                        ty::Visibility::from_hir(&foreign_item.vis, item.id, self.tcx);\n-                    check.visit_foreign_item(foreign_item);\n+                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n+                    self.check(foreign_item.id, vis).generics().predicates().item_type();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity\n-            hir::ItemStruct(ref struct_def, ref generics) |\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n-                check.required_visibility = item_visibility;\n-                check.visit_generics(generics);\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, self.tcx);\n-                    check.required_visibility = min(item_visibility, field_visibility);\n-                    check.visit_struct_field(field);\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n+                    self.check(field.id, min(item_visibility, field_visibility)).item_type();\n                 }\n             }\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_refs) => {\n-                let ty_vis = self.ty_visibility(ty);\n-                check.required_visibility = ty_vis;\n-                check.visit_generics(generics);\n+            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+                let ty_vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                                 .item_type().min_visibility;\n+                self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n-                        ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n-                    check.required_visibility = min(impl_item_vis, ty_vis);\n-                    check.visit_impl_item(impl_item);\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n+                    self.check(impl_item.id, min(impl_item_vis, ty_vis))\n+                        .generics().predicates().item_type();\n+\n+                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    self.inner_visibility = impl_item_vis;\n+                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_refs) => {\n-                let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n-                check.required_visibility = vis;\n-                check.visit_generics(generics);\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+                let vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                              .item_type().impl_trait_ref().min_visibility;\n+                self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                    check.visit_impl_item(impl_item);\n+                    self.check(impl_item.id, vis).generics().predicates().item_type();\n+\n+                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    self.inner_visibility = vis;\n+                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n         }\n@@ -1129,6 +1166,24 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n     fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n         // handled in `visit_item` above\n     }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            // Check the traits being exposed, as they're separate,\n+            // e.g. `impl Iterator<Item=T>` has two predicates,\n+            // `X: Iterator` and `<X as Iterator>::Item == T`,\n+            // where `X` is the `impl Iterator<Item=T>` itself,\n+            // stored in `item_predicates`, not in the `Ty` itself.\n+            self.check(ty.id, self.inner_visibility).predicates();\n+        }\n+\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    // Don't recurse into expressions in array sizes or const initializers\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1180,8 +1235,9 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n             tcx: tcx,\n             old_error_set: &visitor.old_error_set,\n+            inner_visibility: ty::Visibility::Public,\n         };\n-        krate.visit_all_item_likes(&mut visitor);\n+        krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }\n \n     visitor.access_levels"}, {"sha": "058c8266a35e959f6772e5287a7af2a5109daed1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1201,11 +1201,11 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n }\n \n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n+    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => binding.def(),\n-            Err(true) => Def::Err,\n+            Ok(binding) => path.def = binding.def(),\n+            Err(true) => {}\n             Err(false) => {\n                 let path_name = &format!(\"{}\", path);\n                 let error =\n@@ -1218,7 +1218,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n                         def: Def::Err,\n                     };\n                 resolve_error(self, path.span, error);\n-                Def::Err\n             }\n         }\n     }"}, {"sha": "c3b1649662a45086db8d8f4424eacb5ccfccaeb7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -68,7 +68,6 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-    analysis: &'l ty::CrateAnalysis<'l>,\n     dumper: &'ll mut D,\n \n     span: SpanUtils<'l>,\n@@ -84,17 +83,14 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-               save_ctxt: SaveContext<'l, 'tcx>,\n-               analysis: &'l ty::CrateAnalysis<'l>,\n+    pub fn new(save_ctxt: SaveContext<'l, 'tcx>,\n                dumper: &'ll mut D)\n                -> DumpVisitor<'l, 'tcx, 'll, D> {\n-        let span_utils = SpanUtils::new(&tcx.sess);\n+        let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         DumpVisitor {\n-            sess: &tcx.sess,\n-            tcx: tcx,\n+            sess: &save_ctxt.tcx.sess,\n+            tcx: save_ctxt.tcx,\n             save_ctxt: save_ctxt,\n-            analysis: analysis,\n             dumper: dumper,\n             span: span_utils.clone(),\n             cur_scope: CRATE_NODE_ID,\n@@ -274,12 +270,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        self.tcx.expect_def_or_none(ref_id).and_then(|def| {\n-            match def {\n-                Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n-                def => Some(def.def_id()),\n-            }\n-        })\n+        match self.save_ctxt.get_path_def(ref_id) {\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n+            def => Some(def.def_id()),\n+        }\n     }\n \n     fn process_def_kind(&mut self,\n@@ -292,7 +286,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             return;\n         }\n \n-        let def = self.tcx.expect_def(ref_id);\n+        let def = self.save_ctxt.get_path_def(ref_id);\n         match def {\n             Def::Mod(_) => {\n                 self.dumper.mod_ref(ModRefData {\n@@ -919,7 +913,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         // Modules or types in the path prefix.\n-        match self.tcx.expect_def(id) {\n+        match self.save_ctxt.get_path_def(id) {\n             Def::Method(did) => {\n                 let ti = self.tcx.associated_item(did);\n                 if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n@@ -998,7 +992,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         return;\n                     }\n                 };\n-                let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n+                let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n@@ -1209,7 +1203,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n                         let mut names = vec![];\n-                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = &self.save_ctxt.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n                             for n in glob_map.get(&item.id).unwrap() {\n@@ -1370,7 +1364,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let def = self.tcx.expect_def(hir_expr.id);\n+                let def = self.save_ctxt.get_path_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(.., ref args) => self.process_method_call(ex, args),\n@@ -1480,7 +1474,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n \n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            match self.tcx.expect_def(id) {\n+            match self.save_ctxt.get_path_def(id) {\n                 Def::Local(def_id) => {\n                     let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                     let mut value = if immut == ast::Mutability::Immutable {"}, {"sha": "389892193c330cf289134a5e409d59ca907768d5", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -42,8 +42,8 @@ pub mod external_data;\n pub mod span_utils;\n \n use rustc::hir;\n-use rustc::hir::map::{Node, NodeItem};\n use rustc::hir::def::Def;\n+use rustc::hir::map::Node;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n@@ -85,6 +85,7 @@ pub mod recorder {\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    analysis: &'l ty::CrateAnalysis<'tcx>,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -93,16 +94,20 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>) -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+               analysis: &'l ty::CrateAnalysis<'tcx>)\n+               -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n-        SaveContext::from_span_utils(tcx, span_utils)\n+        SaveContext::from_span_utils(tcx, analysis, span_utils)\n     }\n \n     pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+                           analysis: &'l ty::CrateAnalysis<'tcx>,\n                            span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n+            analysis: analysis,\n             span_utils: span_utils,\n         }\n     }\n@@ -318,7 +323,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, vis, docs) =\n           match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n-                Some(NodeItem(item)) => {\n+                Some(Node::NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n@@ -358,7 +363,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n                     match self.tcx.map.get_if_local(def_id) {\n-                        Some(NodeItem(item)) => {\n+                        Some(Node::NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n                              Some(def_id), None,\n                              From::from(&item.vis),\n@@ -497,13 +502,51 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n-        let resolution = self.tcx.expect_resolution(id);\n-        if resolution.depth != 0 {\n-            return None;\n+    pub fn get_path_def(&self, id: NodeId) -> Def {\n+        match self.tcx.map.get(id) {\n+            Node::NodeTraitRef(tr) => tr.path.def,\n+\n+            Node::NodeItem(&hir::Item { node: hir::ItemUse(ref path, _), .. }) |\n+            Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n+\n+            Node::NodeExpr(&hir::Expr { node: hir::ExprPath(ref qpath), .. }) |\n+            Node::NodeExpr(&hir::Expr { node: hir::ExprStruct(ref qpath, ..), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n+                self.tcx.tables().qpath_def(qpath, id)\n+            }\n+\n+            Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n+                Def::Local(def_id)\n+            }\n+\n+            Node::NodeTy(&hir::Ty { node: hir::TyPath(ref qpath), .. }) => {\n+                match *qpath {\n+                    hir::QPath::Resolved(_, ref path) => path.def,\n+                    hir::QPath::TypeRelative(..) => {\n+                        if let Some(ty) = self.analysis.hir_ty_to_ty.get(&id) {\n+                            if let ty::TyProjection(proj) = ty.sty {\n+                                for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n+                                    if item.kind == ty::AssociatedKind::Type {\n+                                        if item.name == proj.item_name {\n+                                            return Def::AssociatedTy(item.def_id);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        Def::Err\n+                    }\n+                }\n+            }\n+\n+            _ => Def::Err\n         }\n-        let def = resolution.base_def;\n+    }\n \n+    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n+        let def = self.get_path_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n@@ -647,8 +690,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.tcx.expect_def(ref_id) {\n-            Def::PrimTy(_) | Def::SelfTy(..) => None,\n+        match self.get_path_def(ref_id) {\n+            Def::PrimTy(_) | Def::SelfTy(..) | Def::Err => None,\n             def => Some(def.def_id()),\n         }\n     }\n@@ -771,7 +814,7 @@ impl Format {\n \n pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                                krate: &ast::Crate,\n-                               analysis: &'l ty::CrateAnalysis<'l>,\n+                               analysis: &'l ty::CrateAnalysis<'tcx>,\n                                cratename: &str,\n                                odir: Option<&Path>,\n                                format: Format) {\n@@ -819,12 +862,12 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     root_path.pop();\n     let output = &mut output_file;\n \n-    let save_ctxt = SaveContext::new(tcx);\n+    let save_ctxt = SaveContext::new(tcx, analysis);\n \n     macro_rules! dump {\n         ($new_dumper: expr) => {{\n             let mut dumper = $new_dumper;\n-            let mut visitor = DumpVisitor::new(tcx, save_ctxt, analysis, &mut dumper);\n+            let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n \n             visitor.dump_crate_info(cratename, krate);\n             visit::walk_crate(&mut visitor, krate);"}, {"sha": "c94c25e0b056cb2bcb78b11e360d5552fca139b8", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1545,7 +1545,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    let link_meta = link::build_link_meta(incremental_hashes_map, name);\n+    let link_meta = link::build_link_meta(incremental_hashes_map, &name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              export_map,"}, {"sha": "bb7b62533001db17b633a294ca0f93615511af6e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 83, "deletions": 184, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -50,7 +50,7 @@\n \n use rustc_const_eval::eval_length;\n use hir::{self, SelfKind};\n-use hir::def::{Def, PathResolution};\n+use hir::def::Def;\n use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n@@ -149,14 +149,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn set_tainted_by_errors(&self);\n }\n \n-#[derive(PartialEq, Eq)]\n-pub enum PathParamMode {\n-    // Any path in a type context.\n-    Explicit,\n-    // The `module::Type` in `module::Type::method` in an expression.\n-    Optional\n-}\n-\n struct ConvertedBinding<'tcx> {\n     item_name: ast::Name,\n     ty: Ty<'tcx>,\n@@ -341,7 +333,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_path_substs_for_ty(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         def_id: DefId,\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n@@ -367,7 +358,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_path(rscope,\n                                             span,\n-                                            param_mode,\n                                             def_id,\n                                             &item_segment.parameters,\n                                             None);\n@@ -385,7 +375,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_path(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n         self_ty: Option<Ty<'tcx>>)\n@@ -397,15 +386,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                parameters={:?})\",\n                def_id, self_ty, parameters);\n \n-        let (lifetimes, num_types_provided) = match *parameters {\n+        let (lifetimes, num_types_provided, infer_types) = match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n-                if param_mode == PathParamMode::Optional && data.types.is_empty() {\n-                    (&data.lifetimes[..], None)\n-                } else {\n-                    (&data.lifetimes[..], Some(data.types.len()))\n-                }\n+                (&data.lifetimes[..], data.types.len(), data.infer_types)\n             }\n-            hir::ParenthesizedParameters(_) => (&[][..], Some(1))\n+            hir::ParenthesizedParameters(_) => (&[][..], 1, false)\n         };\n \n         // If the type is parameterized by this region, then replace this\n@@ -443,9 +428,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n-        if let Some(num_provided) = num_types_provided {\n-            let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-            check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n+        let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n+        if !infer_types || num_types_provided > ty_param_defs.len() {\n+            check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n@@ -474,7 +459,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n \n             let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n-            if num_types_provided.map_or(false, |n| i < n) {\n+            if i < num_types_provided {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n@@ -488,7 +473,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         ty\n                     }\n                 }\n-            } else if num_types_provided.is_none() {\n+            } else if infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -664,7 +649,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_poly_trait_ref(rscope,\n                                         trait_ref.path.span,\n-                                        PathParamMode::Explicit,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.ref_id,\n@@ -687,15 +671,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_mono_trait_ref(rscope,\n                                         trait_ref.path.span,\n-                                        PathParamMode::Explicit,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n-        match self.tcx().expect_def(trait_ref.ref_id) {\n+        match path.def {\n             Def::Trait(trait_def_id) => trait_def_id,\n             Def::Err => {\n                 self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n@@ -710,7 +693,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         path_id: ast::NodeId,\n@@ -729,7 +711,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(shifted_rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -752,7 +733,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_mono_trait_ref(&self,\n                                   rscope: &RegionScope,\n                                   span: Span,\n-                                  param_mode: PathParamMode,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n@@ -761,7 +741,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -772,7 +751,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_trait_ref(&self,\n                                        rscope: &RegionScope,\n                                        span: Span,\n-                                       param_mode: PathParamMode,\n                                        trait_def_id: DefId,\n                                        self_ty: Ty<'tcx>,\n                                        trait_segment: &hir::PathSegment)\n@@ -817,7 +795,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         self.create_substs_for_ast_path(rscope,\n                                         span,\n-                                        param_mode,\n                                         trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n@@ -929,7 +906,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_ty(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         did: DefId,\n         item_segment: &hir::PathSegment)\n         -> Ty<'tcx>\n@@ -944,7 +920,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let substs = self.ast_path_substs_for_ty(rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  did,\n                                                  item_segment);\n \n@@ -977,26 +952,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let tcx = self.tcx();\n         match ty.node {\n-            hir::TyPath(None, ref path) => {\n-                let resolution = tcx.expect_resolution(ty.id);\n-                match resolution.base_def {\n-                    Def::Trait(trait_def_id) if resolution.depth == 0 => {\n-                        self.trait_path_to_object_type(rscope,\n-                                                       path.span,\n-                                                       PathParamMode::Explicit,\n-                                                       trait_def_id,\n-                                                       ty.id,\n-                                                       path.segments.last().unwrap(),\n-                                                       span,\n-                                                       partition_bounds(tcx, span, bounds))\n-                    }\n-                    _ => {\n-                        struct_span_err!(tcx.sess, ty.span, E0172,\n-                                  \"expected a reference to a trait\")\n-                            .span_label(ty.span, &format!(\"expected a trait\"))\n-                            .emit();\n-                        tcx.types.err\n-                    }\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                if let Def::Trait(trait_def_id) = path.def {\n+                    self.trait_path_to_object_type(rscope,\n+                                                   path.span,\n+                                                   trait_def_id,\n+                                                   ty.id,\n+                                                   path.segments.last().unwrap(),\n+                                                   span,\n+                                                   partition_bounds(tcx, span, bounds))\n+                } else {\n+                    struct_span_err!(tcx.sess, ty.span, E0172,\n+                                     \"expected a reference to a trait\")\n+                        .span_label(ty.span, &format!(\"expected a trait\"))\n+                        .emit();\n+                    tcx.types.err\n                 }\n             }\n             _ => {\n@@ -1055,7 +1025,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn trait_path_to_object_type(&self,\n                                  rscope: &RegionScope,\n                                  path_span: Span,\n-                                 param_mode: PathParamMode,\n                                  trait_def_id: DefId,\n                                  trait_path_ref_id: ast::NodeId,\n                                  trait_segment: &hir::PathSegment,\n@@ -1068,7 +1037,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.ast_path_to_poly_trait_ref(rscope,\n                                                         path_span,\n-                                                        param_mode,\n                                                         trait_def_id,\n                                                         dummy_self,\n                                                         trait_path_ref_id,\n@@ -1289,12 +1257,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     // the whole path.\n     // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n     // parameter or Self.\n-    fn associated_path_def_to_ty(&self,\n-                                 span: Span,\n-                                 ty: Ty<'tcx>,\n-                                 ty_path_def: Def,\n-                                 item_segment: &hir::PathSegment)\n-                                 -> (Ty<'tcx>, Def)\n+    pub fn associated_path_def_to_ty(&self,\n+                                     ref_id: ast::NodeId,\n+                                     span: Span,\n+                                     ty: Ty<'tcx>,\n+                                     ty_path_def: Def,\n+                                     item_segment: &hir::PathSegment)\n+                                     -> (Ty<'tcx>, Def)\n     {\n         let tcx = self.tcx();\n         let assoc_name = item_segment.name;\n@@ -1371,13 +1340,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n         let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n-        (ty, Def::AssociatedTy(item.expect(\"missing associated type\").def_id))\n+        let def_id = item.expect(\"missing associated type\").def_id;\n+        tcx.check_stability(def_id, ref_id, span);\n+        (ty, Def::AssociatedTy(def_id))\n     }\n \n     fn qpath_to_ty(&self,\n                    rscope: &RegionScope,\n                    span: Span,\n-                   param_mode: PathParamMode,\n                    opt_self_ty: Option<Ty<'tcx>>,\n                    trait_def_id: DefId,\n                    trait_segment: &hir::PathSegment,\n@@ -1403,7 +1373,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n                                                         span,\n-                                                        param_mode,\n                                                         trait_def_id,\n                                                         self_ty,\n                                                         trait_segment);\n@@ -1442,60 +1411,54 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Check the base def in a PathResolution and convert it to a Ty. If there are\n-    // associated types in the PathResolution, these will need to be separately\n-    // resolved.\n-    fn base_def_to_ty(&self,\n-                      rscope: &RegionScope,\n-                      span: Span,\n-                      param_mode: PathParamMode,\n-                      def: Def,\n-                      opt_self_ty: Option<Ty<'tcx>>,\n-                      base_path_ref_id: ast::NodeId,\n-                      base_segments: &[hir::PathSegment],\n-                      permit_variants: bool)\n-                      -> Ty<'tcx> {\n+    // Check a type Path and convert it to a Ty.\n+    pub fn def_to_ty(&self,\n+                     rscope: &RegionScope,\n+                     opt_self_ty: Option<Ty<'tcx>>,\n+                     path: &hir::Path,\n+                     path_id: ast::NodeId,\n+                     permit_variants: bool)\n+                     -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, base_segments={:?})\",\n-               def, opt_self_ty, base_segments);\n+        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n+               path.def, opt_self_ty, path.segments);\n \n-        match def {\n+        let span = path.span;\n+        match path.def {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n \n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n \n                 self.trait_path_to_object_type(rscope,\n                                                span,\n-                                               param_mode,\n                                                trait_def_id,\n-                                               base_path_ref_id,\n-                                               base_segments.last().unwrap(),\n+                                               path_id,\n+                                               path.segments.last().unwrap(),\n                                                span,\n                                                partition_bounds(tcx, span, &[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope,\n-                                    span,\n-                                    param_mode,\n-                                    did,\n-                                    base_segments.last().unwrap())\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.ast_path_to_ty(rscope, span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(rscope,\n                                     span,\n-                                    param_mode,\n                                     tcx.parent_def_id(did).unwrap(),\n-                                    base_segments.last().unwrap())\n+                                    path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(&path.segments);\n \n                 let node_id = tcx.map.as_local_node_id(did).unwrap();\n                 let param = tcx.ty_param_defs.borrow().get(&node_id)\n@@ -1517,7 +1480,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n \n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(&path.segments);\n                 let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n@@ -1527,35 +1491,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n+                tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n-                                 param_mode,\n                                  opt_self_ty,\n                                  trait_did,\n-                                 &base_segments[base_segments.len()-2],\n-                                 base_segments.last().unwrap())\n-            }\n-            Def::Mod(..) => {\n-                // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n-                // FIXME(#22519) This part of the resolution logic should be\n-                // avoided entirely for that form, once we stop needed a Def\n-                // for `associated_path_def_to_ty`.\n-                // Fixing this will also let use resolve <Self>::Foo the same way we\n-                // resolve Self::Foo, at the moment we can't resolve the former because\n-                // we don't have the trait information around, which is just sad.\n-\n-                assert!(base_segments.is_empty());\n-\n-                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n+                                 &path.segments[path.segments.len()-2],\n+                                 path.segments.last().unwrap())\n             }\n             Def::PrimTy(prim_ty) => {\n-                tcx.prim_ty_to_ty(base_segments, prim_ty)\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prim_ty_to_ty(&path.segments, prim_ty)\n             }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -1564,60 +1516,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             _ => {\n                 struct_span_err!(tcx.sess, span, E0248,\n                            \"found value `{}` used as a type\",\n-                            tcx.item_path_str(def.def_id()))\n+                            tcx.item_path_str(path.def.def_id()))\n                            .span_label(span, &format!(\"value used as a type\"))\n                            .emit();\n                 return self.tcx().types.err;\n             }\n         }\n     }\n \n-    // Resolve possibly associated type path into a type and final definition.\n-    // Note that both base_segments and assoc_segments may be empty, although not at same time.\n-    pub fn finish_resolving_def_to_ty(&self,\n-                                      rscope: &RegionScope,\n-                                      span: Span,\n-                                      param_mode: PathParamMode,\n-                                      base_def: Def,\n-                                      opt_self_ty: Option<Ty<'tcx>>,\n-                                      base_path_ref_id: ast::NodeId,\n-                                      base_segments: &[hir::PathSegment],\n-                                      assoc_segments: &[hir::PathSegment],\n-                                      permit_variants: bool)\n-                                      -> (Ty<'tcx>, Def) {\n-        // Convert the base type.\n-        debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n-                base_segments={:?}, \\\n-                assoc_segments={:?})\",\n-               base_def,\n-               base_segments,\n-               assoc_segments);\n-        let base_ty = self.base_def_to_ty(rscope,\n-                                          span,\n-                                          param_mode,\n-                                          base_def,\n-                                          opt_self_ty,\n-                                          base_path_ref_id,\n-                                          base_segments,\n-                                          permit_variants);\n-        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n-\n-        // If any associated type segments remain, attempt to resolve them.\n-        let (mut ty, mut def) = (base_ty, base_def);\n-        for segment in assoc_segments {\n-            debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n-            // This is pretty bad (it will fail except for T::A and Self::A).\n-            let (new_ty, new_def) = self.associated_path_def_to_ty(span, ty, def, segment);\n-            ty = new_ty;\n-            def = new_def;\n-\n-            if def == Def::Err {\n-                break;\n-            }\n-        }\n-        (ty, def)\n-    }\n-\n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n@@ -1740,29 +1646,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 }\n             }\n-            hir::TyPath(ref maybe_qself, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n-                let path_res = tcx.expect_resolution(ast_ty.id);\n-                let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                    self.ast_ty_to_ty(rscope, &qself.ty)\n+                    self.ast_ty_to_ty(rscope, qself)\n                 });\n-                let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n-                                                                ast_ty.span,\n-                                                                PathParamMode::Explicit,\n-                                                                path_res.base_def,\n-                                                                opt_self_ty,\n-                                                                ast_ty.id,\n-                                                                &path.segments[..base_ty_end],\n-                                                                &path.segments[base_ty_end..],\n-                                                                false);\n-\n-                // Write back the new resolution.\n-                if path_res.depth != 0 {\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n-                }\n+                self.def_to_ty(rscope, opt_self_ty, path, ast_ty.id, false)\n+            }\n+            hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+                debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n+                let ty = self.ast_ty_to_ty(rscope, qself);\n \n-                ty\n+                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                    path.def\n+                } else {\n+                    Def::Err\n+                };\n+                self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, ref e) => {\n                 if let Ok(length) = eval_length(tcx.global_tcx(), &e, \"array length\") {\n@@ -2007,7 +1907,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.trait_path_to_object_type(rscope,\n                                        trait_ref.path.span,\n-                                       PathParamMode::Explicit,\n                                        trait_def_id,\n                                        trait_ref.ref_id,\n                                        trait_ref.path.segments.last().unwrap(),\n@@ -2099,7 +1998,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match tcx.expect_def(b.trait_ref.ref_id) {\n+                match b.trait_ref.path.def {\n                     Def::Trait(trait_did) => {\n                         if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "63e797a87ff2191fea50e7246cb2d83eea4cf9ab", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n                 common_type\n             }\n-            PatKind::Binding(bm, _, ref sub) => {\n+            PatKind::Binding(bm, def_id, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -130,16 +130,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                match tcx.expect_def(pat.id) {\n-                    Def::Err => {}\n-                    Def::Local(def_id) => {\n-                        let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                        if var_id != pat.id {\n-                            let vt = self.local_ty(pat.span, var_id);\n-                            self.demand_eqtype(pat.span, vt, typ);\n-                        }\n-                    }\n-                    d => bug!(\"bad def for pattern binding `{:?}`\", d)\n+                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                if var_id != pat.id {\n+                    let vt = self.local_ty(pat.span, var_id);\n+                    self.demand_eqtype(pat.span, vt, typ);\n                 }\n \n                 if let Some(ref p) = *sub {\n@@ -148,15 +142,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 typ\n             }\n-            PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected)\n+            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected)\n             }\n-            PatKind::Path(ref opt_qself, ref path) => {\n-                let opt_qself_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-                self.check_pat_path(pat, opt_qself_ty, path, expected)\n+            PatKind::Path(ref qpath) => {\n+                self.check_pat_path(pat, qpath, expected)\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.check_pat_struct(pat, path, fields, etc, expected)\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, etc, expected)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -374,7 +367,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // want to use the *precise* type of the discriminant, *not* some\n         // supertype, as the \"discriminant type\" (issue #23116).\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| tcx.arm_contains_ref_binding(a))\n+                                        .filter_map(|a| a.contains_ref_binding())\n                                         .max_by_key(|m| match *m {\n                                             hir::MutMutable => 1,\n                                             hir::MutImmutable => 0,\n@@ -496,13 +489,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_pat_struct(&self,\n                         pat: &'gcx hir::Pat,\n-                        path: &hir::Path,\n+                        qpath: &hir::QPath,\n                         fields: &'gcx [Spanned<hir::FieldPat>],\n                         etc: bool,\n                         expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {\n@@ -515,26 +508,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n-        self.check_struct_pat_fields(pat_ty, pat.span, variant, fields, etc);\n+        self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc);\n         pat_ty\n     }\n \n     fn check_pat_path(&self,\n                       pat: &hir::Pat,\n-                      opt_self_ty: Option<Ty<'tcx>>,\n-                      path: &hir::Path,\n+                      qpath: &hir::QPath,\n                       expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n         let report_unexpected_def = |def: Def| {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(), path);\n+                      def.kind_name(), qpath);\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n-                                                                   pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -558,7 +549,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_pat_tuple_struct(&self,\n                               pat: &hir::Pat,\n-                              path: &hir::Path,\n+                              qpath: &hir::QPath,\n                               subpats: &'gcx [P<hir::Pat>],\n                               ddpos: Option<usize>,\n                               expected: Ty<'tcx>) -> Ty<'tcx>\n@@ -571,14 +562,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              def.kind_name(), path);\n+                              def.kind_name(), qpath);\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n             on_error();\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(None, path, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -612,6 +603,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat(&subpat, field_ty);\n+\n+                self.tcx.check_stability(variant.fields[i].did, pat.id, subpat.span);\n             }\n         } else {\n             let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n@@ -631,6 +624,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_struct_pat_fields(&self,\n                                adt_ty: Ty<'tcx>,\n+                               pat_id: ast::NodeId,\n                                span: Span,\n                                variant: ty::VariantDef<'tcx>,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n@@ -668,7 +662,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n                     field_map.get(&field.name)\n-                        .map(|f| self.field_ty(span, f, substs))\n+                        .map(|f| {\n+                            self.tcx.check_stability(f.did, pat_id, span);\n+\n+                            self.field_ty(span, f, substs)\n+                        })\n                         .unwrap_or_else(|| {\n                             struct_span_err!(tcx.sess, span, E0026,\n                                              \"{} `{}` does not have a field named `{}`\","}, {"sha": "6d00f481fa263a4877471f8b7c6880b3eb20cdc8", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -218,12 +218,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                    let tcx = self.tcx;\n-                    if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                        if pr.depth == 0 && pr.base_def != Def::Err {\n-                            if let Some(span) = tcx.map.span_if_local(pr.base_def.def_id()) {\n-                                err.span_note(span, \"defined here\");\n-                            }\n+                    let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                        self.tables.borrow().qpath_def(qpath, expr.id)\n+                    } else {\n+                        Def::Err\n+                    };\n+                    if def != Def::Err {\n+                        if let Some(span) = self.tcx.map.span_if_local(def.def_id()) {\n+                            err.span_note(span, \"defined here\");\n                         }\n                     }\n                 }"}, {"sha": "f2dcc174d55bbdbae342a63bb2e027ba8ca2e259", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -136,6 +136,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n         }\n \n+        self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n+\n         Ok(self.confirm_method(span,\n                                self_expr,\n                                call_expr,\n@@ -340,6 +342,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let def = pick.item.def();\n+\n+        self.tcx.check_stability(def.def_id(), expr_id, span);\n+\n         if let probe::InherentImplPick = pick.kind {\n             if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);"}, {"sha": "6598790355e8243f977f27bce3ba60631f3ced87", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -28,7 +28,6 @@ use syntax_pos::Span;\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n-use rustc::hir::Expr_;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -210,7 +209,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(expr) = rcvr_expr {\n                         if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n+                        } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.name);\n                             }"}, {"sha": "2babb81bc407a47b5b6295e5db99a1bdb79b9f21", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -80,12 +80,11 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, ast_region_to_region, PathParamMode};\n+use astconv::{AstConv, ast_region_to_region};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use hir::def::{Def, CtorKind, PathResolution};\n+use hir::def::{Def, CtorKind};\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n                    TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -342,7 +341,7 @@ impl UnsafetyState {\n                         (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n                     hir::UnsafeBlock(..) =>\n                         (hir::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n-                    hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock =>\n+                    hir::DefaultBlock =>\n                         (unsafety, self.def, self.unsafe_push_count),\n                 };\n                 UnsafetyState{ def: def,\n@@ -711,7 +710,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Binding(_, ref path1, _) = p.node {\n+        if let PatKind::Binding(_, _, ref path1, _) = p.node {\n             let var_ty = self.assign(p.span, p.id, None);\n \n             self.fcx.require_type_is_sized(var_ty, p.span,\n@@ -796,7 +795,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n \n             // Create type variables for each argument.\n-            pat_util::pat_bindings(&input.pat, |_bm, pat_id, sp, _path| {\n+            input.pat.each_binding(|_bm, pat_id, sp, _path| {\n                 let var_ty = visit.assign(sp, pat_id, None);\n                 fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n             });\n@@ -2999,6 +2998,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n                             self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n+\n+                            self.tcx.check_stability(field.did, expr.id, expr.span);\n+\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3101,6 +3103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         private_candidate = Some((base_def.did, field_ty));\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                            self.tcx.check_stability(field.did, expr.id, expr.span);\n                             Some(field_ty)\n                         } else {\n                             None\n@@ -3193,13 +3196,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n+                                expr_id: ast::NodeId,\n                                 span: Span,\n                                 variant: ty::VariantDef<'tcx>,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let (substs, kind_name) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt.variant_descr()),\n+        let (substs, adt_kind, kind_name) = match adt_ty.sty {\n+            ty::TyAdt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3220,6 +3224,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 expected_field_type = self.field_ty(field.span, v_field, substs);\n \n                 seen_fields.insert(field.name.node, field.span);\n+\n+                // we don't look at stability attributes on\n+                // struct-like enums (yet...), but it's definitely not\n+                // a bug to have construct one.\n+                if adt_kind != ty::AdtKind::Enum {\n+                    tcx.check_stability(v_field.did, expr_id, field.span);\n+                }\n             } else {\n                 error_happened = true;\n                 expected_field_type = tcx.types.err;\n@@ -3301,10 +3312,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_struct_path(&self,\n-                             path: &hir::Path,\n+                             qpath: &hir::QPath,\n                              node_id: ast::NodeId)\n                              -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n-        let (def, ty) = self.finish_resolving_struct_path(path, node_id);\n+        let path_span = match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.span,\n+            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+        };\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -3324,7 +3339,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Def::AssociatedTy(..) | Def::SelfTy(..)\n                             if !self.tcx.sess.features.borrow().more_struct_aliases => {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"more_struct_aliases\", path.span, GateIssue::Language,\n+                                         \"more_struct_aliases\", path_span, GateIssue::Language,\n                                          \"`Self` and associated types in struct \\\n                                           expressions and patterns are unstable\");\n                     }\n@@ -3342,37 +3357,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             // Check bounds on type arguments used in the path.\n-            let bounds = self.instantiate_bounds(path.span, did, substs);\n-            let cause = traits::ObligationCause::new(path.span, self.body_id,\n+            let bounds = self.instantiate_bounds(path_span, did, substs);\n+            let cause = traits::ObligationCause::new(path_span, self.body_id,\n                                                      traits::ItemObligation(did));\n             self.add_obligations_for_parameters(cause, &bounds);\n \n             Some((variant, ty))\n         } else {\n-            struct_span_err!(self.tcx.sess, path.span, E0071,\n+            struct_span_err!(self.tcx.sess, path_span, E0071,\n                              \"expected struct, variant or union type, found {}\",\n                              ty.sort_string(self.tcx))\n-                .span_label(path.span, &format!(\"not a struct\"))\n+                .span_label(path_span, &format!(\"not a struct\"))\n                 .emit();\n             None\n         }\n     }\n \n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n-                         path: &hir::Path,\n+                         qpath: &hir::QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id) {\n+        let (variant, struct_ty) =\n+        if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n             return self.tcx.types.err;\n         };\n \n-        self.check_expr_struct_fields(struct_ty, path.span, variant, fields,\n+        let path_span = match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.span,\n+            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+        };\n+\n+        self.check_expr_struct_fields(struct_ty, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n@@ -3590,9 +3611,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_ref(region, tm)\n             }\n           }\n-          hir::ExprPath(ref opt_qself, ref path) => {\n-              let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+          hir::ExprPath(ref qpath) => {\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath,\n                                                                          expr.id, expr.span);\n               let ty = if def != Def::Err {\n                   self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n@@ -3618,72 +3638,58 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               tcx.mk_nil()\n           }\n-          hir::ExprBreak(ref label_opt, ref expr_opt) => {\n-            let loop_id = if label_opt.is_some() {\n-                let loop_def = tcx.expect_def(expr.id);\n-                if let Def::Label(loop_id) = loop_def {\n-                    Some(Some(loop_id))\n-                } else if loop_def == Def::Err {\n-                    // an error was already printed, so just ignore it\n-                    None\n+          hir::ExprBreak(label, ref expr_opt) => {\n+            let loop_id = label.map(|l| l.loop_id);\n+            let coerce_to = {\n+                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+            };\n+            if let Some(coerce_to) = coerce_to {\n+                let e_ty;\n+                let cause;\n+                if let Some(ref e) = *expr_opt {\n+                    // Recurse without `enclosing_loops` borrowed.\n+                    e_ty = self.check_expr_with_hint(e, coerce_to);\n+                    cause = self.misc(e.span);\n+                    // Notably, the recursive call may alter coerce_to - must not keep using it!\n                 } else {\n-                    span_bug!(expr.span, \"break label resolved to a non-label\");\n+                    // `break` without argument acts like `break ()`.\n+                    e_ty = tcx.mk_nil();\n+                    cause = self.misc(expr.span);\n                 }\n-            } else {\n-                Some(None)\n-            };\n-            if let Some(loop_id) = loop_id {\n-                let coerce_to = {\n-                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                    enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n-                };\n-                if let Some(coerce_to) = coerce_to {\n-                    let e_ty;\n-                    let cause;\n-                    if let Some(ref e) = *expr_opt {\n-                        // Recurse without `enclosing_loops` borrowed.\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                        // Notably, the recursive call may alter coerce_to - must not keep using it!\n-                    } else {\n-                        // `break` without argument acts like `break ()`.\n-                        e_ty = tcx.mk_nil();\n-                        cause = self.misc(expr.span);\n-                    }\n-                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                    let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n \n-                    let result = if let Some(ref e) = *expr_opt {\n-                        // Special-case the first element, as it has no \"previous expressions\".\n-                        let result = if !ctxt.may_break {\n-                            self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                        } else {\n-                            self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                                       ctxt.unified, e, e_ty)\n-                        };\n-\n-                        ctxt.break_exprs.push(e);\n-                        result\n+                let result = if let Some(ref e) = *expr_opt {\n+                    // Special-case the first element, as it has no \"previous expressions\".\n+                    let result = if !ctxt.may_break {\n+                        self.try_coerce(e, e_ty, ctxt.coerce_to)\n                     } else {\n-                        self.eq_types(true, &cause, e_ty, ctxt.unified)\n-                            .map(|InferOk { obligations, .. }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                e_ty\n-                            })\n+                        self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n+                                                   ctxt.unified, e, e_ty)\n                     };\n-                    match result {\n-                        Ok(ty) => ctxt.unified = ty,\n-                        Err(err) => {\n-                            self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n-                        }\n-                    }\n \n-                    ctxt.may_break = true;\n+                    ctxt.break_exprs.push(e);\n+                    result\n+                } else {\n+                    self.eq_types(true, &cause, e_ty, ctxt.unified)\n+                        .map(|InferOk { obligations, .. }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            e_ty\n+                        })\n+                };\n+                match result {\n+                    Ok(ty) => ctxt.unified = ty,\n+                    Err(err) => {\n+                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                    }\n                 }\n-                // Otherwise, we failed to find the enclosing loop; this can only happen if the\n-                // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+\n+                ctxt.may_break = true;\n             }\n+            // Otherwise, we failed to find the enclosing loop; this can only happen if the\n+            // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n             tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n@@ -3930,8 +3936,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tuple\n             }\n           }\n-          hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, path, fields, base_expr)\n+          hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+            self.check_expr_struct(expr, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, lvalue_pref, &base, field)\n@@ -3997,83 +4003,81 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n-    // The newly resolved definition is written into `def_map`.\n+    // The newly resolved definition is written into `type_relative_path_defs`.\n     fn finish_resolving_struct_path(&self,\n-                                    path: &hir::Path,\n+                                    qpath: &hir::QPath,\n+                                    path_span: Span,\n                                     node_id: ast::NodeId)\n                                     -> (Def, Ty<'tcx>)\n     {\n-        let path_res = self.tcx.expect_resolution(node_id);\n-        let base_ty_end = path.segments.len() - path_res.depth;\n-        let (ty, def) = AstConv::finish_resolving_def_to_ty(self, self, path.span,\n-                                                            PathParamMode::Optional,\n-                                                            path_res.base_def,\n-                                                            None,\n-                                                            node_id,\n-                                                            &path.segments[..base_ty_end],\n-                                                            &path.segments[base_ty_end..],\n-                                                            true);\n-        // Write back the new resolution.\n-        if path_res.depth != 0 {\n-            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+        match *qpath {\n+            hir::QPath::Resolved(ref maybe_qself, ref path) => {\n+                let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let ty = AstConv::def_to_ty(self, self, opt_self_ty, path, node_id, true);\n+                (path.def, ty)\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+                let ty = self.to_ty(qself);\n+\n+                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                    path.def\n+                } else {\n+                    Def::Err\n+                };\n+                let (ty, def) = AstConv::associated_path_def_to_ty(self, node_id, path_span,\n+                                                                   ty, def, segment);\n+\n+                // Write back the new resolution.\n+                self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+\n+                (def, ty)\n+            }\n         }\n-        (def, ty)\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n-    // The newly resolved definition is written into `def_map`.\n+    // The newly resolved definition is written into `type_relative_path_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       opt_self_ty: Option<Ty<'tcx>>,\n-                                       path: &'b hir::Path,\n+                                       qpath: &'b hir::QPath,\n                                        node_id: ast::NodeId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let path_res = self.tcx.expect_resolution(node_id);\n-        if path_res.depth == 0 {\n-            // If fully resolved already, we don't have to do anything.\n-            (path_res.base_def, opt_self_ty, &path.segments)\n-        } else {\n-            // Try to resolve everything except for the last segment as a type.\n-            let ty_segments = path.segments.split_last().unwrap().1;\n-            let base_ty_end = path.segments.len() - path_res.depth;\n-            let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                                 PathParamMode::Optional,\n-                                                                 path_res.base_def,\n-                                                                 opt_self_ty,\n-                                                                 node_id,\n-                                                                 &ty_segments[..base_ty_end],\n-                                                                 &ty_segments[base_ty_end..],\n-                                                                 false);\n-\n-            // Resolve an associated constant or method on the previously resolved type.\n-            let item_segment = path.segments.last().unwrap();\n-            let item_name = item_segment.name;\n-            let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n-                Ok(def) => def,\n-                Err(error) => {\n-                    let def = match error {\n-                        method::MethodError::PrivateMatch(def) => def,\n-                        _ => Def::Err,\n-                    };\n-                    if item_name != keywords::Invalid.name() {\n-                        self.report_method_error(span, ty, item_name, None, error);\n-                    }\n-                    def\n+        let (ty, item_segment) = match *qpath {\n+            hir::QPath::Resolved(ref opt_qself, ref path) => {\n+                return (path.def,\n+                        opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n+                        &path.segments[..]);\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+                (self.to_ty(qself), segment)\n+            }\n+        };\n+        let item_name = item_segment.name;\n+        let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n+            Ok(def) => def,\n+            Err(error) => {\n+                let def = match error {\n+                    method::MethodError::PrivateMatch(def) => def,\n+                    _ => Def::Err,\n+                };\n+                if item_name != keywords::Invalid.name() {\n+                    self.report_method_error(span, ty, item_name, None, error);\n                 }\n-            };\n+                def\n+            }\n+        };\n \n-            // Write back the new resolution.\n-            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n-            (def, Some(ty), slice::ref_slice(item_segment))\n-        }\n+        // Write back the new resolution.\n+        self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+        (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n     pub fn check_decl_initializer(&self,\n                                   local: &'gcx hir::Local,\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n+        let ref_bindings = local.pat.contains_ref_binding();\n \n         let local_ty = self.local_ty(init.span, local.id);\n         if let Some(m) = ref_bindings {\n@@ -4379,11 +4383,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => bug!(\"unexpected definition: {:?}\", def),\n         }\n \n-        // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n-        // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n-        // type parameters are not mandatory.\n-        let require_type_space = opt_self_ty.is_some() && ufcs_associated.is_none();\n-\n         debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n \n         // Now that we have categorized what space the parameters for each\n@@ -4414,8 +4413,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n-        self.check_path_parameter_count(span, true, &mut fn_segment);\n+        self.check_path_parameter_count(span, &mut type_segment);\n+        self.check_path_parameter_count(span, &mut fn_segment);\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n@@ -4450,7 +4449,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }, |def, substs| {\n             let mut i = def.index as usize;\n \n-            let can_omit = i >= fn_start || !require_type_space;\n             let segment = if i < fn_start {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n@@ -4464,22 +4462,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let types = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n+            let (types, infer_types) = match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => {\n+                    (&data.types[..], data.infer_types)\n+                }\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => &[]\n+                None => (&[][..], true)\n             };\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n                 i -= generics.regions.len();\n             }\n \n-            let omitted = can_omit && types.is_empty();\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n                 self.to_ty(ast_ty)\n-            } else if let (false, Some(default)) = (omitted, def.default) {\n+            } else if let (false, Some(default)) = (infer_types, def.default) {\n                 // No type parameter provided, but a default exists.\n                 default.subst_spanned(self.tcx, substs, Some(span))\n             } else {\n@@ -4539,16 +4538,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Report errors if the provided parameters are too few or too many.\n     fn check_path_parameter_count(&self,\n                                   span: Span,\n-                                  can_omit: bool,\n                                   segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n-        let (lifetimes, types, bindings) = match segment.map(|(s, _)| &s.parameters) {\n-            Some(&hir::AngleBracketedParameters(ref data)) => {\n-                (&data.lifetimes[..], &data.types[..], &data.bindings[..])\n-            }\n-            Some(&hir::ParenthesizedParameters(_)) => {\n-                span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n+        let (lifetimes, types, infer_types, bindings) = {\n+            match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => {\n+                    (&data.lifetimes[..], &data.types[..], data.infer_types, &data.bindings[..])\n+                }\n+                Some(&hir::ParenthesizedParameters(_)) => {\n+                    span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n+                }\n+                None => (&[][..], &[][..], true, &[][..])\n             }\n-            None => (&[][..], &[][..], &[][..])\n         };\n \n         let count = |n| {\n@@ -4597,7 +4597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if !(can_omit && types.len() == 0) && types.len() < required_len {\n+        } else if !infer_types && types.len() < required_len {\n             let adjust = |len| if len > 1 { \"parameters\" } else { \"parameter\" };\n             let required_param_str = adjust(required_len);\n             let actual_param_str = adjust(types.len());"}, {"sha": "ca33682480c4c61c1667243b0b56d16bbf58f8bb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -92,7 +92,6 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n-use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n \n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat_util::pat_bindings(pat, |_, id, span, _| {\n+        pat.each_binding(|_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n             // data will be accessible from anywhere that the variable is\n             // accessed. We must be wary of loops like this:\n@@ -603,7 +602,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n                expr, self.repeating_scope);\n         match expr.node {\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 self.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n                     let origin = infer::ParameterOrigin::Path;\n                     self.substs_wf_in_scope(origin, &item_substs.substs, expr.span, expr_region);"}, {"sha": "45b3dae3e9f83cb224204a12625024c3ff9a605e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -43,6 +43,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_deferred_obligations(item_id);\n+        wbcx.visit_type_nodes();\n     }\n \n     pub fn resolve_type_vars_in_fn(&self,\n@@ -67,6 +68,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n+        wbcx.visit_type_nodes();\n     }\n }\n \n@@ -356,6 +358,11 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n+        // Export associated path extensions.\n+        if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&id) {\n+            self.tcx().tables.borrow_mut().type_relative_path_defs.insert(id, def);\n+        }\n+\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n \n@@ -478,6 +485,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_type_nodes(&self) {\n+        for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n+            let ty = self.resolve(ty, ResolvingTyNode(id));\n+            self.fcx.ccx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n+        }\n+    }\n+\n     fn resolve<T>(&self, x: &T, reason: ResolveReason) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n@@ -505,6 +519,7 @@ enum ResolveReason {\n     ResolvingFieldTypes(ast::NodeId),\n     ResolvingAnonTy(DefId),\n     ResolvingDeferredObligation(Span),\n+    ResolvingTyNode(ast::NodeId),\n }\n \n impl<'a, 'gcx, 'tcx> ResolveReason {\n@@ -516,10 +531,9 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n-            ResolvingFnSig(id) => {\n-                tcx.map.span(id)\n-            }\n-            ResolvingFieldTypes(id) => {\n+            ResolvingFnSig(id) |\n+            ResolvingFieldTypes(id) |\n+            ResolvingTyNode(id) => {\n                 tcx.map.span(id)\n             }\n             ResolvingClosure(did) |\n@@ -601,7 +615,8 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n                 ResolvingFnSig(_) |\n                 ResolvingFieldTypes(_) |\n-                ResolvingDeferredObligation(_) => {\n+                ResolvingDeferredObligation(_) |\n+                ResolvingTyNode(_) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or\n                     // something else."}, {"sha": "0034a85f8e29e0b156da2ddf5d281f872b691189", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -45,17 +45,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n         if item.vis == hir::Public || item.span == DUMMY_SP {\n             return;\n         }\n-        if let hir::ItemUse(ref path) = item.node {\n-            match path.node {\n-                hir::ViewPathSimple(..) | hir::ViewPathGlob(..) => {\n-                    self.check_import(item.id, path.span);\n-                }\n-                hir::ViewPathList(_, ref path_list) => {\n-                    for path_item in path_list {\n-                        self.check_import(path_item.node.id, path_item.span);\n-                    }\n-                }\n-            }\n+        if let hir::ItemUse(ref path, _) = item.node {\n+            self.check_import(item.id, path.span);\n         }\n     }\n "}, {"sha": "0dcc0bcc316ce96cab2a98079156907d07ffa046", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -136,7 +136,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n-            convert_closure(self.ccx, expr.id);\n+            let def_id = self.ccx.tcx.map.local_def_id(expr.id);\n+            generics_of_def_id(self.ccx, def_id);\n+            type_of_def_id(self.ccx, def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -542,11 +544,10 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_id: ast::NodeId)\n                       -> bool\n {\n-    if let hir::TyPath(None, _) = ast_ty.node {\n-        let path_res = tcx.expect_resolution(ast_ty.id);\n-        match path_res.base_def {\n+    if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+        match path.def {\n             Def::SelfTy(Some(def_id), None) |\n-            Def::TyParam(def_id) if path_res.depth == 0 => {\n+            Def::TyParam(def_id) => {\n                 def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => false\n@@ -571,40 +572,6 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n-fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                             node_id: ast::NodeId)\n-{\n-    let tcx = ccx.tcx;\n-    let def_id = tcx.map.local_def_id(node_id);\n-    let base_def_id = tcx.closure_base_def_id(def_id);\n-    let base_generics = generics_of_def_id(ccx, base_def_id);\n-\n-    // provide junk type parameter defs - the only place that\n-    // cares about anything but the length is instantiation,\n-    // and we don't do that for closures.\n-    let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n-        fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-            index: (base_generics.count() as u32) + (i as u32),\n-            name: Symbol::intern(\"<upvar>\"),\n-            def_id: def_id,\n-            default_def_id: base_def_id,\n-            default: None,\n-            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-            pure_wrt_drop: false,\n-        }).collect()\n-    });\n-    tcx.generics.borrow_mut().insert(def_id, tcx.alloc_generics(ty::Generics {\n-        parent: Some(base_def_id),\n-        parent_regions: base_generics.parent_regions + (base_generics.regions.len() as u32),\n-        parent_types: base_generics.parent_types + (base_generics.types.len() as u32),\n-        regions: vec![],\n-        types: upvar_decls,\n-        has_self: base_generics.has_self,\n-    }));\n-\n-    type_of_def_id(ccx, def_id);\n-}\n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: AssociatedItemContainer,\n                             id: ast::NodeId,\n@@ -696,7 +663,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n     match it.node {\n         // These don't define types.\n-        hir::ItemExternCrate(_) | hir::ItemUse(_) | hir::ItemMod(_) => {\n+        hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n         }\n         hir::ItemForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n@@ -1321,6 +1288,9 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let parent_id = tcx.map.get_parent(node_id);\n                 Some(tcx.map.local_def_id(parent_id))\n             }\n+            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+                Some(tcx.closure_base_def_id(def_id))\n+            }\n             NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n                 let mut parent_id = node_id;\n                 loop {\n@@ -1438,7 +1408,24 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let i = type_start + i as u32;\n             get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n         });\n-        let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+        let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+        // provide junk type parameter defs - the only place that\n+        // cares about anything but the length is instantiation,\n+        // and we don't do that for closures.\n+        if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n+            tcx.with_freevars(node_id, |fv| {\n+                types.extend(fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n+                    index: type_start + i as u32,\n+                    name: Symbol::intern(\"<upvar>\"),\n+                    def_id: def_id,\n+                    default_def_id: parent_def_id.unwrap(),\n+                    default: None,\n+                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                    pure_wrt_drop: false,\n+               }));\n+            });\n+        }\n \n         // Debugging aid.\n         if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n@@ -1625,8 +1612,7 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             if let Ok(kind_id) = kind_id {\n-                let trait_def = tcx.expect_def(tpb.ref_id);\n-                if trait_def != Def::Trait(kind_id) {\n+                if tpb.path.def != Def::Trait(kind_id) {\n                     tcx.sess.span_warn(span,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\"}, {"sha": "049add6f0620cd40b070b5b9a65e526df181901e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -111,7 +111,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n-use session::{config, CompileResult};\n+use session::config;\n use util::common::time;\n \n use syntax::ast;\n@@ -314,7 +314,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> CompileResult {\n+                             -> Result<NodeMap<Ty<'tcx>>, usize> {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n@@ -358,7 +358,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     let err_count = tcx.sess.err_count();\n     if err_count == 0 {\n-        Ok(())\n+        Ok(ccx.ast_ty_to_ty_cache.into_inner())\n     } else {\n         Err(err_count)\n     }"}, {"sha": "686d1a4a7716d823e38a204e5346d68c7b85d2aa", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) |\n+            hir::ItemUse(..) |\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) |\n             hir::ItemFn(..) |"}, {"sha": "851cfcd87231f8a8790a1c6fafa1ec75ba1c8d48", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             }\n \n             hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) |\n+            hir::ItemUse(..) |\n             hir::ItemDefaultImpl(..) |\n             hir::ItemImpl(..) |\n             hir::ItemStatic(..) |"}, {"sha": "e3274611e5bff3ee30ba50c61b825865e20e7dfa", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -29,24 +29,21 @@ use clean::{self, GetDefId};\n \n use super::Clean;\n \n-/// Attempt to inline the definition of a local node id into this AST.\n+/// Attempt to inline a definition into this AST.\n ///\n-/// This function will fetch the definition of the id specified, and if it is\n-/// from another crate it will attempt to inline the documentation from the\n-/// other crate into this crate.\n+/// This function will fetch the definition specified, and if it is\n+/// from another crate it will attempt to inline the documentation\n+/// from the other crate into this crate.\n ///\n /// This is primarily used for `pub use` statements which are, in general,\n /// implementation details. Inlining the documentation should help provide a\n /// better experience when reading the documentation in this use case.\n ///\n-/// The returned value is `None` if the `id` could not be inlined, and `Some`\n-/// of a vector of items if it was successfully expanded.\n-pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n+/// The returned value is `None` if the definition could not be inlined,\n+/// and `Some` of a vector of items if it was successfully expanded.\n+pub fn try_inline(cx: &DocContext, def: Def, into: Option<ast::Name>)\n                   -> Option<Vec<clean::Item>> {\n-    let def = match cx.tcx.expect_def_or_none(id) {\n-        Some(def) => def,\n-        None => return None,\n-    };\n+    if def == Def::Err { return None }\n     let did = def.def_id();\n     if did.is_local() { return None }\n     try_inline_def(cx, def).map(|vec| {"}, {"sha": "e233613ee629e8844652371a4fd86ec96ec82f99", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 68, "deletions": 87, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -667,6 +667,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n                  bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n     Path {\n         global: false,\n+        def: Def::Err,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n             params: external_path_params(cx, trait_did, has_self, bindings, substs)\n@@ -1727,14 +1728,13 @@ impl Clean<Type> for hir::Ty {\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(None, ref path) => {\n-                let def = cx.tcx.expect_def(self.id);\n-                if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+            TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n                     return new_ty;\n                 }\n \n                 let mut alias = None;\n-                if let Def::TyAlias(def_id) = def {\n+                if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n                     if let Some(node_id) = cx.tcx.map.as_local_node_id(def_id) {\n                         if !cx.access_levels.borrow().is_exported(def_id) {\n@@ -1748,7 +1748,7 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = cx.tcx.expect_def(ty_param.id);\n+                        let ty_param_def = Def::TyParam(cx.tcx.map.local_def_id(ty_param.id));\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n                                                                         .cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n@@ -1766,17 +1766,37 @@ impl Clean<Type> for hir::Ty {\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }\n-            TyPath(Some(ref qself), ref p) => {\n+            TyPath(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();\n                 segments.pop();\n                 let trait_path = hir::Path {\n                     span: p.span,\n                     global: p.global,\n+                    def: Def::Trait(cx.tcx.associated_item(p.def.def_id()).container.id()),\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n                     name: p.segments.last().unwrap().name.clean(cx),\n-                    self_type: box qself.ty.clean(cx),\n+                    self_type: box qself.clean(cx),\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n+                }\n+            }\n+            TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+                let mut def = Def::Err;\n+                if let Some(ty) = cx.hir_ty_to_ty.get(&self.id) {\n+                    if let ty::TyProjection(proj) = ty.sty {\n+                        def = Def::Trait(proj.trait_ref.def_id);\n+                    }\n+                }\n+                let trait_path = hir::Path {\n+                    span: self.span,\n+                    global: false,\n+                    def: def,\n+                    segments: vec![].into(),\n+                };\n+                Type::QPath {\n+                    name: segment.name.clean(cx),\n+                    self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n@@ -2182,13 +2202,15 @@ impl Clean<Span> for syntax_pos::Span {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Path {\n     pub global: bool,\n+    pub def: Def,\n     pub segments: Vec<PathSegment>,\n }\n \n impl Path {\n     pub fn singleton(name: String) -> Path {\n         Path {\n             global: false,\n+            def: Def::Err,\n             segments: vec![PathSegment {\n                 name: name,\n                 params: PathParameters::AngleBracketed {\n@@ -2209,6 +2231,7 @@ impl Clean<Path> for hir::Path {\n     fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n             global: self.global,\n+            def: self.def,\n             segments: self.segments.clean(cx),\n         }\n     }\n@@ -2263,11 +2286,20 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n-fn path_to_string(p: &hir::Path) -> String {\n+fn qpath_to_string(p: &hir::QPath) -> String {\n+    let (segments, global) = match *p {\n+        hir::QPath::Resolved(_, ref path) => {\n+            (&path.segments, path.global)\n+        }\n+        hir::QPath::TypeRelative(_, ref segment) => {\n+            return segment.name.to_string()\n+        }\n+    };\n+\n     let mut s = String::new();\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| x.name.as_str()) {\n-        if !first || p.global {\n+    for i in segments.iter().map(|x| x.name.as_str()) {\n+        if !first || global {\n             s.push_str(\"::\");\n         } else {\n             first = false;\n@@ -2568,47 +2600,19 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 None => false,\n             }\n         });\n-        let (mut ret, inner) = match self.node {\n-            hir::ViewPathGlob(ref p) => {\n-                (vec![], Import::Glob(resolve_use_source(cx, p.clean(cx), self.id)))\n-            }\n-            hir::ViewPathList(ref p, ref list) => {\n-                // Attempt to inline all reexported items, but be sure\n-                // to keep any non-inlineable reexports so they can be\n-                // listed in the documentation.\n-                let mut ret = vec![];\n-                let remaining = if !denied {\n-                    let mut remaining = vec![];\n-                    for path in list {\n-                        match inline::try_inline(cx, path.node.id, path.node.rename) {\n-                            Some(items) => {\n-                                ret.extend(items);\n-                            }\n-                            None => {\n-                                remaining.push(path.clean(cx));\n-                            }\n-                        }\n-                    }\n-                    remaining\n-                } else {\n-                    list.clean(cx)\n-                };\n-                if remaining.is_empty() {\n-                    return ret;\n-                }\n-                (ret, Import::List(resolve_use_source(cx, p.clean(cx), self.id), remaining))\n-            }\n-            hir::ViewPathSimple(name, ref p) => {\n-                if !denied {\n-                    if let Some(items) = inline::try_inline(cx, self.id, Some(name)) {\n-                        return items;\n-                    }\n+        let path = self.path.clean(cx);\n+        let inner = if self.glob {\n+            Import::Glob(resolve_use_source(cx, path))\n+        } else {\n+            let name = self.name;\n+            if !denied {\n+                if let Some(items) = inline::try_inline(cx, path.def, Some(name)) {\n+                    return items;\n                 }\n-                (vec![], Import::Simple(name.clean(cx),\n-                                        resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n+            Import::Simple(name.clean(cx), resolve_use_source(cx, path))\n         };\n-        ret.push(Item {\n+        vec![Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2617,8 +2621,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             stability: None,\n             deprecation: None,\n             inner: ImportItem(inner)\n-        });\n-        ret\n+        }]\n     }\n }\n \n@@ -2627,9 +2630,7 @@ pub enum Import {\n     // use source as str;\n     Simple(String, ImportSource),\n     // use source::*;\n-    Glob(ImportSource),\n-    // use source::{a, b, c};\n-    List(ImportSource, Vec<ViewListIdent>),\n+    Glob(ImportSource)\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2638,23 +2639,6 @@ pub struct ImportSource {\n     pub did: Option<DefId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct ViewListIdent {\n-    pub name: String,\n-    pub rename: Option<String>,\n-    pub source: Option<DefId>,\n-}\n-\n-impl Clean<ViewListIdent> for hir::PathListItem {\n-    fn clean(&self, cx: &DocContext) -> ViewListIdent {\n-        ViewListIdent {\n-            name: self.node.name.clean(cx),\n-            rename: self.node.rename.map(|r| r.clean(cx)),\n-            source: resolve_def(cx, self.node.id)\n-        }\n-    }\n-}\n-\n impl Clean<Vec<Item>> for hir::ForeignMod {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n@@ -2724,18 +2708,16 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, ..) | PatKind::Path(None, ref p) => path_to_string(p),\n-        PatKind::Path(..) => panic!(\"tried to get argument name from qualified PatKind::Path, \\\n-                                     which is not allowed in function arguments\"),\n+        PatKind::Binding(_, _, ref p, _) => p.node.to_string(),\n+        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n-            format!(\"{} {{ {}{} }}\", path_to_string(name),\n+            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n                                   format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n-        },\n+        }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),\n@@ -2756,15 +2738,13 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-/// Given a Type, resolve it using the def_map\n+/// Given a type Path, resolve it to a Type using the TyCtxt\n fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n-    let def = cx.tcx.expect_def(id);\n-    debug!(\"resolve_type: def={:?}\", def);\n \n-    let is_generic = match def {\n+    let is_generic = match path.def {\n         Def::PrimTy(p) => match p {\n             hir::TyStr => return Primitive(PrimitiveType::Str),\n             hir::TyBool => return Primitive(PrimitiveType::Bool),\n@@ -2779,7 +2759,7 @@ fn resolve_type(cx: &DocContext,\n         Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n         _ => false,\n     };\n-    let did = register_def(&*cx, def);\n+    let did = register_def(&*cx, path.def);\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n@@ -2811,17 +2791,17 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     did\n }\n \n-fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext, path: Path) -> ImportSource {\n     ImportSource {\n+        did: if path.def == Def::Err {\n+            None\n+        } else {\n+            Some(register_def(cx, path.def))\n+        },\n         path: path,\n-        did: resolve_def(cx, id),\n     }\n }\n \n-fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n-    cx.tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Macro {\n     pub source: String,\n@@ -2925,6 +2905,7 @@ fn lang_struct(cx: &DocContext, did: Option<DefId>,\n         did: did,\n         path: Path {\n             global: false,\n+            def: Def::Err,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n                 params: PathParameters::AngleBracketed {"}, {"sha": "4c2487e2b42a0b855f565caf4c87562955dcc250", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -15,10 +15,10 @@ use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::{Def, ExportMap};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, NodeMap};\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -65,6 +65,9 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n     pub export_map: ExportMap,\n+\n+    /// Table from HIR Ty nodes to their resolved Ty.\n+    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n impl<'a, 'tcx> DocContext<'a, 'tcx> {\n@@ -172,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let ty::CrateAnalysis { access_levels, export_map, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, export_map, hir_ty_to_ty, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n@@ -192,6 +195,7 @@ pub fn run_core(search_paths: SearchPaths,\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             export_map: export_map,\n+            hir_ty_to_ty: hir_ty_to_ty,\n         };\n         debug!(\"crate: {:?}\", tcx.map.krate());\n "}, {"sha": "21fc135eaadae7c0822de78e97d2130bce50702e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -254,10 +254,12 @@ pub struct ExternCrate {\n }\n \n pub struct Import {\n+    pub name: Name,\n     pub id: NodeId,\n     pub vis: hir::Visibility,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub node: hir::ViewPath_,\n+    pub path: hir::Path,\n+    pub glob: bool,\n     pub whence: Span,\n }\n "}, {"sha": "aed41916f5c536594c73d9f557e681e36bf832af", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -969,16 +969,6 @@ impl fmt::Display for clean::Import {\n             clean::Import::Glob(ref src) => {\n                 write!(f, \"use {}::*;\", *src)\n             }\n-            clean::Import::List(ref src, ref names) => {\n-                write!(f, \"use {}::{{\", *src)?;\n-                for (i, n) in names.iter().enumerate() {\n-                    if i > 0 {\n-                        write!(f, \", \")?;\n-                    }\n-                    write!(f, \"{}\", *n)?;\n-                }\n-                write!(f, \"}};\")\n-            }\n         }\n     }\n }\n@@ -1000,23 +990,6 @@ impl fmt::Display for clean::ImportSource {\n     }\n }\n \n-impl fmt::Display for clean::ViewListIdent {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.source {\n-            Some(did) => {\n-                let path = clean::Path::singleton(self.name.clone());\n-                resolved_path(f, did, &path, false)?;\n-            }\n-            _ => write!(f, \"{}\", self.name)?,\n-        }\n-\n-        if let Some(ref name) = self.rename {\n-            write!(f, \" as {}\", name)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if f.alternate() {"}, {"sha": "4087b9a761f97dfc44f066eb3de568b1ae276e4e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 28, "deletions": 49, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -225,42 +225,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    fn visit_view_path(&mut self, path: hir::ViewPath_,\n-                       om: &mut Module,\n-                       id: ast::NodeId,\n-                       please_inline: bool) -> Option<hir::ViewPath_> {\n-        match path {\n-            hir::ViewPathSimple(dst, base) => {\n-                if self.maybe_inline_local(id, Some(dst), false, om, please_inline) {\n-                    None\n-                } else {\n-                    Some(hir::ViewPathSimple(dst, base))\n-                }\n-            }\n-            hir::ViewPathList(p, paths) => {\n-                let mine = paths.into_iter().filter(|path| {\n-                    !self.maybe_inline_local(path.node.id, path.node.rename,\n-                                             false, om, please_inline)\n-                }).collect::<hir::HirVec<hir::PathListItem>>();\n-\n-                if mine.is_empty() {\n-                    None\n-                } else {\n-                    Some(hir::ViewPathList(p, mine))\n-                }\n-            }\n-\n-            hir::ViewPathGlob(base) => {\n-                if self.maybe_inline_local(id, None, true, om, please_inline) {\n-                    None\n-                } else {\n-                    Some(hir::ViewPathGlob(base))\n-                }\n-            }\n-        }\n-\n-    }\n-\n     /// Tries to resolve the target of a `pub use` statement and inlines the\n     /// target if it is defined locally and would not be documented otherwise,\n     /// or when it is specifically requested with `please_inline`.\n@@ -270,8 +234,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// and follows different rules.\n     ///\n     /// Returns true if the target has been inlined.\n-    fn maybe_inline_local(&mut self, id: ast::NodeId, renamed: Option<ast::Name>,\n-                  glob: bool, om: &mut Module, please_inline: bool) -> bool {\n+    fn maybe_inline_local(&mut self,\n+                          id: ast::NodeId,\n+                          def: Def,\n+                          renamed: Option<ast::Name>,\n+                          glob: bool,\n+                          om: &mut Module,\n+                          please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.tcx.map.get_enclosing_scope(node) {\n@@ -287,7 +256,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let tcx = self.cx.tcx;\n-        let def = tcx.expect_def(id);\n+        if def == Def::Err {\n+            return false;\n+        }\n         let def_did = def.def_id();\n \n         let use_attrs = tcx.map.attrs(id);\n@@ -388,11 +359,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                 })\n             }\n-            hir::ItemUse(ref vpath) => {\n-                let node = vpath.node.clone();\n+            hir::ItemUse(_, hir::UseKind::ListStem) => {}\n+            hir::ItemUse(ref path, kind) => {\n+                let is_glob = kind == hir::UseKind::Glob;\n+\n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n-                let node = if item.vis == hir::Public && self.inside_public_path {\n+                if item.vis == hir::Public && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(list) if item.check_name(\"doc\") => {\n@@ -401,18 +374,24 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             _ => false,\n                         }\n                     });\n-                    match self.visit_view_path(node, om, item.id, please_inline) {\n-                        None => return,\n-                        Some(p) => p\n+                    let name = if is_glob { None } else { Some(name) };\n+                    if self.maybe_inline_local(item.id,\n+                                               path.def,\n+                                               name,\n+                                               is_glob,\n+                                               om,\n+                                               please_inline) {\n+                        return;\n                     }\n-                } else {\n-                    node\n-                };\n+                }\n+\n                 om.imports.push(Import {\n+                    name: name,\n                     id: item.id,\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n-                    node: node,\n+                    path: (**path).clone(),\n+                    glob: is_glob,\n                     whence: item.span,\n                 });\n             }"}, {"sha": "12ce642891173725bd76951abbc40590cecbfb9f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -51,6 +51,8 @@ pub enum ExpnFormat {\n     MacroAttribute(Name),\n     /// e.g. `format!()`\n     MacroBang(Name),\n+    /// Desugaring done by the compiler during HIR lowering.\n+    CompilerDesugaring(Name)\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -105,8 +107,9 @@ pub struct NameAndSpan {\n impl NameAndSpan {\n     pub fn name(&self) -> Name {\n         match self.format {\n-            ExpnFormat::MacroAttribute(s) => s,\n-            ExpnFormat::MacroBang(s) => s,\n+            ExpnFormat::MacroAttribute(s) |\n+            ExpnFormat::MacroBang(s) |\n+            ExpnFormat::CompilerDesugaring(s) => s,\n         }\n     }\n }\n@@ -813,6 +816,7 @@ impl CodeMap {\n                     let (pre, post) = match ei.callee.format {\n                         MacroAttribute(..) => (\"#[\", \"]\"),\n                         MacroBang(..) => (\"\", \"!\"),\n+                        CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n                     };\n                     let macro_decl_name = format!(\"{}{}{}\",\n                                                   pre,"}, {"sha": "fca89e265e4edcfa710694532e46cc8f3d162c48", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -307,7 +307,7 @@ fn generate_test_harness(sess: &ParseSess,\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     let info = ExpnInfo {\n-        call_site: DUMMY_SP,\n+        call_site: sp,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n@@ -460,6 +460,7 @@ mod __test {\n \n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = Ident::from_str(\"test\");\n+    let sp = ignored_span(cx, DUMMY_SP);\n     let (vi, vis, ident) = if cx.is_test_crate {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n@@ -474,7 +475,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         node: vi,\n         attrs: vec![],\n         vis: vis,\n-        span: DUMMY_SP\n+        span: sp\n     })\n }\n \n@@ -598,7 +599,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     // FIXME #15962: should be using quote_item, but that stringifies\n     // __test_reexports, causing it to be reinterned, losing the\n     // gensym information.\n-    let sp = DUMMY_SP;\n+    let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),"}, {"sha": "7de6e58c784d57ad7083ae25409c538ad740e8d4", "filename": "src/test/compile-fail-fulldeps/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -16,7 +16,7 @@\n //  which is a reduction of this code to more directly show the reason\n //  for the error message we see here.)\n \n-#![feature(const_fn)]\n+#![feature(const_fn, rustc_private)]\n \n extern crate arena;\n "}, {"sha": "30829847a3a229ce1e16858a71e78311b68e498c", "filename": "src/test/compile-fail-fulldeps/dropck_tarena_unsound_drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_unsound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_unsound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_unsound_drop.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -19,6 +19,8 @@\n // (Also compare against dropck_tarena_cycle_checked.rs, from which\n // this was reduced to better understand its error message.)\n \n+#![feature(rustc_private)]\n+\n extern crate arena;\n \n use arena::TypedArena;"}, {"sha": "bb7478d9a5f6ebe2d93d4fb7c49654d47f48a447", "filename": "src/test/compile-fail-fulldeps/proc-macro/at-the-root.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fat-the-root.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fat-the-root.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fat-the-root.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "abf11637631f46b4278e331ee4a2102174319b33", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "bdb3c09c4d723c9ef64b73feb431135599bd2de7", "filename": "src/test/compile-fail-fulldeps/proc-macro/define-two.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fdefine-two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fdefine-two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fdefine-two.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -11,7 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "4751679ddb8cfe53adca9457ecd77ff5cce4f3a3", "filename": "src/test/compile-fail-fulldeps/proc-macro/error-on-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ferror-on-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ferror-on-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ferror-on-test.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: --test\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "70c8db5ddd2ecb0c36c7ca2d0eebe469b03741a2", "filename": "src/test/compile-fail-fulldeps/proc-macro/illegal-proc-macro-derive-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fillegal-proc-macro-derive-use.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "1bcd4b15eb86350b20993a49934c1967e26b582f", "filename": "src/test/compile-fail-fulldeps/proc-macro/shadow-builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow-builtin.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n \n extern crate proc_macro;\n "}, {"sha": "d9b19d1d85a7a47c62ff6e21612577ba6dc65e28", "filename": "src/test/compile-fail-fulldeps/proc-macro/signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fsignature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fsignature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fsignature.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro, proc_macro_lib)]\n #![allow(warnings)]\n \n extern crate proc_macro;"}, {"sha": "fe7ee1c129f81d6493dc007fb73141478603a2e1", "filename": "src/test/compile-fail/E0254.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0254.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(collections)]\n+\n extern crate collections;\n //~^ NOTE previous import of `collections` here\n "}, {"sha": "95be48b5ff1b35ec80d820060d3c8c22c726a179", "filename": "src/test/compile-fail/E0259.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0259.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(collections, libc)]\n+\n extern crate collections;\n //~^ NOTE previous import of `collections` here\n "}, {"sha": "ae018d2ada93c1e723210681b8cca70be061dd1e", "filename": "src/test/compile-fail/E0260.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0260.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(collections)]\n+\n extern crate collections;\n //~^ NOTE previous import of `collections` here\n "}, {"sha": "efef8305e53547734b7fd1255dd9c809bcaeff79", "filename": "src/test/compile-fail/E0445.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2FE0445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0445.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -13,13 +13,13 @@ trait Foo {\n }\n \n pub trait Bar : Foo {}\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n pub struct Bar2<T: Foo>(pub T);\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n pub fn foo<T: Foo> (t: T) {}\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n \n fn main() {}"}, {"sha": "e4eca7e7eceb4b1e6b23ffb5e0a5f45e52e3b324", "filename": "src/test/compile-fail/borrowck/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(box_syntax)]\n \n-extern crate collections;\n use std::collections::HashMap;\n \n fn main() {"}, {"sha": "ba1ae64ec330af6cda67d77fec86f81891ee1524", "filename": "src/test/compile-fail/borrowck/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-call-is-borrow-issue-12224.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n // Ensure that invoking a closure counts as a unique immutable borrow\n \n type Fn<'a> = Box<FnMut() + 'a>;"}, {"sha": "8499ebb8ac370d0aabf6c9fe0e5be19c002cb5be", "filename": "src/test/compile-fail/borrowck/borrowck-insert-during-each.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-insert-during-each.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate collections;\n use std::collections::HashSet;\n \n struct Foo {"}, {"sha": "4c20688331b6dd8e26374053ff5c4a69605ef45e", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-call.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n \n use std::ops::{Fn, FnMut, FnOnce};\n "}, {"sha": "0b73f5bebb23ced7f9fb4e3287a81ed2a08dade8", "filename": "src/test/compile-fail/derives-span-Clone-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Clone-enum-struct-variant.rs"}, {"sha": "6944ea38b37267e091c14227226245552ad3fcd1", "filename": "src/test/compile-fail/derives-span-Clone-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Clone-enum.rs"}, {"sha": "92bf148ccbd942e738838bd0fc73433ba8edc7c8", "filename": "src/test/compile-fail/derives-span-Clone-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Clone-struct.rs"}, {"sha": "21adfc90301b86fea62f61c931e566223095b0a6", "filename": "src/test/compile-fail/derives-span-Clone-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Clone-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Clone-tuple-struct.rs"}, {"sha": "da777e8a14b451039f5dbe2881b081fac0f90605", "filename": "src/test/compile-fail/derives-span-Debug-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Show-enum-struct-variant.rs"}, {"sha": "bf5d3f2d81b29fb1de7cf877413e8cd9b8594040", "filename": "src/test/compile-fail/derives-span-Debug-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Show-enum.rs"}, {"sha": "b0b275fa2d347d1326fa6e959f2dea69fa7a8550", "filename": "src/test/compile-fail/derives-span-Debug-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Show-struct.rs"}, {"sha": "9689054a7be6db2d6c4ca868a19bef6fe3374573", "filename": "src/test/compile-fail/derives-span-Debug-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Debug-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Show-tuple-struct.rs"}, {"sha": "68b99ed25b855eec33ea1ff494955472cf0eabb3", "filename": "src/test/compile-fail/derives-span-Default-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Default-struct.rs"}, {"sha": "822abe975a1ccc223a7b2c571eb3d22e975f1c4a", "filename": "src/test/compile-fail/derives-span-Default-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Default-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Default-tuple-struct.rs"}, {"sha": "fdc74d5fef6b167e1b9926b1df50122a43fb836b", "filename": "src/test/compile-fail/derives-span-Eq-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalEq-enum-struct-variant.rs"}, {"sha": "4bf30fdf93f7711c2905e87220c2449db41d09c1", "filename": "src/test/compile-fail/derives-span-Eq-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalEq-enum.rs"}, {"sha": "685188f13378649fda75bd3614f6545237bc5e5a", "filename": "src/test/compile-fail/derives-span-Eq-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalEq-struct.rs"}, {"sha": "0e636d027dd3797248fe10a6dfea04bc7afe5a83", "filename": "src/test/compile-fail/derives-span-Eq-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Eq-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalEq-tuple-struct.rs"}, {"sha": "bfb6566223cb31582a596daad76bdd2f4f0461ba", "filename": "src/test/compile-fail/derives-span-Hash-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Hash-enum-struct-variant.rs"}, {"sha": "99f28b376dfe9712171541ef521940b41fc934cf", "filename": "src/test/compile-fail/derives-span-Hash-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Hash-enum.rs"}, {"sha": "acfd5aa7b2a7466453617951ef2690b7e4b36766", "filename": "src/test/compile-fail/derives-span-Hash-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Hash-struct.rs"}, {"sha": "3d76b29834f09bfd19f0cefc0e5e4344044c0b25", "filename": "src/test/compile-fail/derives-span-Hash-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Hash-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-Hash-tuple-struct.rs"}, {"sha": "06ee588e69f49e9c06570e6ffb6b43512d4b22ea", "filename": "src/test/compile-fail/derives-span-Ord-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(Eq,PartialOrd,PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalOrd-enum-struct-variant.rs"}, {"sha": "af9cfbc911097af9cfa5757ba8e72538ea2449a2", "filename": "src/test/compile-fail/derives-span-Ord-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(Eq,PartialOrd,PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalOrd-enum.rs"}, {"sha": "4477d933a6c7ae4316cfa6a9f09d05c304c70e3b", "filename": "src/test/compile-fail/derives-span-Ord-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(Eq,PartialOrd,PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalOrd-struct.rs"}, {"sha": "ebc7518641289cbb8afc3cbe6dc1fffb6d0a387e", "filename": "src/test/compile-fail/derives-span-Ord-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-Ord-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(Eq,PartialOrd,PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-TotalOrd-tuple-struct.rs"}, {"sha": "7c98dcc2a6f1d90f4fba76efabc2b6ddac0d7d55", "filename": "src/test/compile-fail/derives-span-PartialEq-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialEq-enum-struct-variant.rs"}, {"sha": "fe6355e456cca1a028b559b95467b18b5bad2b63", "filename": "src/test/compile-fail/derives-span-PartialEq-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialEq-enum.rs"}, {"sha": "10d9d64277683c69477c976f9f1660657c550454", "filename": "src/test/compile-fail/derives-span-PartialEq-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialEq-struct.rs"}, {"sha": "c92eb0f63c4dafe5ffd0d6f7d3fc4ad4ebcbd8ef", "filename": "src/test/compile-fail/derives-span-PartialEq-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialEq-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n \n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialEq-tuple-struct.rs"}, {"sha": "898104d0ab29cb7c5818b76679784eef2110762d", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum-struct-variant.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialOrd-enum-struct-variant.rs"}, {"sha": "c0585999473b5e5dd5b80699be2482d80bd97d60", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialOrd-enum.rs"}, {"sha": "af05434af9de3d0eb0b72eb2374573ba967a1ddd", "filename": "src/test/compile-fail/derives-span-PartialOrd-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialOrd-struct.rs"}, {"sha": "1afb7bc2b4c4765bf71fab2ea03997d443f16f23", "filename": "src/test/compile-fail/derives-span-PartialOrd-tuple-struct.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n #[derive(PartialEq)]\n struct Error;\n ", "previous_filename": "src/test/compile-fail/deriving-span-PartialOrd-tuple-struct.rs"}, {"sha": "521f122f8af0b57eec342d14cadd72fee2904610", "filename": "src/test/compile-fail/forget-init-unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core_intrinsics)]\n+\n use std::intrinsics::{init, forget};\n \n // Test that the `forget` and `init` intrinsics are really unsafe"}, {"sha": "1dd6763cbe50a580d8de917c4753ce15832dd2eb", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n \n use std::{fmt, ops};\n "}, {"sha": "45bc5ee07a527f9ed2e6d59bd98f43e4fd71c531", "filename": "src/test/compile-fail/issue-17545.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17545.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n pub fn foo<'a, F: Fn(&'a ())>(bar: F) {\n     bar.call((\n         &(), //~ ERROR borrowed value does not live long enough"}, {"sha": "aad3d52153a2d471b25dc5b5c54f1ddf0284773f", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -14,7 +14,8 @@ use std::any::TypeId;\n trait Private<P, R> {\n     fn call(&self, p: P, r: R);\n }\n-pub trait Public: Private< //~ ERROR private trait in public interface\n+pub trait Public: Private<\n+//~^ ERROR private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n     <Self as Public>::P,\n     <Self as Public>::R\n > {"}, {"sha": "da98f21e46138901aa3bdc83d983a235193ca459", "filename": "src/test/compile-fail/issue-20225.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n \n struct Foo;\n "}, {"sha": "dfa9520f38bb78c957c7de6fe93aa05ff87ca4a0", "filename": "src/test/compile-fail/issue-22034.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(libc)]\n+\n extern crate libc;\n \n fn main() {"}, {"sha": "805725dd749f521d9350280fef7f941b626423d1", "filename": "src/test/compile-fail/issue-2392.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(core, fnbox)]\n+\n use std::boxed::FnBox;\n \n struct FuncContainer {"}, {"sha": "3e3d898e3683da7b7811e0913cb0ac7e36b32b7d", "filename": "src/test/compile-fail/issue-28075.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -17,7 +17,6 @@\n extern crate lint_stability;\n \n use lint_stability::{unstable, deprecated}; //~ ERROR use of unstable library feature 'test_feature'\n-//~^ WARNING use of deprecated item\n \n use lint_stability::unstable::{self as u}; //~ ERROR use of unstable library feature 'test_feature'\n "}, {"sha": "3488310b128834dbbd866cbb4fa43e06addcf8a3", "filename": "src/test/compile-fail/issue-28514.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -21,7 +21,7 @@ mod inner {\n         fn b(&self) { }\n     }\n \n-    pub trait C: A + B { //~ ERROR private trait in public interface\n+    pub trait C: A + B { //~ ERROR private trait `inner::A` in public interface\n                          //~^ WARN will become a hard error\n         fn c(&self) { }\n     }"}, {"sha": "48aabce708eab277d3bcfb944a5fbe15734272f0", "filename": "src/test/compile-fail/issue-28992-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -23,5 +23,5 @@ impl S {\n fn main() {\n     if let C1(..) = 0 {} //~ ERROR expected tuple struct/variant, found constant `C1`\n     if let S::C2(..) = 0 {}\n-    //~^ ERROR expected tuple struct/variant, found associated constant `S::C2`\n+    //~^ ERROR expected tuple struct/variant, found associated constant `<S>::C2`\n }"}, {"sha": "15b7edb32d41ddebac3326b6491bbfd4d1222608", "filename": "src/test/compile-fail/issue-30079.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -16,7 +16,7 @@ struct SemiPriv;\n mod m1 {\n     struct Priv;\n     impl ::SemiPriv {\n-        pub fn f(_: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(_: Priv) {} //~ ERROR private type `m1::Priv` in public interface\n         //~^ WARNING hard error\n     }\n \n@@ -28,7 +28,7 @@ mod m1 {\n mod m2 {\n     struct Priv;\n     impl ::std::ops::Deref for ::SemiPriv {\n-        type Target = Priv; //~ ERROR private type in public interface\n+        type Target = Priv; //~ ERROR private type `m2::Priv` in public interface\n         //~^ WARNING hard error\n         fn deref(&self) -> &Self::Target { unimplemented!() }\n     }\n@@ -46,7 +46,7 @@ trait SemiPrivTrait {\n mod m3 {\n     struct Priv;\n     impl ::SemiPrivTrait for () {\n-        type Assoc = Priv; //~ ERROR private type in public interface\n+        type Assoc = Priv; //~ ERROR private type `m3::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }"}, {"sha": "e2acdcee3de8f7447c00c613617b8969617f6137", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -16,7 +16,7 @@ fn main() {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n         //~^^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~| unresolved path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "d75ac0c7f2ef32d5e3f62f94f63406344ef953e6", "filename": "src/test/compile-fail/issue-36881.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rand)]\n+\n fn main() {\n     extern crate rand;\n     use rand::Rng; //~ ERROR unresolved import"}, {"sha": "51f5fc5ee98e1f38a3e14c46908b23d66af9f48f", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {"}, {"sha": "2f74325d19c7d587389ac654de1a3db14dece71b", "filename": "src/test/compile-fail/lint-output-format-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -F unused_features\n+// aux-build:lint_output_format.rs\n+\n+#![feature(foo)] //~ ERROR unused or unknown feature\n+\n+#![feature(test_feature)]\n+\n+extern crate lint_output_format;\n+use lint_output_format::{foo, bar};\n+//~^ WARNING use of deprecated item: text,\n+\n+fn main() {\n+    let _x = foo(); //~ WARNING #[warn(deprecated)] on by default\n+    let _y = bar();\n+}"}, {"sha": "81e0b708b8739d764d298fe2e314859f22a3e96a", "filename": "src/test/compile-fail/lint-output-format.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -11,13 +11,12 @@\n // compile-flags: -F unused_features\n // aux-build:lint_output_format.rs\n \n-#![feature(foo)] //~ ERROR unused or unknown feature\n+#![allow(deprecated)]\n \n extern crate lint_output_format; //~ ERROR use of unstable library feature\n use lint_output_format::{foo, bar}; //~ ERROR use of unstable library feature\n-//~^ WARNING use of deprecated item: text,\n \n fn main() {\n-    let _x = foo(); //~ WARNING #[warn(deprecated)] on by default\n+    let _x = foo();\n     let _y = bar(); //~ ERROR use of unstable library feature\n }"}, {"sha": "77917ff3cd3e5c9c456d77898690106d0e1a6497", "filename": "src/test/compile-fail/lint-stability-2.rs", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-2.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,423 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// aux-build:stability_cfg1.rs\n+\n+#![allow(deprecated)]\n+#![allow(dead_code)]\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+mod cross_crate {\n+    extern crate stability_cfg1;\n+\n+    use lint_stability::*;\n+\n+    fn test() {\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated();\n+        foo.method_deprecated();\n+        Foo::method_deprecated(&foo);\n+        <Foo>::method_deprecated(&foo);\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+\n+        deprecated_text();\n+        foo.method_deprecated_text();\n+        Foo::method_deprecated_text(&foo);\n+        <Foo>::method_deprecated_text(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+\n+        foo.method_deprecated_unstable();\n+        //~^ ERROR use of unstable library feature\n+        Foo::method_deprecated_unstable(&foo);\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::method_deprecated_unstable(&foo);\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_deprecated_unstable();\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::trait_deprecated_unstable(&foo);\n+        //~^ ERROR use of unstable library feature\n+\n+        foo.method_deprecated_unstable_text();\n+        //~^ ERROR use of unstable library feature\n+        Foo::method_deprecated_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::method_deprecated_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_deprecated_unstable_text();\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::trait_deprecated_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature\n+\n+        foo.method_unstable(); //~ ERROR use of unstable library feature\n+        Foo::method_unstable(&foo); //~ ERROR use of unstable library feature\n+        <Foo>::method_unstable(&foo); //~ ERROR use of unstable library feature\n+        foo.trait_unstable(); //~ ERROR use of unstable library feature\n+        <Foo>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n+\n+        foo.method_unstable_text();\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        Foo::method_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        <Foo>::method_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        foo.trait_unstable_text();\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        <Foo>::trait_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+\n+        stable();\n+        foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n+        foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n+\n+        struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n+\n+        let _ = DeprecatedStruct {\n+            i: 0\n+        };\n+        let _ = StableStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct;\n+        let _ = StableUnitStruct;\n+\n+        let _ = Enum::DeprecatedVariant;\n+        let _ = Enum::StableVariant;\n+\n+        let _ = DeprecatedTupleStruct (1);\n+        let _ = StableTupleStruct (1);\n+\n+        // At the moment, the lint checker only checks stability in\n+        // in the arguments of macros.\n+        // Eventually, we will want to lint the contents of the\n+        // macro in the module *defining* it. Also, stability levels\n+        // on macros themselves are not yet linted.\n+        macro_test_arg!(deprecated_text());\n+        macro_test_arg!(macro_test_arg!(deprecated_text()));\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+        foo.trait_deprecated_unstable();\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::trait_deprecated_unstable(&foo);\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_deprecated_unstable_text();\n+        //~^ ERROR use of unstable library feature\n+        <Foo>::trait_deprecated_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_unstable(); //~ ERROR use of unstable library feature\n+        <Foo>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n+        foo.trait_unstable_text();\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        <Foo>::trait_unstable_text(&foo);\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated();\n+        foo.trait_deprecated_text();\n+        foo.trait_deprecated_unstable();\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_deprecated_unstable_text();\n+        //~^ ERROR use of unstable library feature\n+        foo.trait_unstable(); //~ ERROR use of unstable library feature\n+        foo.trait_unstable_text();\n+        //~^ ERROR use of unstable library feature 'test_feature': text\n+        foo.trait_stable();\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S {}\n+    trait LocalTrait2 : DeprecatedTrait { }\n+}\n+\n+mod this_crate {\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub fn deprecated() {}\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub fn deprecated_text() {}\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub fn unstable() {}\n+    #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+    pub fn unstable_text() {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn stable() {}\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn stable_text() {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct MethodTester;\n+\n+    impl MethodTester {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        pub fn method_deprecated(&self) {}\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        pub fn method_deprecated_text(&self) {}\n+\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        pub fn method_unstable(&self) {}\n+        #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+        pub fn method_unstable_text(&self) {}\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn method_stable(&self) {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn method_stable_text(&self) {}\n+    }\n+\n+    pub trait Trait {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn trait_deprecated(&self) {}\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn trait_deprecated_text(&self) {}\n+\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        fn trait_unstable(&self) {}\n+        #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+        fn trait_unstable_text(&self) {}\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn trait_stable(&self) {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn trait_stable_text(&self) {}\n+    }\n+\n+    impl Trait for MethodTester {}\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedUnitStruct;\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableUnitStruct;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableUnitStruct;\n+\n+    pub enum Enum {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        DeprecatedVariant,\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        UnstableVariant,\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        StableVariant,\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedTupleStruct(isize);\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableTupleStruct(isize);\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableTupleStruct(isize);\n+\n+    fn test() {\n+        // Only the deprecated cases of the following should generate\n+        // errors, because other stability attributes now have meaning\n+        // only *across* crates, not within a single crate.\n+\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated();\n+        foo.method_deprecated();\n+        Foo::method_deprecated(&foo);\n+        <Foo>::method_deprecated(&foo);\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+\n+        deprecated_text();\n+        foo.method_deprecated_text();\n+        Foo::method_deprecated_text(&foo);\n+        <Foo>::method_deprecated_text(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+\n+        unstable();\n+        foo.method_unstable();\n+        Foo::method_unstable(&foo);\n+        <Foo>::method_unstable(&foo);\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+\n+        unstable_text();\n+        foo.method_unstable_text();\n+        Foo::method_unstable_text(&foo);\n+        <Foo>::method_unstable_text(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+\n+        stable();\n+        foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n+        foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n+\n+        let _ = DeprecatedStruct {\n+            i: 0\n+        };\n+        let _ = UnstableStruct { i: 0 };\n+        let _ = StableStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct;\n+        let _ = UnstableUnitStruct;\n+        let _ = StableUnitStruct;\n+\n+        let _ = Enum::DeprecatedVariant;\n+        let _ = Enum::UnstableVariant;\n+        let _ = Enum::StableVariant;\n+\n+        let _ = DeprecatedTupleStruct (1);\n+        let _ = UnstableTupleStruct (1);\n+        let _ = StableTupleStruct (1);\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated();\n+        foo.trait_deprecated_text();\n+        foo.trait_unstable();\n+        foo.trait_unstable_text();\n+        foo.trait_stable();\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    fn test_fn_body() {\n+        fn fn_in_body() {}\n+        fn_in_body();\n+    }\n+\n+    impl MethodTester {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn test_method_body(&self) {\n+            fn fn_in_body() {}\n+            fn_in_body();\n+        }\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub trait DeprecatedTrait {\n+        fn dummy(&self) { }\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S { }\n+\n+    trait LocalTrait : DeprecatedTrait { }\n+}\n+\n+fn main() {}"}, {"sha": "d8813b6a6101a377179e2fe1da648099f5085166", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,467 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// aux-build:inherited_stability.rs\n+// aux-build:stability_cfg1.rs\n+// aux-build:stability_cfg2.rs\n+\n+#![deny(deprecated)]\n+#![allow(dead_code)]\n+#![feature(staged_api, test_feature)]\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+mod cross_crate {\n+    extern crate stability_cfg1;\n+    extern crate stability_cfg2;\n+\n+    use lint_stability::*;\n+\n+    fn test() {\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        deprecated_unstable(); //~ ERROR use of deprecated item\n+        foo.method_deprecated_unstable(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        unstable();\n+        foo.method_unstable();\n+        Foo::method_unstable(&foo);\n+        <Foo>::method_unstable(&foo);\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+\n+        unstable_text();\n+        foo.method_unstable_text();\n+        Foo::method_unstable_text(&foo);\n+        <Foo>::method_unstable_text(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+\n+        stable();\n+        foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n+        foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n+\n+        struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n+        struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+        let _ = DeprecatedUnstableStruct {\n+            //~^ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+        let _ = UnstableStruct { i: 0 };\n+        let _ = StableStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnstableUnitStruct; //~ ERROR use of deprecated item\n+        let _ = UnstableUnitStruct;\n+        let _ = StableUnitStruct;\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedUnstableVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::UnstableVariant;\n+        let _ = Enum::StableVariant;\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnstableTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = UnstableTupleStruct (1);\n+        let _ = StableTupleStruct (1);\n+\n+        // At the moment, the lint checker only checks stability in\n+        // in the arguments of macros.\n+        // Eventually, we will want to lint the contents of the\n+        // macro in the module *defining* it. Also, stability levels\n+        // on macros themselves are not yet linted.\n+        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_unstable();\n+        foo.trait_unstable_text();\n+        foo.trait_stable();\n+    }\n+\n+    struct S;\n+\n+    impl UnstableTrait for S { }\n+    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n+    trait LocalTrait : UnstableTrait { }\n+    trait LocalTrait2 : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n+\n+    impl Trait for S {\n+        fn trait_stable(&self) {}\n+        fn trait_unstable(&self) {}\n+    }\n+}\n+\n+mod inheritance {\n+    extern crate inherited_stability;\n+    use self::inherited_stability::*;\n+\n+    fn test_inheritance() {\n+        unstable();\n+        stable();\n+\n+        stable_mod::unstable();\n+        stable_mod::stable();\n+\n+        unstable_mod::deprecated(); //~ ERROR use of deprecated item\n+        unstable_mod::unstable();\n+\n+        let _ = Unstable::UnstableVariant;\n+        let _ = Unstable::StableVariant;\n+\n+        let x: usize = 0;\n+        x.unstable();\n+        x.stable();\n+    }\n+}\n+\n+mod this_crate {\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub fn deprecated() {}\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub fn deprecated_text() {}\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub fn unstable() {}\n+    #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+    pub fn unstable_text() {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn stable() {}\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn stable_text() {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct MethodTester;\n+\n+    impl MethodTester {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        pub fn method_deprecated(&self) {}\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        pub fn method_deprecated_text(&self) {}\n+\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        pub fn method_unstable(&self) {}\n+        #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+        pub fn method_unstable_text(&self) {}\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn method_stable(&self) {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn method_stable_text(&self) {}\n+    }\n+\n+    pub trait Trait {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn trait_deprecated(&self) {}\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn trait_deprecated_text(&self) {}\n+\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        fn trait_unstable(&self) {}\n+        #[unstable(feature = \"test_feature\", reason = \"text\", issue = \"0\")]\n+        fn trait_unstable_text(&self) {}\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn trait_stable(&self) {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        fn trait_stable_text(&self) {}\n+    }\n+\n+    impl Trait for MethodTester {}\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedUnitStruct;\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableUnitStruct;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableUnitStruct;\n+\n+    pub enum Enum {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        DeprecatedVariant,\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        UnstableVariant,\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        StableVariant,\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub struct DeprecatedTupleStruct(isize);\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    pub struct UnstableTupleStruct(isize);\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub struct StableTupleStruct(isize);\n+\n+    fn test() {\n+        // Only the deprecated cases of the following should generate\n+        // errors, because other stability attributes now have meaning\n+        // only *across* crates, not within a single crate.\n+\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        unstable();\n+        foo.method_unstable();\n+        Foo::method_unstable(&foo);\n+        <Foo>::method_unstable(&foo);\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+\n+        unstable_text();\n+        foo.method_unstable_text();\n+        Foo::method_unstable_text(&foo);\n+        <Foo>::method_unstable_text(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+\n+        stable();\n+        foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+\n+        stable_text();\n+        foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n+        foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n+\n+        let _ = DeprecatedStruct {\n+            //~^ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+        let _ = UnstableStruct { i: 0 };\n+        let _ = StableStruct { i: 0 };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = UnstableUnitStruct;\n+        let _ = StableUnitStruct;\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::UnstableVariant;\n+        let _ = Enum::StableVariant;\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = UnstableTupleStruct (1);\n+        let _ = StableTupleStruct (1);\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n+        foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+        foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_unstable();\n+        foo.trait_unstable_text();\n+        foo.trait_stable();\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    fn test_fn_body() {\n+        fn fn_in_body() {}\n+        fn_in_body(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    impl MethodTester {\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        fn test_method_body(&self) {\n+            fn fn_in_body() {}\n+            fn_in_body(); //~ ERROR use of deprecated item: text\n+        }\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    pub trait DeprecatedTrait {\n+        fn dummy(&self) { }\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+}\n+\n+fn main() {}"}, {"sha": "5da3e1a930d7dd6e98fc7119fc506399f422fd72", "filename": "src/test/compile-fail/lint-stability-fields-deprecated.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-fields-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-fields-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields-deprecated.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,348 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability_fields.rs\n+#![deny(deprecated)]\n+#![allow(dead_code)]\n+#![feature(staged_api, test_feature)]\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+mod cross_crate {\n+    extern crate lint_stability_fields;\n+\n+    use self::lint_stability_fields::*;\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+\n+        let x = Unstable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Unstable\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+\n+        let x = Unstable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable2\n+            (_,\n+             _,\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Unstable2\n+            // the patterns are all fine:\n+            (..) = x;\n+\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+            override1: 2,\n+            //~^ ERROR use of deprecated item\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.override1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+            override1: _,\n+            //~^ ERROR use of deprecated item\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+             //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+mod this_crate {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Stable {\n+        inherit: u8,\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        override1: u8,\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        override2: u8,\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Stable2(u8,\n+                   #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                   #[unstable(feature = \"test_feature\", issue = \"0\")]\n+                   #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")] u8);\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    struct Unstable {\n+        inherit: u8,\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        override1: u8,\n+        #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        override2: u8,\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    struct Unstable2(u8,\n+                     #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                     #[unstable(feature = \"test_feature\", issue = \"0\")]\n+                     #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")] u8);\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    struct Deprecated {\n+        inherit: u8,\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        override1: u8,\n+        #[unstable(feature = \"test_feature\", issue = \"0\")]\n+        override2: u8,\n+    }\n+\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    struct Deprecated2(u8,\n+                       #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                       #[unstable(feature = \"test_feature\", issue = \"0\")] u8);\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+\n+        let x = Unstable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Unstable\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+\n+        let x = Unstable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable2\n+            (_,\n+             _,\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Unstable2\n+            // the patterns are all fine:\n+            (..) = x;\n+\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+            override1: 2,\n+            //~^ ERROR use of deprecated item\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.override1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+            override1: _,\n+            //~^ ERROR use of deprecated item\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1b605bdb89396567f6fc4e34d929a1c01b02cb5f", "filename": "src/test/compile-fail/lint-stability-fields.rs", "status": "modified", "additions": 27, "deletions": 115, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // aux-build:lint_stability_fields.rs\n-#![deny(deprecated)]\n+#![allow(deprecated)]\n #![allow(dead_code)]\n #![feature(staged_api)]\n \n@@ -24,23 +24,17 @@ mod cross_crate {\n         let x = Stable {\n             inherit: 1,\n             override1: 2, //~ ERROR use of unstable\n-            override2: 3,\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+            override2: 3, //~ ERROR use of unstable\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1; //~ ERROR use of unstable\n-        let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.override2; //~ ERROR use of unstable\n \n         let Stable {\n             inherit: _,\n             override1: _, //~ ERROR use of unstable\n-            override2: _\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+            override2: _ //~ ERROR use of unstable\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n@@ -49,15 +43,11 @@ mod cross_crate {\n \n         let _ = x.0;\n         let _ = x.1; //~ ERROR use of unstable\n-        let _ = x.2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.2; //~ ERROR use of unstable\n \n         let Stable2(_,\n                    _, //~ ERROR use of unstable\n-                   _)\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+                   _) //~ ERROR use of unstable\n             = x;\n         // all fine\n         let Stable2(..) = x;\n@@ -66,23 +56,17 @@ mod cross_crate {\n         let x = Unstable { //~ ERROR use of unstable\n             inherit: 1, //~ ERROR use of unstable\n             override1: 2,\n-            override2: 3,\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+            override2: 3, //~ ERROR use of unstable\n         };\n \n         let _ = x.inherit; //~ ERROR use of unstable\n         let _ = x.override1;\n-        let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.override2; //~ ERROR use of unstable\n \n         let Unstable { //~ ERROR use of unstable\n             inherit: _, //~ ERROR use of unstable\n             override1: _,\n-            override2: _\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+            override2: _ //~ ERROR use of unstable\n         } = x;\n \n         let Unstable  //~ ERROR use of unstable\n@@ -94,91 +78,50 @@ mod cross_crate {\n \n         let _ = x.0; //~ ERROR use of unstable\n         let _ = x.1;\n-        let _ = x.2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.2; //~ ERROR use of unstable\n \n         let Unstable2  //~ ERROR use of unstable\n             (_, //~ ERROR use of unstable\n              _,\n-             _)\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+             _) //~ ERROR use of unstable\n             = x;\n         let Unstable2 //~ ERROR use of unstable\n             // the patterns are all fine:\n             (..) = x;\n \n \n-        let x = Deprecated {\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n-            inherit: 1,\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+        let x = Deprecated { //~ ERROR use of unstable\n+            inherit: 1, //~ ERROR use of unstable\n             override1: 2,\n-            //~^ ERROR use of deprecated item\n-            override2: 3,\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+            override2: 3, //~ ERROR use of unstable\n         };\n \n-        let _ = x.inherit;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.inherit; //~ ERROR use of unstable\n         let _ = x.override1;\n-        //~^ ERROR use of deprecated item\n-        let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.override2; //~ ERROR use of unstable\n \n-        let Deprecated {\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n-            inherit: _,\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+        let Deprecated { //~ ERROR use of unstable\n+            inherit: _, //~ ERROR use of unstable\n             override1: _,\n-            //~^ ERROR use of deprecated item\n-            override2: _\n-            //~^ ERROR use of unstable\n-            //~^^ ERROR use of deprecated item\n+            override2: _ //~ ERROR use of unstable\n         } = x;\n \n-        let Deprecated\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable\n+        let Deprecated //~ ERROR use of unstable\n             // the patterns are all fine:\n             { .. } = x;\n \n-        let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let x = Deprecated2(1, 2, 3); //~ ERROR use of unstable\n \n-        let _ = x.0;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.0; //~ ERROR use of unstable\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item\n-        let _ = x.2;\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let _ = x.2; //~ ERROR use of unstable\n \n-        let Deprecated2\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n-            (_,\n-             //~^ ERROR use of deprecated item\n-             //~^^ ERROR use of unstable\n+        let Deprecated2 //~ ERROR use of unstable\n+            (_, //~ ERROR use of unstable\n              _,\n-             //~^ ERROR use of deprecated item\n-             _)\n-             //~^ ERROR use of deprecated item\n-             //~^^ ERROR use of unstable\n+             _) //~ ERROR use of unstable\n             = x;\n-        let Deprecated2\n-        //~^ ERROR use of deprecated item\n-        //~^^ ERROR use of unstable\n+        let Deprecated2 //~ ERROR use of unstable\n             // the patterns are all fine:\n             (..) = x;\n     }\n@@ -238,19 +181,16 @@ mod this_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n \n         let Stable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n         } = x;\n         // all fine\n         let Stable { .. } = x;\n@@ -260,12 +200,10 @@ mod this_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n \n         let Stable2(_,\n                    _,\n                    _)\n-            //~^ ERROR use of deprecated item\n             = x;\n         // all fine\n         let Stable2(..) = x;\n@@ -275,19 +213,16 @@ mod this_crate {\n             inherit: 1,\n             override1: 2,\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n         };\n \n         let _ = x.inherit;\n         let _ = x.override1;\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n \n         let Unstable {\n             inherit: _,\n             override1: _,\n             override2: _\n-            //~^ ERROR use of deprecated item\n         } = x;\n \n         let Unstable\n@@ -300,72 +235,49 @@ mod this_crate {\n         let _ = x.0;\n         let _ = x.1;\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n \n         let Unstable2\n             (_,\n              _,\n              _)\n-            //~^ ERROR use of deprecated item\n             = x;\n         let Unstable2\n             // the patterns are all fine:\n             (..) = x;\n \n \n         let x = Deprecated {\n-            //~^ ERROR use of deprecated item\n             inherit: 1,\n-            //~^ ERROR use of deprecated item\n             override1: 2,\n-            //~^ ERROR use of deprecated item\n             override2: 3,\n-            //~^ ERROR use of deprecated item\n         };\n \n         let _ = x.inherit;\n-        //~^ ERROR use of deprecated item\n         let _ = x.override1;\n-        //~^ ERROR use of deprecated item\n         let _ = x.override2;\n-        //~^ ERROR use of deprecated item\n \n         let Deprecated {\n-            //~^ ERROR use of deprecated item\n             inherit: _,\n-            //~^ ERROR use of deprecated item\n             override1: _,\n-            //~^ ERROR use of deprecated item\n             override2: _\n-            //~^ ERROR use of deprecated item\n         } = x;\n \n         let Deprecated\n-            //~^ ERROR use of deprecated item\n             // the patterns are all fine:\n             { .. } = x;\n \n         let x = Deprecated2(1, 2, 3);\n-        //~^ ERROR use of deprecated item\n \n         let _ = x.0;\n-        //~^ ERROR use of deprecated item\n         let _ = x.1;\n-        //~^ ERROR use of deprecated item\n         let _ = x.2;\n-        //~^ ERROR use of deprecated item\n \n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n             (_,\n-             //~^ ERROR use of deprecated item\n              _,\n-             //~^ ERROR use of deprecated item\n              _)\n-            //~^ ERROR use of deprecated item\n             = x;\n         let Deprecated2\n-        //~^ ERROR use of deprecated item\n             // the patterns are all fine:\n             (..) = x;\n     }"}, {"sha": "1ece7a0b8e33423fa8330ea213a79b733a82487a", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 90, "deletions": 150, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -13,7 +13,7 @@\n // aux-build:stability_cfg1.rs\n // aux-build:stability_cfg2.rs\n \n-#![deny(deprecated)]\n+#![allow(deprecated)]\n #![allow(dead_code)]\n #![feature(staged_api)]\n \n@@ -32,81 +32,46 @@ mod cross_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-\n-        deprecated_unstable(); //~ ERROR use of deprecated item\n+        deprecated();\n+        foo.method_deprecated();\n+        Foo::method_deprecated(&foo);\n+        <Foo>::method_deprecated(&foo);\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+\n+        deprecated_text();\n+        foo.method_deprecated_text();\n+        Foo::method_deprecated_text(&foo);\n+        <Foo>::method_deprecated_text(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+\n+        deprecated_unstable();\n         //~^ ERROR use of unstable library feature\n-        foo.method_deprecated_unstable(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo);\n         //~^ ERROR use of unstable library feature\n-        Foo::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        <Foo>::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo);\n         //~^ ERROR use of unstable library feature\n \n-        deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        foo.method_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        Foo::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        <Foo>::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        deprecated_unstable_text();\n         //~^ ERROR use of unstable library feature\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature\n \n         unstable(); //~ ERROR use of unstable library feature\n-        foo.method_unstable(); //~ ERROR use of unstable library feature\n-        Foo::method_unstable(&foo); //~ ERROR use of unstable library feature\n-        <Foo>::method_unstable(&foo); //~ ERROR use of unstable library feature\n-        foo.trait_unstable(); //~ ERROR use of unstable library feature\n         Trait::trait_unstable(&foo); //~ ERROR use of unstable library feature\n-        <Foo>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n         <Foo as Trait>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n \n         unstable_text();\n         //~^ ERROR use of unstable library feature 'test_feature': text\n-        foo.method_unstable_text();\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n-        Foo::method_unstable_text(&foo);\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n-        <Foo>::method_unstable_text(&foo);\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n-        foo.trait_unstable_text();\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n         Trait::trait_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature 'test_feature': text\n-        <Foo>::trait_unstable_text(&foo);\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n         <Foo as Trait>::trait_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature 'test_feature': text\n \n@@ -131,33 +96,31 @@ mod cross_crate {\n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         //~^ ERROR use of unstable library feature\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n-        //~^ ERROR use of deprecated item\n \n-        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+        let _ = DeprecatedStruct {\n+            i: 0\n         };\n         let _ = DeprecatedUnstableStruct {\n-            //~^ ERROR use of deprecated item\n-            //~^^ ERROR use of unstable library feature\n-            i: 0 //~ ERROR use of deprecated item\n+            //~^ ERROR use of unstable library feature\n+            i: 0\n         };\n         let _ = UnstableStruct { i: 0 }; //~ ERROR use of unstable library feature\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct;\n+        let _ = DeprecatedUnstableUnitStruct;\n         //~^ ERROR use of unstable library feature\n         let _ = UnstableUnitStruct; //~ ERROR use of unstable library feature\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n-        let _ = Enum::DeprecatedUnstableVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant;\n+        let _ = Enum::DeprecatedUnstableVariant;\n         //~^ ERROR use of unstable library feature\n         let _ = Enum::UnstableVariant; //~ ERROR use of unstable library feature\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1);\n+        let _ = DeprecatedUnstableTupleStruct (1);\n         //~^ ERROR use of unstable library feature\n         let _ = UnstableTupleStruct (1); //~ ERROR use of unstable library feature\n         let _ = StableTupleStruct (1);\n@@ -167,47 +130,33 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n-        macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(deprecated_text());\n+        macro_test_arg!(deprecated_unstable_text());\n         //~^ ERROR use of unstable library feature\n-        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text()));\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n+        Trait::trait_deprecated_unstable(&foo);\n         //~^ ERROR use of unstable library feature\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable(&foo);\n         //~^ ERROR use of unstable library feature\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature\n-        foo.trait_unstable(); //~ ERROR use of unstable library feature\n         Trait::trait_unstable(&foo); //~ ERROR use of unstable library feature\n-        <Foo>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n         <Foo as Trait>::trait_unstable(&foo); //~ ERROR use of unstable library feature\n-        foo.trait_unstable_text();\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n         Trait::trait_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature 'test_feature': text\n-        <Foo>::trait_unstable_text(&foo);\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n         <Foo as Trait>::trait_unstable_text(&foo);\n         //~^ ERROR use of unstable library feature 'test_feature': text\n         foo.trait_stable();\n@@ -217,24 +166,17 @@ mod cross_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        //~^ ERROR use of unstable library feature\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        //~^ ERROR use of unstable library feature\n-        foo.trait_unstable(); //~ ERROR use of unstable library feature\n-        foo.trait_unstable_text();\n-        //~^ ERROR use of unstable library feature 'test_feature': text\n+        foo.trait_deprecated();\n+        foo.trait_deprecated_text();\n         foo.trait_stable();\n     }\n \n     struct S;\n \n     impl UnstableTrait for S { } //~ ERROR use of unstable library feature\n-    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n+    impl DeprecatedTrait for S {}\n     trait LocalTrait : UnstableTrait { } //~ ERROR use of unstable library feature\n-    trait LocalTrait2 : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n+    trait LocalTrait2 : DeprecatedTrait { }\n \n     impl Trait for S {\n         fn trait_stable(&self) {}\n@@ -253,14 +195,13 @@ mod inheritance {\n         stable_mod::unstable(); //~ ERROR use of unstable library feature\n         stable_mod::stable();\n \n-        unstable_mod::deprecated(); //~ ERROR use of deprecated item\n+        unstable_mod::deprecated();\n         unstable_mod::unstable(); //~ ERROR use of unstable library feature\n \n         let _ = Unstable::UnstableVariant; //~ ERROR use of unstable library feature\n         let _ = Unstable::StableVariant;\n \n         let x: usize = 0;\n-        x.unstable(); //~ ERROR use of unstable library feature\n         x.stable();\n     }\n }\n@@ -375,23 +316,23 @@ mod this_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        deprecated();\n+        foo.method_deprecated();\n+        Foo::method_deprecated(&foo);\n+        <Foo>::method_deprecated(&foo);\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+\n+        deprecated_text();\n+        foo.method_deprecated_text();\n+        Foo::method_deprecated_text(&foo);\n+        <Foo>::method_deprecated_text(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n \n         unstable();\n         foo.method_unstable();\n@@ -430,34 +371,33 @@ mod this_crate {\n         <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct {\n-            //~^ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+            i: 0\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct;\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant;\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1);\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated();\n+        Trait::trait_deprecated(&foo);\n+        <Foo>::trait_deprecated(&foo);\n+        <Foo as Trait>::trait_deprecated(&foo);\n+        foo.trait_deprecated_text();\n+        Trait::trait_deprecated_text(&foo);\n+        <Foo>::trait_deprecated_text(&foo);\n+        <Foo as Trait>::trait_deprecated_text(&foo);\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -473,8 +413,8 @@ mod this_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated();\n+        foo.trait_deprecated_text();\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -484,15 +424,15 @@ mod this_crate {\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n-        fn_in_body(); //~ ERROR use of deprecated item: text\n+        fn_in_body();\n     }\n \n     impl MethodTester {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n-            fn_in_body(); //~ ERROR use of deprecated item: text\n+            fn_in_body();\n         }\n     }\n \n@@ -504,9 +444,9 @@ mod this_crate {\n \n     struct S;\n \n-    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+    impl DeprecatedTrait for S { }\n \n-    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+    trait LocalTrait : DeprecatedTrait { }\n }\n \n fn main() {}"}, {"sha": "e24441c5497d512d1c605bb60c85fcf0365e21b0", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(box_syntax)]\n \n-extern crate collections;\n-\n use std::collections::HashMap;\n \n trait Map<K, V>"}, {"sha": "671a518073c376e478eca2bfea872473ac763c9c", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -22,13 +22,15 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR expected unit struct/variant or constant, found method `Foo::bar`\n+        Foo::bar => {}\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::bar`\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR expected unit struct/variant or constant, found method `bar`\n+        <Foo>::bar => {}\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::bar`\n     }\n     match 0u32 {\n         <Foo>::trait_bar => {}\n-        //~^ ERROR expected unit struct/variant or constant, found method `trait_bar`\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::trait_bar`\n     }\n }"}, {"sha": "f3c9f29821ebb6c3b96f003270ad7b64c38c8f3b", "filename": "src/test/compile-fail/mir-dataflow/def-inits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,7 +10,7 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n-#![feature(rustc_attrs)]\n+#![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "8a5ab6e420adefb0ff83d298dc2f116844013cb7", "filename": "src/test/compile-fail/mir-dataflow/inits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,7 +10,7 @@\n \n // General test of maybe_inits state computed by MIR dataflow.\n \n-#![feature(rustc_attrs)]\n+#![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "8df66ea815c68800b80e2f6debc653fc74ba192c", "filename": "src/test/compile-fail/mir-dataflow/uninits-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,7 +10,7 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n-#![feature(rustc_attrs)]\n+#![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "2edd275e78691e59d73dd362ebdcf52d6c3f363f", "filename": "src/test/compile-fail/mir-dataflow/uninits-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,7 +10,7 @@\n \n // General test of maybe_uninits state computed by MIR dataflow.\n \n-#![feature(rustc_attrs)]\n+#![feature(core_intrinsics, rustc_attrs)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "4383f3ede0db5a1b87e6d177492fe5b918a87dab", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(libc)]\n+\n extern crate libc;\n \n fn main() {"}, {"sha": "1b8284debb49a7e965bc0d4ce800148dd6ecc679", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "7113224664b1fc63326a403815c80831cae42a77", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "030fbfc4914497aacc910ecf9db41f8f2bdc6425", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -13,7 +13,7 @@ mod m1 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type `m1::Priv` in public interface\n     }\n }\n \n@@ -24,7 +24,7 @@ mod m2 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type `m2::Priv` in public interface\n     }\n }\n "}, {"sha": "3496348985d8d174ca8faae75cdb8e6013e2772d", "filename": "src/test/compile-fail/private-in-public-warn.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -24,34 +24,34 @@ mod types {\n         type Alias;\n     }\n \n-    pub type Alias = Priv; //~ ERROR private type in public interface\n+    pub type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n     //~^ WARNING hard error\n     pub enum E {\n-        V1(Priv), //~ ERROR private type in public interface\n+        V1(Priv), //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        V2 { field: Priv }, //~ ERROR private type in public interface\n+        V2 { field: Priv }, //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     pub trait Tr {\n-        const C: Priv = Priv; //~ ERROR private type in public interface\n+        const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        fn f1(arg: Priv) {} //~ ERROR private type in public interface\n+        fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+        fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     extern {\n-        pub static ES: Priv; //~ ERROR private type in public interface\n+        pub static ES: Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        pub fn ef1(arg: Priv); //~ ERROR private type in public interface\n+        pub fn ef1(arg: Priv); //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        pub fn ef2() -> Priv; //~ ERROR private type in public interface\n+        pub fn ef2() -> Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PubTr for Pub {\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -61,22 +61,23 @@ mod traits {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub type Alias<T: PrivTr> = T; //~ ERROR private trait in public interface\n+    pub type Alias<T: PrivTr> = T; //~ ERROR private trait `traits::PrivTr` in public interface\n     //~^ WARN trait bounds are not (yet) enforced in type definitions\n     //~| WARNING hard error\n-    pub trait Tr1: PrivTr {} //~ ERROR private trait in public interface\n+    pub trait Tr1: PrivTr {} //~ ERROR private trait `traits::PrivTr` in public interface\n     //~^ WARNING hard error\n-    pub trait Tr2<T: PrivTr> {} //~ ERROR private trait in public interface\n+    pub trait Tr2<T: PrivTr> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     pub trait Tr3 {\n-        type Alias: PrivTr; //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-        fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait in public interface\n+        //~^ ERROR private trait `traits::PrivTr` in public interface\n+        //~| WARNING hard error\n+        type Alias: PrivTr;\n+        fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     }\n-    impl<T: PrivTr> Pub<T> {} //~ ERROR private trait in public interface\n+    impl<T: PrivTr> Pub<T> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n-    impl<T: PrivTr> PubTr for Pub<T> {} //~ ERROR private trait in public interface\n+    impl<T: PrivTr> PubTr for Pub<T> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n }\n \n@@ -85,18 +86,23 @@ mod traits_where {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub type Alias<T> where T: PrivTr = T; //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+    pub type Alias<T> where T: PrivTr = T;\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n     pub trait Tr3 {\n-        fn f<T>(arg: T) where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+        fn f<T>(arg: T) where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n     }\n-    impl<T> Pub<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    impl<T> PubTr for Pub<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+    impl<T> Pub<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n+    impl<T> PubTr for Pub<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n }\n \n mod generics {\n@@ -105,13 +111,14 @@ mod generics {\n     trait PrivTr<T> {}\n     pub trait PubTr<T> {}\n \n-    pub trait Tr1: PrivTr<Pub> {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2: PubTr<Priv> {} //~ ERROR private type in public interface\n+    pub trait Tr1: PrivTr<Pub> {}\n+        //~^ ERROR private trait `generics::PrivTr<generics::Pub>` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2: PubTr<Priv> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n-    pub trait Tr3: PubTr<[Priv; 1]> {} //~ ERROR private type in public interface\n+    pub trait Tr3: PubTr<[Priv; 1]> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n-    pub trait Tr4: PubTr<Pub<Priv>> {} //~ ERROR private type in public interface\n+    pub trait Tr4: PubTr<Pub<Priv>> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n }\n \n@@ -138,7 +145,7 @@ mod impls {\n         type Alias = Priv; // OK\n     }\n     impl PubTr for Pub {\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `impls::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -210,23 +217,23 @@ mod aliases_pub {\n     pub trait Tr2: PrivUseAliasTr<PrivAlias> {} // OK\n \n     impl PrivAlias {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     // This doesn't even parse\n     // impl <Priv as PrivTr>::AssocAlias {\n-    //     pub fn f(arg: Priv) {} // ERROR private type in public interface\n+    //     pub fn f(arg: Priv) {} // ERROR private type `aliases_pub::Priv` in public interface\n     // }\n     impl PrivUseAliasTr for PrivUseAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PrivUseAliasTr for PrivAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -251,11 +258,13 @@ mod aliases_priv {\n         type AssocAlias = Priv3;\n     }\n \n-    pub trait Tr1: PrivUseAliasTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} //~ ERROR private trait in public interface\n-     //~^ ERROR private type in public interface\n+    pub trait Tr1: PrivUseAliasTr {}\n+        //~^ ERROR private trait `aliases_priv::PrivTr1` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n+        //~^ ERROR private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface\n         //~| WARNING hard error\n+        //~| ERROR private type `aliases_priv::Priv2` in public interface\n         //~| WARNING hard error\n \n     impl PrivUseAlias {"}, {"sha": "b819ef116efe91d5c8eb0949404edd441c4ff79f", "filename": "src/test/compile-fail/private-in-public.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -21,16 +21,16 @@ mod types {\n         type Alias;\n     }\n \n-    pub const C: Priv = Priv; //~ ERROR private type in public interface\n-    pub static S: Priv = Priv; //~ ERROR private type in public interface\n-    pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n-    pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n-    pub struct S1(pub Priv); //~ ERROR private type in public interface\n-    pub struct S2 { pub field: Priv } //~ ERROR private type in public interface\n+    pub const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+    pub static S: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+    pub fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n+    pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n+    pub struct S1(pub Priv); //~ ERROR private type `types::Priv` in public interface\n+    pub struct S2 { pub field: Priv } //~ ERROR private type `types::Priv` in public interface\n     impl Pub {\n-        pub const C: Priv = Priv; //~ ERROR private type in public interface\n-        pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n-        pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+        pub const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+        pub fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n+        pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n     }\n }\n \n@@ -39,11 +39,11 @@ mod traits {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait in public interface\n-    pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait in public interface\n-    pub struct S1<T: PrivTr>(T); //~ ERROR private trait in public interface\n-    impl<T: PrivTr> Pub<T> {\n-        pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait in public interface\n+    pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait `traits::PrivTr` in public interface\n+    pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n+    pub struct S1<T: PrivTr>(T); //~ ERROR private trait `traits::PrivTr` in public interface\n+    impl<T: PrivTr> Pub<T> { //~ ERROR private trait `traits::PrivTr` in public interface\n+        pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n     }\n }\n \n@@ -52,11 +52,16 @@ mod traits_where {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub enum E<T> where T: PrivTr { V(T) } //~ ERROR private trait in public interface\n-    pub fn f<T>(arg: T) where T: PrivTr {} //~ ERROR private trait in public interface\n-    pub struct S1<T>(T) where T: PrivTr; //~ ERROR private trait in public interface\n+    pub enum E<T> where T: PrivTr { V(T) }\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+    pub fn f<T>(arg: T) where T: PrivTr {}\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+    pub struct S1<T>(T) where T: PrivTr;\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n     impl<T> Pub<T> where T: PrivTr {\n-        pub fn f<U>(arg: U) where U: PrivTr {} //~ ERROR private trait in public interface\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        pub fn f<U>(arg: U) where U: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n     }\n }\n \n@@ -66,9 +71,10 @@ mod generics {\n     trait PrivTr<T> {}\n     pub trait PubTr<T> {}\n \n-    pub fn f1(arg: [Priv; 1]) {} //~ ERROR private type in public interface\n-    pub fn f2(arg: Pub<Priv>) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: Priv<Pub>) {} //~ ERROR private type in public interface\n+    pub fn f1(arg: [Priv; 1]) {} //~ ERROR private type `generics::Priv` in public interface\n+    pub fn f2(arg: Pub<Priv>) {} //~ ERROR private type `generics::Priv` in public interface\n+    pub fn f3(arg: Priv<Pub>) {}\n+    //~^ ERROR private type `generics::Priv<generics::Pub>` in public interface\n }\n \n mod impls {\n@@ -82,7 +88,7 @@ mod impls {\n     }\n \n     impl Pub {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `impls::Priv` in public interface\n     }\n }\n \n@@ -101,15 +107,17 @@ mod aliases_pub {\n     use self::m::PubTr as PrivUseAliasTr;\n     type PrivAlias = m::Pub2;\n     trait PrivTr {\n-        type AssocAlias = m::Pub3;\n+        type Assoc = m::Pub3;\n     }\n     impl PrivTr for Priv {}\n \n     // This should be OK, but associated type aliases are not substituted yet\n-    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+    pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n+    //~^ ERROR private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+    //~| ERROR private type `aliases_pub::Priv` in public interface\n \n     impl PrivUseAlias {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `aliases_pub::Priv` in public interface\n     }\n }\n \n@@ -127,22 +135,25 @@ mod aliases_priv {\n     use self::PrivTr1 as PrivUseAliasTr;\n     type PrivAlias = Priv2;\n     trait PrivTr {\n-        type AssocAlias = Priv3;\n+        type Assoc = Priv3;\n     }\n     impl PrivTr for Priv {}\n \n-    pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type in public interface\n-    pub fn f2(arg: PrivAlias) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+    pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type `aliases_priv::Priv1` in public interface\n+    pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n+    pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n+    //~^ ERROR private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public\n+    //~| ERROR private type `aliases_priv::Priv` in public interface\n }\n \n mod aliases_params {\n     struct Priv;\n     type PrivAliasGeneric<T = Priv> = T;\n     type Result<T> = ::std::result::Result<T, Priv>;\n \n-    pub fn f2(arg: PrivAliasGeneric) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: Result<u8>) {} //~ ERROR private type in public interface\n+    pub fn f2(arg: PrivAliasGeneric) {}\n+    //~^ ERROR private type `aliases_params::Priv` in public interface\n+    pub fn f3(arg: Result<u8>) {} //~ ERROR private type `aliases_params::Priv` in public interface\n }\n \n fn main() {}"}, {"sha": "a7bc27e1749182e0f1de42ab64f52992979e4216", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -28,7 +28,7 @@ impl S {\n fn main() {\n     match 10 {\n         <S as Tr>::A::f::<u8> => {}\n-        //~^ ERROR expected unit struct/variant or constant, found method `Tr::A::f<u8>`\n+        //~^ ERROR expected unit struct/variant or constant, found method `<<S as Tr>::A>::f<u8>`\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "1d1153e951b7b1a373974fdf433e10610eb0008d", "filename": "src/test/compile-fail/range_inclusive_gate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -16,10 +16,8 @@\n pub fn main() {\n     let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ... { use std::intrinsics; 2 };\n     //~^ ERROR use of unstable library feature 'inclusive_range'\n-    //~^^ ERROR core_intrinsics\n-    //~^^^ ERROR core_intrinsics\n-    //~^^^^ WARN unused_imports\n-    //~^^^^^ WARN unused_imports\n+    //~| ERROR core_intrinsics\n+    //~| ERROR core_intrinsics\n }\n \n "}, {"sha": "47da97daaffda1b0ed92d68b5c75d2302b648a50", "filename": "src/test/compile-fail/reflect-assoc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect-assoc.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(reflect_marker)]\n+\n // Test that types that appear in assoc bindings in an object\n // type are subject to the reflect check.\n "}, {"sha": "be0dbd801b7966efc2bbb3e090fbbccc41c2cd10", "filename": "src/test/compile-fail/reflect-object-param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect-object-param.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(reflect_marker)]\n+\n // Test that types that appear in input types in an object type are\n // subject to the reflect check.\n "}, {"sha": "28ff7c82c2e0a02af568b87698d7da66de131ddc", "filename": "src/test/compile-fail/reflect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freflect.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(reflect_marker)]\n+\n // Test that there is no way to get a generic type `T` to be\n // considered as `Reflect` (or accessible via something that is\n // considered `Reflect`) without a reflect bound, but that any"}, {"sha": "59fe1ce3af1af7e87e1549662ce28f896a62a977", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n struct closure_box<'a> {\n     cl: Box<FnMut() + 'a>,\n }"}, {"sha": "530dc873f750430e37aec712e9077e02c9513e73", "filename": "src/test/compile-fail/resolve_self_super_hint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(collections)]\n+\n mod a {\n     extern crate collections;\n     use collections::HashMap;"}, {"sha": "0ddc3a8dcebb8cd8f64d676a070025057a827d81", "filename": "src/test/compile-fail/stability-attribute-sanity-2.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-2.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -23,9 +23,4 @@ fn f2() { }\n #[unstable(feature = \"a\", issue = \"no\")] //~ ERROR incorrect 'issue'\n fn f3() { }\n \n-#[macro_export]\n-macro_rules! mac { //~ ERROR This node does not have a stability attribute\n-    () => ()\n-}\n-\n fn main() { }"}, {"sha": "ddefd24b92fd9f8091167c65fdc6f9b633d0ef6b", "filename": "src/test/compile-fail/stability-attribute-sanity-3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity-3.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// More checks that stability attributes are used correctly\n+\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"test_feature\", since = \"1.0.0\")]\n+\n+#[macro_export]\n+macro_rules! mac { //~ ERROR This node does not have a stability attribute\n+    () => ()\n+}\n+\n+fn main() { }"}, {"sha": "f52b128e7e54ad697236bad90c0a3465dbcb70ea", "filename": "src/test/compile-fail/static-mut-foreign-requires-unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(libc)]\n+\n extern crate libc;\n \n extern {"}, {"sha": "d85717f8ce55e104419a2dd5543005b502bfc377", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rand)]\n+\n // ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n \n use std::__rand::ThreadRng;"}, {"sha": "2e865b2aac8fc822fa415f145d70b1e454cbafff", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -11,7 +11,7 @@\n // Checks that the Fn trait hierarchy rules do not permit\n // Fn to be used where FnMut is implemented.\n \n-#![feature(unboxed_closures)]\n+#![feature(fn_traits, unboxed_closures)]\n #![feature(overloaded_calls)]\n \n use std::ops::{Fn,FnMut,FnOnce};"}, {"sha": "bfb24c58722959d33329f3d06b32b81412fd04d0", "filename": "src/test/compile-fail/unboxed-closures-infer-argument-types-two-region-pointers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n // That a closure whose expected argument types include two distinct\n // bound regions.\n "}, {"sha": "433c0c839c580f90208f96504543d7e6cc179e53", "filename": "src/test/compile-fail/unboxed-closures-recursive-fn-using-fn-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core,unboxed_closures)]\n+#![feature(core, fn_traits, unboxed_closures)]\n \n use std::marker::PhantomData;\n "}, {"sha": "84bcca3fc7bd3a3726c6387ea087e21b2d6b926a", "filename": "src/test/compile-fail/unspecified-self-in-trait-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n pub trait Foo<A=Self> {\n-    fn foo();\n+    fn foo(&self);\n }\n \n pub trait Bar<X=usize, A=Self> {\n-    fn foo();\n+    fn foo(&self);\n }\n \n fn main() {"}, {"sha": "fdb7f9c68b99db54189764c305f92df4223d482e", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -40,7 +40,7 @@\n \n \n                   (($crate::fmt::format as\n-                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n+                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n                                                                                                    as\n                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n                                                                                                                                                                                                                static __STATIC_FMTSTR:"}, {"sha": "be353f6d563a196c7f2e6cb25e18b12bdecb2282", "filename": "src/test/run-pass/impl-trait/auxiliary/xcrate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+pub fn fourway_add(a: i32) -> impl Fn(i32) -> impl Fn(i32) -> impl Fn(i32) -> i32 {\n+    move |b| move |c| move |d| a + b + c + d\n+}"}, {"sha": "fe3ed7b3465f47dee3ab9be7f82940a624192156", "filename": "src/test/run-pass/impl-trait/xcrate.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate.rs\n+\n+extern crate xcrate;\n+\n+fn main() {\n+    assert_eq!(xcrate::fourway_add(1)(2)(3)(4), 10);\n+}"}, {"sha": "4b6843d33f7ac367dac45ea5b5122b3ac335ce46", "filename": "src/test/rustdoc/viewpath-rename.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frustdoc%2Fviewpath-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frustdoc%2Fviewpath-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fviewpath-rename.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -21,8 +21,11 @@ pub enum Maybe<A> {\n \n // @has foo/prelude/index.html\n pub mod prelude {\n-    // @has foo/prelude/index.html '//code' 'pub use io::{self as FooIo, Reader as FooReader}'\n+    // @has foo/prelude/index.html '//code' 'pub use io as FooIo;'\n+    // @has foo/prelude/index.html '//code' 'pub use io::Reader as FooReader;'\n     #[doc(no_inline)] pub use io::{self as FooIo, Reader as FooReader};\n-    // @has foo/prelude/index.html '//code' 'pub use Maybe::{self, Just as MaybeJust, Nothing}'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe;'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe::Just as MaybeJust;'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe::Nothing;'\n     #[doc(no_inline)] pub use Maybe::{self, Just as MaybeJust, Nothing};\n }"}, {"sha": "000960ad972abf867eeedb2e18c797a1615227da", "filename": "src/test/rustdoc/viewpath-self.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frustdoc%2Fviewpath-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Frustdoc%2Fviewpath-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fviewpath-self.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -21,8 +21,11 @@ pub enum Maybe<A> {\n \n // @has foo/prelude/index.html\n pub mod prelude {\n-    // @has foo/prelude/index.html '//code' 'pub use io::{self, Reader}'\n+    // @has foo/prelude/index.html '//code' 'pub use io;'\n+    // @has foo/prelude/index.html '//code' 'pub use io::Reader;'\n     #[doc(no_inline)] pub use io::{self, Reader};\n-    // @has foo/prelude/index.html '//code' 'pub use Maybe::{self, Just, Nothing}'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe;'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe::Just;'\n+    // @has foo/prelude/index.html '//code' 'pub use Maybe::Nothing;'\n     #[doc(no_inline)] pub use Maybe::{self, Just, Nothing};\n }"}, {"sha": "01269714c16caea165d15def498158beeae44903", "filename": "src/test/ui/span/issue-23827.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b399e5e99a44cf44d3860d353a8b7619d466410/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs?ref=0b399e5e99a44cf44d3860d353a8b7619d466410", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for #23827\n \n-#![feature(core, unboxed_closures)]\n+#![feature(core, fn_traits, unboxed_closures)]\n \n pub struct Prototype {\n     pub target: u32"}]}