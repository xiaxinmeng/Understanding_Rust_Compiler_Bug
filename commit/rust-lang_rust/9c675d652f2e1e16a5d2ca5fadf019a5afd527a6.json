{"sha": "9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "node_id": "C_kwDOAAsO6NoAKDljNjc1ZDY1MmYyZTFlMTZhNWQyY2E1ZmFkZjAxOWE1YWZkNTI3YTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T12:03:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T12:03:27Z"}, "message": "Auto merge of #12014 - Veykril:expmacfmt, r=Veykril\n\nfeat: Attempt to format expand_macro output with rustfmt if possible\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/10548", "tree": {"sha": "1f696f8075e8ef24fc1421ee738f219c09495d90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f696f8075e8ef24fc1421ee738f219c09495d90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "html_url": "https://github.com/rust-lang/rust/commit/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53afd2a707138230dee582fa1d5c3075cab2b6b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/53afd2a707138230dee582fa1d5c3075cab2b6b7", "html_url": "https://github.com/rust-lang/rust/commit/53afd2a707138230dee582fa1d5c3075cab2b6b7"}, {"sha": "3de9a4281018f40934b195f0f8960c10147163ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de9a4281018f40934b195f0f8960c10147163ff", "html_url": "https://github.com/rust-lang/rust/commit/3de9a4281018f40934b195f0f8960c10147163ff"}], "stats": {"total": 117, "additions": 98, "deletions": 19}, "files": [{"sha": "78ad6dc07db873092e68c22859bdbdfb224804af", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "patch": "@@ -611,6 +611,7 @@ dependencies = [\n  \"syntax\",\n  \"test_utils\",\n  \"text_edit\",\n+ \"toolchain\",\n  \"tracing\",\n  \"url\",\n ]"}, {"sha": "d09b4a0dafe90a5ccfe96bb9dcdc46af2bb17bb9", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "patch": "@@ -37,6 +37,9 @@ ide_completion = { path = \"../ide_completion\", version = \"0.0.0\" }\n # something from some `hir_xxx` subpackage, reexport the API via `hir`.\n hir = { path = \"../hir\", version = \"0.0.0\" }\n \n+[target.'cfg(not(any(target_arch = \"wasm32\", target_os = \"emscripten\")))'.dependencies]\n+toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n+\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n expect-test = \"1.2.2\""}, {"sha": "e4061016e607e4c030fb6c7abd2e4a860b97b6bf", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 94, "deletions": 18, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "patch": "@@ -1,7 +1,7 @@\n use hir::Semantics;\n use ide_db::{\n-    helpers::pick_best_token, syntax_helpers::insert_whitespace_into_node::insert_ws_into,\n-    RootDatabase,\n+    base_db::FileId, helpers::pick_best_token,\n+    syntax_helpers::insert_whitespace_into_node::insert_ws_into, RootDatabase,\n };\n use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T};\n \n@@ -58,10 +58,9 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n             .take_while(|it| it != &token)\n             .filter(|it| it.kind() == T![,])\n             .count();\n-        Some(ExpandedMacro {\n-            name,\n-            expansion: expansions.get(idx).cloned().map(insert_ws_into)?.to_string(),\n-        })\n+        let expansion =\n+            format(db, SyntaxKind::MACRO_ITEMS, position.file_id, expansions.get(idx).cloned()?);\n+        Some(ExpandedMacro { name, expansion })\n     });\n \n     if derive.is_some() {\n@@ -70,28 +69,34 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n \n     // FIXME: Intermix attribute and bang! expansions\n     // currently we only recursively expand one of the two types\n-    let mut expanded = None;\n-    let mut name = None;\n-    for node in tok.ancestors() {\n+    let mut anc = tok.ancestors();\n+    let (name, expanded, kind) = loop {\n+        let node = anc.next()?;\n+\n         if let Some(item) = ast::Item::cast(node.clone()) {\n             if let Some(def) = sema.resolve_attr_macro_call(&item) {\n-                name = Some(def.name(db).to_string());\n-                expanded = expand_attr_macro_recur(&sema, &item);\n-                break;\n+                break (\n+                    def.name(db).to_string(),\n+                    expand_attr_macro_recur(&sema, &item)?,\n+                    SyntaxKind::MACRO_ITEMS,\n+                );\n             }\n         }\n         if let Some(mac) = ast::MacroCall::cast(node) {\n-            name = Some(mac.path()?.segment()?.name_ref()?.to_string());\n-            expanded = expand_macro_recur(&sema, &mac);\n-            break;\n+            break (\n+                mac.path()?.segment()?.name_ref()?.to_string(),\n+                expand_macro_recur(&sema, &mac)?,\n+                mac.syntax().parent().map(|it| it.kind()).unwrap_or(SyntaxKind::MACRO_ITEMS),\n+            );\n         }\n-    }\n+    };\n \n     // FIXME:\n     // macro expansion may lose all white space information\n     // But we hope someday we can use ra_fmt for that\n-    let expansion = insert_ws_into(expanded?).to_string();\n-    Some(ExpandedMacro { name: name.unwrap_or_else(|| \"???\".to_owned()), expansion })\n+    let expansion = format(db, kind, position.file_id, expanded);\n+\n+    Some(ExpandedMacro { name, expansion })\n }\n \n fn expand_macro_recur(\n@@ -130,6 +135,77 @@ fn expand<T: AstNode>(\n     Some(expanded)\n }\n \n+fn format(db: &RootDatabase, kind: SyntaxKind, file_id: FileId, expanded: SyntaxNode) -> String {\n+    let expansion = insert_ws_into(expanded).to_string();\n+\n+    _format(db, kind, file_id, &expansion).unwrap_or(expansion)\n+}\n+\n+#[cfg(any(test, target_arch = \"wasm32\", target_os = \"emscripten\"))]\n+fn _format(\n+    _db: &RootDatabase,\n+    _kind: SyntaxKind,\n+    _file_id: FileId,\n+    _expansion: &str,\n+) -> Option<String> {\n+    None\n+}\n+\n+#[cfg(not(any(test, target_arch = \"wasm32\", target_os = \"emscripten\")))]\n+fn _format(\n+    db: &RootDatabase,\n+    kind: SyntaxKind,\n+    file_id: FileId,\n+    expansion: &str,\n+) -> Option<String> {\n+    use ide_db::base_db::{FileLoader, SourceDatabase};\n+    // hack until we get hygiene working (same character amount to preserve formatting as much as possible)\n+    const DOLLAR_CRATE_REPLACE: &str = &\"__r_a_\";\n+    let expansion = expansion.replace(\"$crate\", DOLLAR_CRATE_REPLACE);\n+    let (prefix, suffix) = match kind {\n+        SyntaxKind::MACRO_PAT => (\"fn __(\", \": u32);\"),\n+        SyntaxKind::MACRO_EXPR | SyntaxKind::MACRO_STMTS => (\"fn __() {\", \"}\"),\n+        SyntaxKind::MACRO_TYPE => (\"type __ =\", \";\"),\n+        _ => (\"\", \"\"),\n+    };\n+    let expansion = format!(\"{prefix}{expansion}{suffix}\");\n+\n+    let &crate_id = db.relevant_crates(file_id).iter().next()?;\n+    let edition = db.crate_graph()[crate_id].edition;\n+\n+    let mut cmd = std::process::Command::new(toolchain::rustfmt());\n+    cmd.arg(\"--edition\");\n+    cmd.arg(edition.to_string());\n+\n+    let mut rustfmt = cmd\n+        .stdin(std::process::Stdio::piped())\n+        .stdout(std::process::Stdio::piped())\n+        .stderr(std::process::Stdio::piped())\n+        .spawn()\n+        .ok()?;\n+\n+    std::io::Write::write_all(&mut rustfmt.stdin.as_mut()?, expansion.as_bytes()).ok()?;\n+\n+    let output = rustfmt.wait_with_output().ok()?;\n+    let captured_stdout = String::from_utf8(output.stdout).ok()?;\n+\n+    if output.status.success() && !captured_stdout.trim().is_empty() {\n+        let output = captured_stdout.replace(DOLLAR_CRATE_REPLACE, \"$crate\");\n+        let output = output.trim().strip_prefix(prefix)?;\n+        let output = match kind {\n+            SyntaxKind::MACRO_PAT => {\n+                output.strip_suffix(suffix).or_else(|| output.strip_suffix(\": u32,\\n);\"))?\n+            }\n+            _ => output.strip_suffix(suffix)?,\n+        };\n+        let trim_indent = stdx::trim_indent(output);\n+        tracing::debug!(\"expand_macro: formatting succeeded\");\n+        Some(trim_indent)\n+    } else {\n+        None\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "1fb3b5ec3f38b233270fd8e65d24e521d23434b5", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c675d652f2e1e16a5d2ca5fadf019a5afd527a6/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=9c675d652f2e1e16a5d2ca5fadf019a5afd527a6", "patch": "@@ -340,7 +340,6 @@ impl TryToNav for hir::Macro {\n             Either::Left(it) => it,\n             Either::Right(it) => it,\n         };\n-        tracing::debug!(\"nav target {:#?}\", name_owner.syntax());\n         let mut res = NavigationTarget::from_named(\n             db,\n             src.as_ref().with_value(name_owner),"}]}