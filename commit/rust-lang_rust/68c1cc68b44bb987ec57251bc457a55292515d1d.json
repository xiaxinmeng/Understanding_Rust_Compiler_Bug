{"sha": "68c1cc68b44bb987ec57251bc457a55292515d1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YzFjYzY4YjQ0YmI5ODdlYzU3MjUxYmM0NTdhNTUyOTI1MTVkMWQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-03T09:23:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-14T04:03:43Z"}, "message": "Refactor `Attribute` to use `Path` and `TokenStream` instead of `MetaItem`.", "tree": {"sha": "c091a1804173d06c3f32831cdaf6ae2ca24dc42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c091a1804173d06c3f32831cdaf6ae2ca24dc42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c1cc68b44bb987ec57251bc457a55292515d1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c1cc68b44bb987ec57251bc457a55292515d1d", "html_url": "https://github.com/rust-lang/rust/commit/68c1cc68b44bb987ec57251bc457a55292515d1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c1cc68b44bb987ec57251bc457a55292515d1d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "460bf55f8a649a7f19680df2ac67dbeb936f8700", "url": "https://api.github.com/repos/rust-lang/rust/commits/460bf55f8a649a7f19680df2ac67dbeb936f8700", "html_url": "https://github.com/rust-lang/rust/commit/460bf55f8a649a7f19680df2ac67dbeb936f8700"}], "stats": {"total": 976, "additions": 614, "deletions": 362}, "files": [{"sha": "54ae947214091653c329807a603495f7992ea099", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -120,11 +120,12 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        let name: &str = &attr.name().as_str();\n-        match name {\n-            \"inline\" => self.check_inline(attr, target),\n-            \"repr\" => self.check_repr(attr, target),\n-            _ => (),\n+        if let Some(name) = attr.name() {\n+            match &*name.as_str() {\n+                \"inline\" => self.check_inline(attr, target),\n+                \"repr\" => self.check_repr(attr, target),\n+                _ => (),\n+            }\n         }\n     }\n }"}, {"sha": "a5c8213067550bdae05cf93ea0c1832663140be3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -1277,7 +1277,7 @@ impl<'a> LoweringContext<'a> {\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n         if let ItemKind::MacroDef(ref tts) = i.node {\n-            if i.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+            if i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n                 self.exported_macros.push(hir::MacroDef {\n                     name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),\n                 });"}, {"sha": "65e2fec0b8b0931fa129b428d3917b814cb9e599", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -402,14 +402,14 @@ pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, S\n pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n \n-    let level = match Level::from_str(&attr.name().as_str()) {\n+    let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n         None => return out,\n         Some(lvl) => lvl,\n     };\n \n+    let meta = unwrap_or!(attr.meta(), return out);\n     attr::mark_used(attr);\n \n-    let meta = &attr.value;\n     let metas = if let Some(metas) = meta.meta_item_list() {\n         metas\n     } else {"}, {"sha": "1fb537140257465eae43371f32b7b78eead2c4bf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = attr.name();\n+                let tag = unwrap_or!(attr.name(), continue);\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> Index<'tcx> {\n \n         let mut is_staged_api = false;\n         for attr in &krate.attrs {\n-            if attr.name() == \"stable\" || attr.name() == \"unstable\" {\n+            if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 is_staged_api = true;\n                 break\n             }"}, {"sha": "27525d550ff209e9e2f86354d31d7efa02e95461", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n             .next()\n         {\n-            let err_sp = item.meta().span.substitute_dummy(span);\n+            let err_sp = item.span.substitute_dummy(span);\n             let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n             if let Some(istring) = item.value_str() {\n                 let istring = &*istring.as_str();"}, {"sha": "fac49b29598aa0cb31feb4370f989e1f69e3b2fb", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -18,16 +18,15 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::{self as visit, Visitor};\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv;\n use std::hash::{Hash, Hasher};\n \n use super::def_path_hash::DefPathHashes;\n@@ -559,7 +558,7 @@ macro_rules! hash_span {\n     });\n }\n \n-impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n+impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n         if self.hash_bodies {\n             visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n@@ -960,50 +959,24 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         }\n     }\n \n-    fn hash_meta_item(&mut self, meta_item: &ast::MetaItem) {\n-        debug!(\"hash_meta_item: st={:?}\", self.st);\n-\n-        // ignoring span information, it doesn't matter here\n-        self.hash_discriminant(&meta_item.node);\n-        meta_item.name.as_str().len().hash(self.st);\n-        meta_item.name.as_str().hash(self.st);\n-\n-        match meta_item.node {\n-            ast::MetaItemKind::Word => {}\n-            ast::MetaItemKind::NameValue(ref lit) => saw_lit(lit).hash(self.st),\n-            ast::MetaItemKind::List(ref items) => {\n-                // Sort subitems so the hash does not depend on their order\n-                let indices = self.indices_sorted_by(&items, |p| {\n-                    (p.name().map(Symbol::as_str), fnv::hash(&p.literal().map(saw_lit)))\n-                });\n-                items.len().hash(self.st);\n-                for (index, &item_index) in indices.iter().enumerate() {\n-                    index.hash(self.st);\n-                    let nested_meta_item: &ast::NestedMetaItemKind = &items[item_index].node;\n-                    self.hash_discriminant(nested_meta_item);\n-                    match *nested_meta_item {\n-                        ast::NestedMetaItemKind::MetaItem(ref meta_item) => {\n-                            self.hash_meta_item(meta_item);\n-                        }\n-                        ast::NestedMetaItemKind::Literal(ref lit) => {\n-                            saw_lit(lit).hash(self.st);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n         debug!(\"hash_attributes: st={:?}\", self.st);\n         let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n \n         for i in indices {\n             let attr = &attributes[i];\n-            if !attr.is_sugared_doc &&\n-               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name().as_str()) {\n+            match attr.name() {\n+                Some(name) if IGNORED_ATTRIBUTES.contains(&&*name.as_str()) => continue,\n+                _ => {}\n+            };\n+            if !attr.is_sugared_doc {\n                 SawAttribute(attr.style).hash(self.st);\n-                self.hash_meta_item(&attr.value);\n+                for segment in &attr.path.segments {\n+                    SawIdent(segment.identifier.name.as_str()).hash(self.st);\n+                }\n+                for tt in attr.tokens.trees() {\n+                    self.hash_token_tree(&tt);\n+                }\n             }\n         }\n     }"}, {"sha": "929249df0b173a15a544b7c417f77635e409c39d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -104,9 +104,9 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n-        for item in attr.meta_item_list().unwrap_or(&[]) {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n-                let value = expect_associated_value(self.tcx, item);\n+                let value = expect_associated_value(self.tcx, &item);\n                 match DepNode::from_label_string(&value.as_str(), def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n@@ -331,9 +331,9 @@ fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n-    for item in attr.meta_item_list().unwrap_or(&[]) {\n+    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n         if item.check_name(CFG) {\n-            let value = expect_associated_value(tcx, item);\n+            let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             return config.contains(&(value, None));\n         }"}, {"sha": "f0276f90f274d6d99ffa2f37b88512c1481a2b37", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -312,7 +312,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.check_name(\"doc\"));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS,\n                          sp,\n@@ -635,7 +635,7 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = attr.name();\n+        let name = unwrap_or!(attr.name(), return);\n         for &&(n, _, ref g) in &self.depr_attrs {\n             if name == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n@@ -1121,8 +1121,8 @@ impl LintPass for UnstableFeatures {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n-        if attr.meta().check_name(\"feature\") {\n-            if let Some(items) = attr.meta().meta_item_list() {\n+        if attr.check_name(\"feature\") {\n+            if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n                 }"}, {"sha": "05dbbc09870252abaa963e49025a924c7fe81861", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -38,6 +38,7 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n \n+#[macro_use]\n extern crate syntax;\n #[macro_use]\n extern crate rustc;"}, {"sha": "abba8afd9da8699f33f5a4691fd4ede7a5477619", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -269,6 +269,7 @@ impl LintPass for UnusedAttributes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n+        let name = unwrap_or!(attr.name(), return);\n \n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n@@ -294,13 +295,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = BUILTIN_ATTRIBUTES.iter()\n-                .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n+                .find(|&&(builtin, ty, _)| name == builtin && ty == AttributeType::CrateLevel)\n                 .is_some();\n \n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| attr.name() == &**x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| name == &**x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "9f5ce00f4081214f870ab9c30395c3c427ce7a68", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -973,9 +973,11 @@ impl<'a> CrateLoader<'a> {\n \n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n-        for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(linkarg) = attr.value_str() {\n-                self.cstore.add_used_link_args(&linkarg.as_str());\n+        for attr in &krate.attrs {\n+            if attr.path == \"link_args\" {\n+                if let Some(linkarg) = attr.value_str() {\n+                    self.cstore.add_used_link_args(&linkarg.as_str());\n+                }\n             }\n         }\n     }"}, {"sha": "17a6a706e0aaa1be559afd5d05406d9b0a1fc6bc", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -269,9 +269,12 @@ impl CrateMetadata {\n     }\n \n     pub fn is_staged_api(&self) -> bool {\n-        self.get_item_attrs(CRATE_DEF_INDEX)\n-            .iter()\n-            .any(|attr| attr.name() == \"stable\" || attr.name() == \"unstable\")\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX) {\n+            if attr.path == \"stable\" || attr.path == \"unstable\" {\n+                return true;\n+            }\n+        }\n+        false\n     }\n \n     pub fn is_allocator(&self) -> bool {"}, {"sha": "8c45a6669453354fdfcbe5b9202502f2f9a7d545", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -241,12 +241,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if let Some(attr) =\n-                        item.attrs.iter().find(|attr| attr.name() == \"warn_directory_ownership\") {\n+                if item.attrs.iter().any(|attr| attr.check_name(\"warn_directory_ownership\")) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.add_lint(lint, item.id, item.span, msg.to_string());\n-                    attr::mark_used(attr);\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {"}, {"sha": "c3e471650a3e183c254da6a229ba27a3fc8e5f43", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -3360,8 +3360,9 @@ impl<'a> Resolver<'a> {\n         if self.proc_macro_enabled { return; }\n \n         for attr in attrs {\n-            let maybe_binding = self.builtin_macros.get(&attr.name()).cloned().or_else(|| {\n-                let ident = Ident::with_empty_ctxt(attr.name());\n+            let name = unwrap_or!(attr.name(), continue);\n+            let maybe_binding = self.builtin_macros.get(&name).cloned().or_else(|| {\n+                let ident = Ident::with_empty_ctxt(name);\n                 self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n             });\n "}, {"sha": "9e1dcd1bc35c497dc4ef71c8e17189fde08e4d73", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -30,6 +30,7 @@ use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n+use syntax::tokenstream::TokenStream;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -176,12 +177,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n+            let name = unwrap_or!(attrs[i].name(), continue);\n+\n             if self.session.plugin_attributes.borrow().iter()\n-                    .any(|&(ref attr_nm, _)| attrs[i].name() == &**attr_nm) {\n+                    .any(|&(ref attr_nm, _)| name == &**attr_nm) {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.builtin_macros.get(&attrs[i].name()).cloned() {\n+            match self.builtin_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -194,9 +197,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         // Check for legacy derives\n         for i in 0..attrs.len() {\n-            if attrs[i].name() == \"derive\" {\n+            let name = unwrap_or!(attrs[i].name(), continue);\n+\n+            if name == \"derive\" {\n                 let mut traits = match attrs[i].meta_item_list() {\n-                    Some(traits) if !traits.is_empty() => traits.to_owned(),\n+                    Some(traits) => traits,\n                     _ => continue,\n                 };\n \n@@ -213,18 +218,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     if traits.is_empty() {\n                         attrs.remove(i);\n                     } else {\n-                        attrs[i].value = ast::MetaItem {\n-                            name: attrs[i].name(),\n-                            span: attrs[i].span,\n-                            node: ast::MetaItemKind::List(traits),\n-                        };\n+                        attrs[i].tokens = ast::MetaItemKind::List(traits).tokens(attrs[i].span);\n                     }\n                     return Some(ast::Attribute {\n-                        value: ast::MetaItem {\n-                            name: legacy_name,\n-                            span: span,\n-                            node: ast::MetaItemKind::Word,\n-                        },\n+                        path: ast::Path::from_ident(span, Ident::with_empty_ctxt(legacy_name)),\n+                        tokens: TokenStream::empty(),\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n                         is_sugared_doc: false,\n@@ -270,19 +268,20 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let (attr_name, path) = {\n-            let attr = attr.as_ref().unwrap();\n-            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n-        };\n \n-        let mut determined = true;\n+        let path = attr.as_ref().unwrap().path.clone();\n+        let mut determinacy = Determinacy::Determined;\n         match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n             Ok(def) => return Ok(def),\n-            Err(Determinacy::Undetermined) => determined = false,\n+            Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n             Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n             Err(Determinacy::Determined) => {}\n         }\n \n+        let attr_name = match path.segments.len() {\n+            1 => path.segments[0].identifier.name,\n+            _ => return Err(determinacy),\n+        };\n         for &(name, span) in traits {\n             let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n             match self.resolve_macro(scope, &path, MacroKind::Derive, force) {\n@@ -304,12 +303,12 @@ impl<'a> Resolver<'a> {\n                     }\n                     return Err(Determinacy::Undetermined);\n                 },\n-                Err(Determinacy::Undetermined) => determined = false,\n+                Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n                 Err(Determinacy::Determined) => {}\n             }\n         }\n \n-        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n+        Err(determinacy)\n     }\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)"}, {"sha": "f038c2dc298ad1fdce8b0bc97905239b19f2f38b", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::TyCtxt;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::CodeMap;\n use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use data::{self, Visibility, SigElement};\n@@ -77,10 +76,9 @@ impl Lower for Vec<ast::Attribute> {\n     type Target = Vec<Attribute>;\n \n     fn lower(self, tcx: TyCtxt) -> Vec<Attribute> {\n-        let doc = Symbol::intern(\"doc\");\n         self.into_iter()\n         // Only retain real attributes. Doc comments are lowered separately.\n-        .filter(|attr| attr.name() != doc)\n+        .filter(|attr| attr.path != \"doc\")\n         .map(|mut attr| {\n             // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n             // attribute. First normalize all inner attribute (#![..]) to outer"}, {"sha": "90ee19198c93984314330a19925a297ac9da6e1a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -54,7 +54,7 @@ use std::path::{Path, PathBuf};\n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -829,11 +829,10 @@ impl<'a> Visitor<'a> for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = Symbol::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {\n-        if attr.name() == doc {\n+        if attr.check_name(\"doc\") {\n             if let Some(val) = attr.value_str() {\n                 if attr.is_sugared_doc {\n                     result.push_str(&strip_doc_comment_decoration(&val.as_str()));"}, {"sha": "8528482c7856cfe5c56120e42369f37c08df4d8e", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n-        for item in attr.meta_item_list().unwrap_or(&[]) {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;"}, {"sha": "660fa647882aa1cbf5e20d6cf35edfd80c725ae3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -39,12 +39,11 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc::hir;\n \n+use std::{mem, slice, vec};\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::slice;\n use std::sync::Arc;\n use std::u32;\n-use std::mem;\n \n use core::DocContext;\n use doctree;\n@@ -472,22 +471,22 @@ impl Clean<Item> for doctree::Module {\n \n pub struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n-    current_list: slice::Iter<'a, ast::NestedMetaItem>,\n+    current_list: vec::IntoIter<ast::NestedMetaItem>,\n     name: &'a str\n }\n \n impl<'a> Iterator for ListAttributesIter<'a> {\n-    type Item = &'a ast::NestedMetaItem;\n+    type Item = ast::NestedMetaItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(nested) = self.current_list.next() {\n             return Some(nested);\n         }\n \n         for attr in &mut self.attrs {\n-            if let Some(ref list) = attr.meta_item_list() {\n+            if let Some(list) = attr.meta_item_list() {\n                 if attr.check_name(self.name) {\n-                    self.current_list = list.iter();\n+                    self.current_list = list.into_iter();\n                     if let Some(nested) = self.current_list.next() {\n                         return Some(nested);\n                     }\n@@ -508,7 +507,7 @@ impl AttributesExt for [ast::Attribute] {\n     fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n         ListAttributesIter {\n             attrs: self.iter(),\n-            current_list: [].iter(),\n+            current_list: Vec::new().into_iter(),\n             name: name\n         }\n     }\n@@ -519,7 +518,7 @@ pub trait NestedAttributesExt {\n     fn has_word(self, &str) -> bool;\n }\n \n-impl<'a, I: IntoIterator<Item=&'a ast::NestedMetaItem>> NestedAttributesExt for I {\n+impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n     fn has_word(self, word: &str) -> bool {\n         self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n     }\n@@ -2596,9 +2595,9 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n-                           attr::list_contains_name(l, \"hidden\"),\n+            a.name().unwrap() == \"doc\" && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n+                           attr::list_contains_name(&l, \"hidden\"),\n                 None => false,\n             }\n         });"}, {"sha": "130a4526bf7054beefc616ff0f22e41a28e6a0bd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -2620,11 +2620,11 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name();\n+        let name = attr.name().unwrap();\n         if !ATTRIBUTE_WHITELIST.contains(&&name.as_str()[..]) {\n             continue;\n         }\n-        if let Some(s) = render_attribute(attr.meta()) {\n+        if let Some(s) = render_attribute(&attr.meta().unwrap()) {\n             attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }"}, {"sha": "f6b7a07bdae01dafd7222e269b73f51876551173", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -137,13 +137,13 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n         attrs: Vec::new(),\n     };\n \n-    let attrs = krate.attrs.iter()\n-                     .filter(|a| a.check_name(\"doc\"))\n-                     .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l)\n-                     .filter(|a| a.check_name(\"test\"))\n-                     .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l);\n+    let test_attrs: Vec<_> = krate.attrs.iter()\n+        .filter(|a| a.check_name(\"doc\"))\n+        .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n+        .filter(|a| a.check_name(\"test\"))\n+        .collect();\n+    let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n+\n     for attr in attrs {\n         if attr.check_name(\"no_crate_inject\") {\n             opts.no_crate_inject = true;"}, {"sha": "4a909f8e2a9728c8117919d6cedc84104246e737", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if item.vis == hir::Public && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(list) if item.check_name(\"doc\") => {\n+                            Some(ref list) if item.check_name(\"doc\") => {\n                                 list.iter().any(|i| i.check_name(\"inline\"))\n                             }\n                             _ => false,"}, {"sha": "5deb91ef53aebc5dd03fec71a121ace52e0fd4c4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -116,6 +116,12 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl<'a> PartialEq<&'a str> for Path {\n+    fn eq(&self, string: &&'a str) -> bool {\n+        self.segments.len() == 1 && self.segments[0].identifier.name == *string\n+    }\n+}\n+\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"path({})\", pprust::path_to_string(self))\n@@ -1679,7 +1685,8 @@ pub struct AttrId(pub usize);\n pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: MetaItem,\n+    pub path: Path,\n+    pub tokens: TokenStream,\n     pub is_sugared_doc: bool,\n     pub span: Span,\n }"}, {"sha": "68f1f690a62f084ed644801ee99bfe8b0fafee14", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 269, "deletions": 37, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -15,20 +15,24 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Name};\n+use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n-use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n+use ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind};\n use codemap::{Spanned, spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::ParseSess;\n+use parse::parser::Parser;\n+use parse::{self, ParseSess, PResult};\n+use parse::token::{self, Token};\n use ptr::P;\n use symbol::Symbol;\n+use tokenstream::{TokenStream, TokenTree, Delimited};\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n+use std::iter;\n \n thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n@@ -185,26 +189,38 @@ impl NestedMetaItem {\n \n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n-        let matches = self.name() == name;\n+        let matches = self.path == name;\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n \n-    pub fn name(&self) -> Name { self.meta().name() }\n+    pub fn name(&self) -> Option<Name> {\n+        match self.path.segments.len() {\n+            1 => Some(self.path.segments[0].identifier.name),\n+            _ => None,\n+        }\n+    }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        self.meta().value_str()\n+        self.meta().and_then(|meta| meta.value_str())\n     }\n \n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        self.meta().meta_item_list()\n+    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match self.meta() {\n+            Some(MetaItem { node: MetaItemKind::List(list), .. }) => Some(list),\n+            _ => None\n+        }\n     }\n \n-    pub fn is_word(&self) -> bool { self.meta().is_word() }\n+    pub fn is_word(&self) -> bool {\n+        self.path.segments.len() == 1 && self.tokens.is_empty()\n+    }\n \n-    pub fn span(&self) -> Span { self.meta().span }\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n \n     pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n@@ -225,7 +241,7 @@ impl MetaItem {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n-                    ast::LitKind::Str(ref s, _) => Some((*s).clone()),\n+                    LitKind::Str(ref s, _) => Some((*s).clone()),\n                     _ => None,\n                 }\n             },\n@@ -264,8 +280,35 @@ impl MetaItem {\n \n impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    pub fn meta(&self) -> &MetaItem {\n-        &self.value\n+    pub fn meta(&self) -> Option<MetaItem> {\n+        let mut tokens = self.tokens.trees().peekable();\n+        Some(MetaItem {\n+            name: match self.path.segments.len() {\n+                1 => self.path.segments[0].identifier.name,\n+                _ => return None,\n+            },\n+            node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n+                if tokens.peek().is_some() {\n+                    return None;\n+                }\n+                node\n+            } else {\n+                return None;\n+            },\n+            span: self.span,\n+        })\n+    }\n+\n+    pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n+        if self.path.segments.len() > 1 {\n+            sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n+        }\n+\n+        Ok(MetaItem {\n+            name: self.path.segments.last().unwrap().identifier.name,\n+            node: Parser::new(sess, self.tokens.clone(), None, false).parse_meta_item_kind()?,\n+            span: self.span,\n+        })\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -293,7 +336,7 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n-    let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n+    let value_lit = dummy_spanned(LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n@@ -348,7 +391,8 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id: id,\n         style: ast::AttrStyle::Inner,\n-        value: item,\n+        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n     }\n@@ -365,7 +409,8 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id: id,\n         style: ast::AttrStyle::Outer,\n-        value: item,\n+        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n     }\n@@ -374,32 +419,25 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit = spanned(lo, hi, LitKind::Str(text, ast::StrStyle::Cooked));\n     Attribute {\n         id: id,\n         style: style,\n-        value: MetaItem {\n-            span: mk_sp(lo, hi),\n-            name: Symbol::intern(\"doc\"),\n-            node: MetaItemKind::NameValue(lit),\n-        },\n+        path: ast::Path::from_ident(mk_sp(lo, hi), ast::Ident::from_str(\"doc\")),\n+        tokens: MetaItemKind::NameValue(lit).tokens(mk_sp(lo, hi)),\n         is_sugared_doc: true,\n         span: mk_sp(lo, hi),\n     }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n-    debug!(\"attr::list_contains_name (name={})\", name);\n     items.iter().any(|item| {\n-        debug!(\"  testing: {:?}\", item.name());\n         item.check_name(name)\n     })\n }\n \n pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n-    debug!(\"attr::contains_name (name={})\", name);\n     attrs.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n         item.check_name(name)\n     })\n }\n@@ -452,8 +490,14 @@ pub enum InlineAttr {\n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        match attr.value.node {\n-            _ if attr.value.name != \"inline\" => ia,\n+        if attr.path != \"inline\" {\n+            return ia;\n+        }\n+        let meta = match attr.meta() {\n+            Some(meta) => meta.node,\n+            None => return ia,\n+        };\n+        match meta {\n             MetaItemKind::Word => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n@@ -574,14 +618,15 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n \n     'outer: for attr in attrs_iter {\n-        let tag = attr.name();\n-        if tag != \"rustc_deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n+        if attr.path != \"rustc_deprecated\" && attr.path != \"unstable\" && attr.path != \"stable\" {\n             continue // not a stability level\n         }\n \n         mark_used(attr);\n \n-        if let Some(metas) = attr.meta_item_list() {\n+        let meta = attr.meta();\n+        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n+            let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n@@ -596,7 +641,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             };\n \n-            match &*tag.as_str() {\n+            match &*meta.name.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -772,7 +817,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n     let mut depr: Option<Deprecation> = None;\n \n     'outer: for attr in attrs_iter {\n-        if attr.name() != \"deprecated\" {\n+        if attr.path != \"deprecated\" {\n             continue\n         }\n \n@@ -847,8 +892,8 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n /// structure layout, and `packed` to remove padding.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n-    match attr.value.node {\n-        ast::MetaItemKind::List(ref items) if attr.value.name == \"repr\" => {\n+    if attr.path == \"repr\" {\n+        if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n@@ -883,8 +928,6 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                 }\n             }\n         }\n-        // Not a \"repr\" hint: ignore.\n-        _ => { }\n     }\n     acc\n }\n@@ -931,6 +974,195 @@ impl IntType {\n     }\n }\n \n+impl MetaItem {\n+    fn tokens(&self) -> TokenStream {\n+        let ident = TokenTree::Token(self.span, Token::Ident(Ident::with_empty_ctxt(self.name)));\n+        TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        let (mut span, name) = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n+            _ => return None,\n+        };\n+        let node = match MetaItemKind::from_tokens(tokens) {\n+            Some(node) => node,\n+            _ => return None,\n+        };\n+        if let Some(last_span) = node.last_span() {\n+            span.hi = last_span.hi;\n+        }\n+        Some(MetaItem { name: name, span: span, node: node })\n+    }\n+}\n+\n+impl MetaItemKind {\n+    fn last_span(&self) -> Option<Span> {\n+        match *self {\n+            MetaItemKind::Word => None,\n+            MetaItemKind::List(ref list) => list.last().map(NestedMetaItem::span),\n+            MetaItemKind::NameValue(ref lit) => Some(lit.span),\n+        }\n+    }\n+\n+    pub fn tokens(&self, span: Span) -> TokenStream {\n+        match *self {\n+            MetaItemKind::Word => TokenStream::empty(),\n+            MetaItemKind::NameValue(ref lit) => {\n+                TokenStream::concat(vec![TokenTree::Token(span, Token::Eq).into(), lit.tokens()])\n+            }\n+            MetaItemKind::List(ref list) => {\n+                let mut tokens = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tokens.push(TokenTree::Token(span, Token::Comma).into());\n+                    }\n+                    tokens.push(item.node.tokens());\n+                }\n+                TokenTree::Delimited(span, Delimited {\n+                    delim: token::Paren,\n+                    tts: TokenStream::concat(tokens).into(),\n+                }).into()\n+            }\n+        }\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItemKind>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        let delimited = match tokens.peek().cloned() {\n+            Some(TokenTree::Token(_, token::Eq)) => {\n+                tokens.next();\n+                return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n+                    LitKind::from_token(token)\n+                        .map(|lit| MetaItemKind::NameValue(Spanned { node: lit, span: span }))\n+                } else {\n+                    None\n+                };\n+            }\n+            Some(TokenTree::Delimited(_, ref delimited)) if delimited.delim == token::Paren => {\n+                tokens.next();\n+                delimited.stream()\n+            }\n+            _ => return Some(MetaItemKind::Word),\n+        };\n+\n+        let mut tokens = delimited.into_trees().peekable();\n+        let mut result = Vec::new();\n+        while let Some(..) = tokens.peek() {\n+            match NestedMetaItemKind::from_tokens(&mut tokens) {\n+                Some(item) => result.push(Spanned { span: item.span(), node: item }),\n+                None => return None,\n+            }\n+            match tokens.next() {\n+                None | Some(TokenTree::Token(_, Token::Comma)) => {}\n+                _ => return None,\n+            }\n+        }\n+        Some(MetaItemKind::List(result))\n+    }\n+}\n+\n+impl NestedMetaItemKind {\n+    fn span(&self) -> Span {\n+        match *self {\n+            NestedMetaItemKind::MetaItem(ref item) => item.span,\n+            NestedMetaItemKind::Literal(ref lit) => lit.span,\n+        }\n+    }\n+\n+    fn tokens(&self) -> TokenStream {\n+        match *self {\n+            NestedMetaItemKind::MetaItem(ref item) => item.tokens(),\n+            NestedMetaItemKind::Literal(ref lit) => lit.tokens(),\n+        }\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItemKind>\n+        where I: Iterator<Item = TokenTree>,\n+    {\n+        if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n+            if let Some(node) = LitKind::from_token(token) {\n+                tokens.next();\n+                return Some(NestedMetaItemKind::Literal(Spanned { node: node, span: span }));\n+            }\n+        }\n+\n+        MetaItem::from_tokens(tokens).map(NestedMetaItemKind::MetaItem)\n+    }\n+}\n+\n+impl Lit {\n+    fn tokens(&self) -> TokenStream {\n+        TokenTree::Token(self.span, self.node.token()).into()\n+    }\n+}\n+\n+impl LitKind {\n+    fn token(&self) -> Token {\n+        use std::ascii;\n+\n+        match *self {\n+            LitKind::Str(string, ast::StrStyle::Cooked) => {\n+                let mut escaped = String::new();\n+                for ch in string.as_str().chars() {\n+                    escaped.extend(ch.escape_unicode());\n+                }\n+                Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n+            }\n+            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n+                Token::Literal(token::Lit::StrRaw(string, n), None)\n+            }\n+            LitKind::ByteStr(ref bytes) => {\n+                let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n+                    .map(Into::<char>::into).collect::<String>();\n+                Token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Byte(byte) => {\n+                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n+                Token::Literal(token::Lit::Byte(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Char(ch) => {\n+                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n+                Token::Literal(token::Lit::Char(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Int(n, ty) => {\n+                let suffix = match ty {\n+                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Unsuffixed => None,\n+                };\n+                Token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n+            }\n+            LitKind::Float(symbol, ty) => {\n+                Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n+            }\n+            LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n+            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(match value {\n+                true => \"true\",\n+                false => \"false\",\n+            }))),\n+        }\n+    }\n+\n+    fn from_token(token: Token) -> Option<LitKind> {\n+        match token {\n+            Token::Ident(ident) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n+            Token::Ident(ident) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n+            Token::Literal(lit, suf) => {\n+                let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n+                if suffix_illegal && suf.is_some() {\n+                    return None;\n+                }\n+                result\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;"}, {"sha": "2591a5766693fb686861881a05944478fde783e1", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -109,7 +109,8 @@ impl<'a> StripUnconfigured<'a> {\n                     self.process_cfg_attr(ast::Attribute {\n                         id: attr::mk_attr_id(),\n                         style: attr.style,\n-                        value: mi.clone(),\n+                        path: ast::Path::from_ident(mi.span, ast::Ident::with_empty_ctxt(mi.name)),\n+                        tokens: mi.node.tokens(mi.span),\n                         is_sugared_doc: false,\n                         span: mi.span,\n                     })\n@@ -132,8 +133,9 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = match attr.value.node {\n-                ast::MetaItemKind::List(ref mis) if is_cfg(&attr) => mis,\n+            let mis = attr.meta_item_list();\n+            let mis = match mis {\n+                Some(ref mis) if is_cfg(&attr) => mis,\n                 _ => return true\n             };\n "}, {"sha": "5b253635f257e5e5d37c7cb16d8d430d840c508d", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -18,7 +18,7 @@ use syntax_pos::Span;\n pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<(Symbol, Span)> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n-        if attr.name() != \"derive\" {\n+        if attr.path != \"derive\" {\n             return true;\n         }\n \n@@ -27,7 +27,7 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n             return false;\n         }\n \n-        let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n+        let traits = attr.meta_item_list().unwrap_or_else(Vec::new);\n         if traits.is_empty() {\n             cx.span_warn(attr.span, \"empty trait list in `derive`\");\n             return false;"}, {"sha": "c1095d34456820e9d60974a8fbcb611f8e83e46c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n                     let item = item\n-                        .map_attrs(|mut attrs| { attrs.retain(|a| a.name() != \"derive\"); attrs });\n+                        .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n                     let item_with_markers =\n                         add_derived_markers(&mut self.cx, &traits, item.clone());\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n@@ -380,7 +380,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = attr.name();\n+        let name = attr.path.segments[0].identifier.name;\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n@@ -392,33 +392,33 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let item = mac.expand(self.cx, attr.span, &attr.value, item);\n+                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                let item = mac.expand(self.cx, attr.span, &meta, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                mac.expand(self.cx, attr.span, &attr.value, &item,\n-                           &mut |item| items.push(item));\n+                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = stream_for_attr_args(&attr, &self.cx.parse_sess);\n                 let item_toks = stream_for_item(&item, &self.cx.parse_sess);\n \n                 let span = Span {\n                     expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            format: MacroAttribute(name),\n+                            format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n                             span: None,\n                             allow_internal_unstable: false,\n                         },\n                     }),\n                     ..attr.span\n                 };\n \n-                let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n+                let tok_result = mac.expand(self.cx, attr.span, attr.tokens.clone(), item_toks);\n                 self.parse_expansion(tok_result, kind, name, span)\n             }\n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n@@ -784,32 +784,6 @@ fn stream_for_item(item: &Annotatable, parse_sess: &ParseSess) -> TokenStream {\n     string_to_stream(text, parse_sess)\n }\n \n-fn stream_for_attr_args(attr: &ast::Attribute, parse_sess: &ParseSess) -> TokenStream {\n-    use ast::MetaItemKind::*;\n-    use print::pp::Breaks;\n-    use print::pprust::PrintState;\n-\n-    let token_string = match attr.value.node {\n-        // For `#[foo]`, an empty token\n-        Word => return TokenStream::empty(),\n-        // For `#[foo(bar, baz)]`, returns `(bar, baz)`\n-        List(ref items) => pprust::to_string(|s| {\n-            s.popen()?;\n-            s.commasep(Breaks::Consistent,\n-                       &items[..],\n-                       |s, i| s.print_meta_list_item(&i))?;\n-            s.pclose()\n-        }),\n-        // For `#[foo = \"bar\"]`, returns `= \"bar\"`\n-        NameValue(ref lit) => pprust::to_string(|s| {\n-            s.word_space(\"=\")?;\n-            s.print_literal(lit)\n-        }),\n-    };\n-\n-    string_to_stream(token_string, parse_sess)\n-}\n-\n fn string_to_stream(text: String, parse_sess: &ParseSess) -> TokenStream {\n     let filename = String::from(\"<macro expansion>\");\n     filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, None, text))"}, {"sha": "10b7249743b8c49762cf2cc38d9dd672a0a8a618", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -220,16 +220,24 @@ pub mod rt {\n     }\n \n     impl ToTokens for ast::Attribute {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             let mut r = vec![];\n             // FIXME: The spans could be better\n             r.push(TokenTree::Token(self.span, token::Pound));\n             if self.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n+            let mut inner = Vec::new();\n+            for (i, segment) in self.path.segments.iter().enumerate() {\n+                if i > 0 {\n+                    inner.push(TokenTree::Token(self.span, token::Colon).into());\n+                }\n+                inner.push(TokenTree::Token(self.span, token::Ident(segment.identifier)).into());\n+            }\n+            inner.push(self.tokens.clone());\n+\n             r.push(TokenTree::Delimited(self.span, tokenstream::Delimited {\n-                delim: token::Bracket,\n-                tts: self.value.to_tokens(cx).into_iter().collect::<TokenStream>().into(),\n+                delim: token::Bracket, tts: TokenStream::concat(inner).into()\n             }));\n             r\n         }"}, {"sha": "2c3ad98a6be63c7db4e2f358636e19fce93be0e4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -859,35 +859,34 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = &*attr.name().as_str();\n+        let name = unwrap_or!(attr.name(), return);\n+\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n-            if n == name {\n+            if name == n {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n-                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", name, ty, gateage);\n+                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n                 return;\n             }\n         }\n         for &(ref n, ref ty) in self.plugin_attributes {\n-            if n == name {\n+            if attr.path == &**n {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below\n-                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", name, ty);\n+                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n                 return;\n             }\n         }\n-        if name.starts_with(\"rustc_\") {\n+        if name.as_str().starts_with(\"rustc_\") {\n             gate_feature!(self, rustc_attrs, attr.span,\n                           \"unless otherwise specified, attributes \\\n                            with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\");\n-        } else if name.starts_with(\"derive_\") {\n+        } else if name.as_str().starts_with(\"derive_\") {\n             gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n-        } else if attr::is_known(attr) {\n-            debug!(\"check_attribute: {:?} is known\", name);\n-        } else {\n+        } else if !attr::is_known(attr) {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n             // before the plugin attributes are registered\n@@ -898,7 +897,7 @@ impl<'a> Context<'a> {\n                                         unknown to the compiler and \\\n                                         may have meaning \\\n                                         added to it in the future\",\n-                                       name));\n+                                       attr.path));\n             }\n         }\n     }\n@@ -1097,7 +1096,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n-        if contains_novel_literal(&attr.value) {\n+        let meta = panictry!(attr.parse_meta(&self.context.parse_sess));\n+        if contains_novel_literal(&meta) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n                                literals in top-level positions, are experimental\");\n@@ -1160,8 +1160,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                                        `#[repr(simd)]` instead\");\n                 }\n                 for attr in &i.attrs {\n-                    if attr.name() == \"repr\" {\n-                        for item in attr.meta_item_list().unwrap_or(&[]) {\n+                    if attr.path == \"repr\" {\n+                        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                             if item.check_name(\"simd\") {\n                                 gate_feature_post!(&self, repr_simd, i.span,\n                                                    \"SIMD types are experimental \\"}, {"sha": "903dac1f379cafcad47549b8fd0bad27b1bf1347", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -488,7 +488,8 @@ pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<At\n     Some(Attribute {\n         id: attr.id,\n         style: attr.style,\n-        value: fld.fold_meta_item(attr.value),\n+        path: fld.fold_path(attr.path),\n+        tokens: fld.fold_tts(attr.tokens),\n         is_sugared_doc: attr.is_sugared_doc,\n         span: fld.new_span(attr.span),\n     })\n@@ -611,7 +612,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n         token::NtIdent(id) => token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}),\n-        token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n+        token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n@@ -1369,7 +1370,7 @@ mod tests {\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n-            \"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n+            \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n     }\n \n     // even inside macro defs...."}, {"sha": "4c9a5d512af0236d13e73f27e70ae9fecd5dff58", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -65,6 +65,16 @@ macro_rules! panictry {\n     })\n }\n \n+#[macro_export]\n+macro_rules! unwrap_or {\n+    ($opt:expr, $default:expr) => {\n+        match $opt {\n+            Some(x) => x,\n+            None => $default,\n+        }\n+    }\n+}\n+\n #[macro_use]\n pub mod diagnostics {\n     #[macro_use]"}, {"sha": "272cff7ad34b2818b82a6dff1f49ea86da0da525", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -143,7 +143,8 @@ impl<'a> Parser<'a> {\n         Ok(ast::Attribute {\n             id: attr::mk_attr_id(),\n             style: style,\n-            value: value,\n+            path: ast::Path::from_ident(value.span, ast::Ident::with_empty_ctxt(value.name)),\n+            tokens: value.node.tokens(value.span),\n             is_sugared_doc: false,\n             span: span,\n         })\n@@ -221,15 +222,20 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         let ident = self.parse_ident()?;\n-        let node = if self.eat(&token::Eq) {\n+        let node = self.parse_meta_item_kind()?;\n+        let hi = self.prev_span.hi;\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+    }\n+\n+    pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n+        Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n         } else if self.token == token::OpenDelim(token::Paren) {\n             ast::MetaItemKind::List(self.parse_meta_seq()?)\n         } else {\n+            self.eat(&token::OpenDelim(token::Paren));\n             ast::MetaItemKind::Word\n-        };\n-        let hi = self.prev_span.hi;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+        })\n     }\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;"}, {"sha": "2bdd3938d6bd58446ebd6f39857be5ac91ecf9ac", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 91, "deletions": 40, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -374,38 +374,80 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, sd: &Handler, sp: Span)\n-                      -> ast::LitKind {\n+macro_rules! err {\n+    ($opt_diag:expr, |$span:ident, $diag:ident| $($body:tt)*) => {\n+        match $opt_diag {\n+            Some(($span, $diag)) => { $($body)* }\n+            None => return None,\n+        }\n+    }\n+}\n+\n+pub fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                 -> (bool /* suffix illegal? */, Option<ast::LitKind>) {\n+    use ast::LitKind;\n+\n+    match lit {\n+       token::Byte(i) => (true, Some(LitKind::Byte(byte_lit(&i.as_str()).0))),\n+       token::Char(i) => (true, Some(LitKind::Char(char_lit(&i.as_str()).0))),\n+\n+        // There are some valid suffixes for integer and float literals,\n+        // so all the handling is done internally.\n+        token::Integer(s) => (false, integer_lit(&s.as_str(), suf, diag)),\n+        token::Float(s) => (false, float_lit(&s.as_str(), suf, diag)),\n+\n+        token::Str_(s) => {\n+            let s = Symbol::intern(&str_lit(&s.as_str()));\n+            (true, Some(LitKind::Str(s, ast::StrStyle::Cooked)))\n+        }\n+        token::StrRaw(s, n) => {\n+            let s = Symbol::intern(&raw_str_lit(&s.as_str()));\n+            (true, Some(LitKind::Str(s, ast::StrStyle::Raw(n))))\n+        }\n+        token::ByteStr(i) => {\n+            (true, Some(LitKind::ByteStr(byte_str_lit(&i.as_str()))))\n+        }\n+        token::ByteStrRaw(i, _) => {\n+            (true, Some(LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))))\n+        }\n+    }\n+}\n+\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                      -> Option<ast::LitKind> {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     let suffix = match suffix {\n         Some(suffix) => suffix,\n-        None => return ast::LitKind::FloatUnsuffixed(data),\n+        None => return Some(ast::LitKind::FloatUnsuffixed(data)),\n     };\n \n-    match &*suffix.as_str() {\n+    Some(match &*suffix.as_str() {\n         \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n         \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n         suf => {\n-            if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n-                // if it looks like a width, lets try to be helpful.\n-                sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n-                 .help(\"valid widths are 32 and 64\")\n-                 .emit();\n-            } else {\n-                sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf))\n-                  .help(\"valid suffixes are `f32` and `f64`\")\n-                  .emit();\n-            }\n+            err!(diag, |span, diag| {\n+                if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n+                    // if it looks like a width, lets try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    diag.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit()\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    diag.struct_span_err(span, &msg)\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            });\n \n             ast::LitKind::FloatUnsuffixed(data)\n         }\n-    }\n+    })\n }\n-pub fn float_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                 -> Option<ast::LitKind> {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    filtered_float_lit(Symbol::intern(&s), suffix, sd, sp)\n+    filtered_float_lit(Symbol::intern(&s), suffix, diag)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -500,7 +542,8 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                   -> Option<ast::LitKind> {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -524,13 +567,16 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     // 1f64 and 2f32 etc. are valid float literals.\n     if let Some(suf) = suffix {\n         if looks_like_width_suffix(&['f'], &suf.as_str()) {\n-            match base {\n-                16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n-                8 => sd.span_err(sp, \"octal float literal is not supported\"),\n-                2 => sd.span_err(sp, \"binary float literal is not supported\"),\n-                _ => ()\n+            let err = match base {\n+                16 => Some(\"hexadecimal float literal is not supported\"),\n+                8 => Some(\"octal float literal is not supported\"),\n+                2 => Some(\"binary float literal is not supported\"),\n+                _ => None,\n+            };\n+            if let Some(err) = err {\n+                err!(diag, |span, diag| diag.span_err(span, err));\n             }\n-            return filtered_float_lit(Symbol::intern(&s), Some(suf), sd, sp)\n+            return filtered_float_lit(Symbol::intern(&s), Some(suf), diag)\n         }\n     }\n \n@@ -539,7 +585,9 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     }\n \n     if let Some(suf) = suffix {\n-        if suf.as_str().is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        if suf.as_str().is_empty() {\n+            err!(diag, |span, diag| diag.span_bug(span, \"found empty literal suffix in Some\"));\n+        }\n         ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n@@ -556,17 +604,20 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n             suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n-                if looks_like_width_suffix(&['i', 'u'], suf) {\n-                    sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n-                                             &suf[1..]))\n-                      .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                      .emit();\n-                } else {\n-                    sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n-                      .help(\"the suffix must be one of the integral types \\\n-                             (`u32`, `isize`, etc)\")\n-                      .emit();\n-                }\n+                err!(diag, |span, diag| {\n+                    if looks_like_width_suffix(&['i', 'u'], suf) {\n+                        let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                        diag.struct_span_err(span, &msg)\n+                            .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                            .emit();\n+                    } else {\n+                        let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n+                        diag.struct_span_err(span, &msg)\n+                            .help(\"the suffix must be one of the integral types \\\n+                                   (`u32`, `isize`, etc)\")\n+                            .emit();\n+                    }\n+                });\n \n                 ty\n             }\n@@ -576,7 +627,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    match u128::from_str_radix(s, base) {\n+    Some(match u128::from_str_radix(s, base) {\n         Ok(r) => ast::LitKind::Int(r, ty),\n         Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string\n@@ -588,11 +639,11 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n                 s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n \n             if !already_errored {\n-                sd.span_err(sp, \"int literal is too large\");\n+                err!(diag, |span, diag| diag.span_err(span, \"int literal is too large\"));\n             }\n             ast::LitKind::Int(0, ty)\n         }\n-    }\n+    })\n }\n \n #[cfg(test)]\n@@ -957,7 +1008,7 @@ mod tests {\n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| a.name() == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| a.path == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);"}, {"sha": "ed512b899877d8996434efc8d33b8d0265544e30", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -60,7 +60,6 @@ use util::ThinVec;\n use std::collections::HashSet;\n use std::{cmp, mem, slice};\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -1643,44 +1642,15 @@ impl<'a> Parser<'a> {\n                 _ => { return self.unexpected_last(&self.token); }\n             },\n             token::Literal(lit, suf) => {\n-                let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitKind::Byte(parse::byte_lit(&i.as_str()).0)),\n-                    token::Char(i) => (true, LitKind::Char(parse::char_lit(&i.as_str()).0)),\n-\n-                    // there are some valid suffixes for integer and\n-                    // float literals, so all the handling is done\n-                    // internally.\n-                    token::Integer(s) => {\n-                        let diag = &self.sess.span_diagnostic;\n-                        (false, parse::integer_lit(&s.as_str(), suf, diag, self.span))\n-                    }\n-                    token::Float(s) => {\n-                        let diag = &self.sess.span_diagnostic;\n-                        (false, parse::float_lit(&s.as_str(), suf, diag, self.span))\n-                    }\n-\n-                    token::Str_(s) => {\n-                        let s = Symbol::intern(&parse::str_lit(&s.as_str()));\n-                        (true, LitKind::Str(s, ast::StrStyle::Cooked))\n-                    }\n-                    token::StrRaw(s, n) => {\n-                        let s = Symbol::intern(&parse::raw_str_lit(&s.as_str()));\n-                        (true, LitKind::Str(s, ast::StrStyle::Raw(n)))\n-                    }\n-                    token::ByteStr(i) => {\n-                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str())))\n-                    }\n-                    token::ByteStrRaw(i, _) => {\n-                        (true, LitKind::ByteStr(Rc::new(i.to_string().into_bytes())))\n-                    }\n-                };\n+                let diag = Some((self.span, &self.sess.span_diagnostic));\n+                let (suffix_illegal, result) = parse::lit_token(lit, suf, diag);\n \n                 if suffix_illegal {\n                     let sp = self.span;\n                     self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n                 }\n \n-                out\n+                result.unwrap()\n             }\n             _ => { return self.unexpected_last(&self.token); }\n         };\n@@ -5135,11 +5105,9 @@ impl<'a> Parser<'a> {\n                     let attr = ast::Attribute {\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n-                        value: ast::MetaItem {\n-                            name: Symbol::intern(\"warn_directory_ownership\"),\n-                            node: ast::MetaItemKind::Word,\n-                            span: syntax_pos::DUMMY_SP,\n-                        },\n+                        path: ast::Path::from_ident(syntax_pos::DUMMY_SP,\n+                                                    Ident::from_str(\"warn_directory_ownership\")),\n+                        tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n                         span: syntax_pos::DUMMY_SP,\n                     };"}, {"sha": "3837700457290b268ea1209265b500ec734a4ffd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -17,7 +17,7 @@ pub use self::Token::*;\n use ast::{self};\n use ptr::P;\n use symbol::keywords;\n-use tokenstream;\n+use tokenstream::TokenTree;\n \n use std::fmt;\n use std::rc::Rc;\n@@ -348,7 +348,7 @@ pub enum Nonterminal {\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n-    NtTT(tokenstream::TokenTree),\n+    NtTT(TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n     NtImplItem(ast::ImplItem),"}, {"sha": "d8af95d8d30625219c3c0a2384e72b17eebdb68c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -28,7 +28,7 @@ use ptr::P;\n use std_inject;\n use symbol::{Symbol, keywords};\n use syntax_pos::DUMMY_SP;\n-use tokenstream::{self, TokenTree};\n+use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n use std::io::{self, Write, Read};\n@@ -329,6 +329,10 @@ pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String {\n     to_string(|s| s.print_tts(tts.iter().cloned().collect()))\n }\n \n+pub fn tokens_to_string(tokens: TokenStream) -> String {\n+    to_string(|s| s.print_tts(tokens))\n+}\n+\n pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n     to_string(|s| s.print_stmt(stmt))\n }\n@@ -750,7 +754,21 @@ pub trait PrintState<'a> {\n                 ast::AttrStyle::Inner => word(self.writer(), \"#![\")?,\n                 ast::AttrStyle::Outer => word(self.writer(), \"#[\")?,\n             }\n-            self.print_meta_item(&attr.meta())?;\n+            if let Some(mi) = attr.meta() {\n+                self.print_meta_item(&mi)?\n+            } else {\n+                for (i, segment) in attr.path.segments.iter().enumerate() {\n+                    if i > 0 {\n+                        word(self.writer(), \"::\")?\n+                    }\n+                    if segment.identifier.name != keywords::CrateRoot.name() &&\n+                       segment.identifier.name != \"$crate\" {\n+                        word(self.writer(), &segment.identifier.name.as_str())?;\n+                    }\n+                }\n+                space(self.writer())?;\n+                self.print_tts(attr.tokens.clone())?;\n+            }\n             word(self.writer(), \"]\")\n         }\n     }\n@@ -789,6 +807,45 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n+    /// This doesn't deserve to be called \"pretty\" printing, but it should be\n+    /// meaning-preserving. A quick hack that might help would be to look at the\n+    /// spans embedded in the TTs to decide where to put spaces and newlines.\n+    /// But it'd be better to parse these according to the grammar of the\n+    /// appropriate macro, transcribe back into the grammar we just parsed from,\n+    /// and then pretty-print the resulting AST nodes (so, e.g., we print\n+    /// expression arguments as expressions). It can be done! I think.\n+    fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n+        match tt {\n+            TokenTree::Token(_, ref tk) => {\n+                word(self.writer(), &token_to_string(tk))?;\n+                match *tk {\n+                    parse::token::DocComment(..) => {\n+                        hardbreak(self.writer())\n+                    }\n+                    _ => Ok(())\n+                }\n+            }\n+            TokenTree::Delimited(_, ref delimed) => {\n+                word(self.writer(), &token_to_string(&delimed.open_token()))?;\n+                space(self.writer())?;\n+                self.print_tts(delimed.stream())?;\n+                space(self.writer())?;\n+                word(self.writer(), &token_to_string(&delimed.close_token()))\n+            },\n+        }\n+    }\n+\n+    fn print_tts(&mut self, tts: tokenstream::TokenStream) -> io::Result<()> {\n+        self.ibox(0)?;\n+        for (i, tt) in tts.into_trees().enumerate() {\n+            if i != 0 {\n+                space(self.writer())?;\n+            }\n+            self.print_tt(tt)?;\n+        }\n+        self.end()\n+    }\n+\n     fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() { space(self.writer())?; }\n         Ok(())\n@@ -1458,45 +1515,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    /// This doesn't deserve to be called \"pretty\" printing, but it should be\n-    /// meaning-preserving. A quick hack that might help would be to look at the\n-    /// spans embedded in the TTs to decide where to put spaces and newlines.\n-    /// But it'd be better to parse these according to the grammar of the\n-    /// appropriate macro, transcribe back into the grammar we just parsed from,\n-    /// and then pretty-print the resulting AST nodes (so, e.g., we print\n-    /// expression arguments as expressions). It can be done! I think.\n-    pub fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n-        match tt {\n-            TokenTree::Token(_, ref tk) => {\n-                word(&mut self.s, &token_to_string(tk))?;\n-                match *tk {\n-                    parse::token::DocComment(..) => {\n-                        hardbreak(&mut self.s)\n-                    }\n-                    _ => Ok(())\n-                }\n-            }\n-            TokenTree::Delimited(_, ref delimed) => {\n-                word(&mut self.s, &token_to_string(&delimed.open_token()))?;\n-                space(&mut self.s)?;\n-                self.print_tts(delimed.stream())?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, &token_to_string(&delimed.close_token()))\n-            },\n-        }\n-    }\n-\n-    pub fn print_tts(&mut self, tts: tokenstream::TokenStream) -> io::Result<()> {\n-        self.ibox(0)?;\n-        for (i, tt) in tts.into_trees().enumerate() {\n-            if i != 0 {\n-                space(&mut self.s)?;\n-            }\n-            self.print_tt(tt)?;\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n         let generics = ast::Generics::default();"}, {"sha": "94954e2c4298065d9f73acfe4b45bb4ef4c42678", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -15,6 +15,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n use parse::ParseSess;\n use ptr::P;\n+use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n@@ -70,11 +71,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n-            value: ast::MetaItem {\n-                name: Symbol::intern(\"prelude_import\"),\n-                node: ast::MetaItemKind::Word,\n-                span: span,\n-            },\n+            path: ast::Path::from_ident(span, ast::Ident::from_str(\"prelude_import\")),\n+            tokens: TokenStream::empty(),\n             id: attr::mk_attr_id(),\n             is_sugared_doc: false,\n             span: span,"}, {"sha": "35e4d9eb68aeaa4d9c992dde123854ce4d6de1bd", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -360,7 +360,7 @@ impl PartialEq<ThinTokenStream> for ThinTokenStream {\n \n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(&pprust::tts_to_string(&self.trees().collect::<Vec<_>>()))\n+        f.write_str(&pprust::tokens_to_string(self.clone()))\n     }\n }\n "}, {"sha": "b01ef65e5fe5ed41611cce78fe34c554b6d135c7", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -23,9 +23,11 @@ struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        if self.0.contains(&attr.name()) {\n-            mark_used(attr);\n-            mark_known(attr);\n+        if let Some(name) = attr.name() {\n+            if self.0.contains(&name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n         }\n     }\n "}, {"sha": "48e7ff0d24370a9bb3bbbb0330a21e47f4a3b598", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -439,7 +439,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        match &*a.name().as_str() {\n+                        a.name().is_some() && match &*a.name().unwrap().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }"}, {"sha": "2d815b3f1bb7d9957afa1e9f2cbcd28acf9f07ac", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c1cc68b44bb987ec57251bc457a55292515d1d/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=68c1cc68b44bb987ec57251bc457a55292515d1d", "patch": "@@ -248,7 +248,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.node {\n             if self.is_proc_macro_crate &&\n-               item.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+               item.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(item.span, msg);\n@@ -270,12 +270,12 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         for attr in &item.attrs {\n             if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n-                    let msg = if attr.name() == prev_attr.name() {\n+                    let msg = if attr.path == prev_attr.path {\n                         format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n-                                attr.name())\n+                                attr.path)\n                     } else {\n                         format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n-                                to the same function\", attr.name(), prev_attr.name())\n+                                to the same function\", attr.path, prev_attr.path)\n                     };\n \n                     self.handler.struct_span_err(attr.span(), &msg)\n@@ -299,7 +299,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         if !is_fn {\n             let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n-                              attr.name());\n+                              attr.path);\n \n             self.handler.span_err(attr.span(), &msg);\n             return;\n@@ -311,7 +311,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         if !self.is_proc_macro_crate {\n             let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n-                              `proc-macro` crate type\", attr.name());\n+                              `proc-macro` crate type\", attr.path);\n \n             self.handler.span_err(attr.span(), &msg);\n             return;"}]}