{"sha": "4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NzBkY2UzZWJmZDBlOTg4YTJlNDUzNjBjNzI0ZWJlOTEyYzNhZDU=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-25T18:45:44Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-25T18:45:44Z"}, "message": "Merge remote-tracking branch 'upstream/io' into io\n\nConflicts:\n\tsrc/rt/rustrt.def.in", "tree": {"sha": "c676e677bf36924cbf177b0723b4ffe0fc435d40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c676e677bf36924cbf177b0723b4ffe0fc435d40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "html_url": "https://github.com/rust-lang/rust/commit/4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/comments", "author": null, "committer": null, "parents": [{"sha": "794923c99511398bc90400e380dd11770ec8e614", "url": "https://api.github.com/repos/rust-lang/rust/commits/794923c99511398bc90400e380dd11770ec8e614", "html_url": "https://github.com/rust-lang/rust/commit/794923c99511398bc90400e380dd11770ec8e614"}, {"sha": "e65d0cbabebc73f2c9733a7ed158576c9702e71e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65d0cbabebc73f2c9733a7ed158576c9702e71e", "html_url": "https://github.com/rust-lang/rust/commit/e65d0cbabebc73f2c9733a7ed158576c9702e71e"}], "stats": {"total": 10446, "additions": 5078, "deletions": 5368}, "files": [{"sha": "baae56c4f4093a816827438ad033eb8fb1ab2384", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -111,7 +111,7 @@ ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += --save-temps\n endif\n ifdef ASM_COMMENTS\n-  CFG_RUSTC_FLAGS += -z asm-comments\n+  CFG_RUSTC_FLAGS += -Z asm-comments\n endif\n ifdef TIME_PASSES\n   CFG_RUSTC_FLAGS += -Z time-passes\n@@ -208,7 +208,6 @@ CFG_STDLIB_$(1) :=$(call CFG_LIB_NAME_$(1),std)\n CFG_EXTRALIB_$(1) :=$(call CFG_LIB_NAME_$(1),extra)\n CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n-CFG_LIBFUZZER_$(1) :=$(call CFG_LIB_NAME_$(1),fuzzer)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n@@ -218,7 +217,6 @@ EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n-LIBFUZZER_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),fuzzer)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n@@ -227,7 +225,6 @@ EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n-LIBFUZZER_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),fuzzer)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n@@ -402,12 +399,10 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n # Prerequisites for a working stageN compiler and libraries, for a specific target\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/fuzzer$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rust$$(X_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBFUZZER_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n@@ -416,7 +411,6 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBFUZZER_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\"}, {"sha": "d099b1336dfd61a1f968ea26697708b6426c58cc", "filename": "RELEASES.txt", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -4,36 +4,90 @@ Version 0.7 (July 2013)\n    * ??? changes, numerous bugfixes\n \n    * Syntax changes\n-      * `#[deriving(Encodable)]`, `#[deriving(Decodable)]`\n+      * `use mod` is no longer valid.\n+      * `fail!` and `assert!` accept `~str`, `&'static str` or `fmt!`-style\n+        argument list.\n+      * `Encodable`, `Decodable`, `TotalOrd`, `TotalEq`, `DeepClone` can all\n+        be automatically derived with `#[deriving(...)]`.\n+      * The `Durable` trait is replaced with the `'static` bounds.\n+      * At long last, 'argument modes' no longer exist.\n+      * The `bytes!` macro returns a vector of bytes for string, u8, char,\n+        and unsuffixed integer literals.\n \n    * Semantic changes\n+      * The borrow checker has been rewritten with flow-sensitivity, fixing\n+        many bugs and inconveniences.\n       * The `self` parameter no longer implicitly means `&'self self`,\n         and can be explicitly marked with a lifetime.\n       * Structs with the `#[packed]` attribute have byte alignment and\n         no padding between fields.\n+      * The `for` loop protocol now requires `for`-iterators to return `bool`\n+        so they compose better.\n+      * `Option<~T>` is now represented as a nullable pointer.\n+      * `@mut` does dynamic borrow checks correctly.\n+      * Macros TODO\n+      * The `main` function is only detected at the topmost level of the crate.\n+        The `#[main]` attribute is still valid anywhere.\n+      * Struct fields may no longer be mutable. Use inherited mutability.\n+      * The `#[non_owned]` attribute makes a type that would otherwise be\n+        `Owned`, not. TODO this may change to non_send before 0.7\n+      * The `#[mutable]` attribute makes a type that would otherwise be\n+        `Const`, note. TODO this may change to non_freeze before 0.7\n+      * Unbounded recursion will abort the process after reaching the limit\n+        specified by the `RUST_MAX_STACK` environment variable.\n+      * The `vecs_implicitly_copyable` lint mode has been removed. Vectors\n+        are never implicitly copyable.\n \n    * Libraries\n-\n-      **Note: in 0.7 `core` was renamed `std` and `std` to `extra.\n-        These notes use the new crate names.**\n-\n       * The `core` crate was renamed to `std`.\n       * The `std` crate was renamed to `extra`.\n       * `std::mut` removed.\n+      * std: The prelude no longer reexports any modules, only types and traits.\n+      * std: Prelude additions: `print`, `println`, `FromStr`, `ApproxEq`, `Equiv`,\n+        `Iterator`, `IteratorUtil`, many numeric traits, many tuple traits.\n       * std: `iterator` module for external iterator objects.\n+      * std: new numeric traits: `Fractional`, `Real`, `RealExt`, `Integer`, `Ratio`,\n+        `Algebraic`, `Trigonometric`, `Exponential`, `Primitive`.\n+      * std: Tuple traits and accessors defined for up to 12-tuples, e.g.\n+        `(0, 1, 2).n2()` or `(0, 1, 2).n2_ref()`.\n       * std: many types implement `Clone` - tuples, @, @mut. TODO\n       * std: `path` type renamed to `Path`.\n       * std: Many standalone functions removed in favor of methods in\n-        `vec`, `str`, TODO. In the future methods will also work as functions.\n+        `vec`, `str`. In the future methods will also work as functions.\n+      * std: `reinterpret_cast` removed. Used `transmute`.\n+      * std: ascii string handling in `std::ascii`.\n+      * std: `Rand` is implemented for ~/@.\n+      * std: `run` module for spawning processes overhauled.\n+      * std: Various atomic types added to `unstable::atomic`.\n+      * std: `LinearMap` and `LinearSet` renamed to `HashMap` and `HashSet`.\n+      * std: Added `os::mkdir_recursive`.\n+      * std: Added `os::glob` function performs filesystems globs.\n+      * std: `FuzzyEq` renamed to `ApproxEq`.\n+      * std: `Map` now defines `pop` and `swap` methods.\n+      * extra: `flate` module moved from `std` to `extra`.\n       * extra: `FileInput` implements `std::io::Reader`.\n       * extra: `Complex` number type and `complex` module.\n       * extra: `Rational` number type and `rational` module.\n       * extra: `BigInt`, `BigUint` implement numeric and comparison traits.\n+      * extra: `term` uses terminfo now, is more correct.\n \n-   * Other\n+   * Tooling\n       * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks.\n-      * More and improved library documentation.\n+      * `unused_mut` lint mode for identifying unused `mut` qualifiers.\n       * The `rusti` command has been rewritten and a number of bugs addressed.\n+      * rustc outputs in color on more terminals.\n+      * rustc accepts a `--link-args` flag to pass arguments to the linker.\n+      * rustc accepts a `-Z print-link-args` flag for debugging linkage.\n+      * Compiling with `-g` will make the binary record information about\n+        dynamic borrowcheck failures for debugging.\n+      * rustdoc has a nicer stylesheet.\n+      * Various improvements to rustdoc.\n+\n+   * Other\n+      * More and improved library documentation.\n+      * Various improvements on ARM and Android.\n+      * Various improvements to MIPS backend.\n+      * jemalloc is the Rust allocator.\n \n Version 0.6 (April 2013)\n ------------------------"}, {"sha": "ed9ea446aa87e38e5842dfc29c0f180d45b053ac", "filename": "doc/rust.css", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -12,41 +12,38 @@ body {\n }\n \n h1 {\n-    font-size: 20pt;\n-    margin-top: 2em;\n+    font-size: 24pt;\n+    margin-top: 1.6em;\n     padding-left: 0.4em;\n     line-height: 1.6em;\n     background-color:#FFF2CE;\n     border-radius: 0.2em;\n-    border: 1px solid rgba(0, 0, 0, 0.15);\n }\n \n h2 {\n-    font-size: 15pt;\n-    margin-top: 2em;\n-    padding-left: 0.4em;\n+    font-size: 16pt;\n+    margin-top: 1.6em;\n+    padding: 0.2em 0.5em;\n     background-color:#FFF2CE;\n     border-radius: 0.4em;\n-    border: 1px solid rgba(0, 0, 0, 0.15);\n }\n \n h2 code {\n     color: #097334;\n-    font-size: 15pt;\n+    font-size: 16pt;\n }\n \n h3 {\n-    font-size: 13pt;\n+    font-size: 14pt;\n     color: black;\n     background-color:#D9E7FF;\n     border-radius: 0.4em;\n-    border: 1px solid rgba(0, 0, 0, 0.15);\n-    padding: 0 0.4em 0 0.4em;\n+    padding: 0.2em 0.5em;\n }\n \n h3 code {\n     color: #541800;\n-    font-size: 13pt;\n+    font-size: 14pt;\n     font-style: italic;\n }\n "}, {"sha": "9edbc44d6c21df1e530190c6cffd42bb86d7ddaa", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -2826,7 +2826,7 @@ Within the body of an item that has type parameter declarations, the names of it\n ~~~~~~~\n fn map<A: Copy, B: Copy>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n-   let first: B = f(xs[0]);\n+   let first: B = f(copy xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n    return ~[first] + rest;\n }"}, {"sha": "2e3ce40c9f7dcb2e5da22fd6c4621bb65eda89aa", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -359,7 +359,7 @@ fn pnorm(nums: &~[float], p: uint) -> float {\n \n fn main() {\n     let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n-    println(fmt!(\"Inf-norm = %?\",  numbers.max()));\n+    println(fmt!(\"Inf-norm = %?\",  *numbers.iter().max().unwrap()));\n \n     let numbers_arc = ARC(numbers);\n "}, {"sha": "f69f569faee43cc14869ddd6b21039b44b0c48ab", "filename": "doc/tutorial.md", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1941,12 +1941,14 @@ fn head_bad<T>(v: &[T]) -> T {\n ~~~~\n \n However, we can tell the compiler that the `head` function is only for\n-copyable types: that is, those that have the `Copy` trait.\n+copyable types: that is, those that have the `Copy` trait. In that\n+case, we can explicitly create a second copy of the value we are\n+returning using the `copy` keyword:\n \n ~~~~\n // This does\n fn head<T: Copy>(v: &[T]) -> T {\n-    v[0]\n+    copy v[0]\n }\n ~~~~\n \n@@ -2039,17 +2041,12 @@ themselves contain type parameters. A trait for generalized sequence\n types might look like the following:\n \n ~~~~\n-# use std::vec;\n trait Seq<T> {\n-    fn len(&self) -> uint;\n-    fn iter(&self, b: &fn(v: &T));\n+    fn length(&self) -> uint;\n }\n \n impl<T> Seq<T> for ~[T] {\n-    fn len(&self) -> uint { self.len() }\n-    fn iter(&self, b: &fn(v: &T)) {\n-        for vec::each(*self) |elt| { b(elt); }\n-    }\n+    fn length(&self) -> uint { self.len() }\n }\n ~~~~\n \n@@ -2142,7 +2139,7 @@ as in this version of `print_all` that copies elements.\n fn print_all<T: Printable + Copy>(printable_things: ~[T]) {\n     let mut i = 0;\n     while i < printable_things.len() {\n-        let copy_of_thing = printable_things[i];\n+        let copy_of_thing = copy printable_things[i];\n         copy_of_thing.print();\n         i += 1;\n     }"}, {"sha": "23efbb3ee15c44957df4664d41580d7346f88136", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -63,13 +63,11 @@ define CLEAN_HOST_STAGE_N\n \n clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustc$(X_$(2))\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/fuzzer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBFUZZER_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME_$(2))\n@@ -83,7 +81,6 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBFUZZER_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n@@ -101,13 +98,11 @@ define CLEAN_TARGET_STAGE_N\n \n clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$(X_$(2))\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/fuzzer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rusti$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBFUZZER_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2))\n@@ -121,7 +116,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBFUZZER_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))"}, {"sha": "912b692a247e2be0254432049b50740b287f41e2", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -32,7 +32,6 @@ PKG_FILES := \\\n       librustc                                 \\\n       compiletest                              \\\n       etc                                      \\\n-      libfuzzer                                \\\n       libextra                                 \\\n       libstd                                   \\\n       libsyntax                                \\"}, {"sha": "f86bbb7f2812b0d10707b9535c90d475f62b2e8f", "filename": "mk/pp.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fpp.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Fpp.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fpp.mk?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -17,7 +17,6 @@ else\n               $(wildcard $(addprefix $(S)src/rustc/,*.rs */*.rs */*/*.rs)) \\\n               $(wildcard $(S)src/test/*/*.rs    \\\n                          $(S)src/test/*/*/*.rs) \\\n-              $(wildcard $(S)src/fuzzer/*.rs)   \\\n               $(wildcard $(S)src/rustpkg/*.rs) \\\n               $(wildcard $(S)src/rusti/*.rs) \\\n               $(wildcard $(S)src/rust/*.rs)"}, {"sha": "da950dffab5bfa6437fb8e004a325e901fd25d7d", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -158,10 +158,10 @@ rt/$(1)/stage$(2)/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJ_$(1)_$(2))\n \t$$(Q)$(AR_$(1)) rcs $$@ $$<\n \n rt/$(1)/stage$(2)/$(CFG_RUNTIME_$(1)): $$(RUNTIME_OBJS_$(1)_$(2)) $$(MKFILE_DEPS) \\\n-                        $$(RUNTIME_DEF_$(1)_$(2)) $$(LIBUV_LIB_$(1)_$(2)) $$(JEMALLOC_LIB_$(1)_$(2))\n+                        $$(RUNTIME_DEF_$(1)_$(2)) $$(LIBUV_LIB_$(1)_$(2))\n \t@$$(call E, link: $$@)\n \t$$(Q)$$(call CFG_LINK_CXX_$(1),$$@, $$(RUNTIME_OBJS_$(1)_$(2)) \\\n-\t  $$(JEMALLOC_LIB_$(1)_$(2)) $$(CFG_GCCISH_POST_LIB_FLAGS_$(1)) $$(LIBUV_LIB_$(1)_$(2)) \\\n+\t  $$(CFG_GCCISH_POST_LIB_FLAGS_$(1)) $$(LIBUV_LIB_$(1)_$(2)) \\\n \t  $$(CFG_LIBUV_LINK_FLAGS_$(1)),$$(RUNTIME_DEF_$(1)_$(2)),$$(CFG_RUNTIME_$(1)))\n \n # FIXME: For some reason libuv's makefiles can't figure out the"}, {"sha": "8319d8d4e4835fee4c1879d6038358b3aedbe4a0", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -11,9 +11,6 @@\n # Rules for non-core tools built with the compiler, both for target\n # and host architectures\n \n-FUZZER_LIB := $(S)src/libfuzzer/fuzzer.rc\n-FUZZER_INPUTS := $(wildcard $(addprefix $(S)src/libfuzzer/, *.rs))\n-\n # The test runner that runs the cfail/rfail/rpass and bxench tests\n COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rc\n COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*rs)\n@@ -38,21 +35,6 @@ RUST_INPUTS := $(wildcard $(S)src/librust/*.rs)\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N_TARGET\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4)):          \\\n-\t\t$$(FUZZER_LIB) $$(FUZZER_INPUTS)\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_STDLIB_$(4))\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_EXTRALIB_$(4))\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n-\n-$$(TBIN$(1)_T_$(4)_H_$(3))/fuzzer$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(DRIVER_CRATE)\t\t\t\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg fuzzer -o $$@ $$<\n-\n $$(TBIN$(1)_T_$(4)_H_$(3))/compiletest$$(X_$(4)):\t\t\t\\\n \t\t$$(COMPILETEST_CRATE) $$(COMPILETEST_INPUTS)\t\\\n \t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\t\\\n@@ -128,27 +110,6 @@ endef\n \n define TOOLS_STAGE_N_HOST\n \n-\n-# Promote the stageN target to stageN+1 host\n-# FIXME: Shouldn't need to depend on host/librustc.so once\n-# rpath is working\n-$$(HLIB$(2)_H_$(4))/$(CFG_LIBFUZZER_$(4)):\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBFUZZER_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBFUZZER_GLOB_$(4)) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBFUZZER_DSYM_GLOB_$(4))) \\\n-\t        $$(HLIB$(2)_H_$(4))\n-\n-$$(HBIN$(2)_H_$(4))/fuzzer$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/fuzzer$$(X_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBFUZZER_$(4))\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n $$(HBIN$(2)_H_$(4))/compiletest$$(X_$(4)):\t\t\t\t\\\n \t\t$$(TBIN$(1)_T_$(4)_H_$(3))/compiletest$$(X_$(4))\t\\\n \t\t$$(HSREQ$(2)_H_$(4))"}, {"sha": "f229068731f44189b67ec01b720606e8cade4e4e", "filename": "src/README.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -4,8 +4,8 @@ Source layout:\n \n librustc/          The self-hosted compiler\n \n-libcore/           The core library (imported and linked by default)\n-libstd/            The standard library (slightly more peripheral code)\n+libstd/            The standard library (imported and linked by default)\n+libextra/          The \"extras\" library (slightly more peripheral code)\n libsyntax/         The Rust parser and pretty-printer\n \n rt/                The runtime system"}, {"sha": "93fe258d167ed4a3c43eb4e2602cf2d819dbed71", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -23,7 +23,7 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n     assert!(prog.ends_with(\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n-    env = do vec::map(env) |pair| {\n+    env = do env.map() |pair| {\n         let (k,v) = copy *pair;\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }"}, {"sha": "e0ceb79a37dfc31de5520d57dc465d387a40b83e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -24,7 +24,6 @@ use util::logv;\n \n use core::io;\n use core::os;\n-use core::str;\n use core::uint;\n use core::vec;\n "}, {"sha": "ccedd3adbaa9bcc7b59fca673a474df317ab00c8", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -16,9 +16,6 @@ extern mod core(name = \"std\", vers = \"0.7-pre\");\n #[cfg(rustpkg)]\n extern mod this(name = \"rustpkg\");\n \n-#[cfg(fuzzer)]\n-extern mod this(name = \"fuzzer\");\n-\n #[cfg(rustdoc)]\n extern mod this(name = \"rustdoc\");\n "}, {"sha": "608dbdcca5d2c7f59c272ece03c902bf4fc7c55a", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -26,29 +26,29 @@ def scrub(b):\n \n snapshot_files = {\n     \"linux\": [\"bin/rustc\",\n-              \"lib/libcore-*.so\",\n               \"lib/libstd-*.so\",\n+              \"lib/libextra-*.so\",\n               \"lib/librustc-*.so\",\n               \"lib/libsyntax-*.so\",\n               \"lib/librustrt.so\",\n               \"lib/librustllvm.so\"],\n     \"macos\": [\"bin/rustc\",\n-              \"lib/libcore-*.dylib\",\n               \"lib/libstd-*.dylib\",\n+              \"lib/libextra-*.dylib\",\n               \"lib/librustc-*.dylib\",\n               \"lib/libsyntax-*.dylib\",\n               \"lib/librustrt.dylib\",\n               \"lib/librustllvm.dylib\"],\n     \"winnt\": [\"bin/rustc.exe\",\n-              \"bin/core-*.dll\",\n               \"bin/std-*.dll\",\n+              \"bin/extra-*.dll\",\n               \"bin/rustc-*.dll\",\n               \"bin/syntax-*.dll\",\n               \"bin/rustrt.dll\",\n               \"bin/rustllvm.dll\"],\n     \"freebsd\": [\"bin/rustc\",\n-                \"lib/libcore-*.so\",\n                 \"lib/libstd-*.so\",\n+                \"lib/libextra-*.so\",\n                 \"lib/librustc-*.so\",\n                 \"lib/libsyntax-*.so\",\n                 \"lib/librustrt.so\","}, {"sha": "661224b0a803722fd224e10060575b65d02c1523", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -58,7 +58,7 @@ pub struct Condvar<'self> {\n \n impl<'self> Condvar<'self> {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n-    #[inline(always)]\n+    #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n@@ -67,7 +67,7 @@ impl<'self> Condvar<'self> {\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn wait_on(&self, condvar_id: uint) {\n         assert!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n@@ -76,28 +76,28 @@ impl<'self> Condvar<'self> {\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    #[inline(always)]\n+    #[inline]\n     pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /**\n      * Wake up a blocked task on a specified condvar (as\n      * sync::cond.signal_on). Returns false if there was no blocked task.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn signal_on(&self, condvar_id: uint) -> bool {\n         assert!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    #[inline(always)]\n+    #[inline]\n     pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /**\n      * Wake up all blocked tasks on a specified condvar (as\n      * sync::cond.broadcast_on). Returns the number of tasks woken.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         assert!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n@@ -198,22 +198,20 @@ impl<T:Owned> MutexARC<T> {\n      * any tasks that subsequently try to access it (including those already\n      * blocked on the mutex) will also fail immediately.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            // Borrowck would complain about this if the function were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            do (&(*state).lock).lock {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            }\n+        let state = self.x.get();\n+        // Borrowck would complain about this if the function were\n+        // not already unsafe. See borrow_rwlock, far below.\n+        do (&(*state).lock).lock {\n+            check_poison(true, (*state).failed);\n+            let _z = PoisonOnFail(&mut (*state).failed);\n+            blk(&mut (*state).data)\n         }\n     }\n \n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn access_cond<'x, 'c, U>(&self,\n                                          blk: &fn(x: &'x mut T,\n                                                   c: &'c Condvar) -> U)\n@@ -231,7 +229,7 @@ impl<T:Owned> MutexARC<T> {\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n-#[inline(always)]\n+#[inline]\n #[doc(hidden)]\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n@@ -322,7 +320,7 @@ impl<T:Const + Owned> RWARC<T> {\n      * that other tasks won't block forever. As MutexARC.access, it will also\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n@@ -335,7 +333,7 @@ impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n-    #[inline(always)]\n+    #[inline]\n     pub fn write_cond<'x, 'c, U>(&self,\n                                  blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                                  -> U {"}, {"sha": "db4cf564babc593261f78ffd0e77597833d3b8d8", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -119,7 +119,7 @@ pub fn Arena() -> Arena {\n     arena_with_size(32u)\n }\n \n-#[inline(always)]\n+#[inline]\n fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n@@ -156,12 +156,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // initialized in the arena in the low bit of the tydesc pointer. This\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n-#[inline(always)]\n+#[inline]\n unsafe fn bitpack_tydesc_ptr(p: *TypeDesc, is_done: bool) -> uint {\n     let p_bits: uint = transmute(p);\n     p_bits | (is_done as uint)\n }\n-#[inline(always)]\n+#[inline]\n unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n@@ -179,7 +179,7 @@ impl Arena {\n         return self.alloc_pod_inner(n_bytes, align);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             // XXX: Borrow check\n@@ -199,7 +199,7 @@ impl Arena {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -223,7 +223,7 @@ impl Arena {\n         return self.alloc_nonpod_inner(n_bytes, align);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n                           -> (*u8, *u8) {\n         unsafe {\n@@ -246,7 +246,7 @@ impl Arena {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n@@ -268,7 +268,7 @@ impl Arena {\n     }\n \n     // The external interface\n-    #[inline(always)]\n+    #[inline]\n     pub fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check"}, {"sha": "5bf4dd517a5b2be655d12b7842cd1f64d40c1b03", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -229,8 +229,6 @@ impl<'self> FromBase64 for &'self str {\n \n #[cfg(test)]\n mod tests {\n-    use core::str;\n-\n     #[test]\n     fn test_to_base64() {\n         assert_eq!(\"\".to_base64(), ~\"\");"}, {"sha": "647fa81c71857584cd6cbd04411dec7a4b799a96", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -23,7 +23,7 @@ struct SmallBitv {\n }\n \n /// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n-#[inline(always)]\n+#[inline]\n fn small_mask(nbits: uint) -> uint {\n     (1 << nbits) - 1\n }\n@@ -33,7 +33,7 @@ impl SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn bits_op(&mut self,\n                    right_bits: uint,\n                    nbits: uint,\n@@ -46,32 +46,32 @@ impl SmallBitv {\n         mask & old_b != mask & new_b\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n@@ -81,29 +81,29 @@ impl SmallBitv {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self) { self.bits = 0; }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set_all(&mut self) { self.bits = !0; }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) { self.bits = !self.bits; }\n }\n \n@@ -115,7 +115,7 @@ struct BigBitv {\n  * a mask that has a 1 for each defined bit in the nth element of a big_bitv,\n  * assuming n bits.\n  */\n-#[inline(always)]\n+#[inline]\n fn big_mask(nbits: uint, elem: uint) -> uint {\n     let rmd = nbits % uint::bits;\n     let nelems = nbits/uint::bits + if rmd == 0 {0} else {1};\n@@ -132,7 +132,7 @@ impl BigBitv {\n         BigBitv {storage: storage}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn process(&mut self,\n                    b: &BigBitv,\n                    nbits: uint,\n@@ -154,43 +154,43 @@ impl BigBitv {\n         changed\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n         uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |_, w| w)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n@@ -199,7 +199,7 @@ impl BigBitv {\n                           else { self.storage[w] & !flag };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n@@ -229,7 +229,7 @@ fn die() -> ! {\n }\n \n impl Bitv {\n-    #[inline(always)]\n+    #[inline]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n             die();\n@@ -279,7 +279,7 @@ impl Bitv {\n      * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n      * the same length. Returns 'true' if `self` changed.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n@@ -288,7 +288,7 @@ impl Bitv {\n      * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn intersect(&mut self, v1: &Bitv) -> bool {\n         self.do_op(Intersect, v1)\n     }\n@@ -299,11 +299,11 @@ impl Bitv {\n      * Both bitvectors must be the same length. Returns `true` if `self` was\n      * changed\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         assert!((i < self.nbits));\n         match self.rep {\n@@ -317,7 +317,7 @@ impl Bitv {\n      *\n      * `i` must be less than the length of the bitvector.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n       assert!((i < self.nbits));\n       match self.rep {\n@@ -332,7 +332,7 @@ impl Bitv {\n      * Both bitvectors must be the same length. Returns `true` if both\n      * bitvectors contain identical elements.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n@@ -348,7 +348,7 @@ impl Bitv {\n     }\n \n     /// Set all bits to 0\n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self) {\n         match self.rep {\n           Small(ref mut b) => b.clear(),\n@@ -357,15 +357,15 @@ impl Bitv {\n     }\n \n     /// Set all bits to 1\n-    #[inline(always)]\n+    #[inline]\n     pub fn set_all(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.set_all(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n-    #[inline(always)]\n+    #[inline]\n     pub fn invert(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.invert(),\n@@ -381,13 +381,13 @@ impl Bitv {\n      *\n      * Returns `true` if `v0` was changed.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn difference(&mut self, v: &Bitv) -> bool {\n         self.do_op(Difference, v)\n     }\n \n     /// Returns true if all bits are 1\n-    #[inline(always)]\n+    #[inline]\n     pub fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n@@ -398,7 +398,7 @@ impl Bitv {\n       }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n         let mut i = 0;\n         while i < self.nbits {\n@@ -508,7 +508,7 @@ impl Bitv {\n \n impl Clone for Bitv {\n     /// Makes a copy of a bitvector\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> Bitv {\n         match self.rep {\n           Small(ref b) => {\n@@ -562,7 +562,7 @@ impl ops::Index<uint,bool> for Bitv {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n@@ -623,7 +623,7 @@ impl BitvSet {\n         return Bitv{ nbits:cap, rep: Big(~bitv) };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;"}, {"sha": "fd48e7d5958d4a1b30719619656c46fa93d3746a", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -122,7 +122,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  */\n pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert!(ofs < len(t));\n-    return unsafe { *ptr::mut_offset(t.base, ofs) };\n+    return unsafe { copy *ptr::mut_offset(t.base, ofs) };\n }\n \n /**"}, {"sha": "c8bb984736a11f3c3575b4724edb121c717786b6", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -264,31 +264,31 @@ mod tests {\n     fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(a);\n-        deq.add_front(b);\n-        deq.add_back(c);\n+        deq.add_front(copy a);\n+        deq.add_front(copy b);\n+        deq.add_back(copy c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(d);\n+        deq.add_back(copy d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.peek_front(), b);\n-        assert_eq!(*deq.peek_back(), d);\n-        assert_eq!(deq.pop_front(), b);\n-        assert_eq!(deq.pop_back(), d);\n-        assert_eq!(deq.pop_back(), c);\n-        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(copy *deq.peek_front(), copy b);\n+        assert_eq!(copy *deq.peek_back(), copy d);\n+        assert_eq!(deq.pop_front(), copy b);\n+        assert_eq!(deq.pop_back(), copy d);\n+        assert_eq!(deq.pop_back(), copy c);\n+        assert_eq!(deq.pop_back(), copy a);\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(c);\n+        deq.add_back(copy c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(b);\n+        deq.add_front(copy b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(d);\n+        deq.add_back(copy d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(a);\n+        deq.add_front(copy a);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.get(0), a);\n-        assert_eq!(*deq.get(1), b);\n-        assert_eq!(*deq.get(2), c);\n-        assert_eq!(*deq.get(3), d);\n+        assert_eq!(copy *deq.get(0), copy a);\n+        assert_eq!(copy *deq.get(1), copy b);\n+        assert_eq!(copy *deq.get(2), copy c);\n+        assert_eq!(copy *deq.get(3), copy d);\n     }\n \n     #[deriving(Eq)]"}, {"sha": "953803c6843f7fbfc848d8a08c1a855a1ff8c04c", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -111,7 +111,8 @@ pub fn from_elem<T>(data: T) -> @mut DList<T> {\n /// Creates a new dlist from a vector of elements, maintaining the same order\n pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n     do vec.iter().fold(DList()) |list,data| {\n-        list.push(*data); // Iterating left-to-right -- add newly to the tail.\n+        // Iterating left-to-right -- add newly to the tail.\n+        list.push(copy *data);\n         list\n     }\n }\n@@ -159,7 +160,7 @@ impl<T> DList<T> {\n     }\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n-    #[inline(always)]\n+    #[inline]\n     fn link(&mut self, before: DListLink<T>, after: DListLink<T>) {\n         match before {\n             Some(neighbour) => neighbour.next = after,\n@@ -460,35 +461,35 @@ impl<T> DList<T> {\n impl<T:Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n     pub fn pop(@mut self) -> Option<T> {\n-        self.pop_n().map(|nobe| nobe.data)\n+        self.pop_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Remove data from the tail of the list. O(1).\n     pub fn pop_tail(@mut self) -> Option<T> {\n-        self.pop_tail_n().map(|nobe| nobe.data)\n+        self.pop_tail_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's head. O(1).\n     pub fn peek(@mut self) -> Option<T> {\n-        self.peek_n().map(|nobe| nobe.data)\n+        self.peek_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n     pub fn peek_tail(@mut self) -> Option<T> {\n-        self.peek_tail_n().map (|nobe| nobe.data)\n+        self.peek_tail_n().map (|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    pub fn head(@mut self) -> T { self.head_n().data }\n+    pub fn head(@mut self) -> T { copy self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    pub fn tail(@mut self) -> T { self.tail_n().data }\n+    pub fn tail(@mut self) -> T { copy self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n     pub fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         for old_iter::eachi(&self) |index,data| {\n-            v[index] = *data;\n+            v[index] = copy *data;\n         }\n         v\n     }\n@@ -531,7 +532,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n         return true;\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n "}, {"sha": "9a8ee39593646b32ed0c8be5f496d2291ac6e58e", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -516,7 +516,6 @@ pub mod bytepipes {\n     use core::comm::{Port, Chan};\n     use core::comm;\n     use core::io::{Writer, Reader, ReaderUtil};\n-    use core::vec;\n \n     pub struct ReaderBytePort<R> {\n         reader: R\n@@ -583,12 +582,12 @@ pub mod bytepipes {\n \n     impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            if vec::uniq_len(&const *self.buf) >= count {\n+            if self.buf.len() >= count {\n                 let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n                 *self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n-            } else if vec::uniq_len(&const *self.buf) > 0 {\n+            } else if !self.buf.is_empty() {\n                 let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n                 assert!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n@@ -598,7 +597,7 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else if vec::uniq_len(&const *self.buf) == 0 {\n+            } else /* empty */ {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n                         assert!(!buf.is_empty());\n@@ -607,8 +606,6 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else {\n-                ::core::util::unreachable()\n             }\n         }\n     }"}, {"sha": "4652e1d6477015d53dc57317f9b5234587dfe9ec", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -57,7 +57,7 @@ priv enum FutureState<A> {\n impl<A:Copy> Future<A> {\n     pub fn get(&mut self) -> A {\n         //! Get the value of the future.\n-        *(self.get_ref())\n+        copy *(self.get_ref())\n     }\n }\n "}, {"sha": "34c35e0d7fde2524bfc6e899ffee06bd55d463bd", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -27,7 +27,7 @@ pub enum MutList<T> {\n \n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(*h, t))\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(copy *h, t))\n }\n \n /**\n@@ -61,7 +61,7 @@ pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     loop {\n         ls = match *ls {\n           Cons(ref hd, tl) => {\n-            if f(hd) { return Some(*hd); }\n+            if f(hd) { return Some(copy *hd); }\n             tl\n           }\n           Nil => return None"}, {"sha": "51d744955b81a8fb99fc7d7e73279fa86b5cf6f8", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 129, "deletions": 140, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -181,90 +181,88 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         debug!(\"stream_handle_ptr outside interact %?\",\n                         stream_handle_ptr);\n         do iotask::interact(iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp client connect..\");\n-                debug!(\"stream_handle_ptr in interact %?\",\n-                                stream_handle_ptr);\n-                match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-                    0i32 => {\n-                        debug!(\"tcp_init successful\");\n-                        debug!(\"dealing w/ ipv4 connection..\");\n-                        let connect_req_ptr: *uv::ll::uv_connect_t =\n-                            &(*socket_data_ptr).connect_req;\n-                        let addr_str = ip::format_addr(&input_ip);\n-                        let connect_result = match input_ip {\n-                            ip::Ipv4(ref addr) => {\n-                                // have to \"recreate\" the\n-                                // sockaddr_in/6 since the ip_addr\n-                                // discards the port info.. should\n-                                // probably add an additional rust\n-                                // type that actually is closer to\n-                                // what the libuv API expects (ip str\n-                                // + port num)\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip4_addr(addr_str,\n-                                                               port as int);\n-                                uv::ll::tcp_connect(\n-                                    connect_req_ptr,\n-                                    stream_handle_ptr,\n-                                    &in_addr,\n-                                    tcp_connect_on_connect_cb)\n-                            }\n-                            ip::Ipv6(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip6_addr(addr_str,\n-                                                               port as int);\n-                                uv::ll::tcp_connect6(\n-                                    connect_req_ptr,\n-                                    stream_handle_ptr,\n-                                    &in_addr,\n-                                    tcp_connect_on_connect_cb)\n-                            }\n-                        };\n-                        match connect_result {\n-                            0i32 => {\n-                                debug!(\"tcp_connect successful: \\\n-                                        stream %x,\n-                                        socket data %x\",\n-                                       stream_handle_ptr as uint,\n-                                       socket_data_ptr as uint);\n-                                // reusable data that we'll have for the\n-                                // duration..\n-                                uv::ll::set_data_for_uv_handle(\n-                                    stream_handle_ptr,\n-                                    socket_data_ptr as\n-                                    *libc::c_void);\n-                                // just so the connect_cb can send the\n-                                // outcome..\n-                                uv::ll::set_data_for_req(connect_req_ptr,\n-                                                         conn_data_ptr);\n-                                debug!(\"leaving tcp_connect interact cb...\");\n-                                // let tcp_connect_on_connect_cb send on\n-                                // the result_ch, now..\n-                            }\n-                            _ => {\n-                                // immediate connect\n-                                // failure.. probably a garbage ip or\n-                                // somesuch\n-                                let err_data =\n-                                    uv::ll::get_last_err_data(loop_ptr);\n-                                let result_ch = (*conn_data_ptr)\n-                                    .result_ch.clone();\n-                                result_ch.send(ConnFailure(err_data));\n-                                uv::ll::set_data_for_uv_handle(\n-                                    stream_handle_ptr,\n-                                    conn_data_ptr);\n-                                uv::ll::close(stream_handle_ptr,\n-                                              stream_error_close_cb);\n-                            }\n+            debug!(\"in interact cb for tcp client connect..\");\n+            debug!(\"stream_handle_ptr in interact %?\",\n+                            stream_handle_ptr);\n+            match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n+                0i32 => {\n+                    debug!(\"tcp_init successful\");\n+                    debug!(\"dealing w/ ipv4 connection..\");\n+                    let connect_req_ptr: *uv::ll::uv_connect_t =\n+                        &(*socket_data_ptr).connect_req;\n+                    let addr_str = ip::format_addr(&input_ip);\n+                    let connect_result = match input_ip {\n+                        ip::Ipv4(ref addr) => {\n+                            // have to \"recreate\" the\n+                            // sockaddr_in/6 since the ip_addr\n+                            // discards the port info.. should\n+                            // probably add an additional rust\n+                            // type that actually is closer to\n+                            // what the libuv API expects (ip str\n+                            // + port num)\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip4_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_connect(\n+                                connect_req_ptr,\n+                                stream_handle_ptr,\n+                                &in_addr,\n+                                tcp_connect_on_connect_cb)\n+                        }\n+                        ip::Ipv6(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip6_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_connect6(\n+                                connect_req_ptr,\n+                                stream_handle_ptr,\n+                                &in_addr,\n+                                tcp_connect_on_connect_cb)\n+                        }\n+                    };\n+                    match connect_result {\n+                        0i32 => {\n+                            debug!(\"tcp_connect successful: \\\n+                                    stream %x,\n+                                    socket data %x\",\n+                                   stream_handle_ptr as uint,\n+                                   socket_data_ptr as uint);\n+                            // reusable data that we'll have for the\n+                            // duration..\n+                            uv::ll::set_data_for_uv_handle(\n+                                stream_handle_ptr,\n+                                socket_data_ptr as\n+                                *libc::c_void);\n+                            // just so the connect_cb can send the\n+                            // outcome..\n+                            uv::ll::set_data_for_req(connect_req_ptr,\n+                                                     conn_data_ptr);\n+                            debug!(\"leaving tcp_connect interact cb...\");\n+                            // let tcp_connect_on_connect_cb send on\n+                            // the result_ch, now..\n+                        }\n+                        _ => {\n+                            // immediate connect\n+                            // failure.. probably a garbage ip or\n+                            // somesuch\n+                            let err_data =\n+                                uv::ll::get_last_err_data(loop_ptr);\n+                            let result_ch = (*conn_data_ptr)\n+                                .result_ch.clone();\n+                            result_ch.send(ConnFailure(err_data));\n+                            uv::ll::set_data_for_uv_handle(\n+                                stream_handle_ptr,\n+                                conn_data_ptr);\n+                            uv::ll::close(stream_handle_ptr,\n+                                          stream_error_close_cb);\n                         }\n                     }\n-                    _ => {\n-                        // failure to create a tcp handle\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        let result_ch = (*conn_data_ptr).result_ch.clone();\n-                        result_ch.send(ConnFailure(err_data));\n-                    }\n+                }\n+                _ => {\n+                    // failure to create a tcp handle\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    let result_ch = (*conn_data_ptr).result_ch.clone();\n+                    result_ch.send(ConnFailure(err_data));\n                 }\n             }\n         }\n@@ -879,8 +877,7 @@ impl io::Reader for TcpSocketBuf {\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n-          let nbuffered = vec::uniq_len(&const self.data.buf) -\n-                self.data.buf_off;\n+          let nbuffered = self.data.buf.len() - self.data.buf_off;\n           let needed = len - count;\n             if nbuffered > 0 {\n                 unsafe {\n@@ -934,7 +931,7 @@ impl io::Reader for TcpSocketBuf {\n     }\n     fn read_byte(&self) -> int {\n         loop {\n-          if vec::uniq_len(&const self.data.buf) > self.data.buf_off {\n+          if self.data.buf.len() > self.data.buf_off {\n             let c = self.data.buf[self.data.buf_off];\n             self.data.buf_off += 1;\n             return c as int\n@@ -1016,14 +1013,12 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         let close_data_ptr: *TcpSocketCloseData = &close_data;\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\n-                    \"interact dtor for tcp_socket stream %? loop %?\",\n-                         stream_handle_ptr, loop_ptr);\n-                uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                               close_data_ptr);\n-                uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-            }\n+            debug!(\n+                \"interact dtor for tcp_socket stream %? loop %?\",\n+                     stream_handle_ptr, loop_ptr);\n+            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                           close_data_ptr);\n+            uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n         };\n         closed_po.recv();\n         //the line below will most likely crash\n@@ -1083,19 +1078,17 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         let (stop_po, stop_ch) = stream::<Option<TcpErrData>>();\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp::read_stop\");\n-                match uv::ll::read_stop(stream_handle_ptr\n-                                        as *uv::ll::uv_stream_t) {\n-                    0i32 => {\n-                        debug!(\"successfully called uv_read_stop\");\n-                        stop_ch.send(None);\n-                    }\n-                    _ => {\n-                        debug!(\"failure in calling uv_read_stop\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        stop_ch.send(Some(err_data.to_tcp_err()));\n-                    }\n+            debug!(\"in interact cb for tcp::read_stop\");\n+            match uv::ll::read_stop(stream_handle_ptr\n+                                    as *uv::ll::uv_stream_t) {\n+                0i32 => {\n+                    debug!(\"successfully called uv_read_stop\");\n+                    stop_ch.send(None);\n+                }\n+                _ => {\n+                    debug!(\"failure in calling uv_read_stop\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    stop_ch.send(Some(err_data.to_tcp_err()));\n                 }\n             }\n         }\n@@ -1115,22 +1108,20 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n         let (start_po, start_ch) = stream::<Option<uv::ll::uv_err_data>>();\n         debug!(\"in tcp::read_start before interact loop\");\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in tcp::read_start interact cb %?\",\n-                                loop_ptr);\n-                match uv::ll::read_start(stream_handle_ptr\n-                                         as *uv::ll::uv_stream_t,\n-                                         on_alloc_cb,\n-                                         on_tcp_read_cb) {\n-                    0i32 => {\n-                        debug!(\"success doing uv_read_start\");\n-                        start_ch.send(None);\n-                    }\n-                    _ => {\n-                        debug!(\"error attempting uv_read_start\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        start_ch.send(Some(err_data));\n-                    }\n+            debug!(\"in tcp::read_start interact cb %?\",\n+                            loop_ptr);\n+            match uv::ll::read_start(stream_handle_ptr\n+                                     as *uv::ll::uv_stream_t,\n+                                     on_alloc_cb,\n+                                     on_tcp_read_cb) {\n+                0i32 => {\n+                    debug!(\"success doing uv_read_start\");\n+                    start_ch.send(None);\n+                }\n+                _ => {\n+                    debug!(\"error attempting uv_read_start\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    start_ch.send(Some(err_data));\n                 }\n             }\n         }\n@@ -1167,24 +1158,22 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         };\n         let write_data_ptr: *WriteReqData = &write_data;\n         do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"in interact cb for tcp::write %?\",\n-                                loop_ptr);\n-                match uv::ll::write(write_req_ptr,\n-                                    stream_handle_ptr,\n-                                    write_buf_vec_ptr,\n-                                    tcp_write_complete_cb) {\n-                    0i32 => {\n-                        debug!(\"uv_write() invoked successfully\");\n-                        uv::ll::set_data_for_req(write_req_ptr,\n-                                                 write_data_ptr);\n-                    }\n-                    _ => {\n-                        debug!(\"error invoking uv_write()\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        let result_ch = (*write_data_ptr).result_ch.clone();\n-                        result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n-                    }\n+            debug!(\"in interact cb for tcp::write %?\",\n+                            loop_ptr);\n+            match uv::ll::write(write_req_ptr,\n+                                stream_handle_ptr,\n+                                write_buf_vec_ptr,\n+                                tcp_write_complete_cb) {\n+                0i32 => {\n+                    debug!(\"uv_write() invoked successfully\");\n+                    uv::ll::set_data_for_req(write_req_ptr,\n+                                             write_data_ptr);\n+                }\n+                _ => {\n+                    debug!(\"error invoking uv_write()\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    let result_ch = (*write_data_ptr).result_ch.clone();\n+                    result_ch.send(TcpWriteError(err_data.to_tcp_err()));\n                 }\n             }\n         }"}, {"sha": "c626260043ee9e97d615081770b4194808c11fc0", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -80,19 +80,17 @@ impl<T: Clone + Num> Cmplx<T> {\n     }\n }\n \n-#[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Algebraic + Num> Cmplx<T> {\n     /// Calculate |self|\n-    #[inline(always)]\n+    #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(&self.im)\n     }\n }\n \n-#[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n-    #[inline(always)]\n+    #[inline]\n     pub fn arg(&self) -> T {\n         self.im.atan2(&self.re)\n     }\n@@ -222,6 +220,8 @@ mod test {\n     }\n \n     #[test]\n+    #[ignore(cfg(target_arch = \"x86\"))]\n+    // FIXME #7158: (maybe?) currently failing on x86.\n     fn test_norm() {\n         fn test(c: Complex, ns: float) {\n             assert_eq!(c.norm_sqr(), ns);"}, {"sha": "b2b966928e9ac539c6e15beeccdfd79244dd58d6", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -36,19 +36,19 @@ pub type BigRational = Ratio<BigInt>;\n impl<T: Clone + Integer + Ord>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn from_integer(t: T) -> Ratio<T> {\n         Ratio::new_raw(t, One::one())\n     }\n \n     /// Create a ratio without checking for `denom == 0` or reducing.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n         Ratio { numer: numer, denom: denom }\n     }\n \n     /// Create a new Ratio. Fails if `denom == 0`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n             fail!(\"denominator == 0\");\n@@ -206,7 +206,7 @@ impl<T: Clone + Integer + Ord>\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n             Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n@@ -215,7 +215,7 @@ impl<T: Clone + Integer + Ord>\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> Ratio<T> {\n         Ratio::from_integer(self.numer / self.denom)\n     }"}, {"sha": "efbf23f11b15c3ffb86c8ac3cd9068927fe8a5db", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -35,10 +35,10 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n \n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n-    fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n+    fn len(&self) -> uint { self.data.len() }\n \n     /// Returns true if a queue contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T:Ord> Mutable for PriorityQueue<T> {"}, {"sha": "b90b0983dc246d28537abe65affc982855e49451", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -60,7 +60,7 @@ pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n }\n \n impl<T> Rc<T> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n     }"}, {"sha": "fed73256c002c18164e7eff2d24d373edffaf28b", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1271,7 +1271,6 @@ mod tests {\n \n     use rope::*;\n \n-    use core::str;\n     use core::uint;\n     use core::vec;\n "}, {"sha": "cb372dd920da92e7fee867042749f24656458e6e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -29,7 +29,7 @@ pub enum Identifier {\n }\n \n impl cmp::Ord for Identifier {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Identifier) -> bool {\n         match (self, other) {\n             (&Numeric(a), &Numeric(b)) => a < b,\n@@ -38,22 +38,22 @@ impl cmp::Ord for Identifier {\n             (&AlphaNumeric(_), _) => false\n         }\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Identifier) -> bool {\n         ! (other < self)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Identifier) -> bool {\n         other < self\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Identifier) -> bool {\n         ! (self < other)\n     }\n }\n \n impl ToStr for Identifier {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         match self {\n             &Numeric(n) => n.to_str(),\n@@ -73,7 +73,7 @@ pub struct Version {\n }\n \n impl ToStr for Version {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n@@ -90,7 +90,7 @@ impl ToStr for Version {\n }\n \n impl cmp::Ord for Version {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Version) -> bool {\n \n         self.major < other.major ||\n@@ -123,15 +123,15 @@ impl cmp::Ord for Version {\n              self.build < other.build)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Version) -> bool {\n         ! (other < self)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Version) -> bool {\n         other < self\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Version) -> bool {\n         ! (self < other)\n     }"}, {"sha": "7c4b3f4ce39f7345ddaa9ed49912cc20d14854c9", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -24,7 +24,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -93,7 +92,7 @@ pub fn sha1() -> @Sha1 {\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n         assert_eq!(st.h.len(), digest_buf_len);\n-        assert_eq!(vec::uniq_len(st.work_buf), work_buf_len);\n+        assert_eq!(st.work_buf.len(), work_buf_len);\n         let mut t: int; // Loop counter\n         let w = st.work_buf;\n \n@@ -279,8 +278,6 @@ pub fn sha1() -> @Sha1 {\n mod tests {\n     use sha1;\n \n-    use core::vec;\n-\n     #[test]\n     fn test() {\n         struct Test {"}, {"sha": "aee087d3764db0121565030e37a10a65f7b54171", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -32,9 +32,9 @@ pub struct SmallIntMap<T> {\n \n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         let mut sz = 0;\n-        for uint::range(0, vec::uniq_len(&const self.v)) |i| {\n+        for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n                 Some(_) => sz += 1,\n                 None => {}\n@@ -44,7 +44,7 @@ impl<V> Container for SmallIntMap<V> {\n     }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<V> Mutable for SmallIntMap<V> {\n@@ -179,7 +179,7 @@ impl<V:Copy> SmallIntMap<V> {\n                            ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n-            Some(orig) => ff(key, *orig, val)\n+            Some(orig) => ff(key, copy *orig, val)\n         };\n         self.insert(key, new_val)\n     }\n@@ -199,12 +199,12 @@ pub struct SmallIntSet {\n \n impl Container for SmallIntSet {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         self.map.len()\n     }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl Mutable for SmallIntSet {\n@@ -294,11 +294,6 @@ mod tests {\n \n     use super::SmallIntMap;\n \n-    use core::local_data;\n-    use core::rand;\n-    use core::uint;\n-    use core::vec;\n-\n     #[test]\n     fn test_find_mut() {\n         let mut m = SmallIntMap::new();"}, {"sha": "3e81216fc3a1d9b3427a9079c24e3bacea244bbd", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -37,7 +37,7 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n \n         let v_len = end - begin;\n         if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[v[begin]]; }\n+        if v_len == 1 { return ~[copy v[begin]]; }\n \n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n@@ -53,9 +53,9 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n         let mut b_ix = 0;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(a[a_ix]);\n+                rs.push(copy a[a_ix]);\n                 a_ix += 1;\n-            } else { rs.push(b[b_ix]); b_ix += 1; }\n+            } else { rs.push(copy b[b_ix]); b_ix += 1; }\n         }\n         rs.push_all(vec::slice(a, a_ix, a_len));\n         rs.push_all(vec::slice(b, b_ix, b_len));\n@@ -106,7 +106,7 @@ pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n \n fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n-    let v: T = arr[right];\n+    let v: T = copy arr[right];\n     let mut i: int = left - 1;\n     let mut j: int = right;\n     let mut p: int = i;\n@@ -233,7 +233,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n     if start == 0 { start += 1; }\n \n     while start < size {\n-        let pivot = array[start];\n+        let pivot = copy array[start];\n         let mut left = 0;\n         let mut right = start;\n         assert!(left <= right);\n@@ -470,7 +470,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base1, base1+len1) |i| {\n-            tmp.push(array[i]);\n+            tmp.push(copy array[i]);\n         }\n \n         let mut c1 = 0;\n@@ -580,7 +580,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base2, base2+len2) |i| {\n-            tmp.push(array[i]);\n+            tmp.push(copy array[i]);\n         }\n \n         let mut c1 = base1 + len1 - 1;\n@@ -725,18 +725,18 @@ impl<T:Copy + Ord> MergeState<T> {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn copy_vec<T:Copy>(dest: &mut [T],\n                     s1: uint,\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n     for from.eachi |i, v| {\n-        dest[s1+i] = *v;\n+        dest[s1+i] = copy *v;\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn shift_vec<T:Copy>(dest: &mut [T],\n                      s1: uint,\n                      s2: uint,\n@@ -751,7 +751,6 @@ fn shift_vec<T:Copy>(dest: &mut [T],\n mod test_qsort3 {\n     use sort::*;\n \n-    use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = v1.len();\n@@ -861,8 +860,6 @@ mod tests {\n \n     use sort::*;\n \n-    use core::vec;\n-\n     fn check_sort(v1: &[int], v2: &[int]) {\n         let len = v1.len();\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n@@ -1048,7 +1045,7 @@ mod big_tests {\n     fn multiplyVec<T:Copy>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n-            arr[i % size]\n+            copy arr[i % size]\n         };\n         res\n     }"}, {"sha": "3a1de5de01d60558041742ea575c2467d7029104", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n \n-use core::vec;\n use core::f64;\n use core::cmp;\n use core::num;"}, {"sha": "d4c85ef51362d008d0847405a4e21f6d153140a3", "filename": "src/libextra/std.rc", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -10,34 +10,32 @@\n \n /*!\n \n-The Rust standard library.\n+Rust extras.\n \n-The Rust standand library provides a number of useful features that are\n-not required in or otherwise suitable for the core library.\n+The `extra` crate is a set of useful modules for a variety of\n+purposes, including collections, numerics, I/O, serialization,\n+and concurrency.\n+\n+Rust extras are part of the standard Rust distribution.\n \n */\n \n #[link(name = \"extra\",\n        vers = \"0.7-pre\",\n        uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/libstd\")];\n+       url = \"https://github.com/mozilla/rust/tree/master/src/libextra\")];\n \n-#[comment = \"The Rust standard library\"];\n+#[comment = \"Rust extras\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n-// NOTE: remove these two attributes after the next snapshot\n-#[no_core]; // for stage0\n-#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n-\n #[no_std];\n \n extern mod core(name = \"std\", vers = \"0.7-pre\");\n \n-use core::{str, unstable};\n use core::str::{StrSlice, OwnedStr};\n \n pub use core::os;\n@@ -127,7 +125,7 @@ pub mod test;\n pub mod serialize;\n \n // A curious inner-module that's not exported that contains the binding\n-// 'extra' so that macro-expanded references to std::serialize and such\n+// 'extra' so that macro-expanded references to extra::serialize and such\n // can be resolved within libextra.\n #[doc(hidden)]\n pub mod std {"}, {"sha": "f5d0b6946d33236be035201946360394ba61527f", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -363,7 +363,7 @@ impl<'self> Condvar<'self> {\n \n // Checks whether a condvar ID was out of bounds, and fails if so, or does\n // something else next on success.\n-#[inline(always)]\n+#[inline]\n #[doc(hidden)]\n fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: &fn() -> U) -> U {"}, {"sha": "39dcee5eff315a04cb412451078f8174e18ac3d6", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -36,7 +36,6 @@ mod tests {\n     use tempfile::mkdtemp;\n \n     use core::os;\n-    use core::str;\n \n     #[test]\n     fn test_mkdtemp() {"}, {"sha": "11f0fc23be518c6a3b7d5badb403103e9e1837ab", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -224,9 +224,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'i' => match (copy mparams[0], copy mparams[1]) {\n-                        (Number(ref mut x), Number(ref mut y)) => {\n-                            *x += 1;\n-                            *y += 1;\n+                        (Number(x), Number(y)) => {\n+                            mparams[0] = Number(x+1);\n+                            mparams[1] = Number(y+1);\n                         },\n                         (_, _) => return Err(~\"first two params not numbers with %i\")\n                     },\n@@ -352,6 +352,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use core::result::Ok;\n \n     #[test]\n     fn test_basic_setabf() {\n@@ -366,6 +367,16 @@ mod test {\n                    bytes!(\"21\").to_owned());\n     }\n \n+    #[test]\n+    fn test_op_i() {\n+        let mut vars = Variables::new();\n+        assert_eq!(expand(bytes!(\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\"),\n+                          [Number(1),Number(2),Number(3)], &mut vars),\n+                   Ok(bytes!(\"123233\").to_owned()));\n+        assert_eq!(expand(bytes!(\"%p1%d%p2%d%i%p1%d%p2%d\"), [], &mut vars),\n+                   Ok(bytes!(\"0011\").to_owned()));\n+    }\n+\n     #[test]\n     fn test_param_stack_failure_conditions() {\n         let mut varstruct = Variables::new();"}, {"sha": "66649c62fcaf34759bffe0d079130827c49d1980", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -313,7 +313,6 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use p = core::path::Path;\n \n     #[test]\n     fn test_veclens() {"}, {"sha": "64c6a822a86e70876ebbb13433ae1d0e0b9d15e7", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -26,20 +26,11 @@ use core::either;\n use core::io;\n use core::option;\n use core::result;\n-use core::str;\n use core::task;\n use core::to_str::ToStr;\n use core::uint;\n use core::vec;\n \n-pub mod rustrt {\n-    use core::libc::size_t;\n-\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        pub unsafe fn rust_sched_threads() -> size_t;\n-    }\n-}\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -365,7 +356,7 @@ pub fn run_tests_console(opts: &TestOpts,\n fn print_failures(st: &ConsoleTestState) {\n     st.out.write_line(\"\\nfailures:\");\n     let mut failures = ~[];\n-    for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n+    for uint::range(0, st.failures.len()) |i| {\n         let name = copy st.failures[i].name;\n         failures.push(name.to_str());\n     }\n@@ -489,11 +480,10 @@ static sched_overcommit : uint = 1;\n static sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n-    unsafe {\n-        let threads = rustrt::rust_sched_threads() as uint;\n-        if threads == 1 { 1 }\n-        else { threads * sched_overcommit }\n-    }\n+    use core::rt;\n+    let threads = rt::util::default_sched_threads();\n+    if threads == 1 { 1 }\n+    else { threads * sched_overcommit }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -542,7 +532,7 @@ pub fn filter_tests(\n \n     // Sort the tests alphabetically\n     fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n+        t1.desc.name.to_str() < t2.desc.name.to_str()\n     }\n     sort::quick_sort(filtered, lteq);\n "}, {"sha": "005238a564e85ec45fff32267d0d1c5db7e3e7f2", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -275,7 +275,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n-            match strs[i] { // can't use let due to stage0 bugs\n+            match strs[i] { // can't use let due to let-pattern bugs\n                 (ref needle, value) => {\n                     if match_str(ss, pos, *needle) {\n                         return Some((value, pos + needle.len()));"}, {"sha": "f857581c17dd26d73333bdb18b65f60befe71276", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -75,13 +75,13 @@ fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n }\n \n impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n@@ -145,7 +145,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[inline(always)]\n+    #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n     }\n@@ -236,7 +236,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n \n impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n         do self.iter.next().map |&(value, _)| { value }\n     }\n@@ -251,69 +251,69 @@ pub struct TreeSet<T> {\n \n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n-    #[inline(always)]\n+    #[inline]\n     fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n     /// Return true if the set has no elements in common with `other`.\n@@ -336,7 +336,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Return true if the set is a subset of another\n-    #[inline(always)]\n+    #[inline]\n     fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n     }\n@@ -490,12 +490,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n impl<T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n-    #[inline(always)]\n+    #[inline]\n     pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n@@ -518,7 +518,7 @@ struct TreeNode<K, V> {\n \n impl<K: TotalOrd, V> TreeNode<K, V> {\n     /// Creates a new tree node.\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n@@ -710,7 +710,6 @@ mod test_treemap {\n \n     use core::rand::RngUtil;\n     use core::rand;\n-    use core::str;\n     use core::vec;\n \n     #[test]"}, {"sha": "12a26606f36e3f44ed8ddf00f39bad62626d2c57", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -104,7 +104,7 @@ struct WorkKey {\n }\n \n impl to_bytes::IterBytes for WorkKey {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n     }"}, {"sha": "7d623919ff9365f70c36f3689e248ec0fff6cc7a", "filename": "src/libfuzzer/ast_match.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=794923c99511398bc90400e380dd11770ec8e614", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::prelude::*;\n-\n-use vec;\n-\n-fn vec_equal<T>(v: ~[T],\n-                u: ~[T],\n-                element_equality_test: @fn(&&T, &&T) -> bool) ->\n-   bool {\n-    let Lv = v.len();\n-    if Lv != u.len() { return false; }\n-    let i = 0u;\n-    while i < Lv {\n-        if !element_equality_test(v[i], u[i]) { return false; }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n-fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n-fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n-\n-fn main() {\n-    assert!((builtin_equal(5, 5)));\n-    assert!((!builtin_equal(5, 4)));\n-    assert!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n-    assert!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n-    assert!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n-    assert!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n-    assert!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n-\n-    error!(\"Pass\");\n-}"}, {"sha": "2256325fa43765103dc7b57eae8eb5b6404fcb27", "filename": "src/libfuzzer/cycles.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=794923c99511398bc90400e380dd11770ec8e614", "patch": "@@ -1,108 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use extra;\n-use extra::rand;\n-use uint::range;\n-\n-// random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint {\n-    assert!(n != 0u); r.next() as uint % n\n-}\n-\n-// random choice from a vec\n-fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    assert!(v.len() != 0u); v[under(r, v.len())]\n-}\n-\n-// k in n chance of being true\n-fn likelihood(r : rand::rng, k : uint, n : uint) -> bool { under(r, n) < k }\n-\n-\n-static iters : uint = 1000u;\n-static vlen  : uint = 100u;\n-\n-enum maybe_pointy {\n-    none,\n-    p(@pointy)\n-}\n-\n-type pointy = {\n-    mut a : maybe_pointy,\n-    mut b : ~maybe_pointy,\n-    mut c : @maybe_pointy,\n-\n-    mut f : @fn()->(),\n-    mut g : ~fn()->(),\n-\n-    mut m : ~[maybe_pointy],\n-    mut n : ~[maybe_pointy],\n-    mut o : {x : int, y : maybe_pointy}\n-};\n-// To add: objects; traits; anything type-parameterized?\n-\n-fn empty_pointy() -> @pointy {\n-    return @{\n-        mut a : none,\n-        mut b : ~none,\n-        mut c : @none,\n-\n-        mut f : || {},\n-        mut g : || {},\n-\n-        mut m : ~[],\n-        mut n : ~[],\n-        mut o : {x : 0, y : none}\n-    }\n-}\n-\n-fn nopP(_x : @pointy) { }\n-fn nop<T>(_x: T) { }\n-\n-fn test_cycles(r : rand::rng, k: uint, n: uint)\n-{\n-    let mut v : ~[@pointy] = ~[];\n-\n-    // Create a graph with no edges\n-    range(0u, vlen) {|_i|\n-        v.push(empty_pointy());\n-    }\n-\n-    // Fill in the graph with random edges, with density k/n\n-    range(0u, vlen) {|i|\n-        if (likelihood(r, k, n)) { v[i].a = p(choice(r, v)); }\n-        if (likelihood(r, k, n)) { v[i].b = ~p(choice(r, v)); }\n-        if (likelihood(r, k, n)) { v[i].c = @p(choice(r, v)); }\n-\n-        if (likelihood(r, k, n)) { v[i].f = bind nopP(choice(r, v)); }\n-        //if (false)               { v[i].g = bind (|_: @pointy| { })(\n-        // choice(r, v)); }\n-          // https://github.com/mozilla/rust/issues/1899\n-\n-        if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }\n-        if (likelihood(r, k, n)) { v[i].n.push(mut p(choice(r, v))); }\n-        if (likelihood(r, k, n)) { v[i].o = {x: 0, y: p(choice(r, v))}; }\n-    }\n-\n-    // Drop refs one at a time\n-    range(0u, vlen) {|i|\n-        v[i] = empty_pointy()\n-    }\n-}\n-\n-fn main()\n-{\n-    let r = rand::rng();\n-    range(0u, iters) {|i|\n-        test_cycles(r, i, iters);\n-    }\n-}"}, {"sha": "4e2103fcd7047ba4dbf15e70776f2e2be0f87a0f", "filename": "src/libfuzzer/fuzzer.rc", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=794923c99511398bc90400e380dd11770ec8e614", "patch": "@@ -1,713 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#[link(name = \"fuzzer\",\n-       vers = \"0.7-pre\",\n-       uuid = \"d6418797-2736-4833-bd82-d3c684b7c1b0\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/libfuzzer\")];\n-\n-#[comment = \"The Rust fuzzer library\"];\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-#[allow(non_camel_case_types)];\n-\n-#[no_std];\n-\n-extern mod std(name = \"std\", vers = \"0.7-pre\");\n-extern mod extra(name = \"extra\", vers = \"0.7-pre\");\n-\n-extern mod syntax(vers = \"0.7-pre\");\n-\n-use std::prelude::*;\n-\n-use std::int;\n-use std::io;\n-use std::option;\n-use std::os;\n-use std::result;\n-use std::run;\n-use std::str;\n-use std::uint;\n-\n-use syntax::diagnostic;\n-use syntax::parse::token::ident_interner;\n-use syntax::parse::token;\n-use syntax::parse;\n-use syntax::print::pprust;\n-use syntax::{ast, fold, visit, codemap};\n-\n-#[deriving(Eq)]\n-pub enum test_mode { tm_converge, tm_run, }\n-\n-pub struct Context { mode: test_mode } // + rng\n-\n-pub fn write_file(filename: &Path, content: &str) {\n-    result::get(&io::file_writer(filename, [io::Create, io::Truncate]))\n-                    .write_str(content);\n-}\n-\n-pub fn contains(haystack: &str, needle: &str) -> bool {\n-    haystack.contains(needle)\n-}\n-\n-pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n-    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), \"utf8\") {\n-        // ignoring \"utf8\" tests because something is broken\n-        files.push(path.clone());\n-    } else if os::path_is_dir(path)\n-        && !contains(path.to_str(), \"compile-fail\")\n-        && !contains(path.to_str(), \"build\") {\n-        for os::list_dir_path(path).each |p| {\n-            find_rust_files(&mut *files, *p);\n-        }\n-    }\n-}\n-\n-\n-pub fn common_exprs() -> ~[@ast::expr] {\n-    fn dse(e: ast::expr_) -> @ast::expr {\n-        @ast::expr {\n-            id: 0,\n-            node: e,\n-            span: codemap::dummy_sp(),\n-        }\n-    }\n-\n-    fn dsl(l: ast::lit_) -> ast::lit {\n-        codemap::spanned { node: l, span: codemap::dummy_sp() }\n-    }\n-\n-    ~[dse(ast::expr_break(option::None)),\n-     dse(ast::expr_again(option::None)),\n-     dse(ast::expr_ret(option::None)),\n-     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(-1, ast::box(ast::m_imm),\n-                         dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(-1, ast::uniq(ast::m_imm),\n-                         dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n-    ]\n-}\n-\n-pub fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(e, tm)\n-}\n-\n-pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    match tm {\n-      tm_converge => {\n-        match e.node {\n-          // If the fuzzer moves a block-ending-in-semicolon into callee\n-          // position, the pretty-printer can't preserve this even by\n-          // parenthesizing!!  See email to marijn.\n-          ast::expr_if(*) | ast::expr_block(*)\n-          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n-\n-          // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(*) | ast::expr_binary(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) => { false }\n-\n-          ast::expr_ret(option::None) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/953\n-          //ast::expr_fail(option::Some(_)) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/928\n-          //ast::expr_cast(_, _) { false }\n-\n-          // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(*) => { false }\n-\n-          _ => { true }\n-        }\n-      }\n-      tm_run => { true }\n-    }\n-}\n-\n-pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n-    // Restrictions happen to be the same.\n-    safe_to_replace_ty(&t.node, tm)\n-}\n-\n-// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n-pub fn stash_expr_if(c: @fn(@ast::expr, test_mode)->bool,\n-                     es: @mut ~[@ast::expr],\n-                     e: @ast::expr,\n-                     tm: test_mode) {\n-    if c(e, tm) {\n-        *es = *es + [e];\n-    } else {\n-        /* now my indices are wrong :( */\n-    }\n-}\n-\n-pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode) -> bool,\n-                   es: @mut ~[@ast::Ty],\n-                   e: @ast::Ty,\n-                   tm: test_mode) {\n-    if c(e, tm) {\n-        es.push(e);\n-    } else {\n-        /* now my indices are wrong :( */\n-    }\n-}\n-\n-pub struct StolenStuff {\n-    exprs: ~[@ast::expr],\n-    tys: ~[@ast::Ty]\n-}\n-\n-pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n-    let exprs = @mut ~[];\n-    let tys = @mut ~[];\n-    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n-        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n-        .. *visit::default_simple_visitor()\n-    });\n-    visit::visit_crate(crate, ((), v));\n-    StolenStuff {\n-        exprs: (*exprs).clone(),\n-        tys: (*tys).clone(),\n-    }\n-}\n-\n-\n-pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n-    match *e {\n-        // https://github.com/mozilla/rust/issues/652\n-        ast::expr_if(*) => false,\n-        ast::expr_block(_) => false,\n-\n-        // expr_call is also missing a constraint\n-        ast::expr_fn_block(*) => false,\n-\n-        _ => true,\n-    }\n-}\n-\n-pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n-    match *t {\n-      ast::ty_infer => { false } // always implicit, always top level\n-      ast::ty_bot => { false }   // in source, can only appear\n-                              // as the out type of a function\n-      ast::ty_mac(_) => { false }\n-      _ => { true }\n-    }\n-}\n-\n-// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-pub fn replace_expr_in_crate(crate: @ast::crate,\n-                             i: uint,\n-                             newexpr: @ast::expr,\n-                             tm: test_mode)\n-                             -> @ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_expr_rep(j_: @mut uint,\n-                     i_: uint,\n-                     newexpr_: &ast::expr_,\n-                     original: &ast::expr_,\n-                     fld: @fold::ast_fold,\n-                     tm_: test_mode)\n-                     -> ast::expr_ {\n-        *j_ += 1;\n-        if i_ + 1 == *j_ && safe_to_replace_expr(original, tm_) {\n-            copy *newexpr_\n-        } else {\n-            fold::noop_fold_expr(original, fld)\n-        }\n-    }\n-    let afp = @fold::AstFoldFns {\n-        fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, &newexpr.node, a, b, tm)\n-        }),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    crate2\n-}\n-\n-\n-// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-pub fn replace_ty_in_crate(crate: @ast::crate,\n-                           i: uint,\n-                           newty: @ast::Ty,\n-                           tm: test_mode)\n-                           -> @ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_ty_rep(j_: @mut uint,\n-                   i_: uint,\n-                   newty_: &ast::ty_,\n-                   original: &ast::ty_,\n-                   fld: @fold::ast_fold,\n-                   tm_: test_mode)\n-                   -> ast::ty_ {\n-        *j_ += 1;\n-        if i_ + 1 == *j_ && safe_to_replace_ty(original, tm_) {\n-            copy *newty_\n-        } else {\n-            fold::noop_fold_ty(original, fld)\n-        }\n-    }\n-    let afp = @fold::AstFoldFns {\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, &newty.node, a, b, tm)),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    crate2\n-}\n-\n-pub fn under(n: uint, it: &fn(uint)) {\n-    let mut i: uint = 0u;\n-    while i < n { it(i); i += 1u; }\n-}\n-\n-pub fn as_str(f: @fn(x: @io::Writer)) -> ~str {\n-    io::with_str_writer(f)\n-}\n-\n-pub fn check_variants_of_ast(crate: @ast::crate,\n-                             codemap: @codemap::CodeMap,\n-                             filename: &Path,\n-                             cx: Context) {\n-    let stolen = steal(crate, cx.mode);\n-    let extra_exprs = do common_exprs().filtered |&a| {\n-        safe_to_use_expr(a, cx.mode)\n-    };\n-    check_variants_T(crate,\n-                     codemap,\n-                     filename,\n-                     ~\"expr\",\n-                     extra_exprs + stolen.exprs,\n-                     pprust::expr_to_str,\n-                     replace_expr_in_crate,\n-                     cx);\n-    check_variants_T(crate,\n-                     codemap,\n-                     filename,\n-                     ~\"ty\",\n-                     stolen.tys,\n-                     pprust::ty_to_str,\n-                     replace_ty_in_crate,\n-                     cx);\n-}\n-\n-pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n-                                codemap: @codemap::CodeMap,\n-                                filename: &Path,\n-                                thing_label: ~str,\n-                                things: &[T],\n-                                stringifier: @fn(T, @ident_interner) -> ~str,\n-                                replacer: @fn(@ast::crate,\n-                                              uint,\n-                                              T,\n-                                              test_mode)\n-                                              -> @ast::crate,\n-                                cx: Context) {\n-    error!(\"%s contains %u %s objects\", filename.to_str(),\n-           things.len(), thing_label);\n-\n-    // Assuming we're not generating any token_trees\n-    let intr = syntax::parse::token::mk_fake_ident_interner();\n-\n-    let L = things.len();\n-\n-    if L < 100 {\n-        do under(uint::min(L, 20)) |i| {\n-            error!(\"Replacing... #%?\", uint::to_str(i));\n-            let fname = str::to_owned(filename.to_str());\n-            do under(uint::min(L, 30)) |j| {\n-                let fname = fname.to_str();\n-                error!(\"With... %?\", stringifier(things[j], intr));\n-                let crate2 = replacer(crate, i, things[j], cx.mode);\n-                // It would be best to test the *crate* for stability, but\n-                // testing the string for stability is easier and ok for now.\n-                let handler = diagnostic::mk_handler(None);\n-                let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    let fname = fname.to_str();\n-                    let string = do as_str |a| {\n-                        let span_handler =\n-                            diagnostic::mk_span_handler(handler, codemap);\n-                        pprust::print_crate(codemap,\n-                                            intr,\n-                                            span_handler,\n-                                            crate2,\n-                                            fname.to_managed(),\n-                                            rdr,\n-                                            a,\n-                                            pprust::no_ann(),\n-                                            false)\n-                    };\n-                    string.to_managed()\n-                };\n-                match cx.mode {\n-                    tm_converge => check_roundtrip_convergence(str3, 1),\n-                    tm_run => {\n-                        let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                              last_part(filename.to_str()),\n-                                              thing_label,\n-                                              i,\n-                                              j);\n-                        let safe_to_run = !(content_is_dangerous_to_run(str3)\n-                                            || has_raw_pointers(crate2));\n-                        check_whole_compiler(str3,\n-                                             &Path(file_label),\n-                                             safe_to_run);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn last_part(filename: ~str) -> ~str {\n-    let ix = filename.rfind('/').get();\n-    filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n-}\n-\n-pub enum happiness {\n-    passed,\n-    cleanly_rejected(~str),\n-    known_bug(~str),\n-    failed(~str),\n-}\n-\n-// We'd find more bugs if we could take an AST here, but\n-// - that would find many \"false positives\" or unimportant bugs\n-// - that would be tricky, requiring use of tasks or serialization\n-//   or randomness.\n-// This seems to find plenty of bugs as it is :)\n-pub fn check_whole_compiler(code: &str,\n-                            suggested_filename_prefix: &Path,\n-                            allow_running: bool) {\n-    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n-    write_file(filename, code);\n-\n-    let compile_result = check_compiling(filename);\n-\n-    let run_result = match (compile_result, allow_running) {\n-      (passed, true) => { check_running(suggested_filename_prefix) }\n-      (h, _) => { h }\n-    };\n-\n-    match run_result {\n-      passed | cleanly_rejected(_) | known_bug(_) => {\n-        removeIfExists(suggested_filename_prefix);\n-        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n-        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n-      }\n-      failed(s) => {\n-        error!(\"check_whole_compiler failure: %?\", s);\n-        error!(\"Saved as: %?\", filename.to_str());\n-      }\n-    }\n-}\n-\n-pub fn removeIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert!(!contains(filename.to_str(), \" \"));\n-    run::process_status(\"bash\", [~\"-c\", ~\"rm \" + filename.to_str()]);\n-}\n-\n-pub fn removeDirIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert!(!contains(filename.to_str(), \" \"));\n-    run::process_status(\"bash\", [~\"-c\", ~\"rm -r \" + filename.to_str()]);\n-}\n-\n-pub fn check_running(exe_filename: &Path) -> happiness {\n-    let p = run::process_output(\n-        \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        [exe_filename.to_str()]);\n-    let comb = str::from_bytes(p.output) + \"\\n\" + str::from_bytes(p.error);\n-    if comb.len() > 1u {\n-        error!(\"comb comb comb: %?\", comb);\n-    }\n-\n-    if contains(comb, \"Assertion failed:\") {\n-        failed(~\"C++ assertion failure\")\n-    } else if contains(comb, \"leaked memory in rust main loop\") {\n-        // might also use exit code 134\n-        //failed(\"Leaked\")\n-        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n-    } else if contains(comb, \"src/rt/\") {\n-        failed(~\"Mentioned src/rt/\")\n-    } else if contains(comb, \"malloc\") {\n-        failed(~\"Mentioned malloc\")\n-    } else {\n-        match p.status {\n-            0         => { passed }\n-            100       => { cleanly_rejected(~\"running: explicit fail\") }\n-            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n-            245 | 246 | 138 | 252 => {\n-              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n-            }\n-            136 | 248 => {\n-              known_bug(\n-                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n-            }\n-            rc => {\n-              failed(~\"Rust program ran but exited with status \" +\n-                     int::to_str(rc))\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check_compiling(filename: &Path) -> happiness {\n-    let p = run::process_output(\n-        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/stage1/bin/rustc\",\n-        [filename.to_str()]);\n-\n-    let out = str::from_bytes(p.output);\n-    let err = str::from_bytes(p.error);\n-\n-    //error!(\"Status: %d\", p.status);\n-    if p.status == 0 {\n-        passed\n-    } else if !err.is_empty() {\n-        if err.contains(\"error:\") {\n-            cleanly_rejected(~\"rejected with span_error\")\n-        } else {\n-            error!(\"Stderr: %?\", err);\n-            failed(~\"Unfamiliar error message\")\n-        }\n-    } else if out.contains(\"Assertion\") && out.contains(\"failed\") {\n-        error!(\"Stdout: %?\", out);\n-        failed(~\"Looks like an llvm assertion failure\")\n-    } else if out.contains(\"internal compiler error unimplemented\") {\n-        known_bug(~\"Something unimplemented\")\n-    } else if out.contains(\"internal compiler error\") {\n-        error!(\"Stdout: %?\", out);\n-        failed(~\"internal compiler error\")\n-\n-    } else {\n-        error!(\"%?\", p.status);\n-        error!(\"!Stdout: %?\", out);\n-        failed(~\"What happened?\")\n-    }\n-}\n-\n-\n-pub fn parse_and_print(code: @str) -> @str {\n-    let filename = Path(\"tmp.rs\");\n-    let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, code);\n-    let crate = parse::parse_crate_from_source_str(filename.to_str().to_managed(),\n-                                                   code,\n-                                                   ~[],\n-                                                   sess);\n-    do io::with_str_reader(code) |rdr| {\n-        let filename = filename.to_str();\n-        do as_str |a| {\n-            pprust::print_crate(sess.cm,\n-                                // Assuming there are no token_trees\n-                                token::mk_fake_ident_interner(),\n-                                copy sess.span_diagnostic,\n-                                crate,\n-                                filename.to_managed(),\n-                                rdr,\n-                                a,\n-                                pprust::no_ann(),\n-                                false)\n-        }.to_managed()\n-    }\n-}\n-\n-pub fn has_raw_pointers(c: @ast::crate) -> bool {\n-    let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n-        match t.node {\n-          ast::ty_ptr(_) => { *flag = true; }\n-          _ => { }\n-        }\n-    }\n-    let v =\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_ty: |a| visit_ty(has_rp, a),\n-            .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, ((), v));\n-    return *has_rp;\n-}\n-\n-pub fn content_is_dangerous_to_run(code: &str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"import\",  // espeically fs, run\n-         ~\"extern\",\n-         ~\"unsafe\",\n-         ~\"log\"];    // python --> rust pipe deadlock?\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn content_is_dangerous_to_compile(code: &str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\"];\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn content_might_not_converge(code: &str) -> bool {\n-    let confusing_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"xfail-pretty\",\n-         ~\"self\",       // crazy rules enforced by parser not typechecker?\n-         ~\"spawn\",      // precedence issues?\n-         ~\"bind\",       // precedence issues?\n-         ~\" be \",       // don't want to replace its child with a non-call:\n-                       // \"Non-call expression in tail call\"\n-         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n-        ];\n-\n-    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-pub fn file_might_not_converge(filename: &Path) -> bool {\n-    let confusing_files = ~[\n-      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n-                     // vs \"a = b = c\" and wrapping\n-      ~\"block-arg-in-ternary.rs\", // wrapping\n-      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n-      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n-    ];\n-\n-\n-    for confusing_files.each |f| {\n-        if contains(filename.to_str(), *f) {\n-            return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-pub fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n-    let mut i = 0u;\n-    let mut newv = code;\n-    let mut oldv = code;\n-\n-    while i < maxIters {\n-        oldv = newv;\n-        if content_might_not_converge(oldv) { return; }\n-        newv = parse_and_print(oldv);\n-        if oldv == newv { break; }\n-        i += 1u;\n-    }\n-\n-    if oldv == newv {\n-        error!(\"Converged after %u iterations\", i);\n-    } else {\n-        error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), newv);\n-        run::process_status(\"diff\", [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\", ~\"round-trip-b.rs\"]);\n-        fail!(\"Mismatch\");\n-    }\n-}\n-\n-pub fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", files.len());\n-    for files.each |file| {\n-        if !file_might_not_converge(file) {\n-            let s = result::get(&io::read_whole_file_str(file)).to_managed();\n-            if !content_might_not_converge(s) {\n-                error!(\"pp converge: %s\", file.to_str());\n-                // Change from 7u to 2u once\n-                // https://github.com/mozilla/rust/issues/850 is fixed\n-                check_roundtrip_convergence(s, 7u);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check_variants(files: &[Path], cx: Context) {\n-    for files.each |file| {\n-        if cx.mode == tm_converge &&\n-            file_might_not_converge(file) {\n-            error!(\"Skipping convergence test based on\\\n-                    file_might_not_converge\");\n-            loop;\n-        }\n-\n-        let s = result::get(&io::read_whole_file_str(file)).to_managed();\n-        if s.contains_char('#') {\n-            loop; // Macros are confusing\n-        }\n-        if cx.mode == tm_converge && content_might_not_converge(s) {\n-            loop;\n-        }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(s) {\n-            loop;\n-        }\n-\n-        let file_str = file.to_str();\n-\n-        error!(\"check_variants: %?\", file_str);\n-        let sess = parse::new_parse_sess(None);\n-        let crate = parse::parse_crate_from_source_str(file_str.to_managed(),\n-                                                       s,\n-                                                       ~[],\n-                                                       sess);\n-        io::with_str_reader(s, |rdr| {\n-            let file_str = file_str.to_str();\n-            error!(\"%s\",\n-                   as_str(|a| {\n-                    pprust::print_crate(\n-                        sess.cm,\n-                        // Assuming no token_trees\n-                        token::mk_fake_ident_interner(),\n-                        copy sess.span_diagnostic,\n-                        crate,\n-                        file_str.to_managed(),\n-                        rdr,\n-                        a,\n-                        pprust::no_ann(),\n-                        false)\n-                    }))\n-        });\n-        check_variants_of_ast(crate, sess.cm, file, cx);\n-    }\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    if args.len() != 2u {\n-        error!(\"usage: %s <testdir>\", args[0]);\n-        return;\n-    }\n-    let mut files = ~[];\n-    let root = Path(args[1]);\n-\n-    find_rust_files(&mut files, &root);\n-    error!(\"== check_convergence ==\");\n-    check_convergence(files);\n-    error!(\"== check_variants: converge ==\");\n-    check_variants(files, Context { mode: tm_converge });\n-    error!(\"== check_variants: run ==\");\n-    check_variants(files, Context { mode: tm_run });\n-\n-    error!(\"Fuzzer done\");\n-}\n-\n-// For bootstrapping purposes...\n-pub mod core {\n-    pub use std::cmp;\n-    pub use std::sys;\n-}"}, {"sha": "8f019a14eedb3f6fb4341b57bb21450c19637463", "filename": "src/libfuzzer/ivec_fuzz.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fivec_fuzz.rs?ref=794923c99511398bc90400e380dd11770ec8e614", "patch": "@@ -1,121 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-\n-Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n-\n-  two functions, \"return all edits\" and \"return a random edit\" = move-\n-    leaning toward this model or two functions, \"return the number of\n-    possible edits\" and \"return edit #n\"\n-\n-It would be nice if this could be data-driven, so the two functions\n-could share information:\n-  type vec_modifier = rec(fn (<T> v, uint i) -> ~[T] fun, uint lo, uint di);\n-  const ~[vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...]/~;\n-But that gives me \"error: internal compiler error unimplemented consts\n-that's not a plain literal\".\n-https://github.com/graydon/rust/issues/570\n-\n-vec_edits is not an iter because iters might go away.\n-\n-*/\n-\n-use std::prelude::*;\n-\n-use vec::slice;\n-use vec::len;\n-\n-fn vec_omit<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + slice(v, i + 1u, len(v))\n-}\n-fn vec_dup<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n-}\n-fn vec_swadj<T:copy>(v: ~[T], i: uint) -> ~[T] {\n-    slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n-}\n-fn vec_prefix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, 0u, i) }\n-fn vec_suffix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, i, len(v)) }\n-\n-fn vec_poke<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i + 1u, len(v))\n-}\n-fn vec_insert<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i, len(v))\n-}\n-\n-// Iterates over 0...length, skipping the specified number on each side.\n-fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n-    let i: uint = skip_low;\n-    while i + skip_high <= length { it(i); i += 1u; }\n-}\n-\n-// Returns a bunch of modified versions of v, some of which introduce\n-// new elements (borrowed from xs).\n-fn vec_edits<T:copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n-    let edits: ~[~[T]] = ~[];\n-    let Lv: uint = len(v);\n-\n-    if Lv != 1u {\n-        // When Lv == 1u, this is redundant with omit.\n-        edits.push(~[]);\n-    }\n-    if Lv >= 3u {\n-        // When Lv == 2u, this is redundant with swap.\n-        edits.push(vec::reversed(v));\n-    }\n-    ix(0u, 1u, Lv) {|i| edits += ~[vec_omit(v, i)]; }\n-    ix(0u, 1u, Lv) {|i| edits += ~[vec_dup(v, i)]; }\n-    ix(0u, 2u, Lv) {|i| edits += ~[vec_swadj(v, i)]; }\n-    ix(1u, 2u, Lv) {|i| edits += ~[vec_prefix(v, i)]; }\n-    ix(2u, 1u, Lv) {|i| edits += ~[vec_suffix(v, i)]; }\n-\n-    ix(0u, 1u, len(xs)) {|j|\n-        ix(0u, 1u, Lv) {|i|\n-            edits.push(vec_poke(v, i, xs[j]));\n-        }\n-        ix(0u, 0u, Lv) {|i|\n-            edits.push(vec_insert(v, i, xs[j]));\n-        }\n-    }\n-\n-    edits\n-}\n-\n-// Would be nice if this were built in:\n-// https://github.com/graydon/rust/issues/424\n-fn vec_to_str(v: ~[int]) -> str {\n-    let i = 0u;\n-    let s = \"[\";\n-    while i < len(v) {\n-        s += int::str(v[i]);\n-        if i + 1u < len(v) { s += \", \"; }\n-        i += 1u;\n-    }\n-    return s + \"]\";\n-}\n-\n-fn show_edits(a: ~[int], xs: ~[int]) {\n-    log(error, \"=== Edits of \" + vec_to_str(a) + \" ===\");\n-    let b = vec_edits(a, xs);\n-    ix(0u, 1u, len(b)) {|i| log(error, vec_to_str(b[i])); }\n-}\n-\n-fn demo_edits() {\n-    let xs = ~[7, 8];\n-    show_edits(~[], xs);\n-    show_edits(~[1], xs);\n-    show_edits(~[1, 2], xs);\n-    show_edits(~[1, 2, 3], xs);\n-    show_edits(~[1, 2, 3, 4], xs);\n-}\n-\n-fn main() { demo_edits(); }"}, {"sha": "abc6b1cfc0af1361536a0e066f8b11186fce3f6f", "filename": "src/libfuzzer/rand_util.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=794923c99511398bc90400e380dd11770ec8e614", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::prelude::*;\n-use extra::rand;\n-\n-// random uint less than n\n-fn under(r : rand::rng, n : uint) -> uint {\n-    assert!(n != 0u); r.next() as uint % n\n-}\n-\n-// random choice from a vec\n-fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    assert!(v.len() != 0u); v[under(r, v.len())]\n-}\n-\n-// 1 in n chance of being true\n-fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n-\n-// shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n-    let i = v.len();\n-    while i >= 2u {\n-        // Loop invariant: elements with index >= i have been locked in place.\n-        i -= 1u;\n-        vec::swap(v, i, under(r, i + 1u)); // Lock element i in place.\n-    }\n-}\n-\n-// create a shuffled copy of a vec\n-fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n-    let w = vec::to_mut(v);\n-    shuffle(r, w);\n-    vec::from_mut(w) // Shouldn't this happen automatically?\n-}\n-\n-// sample from a population without replacement\n-//fn sample<T>(r : rand::rng, pop : ~[T], k : uint) -> ~[T] { fail!() }\n-\n-// Two ways to make a weighted choice.\n-// * weighted_choice is O(number of choices) time\n-// * weighted_vec is O(total weight) space\n-type weighted<T> = { weight: uint, item: T };\n-fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    assert!(v.len() != 0u);\n-    let total = 0u;\n-    for {weight: weight, item: _} in v {\n-        total += weight;\n-    }\n-    assert!(total >= 0u);\n-    let chosen = under(r, total);\n-    let so_far = 0u;\n-    for {weight: weight, item: item} in v {\n-        so_far += weight;\n-        if so_far > chosen {\n-            return item;\n-        }\n-    }\n-    std::unreachable();\n-}\n-\n-fn weighted_vec<T:copy>(v : ~[weighted<T>]) -> ~[T] {\n-    let r = ~[];\n-    for {weight: weight, item: item} in v {\n-        let i = 0u;\n-        while i < weight {\n-            r.push(item);\n-            i += 1u;\n-        }\n-    }\n-    r\n-}\n-\n-fn main()\n-{\n-    let r = rand::mk_rng();\n-\n-    log(error, under(r, 5u));\n-    log(error, choice(r, ~[10, 20, 30]));\n-    log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n-\n-    let mut a = ~[1, 2, 3];\n-    shuffle(r, a);\n-    log(error, a);\n-\n-    let i = 0u;\n-    let v = ~[\n-        {weight:1u, item:\"low\"},\n-        {weight:8u, item:\"middle\"},\n-        {weight:1u, item:\"high\"}\n-    ];\n-    let w = weighted_vec(v);\n-\n-    while i < 1000u {\n-        log(error, \"Immed: \" + weighted_choice(r, v));\n-        log(error, \"Fast:  \" + choice(r, w));\n-        i += 1u;\n-    }\n-}"}, {"sha": "987c76dccb4242a80d7cc38a55b64477be9907e3", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -221,7 +221,7 @@ pub static analysis_passes : &'static [(&'static str, &'static str)] = &'static\n /** Transformation Passes */\n pub static transform_passes : &'static [(&'static str, &'static str)] = &'static [\n     (\"adce\",                            \"Aggressive Dead Code Elimination\"),\n-    (\"always-inline\",                   \"Inliner for #[inline(always)] functions\"),\n+    (\"always-inline\",                   \"Inliner for #[inline] functions\"),\n     (\"argpromotion\",                    \"Promote 'by reference' arguments to scalars\"),\n     (\"bb-vectorize\",                    \"Basic-Block Vectorization\"),\n     (\"block-placement\",                 \"Profile Guided Basic Block Placement\"),\n@@ -299,18 +299,27 @@ fn passes_exist() {\n     let mut failed = ~[];\n     unsafe { llvm::LLVMInitializePasses(); }\n     for analysis_passes.each() |&(name,_)| {\n-        if !create_pass(name).is_some() {\n+        let pass = create_pass(name);\n+        if !pass.is_some() {\n             failed.push(name);\n+        } else {\n+            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n     for transform_passes.each() |&(name,_)| {\n-        if !create_pass(name).is_some() {\n+        let pass = create_pass(name);\n+        if !pass.is_some() {\n             failed.push(name);\n+        } else {\n+            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n     for utility_passes.each() |&(name,_)| {\n-        if !create_pass(name).is_some() {\n+        let pass = create_pass(name);\n+        if !pass.is_some() {\n             failed.push(name);\n+        } else {\n+            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n "}, {"sha": "fd22a7e79c6efcae3464baee37bc4c4a77116759", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -77,6 +77,10 @@ fn get_rpaths(os: session::os,\n     // crates they depend on.\n     let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n \n+    // Make backup absolute paths to the libraries. Binaries can\n+    // be moved as long as the crates they link against don't move.\n+    let abs_rpaths = get_absolute_rpaths(libs);\n+\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n@@ -88,9 +92,11 @@ fn get_rpaths(os: session::os,\n     }\n \n     log_rpaths(\"relative\", rel_rpaths);\n+    log_rpaths(\"absolute\", abs_rpaths);\n     log_rpaths(\"fallback\", fallback_rpaths);\n \n     let mut rpaths = rel_rpaths;\n+    rpaths.push_all(abs_rpaths);\n     rpaths.push_all(fallback_rpaths);\n \n     // Remove duplicates\n@@ -160,19 +166,14 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n-    let install_prefix = env!(\"CFG_PREFIX\");\n-\n-    if install_prefix.is_empty() {\n-        fail!(\"rustc compiled without CFG_PREFIX environment variable\");\n-    }\n+fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n+    vec::map(libs, |a| get_absolute_rpath(a) )\n+}\n \n-    let tlib = filesearch::relative_target_lib_path(target_triple);\n-    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n+pub fn get_absolute_rpath(lib: &Path) -> Path {\n+    os::make_absolute(lib).dir_path()\n }\n \n-#[cfg(not(stage0))]\n pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n@@ -198,15 +199,13 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n #[cfg(unix, test)]\n mod test {\n     use core::prelude::*;\n-\n     use core::os;\n-    use core::str;\n \n     // FIXME(#2119): the outer attribute should be #[cfg(unix, test)], then\n     // these redundant #[cfg(test)] blocks can be removed\n     #[cfg(test)]\n     #[cfg(test)]\n-    use back::rpath::{get_install_prefix_rpath};\n+    use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n     use back::rpath::{get_relative_to, get_rpath_relative_to_output};\n     use back::rpath::{minimize_rpaths, rpaths_to_flags};\n     use driver::session;\n@@ -350,4 +349,14 @@ mod test {\n                                                &Path(\"lib/libstd.so\"));\n         assert_eq!(res.to_str(), ~\"@executable_path/../lib\");\n     }\n+\n+    #[test]\n+    fn test_get_absolute_rpath() {\n+        let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n+        debug!(\"test_get_absolute_rpath: %s vs. %s\",\n+               res.to_str(),\n+               os::make_absolute(&Path(\"lib\")).to_str());\n+\n+        assert_eq!(res, os::make_absolute(&Path(\"lib\")));\n+    }\n }"}, {"sha": "43b3397094b526fc56e348e3964ee4c408a24025", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -65,34 +65,24 @@ pub fn source_name(input: &input) -> @str {\n \n pub fn default_configuration(sess: Session, argv0: @str, input: &input) ->\n    ast::crate_cfg {\n-    let libc = match sess.targ_cfg.os {\n-      session::os_win32 => @\"msvcrt.dll\",\n-      session::os_macos => @\"libc.dylib\",\n-      session::os_linux => @\"libc.so.6\",\n-      session::os_android => @\"libc.so\",\n-      session::os_freebsd => @\"libc.so.7\"\n-      // _ { \"libc.so\" }\n+    let (libc, tos) = match sess.targ_cfg.os {\n+        session::os_win32 =>   (@\"msvcrt.dll\", @\"win32\"),\n+        session::os_macos =>   (@\"libc.dylib\", @\"macos\"),\n+        session::os_linux =>   (@\"libc.so.6\",  @\"linux\"),\n+        session::os_android => (@\"libc.so\",    @\"android\"),\n+        session::os_freebsd => (@\"libc.so.7\",  @\"freebsd\")\n     };\n-    let tos = match sess.targ_cfg.os {\n-      session::os_win32 => @\"win32\",\n-      session::os_macos => @\"macos\",\n-      session::os_linux => @\"linux\",\n-      session::os_android => @\"android\",\n-      session::os_freebsd => @\"freebsd\"\n-      // _ { \"libc.so\" }\n-    };\n-\n-    let mk = attr::mk_name_value_item_str;\n \n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 => (@\"little\",@\"x86\",@\"32\"),\n-        abi::X86_64 => (@\"little\",@\"x86_64\",@\"64\"),\n-        abi::Arm => (@\"little\",@\"arm\",@\"32\"),\n-        abi::Mips => (@\"big\",@\"mips\",@\"32\")\n+        abi::X86 =>    (@\"little\", @\"x86\",    @\"32\"),\n+        abi::X86_64 => (@\"little\", @\"x86_64\", @\"64\"),\n+        abi::Arm =>    (@\"little\", @\"arm\",    @\"32\"),\n+        abi::Mips =>   (@\"big\",    @\"mips\",   @\"32\")\n     };\n \n+    let mk = attr::mk_name_value_item_str;\n     return ~[ // Target bindings.\n          attr::mk_word_item(os::FAMILY.to_managed()),\n          mk(@\"target_os\", tos),\n@@ -463,36 +453,38 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    if triple.contains(\"win32\") ||\n-               triple.contains(\"mingw32\") {\n-            Some(session::os_win32)\n-        } else if triple.contains(\"darwin\") {\n-            Some(session::os_macos)\n-        } else if triple.contains(\"android\") {\n-            Some(session::os_android)\n-        } else if triple.contains(\"linux\") {\n-            Some(session::os_linux)\n-        } else if triple.contains(\"freebsd\") {\n-            Some(session::os_freebsd)\n-        } else { None }\n+    for os_names.each |&(name, os)| {\n+        if triple.contains(name) { return Some(os) }\n+    }\n+    None\n }\n+static os_names : &'static [(&'static str, session::os)] = &'static [\n+    (\"mingw32\", session::os_win32),\n+    (\"win32\",   session::os_win32),\n+    (\"darwin\",  session::os_macos),\n+    (\"android\", session::os_android),\n+    (\"linux\",   session::os_linux),\n+    (\"freebsd\", session::os_freebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    if triple.contains(\"i386\") ||\n-        triple.contains(\"i486\") ||\n-               triple.contains(\"i586\") ||\n-               triple.contains(\"i686\") ||\n-               triple.contains(\"i786\") {\n-            Some(abi::X86)\n-        } else if triple.contains(\"x86_64\") {\n-            Some(abi::X86_64)\n-        } else if triple.contains(\"arm\") ||\n-                      triple.contains(\"xscale\") {\n-            Some(abi::Arm)\n-        } else if triple.contains(\"mips\") {\n-            Some(abi::Mips)\n-        } else { None }\n+    for architecture_abis.each |&(arch, abi)| {\n+        if triple.contains(arch) { return Some(abi) }\n+    }\n+    None\n }\n+static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'static [\n+    (\"i386\",   abi::X86),\n+    (\"i486\",   abi::X86),\n+    (\"i586\",   abi::X86),\n+    (\"i686\",   abi::X86),\n+    (\"i786\",   abi::X86),\n+\n+    (\"x86_64\", abi::X86_64),\n+\n+    (\"arm\",    abi::Arm),\n+    (\"xscale\", abi::Arm),\n+\n+    (\"mips\",   abi::Mips)];\n \n pub fn build_target_config(sopts: @session::options,\n                            demitter: diagnostic::Emitter)\n@@ -529,25 +521,6 @@ pub fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n-#[cfg(stage0)]\n-pub fn host_triple() -> ~str {\n-    // Get the host triple out of the build environment. This ensures that our\n-    // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n-    // normalize all ix86 architectures to i386.\n-    //\n-    // Instead of grabbing the host triple (for the current host), we grab (at\n-    // compile time) the target triple that this rustc is built with and\n-    // calling that (at runtime) the host triple.\n-    let ht = env!(\"CFG_COMPILER_TRIPLE\");\n-    return if ht != ~\"\" {\n-            ht\n-        } else {\n-            fail!(\"rustc built without CFG_COMPILER_TRIPLE\")\n-        };\n-}\n-\n-#[cfg(not(stage0))]\n pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've"}, {"sha": "5d5a5e736bce186fd4e2d23bf578c4a09cce0757", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 207, "deletions": 5, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -224,13 +224,50 @@ pub type SectionIteratorRef = *SectionIterator_opaque;\n pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n \n+pub mod debuginfo {\n+    use super::{ValueRef};\n+\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *DIBuilder_opaque;\n+\n+    pub type DIDescriptor = ValueRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12\n+    }\n+}\n+\n pub mod llvm {\n     use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef,PassRef};\n-\n+    use super::{ValueRef, PassRef};\n+    use super::debuginfo::*;\n     use core::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n \n     #[link_args = \"-Lrustllvm -lrustllvm\"]\n@@ -929,6 +966,12 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef, MoveAfter: BasicBlockRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef, MoveBefore: BasicBlockRef);\n+\n         /* Operations on instructions */\n         #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionParent(Inst: ValueRef)\n@@ -1641,6 +1684,9 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMCreatePass(PassName:*c_char) -> PassRef;\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMDestroyPass(P: PassRef);\n+\n         /** Adds a verification pass. */\n         #[fast_ffi]\n         pub unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n@@ -1885,6 +1931,164 @@ pub mod llvm {\n                                     AlignStack: Bool, Dialect: c_uint)\n                                  -> ValueRef;\n \n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateCompileUnit(\n+            Builder: DIBuilderRef,\n+            Lang: c_uint,\n+            File: *c_char,\n+            Dir: *c_char,\n+            Producer: *c_char,\n+            isOptimized: bool,\n+            Flags: *c_char,\n+            RuntimeVer: c_uint,\n+            SplitName: *c_char);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateFile(\n+            Builder: DIBuilderRef,\n+            Filename: *c_char,\n+            Directory: *c_char) -> DIFile;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateSubroutineType(\n+            Builder: DIBuilderRef,\n+            File: DIFile,\n+            ParameterTypes: DIArray) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateFunction(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            LinkageName: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            isLocalToUnit: bool,\n+            isDefinition: bool,\n+            ScopeLine: c_uint,\n+            Flags: c_uint,\n+            isOptimized: bool,\n+            Fn: ValueRef,\n+            TParam: ValueRef,\n+            Decl: ValueRef) -> DISubprogram;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateBasicType(\n+            Builder: DIBuilderRef,\n+            Name: *c_char,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Encoding: c_uint) -> DIBasicType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreatePointerType(\n+            Builder: DIBuilderRef,\n+            PointeeTy: DIType,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Name: *c_char) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateStructType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Flags: c_uint,\n+            DerivedFrom: DIType,\n+            Elements: DIArray,\n+            RunTimeLang: c_uint,\n+            VTableHolder: ValueRef) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateMemberType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            OffsetInBits: c_ulonglong,\n+            Flags: c_uint,\n+            Ty: DIType) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateLexicalBlock(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            File: DIFile,\n+            Line: c_uint,\n+            Col: c_uint) -> DILexicalBlock;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateLocalVariable(\n+            Builder: DIBuilderRef,\n+            Tag: c_uint,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            AlwaysPreserve: bool,\n+            Flags: c_uint,\n+            ArgNo: c_uint) -> DIVariable;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateArrayType(\n+            Builder: DIBuilderRef,\n+            Size: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Ty: DIType,\n+            Subscripts: DIArray) -> DIType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateVectorType(\n+            Builder: DIBuilderRef,\n+            Size: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Ty: DIType,\n+            Subscripts: DIArray) -> DIType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderGetOrCreateSubrange(\n+            Builder: DIBuilderRef,\n+            Lo: c_longlong,\n+            Count: c_longlong) -> DISubrange;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderGetOrCreateArray(\n+            Builder: DIBuilderRef,\n+            Ptr: *DIDescriptor,\n+            Count: c_uint) -> DIArray;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderInsertDeclareAtEnd(\n+            Builder: DIBuilderRef,\n+            Val: ValueRef,\n+            VarInfo: DIVariable,\n+            InsertAtEnd: BasicBlockRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderInsertDeclareBefore(\n+            Builder: DIBuilderRef,\n+            Val: ValueRef,\n+            VarInfo: DIVariable,\n+            InsertBefore: ValueRef) -> ValueRef;\n     }\n }\n \n@@ -1988,9 +2192,7 @@ pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n             let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n             let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n             let args = vec::from_elem(n_args, 0 as TypeRef);\n-            unsafe {\n-                llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-            }\n+            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n             // See [Note at-str]\n             return fmt!(\"fn(%s) -> %s\",\n                         tys_str(names, outer, args),"}, {"sha": "5d5d7582b5f31fc22d2c9b49f7407e86abf7c4ee", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1184,7 +1184,7 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n     for index.each |elt| {\n         let h = elt.val.hash() as uint;\n-        buckets[h % 256].push(*elt);\n+        buckets[h % 256].push(copy *elt);\n     }\n \n     let mut buckets_frozen = ~[];"}, {"sha": "585704381b69e14eec6de383e5e5b8e47a2bd236", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -204,35 +204,33 @@ fn get_metadata_section(os: os,\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-            let name = unsafe { str::raw::from_c_str(name_buf) };\n+            let name = str::raw::from_c_str(name_buf);\n             debug!(\"get_metadata_section: name %s\", name);\n             if name == read_meta_section_name(os) {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = None;\n-                unsafe {\n-                    let cvbuf: *u8 = cast::transmute(cbuf);\n-                    let vlen = encoder::metadata_encoding_version.len();\n-                    debug!(\"checking %u bytes of metadata-version stamp\",\n-                           vlen);\n-                    let minsz = uint::min(vlen, csz);\n-                    let mut version_ok = false;\n-                    do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n-                        version_ok = (buf0 ==\n-                                      encoder::metadata_encoding_version);\n-                    }\n-                    if !version_ok { return None; }\n+                let cvbuf: *u8 = cast::transmute(cbuf);\n+                let vlen = encoder::metadata_encoding_version.len();\n+                debug!(\"checking %u bytes of metadata-version stamp\",\n+                       vlen);\n+                let minsz = uint::min(vlen, csz);\n+                let mut version_ok = false;\n+                do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n+                    version_ok = (buf0 ==\n+                                  encoder::metadata_encoding_version);\n+                }\n+                if !version_ok { return None; }\n \n-                    let cvbuf1 = ptr::offset(cvbuf, vlen);\n-                    debug!(\"inflating %u bytes of compressed metadata\",\n-                           csz - vlen);\n-                    do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n-                        let inflated = flate::inflate_bytes(bytes);\n-                        found = Some(@(inflated));\n-                    }\n-                    if found != None {\n-                        return found;\n-                    }\n+                let cvbuf1 = ptr::offset(cvbuf, vlen);\n+                debug!(\"inflating %u bytes of compressed metadata\",\n+                       csz - vlen);\n+                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n+                    let inflated = flate::inflate_bytes(bytes);\n+                    found = Some(@(inflated));\n+                }\n+                if found != None {\n+                    return found;\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);"}, {"sha": "925b1f506d75d31e675fd692615052ed426baac7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -15,7 +15,6 @@ use cstore = metadata::cstore;\n use driver::session::Session;\n use e = metadata::encoder;\n use metadata::decoder;\n-use metadata::encoder;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tyencode;"}, {"sha": "be87beba7784b25213d98f46f86c6d761fe81bdb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -82,7 +82,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        for self.dfcx_loans.each_bit_on_entry(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             if !op(loan) {\n                 return false;\n@@ -134,7 +134,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        for self.dfcx_loans.each_gen_bit(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n             result.push(loan_index);\n         }\n         return result;"}, {"sha": "5431a0a299807f713d4e85c838af8ed86c3e1aa5", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -105,7 +105,8 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n         mc::cat_implicit_self(*) |\n         mc::cat_copied_upvar(*) |\n         mc::cat_deref(_, _, mc::region_ptr(*)) |\n-        mc::cat_deref(_, _, mc::gc_ptr(*)) => {\n+        mc::cat_deref(_, _, mc::gc_ptr(*)) |\n+        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n             bccx.span_err(\n                 cmt0.span,\n                 fmt!(\"cannot move out of %s\",\n@@ -129,8 +130,7 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n         mc::cat_rvalue(*) |\n         mc::cat_local(*) |\n         mc::cat_arg(*) |\n-        mc::cat_self(*) |\n-        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+        mc::cat_self(*) => {\n             true\n         }\n "}, {"sha": "d7186ad933355d47bb23e3d6c24cdf2ac8c5f477", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -775,17 +775,17 @@ impl BorrowckCtxt {\n }\n \n impl DataFlowOperator for LoanDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // loans from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }"}, {"sha": "3b1c451d0a6ed6132c9b8bd2ed33567ab67190fd", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -504,7 +504,7 @@ impl FlowedMoveData {\n \n         let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n \n-        for self.dfcx_moves.each_bit_on_entry(id) |index| {\n+        for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             if base_indices.contains(&moved_path) {\n@@ -560,7 +560,7 @@ impl FlowedMoveData {\n             }\n         };\n \n-        for self.dfcx_assign.each_bit_on_entry(id) |index| {\n+        for self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n             let assignment = &self.move_data.var_assignments[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 return false;\n@@ -571,34 +571,34 @@ impl FlowedMoveData {\n }\n \n impl DataFlowOperator for MoveDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }\n }\n \n impl DataFlowOperator for AssignDataFlowOperator {\n-    #[inline(always)]\n+    #[inline]\n     fn initial_value(&self) -> bool {\n         false // no assignments in scope by default\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn walk_closures(&self) -> bool {\n         true\n     }"}, {"sha": "b4942fba05da1f8dc525d28ac601388cd4e693fb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 72, "deletions": 21, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -22,6 +22,7 @@ use core::cast;\n use core::io;\n use core::uint;\n use core::vec;\n+use core::hashmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::id_range;\n@@ -37,16 +38,16 @@ pub struct DataFlowContext<O> {\n     /// the data flow operator\n     priv oper: O,\n \n-    /// range of ids that appear within the item in question\n-    priv id_range: id_range,\n-\n     /// number of bits to propagate per id\n     priv bits_per_id: uint,\n \n     /// number of words we will use to store bits_per_id.\n     /// equal to bits_per_id/uint::bits rounded up.\n     priv words_per_id: uint,\n \n+    // mapping from node to bitset index.\n+    priv nodeid_to_bitset: HashMap<ast::node_id,uint>,\n+\n     // Bit sets per id.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n     // `id_range`, there is a range of words equal to `words_per_id`.\n@@ -108,19 +109,17 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n                id_range, bits_per_id, words_per_id);\n \n-        let len = (id_range.max - id_range.min) as uint * words_per_id;\n-        let gens = vec::from_elem(len, 0);\n-        let kills = vec::from_elem(len, 0);\n-        let elem = if oper.initial_value() {uint::max_value} else {0};\n-        let on_entry = vec::from_elem(len, elem);\n+        let gens = ~[];\n+        let kills = ~[];\n+        let on_entry = ~[];\n \n         DataFlowContext {\n             tcx: tcx,\n             method_map: method_map,\n             words_per_id: words_per_id,\n+            nodeid_to_bitset: HashMap::new(),\n             bits_per_id: bits_per_id,\n             oper: oper,\n-            id_range: id_range,\n             gens: gens,\n             kills: kills,\n             on_entry: on_entry\n@@ -149,7 +148,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n     }\n \n-    fn apply_gen_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_gen_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n         debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n@@ -164,7 +163,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn apply_kill(&self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n         debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n@@ -174,18 +173,56 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn compute_id_range(&self, absolute_id: ast::node_id) -> (uint, uint) {\n-        assert!(absolute_id >= self.id_range.min);\n-        assert!(absolute_id < self.id_range.max);\n+    fn compute_id_range_frozen(&self, id: ast::node_id) -> (uint, uint) {\n+        let n = *self.nodeid_to_bitset.get(&id);\n+        let start = n * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        (start, end)\n+    }\n \n-        let relative_id = absolute_id - self.id_range.min;\n-        let start = (relative_id as uint) * self.words_per_id;\n+    fn compute_id_range(&mut self, id: ast::node_id) -> (uint, uint) {\n+        let mut expanded = false;\n+        let len = self.nodeid_to_bitset.len();\n+        let n = do self.nodeid_to_bitset.find_or_insert_with(id) |_| {\n+            expanded = true;\n+            len\n+        };\n+        if expanded {\n+            let entry = if self.oper.initial_value() { uint::max_value } else {0};\n+            for self.words_per_id.times {\n+                self.gens.push(0);\n+                self.kills.push(0);\n+                self.on_entry.push(entry);\n+            }\n+        }\n+        let start = *n * self.words_per_id;\n         let end = start + self.words_per_id;\n+\n+        assert!(start < self.gens.len());\n+        assert!(end <= self.gens.len());\n+        assert!(self.gens.len() == self.kills.len());\n+        assert!(self.gens.len() == self.on_entry.len());\n+\n         (start, end)\n     }\n \n \n-    pub fn each_bit_on_entry(&self,\n+    pub fn each_bit_on_entry_frozen(&self,\n+                                    id: ast::node_id,\n+                                    f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+        if !self.nodeid_to_bitset.contains_key(&id) {\n+            return true;\n+        }\n+        let (start, end) = self.compute_id_range_frozen(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f)\n+    }\n+\n+    pub fn each_bit_on_entry(&mut self,\n                              id: ast::node_id,\n                              f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n@@ -198,7 +235,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    pub fn each_gen_bit(&self,\n+    pub fn each_gen_bit(&mut self,\n                         id: ast::node_id,\n                         f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n@@ -210,6 +247,20 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n+    pub fn each_gen_bit_frozen(&self,\n+                               id: ast::node_id,\n+                               f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit in the gen set for `id`.\n+        if !self.nodeid_to_bitset.contains_key(&id) {\n+            return true;\n+        }\n+        let (start, end) = self.compute_id_range_frozen(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n     fn each_bit(&self,\n                 words: &[uint],\n                 f: &fn(uint) -> bool) -> bool {\n@@ -285,8 +336,8 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n                 pprust::node_pat(ps, pat) => (ps, pat.id)\n             };\n \n-            if id >= self.id_range.min || id < self.id_range.max {\n-                let (start, end) = self.compute_id_range(id);\n+            if self.nodeid_to_bitset.contains_key(&id) {\n+                let (start, end) = self.compute_id_range_frozen(id);\n                 let on_entry = vec::slice(self.on_entry, start, end);\n                 let entry_str = bits_to_str(on_entry);\n \n@@ -965,7 +1016,7 @@ fn join_bits<O:DataFlowOperator>(oper: &O,\n     bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n }\n \n-#[inline(always)]\n+#[inline]\n fn bitwise(out_vec: &mut [uint],\n            in_vec: &[uint],\n            op: &fn(uint, uint) -> uint) -> bool {"}, {"sha": "08cba4d51cd342025131dc9fb727c7384e4621a8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -749,11 +749,7 @@ impl Liveness {\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                let len = { // FIXME(#5074) stage0\n-                    let loop_scope = &mut *self.loop_scope;\n-                    loop_scope.len()\n-                };\n-                if len == 0 {\n+                if self.loop_scope.len() == 0 {\n                     self.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method..."}, {"sha": "3e656b3e5940509cb7ff8be7b785101bef842afd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -4845,7 +4845,7 @@ impl Resolver {\n         let mut smallest = 0;\n         for maybes.eachi |i, &other| {\n \n-            values[i] = str::levdistance(name, other);\n+            values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "0976407b0bd0f52045184a7379a9a34c92097638", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -47,7 +47,6 @@\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n-use core::str;\n use core::vec;\n \n use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n@@ -165,7 +164,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n-                return CEnum(discrs.min(), discrs.max());\n+                return CEnum(*discrs.iter().min().unwrap(), *discrs.iter().max().unwrap());\n             }\n \n             if cases.len() == 1 {\n@@ -509,7 +508,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n         }\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n-            let max_sz = cases.map(|s| s.size).max();\n+            let max_sz = cases.iter().transform(|x| x.size).max().unwrap();\n             let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n@@ -577,7 +576,7 @@ fn padding(size: u64) -> ValueRef {\n }\n \n // XXX this utility routine should be somewhere more general\n-#[inline(always)]\n+#[inline]\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)"}, {"sha": "d7d21707f40fed871c2340b4a8b1e2a78c45d15d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -71,7 +71,6 @@ use core::libc::c_uint;\n use core::str;\n use core::uint;\n use core::vec;\n-use core::local_data;\n use extra::time;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n@@ -1318,26 +1317,38 @@ pub fn cleanup_and_leave(bcx: block,\n \n         match cur.kind {\n             block_scope(inf) if !inf.empty_cleanups() => {\n-                let (sub_cx, inf_cleanups) = {\n-                    let inf = &mut *inf; // FIXME(#5074) workaround stage0\n+                let (sub_cx, dest, inf_cleanups) = {\n+                    let inf = &mut *inf;\n+                    let mut skip = 0;\n+                    let mut dest = None;\n                     {\n-                        let r = vec::find((*inf).cleanup_paths, |cp| cp.target == leave);\n+                        let r = vec::rfind((*inf).cleanup_paths, |cp| cp.target == leave);\n                         for r.iter().advance |cp| {\n-                            Br(bcx, cp.dest);\n-                            return;\n+                            if cp.size == inf.cleanups.len() {\n+                                Br(bcx, cp.dest);\n+                                return;\n+                            }\n+\n+                            skip = cp.size;\n+                            dest = Some(cp.dest);\n                         }\n                     }\n                     let sub_cx = sub_block(bcx, \"cleanup\");\n                     Br(bcx, sub_cx.llbb);\n                     inf.cleanup_paths.push(cleanup_path {\n                         target: leave,\n+                        size: inf.cleanups.len(),\n                         dest: sub_cx.llbb\n                     });\n-                    (sub_cx, copy inf.cleanups)\n+                    (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n                 };\n                 bcx = trans_block_cleanups_(sub_cx,\n                                             inf_cleanups,\n                                             is_lpad);\n+                for dest.iter().advance |&dest| {\n+                    Br(bcx, dest);\n+                    return;\n+                }\n             }\n             _ => ()\n         }\n@@ -1897,6 +1908,12 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     finish(bcx);\n     cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n \n+    // Put return block after all other blocks.\n+    // This somewhat improves single-stepping experience in debugger.\n+    unsafe {\n+        llvm::LLVMMoveBasicBlockAfter(fcx.llreturn, bcx.llbb);\n+    }\n+\n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }\n@@ -3033,7 +3050,7 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n \n // Writes the current ABI version into the crate.\n pub fn write_abi_version(ccx: &mut CrateContext) {\n-    mk_global(ccx, ~\"rust_abi_version\", C_uint(ccx, abi::abi_version),\n+    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n \n@@ -3091,6 +3108,9 @@ pub fn trans_crate(sess: session::Session,\n     fill_crate_map(ccx, ccx.crate_map);\n     glue::emit_tydescs(ccx);\n     write_abi_version(ccx);\n+    if ccx.sess.opts.debuginfo {\n+        debuginfo::finalize(ccx);\n+    }\n \n     // Translate the metadata.\n     write_metadata(ccx, crate);\n@@ -3120,4 +3140,3 @@ pub fn trans_crate(sess: session::Session,\n \n     return (llcx, llmod, link_meta);\n }\n-"}, {"sha": "a55e89747f5b2eff905a761e01bae67f44a8b912", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -618,13 +618,11 @@ pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n    ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-        unsafe {\n-            count_insn(cx, \"inboundsgep\");\n+        count_insn(cx, \"inboundsgep\");\n         return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                            vec::raw::to_ptr(Indices),\n                                            Indices.len() as c_uint,\n                                            noname());\n-        }\n     }\n }\n \n@@ -1072,11 +1070,9 @@ pub fn Trap(cx: block) {\n         });\n         assert!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n-        unsafe {\n-            count_insn(cx, \"trap\");\n-            llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n-                                Args.len() as c_uint, noname());\n-        }\n+        count_insn(cx, \"trap\");\n+        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n+                            Args.len() as c_uint, noname());\n     }\n }\n "}, {"sha": "c368ab5c9bdf52ba7e757b08a3a4c2d33d509762", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -553,7 +553,7 @@ pub fn make_opaque_cbox_drop_glue(\n         ast::BorrowedSigil => bcx,\n         ast::ManagedSigil => {\n             glue::decr_refcnt_maybe_free(\n-                bcx, Load(bcx, cboxptr),\n+                bcx, Load(bcx, cboxptr), Some(cboxptr),\n                 ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }\n         ast::OwnedSigil => {"}, {"sha": "ff98e5a177f2ee26df59c98302fcfac808523ebe", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -325,11 +325,17 @@ pub enum cleanup {\n // target: none means the path ends in an resume instruction\n pub struct cleanup_path {\n     target: Option<BasicBlockRef>,\n+    size: uint,\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(scope_info: &mut scope_info) {\n-    if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n+pub fn shrink_scope_clean(scope_info: &mut scope_info, size: uint) {\n+    scope_info.landing_pad = None;\n+    scope_info.cleanup_paths = scope_info.cleanup_paths.iter()\n+            .take_while(|&cu| cu.size <= size).transform(|&x|x).collect();\n+}\n+\n+pub fn grow_scope_clean(scope_info: &mut scope_info) {\n     scope_info.landing_pad = None;\n }\n \n@@ -374,7 +380,7 @@ pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n         scope_info.cleanups.push(\n             clean(|a| glue::drop_ty_root(a, root, rooted, t),\n                   cleanup_type));\n-        scope_clean_changed(scope_info);\n+        grow_scope_clean(scope_info);\n     }\n }\n \n@@ -388,7 +394,7 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n         scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n                        cleanup_type));\n-        scope_clean_changed(scope_info);\n+        grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n@@ -402,7 +408,7 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n         scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n                        cleanup_type));\n-        scope_clean_changed(scope_info);\n+        grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_return_to_mut(bcx: block,\n@@ -434,7 +440,7 @@ pub fn add_clean_return_to_mut(bcx: block,\n                                                  filename_val,\n                                                  line_val),\n                 normal_exit_only));\n-        scope_clean_changed(scope_info);\n+        grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n@@ -451,7 +457,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     do in_scope_cx(cx) |scope_info| {\n         scope_info.cleanups.push(clean_temp(ptr, free_fn,\n                                       normal_exit_and_unwind));\n-        scope_clean_changed(scope_info);\n+        grow_scope_clean(scope_info);\n     }\n }\n \n@@ -474,7 +480,7 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n                             vec::slice(scope_info.cleanups,\n                                       *i + 1u,\n                                       scope_info.cleanups.len()));\n-            scope_clean_changed(scope_info);\n+            shrink_scope_clean(scope_info, *i);\n         }\n     }\n }"}, {"sha": "d6c7472424f7afdcabf41f72e4eec91296e1d6da", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -148,7 +148,7 @@ impl CrateContext {\n             lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n-                Some(debuginfo::mk_ctxt(name.to_owned()))\n+                Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n             } else {\n                 None\n             };\n@@ -211,9 +211,7 @@ impl CrateContext {\n                   int_type: int_type,\n                   float_type: float_type,\n                   opaque_vec_type: T_opaque_vec(targ_cfg),\n-                  builder: BuilderRef_res(unsafe {\n-                      llvm::LLVMCreateBuilderInContext(llcx)\n-                  }),\n+                  builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   shape_cx: mk_ctxt(llmod),\n                   crate_map: crate_map,\n                   uses_gc: false,"}, {"sha": "269451b13070dc6cc5c9f0ec4ddde360153c8c5f", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 454, "deletions": 727, "changes": 1181, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,31 +11,28 @@\n use core::prelude::*;\n \n use driver::session;\n-use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n-use middle::trans::context::task_llcx;\n+use lib::llvm::{ValueRef, ModuleRef, ContextRef};\n+use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::cast;\n use core::hashmap::HashMap;\n use core::libc;\n-use core::option;\n+use core::libc::c_uint;\n+use core::cmp;\n use core::ptr;\n-use core::str;\n+use core::str::as_c_str;\n use core::sys;\n use core::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n-static LLVMDebugVersion: int = (9 << 16);\n-\n static DW_LANG_RUST: int = 0x9000;\n-static DW_VIRTUALITY_none: int = 0;\n \n static CompileUnitTag: int = 17;\n static FileDescriptorTag: int = 41;\n@@ -59,302 +56,169 @@ static DW_ATE_signed_char: int = 0x06;\n static DW_ATE_unsigned: int = 0x07;\n static DW_ATE_unsigned_char: int = 0x08;\n \n-fn llstr(s: &str) -> ValueRef {\n-    do str::as_c_str(s) |sbuf| {\n-        unsafe {\n-            llvm::LLVMMDStringInContext(task_llcx(),\n-                                        sbuf,\n-                                        s.len() as libc::c_uint)\n-        }\n-    }\n-}\n-fn lltag(lltag: int) -> ValueRef {\n-    lli32(LLVMDebugVersion | lltag)\n-}\n-fn lli32(val: int) -> ValueRef {\n-    C_i32(val as i32)\n-}\n-fn lli64(val: int) -> ValueRef {\n-    C_i64(val as i64)\n-}\n-fn lli1(bval: bool) -> ValueRef {\n-    C_i1(bval)\n-}\n-fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMMDNodeInContext(task_llcx(),\n-                                  vec::raw::to_ptr(elems),\n-                                  elems.len() as libc::c_uint)\n-    }\n-}\n-fn llunused() -> ValueRef {\n-    lli32(0x0)\n-}\n-fn llnull() -> ValueRef {\n-    unsafe {\n-        cast::transmute(ptr::null::<ValueRef>())\n-    }\n-}\n-\n-fn add_named_metadata(cx: &CrateContext, name: ~str, val: ValueRef) {\n-    str::as_c_str(name, |sbuf| {\n-        unsafe {\n-            llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n-        }\n-    })\n-}\n-\n ////////////////\n \n pub struct DebugContext {\n-    llmetadata: metadata_cache,\n     names: namegen,\n-    crate_file: ~str\n-}\n-\n-pub fn mk_ctxt(crate: ~str) -> DebugContext {\n-    DebugContext {\n-        llmetadata: @mut HashMap::new(),\n-        names: new_namegen(),\n-        crate_file: crate\n+    crate_file: ~str,\n+    llcontext: ContextRef,\n+    builder: DIBuilderRef,\n+    curr_loc: (uint, uint),\n+    created_files: HashMap<~str, DIFile>,\n+    created_functions: HashMap<ast::node_id, DISubprogram>,\n+    created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n+    created_types: HashMap<uint, DIType>\n+}\n+\n+impl DebugContext {\n+    pub fn new(llmod: ModuleRef, crate: ~str) -> DebugContext {\n+        debug!(\"DebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return DebugContext {\n+            names: new_namegen(),\n+            crate_file: crate,\n+            llcontext: llcontext,\n+            builder: builder,\n+            curr_loc: (0, 0),\n+            created_files: HashMap::new(),\n+            created_functions: HashMap::new(),\n+            created_blocks: HashMap::new(),\n+            created_types: HashMap::new(),\n+        };\n     }\n }\n \n-fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let mut existing = match cache.pop(&mdtag) {\n-        Some(arr) => arr, None => ~[]\n-    };\n-    existing.push(val);\n-    cache.insert(mdtag, existing);\n-}\n-\n-struct Metadata<T> {\n-    node: ValueRef,\n-    data: T\n-}\n-\n-struct FileMetadata {\n-    path: ~str\n-}\n-struct CompileUnitMetadata {\n-    name: ~str\n-}\n-struct SubProgramMetadata {\n-    id: ast::node_id\n-}\n-struct LocalVarMetadata {\n-    id: ast::node_id\n-}\n-struct TyDescMetadata {\n-    hash: uint\n-}\n-struct BlockMetadata {\n-    start: codemap::Loc,\n-    end: codemap::Loc\n-}\n-struct ArgumentMetadata {\n-    id: ast::node_id\n-}\n-struct RetvalMetadata {\n-    id: ast::node_id\n+#[inline]\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+    cx.dbg_cx.get_mut_ref()\n }\n \n-type metadata_cache = @mut HashMap<int, ~[debug_metadata]>;\n-\n-enum debug_metadata {\n-    file_metadata(@Metadata<FileMetadata>),\n-    compile_unit_metadata(@Metadata<CompileUnitMetadata>),\n-    subprogram_metadata(@Metadata<SubProgramMetadata>),\n-    local_var_metadata(@Metadata<LocalVarMetadata>),\n-    tydesc_metadata(@Metadata<TyDescMetadata>),\n-    block_metadata(@Metadata<BlockMetadata>),\n-    argument_metadata(@Metadata<ArgumentMetadata>),\n-    retval_metadata(@Metadata<RetvalMetadata>),\n+#[inline]\n+fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx.get_ref().builder\n }\n \n-fn cast_safely<T:Copy,U>(val: T) -> U {\n+/// Create any deferred debug metadata nodes\n+pub fn finalize(cx: @mut CrateContext) {\n+    debug!(\"finalize\");\n+    create_compile_unit(cx);\n     unsafe {\n-        let val2 = val;\n-        return cast::transmute(val2);\n-    }\n-}\n-\n-fn md_from_metadata<T>(val: debug_metadata) -> T {\n-    match val {\n-      file_metadata(md) => cast_safely(md),\n-      compile_unit_metadata(md) => cast_safely(md),\n-      subprogram_metadata(md) => cast_safely(md),\n-      local_var_metadata(md) => cast_safely(md),\n-      tydesc_metadata(md) => cast_safely(md),\n-      block_metadata(md) => cast_safely(md),\n-      argument_metadata(md) => cast_safely(md),\n-      retval_metadata(md) => cast_safely(md)\n-    }\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n+    };\n }\n \n-fn cached_metadata<T:Copy>(cache: metadata_cache,\n-                            mdtag: int,\n-                            eq_fn: &fn(md: T) -> bool)\n-                         -> Option<T> {\n-    if cache.contains_key(&mdtag) {\n-        let items = cache.get(&mdtag);\n-        for items.each |item| {\n-            let md: T = md_from_metadata::<T>(*item);\n-            if eq_fn(md) {\n-                return option::Some(md);\n-            }\n-        }\n-    }\n-    return option::None;\n+fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n+    };\n }\n \n-fn create_compile_unit(cx: &mut CrateContext) -> @Metadata<CompileUnitMetadata> {\n-    let cache = get_cache(cx);\n-    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-    let tg = CompileUnitTag;\n-    match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n-                        |md| md.data.name == crate_name) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+fn create_compile_unit(cx: @mut CrateContext) {\n+    let dcx = dbg_cx(cx);\n+    let crate_name: &str = dcx.crate_file;\n+    let work_dir = cx.sess.working_dir.to_str();\n+    let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n+\n+    do as_c_str(crate_name) |crate_name| {\n+    do as_c_str(work_dir) |work_dir| {\n+    do as_c_str(producer) |producer| {\n+    do as_c_str(\"\") |flags| {\n+    do as_c_str(\"\") |split_name| { unsafe {\n+        llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n+            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+            cx.sess.opts.optimize != session::No,\n+            flags, 0, split_name);\n+    }}}}}};\n+}\n+\n+fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n+    match dbg_cx(cx).created_files.find_equiv(&full_path) {\n+        Some(file_md) => return *file_md,\n+        None => ()\n     }\n \n-    let (_, work_dir) = get_file_path_and_dir(\n-        cx.sess.working_dir.to_str(), crate_name);\n-    let unit_metadata = ~[lltag(tg),\n-                         llunused(),\n-                         lli32(DW_LANG_RUST),\n-                         llstr(crate_name),\n-                         llstr(work_dir),\n-                         llstr(env!(\"CFG_VERSION\")),\n-                         lli1(true), // deprecated: main compile unit\n-                         lli1(cx.sess.opts.optimize != session::No),\n-                         llstr(\"\"), // flags (???)\n-                         lli32(0) // runtime version (???)\n-                        ];\n-    let unit_node = llmdnode(unit_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-    let mdval = @Metadata {\n-        node: unit_node,\n-        data: CompileUnitMetadata {\n-            name: crate_name\n-        }\n-    };\n-    update_cache(cache, tg, compile_unit_metadata(mdval));\n+    debug!(\"create_file: %s\", full_path);\n \n-    return mdval;\n-}\n+    let work_dir = cx.sess.working_dir.to_str();\n+    let file_name =\n+        if full_path.starts_with(work_dir) {\n+            full_path.slice(work_dir.len() + 1u, full_path.len())\n+        } else {\n+            full_path\n+        };\n \n-fn get_cache(cx: &CrateContext) -> metadata_cache {\n-    cx.dbg_cx.get_ref().llmetadata\n-}\n+    let file_md =\n+        do as_c_str(file_name) |file_name| {\n+        do as_c_str(work_dir) |work_dir| { unsafe {\n+            llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+        }}};\n \n-fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    (if full_path.starts_with(work_dir) {\n-        full_path.slice(work_dir.len() + 1u,\n-                   full_path.len()).to_owned()\n-    } else {\n-        full_path.to_owned()\n-    }, work_dir.to_owned())\n+    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_md);\n+    return file_md;\n }\n \n-fn create_file(cx: &mut CrateContext, full_path: ~str)\n-    -> @Metadata<FileMetadata> {\n-    let cache = get_cache(cx);;\n-    let tg = FileDescriptorTag;\n-    match cached_metadata::<@Metadata<FileMetadata>>(\n-        cache, tg, |md| md.data.path == full_path) {\n-        option::Some(md) => return md,\n-        option::None => ()\n-    }\n-\n-    let (file_path, work_dir) =\n-        get_file_path_and_dir(cx.sess.working_dir.to_str(),\n-                              full_path);\n-    let unit_node = create_compile_unit(cx).node;\n-    let file_md = ~[lltag(tg),\n-                   llstr(file_path),\n-                   llstr(work_dir),\n-                   unit_node];\n-    let val = llmdnode(file_md);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: FileMetadata {\n-            path: full_path\n-        }\n-    };\n-    update_cache(cache, tg, file_metadata(mdval));\n-    return mdval;\n+/// Return codemap::Loc corresponding to the beginning of the span\n+fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n+    return cx.sess.codemap.lookup_char_pos(span.lo);\n }\n \n-fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n-    cm.lookup_char_pos(sp.lo).line\n-}\n+fn create_block(bcx: block) -> DILexicalBlock {\n+    let mut bcx = bcx;\n+    let cx = bcx.ccx();\n \n-fn create_block(mut cx: block) -> @Metadata<BlockMetadata> {\n-    let cache = get_cache(cx.ccx());\n-    while cx.node_info.is_none() {\n-        match cx.parent {\n-          Some(b) => cx = b,\n+    while bcx.node_info.is_none() {\n+        match bcx.parent {\n+          Some(b) => bcx = b,\n           None => fail!()\n         }\n     }\n-    let sp = cx.node_info.get().span;\n-\n-    let start = cx.sess().codemap.lookup_char_pos(sp.lo);\n-    let fname = /*bad*/copy start.file.name;\n-    let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n-    let tg = LexicalBlockTag;\n-    /*match cached_metadata::<@Metadata<BlockMetadata>>(\n-        cache, tg,\n-        {|md| start == md.data.start && end == md.data.end}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n-\n-    let parent = match cx.parent {\n-        None => create_function(cx.fcx).node,\n-        Some(bcx) => create_block(bcx).node\n-    };\n-    let file_node = create_file(cx.ccx(), /* bad */ fname.to_owned());\n-    let unique_id = match cache.find(&LexicalBlockTag) {\n-      option::Some(v) => v.len() as int,\n-      option::None => 0\n+    let span = bcx.node_info.get().span;\n+    let id = bcx.node_info.get().id;\n+\n+    match dbg_cx(cx).created_blocks.find(&id) {\n+        Some(block) => return *block,\n+        None => ()\n+    }\n+\n+    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n+\n+    let parent = match bcx.parent {\n+        None => create_function(bcx.fcx),\n+        Some(b) => create_block(b)\n     };\n-    let lldata = ~[lltag(tg),\n-                  parent,\n-                  lli32(start.line.to_int()),\n-                  lli32(start.col.to_int()),\n-                  file_node.node,\n-                  lli32(unique_id)\n-                 ];\n-    let val = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: BlockMetadata {\n-            start: start,\n-            end: end\n-        }\n+    let cx = bcx.ccx();\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let block_md = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent, file_md,\n+            loc.line as c_uint, loc.col.to_uint() as c_uint)\n     };\n-    //update_cache(cache, tg, block_metadata(mdval));\n-    return mdval;\n+\n+    dbg_cx(cx).created_blocks.insert(id, block_md);\n+\n+    return block_md;\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty) as int,\n-     machine::llalign_of_pref(cx, llty) as int)\n+    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n }\n \n-fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let cache = get_cache(cx);\n-    let tg = BasicTypeDescriptorTag;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, |md| ty::type_id(t) == md.data.hash) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n     }\n \n+    debug!(\"create_basic_type: %?\", ty::get(t));\n+\n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n         ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n@@ -381,380 +245,272 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n         _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n     };\n \n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let cu_node = create_compile_unit(cx);\n     let (size, align) = size_and_align_of(cx, t);\n-    let lldata = ~[lltag(tg),\n-                  cu_node.node,\n-                  llstr(name),\n-                  file_node.node,\n-                  lli32(0), //XXX source line\n-                  lli64(size * 8),  // size in bits\n-                  lli64(align * 8), // alignment in bits\n-                  lli64(0), //XXX offset?\n-                  lli32(0), //XXX flags?\n-                  lli32(encoding)];\n-    let llnode = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n+    let ty_md = do as_c_str(name) |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                DIB(cx), name,\n+                size * 8 as u64, align * 8 as u64, encoding as c_uint)\n+        }};\n+\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-fn create_pointer_type(cx: &mut CrateContext, t: ty::t, span: span,\n-                       pointee: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    let tg = PointerTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n+fn create_pointer_type(cx: @mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit(cx, fname);\n     let name = ty_to_str(cx.tcx, t);\n-    let llnode = create_derived_type(tg, file_node.node, name, 0, size * 8,\n-                                     align * 8, 0, pointee.node);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-struct StructCtxt {\n-    file: ValueRef,\n-    name: @str,\n-    line: int,\n-    members: ~[ValueRef],\n-    total_size: int,\n-    align: int\n-}\n+    let ptr_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreatePointerType(DIB(cx),\n+                pointee, size * 8 as u64, align * 8 as u64, name)\n+    }};\n+    return ptr_md;\n+}\n+\n+struct StructContext {\n+    builder: DIBuilderRef,\n+    file: DIFile,\n+    name: ~str,\n+    line: uint,\n+    members: ~[DIDerivedType],\n+    total_size: uint,\n+    align: uint\n+}\n+\n+impl StructContext {\n+    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> ~StructContext {\n+        debug!(\"StructContext::create: %s\", name);\n+        let scx = ~StructContext {\n+            builder: DIB(cx),\n+            file: file,\n+            name: name,\n+            line: line,\n+            members: ~[],\n+            total_size: 0,\n+            align: 1\n+        };\n+        return scx;\n+    }\n \n-fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n-    return create_composite_type(StructureTypeTag,\n-                                 cx.name,\n-                                 cx.file,\n-                                 cx.line,\n-                                 cx.total_size,\n-                                 cx.align,\n-                                 0,\n-                                 None,\n-                                 Some(/*bad*/copy cx.members));\n-}\n+    fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n+        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u\",\n+                self.name, name, size, align);\n+        let offset = roundup(self.total_size, align);\n+        let mem_t = do as_c_str(name) |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateMemberType(\n+                self.builder, ptr::null(), name, self.file, line as c_uint,\n+                size * 8 as u64, align * 8 as u64, offset * 8 as u64,\n+                0, ty)\n+            }};\n+        self.members.push(mem_t);\n+        self.total_size = offset + size;\n+        // struct alignment is the max alignment of its' members\n+        self.align = cmp::max(self.align, align);\n+    }\n \n-fn create_structure(file: @Metadata<FileMetadata>, name: @str, line: int)\n-                 -> @mut StructCtxt {\n-    let cx = @mut StructCtxt {\n-        file: file.node,\n-        name: name,\n-        line: line,\n-        members: ~[],\n-        total_size: 0,\n-        align: 64 //XXX different alignment per arch?\n-    };\n-    return cx;\n+    fn finalize(&self) -> DICompositeType {\n+        debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n+                self.name, self.total_size, self.align);\n+        let members_md = create_DIArray(self.builder, self.members);\n+\n+        let struct_md =\n+            do as_c_str(self.name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateStructType(\n+                    self.builder, self.file, name,\n+                    self.file, self.line as c_uint,\n+                    self.total_size * 8 as u64, self.align * 8 as u64, 0, ptr::null(),\n+                    members_md, 0, ptr::null())\n+            }};\n+        return struct_md;\n+    }\n }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, name: &str, line: int,\n-                       size: int, align: int, offset: int, ty: ValueRef)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  lli64(size),\n-                  lli64(align),\n-                  lli64(offset),\n-                  lli32(0),\n-                  ty];\n-    return llmdnode(lldata);\n+#[inline]\n+fn roundup(x: uint, a: uint) -> uint {\n+    ((x + (a - 1)) / a) * a\n }\n \n-fn add_member(cx: @mut StructCtxt,\n-              name: &str,\n-              line: int,\n-              size: int,\n-              align: int,\n-              ty: ValueRef) {\n-    cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n-                                        size * 8, align * 8, cx.total_size,\n-                                        ty));\n-    cx.total_size += size * 8;\n-}\n+fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n+                -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n \n-fn create_struct(cx: &mut CrateContext, t: ty::t, fields: ~[ty::field],\n-                 span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node, (ty_to_str(cx.tcx, t)).to_managed(),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, cx.sess.str_of(field.ident),\n-                   line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(cx.sess.str_of(field.ident), loc.line, size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n+    return scx.finalize();\n }\n \n-fn create_tuple(cx: &mut CrateContext, t: ty::t, elements: &[ty::t], span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node,\n-                               cx.sess.str_of(\n-                                   ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (\"tuple\")),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+// returns (void* type as a ValueRef, size in bytes, align in bytes)\n+fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n+    let size = sys::size_of::<ValueRef>();\n+    let align = sys::min_align_of::<ValueRef>();\n+    let vp = do as_c_str(\"*void\") |name| { unsafe {\n+            llvm::LLVMDIBuilderCreatePointerType(DIB(cx), ptr::null(),\n+                size*8 as u64, align*8 as u64, name)\n+        }};\n+    return (vp, size, align);\n+}\n+\n+fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span)\n+                -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n+    let mut scx = StructContext::new(cx, name, file_md, loc.line);\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n-        add_member(scx, \"\", line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(\"\", loc.line, size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n+    return scx.finalize();\n }\n \n-// returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr() -> (ValueRef, int, int) {\n-    let null = ptr::null();\n-    let size = sys::size_of::<ValueRef>() as int;\n-    let align = sys::min_align_of::<ValueRef>() as int;\n-    let vp = create_derived_type(PointerTypeTag, null, \"\", 0,\n-                                 size, align, 0, null);\n-    return (vp, size, align);\n-}\n-\n-fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n-                     span: span, boxed: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    //let tg = StructureTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(contents) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit_metadata(cx, fname);\n+fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n+                     span: span, boxed: DIType) -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n-    let scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n-    add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n+\n+    let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n+    scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n     // the tydesc and other pointers should be irrelevant to the\n     // debugger, so treat them as void* types\n-    let (vp, vpsize, vpalign) = voidptr();\n-    add_member(scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"next\", 0, vpsize, vpalign, vp);\n+    let (vp, vpsize, vpalign) = voidptr(cx);\n+    scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n     let (size, align) = size_and_align_of(cx, contents);\n-    add_member(scx, \"boxed\", 0, size, align, boxed.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(contents)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n-                         line: int, size: int, align: int, offset: int,\n-                         derived: Option<ValueRef>,\n-                         members: Option<~[ValueRef]>)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name), // type name\n-                  file, // source file definition\n-                  lli32(line), // source line definition\n-                  lli64(size), // size of members\n-                  lli64(align), // align\n-                  lli32/*64*/(offset), // offset\n-                  lli32(0), // flags\n-                  if derived.is_none() {\n-                      llnull()\n-                  } else { // derived from\n-                      derived.get()\n-                  },\n-                  if members.is_none() {\n-                      llnull()\n-                  } else { //members\n-                      llmdnode(members.get())\n-                  },\n-                  lli32(0),  // runtime language\n-                  llnull()\n-                 ];\n-    return llmdnode(lldata);\n+    scx.add_member(\"boxed\", 0, size, align, boxed);\n+    return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    len: int, span: span) -> @Metadata<TyDescMetadata> {\n-    let t_md = create_ty(cx, elem_t, span);\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n+                    len: uint, span: span) -> DIType {\n+    let elem_ty_md = create_ty(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n-    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let array = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                      size * len, align, 0, Some(t_md.node),\n-                                      Some(~[subrange]));\n-    @Metadata {\n-        node: array,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    }\n+\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, len as i64)\n+    };\n+\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n+            size * len * 8 as u64, align * 8 as u64, elem_ty_md, subscripts)\n+    };\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: codemap::span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, vec_ty_span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    vec_ty_span: span) -> DICompositeType {\n+    let loc = span_start(cx, vec_ty_span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-    let vec_scx = create_structure(file_node,\n-                               ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n+\n+    let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n-    add_member(vec_scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    add_member(vec_scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n+    vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    vec_scx.add_member(\"alloc\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n+    };\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let data_ptr = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                         arr_size, arr_align, 0,\n-                                         Some(elem_ty_md.node),\n-                                         Some(~[subrange]));\n-    add_member(vec_scx, \"data\", 0, 0, // clang says the size should be 0\n-               sys::min_align_of::<u8>() as int, data_ptr);\n-    let llnode = finish_structure(vec_scx);\n-    let vec_md = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n+\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    let data_ptr = unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n+            arr_size * 8 as u64, arr_align * 8 as u64, elem_ty_md, subscripts)\n     };\n+    vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n+               sys::min_align_of::<u8>(), data_ptr);\n+    let vec_md = vec_scx.finalize();\n \n-    let box_scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n+    let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n-    add_member(box_scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n-    let (vp, vpsize, vpalign) = voidptr();\n-    add_member(box_scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"next\", 0, vpsize, vpalign, vp);\n-    let size = 2 * sys::size_of::<int>() as int;\n-    let align = sys::min_align_of::<int>() as int;\n-    add_member(box_scx, \"boxed\", 0, size, align, vec_md.node);\n-    let llnode = finish_structure(box_scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(elem_t)\n-        }\n-    };\n+    box_scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n+    let (vp, vpsize, vpalign) = voidptr(cx);\n+    box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n+    let size = 2 * sys::size_of::<int>();\n+    let align = sys::min_align_of::<int>();\n+    box_scx.add_member(\"boxed\", 0, size, align, vec_md);\n+    let mdval = box_scx.finalize();\n     return mdval;\n }\n \n-fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+                    -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n-    let (_, ptr_size, ptr_align) = voidptr();\n-    add_member(scx, \"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n-    add_member(scx, \"length\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, uint_type.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    };\n-    return mdval;\n+\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n+    let (_, ptr_size, ptr_align) = voidptr(cx);\n+    scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n+    scx.add_member(\"length\", 0, sys::size_of::<uint>(),\n+                    sys::min_align_of::<uint>(), uint_type);\n+    return scx.finalize();\n }\n \n-fn create_fn_ty(cx: &mut CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n-                span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let (vp, _, _) = voidptr();\n+fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+                span: span) -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+    let (vp, _, _) = voidptr(cx);\n     let output_md = create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span).node };\n-    let members = ~[output_ptr_md.node, vp] + inputs_vals;\n-    let llnode = create_composite_type(SubroutineTag, \"\", file_node.node,\n-                                       0, 0, 0, 0, None, Some(members));\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(fn_ty)\n-        }\n+    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n+    let members = ~[output_ptr_md, vp] + inputs_vals;\n+\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_md,\n+            create_DIArray(DIB(cx), members))\n     };\n-    return mdval;\n }\n \n-fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n+fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n+    let name = ty_to_str(cx.tcx, t);\n+    let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx), name,\n+            0_u64, 8_u64, DW_ATE_unsigned as c_uint)\n+        }};\n+    return md;\n+}\n+\n+fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n+    }\n+\n     debug!(\"create_ty: %?\", ty::get(t));\n-    /*let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| t == md.data.hash}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n \n     let sty = copy ty::get(t).sty;\n-    match sty {\n+    let ty_md = match sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, i8_t, len as int + 1, span)\n+                    create_fixed_vec(cx, t, i8_t, len + 1, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, i8_t, span);\n@@ -766,7 +522,8 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n             }\n         },\n         ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_bug(span, \"debuginfo for enum NYI\")\n+            cx.sess.span_note(span, \"debuginfo for enum NYI\");\n+            create_unimpl_ty(cx, t)\n         }\n         ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n             let boxed = create_ty(cx, mt.ty, span);\n@@ -776,7 +533,7 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, mt.ty, len as int, span)\n+                    create_fixed_vec(cx, t, mt.ty, len, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, mt.ty, span);\n@@ -792,18 +549,21 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_rptr(ref _region, ref _mt) => {\n-            cx.sess.span_bug(span, \"debuginfo for rptr NYI\")\n+            cx.sess.span_note(span, \"debuginfo for rptr NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n             create_fn_ty(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_bug(span, \"debuginfo for closure NYI\")\n+            cx.sess.span_note(span, \"debuginfo for closure NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n-            cx.sess.span_bug(span, \"debuginfo for trait NYI\")\n+            cx.sess.span_note(span, \"debuginfo for trait NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n@@ -813,59 +573,41 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n             create_tuple(cx, t, *elements, span)\n         },\n         _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n-    }\n-}\n-\n-fn filename_from_span(cx: &CrateContext, sp: codemap::span) -> @str {\n-    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n-}\n+    };\n \n-fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n-              line: int, ret_ty: ValueRef) -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  context,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  ret_ty,\n-                  lli32(0)\n-                 ];\n-    return llmdnode(lldata);\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-pub fn create_local_var(bcx: block, local: @ast::local)\n-    -> @Metadata<LocalVarMetadata> {\n+pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n-    let cache = get_cache(cx);\n-    let tg = AutoVariableTag;\n-    match cached_metadata::<@Metadata<LocalVarMetadata>>(\n-        cache, tg, |md| md.data.id == local.node.id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n-    }\n \n-    let name = match local.node.pat.node {\n+    let ident = match local.node.pat.node {\n       ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n-      _ => fail!(\"no single variable name for local\")\n+      _ => {\n+        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n+        return ptr::null();\n+      }\n     };\n-    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+    let name: &str = cx.sess.str_of(ident);\n+    debug!(\"create_local_var: %s\", name);\n+\n+    let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, /*bad*/ loc.file.name.to_owned());\n+    let filemd = create_file(cx, loc.file.name);\n     let context = match bcx.parent {\n-        None => create_function(bcx.fcx).node,\n-        Some(_) => create_block(bcx).node\n+        None => create_function(bcx.fcx),\n+        Some(_) => create_block(bcx)\n     };\n-    let mdnode = create_var(tg, context, cx.sess.str_of(name),\n-                            filemd.node, loc.line as int, tymd.node);\n-    let mdval = @Metadata {\n-        node: mdnode,\n-        data: LocalVarMetadata {\n-            id: local.node.id\n-        }\n-    };\n-    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n+\n+    let var_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateLocalVariable(\n+            DIB(cx), AutoVariableTag as u32,\n+            context, name, filemd,\n+            loc.line as c_uint, tymd, false, 0, 0)\n+        }};\n \n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n     let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n@@ -876,92 +618,94 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n                 fmt!(\"No entry in lllocals table for %?\", local.node.id));\n         }\n     };\n-    let declargs = ~[llmdnode([llptr]), mdnode];\n-    trans::build::Call(bcx, cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n-                       declargs);\n-    return mdval;\n+\n+    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+    }\n+\n+    return var_md;\n }\n \n-pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> Option<@Metadata<ArgumentMetadata>> {\n+pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_arg\");\n+    if true {\n+        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n+        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        return None;\n+    }\n+\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n-    let cache = get_cache(cx);\n-    let tg = ArgVariableTag;\n-    match cached_metadata::<@Metadata<ArgumentMetadata>>(\n-        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-      option::Some(md) => return Some(md),\n-      option::None => ()\n-    }\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    let loc = span_start(cx, span);\n     if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n+\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, /* bad */ loc.file.name.to_owned());\n-    let context = create_function(bcx.fcx);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = create_function(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n-            let mdnode = create_var(\n-                tg,\n-                context.node,\n-                cx.sess.str_of(*path.idents.last()),\n-                filemd.node,\n-                loc.line as int,\n-                tymd.node\n-            );\n-\n-            let mdval = @Metadata {\n-                node: mdnode,\n-                data: ArgumentMetadata {\n-                    id: arg.id\n-                }\n-            };\n-            update_cache(cache, tg, argument_metadata(mdval));\n+            let ident = path.idents.last();\n+            let name: &str = cx.sess.str_of(*ident);\n+            let mdnode = do as_c_str(name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n+                    ArgVariableTag as u32, context, name,\n+                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                    // XXX need to pass in a real argument number\n+            }};\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            let declargs = ~[llmdnode([llptr]), mdnode];\n-            trans::build::Call(bcx,\n-                               cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n-                               declargs);\n-            return Some(mdval);\n+            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+            }\n+            return Some(mdnode);\n         }\n         _ => {\n             return None;\n         }\n     }\n }\n \n-pub fn update_source_pos(cx: block, s: span) {\n-    if !cx.sess().opts.debuginfo || (*s.lo == 0 && *s.hi == 0) {\n+fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n+    if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n     }\n-    let cm = cx.sess().codemap;\n-    let blockmd = create_block(cx);\n-    let loc = cm.lookup_char_pos(s.lo);\n-    let scopedata = ~[lli32(loc.line.to_int()),\n-                     lli32(loc.col.to_int()),\n-                     blockmd.node,\n-                     llnull()];\n-    let dbgscope = llmdnode(scopedata);\n+    debug!(\"setting debug location to %u %u\", line, col);\n+    dbg_cx(cx).curr_loc = (line, col);\n+\n+    let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n+        let dbg_loc = llvm::LLVMMDNodeInContext(\n+                dbg_cx(cx).llcontext, vec::raw::to_ptr(elems),\n+                elems.len() as libc::c_uint);\n+        llvm::LLVMSetCurrentDebugLocation(cx.builder.B, dbg_loc);\n     }\n }\n \n-pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n-    let mut cx = fcx.ccx;\n-\n-    debug!(\"~~\");\n+/// Set current debug location at the beginning of the span\n+pub fn update_source_pos(bcx: block, span: span) {\n+    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+        return;\n+    }\n+    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n+    let loc = span_start(bcx.ccx(), span);\n+    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+}\n \n+pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+    let cx = fcx.ccx;\n     let fcx = &mut *fcx;\n-\n-    let sp = fcx.span.get();\n-    debug!(\"%s\", cx.sess.codemap.span_to_str(sp));\n+    let span = fcx.span.get();\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n@@ -978,8 +722,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n-            let dbg_cx = cx.dbg_cx.get_ref();\n-            ((dbg_cx.names)(\"fn\"), decl.output, expr.id)\n+            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")\n@@ -988,62 +731,46 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n-    debug!(\"%?\", ident);\n-    debug!(\"%?\", id);\n-\n-    let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<SubProgramMetadata>>(\n-        cache, SubprogramTag, |md| md.data.id == id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+    match dbg_cx(cx).created_functions.find(&id) {\n+        Some(fn_md) => return *fn_md,\n+        None => ()\n     }\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let file_node = create_file(cx, loc.file.name.to_owned()).node;\n-    let ty_node = if cx.sess.opts.extra_debuginfo {\n+    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n-          ast::ty_nil => llnull(),\n+          ast::ty_nil => ptr::null(),\n           _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span).node\n+                         ret_ty.span)\n         }\n     } else {\n-        llnull()\n+        ptr::null()\n     };\n-    let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n-                                         0, 0, option::None,\n-                                         option::Some(~[ty_node]));\n-\n-    let fn_metadata = ~[lltag(SubprogramTag),\n-                       llunused(),\n-                       file_node,\n-                       llstr(cx.sess.str_of(ident)),\n-                        //XXX fully-qualified C++ name:\n-                       llstr(cx.sess.str_of(ident)),\n-                       llstr(\"\"), //XXX MIPS name?????\n-                       file_node,\n-                       lli32(loc.line as int),\n-                       sub_node,\n-                       lli1(false), //XXX static (check export)\n-                       lli1(true), // defined in compilation unit\n-                       lli32(DW_VIRTUALITY_none), // virtual-ness\n-                       lli32(0i), //index into virt func\n-                       /*llnull()*/ lli32(0), // base type with vtbl\n-                       lli32(256), // flags\n-                       lli1(cx.sess.opts.optimize != session::No),\n-                       fcx.llfn\n-                       //list of template params\n-                       //func decl descriptor\n-                       //list of func vars\n-                      ];\n-    let val = llmdnode(fn_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.sp\", val);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: SubProgramMetadata {\n-            id: id\n-        }\n+\n+    let fn_ty = unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n+            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n     };\n-    update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n \n-    return mdval;\n+    let fn_md =\n+        do as_c_str(cx.sess.str_of(ident)) |name| {\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn, ptr::null(), ptr::null())\n+            }}};\n+\n+    dbg_cx(cx).created_functions.insert(id, fn_md);\n+    return fn_md;\n }"}, {"sha": "05461c936318dff8079130dd5f107bd55a0532b7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -103,7 +103,7 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) => {\n-        decr_refcnt_maybe_free(bcx, v, t)\n+        decr_refcnt_maybe_free(bcx, v, None, t)\n       }\n       _ => bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\")\n     }\n@@ -419,15 +419,6 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n-      ty::ty_struct(did, ref substs) => {\n-        // Call the dtor if there is one\n-        match ty::ty_dtor(bcx.tcx(), did) {\n-            ty::NoDtor => bcx,\n-            ty::TraitDtor(ref dt_id) => {\n-                trans_struct_drop(bcx, t, v, *dt_id, did, substs)\n-            }\n-        }\n-      }\n       _ => bcx\n     };\n     build_return(bcx);\n@@ -489,7 +480,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n-        decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n+        decr_refcnt_maybe_free(bcx, Load(bcx, v0), Some(v0), t)\n       }\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n@@ -514,8 +505,10 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v0, [0u, abi::trt_field_box]));\n-        decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n+          let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n+          let llbox = Load(bcx, llbox_ptr);\n+          decr_refcnt_maybe_free(bcx, llbox, Some(llbox_ptr),\n+                                 ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n@@ -549,7 +542,10 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t)\n+// box_ptr_ptr is optional, it is constructed if not supplied.\n+pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n+                              box_ptr_ptr: Option<ValueRef>,\n+                              t: ty::t)\n                            -> block {\n     let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n@@ -559,7 +555,12 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t)\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-        with_cond(bcx, zero_test, |bcx| free_ty_immediate(bcx, box_ptr, t))\n+        do with_cond(bcx, zero_test) |bcx| {\n+            match box_ptr_ptr {\n+                Some(p) => free_ty(bcx, p, t),\n+                None => free_ty_immediate(bcx, box_ptr, t)\n+            }\n+        }\n     }\n }\n "}, {"sha": "4fc431e0a54caccec4e7ccb7eda8876bae16132b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1094,62 +1094,62 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n         cast::transmute::<&'static t_box_, t>(primitive)\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_bot() -> t { mk_prim_t(&primitives::TY_BOT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_bool() -> t { mk_prim_t(&primitives::TY_BOOL) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_int() -> t { mk_prim_t(&primitives::TY_INT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i8() -> t { mk_prim_t(&primitives::TY_I8) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i16() -> t { mk_prim_t(&primitives::TY_I16) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i32() -> t { mk_prim_t(&primitives::TY_I32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_i64() -> t { mk_prim_t(&primitives::TY_I64) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_float() -> t { mk_prim_t(&primitives::TY_FLOAT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_f32() -> t { mk_prim_t(&primitives::TY_F32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_f64() -> t { mk_prim_t(&primitives::TY_F64) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_uint() -> t { mk_prim_t(&primitives::TY_UINT) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u8() -> t { mk_prim_t(&primitives::TY_U8) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u16() -> t { mk_prim_t(&primitives::TY_U16) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u32() -> t { mk_prim_t(&primitives::TY_U32) }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n \n pub fn mk_mach_int(tm: ast::int_ty) -> t {\n@@ -1181,7 +1181,7 @@ pub fn mk_mach_float(tm: ast::float_ty) -> t {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n@@ -2273,7 +2273,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         for type_param_def.bounds.builtin_bounds.each |bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             tc = tc - match bound {\n-                BoundCopy => TypeContents::nonimplicitly_copyable(cx),\n+                BoundCopy => TypeContents::noncopyable(cx),\n                 BoundStatic => TypeContents::nonstatic(cx),\n                 BoundOwned => TypeContents::nonowned(cx),\n                 BoundConst => TypeContents::nonconst(cx),\n@@ -3694,16 +3694,16 @@ fn lookup_locally_or_in_crate_store<V:Copy>(\n      */\n \n     match map.find(&def_id) {\n-        Some(&v) => { return v; }\n+        Some(&ref v) => { return copy *v; }\n         None => { }\n     }\n \n     if def_id.crate == ast::local_crate {\n         fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n     }\n     let v = load_external();\n-    map.insert(def_id, v);\n-    return v;\n+    map.insert(def_id, copy v);\n+    return copy v;\n }\n \n pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {"}, {"sha": "12b413bc5af918c21aa6eeee1e1686ee29293770", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -725,7 +725,7 @@ impl FnCtxt {\n         ty::re_scope(self.region_lb)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());"}, {"sha": "197bf5d82ccea1c57c3e3b549ab70c8bf874a871", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use middle::resolve::Impl;\n use middle::ty::param_ty;\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n@@ -27,7 +26,6 @@ use util::ppaux;\n \n use core::hashmap::HashSet;\n use core::result;\n-use core::uint;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n@@ -248,16 +246,9 @@ fn lookup_vtable(vcx: &VtableContext,\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n-                    let len = { // FIXME(#5074): stage0 requires it\n-                        let implementations: &mut ~[@Impl] = *implementations;\n-                        implementations.len()\n-                    };\n-\n                     // implementations is the list of all impls in scope for\n                     // trait_ref. (Usually, there's just one.)\n-                    for uint::range(0, len) |i| {\n-                        let im = implementations[i];\n-\n+                    for implementations.iter().advance |im| {\n                         // im is one specific impl of trait_ref.\n \n                         // First, ensure we haven't processed this impl yet."}, {"sha": "d71820a67b35ff0956cd5938e9061de4caf37608", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -520,12 +520,8 @@ impl CoherenceChecker {\n \n         match extension_methods.find(&trait_def_id) {\n             Some(impls) => {\n-                let len = { // FIXME(#5074) stage0 requires this\n-                    let impls: &mut ~[@Impl] = *impls;\n-                    impls.len()\n-                };\n-                for uint::range(0, len) |i| {\n-                    f(impls[i]);\n+                for impls.iter().advance |&im| {\n+                    f(im);\n                 }\n             }\n             None => { /* no impls? */ }"}, {"sha": "7a3230079ee396837c75a265f94fca0fa1c5b36b", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -89,10 +89,10 @@ impl CombineFields {\n         // Need to make sub_id a subtype of sup_id.\n         let node_a = self.infcx.get(a_id);\n         let node_b = self.infcx.get(b_id);\n-        let a_id = node_a.root;\n-        let b_id = node_b.root;\n-        let a_bounds = node_a.possible_types;\n-        let b_bounds = node_b.possible_types;\n+        let a_id = copy node_a.root;\n+        let b_id = copy node_b.root;\n+        let a_bounds = copy node_a.possible_types;\n+        let b_bounds = copy node_b.possible_types;\n \n         debug!(\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n@@ -102,8 +102,8 @@ impl CombineFields {\n \n         // If both A's UB and B's LB have already been bound to types,\n         // see if we can make those types subtypes.\n-        match (a_bounds.ub, b_bounds.lb) {\n-            (Some(ref a_ub), Some(ref b_lb)) => {\n+        match (&a_bounds.ub, &b_bounds.lb) {\n+            (&Some(ref a_ub), &Some(ref b_lb)) => {\n                 let r = self.infcx.try(\n                     || LatticeValue::sub(self, a_ub, b_lb));\n                 match r {\n@@ -138,9 +138,9 @@ impl CombineFields {\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n \n         let node_a = self.infcx.get(a_id);\n-        let a_id = node_a.root;\n+        let a_id = copy node_a.root;\n         let a_bounds = &node_a.possible_types;\n-        let b_bounds = &Bounds { lb: None, ub: Some(b) };\n+        let b_bounds = &Bounds { lb: None, ub: Some(copy b) };\n \n         debug!(\"var_sub_t(%s=%s <: %s)\",\n                a_id.to_str(),\n@@ -161,9 +161,9 @@ impl CombineFields {\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n \n-        let a_bounds = &Bounds { lb: Some(a), ub: None };\n+        let a_bounds = &Bounds { lb: Some(copy a), ub: None };\n         let node_b = self.infcx.get(b_id);\n-        let b_id = node_b.root;\n+        let b_id = copy node_b.root;\n         let b_bounds = &node_b.possible_types;\n \n         debug!(\"t_sub_var(%s <: %s=%s)\",\n@@ -190,11 +190,11 @@ impl CombineFields {\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n-        match (*a, *b) {\n-            (None,          None) => Ok(None),\n-            (Some(_),       None) => Ok(*a),\n-            (None,          Some(_)) => Ok(*b),\n-            (Some(ref v_a), Some(ref v_b)) => {\n+        match (a, b) {\n+            (&None,          &None) => Ok(None),\n+            (&Some(_),       &None) => Ok(copy *a),\n+            (&None,          &Some(_)) => Ok(copy *b),\n+            (&Some(ref v_a), &Some(ref v_b)) => {\n                 do lattice_op(self, v_a, v_b).chain |v| {\n                     Ok(Some(v))\n                 }\n@@ -272,13 +272,13 @@ impl CombineFields {\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n-        match (*a, *b) {\n-            (None, None) |\n-            (Some(_), None) |\n-            (None, Some(_)) => {\n+        match (a, b) {\n+            (&None, &None) |\n+            (&Some(_), &None) |\n+            (&None, &Some(_)) => {\n                 uok()\n             }\n-            (Some(ref t_a), Some(ref t_b)) => {\n+            (&Some(ref t_a), &Some(ref t_b)) => {\n                 LatticeValue::sub(self, t_a, t_b)\n             }\n         }\n@@ -303,9 +303,9 @@ pub trait TyLatticeDir {\n \n impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.ub }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { ub: Some(t), ..*b }\n+        Bounds { ub: Some(t), ..copy *b }\n     }\n }\n \n@@ -317,9 +317,9 @@ impl TyLatticeDir for Lub {\n \n impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.lb }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { lb: Some(t), ..*b }\n+        Bounds { lb: Some(t), ..copy *b }\n     }\n }\n \n@@ -405,8 +405,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     -> cres<LatticeVarResult<V,T>> {\n     let nde_a = this.infcx().get(a_vid);\n     let nde_b = this.infcx().get(b_vid);\n-    let a_vid = nde_a.root;\n-    let b_vid = nde_b.root;\n+    let a_vid = copy nde_a.root;\n+    let b_vid = copy nde_b.root;\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n@@ -436,8 +436,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    do cf.var_sub_var(a_vid, b_vid).then {\n-        Ok(VarResult(a_vid))\n+    do cf.var_sub_var(copy a_vid, copy b_vid).then {\n+        Ok(VarResult(copy a_vid))\n     }\n }\n \n@@ -450,7 +450,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {\n     let nde_a = this.infcx().get(a_id);\n-    let a_id = nde_a.root;\n+    let a_id = copy nde_a.root;\n     let a_bounds = &nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n@@ -472,10 +472,11 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n             debug!(\"bnd=None\");\n-            let a_bounds = this.with_bnd(a_bounds, *b);\n+            let a_bounds = this.with_bnd(a_bounds, copy *b);\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                this.infcx().set(a_id, Root(a_bounds, nde_a.rank));\n-                Ok(*b)\n+                this.infcx().set(copy a_id,\n+                                 Root(copy a_bounds, copy nde_a.rank));\n+                Ok(copy *b)\n             }\n         }\n     }"}, {"sha": "410e2fe23c10b67694d9dca5fe43456b3f5074b5", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -504,9 +504,9 @@ trait CresCompare<T> {\n \n impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n-        do self.chain |s| {\n+        do (copy *self).chain |s| {\n             if s == t {\n-                *self\n+                copy *self\n             } else {\n                 Err(f())\n             }"}, {"sha": "371d389f712c7f3c03a5de90b3c8884c96225bcc", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -61,19 +61,19 @@ impl InferCtxt {\n         {\n             let vid_u = vid.to_uint();\n             let var_val = match vb.vals.find(&vid_u) {\n-                Some(&var_val) => var_val,\n+                Some(&ref var_val) => copy *var_val,\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n             };\n             match var_val {\n                 Redirect(vid) => {\n-                    let node: Node<V,T> = helper(tcx, vb, vid);\n+                    let node: Node<V,T> = helper(tcx, vb, copy vid);\n                     if node.root != vid {\n                         // Path compression\n                         vb.vals.insert(vid.to_uint(),\n-                                       Redirect(node.root));\n+                                       Redirect(copy node.root));\n                     }\n                     node\n                 }\n@@ -96,12 +96,10 @@ impl InferCtxt {\n         debug!(\"Updating variable %s to %s\",\n                vid.to_str(), new_v.inf_str(self));\n \n-        { // FIXME(#4903)---borrow checker is not flow sensitive\n-            let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-            let old_v = { *vb.vals.get(&vid.to_uint()) }; // FIXME(#4903)\n-            vb.bindings.push((vid, old_v));\n-            vb.vals.insert(vid.to_uint(), new_v);\n-        }\n+        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n+        let old_v = copy *vb.vals.get(&vid.to_uint());\n+        vb.bindings.push((copy vid, old_v));\n+        vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n     pub fn unify<T:Copy + InferStr,\n@@ -120,18 +118,18 @@ impl InferCtxt {\n         if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(node_b.root, Redirect(node_a.root));\n-            (node_a.root, node_a.rank)\n+            self.set(copy node_b.root, Redirect(copy node_a.root));\n+            (copy node_a.root, node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(node_a.root, Redirect(node_b.root));\n-            (node_b.root, node_b.rank)\n+            self.set(copy node_a.root, Redirect(copy node_b.root));\n+            (copy node_b.root, node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(node_b.root, Redirect(node_a.root));\n-            (node_a.root, node_a.rank + 1)\n+            self.set(copy node_b.root, Redirect(copy node_a.root));\n+            (copy node_a.root, node_a.rank + 1)\n         }\n     }\n \n@@ -174,20 +172,20 @@ impl InferCtxt {\n \n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n-        let a_id = node_a.root;\n-        let b_id = node_b.root;\n+        let a_id = copy node_a.root;\n+        let b_id = copy node_b.root;\n \n         if a_id == b_id { return uok(); }\n \n         let combined = match (&node_a.possible_types, &node_b.possible_types)\n         {\n             (&None, &None) => None,\n-            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(*v),\n+            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(copy *v),\n             (&Some(ref v1), &Some(ref v2)) => {\n                 if *v1 != *v2 {\n-                    return mk_err(a_is_expected, *v1, *v2);\n+                    return mk_err(a_is_expected, copy *v1, copy *v2);\n                 }\n-                Some(*v1)\n+                Some(copy *v1)\n             }\n         };\n \n@@ -211,7 +209,7 @@ impl InferCtxt {\n          * `b`. */\n \n         let node_a = self.get(a_id);\n-        let a_id = node_a.root;\n+        let a_id = copy node_a.root;\n \n         match node_a.possible_types {\n             None => {\n@@ -223,7 +221,7 @@ impl InferCtxt {\n                 if *a_t == b {\n                     return uok();\n                 } else {\n-                    return mk_err(a_is_expected, *a_t, b);\n+                    return mk_err(a_is_expected, copy *a_t, b);\n                 }\n             }\n         }"}, {"sha": "021dd6648cbf0676695a78241dbc59a07d64e2cc", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -28,16 +28,8 @@ extern mod core(name = \"std\");\n extern mod extra(name = \"extra\");\n extern mod syntax;\n \n-// For deriving(Encodable) purposes...\n-#[cfg(stage0)]\n-extern mod std(name = \"extra\", vers = \"0.7-pre\");\n-#[cfg(not(stage0))]\n extern mod std(name = \"std\", vers = \"0.7-pre\");\n \n-// For bootstrapping purposes.\n-#[cfg(stage0)]\n-pub use core::unstable;\n-\n use core::prelude::*;\n \n use driver::driver::{host_triple, optgroups, early_error};"}, {"sha": "3775aafb56969539cddb3e9e19cb545393decb07", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -32,8 +32,6 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax;\n \n-#[cfg(test)] use core::vec;\n-\n pub struct Ctxt {\n     ast: @ast::crate,\n     ast_map: ast_map::map"}, {"sha": "1abdae113c597bb751e95e2df1dd5488191f0dd3", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -152,6 +152,6 @@ mod test {\n     fn should_concatenate_multiple_doc_comments() {\n         let source = @\"/// foo\\n/// bar\";\n         let desc = parse_desc(parse_attributes(source));\n-        assert!(desc == Some(~\"foo\\nbar\"));\n+        assert!(desc == Some(~\" foo\\n bar\"));\n     }\n }"}, {"sha": "dbaa5e8532cb3b91a9bbe5896a1e5cf0a96e238f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -24,7 +24,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::str;\n use core::util;\n \n pub fn mk_pass() -> Pass {\n@@ -129,25 +128,21 @@ fn first_sentence_(s: &str) -> ~str {\n         }\n     });\n     match idx {\n-        Some(idx) if idx > 2u => {\n-            str::to_owned(s.slice(0, idx - 1))\n-        }\n+        Some(idx) if idx > 2u => s.slice(0, idx - 1).to_owned(),\n         _ => {\n             if s.ends_with(\".\") {\n-                str::to_owned(s)\n+                s.to_owned()\n             } else {\n-                str::to_owned(s)\n+                s.to_owned()\n             }\n         }\n     }\n }\n \n pub fn paragraphs(s: &str) -> ~[~str] {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do lines.iter().fold(~[]) |paras, line| {\n+    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -163,9 +158,9 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n             whitespace_lines = 0;\n \n             accum = if accum.is_empty() {\n-                copy *line\n+                line.to_owned()\n             } else {\n-                accum + \"\\n\" + *line\n+                fmt!(\"%s\\n%s\", accum, line)\n             }\n         }\n "}, {"sha": "f8c49f544bc2efb25e327680bb632ba7f210b183", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -285,8 +285,6 @@ mod test {\n     use extract::{extract, from_srv};\n     use parse;\n \n-    use core::vec;\n-\n     fn mk_doc(source: @str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")"}, {"sha": "075b64a674cbbaffbdef0a8ef9151616952a87fd", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -466,10 +466,7 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n }\n \n fn list_item_indent(item: &str) -> ~str {\n-    let mut indented = ~[];\n-    for str::each_line_any(item) |line| {\n-        indented.push(line);\n-    }\n+    let indented = item.any_line_iter().collect::<~[&str]>();\n \n     // separate markdown elements within `*` lists must be indented by four\n     // spaces, or they will escape the list context. indenting everything\n@@ -539,8 +536,6 @@ mod test {\n     use tystr_pass;\n     use unindent_pass;\n \n-    use core::str;\n-\n     fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);"}, {"sha": "584e6ccc887301a3e2176cfbd0817ed170182965", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -157,7 +157,6 @@ mod test {\n     use doc;\n     use extract;\n     use page_pass::run;\n-    use core::vec;\n \n     fn mk_doc_(\n         output_style: config::OutputStyle,"}, {"sha": "484eb8c7980dc06bbff5b052edafa0295f523e80", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -77,8 +77,6 @@ mod test {\n \n     #[test]\n     fn should_prune_hidden_items() {\n-        use core::vec;\n-\n         let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n         assert!(doc.cratemod().mods().is_empty())\n     }"}, {"sha": "741da3e265eebb91e1c998317fb36d285cfba291", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -162,7 +162,6 @@ mod test {\n     use extract;\n     use tystr_pass;\n     use prune_private_pass::run;\n-    use core::vec;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {"}, {"sha": "ba433bf479d2cebe5b5d0dde6c5dcffc838b65f6", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,7 +19,7 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::str;\n+use core::iterator::IteratorUtil;\n \n pub fn mk_pass() -> Pass {\n     Pass {\n@@ -104,39 +104,37 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     if desc.is_none() {\n         return (None, ~[]);\n     }\n-    let mut lines = ~[];\n-    for str::each_line_any(*desc.get_ref()) |line| { lines.push(line.to_owned()); }\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;\n     let mut sections = ~[];\n \n-    for lines.each |line| {\n-        match parse_header(copy *line) {\n+    for desc.get_ref().any_line_iter().advance |line| {\n+        match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections += [copy *current_section.get_ref()];\n+                sections.push(copy *current_section.get_ref());\n             }\n             current_section = Some(doc::Section {\n-                header: header,\n+                header: header.to_owned(),\n                 body: ~\"\"\n             });\n           }\n           None => {\n             match copy current_section {\n               Some(section) => {\n                 current_section = Some(doc::Section {\n-                    body: section.body + \"\\n\" + *line,\n+                    body: fmt!(\"%s\\n%s\", section.body, line),\n                     .. section\n                 });\n               }\n               None => {\n                 new_desc = match copy new_desc {\n                   Some(desc) => {\n-                    Some(desc + \"\\n\" + *line)\n+                    Some(fmt!(\"%s\\n%s\", desc, line))\n                   }\n                   None => {\n-                    Some(copy *line)\n+                    Some(line.to_owned())\n                   }\n                 };\n               }\n@@ -146,15 +144,15 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     }\n \n     if current_section.is_some() {\n-        sections += [current_section.get()];\n+        sections.push(current_section.unwrap());\n     }\n \n     (new_desc, sections)\n }\n \n-fn parse_header(line: ~str) -> Option<~str> {\n+fn parse_header<'a>(line: &'a str) -> Option<&'a str> {\n     if line.starts_with(\"# \") {\n-        Some(line.slice(2u, line.len()).to_owned())\n+        Some(line.slice_from(2))\n     } else {\n         None\n     }\n@@ -172,9 +170,6 @@ mod test {\n     use extract;\n     use sectionalize_pass::run;\n \n-    use core::str;\n-    use core::vec;\n-\n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");"}, {"sha": "6db582a60e98baac7f9da61db15717b563918cd9", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -149,8 +149,6 @@ mod test {\n     use sectionalize_pass;\n     use text_pass::mk_pass;\n \n-    use core::str;\n-\n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");"}, {"sha": "2bcf04c0262e0b4f6a0f49a7c9599f8f7f22bbbc", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -21,7 +21,6 @@ middle of a line, and each of the following lines is indented.\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use pass::Pass;\n use text_pass;\n@@ -31,8 +30,7 @@ pub fn mk_pass() -> Pass {\n }\n \n fn unindent(s: &str) -> ~str {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n+    let lines = s.any_line_iter().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do lines.iter().fold(uint::max_value)\n@@ -76,19 +74,20 @@ fn unindent(s: &str) -> ~str {\n         }\n     };\n \n-    if !lines.is_empty() {\n-        let unindented = ~[lines.head().trim().to_owned()]\n-            + do lines.tail().map |line| {\n-            if line.is_whitespace() {\n-                copy *line\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line.slice(min_indent, line.len()).to_owned()\n-            }\n-        };\n-        unindented.connect(\"\\n\")\n-    } else {\n-        s.to_str()\n+    match lines {\n+        [head, .. tail] => {\n+            let mut unindented = ~[ head.trim() ];\n+            unindented.push_all(do tail.map |&line| {\n+                if line.is_whitespace() {\n+                    line\n+                } else {\n+                    assert!(line.len() >= min_indent);\n+                    line.slice_from(min_indent)\n+                }\n+            });\n+            unindented.connect(\"\\n\")\n+        }\n+        [] => s.to_owned()\n     }\n }\n "}, {"sha": "c618623a2cb7af8b00b84101746ce44868583cdd", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -370,7 +370,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n                     (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n-                    (copy *arg, arg + \".rs\")\n+                    (copy *arg, *arg + \".rs\")\n                 };\n                 match compile_crate(filename, copy repl.binary) {\n                     Some(_) => loaded_crates.push(crate),\n@@ -537,6 +537,9 @@ mod tests {\n     }\n \n     #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n     fn run_all() {\n         // FIXME(#7071):\n         // By default, unit tests are run in parallel. Rusti, on the other hand,\n@@ -648,6 +651,9 @@ mod tests {\n     }\n \n     #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n     fn exit_quits() {\n         let mut r = repl();\n         assert!(r.running);"}, {"sha": "8b9158732696851f6691ec1ccac08fbca92d3b4f", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -309,7 +309,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     }\n }\n \n-#[test]\n+#[test] #[ignore] //FIXME(#7249)\n fn test_all() {\n     // FIXME(#7071): these tests use rustc, so they can't be run in parallel\n     //               until this issue is resolved"}, {"sha": "18dfbd82c5ae7273765c05936a63e82372dfe657", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -23,22 +23,8 @@ use vec;\n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n \n-pub mod rustrt {\n-    use libc;\n-    use sys;\n-    use vec;\n-\n-    #[abi = \"cdecl\"]\n-    #[link_name = \"rustrt\"]\n-    pub extern {\n-        pub unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n-                                                v: **vec::raw::VecRepr,\n-                                                n: libc::size_t);\n-    }\n-}\n-\n /// Returns the number of elements the vector can hold without reallocating\n-#[inline(always)]\n+#[inline]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(&v);\n@@ -58,7 +44,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec: @[A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n@@ -76,7 +62,7 @@ pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n@@ -93,7 +79,7 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A>(size: Option<uint>,\n                           builder: &fn(push: &fn(v: A)))\n                        -> @[A] {\n@@ -104,11 +90,11 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for lhs.each |x| { push(*x); }\n-        for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n+        for lhs.each |x| { push(copy *x); }\n+        for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n     }\n }\n \n@@ -168,7 +154,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n  * elements of a slice.\n  */\n pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| v[i])\n+    from_fn(v.len(), |i| copy v[i])\n }\n \n #[cfg(not(test))]\n@@ -178,7 +164,7 @@ pub mod traits {\n     use ops::Add;\n \n     impl<'self,T:Copy> Add<&'self const [T],@[T]> for @[T] {\n-        #[inline(always)]\n+        #[inline]\n         fn add(&self, rhs: & &'self const [T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n@@ -189,14 +175,16 @@ pub mod traits {\n pub mod traits {}\n \n pub mod raw {\n-    use at_vec::{capacity, rustrt};\n+    use at_vec::capacity;\n     use cast::{transmute, transmute_copy};\n     use libc;\n     use ptr;\n     use sys;\n     use uint;\n     use unstable::intrinsics::{move_val_init};\n     use vec;\n+    use vec::UnboxedVecRepr;\n+    use sys::TypeDesc;\n \n     pub type VecRepr = vec::raw::VecRepr;\n     pub type SliceRepr = vec::raw::SliceRepr;\n@@ -208,7 +196,7 @@ pub mod raw {\n      * modifing its buffers, so it is up to the caller to ensure that\n      * the vector is actually the specified size.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n         let repr: **mut VecRepr = transmute(&v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n@@ -217,7 +205,7 @@ pub mod raw {\n     /**\n      * Pushes a new value onto this vector.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n         let repr: **VecRepr = transmute_copy(&v);\n         let fill = (**repr).unboxed.fill;\n@@ -228,7 +216,7 @@ pub mod raw {\n         }\n     }\n \n-    #[inline(always)] // really pretty please\n+    #[inline] // really pretty please\n     unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n         let repr: **mut VecRepr = ::cast::transmute(v);\n         let fill = (**repr).unboxed.fill;\n@@ -257,9 +245,47 @@ pub mod raw {\n     pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(*v) < n {\n-            let ptr: **VecRepr = transmute(v);\n-            rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n-                                              ptr, n as libc::size_t);\n+            let ptr: *mut *mut VecRepr = transmute(v);\n+            let ty = sys::get_type_desc::<T>();\n+            return reserve_raw(ty, ptr, n);\n+        }\n+    }\n+\n+    // Implementation detail. Shouldn't be public\n+    #[allow(missing_doc)]\n+    pub fn reserve_raw(ty: *TypeDesc, ptr: *mut *mut VecRepr, n: uint) {\n+\n+        unsafe {\n+            let size_in_bytes = n * (*ty).size;\n+            if size_in_bytes > (**ptr).unboxed.alloc {\n+                let total_size = size_in_bytes + sys::size_of::<UnboxedVecRepr>();\n+                // XXX: UnboxedVecRepr has an extra u8 at the end\n+                let total_size = total_size - sys::size_of::<u8>();\n+                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut VecRepr;\n+                (**ptr).unboxed.alloc = size_in_bytes;\n+            }\n+        }\n+\n+        fn local_realloc(ptr: *(), size: uint) -> *() {\n+            use rt;\n+            use rt::OldTaskContext;\n+            use rt::local::Local;\n+            use rt::task::Task;\n+\n+            if rt::context() == OldTaskContext {\n+                unsafe {\n+                    return rust_local_realloc(ptr, size as libc::size_t);\n+                }\n+\n+                extern {\n+                    #[fast_ffi]\n+                    fn rust_local_realloc(ptr: *(), size: libc::size_t) -> *();\n+                }\n+            } else {\n+                do Local::borrow::<Task, *()> |task| {\n+                    task.heap.realloc(ptr as *libc::c_void, size) as *()\n+                }\n+            }\n         }\n     }\n "}, {"sha": "e6be164099bf00b2e6315fee864d0463c8255872", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -212,7 +212,7 @@ impl FromStr for bool {\n * ~~~\n */\n impl ToStr for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         if *self { ~\"true\" } else { ~\"false\" }\n     }\n@@ -250,24 +250,24 @@ pub fn all_values(blk: &fn(v: bool)) {\n * 0\n * ~~~\n */\n-#[inline(always)]\n+#[inline]\n pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[cfg(not(test))]\n impl Ord for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &bool) -> bool { to_bit(*self) < to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &bool) -> bool { to_bit(*self) <= to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &bool) -> bool { to_bit(*self) > to_bit(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &bool) -> bool { to_bit(*self) >= to_bit(*other) }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &bool) -> Ordering { to_bit(*self).cmp(&to_bit(*other)) }\n }\n \n@@ -298,9 +298,9 @@ impl TotalOrd for bool {\n */\n #[cfg(not(test))]\n impl Eq for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "9e3a3a28fe8cef39aa0b1020d8f548ca37e8cfdb", "filename": "src/libstd/borrow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,25 +14,25 @@\n use prelude::*;\n \n /// Cast a region pointer - &T - to a uint.\n-#[inline(always)]\n+#[inline]\n pub fn to_uint<T>(thing: &T) -> uint {\n     thing as *T as uint\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n-#[inline(always)]\n+#[inline]\n pub fn ref_eq<'a, 'b, T>(thing: &'a T, other: &'b T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n // Equality for region pointers\n #[cfg(not(test))]\n impl<'self, T: Eq> Eq for &'self T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: & &'self T) -> bool {\n         *(*self) == *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: & &'self T) -> bool {\n         *(*self) != *(*other)\n     }\n@@ -41,19 +41,19 @@ impl<'self, T: Eq> Eq for &'self T {\n // Comparison for region pointers\n #[cfg(not(test))]\n impl<'self, T: Ord> Ord for &'self T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: & &'self T) -> bool {\n         *(*self) < *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: & &'self T) -> bool {\n         *(*self) <= *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: & &'self T) -> bool {\n         *(*self) >= *(*other)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: & &'self T) -> bool {\n         *(*self) > *(*other)\n     }"}, {"sha": "30b6b030dba296b1cf68e4a906b8ff9a4cad0edd", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,22 +14,9 @@ use sys;\n use unstable::intrinsics;\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(stage0)]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = intrinsics::uninit();\n-    {\n-        let dest_ptr: *mut u8 = transmute(&mut dest);\n-        let src_ptr: *u8 = transmute(src);\n-        intrinsics::memmove64(dest_ptr,\n-                              src_ptr,\n-                              sys::size_of::<U>() as u64);\n-    }\n-    dest\n-}\n-\n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(target_word_size = \"32\", not(stage0))]\n-#[inline(always)]\n+#[cfg(target_word_size = \"32\")]\n+#[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n@@ -39,8 +26,8 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(target_word_size = \"64\", not(stage0))]\n-#[inline(always)]\n+#[cfg(target_word_size = \"64\")]\n+#[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n@@ -54,19 +41,16 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n  *\n  * The forget function will take ownership of the provided value but neglect\n  * to run any required cleanup or memory-management operations on it. This\n- * can be used for various acts of magick, particularly when using\n- * reinterpret_cast on pointer types.\n+ * can be used for various acts of magick.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n- * carelessly, this can leak the box. Use this in conjunction with transmute\n- * and/or reinterpret_cast when such calls would otherwise scramble a box's\n- * reference count\n+ * carelessly, this can leak the box.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n \n /**\n@@ -77,59 +61,59 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     intrinsics::transmute(thing)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n /// Coerce a mutable reference to be immutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_immut<'a,T>(ptr: &'a mut T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T {\n     transmute_mut_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }"}, {"sha": "797fd9e8c020e3d3e9916054b82240bf6fcdbfe5", "filename": "src/libstd/char.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -17,8 +17,8 @@ use u32;\n use uint;\n use unicode::{derived_property, general_category};\n \n-#[cfg(not(test))]\n-use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use num::Zero;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -65,22 +65,22 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n /// Indicates whether a character is in lower case, defined\n /// in terms of the Unicode General Category 'Ll'\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_lowercase(c: char) -> bool { general_category::Ll(c) }\n \n ///\n /// Indicates whether a character is in upper case, defined\n /// in terms of the Unicode General Category 'Lu'.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n \n ///\n /// Indicates whether a character is whitespace. Whitespace is defined in\n /// terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n /// additional 'Cc'-category control codes in the range [0x09, 0x0d]\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_whitespace(c: char) -> bool {\n     ('\\x09' <= c && c <= '\\x0d')\n         || general_category::Zs(c)\n@@ -93,7 +93,7 @@ pub fn is_whitespace(c: char) -> bool {\n /// defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n /// and the Derived Core Property 'Alphabetic'.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_alphanumeric(c: char) -> bool {\n     derived_property::Alphabetic(c)\n         || general_category::Nd(c)\n@@ -102,7 +102,7 @@ pub fn is_alphanumeric(c: char) -> bool {\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n-#[inline(always)]\n+#[inline]\n pub fn is_digit(c: char) -> bool {\n     general_category::Nd(c)\n         || general_category::Nl(c)\n@@ -127,7 +127,7 @@ pub fn is_digit(c: char) -> bool {\n ///\n /// This just wraps `to_digit()`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n         Some(_) => true,\n@@ -310,24 +310,30 @@ impl Char for char {\n \n #[cfg(not(test))]\n impl Eq for char {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl Ord for char {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &char) -> bool { *self < *other }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &char) -> bool { *self <= *other }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &char) -> bool { *self > *other }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &char) -> bool { *self >= *other }\n }\n \n+#[cfg(not(test))]\n+impl Zero for char {\n+    fn zero() -> char { 0 as char }\n+    fn is_zero(&self) -> bool { *self == 0 as char }\n+}\n+\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());"}, {"sha": "36c1fdf781b250e427896d0bbe2e918c8d5a77e6", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 13, "deletions": 103, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -13,107 +13,14 @@\n use libc::{c_char, c_void, intptr_t, uintptr_t};\n use ptr::mut_null;\n use repr::BoxRepr;\n+use rt;\n+use rt::OldTaskContext;\n use sys::TypeDesc;\n use cast::transmute;\n-#[cfg(not(test))] use unstable::lang::clear_task_borrow_list;\n \n #[cfg(not(test))] use ptr::to_unsafe_ptr;\n \n-/**\n- * Runtime structures\n- *\n- * NB: These must match the representation in the C++ runtime.\n- */\n-\n type DropGlue<'self> = &'self fn(**TypeDesc, *c_void);\n-type FreeGlue<'self> = &'self fn(**TypeDesc, *c_void);\n-\n-type TaskID = uintptr_t;\n-\n-struct StackSegment { priv opaque: () }\n-struct Scheduler { priv opaque: () }\n-struct SchedulerLoop { priv opaque: () }\n-struct Kernel { priv opaque: () }\n-struct Env { priv opaque: () }\n-struct AllocHeader { priv opaque: () }\n-struct MemoryRegion { priv opaque: () }\n-\n-#[cfg(target_arch=\"x86\")]\n-struct Registers {\n-    data: [u32, ..16]\n-}\n-\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-struct Registers {\n-    data: [u32, ..32]\n-}\n-\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-struct Context {\n-    regs: Registers,\n-    next: *Context,\n-    pad: [u32, ..3]\n-}\n-\n-#[cfg(target_arch=\"x86_64\")]\n-struct Registers {\n-    data: [u64, ..22]\n-}\n-\n-#[cfg(target_arch=\"x86_64\")]\n-struct Context {\n-    regs: Registers,\n-    next: *Context,\n-    pad: uintptr_t\n-}\n-\n-struct BoxedRegion {\n-    env: *Env,\n-    backing_region: *MemoryRegion,\n-    live_allocs: *BoxRepr\n-}\n-\n-#[cfg(target_arch=\"x86\")]\n-#[cfg(target_arch=\"arm\")]\n-#[cfg(target_arch=\"mips\")]\n-struct Task {\n-    // Public fields\n-    refcount: intptr_t,                 // 0\n-    id: TaskID,                         // 4\n-    pad: [u32, ..2],                    // 8\n-    ctx: Context,                       // 16\n-    stack_segment: *StackSegment,       // 96\n-    runtime_sp: uintptr_t,              // 100\n-    scheduler: *Scheduler,              // 104\n-    scheduler_loop: *SchedulerLoop,     // 108\n-\n-    // Fields known only to the runtime\n-    kernel: *Kernel,                    // 112\n-    name: *c_char,                      // 116\n-    list_index: i32,                    // 120\n-    boxed_region: BoxedRegion           // 128\n-}\n-\n-#[cfg(target_arch=\"x86_64\")]\n-struct Task {\n-    // Public fields\n-    refcount: intptr_t,\n-    id: TaskID,\n-    ctx: Context,\n-    stack_segment: *StackSegment,\n-    runtime_sp: uintptr_t,\n-    scheduler: *Scheduler,\n-    scheduler_loop: *SchedulerLoop,\n-\n-    // Fields known only to the runtime\n-    kernel: *Kernel,\n-    name: *c_char,\n-    list_index: i32,\n-    boxed_region: BoxedRegion\n-}\n \n /*\n  * Box annihilation\n@@ -132,9 +39,9 @@ unsafe fn each_live_alloc(read_next_before: bool,\n     //! Walks the internal list of allocations\n \n     use managed;\n+    use rt::local_heap;\n \n-    let task: *Task = transmute(rustrt::rust_get_task());\n-    let box = (*task).boxed_region.live_allocs;\n+    let box = local_heap::live_allocs();\n     let mut box: *mut BoxRepr = transmute(copy box);\n     while box != mut_null() {\n         let next_before = transmute(copy (*box).header.next);\n@@ -156,7 +63,11 @@ unsafe fn each_live_alloc(read_next_before: bool,\n \n #[cfg(unix)]\n fn debug_mem() -> bool {\n-    ::rt::env::get().debug_mem\n+    // XXX: Need to port the environment struct to newsched\n+    match rt::context() {\n+        OldTaskContext => ::rt::env::get().debug_mem,\n+        _ => false\n+    }\n }\n \n #[cfg(windows)]\n@@ -165,13 +76,12 @@ fn debug_mem() -> bool {\n }\n \n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-#[cfg(not(test))]\n-#[lang=\"annihilate\"]\n pub unsafe fn annihilate() {\n-    use unstable::lang::local_free;\n+    use rt::local_heap::local_free;\n     use io::WriterUtil;\n     use io;\n     use libc;\n+    use rt::borrowck;\n     use sys;\n     use managed;\n \n@@ -183,7 +93,7 @@ pub unsafe fn annihilate() {\n \n     // Quick hack: we need to free this list upon task exit, and this\n     // is a convenient place to do it.\n-    clear_task_borrow_list();\n+    borrowck::clear_task_borrow_list();\n \n     // Pass 1: Make all boxes immortal.\n     //\n@@ -207,7 +117,7 @@ pub unsafe fn annihilate() {\n         if !uniq {\n             let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n             let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n-            drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n+            drop_glue(&tydesc, transmute(&(*box).data));\n         }\n     }\n "}, {"sha": "5ec594cef7ee6c747a0703d6b81801089e28bb97", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -34,33 +34,33 @@ pub trait Clone {\n \n impl<T: Clone> Clone for ~T {\n     /// Return a deep copy of the owned box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> ~T { ~(**self).clone() }\n }\n \n impl<T> Clone for @T {\n     /// Return a shallow copy of the managed box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> @T { *self }\n }\n \n impl<T> Clone for @mut T {\n     /// Return a shallow copy of the managed box.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> @mut T { *self }\n }\n \n impl<'self, T> Clone for &'self T {\n     /// Return a shallow copy of the borrowed pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> &'self T { *self }\n }\n \n macro_rules! clone_impl(\n     ($t:ty) => {\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n-            #[inline(always)]\n+            #[inline]\n             fn clone(&self) -> $t { *self }\n         }\n     }\n@@ -96,31 +96,31 @@ pub trait DeepClone {\n \n impl<T: DeepClone> DeepClone for ~T {\n     /// Return a deep copy of the owned box.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> ~T { ~(**self).deep_clone() }\n }\n \n // FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n impl<T: Const + DeepClone> DeepClone for @T {\n     /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> @T { @(**self).deep_clone() }\n }\n \n // FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n impl<T: Const + DeepClone> DeepClone for @mut T {\n     /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n-    #[inline(always)]\n+    #[inline]\n     fn deep_clone(&self) -> @mut T { @mut (**self).deep_clone() }\n }\n \n macro_rules! deep_clone_impl(\n     ($t:ty) => {\n         impl DeepClone for $t {\n             /// Return a deep copy of the value.\n-            #[inline(always)]\n+            #[inline]\n             fn deep_clone(&self) -> $t { *self }\n         }\n     }"}, {"sha": "2c4bb46b23b83a0cff9dd550ebd5dbac5e1526c5", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -45,7 +45,7 @@ pub trait TotalEq {\n macro_rules! totaleq_impl(\n     ($t:ty) => {\n         impl TotalEq for $t {\n-            #[inline(always)]\n+            #[inline]\n             fn equals(&self, other: &$t) -> bool { *self == *other }\n         }\n     }\n@@ -84,27 +84,27 @@ pub trait TotalOrd: TotalEq {\n }\n \n impl TotalOrd for Ordering {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n impl Ord for Ordering {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &Ordering) -> bool { (*self as int) <= (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &Ordering) -> bool { (*self as int) > (*other as int) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &Ordering) -> bool { (*self as int) >= (*other as int) }\n }\n \n macro_rules! totalord_impl(\n     ($t:ty) => {\n         impl TotalOrd for $t {\n-            #[inline(always)]\n+            #[inline]\n             fn cmp(&self, other: &$t) -> Ordering {\n                 if *self < *other { Less }\n                 else if *self > *other { Greater }\n@@ -146,7 +146,7 @@ Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n lexical ordering on a type `(int, int)`.\n */\n // used in deriving code in libsyntax\n-#[inline(always)]\n+#[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n         Equal => o2,\n@@ -180,12 +180,12 @@ pub trait Equiv<T> {\n     fn equiv(&self, other: &T) -> bool;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }"}, {"sha": "00c33c8ab325d05efa2774b16cc1058938cbb33a", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -20,7 +20,6 @@ use either::{Either, Left, Right};\n use kinds::Owned;\n use option::{Option, Some, None};\n use uint;\n-use vec;\n use vec::OwnedVector;\n use util::replace;\n use unstable::sync::{Exclusive, exclusive};\n@@ -209,7 +208,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n     fn peek(&self) -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n-        for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n+        for uint::range(0, self.ports.len()) |i| {\n             let port: &pipesy::Port<T> = &self.ports[i];\n             if port.peek() {\n                 return true;\n@@ -221,48 +220,58 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n \n /// A channel that can be shared between many senders.\n pub struct SharedChan<T> {\n-    ch: Exclusive<pipesy::Chan<T>>\n+    inner: Either<Exclusive<pipesy::Chan<T>>, rtcomm::SharedChan<T>>\n }\n \n impl<T: Owned> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n         let Chan { inner } = c;\n         let c = match inner {\n-            Left(c) => c,\n-            Right(_) => fail!(\"SharedChan not implemented\")\n+            Left(c) => Left(exclusive(c)),\n+            Right(c) => Right(rtcomm::SharedChan::new(c))\n         };\n-        SharedChan { ch: exclusive(c) }\n+        SharedChan { inner: c }\n     }\n }\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(&self, x: T) {\n-        unsafe {\n-            let mut xx = Some(x);\n-            do self.ch.with_imm |chan| {\n-                let x = replace(&mut xx, None);\n-                chan.send(x.unwrap())\n+        match self.inner {\n+            Left(ref chan) => {\n+                unsafe {\n+                    let mut xx = Some(x);\n+                    do chan.with_imm |chan| {\n+                        let x = replace(&mut xx, None);\n+                        chan.send(x.unwrap())\n+                    }\n+                }\n             }\n+            Right(ref chan) => chan.send(x)\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(&self, x: T) -> bool {\n-        unsafe {\n-            let mut xx = Some(x);\n-            do self.ch.with_imm |chan| {\n-                let x = replace(&mut xx, None);\n-                chan.try_send(x.unwrap())\n+        match self.inner {\n+            Left(ref chan) => {\n+                unsafe {\n+                    let mut xx = Some(x);\n+                    do chan.with_imm |chan| {\n+                        let x = replace(&mut xx, None);\n+                        chan.try_send(x.unwrap())\n+                    }\n+                }\n             }\n+            Right(ref chan) => chan.try_send(x)\n         }\n     }\n }\n \n impl<T: Owned> ::clone::Clone for SharedChan<T> {\n     fn clone(&self) -> SharedChan<T> {\n-        SharedChan { ch: self.ch.clone() }\n+        SharedChan { inner: self.inner.clone() }\n     }\n }\n \n@@ -625,7 +634,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericChan<T> for Chan<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn send(&self, x: T) {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -636,7 +645,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn try_send(&self, x: T) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -653,7 +662,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> GenericPort<T> for Port<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn recv(&self) -> T {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -664,7 +673,7 @@ mod pipesy {\n             }\n         }\n \n-        #[inline(always)]\n+        #[inline]\n         fn try_recv(&self) -> Option<T> {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n@@ -681,7 +690,7 @@ mod pipesy {\n     }\n \n     impl<T: Owned> Peekable<T> for Port<T> {\n-        #[inline(always)]\n+        #[inline]\n         fn peek(&self) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);"}, {"sha": "c1b656f1cd9e6bdc71d818d01f069053bef373d5", "filename": "src/libstd/container.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -16,10 +16,10 @@ use option::Option;\n /// knowledge known is the number of elements contained within.\n pub trait Container {\n     /// Return the number of elements in the container\n-    fn len(&const self) -> uint;\n+    fn len(&self) -> uint;\n \n     /// Return true if the container contains no elements\n-    fn is_empty(&const self) -> bool;\n+    fn is_empty(&self) -> bool;\n }\n \n /// A trait to represent mutable containers"}, {"sha": "6911c00e55ba645c686431ca71697b6bd5b02261", "filename": "src/libstd/core.rc", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -12,19 +12,20 @@\n \n # The Rust standard library\n \n-The Rust standard library provides runtime features required by the language,\n-including the task scheduler and memory allocators, as well as library\n-support for Rust built-in types, platform abstractions, and other commonly\n-used features.\n-\n-`std` includes modules corresponding to each of the integer types, each of\n-the floating point types, the `bool` type, tuples, characters, strings\n-(`str`), vectors (`vec`), managed boxes (`managed`), owned boxes (`owned`),\n-and unsafe and borrowed pointers (`ptr`).  Additionally, `std` provides\n-pervasive types (`option` and `result`), task creation and communication\n-primitives (`task`, `comm`), platform abstractions (`os` and `path`), basic\n-I/O abstractions (`io`), common traits (`kinds`, `ops`, `cmp`, `num`,\n-`to_str`), and complete bindings to the C standard library (`libc`).\n+The Rust standard library is a group of interrelated modules defining\n+the core language traits, operations on built-in data types, collections,\n+platform abstractions, the task scheduler, runtime support for language\n+features and other common functionality.\n+\n+`std` includes modules corresponding to each of the integer types,\n+each of the floating point types, the `bool` type, tuples, characters,\n+strings (`str`), vectors (`vec`), managed boxes (`managed`), owned\n+boxes (`owned`), and unsafe and borrowed pointers (`ptr`, `borrowed`).\n+Additionally, `std` provides pervasive types (`option` and `result`),\n+task creation and communication primitives (`task`, `comm`), platform\n+abstractions (`os` and `path`), basic I/O abstractions (`io`), common\n+traits (`kinds`, `ops`, `cmp`, `num`, `to_str`), and complete bindings\n+to the C standard library (`libc`).\n \n # Standard library injection and the Rust prelude\n \n@@ -38,7 +39,7 @@ with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n etc.\n \n Additionally, `std` contains a `prelude` module that reexports many of the\n-most common std modules, types and traits. The contents of the prelude are\n+most common types, traits and functions. The contents of the prelude are\n imported into every *module* by default.  Implicitly, all modules behave as if\n they contained the following prologue:\n \n@@ -56,17 +57,13 @@ they contained the following prologue:\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-// NOTE: remove these two attributes after the next snapshot\n-#[no_core]; // for stage0\n-#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n-\n // Don't link to std. We are std.\n #[no_std];\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n-// Make core testable by not duplicating lang items. See #2912\n+// Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern mod realstd(name = \"std\");\n #[cfg(test)] pub use kinds = realstd::kinds;\n #[cfg(test)] pub use ops = realstd::ops;"}, {"sha": "681a7fbc821f89273d72b325afcdde87abb7becd", "filename": "src/libstd/either.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -33,7 +33,7 @@ pub enum Either<T, U> {\n /// If `value` is left(T) then `f_left` is applied to its contents, if\n /// `value` is right(U) then `f_right` is applied to its contents, and the\n /// result is returned.\n-#[inline(always)]\n+#[inline]\n pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n                        f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n     match *value {\n@@ -47,7 +47,7 @@ pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n-                Left(ref l) => { push(*l); }\n+                Left(ref l) => { push(copy *l); }\n                 _ => { /* fallthrough */ }\n             }\n         }\n@@ -59,7 +59,7 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n-                Right(ref r) => { push(*r); }\n+                Right(ref r) => { push(copy *r); }\n                 _ => { /* fallthrough */ }\n             }\n         }\n@@ -83,7 +83,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n }\n \n /// Flips between left and right of a given either\n-#[inline(always)]\n+#[inline]\n pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     match eith {\n         Right(r) => Left(r),\n@@ -95,7 +95,7 @@ pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n ///\n /// Converts an `either` type to a `result` type, making the \"right\" choice\n /// an ok result, and the \"left\" choice a fail\n-#[inline(always)]\n+#[inline]\n pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n     match eith {\n         Right(r) => result::Ok(r),\n@@ -104,7 +104,7 @@ pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n }\n \n /// Checks whether the given value is a left\n-#[inline(always)]\n+#[inline]\n pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     match *eith {\n         Left(_) => true,\n@@ -113,7 +113,7 @@ pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n }\n \n /// Checks whether the given value is a right\n-#[inline(always)]\n+#[inline]\n pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     match *eith {\n         Right(_) => true,\n@@ -122,7 +122,7 @@ pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n }\n \n /// Retrieves the value in the left branch. Fails if the either is Right.\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     match eith {\n         Left(x) => x,\n@@ -131,7 +131,7 @@ pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n }\n \n /// Retrieves the value in the right branch. Fails if the either is Left.\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     match eith {\n         Right(x) => x,\n@@ -140,27 +140,27 @@ pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n }\n \n impl<T, U> Either<T, U> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n         either(f_left, f_right, self)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn flip(self) -> Either<U, T> { flip(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn to_result(self) -> Result<U, T> { to_result(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_left(&self) -> bool { is_left(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_right(&self) -> bool { is_right(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_left(self) -> T { unwrap_left(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_right(self) -> U { unwrap_right(self) }\n }\n "}, {"sha": "1967a57e867fb18f440a446e457a394748a01498", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -64,7 +64,7 @@ pub trait HashUtil {\n }\n \n impl<A:Hash> HashUtil for A {\n-    #[inline(always)]\n+    #[inline]\n     fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n }\n \n@@ -79,7 +79,7 @@ pub trait Streaming {\n }\n \n impl<A:IterBytes> Hash for A {\n-    #[inline(always)]\n+    #[inline]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         let mut s = State::new(k0, k1);\n         for self.iter_bytes(true) |bytes| {\n@@ -176,7 +176,7 @@ fn hash_keyed_5<A: IterBytes,\n     s.result_u64()\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn default_state() -> State {\n     State::new(0, 0)\n }\n@@ -194,7 +194,7 @@ struct SipState {\n }\n \n impl SipState {\n-    #[inline(always)]\n+    #[inline]\n     fn new(key0: u64, key1: u64) -> SipState {\n         let mut state = SipState {\n             k0: key0,\n@@ -248,7 +248,7 @@ macro_rules! compress (\n \n impl Writer for SipState {\n     // Methods for io::writer\n-    #[inline(always)]\n+    #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n@@ -315,12 +315,12 @@ impl Writer for SipState {\n }\n \n impl Streaming for SipState {\n-    #[inline(always)]\n+    #[inline]\n     fn input(&mut self, buf: &[u8]) {\n         self.write(buf);\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn result_u64(&mut self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n@@ -373,7 +373,7 @@ impl Streaming for SipState {\n         s\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n@@ -558,4 +558,15 @@ mod tests {\n             val & !(0xff << (byte * 8))\n         }\n     }\n+\n+    #[test]\n+    fn test_float_hashes_differ() {\n+        assert!(0.0.hash() != 1.0.hash());\n+        assert!(1.0.hash() != (-1.0).hash());\n+    }\n+\n+    #[test]\n+    fn test_float_hashes_of_zero() {\n+        assert_eq!(0.0.hash(), (-0.0).hash());\n+    }\n }"}, {"sha": "d05fa63a6f9b3bc74c248291224480af2e847568", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -59,7 +59,7 @@ enum SearchResult {\n     FoundEntry(uint), FoundHole(uint), TableFull\n }\n \n-#[inline(always)]\n+#[inline]\n fn resize_at(capacity: uint) -> uint {\n     ((capacity as float) * 3. / 4.) as uint\n }\n@@ -85,19 +85,19 @@ fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n }\n \n impl<K:Hash + Eq,V> HashMap<K, V> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n         // bits is assumed. SipHash is more than good enough.\n         h % self.buckets.len()\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n         (idx + 1) % len_buckets\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_sequence(&self, hash: uint,\n                        op: &fn(uint) -> bool) -> bool {\n         let start_idx = self.to_bucket(hash);\n@@ -112,20 +112,20 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key(&self, k: &K) -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash(hash, k)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n                                                -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_with_hash(&self,\n                                 hash: uint,\n                                 k: &K)\n@@ -141,7 +141,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         TableFull\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n                                                   hash: uint,\n                                                   k: &Q)\n@@ -161,7 +161,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n     /// Expand the capacity of the array to the next power of two\n     /// and re-insert each of the existing buckets.\n-    #[inline(always)]\n+    #[inline]\n     fn expand(&mut self) {\n         let new_capacity = self.buckets.len() * 2;\n         self.resize(new_capacity);\n@@ -190,15 +190,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n             None => fail!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n         match self.buckets[idx] {\n             Some(ref mut bkt) => &mut bkt.value,"}, {"sha": "e5e8a4cb601817c5e63f6420245148d66f7f3323", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1654,9 +1654,7 @@ impl Writer for BytesWriter {\n         vec::reserve(bytes, count);\n \n         unsafe {\n-            // Silly stage0 borrow check workaround...\n-            let casted: &mut ~[u8] = cast::transmute_copy(&bytes);\n-            vec::raw::set_len(casted, count);\n+            vec::raw::set_len(bytes, count);\n \n             let view = vec::mut_slice(*bytes, *self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);\n@@ -1667,7 +1665,7 @@ impl Writer for BytesWriter {\n \n     fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = *self.pos;\n-        let len = vec::uniq_len(&const *self.bytes);\n+        let len = self.bytes.len();\n         *self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -1779,7 +1777,7 @@ pub mod fsync {\n                 None => (),\n                 Some(level) => {\n                   // fail hard if not succesful\n-                  assert!(((self.arg.fsync_fn)(self.arg.val, level)\n+                  assert!(((self.arg.fsync_fn)(copy self.arg.val, level)\n                     != -1));\n                 }\n             }"}, {"sha": "7053cbe0df5a6478c47abb0398706334ba4d14ed", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -73,7 +73,7 @@ pub trait FromIter<T> {\n  * assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn any<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     for iter |x| {\n@@ -94,7 +94,7 @@ pub fn any<T>(predicate: &fn(T) -> bool,\n  * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn all<T>(predicate: &fn(T) -> bool,\n               iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     // If we ever break, iter will return false, so this will only return true\n@@ -112,7 +112,7 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n  * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn find<T>(predicate: &fn(&T) -> bool,\n                iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     for iter |x| {\n@@ -226,7 +226,7 @@ pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&m\n  * assert_eq!(do sum |f| { xs.each(f) }, 10);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n }\n@@ -241,7 +241,7 @@ pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  * assert_eq!(do product |f| { xs.each(f) }, 24);\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n }"}, {"sha": "eefad1a03dcb22f4a7b1da438f60bd3bd9cbe815", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -308,66 +308,72 @@ pub trait IteratorUtil<A> {\n     /// assert!(!it.any_(|&x| *x == 3));\n     /// ~~~\n     fn any_(&mut self, f: &fn(A) -> bool) -> bool;\n+\n+    /// Return the first element satisfying the specified predicate\n+    fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A>;\n+\n+    /// Return the index of the first element satisfying the specified predicate\n+    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n /// implementations of the `Iterator` trait.\n ///\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, T, B, U> {\n         ZipIterator{a: self, b: other}\n     }\n \n     // FIXME: #5898: should be called map\n-    #[inline(always)]\n+    #[inline]\n     fn transform<'r, B>(self, f: &'r fn(A) -> B) -> MapIterator<'r, A, B, T> {\n         MapIterator{iter: self, f: f}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> FilterIterator<'r, A, T> {\n         FilterIterator{iter: self, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMapIterator<'r, A, B, T> {\n         FilterMapIterator { iter: self, f: f }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn enumerate(self) -> EnumerateIterator<A, T> {\n         EnumerateIterator{iter: self, count: 0}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhileIterator<'r, A, T> {\n         SkipWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, T> {\n         TakeWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn skip(self, n: uint) -> SkipIterator<A, T> {\n         SkipIterator{iter: self, n: n}\n     }\n \n     // FIXME: #5898: should be called take\n-    #[inline(always)]\n+    #[inline]\n     fn take_(self, n: uint) -> TakeIterator<A, T> {\n         TakeIterator{iter: self, n: n}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, T, St> {\n         ScanIterator{iter: self, f: f, state: initial_state}\n@@ -386,13 +392,13 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn collect<B: FromIter<A>>(&mut self) -> B {\n         FromIter::from_iter::<A, B>(|f| self.advance(f))\n     }\n \n     /// Return the `n`th item yielded by an iterator.\n-    #[inline(always)]\n+    #[inline]\n     fn nth(&mut self, mut n: uint) -> Option<A> {\n         loop {\n             match self.next() {\n@@ -404,7 +410,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     /// Return the last item yielded by an iterator.\n-    #[inline(always)]\n+    #[inline]\n     fn last_(&mut self) -> Option<A> {\n         let mut last = None;\n         for self.advance |x| { last = Some(x); }\n@@ -421,23 +427,45 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n                 None    => { break; }\n             }\n         }\n-        return accum;\n+        accum\n     }\n \n     /// Count the number of items yielded by an iterator\n-    #[inline(always)]\n+    #[inline]\n     fn count(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if !f(x) { return false; } }\n-        return true;\n+        true\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn any_(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if f(x) { return true; } }\n-        return false;\n+        false\n+    }\n+\n+    /// Return the first element satisfying the specified predicate\n+    #[inline]\n+    fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n+        for self.advance |x| {\n+            if predicate(&x) { return Some(x) }\n+        }\n+        None\n+    }\n+\n+    /// Return the index of the first element satisfying the specified predicate\n+    #[inline]\n+    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+        let mut i = 0;\n+        for self.advance |x| {\n+            if predicate(x) {\n+                return Some(i);\n+            }\n+            i += 1;\n+        }\n+        None\n     }\n }\n \n@@ -456,7 +484,7 @@ pub trait AdditiveIterator<A> {\n }\n \n impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn sum(&mut self) -> A { self.fold(Zero::zero::<A>(), |s, x| s + x) }\n }\n \n@@ -481,7 +509,7 @@ pub trait MultiplicativeIterator<A> {\n }\n \n impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn product(&mut self) -> A { self.fold(One::one::<A>(), |p, x| p * x) }\n }\n \n@@ -510,7 +538,7 @@ pub trait OrdIterator<A> {\n }\n \n impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n-    #[inline(always)]\n+    #[inline]\n     fn max(&mut self) -> Option<A> {\n         self.fold(None, |max, x| {\n             match max {\n@@ -520,7 +548,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n         })\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min(&mut self) -> Option<A> {\n         self.fold(None, |min, x| {\n             match min {\n@@ -788,8 +816,8 @@ impl<'self, A, St> UnfoldrIterator<'self, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the iterator\n     #[inline]\n-    pub fn new(f: &'self fn(&mut St) -> Option<A>, initial_state: St)\n-        -> UnfoldrIterator<'self, A, St> {\n+    pub fn new<'a>(f: &'a fn(&mut St) -> Option<A>, initial_state: St)\n+        -> UnfoldrIterator<'a, A, St> {\n         UnfoldrIterator {\n             f: f,\n             state: initial_state\n@@ -815,14 +843,14 @@ pub struct Counter<A> {\n \n impl<A> Counter<A> {\n     /// Creates a new counter with the specified start/step\n-    #[inline(always)]\n+    #[inline]\n     pub fn new(start: A, step: A) -> Counter<A> {\n         Counter{state: start, step: step}\n     }\n }\n \n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> Option<A> {\n         let result = self.state.clone();\n         self.state = self.state.add(&self.step); // FIXME: #6050\n@@ -1055,4 +1083,20 @@ mod tests {\n         assert!(!v.iter().any_(|&x| x > 100));\n         assert!(!v.slice(0, 0).iter().any_(|_| fail!()));\n     }\n+\n+    #[test]\n+    fn test_find() {\n+        let v = &[1, 3, 9, 27, 103, 14, 11];\n+        assert_eq!(*v.iter().find_(|x| *x & 1 == 0).unwrap(), 14);\n+        assert_eq!(*v.iter().find_(|x| *x % 3 == 0).unwrap(), 3);\n+        assert!(v.iter().find_(|x| *x % 12 == 0).is_none());\n+    }\n+\n+    #[test]\n+    fn test_position() {\n+        let v = &[1, 3, 9, 27, 103, 14, 11];\n+        assert_eq!(v.iter().position_(|x| *x & 1 == 0).unwrap(), 5);\n+        assert_eq!(v.iter().position_(|x| *x % 3 == 0).unwrap(), 1);\n+        assert!(v.iter().position_(|x| *x % 12 == 0).is_none());\n+    }\n }"}, {"sha": "07b2ac6ed01b563ef51a0274fdff13ff12954400", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,8 +14,8 @@\n * This module contains bindings to the C standard library,\n * organized into modules by their defining standard.\n * Additionally, it contains some assorted platform-specific definitions.\n-* For convenience, most functions and types are reexported from `core::libc`,\n-* so `pub use core::libc::*` will import the available\n+* For convenience, most functions and types are reexported from `std::libc`,\n+* so `pub use std::libc::*` will import the available\n * C bindings as appropriate for the target platform. The exact\n * set of functions available are platform specific.\n *\n@@ -1457,11 +1457,11 @@ pub mod funcs {\n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n                 #[rust_stack]\n-                #[inline(always)]\n+                #[inline]\n                 unsafe fn memcmp(cx: *c_void, ct: *c_void, n: size_t)\n                               -> c_int;\n                 #[rust_stack]\n-                #[inline(always)]\n+                #[inline]\n                 unsafe fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n             }\n         }"}, {"sha": "743b71e33ea802538f05886227f53a0ec8d28ab6", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -11,13 +11,20 @@\n //! Logging\n \n use option::*;\n+use os;\n use either::*;\n+use rt;\n+use rt::OldTaskContext;\n use rt::logging::{Logger, StdErrLogger};\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n-    unsafe {\n-        rustrt::rust_log_console_on();\n+    if rt::context() == OldTaskContext {\n+        unsafe {\n+            rustrt::rust_log_console_on();\n+        }\n+    } else {\n+        rt::logging::console_on();\n     }\n }\n \n@@ -29,8 +36,17 @@ pub fn console_on() {\n  * the RUST_LOG environment variable\n  */\n pub fn console_off() {\n-    unsafe {\n-        rustrt::rust_log_console_off();\n+    // If RUST_LOG is set then the console can't be turned off\n+    if os::getenv(\"RUST_LOG\").is_some() {\n+        return;\n+    }\n+\n+    if rt::context() == OldTaskContext {\n+        unsafe {\n+            rustrt::rust_log_console_off();\n+        }\n+    } else {\n+        rt::logging::console_off();\n     }\n }\n "}, {"sha": "d514612b5afd8205401b76370e6c2514488f1a11", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -38,56 +38,56 @@ pub mod raw {\n }\n \n /// Determine if two shared boxes point to the same object\n-#[inline(always)]\n+#[inline]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n \n /// Determine if two mutable shared boxes point to the same object\n-#[inline(always)]\n+#[inline]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @mut T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @mut T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "40f6d53ed22f063b1b92ae26c1678be7fb5fbb69", "filename": "src/libstd/nil.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnil.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,32 +19,32 @@ use prelude::*;\n \n #[cfg(not(test))]\n impl Eq for () {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(not(test))]\n impl Ord for () {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, _other: &()) -> bool { false }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, _other: &()) -> bool { true }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for () {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, _other: &()) -> Ordering { Equal }\n }\n \n #[cfg(not(test))]\n impl TotalEq for () {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, _other: &()) -> bool { true }\n }"}, {"sha": "117a474ffd7d3b4bc12aaace61c80e1465161da3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 129, "deletions": 129, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -20,7 +20,7 @@ use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n-// An inner module is required to get the #[inline(always)] attribute on the\n+// An inner module is required to get the #[inline] attribute on the\n // functions.\n pub use self::delegated::*;\n \n@@ -40,7 +40,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline(always)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)\n@@ -115,45 +115,45 @@ pub static infinity: f32 = 1.0_f32/0.0_f32;\n \n pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-#[inline(always)]\n+#[inline]\n pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmax(x: f32, y: f32) -> f32 {\n     if x >= y || y.is_NaN() { x } else { y }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmin(x: f32, y: f32) -> f32 {\n     if x <= y || y.is_NaN() { x } else { y }\n }\n@@ -212,56 +212,56 @@ impl Num for f32 {}\n \n #[cfg(not(test))]\n impl Eq for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> f32 { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &f32) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f32, f32>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &f32, approx_epsilon: &f32) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for f32 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &f32) -> f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &f32) -> f32 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         cond!(\n             (self.is_NaN())   { *self }\n@@ -273,65 +273,65 @@ impl Orderable for f32 {\n }\n \n impl Zero for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> f32 { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> f32 { 1.0 }\n }\n \n #[cfg(not(test))]\n impl Add<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<f32,f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &f32) -> f32 { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<f32> for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> f32 { -*self }\n }\n \n impl Signed for f32 {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> f32 { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n \n     ///\n@@ -341,35 +341,35 @@ impl Signed for f32 {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> f32 {\n         if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Round for f32 {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> f32 { floor(*self) }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> f32 { ceil(*self) }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> f32 { round(*self) }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> f32 { trunc(*self) }\n \n     ///\n@@ -379,96 +379,96 @@ impl Round for f32 {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> f32 { *self - self.trunc() }\n }\n \n impl Fractional for f32 {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> f32 { 1.0 / *self }\n }\n \n impl Algebraic for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &f32) -> f32 { pow(*self, *n) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> f32 { sqrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> f32 { cbrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &f32) -> f32 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> f32 { sin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> f32 { cos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> f32 { tan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> f32 { asin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> f32 { acos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> f32 { atan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &f32) -> f32 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (f32, f32) {\n         (self.sin(), self.cos())\n     }\n }\n \n impl Exponential for f32 {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> f32 { exp(*self) }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> f32 { exp2(*self) }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> f32 { ln(*self) }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> f32 { log2(*self) }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> f32 { log10(*self) }\n }\n \n impl Hyperbolic for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> f32 { sinh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> f32 { cosh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> f32 { tanh(*self) }\n \n     ///\n@@ -480,7 +480,7 @@ impl Hyperbolic for f32 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> f32 {\n         match *self {\n             neg_infinity => neg_infinity,\n@@ -497,7 +497,7 @@ impl Hyperbolic for f32 {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> f32 {\n         match *self {\n             x if x < 1.0 => Float::NaN(),\n@@ -517,137 +517,137 @@ impl Hyperbolic for f32 {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> f32 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n     }\n }\n \n impl Real for f32 {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n     /// 1 .0/ pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n     /// 2.0 / sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> f32 { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n }\n \n impl Bounded for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> f32 { 1.17549435e-38 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> f32 { 3.40282347e+38 }\n }\n \n impl Primitive for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { 32 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n }\n \n impl Float for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> f32 { 0.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> f32 { 1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> f32 { -1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool {\n         self.classify() == FPNormal\n     }\n@@ -670,29 +670,29 @@ impl Float for f32 {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { 24 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { 6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> f32 { 1.19209290e-07 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { -125 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { 128 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { -37 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { 38 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: f32, exp: int) -> f32 {\n         ldexp(x, exp as c_int)\n     }\n@@ -703,7 +703,7 @@ impl Float for f32 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (f32, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n@@ -714,28 +714,28 @@ impl Float for f32 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> f32 { exp_m1(*self) }\n \n     ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> f32 { ln_1p(*self) }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: f32, b: f32) -> f32 {\n         mul_add(*self, a, b)\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: f32) -> f32 {\n         next_after(*self, other)\n     }\n@@ -752,7 +752,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -766,7 +766,7 @@ pub fn to_str(num: f32) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -787,7 +787,7 @@ pub fn to_str_hex(num: f32) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n@@ -805,7 +805,7 @@ pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -820,7 +820,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n@@ -836,20 +836,20 @@ pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n@@ -882,7 +882,7 @@ impl num::ToStrRadix for f32 {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -915,7 +915,7 @@ pub fn from_str(num: &str) -> Option<f32> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -940,19 +940,19 @@ pub fn from_str_hex(num: &str) -> Option<f32> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<f32> { from_str(val) }\n }\n \n impl num::FromStrRadix for f32 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         from_str_radix(val, rdx)\n     }"}, {"sha": "e13dff1e623573854df48db1cfa3aea991ccdd26", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 132, "deletions": 132, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -22,7 +22,7 @@ use to_str;\n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n-// An inner module is required to get the #[inline(always)] attribute on the\n+// An inner module is required to get the #[inline] attribute on the\n // functions.\n pub use self::delegated::*;\n \n@@ -42,7 +42,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline(always)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)\n@@ -141,45 +141,45 @@ pub static infinity: f64 = 1.0_f64/0.0_f64;\n \n pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-#[inline(always)]\n+#[inline]\n pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmax(x: f64, y: f64) -> f64 {\n     if x >= y || y.is_NaN() { x } else { y }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn fmin(x: f64, y: f64) -> f64 {\n     if x <= y || y.is_NaN() { x } else { y }\n }\n@@ -234,56 +234,56 @@ impl Num for f64 {}\n \n #[cfg(not(test))]\n impl Eq for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<f64> for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> f64 { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &f64) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f64, f64>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &f64, approx_epsilon: &f64) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for f64 {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &f64) -> f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &f64) -> f64 {\n         if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         cond!(\n             (self.is_NaN())   { *self }\n@@ -295,16 +295,16 @@ impl Orderable for f64 {\n }\n \n impl Zero for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> f64 { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> f64 { 1.0 }\n }\n \n@@ -326,7 +326,7 @@ impl Div<f64,f64> for f64 {\n }\n #[cfg(not(test))]\n impl Rem<f64,f64> for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &f64) -> f64 { *self % *other }\n }\n #[cfg(not(test))]\n@@ -336,14 +336,14 @@ impl Neg<f64> for f64 {\n \n impl Signed for f64 {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> f64 { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n \n     ///\n@@ -353,35 +353,35 @@ impl Signed for f64 {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> f64 {\n         if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Round for f64 {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> f64 { floor(*self) }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> f64 { ceil(*self) }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> f64 { round(*self) }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> f64 { trunc(*self) }\n \n     ///\n@@ -391,96 +391,96 @@ impl Round for f64 {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> f64 { *self - self.trunc() }\n }\n \n impl Fractional for f64 {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> f64 { 1.0 / *self }\n }\n \n impl Algebraic for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &f64) -> f64 { pow(*self, *n) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> f64 { sqrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> f64 { cbrt(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &f64) -> f64 { hypot(*self, *other) }\n }\n \n impl Trigonometric for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> f64 { sin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> f64 { cos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> f64 { tan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> f64 { asin(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> f64 { acos(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> f64 { atan(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &f64) -> f64 { atan2(*self, *other) }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (f64, f64) {\n         (self.sin(), self.cos())\n     }\n }\n \n impl Exponential for f64 {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> f64 { exp(*self) }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> f64 { exp2(*self) }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> f64 { ln(*self) }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> f64 { log2(*self) }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> f64 { log10(*self) }\n }\n \n impl Hyperbolic for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> f64 { sinh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> f64 { cosh(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> f64 { tanh(*self) }\n \n     ///\n@@ -492,7 +492,7 @@ impl Hyperbolic for f64 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> f64 {\n         match *self {\n             neg_infinity => neg_infinity,\n@@ -509,7 +509,7 @@ impl Hyperbolic for f64 {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> f64 {\n         match *self {\n             x if x < 1.0 => Float::NaN(),\n@@ -529,167 +529,167 @@ impl Hyperbolic for f64 {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> f64 {\n         0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n     }\n }\n \n impl Real for f64 {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n \n     /// 1.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n \n     /// 2.0 / sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> f64 { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n }\n \n impl RealExt for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn lgamma(&self) -> (int, f64) {\n         let mut sign = 0;\n         let result = lgamma(*self, &mut sign);\n         (sign as int, result)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tgamma(&self) -> f64 { tgamma(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j0(&self) -> f64 { j0(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j1(&self) -> f64 { j1(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn jn(&self, n: int) -> f64 { jn(n as c_int, *self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y0(&self) -> f64 { y0(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y1(&self) -> f64 { y1(*self) }\n \n-    #[inline(always)]\n+    #[inline]\n     fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n impl Bounded for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> f64 { 2.2250738585072014e-308 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> f64 { 1.7976931348623157e+308 }\n }\n \n impl Primitive for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { 64 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n }\n \n impl Float for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> f64 { 0.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> f64 { 1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> f64 { -1.0 / 0.0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool {\n         self.classify() == FPNormal\n     }\n@@ -712,29 +712,29 @@ impl Float for f64 {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { 53 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { 15 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> f64 { 2.2204460492503131e-16 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { -1021 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { 1024 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { -307 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { 308 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: f64, exp: int) -> f64 {\n         ldexp(x, exp as c_int)\n     }\n@@ -745,7 +745,7 @@ impl Float for f64 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (f64, int) {\n         let mut exp = 0;\n         let x = frexp(*self, &mut exp);\n@@ -756,28 +756,28 @@ impl Float for f64 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> f64 { exp_m1(*self) }\n \n     ///\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> f64 { ln_1p(*self) }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: f64, b: f64) -> f64 {\n         mul_add(*self, a, b)\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: f64) -> f64 {\n         next_after(*self, other)\n     }\n@@ -794,7 +794,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -808,7 +808,7 @@ pub fn to_str(num: f64) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -829,7 +829,7 @@ pub fn to_str_hex(num: f64) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, rdx, true, strconv::SignNeg, strconv::DigAll);\n@@ -847,7 +847,7 @@ pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -862,7 +862,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n@@ -878,20 +878,20 @@ pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n impl to_str::ToStr for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         to_str_radix(*self, rdx)\n     }\n@@ -924,7 +924,7 @@ impl num::ToStrRadix for f64 {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -957,7 +957,7 @@ pub fn from_str(num: &str) -> Option<f64> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -982,19 +982,19 @@ pub fn from_str_hex(num: &str) -> Option<f64> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<f64> { from_str(val) }\n }\n \n impl num::FromStrRadix for f64 {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         from_str_radix(val, rdx)\n     }"}, {"sha": "c583aeacf162dd4a84fb12bb220f27f9752b19a1", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 129, "deletions": 129, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -99,7 +99,7 @@ pub mod consts {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n@@ -113,7 +113,7 @@ pub fn to_str(num: float) -> ~str {\n ///\n /// * num - The float value\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n@@ -134,7 +134,7 @@ pub fn to_str_hex(num: float) -> ~str {\n /// possible misinterpretation of the result at higher bases. If those values\n /// are expected, use `to_str_radix_special()` instead.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n@@ -152,7 +152,7 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n@@ -167,7 +167,7 @@ pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n@@ -183,20 +183,20 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n ///\n-#[inline(always)]\n+#[inline]\n pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n \n impl to_str::ToStr for float {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n }\n \n impl num::ToStrRadix for float {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n@@ -229,7 +229,7 @@ impl num::ToStrRadix for float {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n@@ -262,7 +262,7 @@ pub fn from_str(num: &str) -> Option<float> {\n /// `none` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n@@ -287,19 +287,19 @@ pub fn from_str_hex(num: &str) -> Option<float> {\n /// `none` if the string did not represent a valid number. Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `num`.\n ///\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n                              strconv::ExpNone, false, false)\n }\n \n impl FromStr for float {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(val: &str) -> Option<float> { from_str(val) }\n }\n \n impl num::FromStrRadix for float {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n         from_str_radix(val, radix)\n     }\n@@ -341,27 +341,27 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn abs(x: float) -> float {\n     f64::abs(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn sqrt(x: float) -> float {\n     f64::sqrt(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn atan(x: float) -> float {\n     f64::atan(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn sin(x: float) -> float {\n     f64::sin(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn cos(x: float) -> float {\n     f64::cos(x as f64) as float\n }\n-#[inline(always)]\n+#[inline]\n pub fn tan(x: float) -> float {\n     f64::tan(x as f64) as float\n }\n@@ -370,90 +370,90 @@ impl Num for float {}\n \n #[cfg(not(test))]\n impl Eq for float {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n #[cfg(not(test))]\n impl ApproxEq<float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn approx_epsilon() -> float { 1.0e-6 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq(&self, other: &float) -> bool {\n         self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<float, float>())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn approx_eq_eps(&self, other: &float, approx_epsilon: &float) -> bool {\n         (*self - *other).abs() < *approx_epsilon\n     }\n }\n \n #[cfg(not(test))]\n impl Ord for float {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n impl Orderable for float {\n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &float) -> float {\n         (*self as f64).min(&(*other as f64)) as float\n     }\n \n     /// Returns `NaN` if either of the numbers are `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &float) -> float {\n         (*self as f64).max(&(*other as f64)) as float\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n     /// If any of the numbers are `NaN` then `NaN` is returned.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &float, mx: &float) -> float {\n         (*self as f64).clamp(&(*mn as f64), &(*mx as f64)) as float\n     }\n }\n \n impl Zero for float {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> float { 0.0 }\n \n     /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n impl One for float {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> float { 1.0 }\n }\n \n impl Round for float {\n     /// Round half-way cases toward `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn floor(&self) -> float { floor(*self as f64) as float }\n \n     /// Round half-way cases toward `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn ceil(&self) -> float { ceil(*self as f64) as float }\n \n     /// Round half-way cases away from `0.0`\n-    #[inline(always)]\n+    #[inline]\n     fn round(&self) -> float { round(*self as f64) as float }\n \n     /// The integer part of the number (rounds towards `0.0`)\n-    #[inline(always)]\n+    #[inline]\n     fn trunc(&self) -> float { trunc(*self as f64) as float }\n \n     ///\n@@ -463,81 +463,81 @@ impl Round for float {\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn fract(&self) -> float { *self - self.trunc() }\n }\n \n impl Fractional for float {\n     /// The reciprocal (multiplicative inverse) of the number\n-    #[inline(always)]\n+    #[inline]\n     fn recip(&self) -> float { 1.0 / *self }\n }\n \n impl Algebraic for float {\n-    #[inline(always)]\n+    #[inline]\n     fn pow(&self, n: &float) -> float {\n         (*self as f64).pow(&(*n as f64)) as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn sqrt(&self) -> float {\n         (*self as f64).sqrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn rsqrt(&self) -> float {\n         (*self as f64).rsqrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cbrt(&self) -> float {\n         (*self as f64).cbrt() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn hypot(&self, other: &float) -> float {\n         (*self as f64).hypot(&(*other as f64)) as float\n     }\n }\n \n impl Trigonometric for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sin(&self) -> float {\n         (*self as f64).sin() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cos(&self) -> float {\n         (*self as f64).cos() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tan(&self) -> float {\n         (*self as f64).tan() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn asin(&self) -> float {\n         (*self as f64).asin() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn acos(&self) -> float {\n         (*self as f64).acos() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan(&self) -> float {\n         (*self as f64).atan() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn atan2(&self, other: &float) -> float {\n         (*self as f64).atan2(&(*other as f64)) as float\n     }\n \n     /// Simultaneously computes the sine and cosine of the number\n-    #[inline(always)]\n+    #[inline]\n     fn sin_cos(&self) -> (float, float) {\n         match (*self as f64).sin_cos() {\n             (s, c) => (s as float, c as float)\n@@ -547,54 +547,54 @@ impl Trigonometric for float {\n \n impl Exponential for float {\n     /// Returns the exponential of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp(&self) -> float {\n         (*self as f64).exp() as float\n     }\n \n     /// Returns 2 raised to the power of the number\n-    #[inline(always)]\n+    #[inline]\n     fn exp2(&self) -> float {\n         (*self as f64).exp2() as float\n     }\n \n     /// Returns the natural logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn ln(&self) -> float {\n         (*self as f64).ln() as float\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline(always)]\n+    #[inline]\n     fn log(&self, base: &float) -> float {\n         (*self as f64).log(&(*base as f64)) as float\n     }\n \n     /// Returns the base 2 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log2(&self) -> float {\n         (*self as f64).log2() as float\n     }\n \n     /// Returns the base 10 logarithm of the number\n-    #[inline(always)]\n+    #[inline]\n     fn log10(&self) -> float {\n         (*self as f64).log10() as float\n     }\n }\n \n impl Hyperbolic for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sinh(&self) -> float {\n         (*self as f64).sinh() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn cosh(&self) -> float {\n         (*self as f64).cosh() as float\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tanh(&self) -> float {\n         (*self as f64).tanh() as float\n     }\n@@ -608,7 +608,7 @@ impl Hyperbolic for float {\n     /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n     /// - `NaN` if `self` is `NaN`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn asinh(&self) -> float {\n         (*self as f64).asinh() as float\n     }\n@@ -622,7 +622,7 @@ impl Hyperbolic for float {\n     /// - `infinity` if `self` is `infinity`\n     /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn acosh(&self) -> float {\n         (*self as f64).acosh() as float\n     }\n@@ -639,165 +639,165 @@ impl Hyperbolic for float {\n     /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `infinity` and `neg_infinity`)\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn atanh(&self) -> float {\n         (*self as f64).atanh() as float\n     }\n }\n \n impl Real for float {\n     /// Archimedes' constant\n-    #[inline(always)]\n+    #[inline]\n     fn pi() -> float { 3.14159265358979323846264338327950288 }\n \n     /// 2.0 * pi\n-    #[inline(always)]\n+    #[inline]\n     fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n \n     /// pi / 2.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n \n     /// pi / 3.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n \n     /// pi / 4.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n \n     /// pi / 6.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n \n     /// pi / 8.0\n-    #[inline(always)]\n+    #[inline]\n     fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n \n     /// 1.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n \n     /// 2.0 / pi\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n \n     /// 2 .0/ sqrt(pi)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n \n     /// sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n \n     /// 1.0 / sqrt(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n \n     /// Euler's number\n-    #[inline(always)]\n+    #[inline]\n     fn e() -> float { 2.71828182845904523536028747135266250 }\n \n     /// log2(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n \n     /// log10(e)\n-    #[inline(always)]\n+    #[inline]\n     fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n \n     /// ln(2.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_2() -> float { 0.693147180559945309417232121458176568 }\n \n     /// ln(10.0)\n-    #[inline(always)]\n+    #[inline]\n     fn ln_10() -> float { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n-    #[inline(always)]\n+    #[inline]\n     fn to_degrees(&self) -> float { (*self as f64).to_degrees() as float }\n \n     /// Converts to radians, assuming the number is in degrees\n-    #[inline(always)]\n+    #[inline]\n     fn to_radians(&self) -> float { (*self as f64).to_radians() as float }\n }\n \n impl RealExt for float {\n-    #[inline(always)]\n+    #[inline]\n     fn lgamma(&self) -> (int, float) {\n         let mut sign = 0;\n         let result = lgamma(*self as f64, &mut sign);\n         (sign as int, result as float)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn tgamma(&self) -> float { tgamma(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j0(&self) -> float { j0(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn j1(&self) -> float { j1(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn jn(&self, n: int) -> float { jn(n as c_int, *self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y0(&self) -> float { y0(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn y1(&self) -> float { y1(*self as f64) as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn yn(&self, n: int) -> float { yn(n as c_int, *self as f64) as float }\n }\n \n #[cfg(not(test))]\n impl Add<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &float) -> float { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &float) -> float { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<float,float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &float) -> float { *self % *other }\n }\n #[cfg(not(test))]\n impl Neg<float> for float {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> float { -*self }\n }\n \n impl Signed for float {\n     /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> float { abs(*self) }\n \n     ///\n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &float) -> float {\n         (*self as f64).abs_sub(&(*other as f64)) as float\n     }\n@@ -809,93 +809,93 @@ impl Signed for float {\n     /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n     /// - `NaN` if the number is NaN\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> float {\n         if self.is_NaN() { NaN } else { f64::copysign(1.0, *self as f64) as float }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n \n     /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n impl Bounded for float {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> float { Bounded::min_value::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> float { Bounded::max_value::<f64>() as float }\n }\n \n impl Primitive for float {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { Primitive::bits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { Primitive::bytes::<f64>() }\n }\n \n impl Float for float {\n-    #[inline(always)]\n+    #[inline]\n     fn NaN() -> float { Float::NaN::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn infinity() -> float { Float::infinity::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n \n     /// Returns `true` if the number is NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_NaN(&self) -> bool { (*self as f64).is_NaN() }\n \n     /// Returns `true` if the number is infinite\n-    #[inline(always)]\n+    #[inline]\n     fn is_infinite(&self) -> bool { (*self as f64).is_infinite() }\n \n     /// Returns `true` if the number is neither infinite or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_finite(&self) -> bool { (*self as f64).is_finite() }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline(always)]\n+    #[inline]\n     fn is_normal(&self) -> bool { (*self as f64).is_normal() }\n \n     /// Returns the floating point category of the number. If only one property is going to\n     /// be tested, it is generally faster to use the specific predicate instead.\n-    #[inline(always)]\n+    #[inline]\n     fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn digits() -> uint { Float::digits::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn epsilon() -> float { Float::epsilon::<f64>() as float }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_exp() -> int { Float::min_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_exp() -> int { Float::max_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn min_10_exp() -> int { Float::min_10_exp::<f64>() }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n-    #[inline(always)]\n+    #[inline]\n     fn ldexp(x: float, exp: int) -> float {\n         Float::ldexp(x as f64, exp) as float\n     }\n@@ -906,7 +906,7 @@ impl Float for float {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn frexp(&self) -> (float, int) {\n         match (*self as f64).frexp() {\n             (x, exp) => (x as float, exp)\n@@ -917,7 +917,7 @@ impl Float for float {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn exp_m1(&self) -> float {\n         (*self as f64).exp_m1() as float\n     }\n@@ -926,7 +926,7 @@ impl Float for float {\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn ln_1p(&self) -> float {\n         (*self as f64).ln_1p() as float\n     }\n@@ -936,13 +936,13 @@ impl Float for float {\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mul_add(&self, a: float, b: float) -> float {\n         mul_add(*self as f64, a as f64, b as f64) as float\n     }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline(always)]\n+    #[inline]\n     fn next_after(&self, other: float) -> float {\n         next_after(*self as f64, other as f64) as float\n     }"}, {"sha": "eec20297a533ea1bc6eddee2b1d9b52258c91b86", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,14 +19,14 @@ int_module!(i16, 16)\n \n impl BitCount for i16 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n }"}, {"sha": "769187cc66d6dd45a8ef39f28e44bb05855602da", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,14 +19,14 @@ int_module!(i32, 32)\n \n impl BitCount for i32 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n }"}, {"sha": "ae0e59d16610e53c9e8b561f0951f4575e426cc1", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,14 +19,14 @@ int_module!(i64, 64)\n \n impl BitCount for i64 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n }"}, {"sha": "31a1f4241f58e47f54fe829d05747104ea568178", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,14 +19,14 @@ int_module!(i8, 8)\n \n impl BitCount for i8 {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n }"}, {"sha": "d3c2733b47d5c2a60c209e3f6efaa586c9d8857e", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -22,30 +22,30 @@ int_module!(int, super::bits)\n #[cfg(target_word_size = \"32\")]\n impl BitCount for int {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> int { (*self as i32).population_count() as int }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl BitCount for int {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> int { (*self as i64).population_count() as int }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n }\n "}, {"sha": "74ec46ccfcd47ca708475524123ab55dec29e771", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -27,17 +27,17 @@ pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n /// Calculates the sum of two numbers\n-#[inline(always)]\n+#[inline]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n /// Subtracts the second number from the first\n-#[inline(always)]\n+#[inline]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n /// Multiplies two numbers together\n-#[inline(always)]\n+#[inline]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n /// Divides the first argument by the second argument (using integer division)\n /// Divides the first argument by the second argument (using integer division)\n-#[inline(always)]\n+#[inline]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n \n ///\n@@ -60,26 +60,26 @@ pub fn div(x: $T, y: $T) -> $T { x / y }\n /// ~~~\n ///\n ///\n-#[inline(always)]\n+#[inline]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n /// Returns true iff `x < y`\n-#[inline(always)]\n+#[inline]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n /// Returns true iff `x <= y`\n-#[inline(always)]\n+#[inline]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n /// Returns true iff `x == y`\n-#[inline(always)]\n+#[inline]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n /// Returns true iff `x != y`\n-#[inline(always)]\n+#[inline]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n /// Returns true iff `x >= y`\n-#[inline(always)]\n+#[inline]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n /// Returns true iff `x > y`\n-#[inline(always)]\n+#[inline]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n ///\n@@ -99,7 +99,7 @@ pub fn gt(x: $T, y: $T) -> bool { x > y }\n /// assert!(sum == 10);\n /// ~~~\n ///\n-#[inline(always)]\n+#[inline]\n pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n@@ -122,96 +122,96 @@ pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n     range_step(lo, hi, 1 as $T, it)\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T, it)\n }\n \n /// Computes the bitwise complement\n-#[inline(always)]\n+#[inline]\n pub fn compl(i: $T) -> $T {\n     -1 as $T ^ i\n }\n \n /// Computes the absolute value\n-#[inline(always)]\n+#[inline]\n pub fn abs(i: $T) -> $T { i.abs() }\n \n impl Num for $T {}\n \n #[cfg(not(test))]\n impl Ord for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &$T) -> bool { return (*self) <= (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &$T) -> bool { return (*self) >= (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &$T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(not(test))]\n impl Eq for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n impl Orderable for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n         if *self > *mx { *mx } else\n         if *self < *mn { *mn } else { *self }\n     }\n }\n \n impl Zero for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> $T { 0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n impl One for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n impl Add<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n@@ -235,7 +235,7 @@ impl Div<$T,$T> for $T {\n     /// assert!(-1 / -2 ==  0);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n@@ -262,19 +262,19 @@ impl Rem<$T,$T> for $T {\n     /// assert!(-1 % -2 == -1);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> $T { -*self }\n }\n \n impl Signed for $T {\n     /// Computes the absolute value\n-    #[inline(always)]\n+    #[inline]\n     fn abs(&self) -> $T {\n         if self.is_negative() { -*self } else { *self }\n     }\n@@ -283,7 +283,7 @@ impl Signed for $T {\n     /// The positive difference of two numbers. Returns `0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn abs_sub(&self, other: &$T) -> $T {\n         if *self <= *other { 0 } else { *self - *other }\n     }\n@@ -295,7 +295,7 @@ impl Signed for $T {\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn signum(&self) -> $T {\n         match *self {\n             n if n > 0 =>  1,\n@@ -305,11 +305,11 @@ impl Signed for $T {\n     }\n \n     /// Returns true if the number is positive\n-    #[inline(always)]\n+    #[inline]\n     fn is_positive(&self) -> bool { *self > 0 }\n \n     /// Returns true if the number is negative\n-    #[inline(always)]\n+    #[inline]\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n@@ -331,7 +331,7 @@ impl Integer for $T {\n     /// assert!((-1).div_floor(-2) ==  0);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn div_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -363,7 +363,7 @@ impl Integer for $T {\n     /// assert!((-1).mod_floor(-2) == -1);\n     /// ~~~\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn mod_floor(&self, other: &$T) -> $T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -375,7 +375,7 @@ impl Integer for $T {\n     }\n \n     /// Calculates `div_floor` and `mod_floor` simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n@@ -387,7 +387,7 @@ impl Integer for $T {\n     }\n \n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n@@ -397,7 +397,7 @@ impl Integer for $T {\n     ///\n     /// The result is always positive\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut (m, n) = (*self, *other);\n@@ -412,112 +412,112 @@ impl Integer for $T {\n     ///\n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     ///\n-    #[inline(always)]\n+    #[inline]\n     fn lcm(&self, other: &$T) -> $T {\n         ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+    #[inline]\n     fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl Bitwise for $T {}\n \n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n impl BitAnd<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n impl BitXor<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n impl Shl<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n impl Shr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n impl Not<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn not(&self) -> $T { !*self }\n }\n \n impl Bounded for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> $T { min_value }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> $T { max_value }\n }\n \n impl Int for $T {}\n \n impl Primitive for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { bits }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { bits / 8 }\n }\n \n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, true, false, false,\n                          strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, true, false, false,\n                                strconv::ExpNone, false, false)\n }\n \n impl FromStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n@@ -526,38 +526,38 @@ impl FromStrRadix for $T {\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                                       strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }"}, {"sha": "30a18a0587bc025781b86a519f5f51b591e25f05", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -307,7 +307,7 @@ pub trait Float: Real\n /// assert_eq!(twenty, 20f32);\n /// ~~~\n ///\n-#[inline(always)]\n+#[inline]\n pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n@@ -338,28 +338,28 @@ pub trait NumCast {\n macro_rules! impl_num_cast(\n     ($T:ty, $conv:ident) => (\n         impl NumCast for $T {\n-            #[inline(always)]\n+            #[inline]\n             fn from<N:NumCast>(n: N) -> $T {\n                 // `$conv` could be generated using `concat_idents!`, but that\n                 // macro seems to be broken at the moment\n                 n.$conv()\n             }\n \n-            #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-            #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-            #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-            #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-            #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-            #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-            #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-            #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-            #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-            #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-            #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-            #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-            #[inline(always)] fn to_float(&self) -> float { *self as float }\n+            #[inline] fn to_u8(&self)    -> u8    { *self as u8    }\n+            #[inline] fn to_u16(&self)   -> u16   { *self as u16   }\n+            #[inline] fn to_u32(&self)   -> u32   { *self as u32   }\n+            #[inline] fn to_u64(&self)   -> u64   { *self as u64   }\n+            #[inline] fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+            #[inline] fn to_i8(&self)    -> i8    { *self as i8    }\n+            #[inline] fn to_i16(&self)   -> i16   { *self as i16   }\n+            #[inline] fn to_i32(&self)   -> i32   { *self as i32   }\n+            #[inline] fn to_i64(&self)   -> i64   { *self as i64   }\n+            #[inline] fn to_int(&self)   -> int   { *self as int   }\n+\n+            #[inline] fn to_f32(&self)   -> f32   { *self as f32   }\n+            #[inline] fn to_f64(&self)   -> f64   { *self as f64   }\n+            #[inline] fn to_float(&self) -> float { *self as float }\n         }\n     )\n )\n@@ -410,14 +410,29 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(radix: uint, pow\n     let mut multiplier = cast(radix);\n     while (my_pow > 0u) {\n         if my_pow % 2u == 1u {\n-            total *= multiplier;\n+            total = total * multiplier;\n         }\n-        my_pow     /= 2u;\n-        multiplier *= multiplier;\n+        my_pow     = my_pow / 2u;\n+        multiplier = multiplier * multiplier;\n     }\n     total\n }\n \n+impl<T: Zero> Zero for @mut T {\n+    fn zero() -> @mut T { @mut Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n+impl<T: Zero> Zero for @T {\n+    fn zero() -> @T { @Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n+impl<T: Zero> Zero for ~T {\n+    fn zero() -> ~T { ~Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {"}, {"sha": "a062838aacf049889e6ee56535a7b746cfa9d68d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -42,28 +42,28 @@ pub enum SignFormat {\n     SignAll\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_NaN<T:Eq>(num: &T) -> bool {\n     *num != *num\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n     match NumStrConv::neg_inf() {\n         None    => false,\n         Some(n) => *num == n\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -83,23 +83,23 @@ pub trait NumStrConv {\n \n macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)]\n+        #[inline]\n         fn NaN()      -> Option<$t> { Some( 0.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-        #[inline(always)]\n+        #[inline]\n         fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n \n-        #[inline(always)]\n+        #[inline]\n         fn round_to_zero(&self) -> $t {\n             ( if *self < 0.0 { f64::ceil(*self as f64)  }\n               else           { f64::floor(*self as f64) }\n             ) as $t\n         }\n \n-        #[inline(always)]\n+        #[inline]\n         fn fractional_part(&self) -> $t {\n             *self - self.round_to_zero()\n         }\n@@ -108,13 +108,13 @@ macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n \n macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n     impl NumStrConv for $t {\n-        #[inline(always)] fn NaN()      -> Option<$t> { None }\n-        #[inline(always)] fn inf()      -> Option<$t> { None }\n-        #[inline(always)] fn neg_inf()  -> Option<$t> { None }\n-        #[inline(always)] fn neg_zero() -> Option<$t> { None }\n+        #[inline] fn NaN()      -> Option<$t> { None }\n+        #[inline] fn inf()      -> Option<$t> { None }\n+        #[inline] fn neg_inf()  -> Option<$t> { None }\n+        #[inline] fn neg_zero() -> Option<$t> { None }\n \n-        #[inline(always)] fn round_to_zero(&self)   -> $t { *self }\n-        #[inline(always)] fn fractional_part(&self) -> $t {     0 }\n+        #[inline] fn round_to_zero(&self)   -> $t { *self }\n+        #[inline] fn fractional_part(&self) -> $t {     0 }\n     }\n ))\n \n@@ -229,7 +229,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n         };\n \n         // Decrease the deccumulator one digit at a time\n-        deccum /= radix_gen;\n+        deccum = deccum / radix_gen;\n         deccum = deccum.round_to_zero();\n \n         buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n@@ -282,7 +282,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n               )\n         ) {\n             // Shift first fractional digit into the integer part\n-            deccum *= radix_gen;\n+            deccum = deccum * radix_gen;\n \n             // Calculate the absolute value of each digit.\n             // See note in first loop.\n@@ -381,7 +381,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  * Converts a number to its string representation. This is a wrapper for\n  * `to_str_bytes_common()`, for details see there.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n@@ -499,8 +499,8 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n \n     // Initialize accumulator with signed zero for floating point parsing to\n     // work\n-    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n-    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut accum      = if accum_positive { copy _0 } else { -_1 * _0};\n+    let mut last_accum = copy accum; // Necessary to detect overflow\n     let mut i          = start;\n     let mut exp_found  = false;\n \n@@ -511,13 +511,13 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         match char::to_digit(c, radix) {\n             Some(digit) => {\n                 // shift accum one digit left\n-                accum *= radix_gen;\n+                accum = accum * copy radix_gen;\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n-                    accum += cast(digit as int);\n+                    accum = accum + cast(digit as int);\n                 } else {\n-                    accum -= cast(digit as int);\n+                    accum = accum - cast(digit as int);\n                 }\n \n                 // Detect overflow by comparing to last value, except\n@@ -526,7 +526,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                     if accum_positive && accum <= last_accum { return None; }\n                     if !accum_positive && accum >= last_accum { return None; }\n                 }\n-                last_accum = accum;\n+                last_accum = copy accum;\n             }\n             None => match c {\n                 '_' if ignore_underscores => {}\n@@ -548,29 +548,29 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n     // Parse fractional part of number\n     // Skip if already reached start of exponent\n     if !exp_found {\n-        let mut power = _1;\n+        let mut power = copy _1;\n \n         while i < len {\n             let c = buf[i] as char;\n \n             match char::to_digit(c, radix) {\n                 Some(digit) => {\n                     // Decrease power one order of magnitude\n-                    power /= radix_gen;\n+                    power = power / radix_gen;\n \n                     let digit_t: T = cast(digit);\n \n                     // add/subtract current digit depending on sign\n                     if accum_positive {\n-                        accum += digit_t * power;\n+                        accum = accum + digit_t * power;\n                     } else {\n-                        accum -= digit_t * power;\n+                        accum = accum - digit_t * power;\n                     }\n \n                     // Detect overflow by comparing to last value\n                     if accum_positive && accum < last_accum { return None; }\n                     if !accum_positive && accum > last_accum { return None; }\n-                    last_accum = accum;\n+                    last_accum = copy accum;\n                 }\n                 None => match c {\n                     '_' if ignore_underscores => {}\n@@ -596,7 +596,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         }\n     }\n \n-    let mut multiplier = _1;\n+    let mut multiplier = copy _1;\n \n     if exp_found {\n         let c = buf[i] as char;\n@@ -632,7 +632,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n  * Parses a string as a number. This is a wrapper for\n  * `from_str_bytes_common()`, for details see there.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,"}, {"sha": "126150c0f1bfcbb1acc3fff73157cc04a38d9ad9", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -95,7 +95,7 @@ pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n }\n \n impl iter::Times for uint {\n-    #[inline(always)]\n+    #[inline]\n     ///\n     /// A convenience form for basic iteration. Given a uint `x`,\n     /// `for x.times { ... }` executes the given block x times.\n@@ -117,7 +117,7 @@ impl iter::Times for uint {\n }\n \n /// Returns the smallest power of 2 greater than or equal to `n`\n-#[inline(always)]\n+#[inline]\n pub fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;"}, {"sha": "52f620f97ce8674daeb1b3d0152c8333e50146f0", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -28,42 +28,42 @@ pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n /// Calculates the sum of two numbers\n-#[inline(always)]\n+#[inline]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n /// Subtracts the second number from the first\n-#[inline(always)]\n+#[inline]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n /// Multiplies two numbers together\n-#[inline(always)]\n+#[inline]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n /// Divides the first argument by the second argument (using integer division)\n-#[inline(always)]\n+#[inline]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n /// Calculates the integer remainder when x is divided by y (equivalent to the\n /// '%' operator)\n-#[inline(always)]\n+#[inline]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n /// Returns true iff `x < y`\n-#[inline(always)]\n+#[inline]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n /// Returns true iff `x <= y`\n-#[inline(always)]\n+#[inline]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n /// Returns true iff `x == y`\n-#[inline(always)]\n+#[inline]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n /// Returns true iff `x != y`\n-#[inline(always)]\n+#[inline]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n /// Returns true iff `x >= y`\n-#[inline(always)]\n+#[inline]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n /// Returns true iff `x > y`\n-#[inline(always)]\n+#[inline]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n \n-#[inline(always)]\n+#[inline]\n /**\n  * Iterate through a range with a given step value.\n  *\n@@ -99,20 +99,20 @@ pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) ->\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n     range_step(lo, hi, 1 as $T_SIGNED, it)\n }\n \n-#[inline(always)]\n+#[inline]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n     range_step(hi, lo, -1 as $T_SIGNED, it)\n }\n \n /// Computes the bitwise complement\n-#[inline(always)]\n+#[inline]\n pub fn compl(i: $T) -> $T {\n     max_value ^ i\n }\n@@ -121,37 +121,37 @@ impl Num for $T {}\n \n #[cfg(not(test))]\n impl Ord for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &$T) -> bool { (*self) <= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &$T) -> bool { (*self) >= (*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &$T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(not(test))]\n impl Eq for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &$T) -> bool { return (*self) != (*other); }\n }\n \n impl Orderable for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min(&self, other: &$T) -> $T {\n         if *self < *other { *self } else { *other }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max(&self, other: &$T) -> $T {\n         if *self > *other { *self } else { *other }\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    #[inline(always)]\n+    #[inline]\n     fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n         cond!(\n             (*self > *mx) { *mx   }\n@@ -162,79 +162,79 @@ impl Orderable for $T {\n }\n \n impl Zero for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn zero() -> $T { 0 }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_zero(&self) -> bool { *self == 0 }\n }\n \n impl One for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn one() -> $T { 1 }\n }\n \n #[cfg(not(test))]\n impl Add<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn add(&self, other: &$T) -> $T { *self + *other }\n }\n \n #[cfg(not(test))]\n impl Sub<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn sub(&self, other: &$T) -> $T { *self - *other }\n }\n \n #[cfg(not(test))]\n impl Mul<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn mul(&self, other: &$T) -> $T { *self * *other }\n }\n \n #[cfg(not(test))]\n impl Div<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n }\n \n #[cfg(not(test))]\n impl Rem<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n }\n \n #[cfg(not(test))]\n impl Neg<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn neg(&self) -> $T { -*self }\n }\n \n impl Unsigned for $T {}\n \n impl Integer for $T {\n     /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_rem(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Unsigned integer division. Returns the same result as `div` (`/`).\n-    #[inline(always)]\n+    #[inline]\n     fn div_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-    #[inline(always)]\n+    #[inline]\n     fn mod_floor(&self, other: &$T) -> $T { *self / *other }\n \n     /// Calculates `div_floor` and `modulo_floor` simultaneously\n-    #[inline(always)]\n+    #[inline]\n     fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n         (*self / *other, *self % *other)\n     }\n \n     /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-    #[inline(always)]\n+    #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n         let mut (m, n) = (*self, *other);\n@@ -247,67 +247,67 @@ impl Integer for $T {\n     }\n \n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-    #[inline(always)]\n+    #[inline]\n     fn lcm(&self, other: &$T) -> $T {\n         (*self * *other) / self.gcd(other)\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+    #[inline]\n     fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_even(&self) -> bool { self.is_multiple_of(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl Bitwise for $T {}\n \n #[cfg(not(test))]\n impl BitOr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitor(&self, other: &$T) -> $T { *self | *other }\n }\n \n #[cfg(not(test))]\n impl BitAnd<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitand(&self, other: &$T) -> $T { *self & *other }\n }\n \n #[cfg(not(test))]\n impl BitXor<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n }\n \n #[cfg(not(test))]\n impl Shl<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shl(&self, other: &$T) -> $T { *self << *other }\n }\n \n #[cfg(not(test))]\n impl Shr<$T,$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn shr(&self, other: &$T) -> $T { *self >> *other }\n }\n \n #[cfg(not(test))]\n impl Not<$T> for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn not(&self) -> $T { !*self }\n }\n \n impl Bounded for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn min_value() -> $T { min_value }\n \n-    #[inline(always)]\n+    #[inline]\n     fn max_value() -> $T { max_value }\n }\n \n@@ -316,35 +316,35 @@ impl Int for $T {}\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn from_str(s: &str) -> Option<$T> {\n     strconv::from_str_common(s, 10u, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a string as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n     strconv::from_str_common(s, radix, false, false, false,\n                              strconv::ExpNone, false, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n-#[inline(always)]\n+#[inline]\n pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n     strconv::from_str_bytes_common(buf, radix, false, false, false,\n                                    strconv::ExpNone, false, false)\n }\n \n impl FromStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n         from_str(s)\n     }\n }\n \n impl FromStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n         from_str_radix(s, radix)\n     }\n@@ -353,66 +353,66 @@ impl FromStrRadix for $T {\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n-#[inline(always)]\n+#[inline]\n pub fn to_str(num: $T) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, 10u, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n-#[inline(always)]\n+#[inline]\n pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n     let (buf, _) = strconv::to_str_common(&num, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n impl ToStr for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         to_str(*self)\n     }\n }\n \n impl ToStrRadix for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         to_str_radix(*self, radix)\n     }\n }\n \n impl Primitive for $T {\n-    #[inline(always)]\n+    #[inline]\n     fn bits() -> uint { bits }\n \n-    #[inline(always)]\n+    #[inline]\n     fn bytes() -> uint { bits / 8 }\n }\n \n impl BitCount for $T {\n     /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn population_count(&self) -> $T {\n         (*self as $T_SIGNED).population_count() as $T\n     }\n \n     /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn leading_zeros(&self) -> $T {\n         (*self as $T_SIGNED).leading_zeros() as $T\n     }\n \n     /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n-    #[inline(always)]\n+    #[inline]\n     fn trailing_zeros(&self) -> $T {\n         (*self as $T_SIGNED).trailing_zeros() as $T\n     }"}, {"sha": "83bb9eb09088e423443ed168e1d0b244aea667fe", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -16,7 +16,7 @@\n \n #[allow(missing_doc)];\n \n-use cmp::{Eq, Ord};\n+use cmp::{Eq};\n use kinds::Copy;\n use option::{None, Option, Some};\n use vec;\n@@ -54,11 +54,6 @@ pub trait CopyableIter<A:Copy> {\n     fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n-pub trait CopyableOrderedIter<A:Copy + Ord> {\n-    fn min(&self) -> A;\n-    fn max(&self) -> A;\n-}\n-\n // A trait for sequences that can be built by imperatively pushing elements\n // onto them.\n pub trait Buildable<A> {\n@@ -78,7 +73,7 @@ pub trait Buildable<A> {\n      fn build_sized(size: uint, builder: &fn(push: &fn(A))) -> Self;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn _eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     let mut i = 0;\n     for this.each |a| {\n@@ -94,7 +89,7 @@ pub fn eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     _eachi(this, blk)\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     for this.each |a| {\n         if !blk(a) {\n@@ -104,7 +99,7 @@ pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     return true;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     for this.each |a| {\n         if blk(a) {\n@@ -114,18 +109,18 @@ pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n     return false;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n                                             prd: &fn(&A) -> bool)\n                                          -> ~[A] {\n     do vec::build_sized_opt(this.size_hint()) |push| {\n         for this.each |a| {\n-            if prd(a) { push(*a); }\n+            if prd(a) { push(copy *a); }\n         }\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n     do vec::build_sized_opt(this.size_hint()) |push| {\n         for this.each |a| {\n@@ -134,7 +129,7 @@ pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n                                                           op: &fn(&A) -> IB)\n                                                        -> ~[B] {\n@@ -147,7 +142,7 @@ pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n                               -> B {\n     let mut b = b0;\n@@ -157,20 +152,20 @@ pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n     b\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn to_vec<A:Copy,IA:BaseIter<A>>(this: &IA) -> ~[A] {\n     map_to_vec(this, |&x| x)\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn contains<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> bool {\n     for this.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n     do foldl(this, 0) |count, value| {\n         if *value == *x {\n@@ -181,7 +176,7 @@ pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                -> Option<uint> {\n     let mut i = 0;\n@@ -192,45 +187,11 @@ pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n     return None;\n }\n \n-// note: 'rposition' would only make sense to provide with a bidirectional\n-// iter interface, such as would provide \"reach\" in addition to \"each\". As is,\n-// it would have to be implemented with foldr, which is too inefficient.\n-\n-#[inline(always)]\n-pub fn min<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ < *b => {\n-             *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(\"min called on empty iterator\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn max<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n-        match a {\n-          &Some(ref a_) if *a_ > *b => {\n-              *(a)\n-          }\n-          _ => Some(*b)\n-        }\n-    } {\n-        Some(val) => val,\n-        None => fail!(\"max called on empty iterator\")\n-    }\n-}\n-\n-#[inline(always)]\n+#[inline]\n pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                 -> Option<A> {\n     for this.each |i| {\n-        if f(i) { return Some(*i) }\n+        if f(i) { return Some(copy *i) }\n     }\n     return None;\n }\n@@ -247,7 +208,7 @@ pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n  *             as an argument a function that will push an element\n  *             onto the sequence being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(4, builder)\n }\n@@ -265,7 +226,7 @@ pub fn build<A,B: Buildable<A>>(builder: &fn(push: &fn(A))) -> B {\n  *             as an argument a function that will push an element\n  *             onto the sequence being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n                                           builder: &fn(push: &fn(A))) -> B {\n     Buildable::build_sized(size.get_or_default(4), builder)\n@@ -275,7 +236,7 @@ pub fn build_sized_opt<A,B: Buildable<A>>(size: Option<uint>,\n \n /// Applies a function to each element of an iterable and returns the results\n /// in a sequence built via `BU`.  See also `map_to_vec`.\n-#[inline(always)]\n+#[inline]\n pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n     -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n@@ -291,7 +252,7 @@ pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n  * Creates a generic sequence of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n@@ -305,31 +266,31 @@ pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n-        while i < n_elts { push(t); i += 1; }\n+        while i < n_elts { push(copy t); i += 1; }\n     }\n }\n \n /// Appends two generic sequences.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n                                                   -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n-        for lhs.each |x| { push(*x); }\n-        for rhs.each |x| { push(*x); }\n+        for lhs.each |x| { push(copy *x); }\n+        for rhs.each |x| { push(copy *x); }\n     }\n }\n \n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n-#[inline(always)]\n+#[inline]\n pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n-        for v.each |x| { push(*x); }\n+        for v.each |x| { push(copy *x); }\n     }\n }"}, {"sha": "7dc6b7fe4b1676f449e5b6a3670acf00f25fb31f", "filename": "src/libstd/option.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -88,14 +88,14 @@ impl<T:Ord> Ord for Option<T> {\n     }\n }\n \n-impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n-    #[inline(always)]\n+impl<T: Copy+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n+    #[inline]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n-        match (*self, *other) {\n-            (None, None) => None,\n-            (_, None) => *self,\n-            (None, _) => *other,\n-            (Some(ref lhs), Some(ref rhs)) => Some(*lhs + *rhs)\n+        match (&*self, &*other) {\n+            (&None, &None) => None,\n+            (_, &None) => copy *self,\n+            (&None, _) => copy *other,\n+            (&Some(ref lhs), &Some(ref rhs)) => Some(*lhs + *rhs)\n         }\n     }\n }\n@@ -126,12 +126,12 @@ impl<T> Option<T> {\n     }\n \n     /// Returns true if the option contains some value\n-    #[inline(always)]\n+    #[inline]\n     pub fn is_some(&const self) -> bool { !self.is_none() }\n \n     /// Update an optional value by optionally running its content through a\n     /// function that returns an option.\n-    #[inline(always)]\n+    #[inline]\n     pub fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n         match self {\n             Some(t) => f(t),\n@@ -140,7 +140,7 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the leftmost Some() value, or None if both are None.\n-    #[inline(always)]\n+    #[inline]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(opta) => Some(opta),\n@@ -150,7 +150,7 @@ impl<T> Option<T> {\n \n     /// Update an optional value by optionally running its content by reference\n     /// through a function that returns an option.\n-    #[inline(always)]\n+    #[inline]\n     pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>)\n                             -> Option<U> {\n         match *self {\n@@ -160,27 +160,27 @@ impl<T> Option<T> {\n     }\n \n     /// Maps a `some` value from one type to another by reference\n-    #[inline(always)]\n+    #[inline]\n     pub fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         match self { None => None, Some(v) => Some(f(v)) }\n     }\n \n     /// Applies a function to the contained value or returns a default\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n-    #[inline(always)]\n+    #[inline]\n     pub fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n@@ -237,15 +237,15 @@ impl<T> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,\n           None => fail!(\"option::get_mut_ref none\")\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap(self) -> T {\n         /*!\n         Moves a value out of an option type and returns it.\n@@ -277,7 +277,7 @@ impl<T> Option<T> {\n      *\n      * Fails if the value equals `None`.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn swap_unwrap(&mut self) -> T {\n         if self.is_none() { fail!(\"option::swap_unwrap none\") }\n         util::replace(self, None).unwrap()\n@@ -291,7 +291,7 @@ impl<T> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n           Some(val) => val,\n@@ -315,7 +315,7 @@ impl<T:Copy> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n     */\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(self) -> T {\n         match self {\n           Some(x) => return x,\n@@ -324,13 +324,13 @@ impl<T:Copy> Option<T> {\n     }\n \n     /// Returns the contained value or a default\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_or_default(self, def: T) -> T {\n         match self { Some(x) => x, None => def }\n     }\n \n     /// Applies a function zero or more times until the result is none.\n-    #[inline(always)]\n+    #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         let mut opt = self;\n         while opt.is_some() {\n@@ -341,7 +341,7 @@ impl<T:Copy> Option<T> {\n \n impl<T:Copy + Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_or_zero(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -350,6 +350,11 @@ impl<T:Copy + Zero> Option<T> {\n     }\n }\n \n+impl<T> Zero for Option<T> {\n+    fn zero() -> Option<T> { None }\n+    fn is_zero(&self) -> bool { self.is_none() }\n+}\n+\n /// Immutable iterator over an `Option<A>`\n pub struct OptionIterator<'self, A> {\n     priv opt: Option<&'self A>"}, {"sha": "765dd30febcfb75999064c8ffc1d19587c758209", "filename": "src/libstd/os.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -40,6 +40,8 @@ use option::{Some, None};\n use os;\n use prelude::*;\n use ptr;\n+use rt;\n+use rt::TaskContext;\n use str;\n use uint;\n use unstable::finally::Finally;\n@@ -144,7 +146,7 @@ pub mod win32 {\n     }\n \n     pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n-        let mut t = str::to_utf16(s);\n+        let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t += [0u16];\n         vec::as_imm_buf(t, |buf, _len| f(buf))\n@@ -959,12 +961,10 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             fclose(ostream);\n \n             // Give the new file the old file's permissions\n-            unsafe {\n-                if do str::as_c_str(to.to_str()) |to_buf| {\n-                    libc::chmod(to_buf, from_mode as mode_t)\n-                } != 0 {\n-                    return false; // should be a condition...\n-                }\n+            if do str::as_c_str(to.to_str()) |to_buf| {\n+                libc::chmod(to_buf, from_mode as mode_t)\n+            } != 0 {\n+                return false; // should be a condition...\n             }\n             return ok;\n         }\n@@ -1169,10 +1169,17 @@ pub fn real_args() -> ~[~str] {\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n pub fn real_args() -> ~[~str] {\n-    unsafe {\n-        let argc = rustrt::rust_get_argc();\n-        let argv = rustrt::rust_get_argv();\n-        load_argc_and_argv(argc, argv)\n+    if rt::context() == TaskContext {\n+        match rt::args::clone() {\n+            Some(args) => args,\n+            None => fail!(\"process arguments not initialized\")\n+        }\n+    } else {\n+        unsafe {\n+            let argc = rustrt::rust_get_argc();\n+            let argv = rustrt::rust_get_argv();\n+            load_argc_and_argv(argc, argv)\n+        }\n     }\n }\n \n@@ -1685,10 +1692,11 @@ mod tests {\n           assert!((ostream as uint != 0u));\n           let s = ~\"hello\";\n           let mut buf = s.as_bytes_with_null().to_owned();\n+          let len = buf.len();\n           do vec::as_mut_buf(buf) |b, _len| {\n-              assert!((libc::fwrite(b as *c_void, 1u as size_t,\n-                                   (s.len() + 1u) as size_t, ostream)\n-                      == buf.len() as size_t))\n+              assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n+                                      (s.len() + 1u) as size_t, ostream),\n+                         len as size_t)\n           }\n           assert_eq!(libc::fclose(ostream), (0u as c_int));\n           let in_mode = in.get_mode();"}, {"sha": "e7a6e38fdb08874d5474806d66f346a9167e75ca", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,20 +14,20 @@\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for ~T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &~T) -> bool { *(*self) == *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &~T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for ~T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &~T) -> bool { *(*self) < *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &~T) -> bool { *(*self) <= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &~T) -> bool { *(*self) >= *(*other) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }"}, {"sha": "9c51526aa7f66b4240ee0976c05b59b5f9163059", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -515,7 +515,7 @@ impl GenericPath for PosixPath {\n     fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -657,7 +657,7 @@ impl GenericPath for WindowsPath {\n             (None, None) => {\n                 host = None;\n                 device = None;\n-                rest = str::to_owned(s);\n+                rest = s.to_owned();\n             }\n         }\n \n@@ -729,7 +729,7 @@ impl GenericPath for WindowsPath {\n     fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -904,7 +904,7 @@ pub mod windows {\n     use libc;\n     use option::{None, Option, Some};\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_sep(u: char) -> bool {\n         u == '/' || u == '\\\\'\n     }\n@@ -947,7 +947,6 @@ pub mod windows {\n mod tests {\n     use option::{None, Some};\n     use path::{PosixPath, WindowsPath, windows};\n-    use str;\n \n     #[test]\n     fn test_double_slash_collapsing() {\n@@ -984,7 +983,7 @@ mod tests {\n     fn test_posix_paths() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1042,7 +1041,7 @@ mod tests {\n     fn test_normalize() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1105,7 +1104,7 @@ mod tests {\n     fn test_windows_paths() {\n         fn t(wp: &WindowsPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);"}, {"sha": "26dd4af45d6c33326da437fcbfd477ace08635b7", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -85,7 +85,7 @@ bounded and unbounded protocols allows for less code duplication.\n #[allow(missing_doc)];\n \n use container::Container;\n-use cast::{forget, transmute, transmute_copy};\n+use cast::{forget, transmute, transmute_copy, transmute_mut};\n use either::{Either, Left, Right};\n use iterator::IteratorUtil;\n use kinds::Owned;\n@@ -102,10 +102,6 @@ use util::replace;\n \n static SPIN_COUNT: uint = 0;\n \n-macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n-)\n-\n #[deriving(Eq)]\n enum State {\n     Empty,\n@@ -316,9 +312,11 @@ impl<T> Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n             // FIXME(#4330) Need self by value to get mutability.\n-            let this: &mut BufferResource<T> = transmute(self);\n+            let this: &mut BufferResource<T> = transmute_mut(self);\n+\n+            let null_buffer: ~Buffer<T> = transmute(ptr::null::<Buffer<T>>());\n+            let mut b = replace(&mut this.buffer, null_buffer);\n \n-            let mut b = move_it!(this.buffer);\n             //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n             let old_count = intrinsics::atomic_xsub_rel("}, {"sha": "309df27e151d26009f90880119752bef2f26591f", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -47,9 +47,9 @@ pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use old_iter::{BaseIter, ReverseIter, ExtendedIter, EqIter};\n-pub use old_iter::{CopyableIter, CopyableOrderedIter};\n+pub use old_iter::CopyableIter;\n pub use iter::{Times, FromIter};\n-pub use iterator::{Iterator, IteratorUtil};\n+pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n@@ -61,7 +61,7 @@ pub use path::Path;\n pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n-pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n+pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, StrUtil, NullTerminatedStr};\n pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;"}, {"sha": "7f89d454be1106cf0787ad003cd084ae924f670d", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 39, "deletions": 96, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,31 +19,31 @@ use unstable::intrinsics;\n use uint;\n \n /// Calculate the offset from a pointer\n-#[inline(always)]\n+#[inline]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a const pointer\n-#[inline(always)]\n+#[inline]\n pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer\n-#[inline(always)]\n+#[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n /// Return the offset of the first null pointer in `buf`.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn buf_len<T>(buf: **T) -> uint {\n     position(buf, |i| *i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n-#[inline(always)]\n+#[inline]\n pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n     let mut i = 0;\n     loop {\n@@ -53,19 +53,19 @@ pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n }\n \n /// Create an unsafe null pointer\n-#[inline(always)]\n+#[inline]\n pub fn null<T>() -> *T { 0 as *T }\n \n /// Create an unsafe mutable null pointer\n-#[inline(always)]\n+#[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n /// Returns true if the pointer is equal to the null pointer.\n-#[inline(always)]\n+#[inline]\n pub fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n-#[inline(always)]\n+#[inline]\n pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n@@ -74,22 +74,8 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"32\", stage0)]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove32;\n-    let n = count * sys::size_of::<T>();\n-    memmove32(dst as *mut u8, src as *u8, n as u32);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n-#[inline(always)]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n     memmove32(dst, src as *T, count as u32);\n@@ -101,22 +87,8 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may overlap.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"64\", stage0)]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove64;\n-    let n = count * sys::size_of::<T>();\n-    memmove64(dst as *mut u8, src as *u8, n as u64);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n-#[inline(always)]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n     memmove64(dst, src as *T, count as u64);\n@@ -128,22 +100,8 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"32\", stage0)]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove32;\n-    let n = count * sys::size_of::<T>();\n-    memmove32(dst as *mut u8, src as *u8, n as u32);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n-#[inline(always)]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy32;\n     memcpy32(dst, src as *T, count as u32);\n@@ -155,22 +113,8 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Copies `count` elements (not bytes) from `src` to `dst`. The source\n  * and destination may *not* overlap.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"64\", stage0)]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove64;\n-    let n = count * sys::size_of::<T>();\n-    memmove64(dst as *mut u8, src as *u8, n as u64);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n-#[inline(always)]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy64;\n     memcpy64(dst, src as *T, count as u64);\n@@ -180,8 +124,8 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n  * bytes of memory starting at `dst` to `c`.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset32;\n     memset32(dst, c, count as u32);\n@@ -191,8 +135,8 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n  * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n  * bytes of memory starting at `dst` to `c`.\n  */\n-#[inline(always)]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[inline]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset64;\n     memset64(dst, c, count as u64);\n@@ -222,26 +166,26 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n  * Replace the value at a mutable location with a new one, returning the old\n  * value, without deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n     swap_ptr(dest, &mut src);\n     src\n }\n \n /// Transform a region pointer - &T - to an unsafe pointer - *T.\n-#[inline(always)]\n+#[inline]\n pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     thing as *T\n }\n \n /// Transform a const region pointer - &const T - to a const unsafe pointer - *const T.\n-#[inline(always)]\n+#[inline]\n pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     thing as *const T\n }\n \n /// Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T.\n-#[inline(always)]\n+#[inline]\n pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     thing as *mut T\n }\n@@ -297,11 +241,11 @@ pub trait RawPtr<T> {\n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     ///\n@@ -314,26 +258,26 @@ impl<T> RawPtr<T> for *T {\n     /// that this is still an unsafe operation because the returned value could\n     /// be pointing to invalid memory.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_option(&const self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n     }\n \n     /// Calculates the offset from a pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn offset(&self, count: uint) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n impl<T> RawPtr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     ///\n@@ -346,45 +290,45 @@ impl<T> RawPtr<T> for *mut T {\n     /// that this is still an unsafe operation because the returned value could\n     /// be pointing to invalid memory.\n     ///\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn to_option(&const self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n     }\n \n     /// Calculates the offset from a mutable pointer.\n-    #[inline(always)]\n+    #[inline]\n     fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers\n #[cfg(not(test))]\n impl<T> Eq for *const T {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n         (*self as uint) == (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n // Comparison for pointers\n #[cfg(not(test))]\n impl<T> Ord for *const T {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &*const T) -> bool {\n         (*self as uint) < (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &*const T) -> bool {\n         (*self as uint) <= (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &*const T) -> bool {\n         (*self as uint) >= (*other as uint)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &*const T) -> bool {\n         (*self as uint) > (*other as uint)\n     }\n@@ -592,7 +536,6 @@ pub mod ptr_tests {\n     }\n \n     #[test]\n-    #[cfg(not(stage0))]\n     fn test_set_memory() {\n         let mut xs = [0u8, ..20];\n         let ptr = vec::raw::to_mut_ptr(xs);"}, {"sha": "739e3dfedc7f4bfb09af0140df7c9e4d4be018bd", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -451,7 +451,7 @@ pub trait RngUtil {\n /// Extension methods for random number generators\n impl<R: Rng> RngUtil for R {\n     /// Return a random value for a Rand type\n-    #[inline(always)]\n+    #[inline]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n@@ -526,7 +526,7 @@ impl<R: Rng> RngUtil for R {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(values[self.gen_uint_range(0u, values.len())])\n+            Some(copy values[self.gen_uint_range(0u, values.len())])\n         }\n     }\n     /**\n@@ -555,7 +555,7 @@ impl<R: Rng> RngUtil for R {\n         for v.each |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n-                return Some(item.item);\n+                return Some(copy item.item);\n             }\n         }\n         util::unreachable();\n@@ -569,7 +569,7 @@ impl<R: Rng> RngUtil for R {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n-                r.push(item.item);\n+                r.push(copy item.item);\n             }\n         }\n         r\n@@ -762,7 +762,7 @@ impl IsaacRng {\n }\n \n impl Rng for IsaacRng {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> u32 {\n         if self.cnt == 0 {\n             // make some more numbers\n@@ -862,7 +862,7 @@ pub fn task_rng() -> @@mut IsaacRng {\n \n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @@mut R {\n-    #[inline(always)]\n+    #[inline]\n     fn next(&mut self) -> u32 {\n         match *self {\n             @@ref mut r => r.next()"}, {"sha": "6f4f1a34977e9a7d8e155416821078cac4905884", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -26,7 +26,7 @@ use rand::{Rng,Rand};\n mod ziggurat_tables;\n \n // inlining should mean there is no performance penalty for this\n-#[inline(always)]\n+#[inline]\n fn ziggurat<R:Rng>(rng: &mut R,\n                    center_u: bool,\n                    X: ziggurat_tables::ZigTable,\n@@ -77,11 +77,11 @@ pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n     fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n-        #[inline(always)]\n+        #[inline]\n         fn pdf(x: f64) -> f64 {\n             f64::exp((-x*x/2.0) as f64) as f64\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n             // compute a random number in the tail by hand\n \n@@ -131,11 +131,11 @@ pub struct Exp1(f64);\n impl Rand for Exp1 {\n     #[inline]\n     fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n-        #[inline(always)]\n+        #[inline]\n         fn pdf(x: f64) -> f64 {\n             f64::exp(-x)\n         }\n-        #[inline(always)]\n+        #[inline]\n         fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n             ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n         }"}, {"sha": "d276abf0c8b3e33a96a873d29c2c560c89e3425a", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -35,7 +35,7 @@ pub trait MovePtr {\n }\n \n /// Helper function for alignment calculation.\n-#[inline(always)]\n+#[inline]\n pub fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1u) & !(align - 1u)\n }\n@@ -49,26 +49,26 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n }\n \n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn bump(&self, sz: uint) {\n         do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n         };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn align(&self, a: uint) {\n         do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n         };\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn align_to<T>(&self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }"}, {"sha": "ab3f83d34d59013b9a1f65104bb7d564f66b3bbb", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -18,6 +18,7 @@ More runtime type reflection\n \n use cast::transmute;\n use char;\n+use container::Container;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use intrinsic::Opaque;\n@@ -163,7 +164,7 @@ pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n }\n \n impl MovePtr for ReprVisitor {\n-    #[inline(always)]\n+    #[inline]\n     fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n         *self.ptr = adjustment(*self.ptr);\n     }\n@@ -178,20 +179,20 @@ impl MovePtr for ReprVisitor {\n impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(*self.ptr));\n         }\n         true\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(*self.ptr, inner)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor(ptr, self.writer);\n@@ -201,7 +202,7 @@ impl ReprVisitor {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn write<T:Repr>(&self) -> bool {\n         do self.get |v:&T| {\n             v.write_repr(self.writer);\n@@ -502,7 +503,7 @@ impl TyVisitor for ReprVisitor {\n                                 _offset: uint,\n                                 inner: *TyDesc)\n                                 -> bool {\n-        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -520,7 +521,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk[vec::uniq_len(&const *self.var_stk) - 1] {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');"}, {"sha": "6cef5c33de0652d5af55d6b1df5fa7b58a25a3f7", "filename": "src/libstd/result.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -38,7 +38,7 @@ pub enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(ref t) => copy *t,\n@@ -54,7 +54,7 @@ pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n@@ -70,7 +70,7 @@ pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n  *\n  * If the result is not an error\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(ref u) => copy *u,\n@@ -79,7 +79,7 @@ pub fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n }\n \n /// Returns true if the result is `ok`\n-#[inline(always)]\n+#[inline]\n pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n@@ -88,7 +88,7 @@ pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n }\n \n /// Returns true if the result is `err`\n-#[inline(always)]\n+#[inline]\n pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n@@ -99,7 +99,7 @@ pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n@@ -122,7 +122,7 @@ pub fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n@@ -139,7 +139,7 @@ pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: &fn(t: V) -> Result<T, U>)\n@@ -164,7 +164,7 @@ pub fn chain_err<T, U, V>(\n  *         print_buf(buf)\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n@@ -180,7 +180,7 @@ pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n@@ -202,7 +202,7 @@ pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n@@ -219,7 +219,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n@@ -229,53 +229,53 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n impl<T, E> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_ok(&self) -> bool { is_ok(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn is_err(&self) -> bool { is_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap(self) -> T { unwrap(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn unwrap_err(self) -> E { unwrap_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n \n impl<T:Copy,E> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get(&self) -> T { get(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n \n impl<T, E: Copy> Result<T, E> {\n-    #[inline(always)]\n+    #[inline]\n     pub fn get_err(&self) -> E { get_err(self) }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n@@ -298,7 +298,7 @@ impl<T, E: Copy> Result<T, E> {\n  *         assert!(incd == ~[2u, 3u, 4u]);\n  *     }\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -312,7 +312,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     return Ok(vs);\n }\n \n-#[inline(always)]\n+#[inline]\n #[allow(missing_doc)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n     o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n@@ -335,7 +335,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -358,7 +358,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map_zip()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n@@ -376,7 +376,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-#[inline(always)]\n+#[inline]\n pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n@@ -385,7 +385,7 @@ pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-#[inline(always)]\n+#[inline]\n pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match res {\n       Err(u) => u,"}, {"sha": "75ee4f381f6ef6c454f8f351cf670c6f16812570", "filename": "src/libstd/rt/args.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Global storage for command line arguments\n+//!\n+//! The current incarnation of the Rust runtime expects for\n+//! the processes `argc` and `argv` arguments to be stored\n+//! in a globally-accessible location for use by the `os` module.\n+//!\n+//! XXX: Would be nice for this to not exist.\n+//! XXX: This has a lot of C glue for lack of globals.\n+\n+use libc;\n+use option::{Option, Some, None};\n+use str;\n+use uint;\n+use unstable::finally::Finally;\n+use util;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: int, argv: **u8) {\n+    let args = load_argc_and_argv(argc, argv);\n+    put(args);\n+}\n+\n+/// One-time global cleanup.\n+pub fn cleanup() {\n+    rtassert!(take().is_some());\n+}\n+\n+/// Take the global arguments from global storage.\n+pub fn take() -> Option<~[~str]> {\n+    with_lock(|| unsafe {\n+        let ptr = get_global_ptr();\n+        let val = util::replace(&mut *ptr, None);\n+        val.map(|s: &~~[~str]| (**s).clone())\n+    })\n+}\n+\n+/// Give the global arguments to global storage.\n+///\n+/// It is an error if the arguments already exist.\n+pub fn put(args: ~[~str]) {\n+    with_lock(|| unsafe {\n+        let ptr = get_global_ptr();\n+        rtassert!((*ptr).is_none());\n+        (*ptr) = Some(~args.clone());\n+    })\n+}\n+\n+/// Make a clone of the global arguments.\n+pub fn clone() -> Option<~[~str]> {\n+    with_lock(|| unsafe {\n+        let ptr = get_global_ptr();\n+        (*ptr).map(|s: &~~[~str]| (**s).clone())\n+    })\n+}\n+\n+fn with_lock<T>(f: &fn() -> T) -> T {\n+    do (|| {\n+        unsafe {\n+            rust_take_global_args_lock();\n+            f()\n+        }\n+    }).finally {\n+        unsafe {\n+            rust_drop_global_args_lock();\n+        }\n+    }\n+}\n+\n+fn get_global_ptr() -> *mut Option<~~[~str]> {\n+    unsafe { rust_get_global_args_ptr() }\n+}\n+\n+// Copied from `os`.\n+unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n+    let mut args = ~[];\n+    for uint::range(0, argc as uint) |i| {\n+        args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i)));\n+    }\n+    return args;\n+}\n+\n+extern {\n+    fn rust_take_global_args_lock();\n+    fn rust_drop_global_args_lock();\n+    fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use option::{Some, None};\n+    use super::*;\n+    use unstable::finally::Finally;\n+\n+    #[test]\n+    fn smoke_test() {\n+        // Preserve the actual global state.\n+        let saved_value = take();\n+\n+        let expected = ~[~\"happy\", ~\"today?\"];\n+\n+        put(expected.clone());\n+        assert!(clone() == Some(expected.clone()));\n+        assert!(take() == Some(expected.clone()));\n+        assert!(take() == None);\n+\n+        do (|| {\n+        }).finally {\n+            // Restore the actual global state.\n+            match saved_value {\n+                Some(ref args) => put(args.clone()),\n+                None => ()\n+            }\n+        }\n+    }\n+}"}, {"sha": "e057f6e963714f440d025dba9a1890354e2f5451", "filename": "src/libstd/rt/borrowck.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast::transmute;\n+use libc::{c_char, c_void, size_t, STDERR_FILENO};\n+use io;\n+use io::{Writer, WriterUtil};\n+use managed::raw::BoxRepr;\n+use option::{Option, None, Some};\n+use uint;\n+use str;\n+use str::OwnedStr;\n+use sys;\n+use vec::ImmutableVector;\n+\n+#[allow(non_camel_case_types)]\n+type rust_task = c_void;\n+\n+pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n+pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n+static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n+\n+#[deriving(Eq)]\n+struct BorrowRecord {\n+    box: *mut BoxRepr,\n+    file: *c_char,\n+    line: size_t\n+}\n+\n+fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n+    unsafe {\n+        let cur_task: *rust_task = rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let ptr = rust_take_task_borrow_list(cur_task);\n+            if ptr.is_null() {\n+                None\n+            } else {\n+                let v: ~[BorrowRecord] = transmute(ptr);\n+                Some(v)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+    unsafe {\n+        let cur_task: *rust_task = rust_try_get_task();\n+        if cur_task.is_not_null() {\n+            let mut borrow_list: ~[BorrowRecord] = {\n+                let ptr = rust_take_task_borrow_list(cur_task);\n+                if ptr.is_null() { ~[] } else { transmute(ptr) }\n+            };\n+            borrow_list = f(borrow_list);\n+            rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n+        }\n+    }\n+}\n+\n+pub unsafe fn clear_task_borrow_list() {\n+    // pub because it is used by the box annihilator.\n+    let _ = try_take_task_borrow_list();\n+}\n+\n+unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n+    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n+\n+    match try_take_task_borrow_list() {\n+        None => { // not recording borrows\n+            let msg = \"borrowed\";\n+            do str::as_buf(msg) |msg_p, _| {\n+                sys::begin_unwind_(msg_p as *c_char, file, line);\n+            }\n+        }\n+        Some(borrow_list) => { // recording borrows\n+            let mut msg = ~\"borrowed\";\n+            let mut sep = \" at \";\n+            for borrow_list.rev_iter().advance |entry| {\n+                if entry.box == box {\n+                    msg.push_str(sep);\n+                    let filename = str::raw::from_c_str(entry.file);\n+                    msg.push_str(filename);\n+                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n+                    sep = \" and at \";\n+                }\n+            }\n+            do str::as_buf(msg) |msg_p, _| {\n+                sys::begin_unwind_(msg_p as *c_char, file, line)\n+            }\n+        }\n+    }\n+}\n+\n+/// Because this code is so perf. sensitive, use a static constant so that\n+/// debug printouts are compiled out most of the time.\n+static ENABLE_DEBUG: bool = false;\n+\n+#[inline]\n+unsafe fn debug_borrow<T>(tag: &'static str,\n+                          p: *const T,\n+                          old_bits: uint,\n+                          new_bits: uint,\n+                          filename: *c_char,\n+                          line: size_t) {\n+    //! A useful debugging function that prints a pointer + tag + newline\n+    //! without allocating memory.\n+\n+    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n+        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n+    }\n+\n+    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n+                                   p: *const T,\n+                                   old_bits: uint,\n+                                   new_bits: uint,\n+                                   filename: *c_char,\n+                                   line: size_t) {\n+        let dbg = STDERR_FILENO as io::fd_t;\n+        dbg.write_str(tag);\n+        dbg.write_hex(p as uint);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(old_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(new_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_cstr(filename);\n+        dbg.write_str(\":\");\n+        dbg.write_hex(line as uint);\n+        dbg.write_str(\"\\n\");\n+    }\n+}\n+\n+trait DebugPrints {\n+    fn write_hex(&self, val: uint);\n+    unsafe fn write_cstr(&self, str: *c_char);\n+}\n+\n+impl DebugPrints for io::fd_t {\n+    fn write_hex(&self, mut i: uint) {\n+        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n+        static uint_nibbles: uint = ::uint::bytes << 1;\n+        let mut buffer = [0_u8, ..uint_nibbles+1];\n+        let mut c = uint_nibbles;\n+        while c > 0 {\n+            c -= 1;\n+            buffer[c] = letters[i & 0xF] as u8;\n+            i >>= 4;\n+        }\n+        self.write(buffer.slice(0, uint_nibbles));\n+    }\n+\n+    unsafe fn write_cstr(&self, p: *c_char) {\n+        use libc::strlen;\n+        use vec;\n+\n+        let len = strlen(p);\n+        let p: *u8 = transmute(p);\n+        do vec::raw::buf_as_slice(p, len as uint) |s| {\n+            self.write(s);\n+        }\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & MUT_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+#[inline]\n+pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n+\n+    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n+\n+    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+\n+    (*a).header.ref_count = new_ref_count;\n+\n+    old_ref_count\n+}\n+\n+pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n+            borrow_list\n+        }\n+    }\n+}\n+\n+pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n+                              file: *c_char, line: size_t) {\n+    if (old_ref_count & ALL_BITS) == 0 {\n+        // was not borrowed before, so we should find the record at\n+        // the end of the list\n+        let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n+        do swap_task_borrow_list |borrow_list| {\n+            let mut borrow_list = borrow_list;\n+            assert!(!borrow_list.is_empty());\n+            let br = borrow_list.pop();\n+            if br.box != a || br.file != file || br.line != line {\n+                let err = fmt!(\"wrong borrow found, br=%?\", br);\n+                do str::as_buf(err) |msg_p, _| {\n+                    sys::begin_unwind_(msg_p as *c_char, file, line)\n+                }\n+            }\n+            borrow_list\n+        }\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n+                            file: *c_char, line: size_t) {\n+    // Sometimes the box is null, if it is conditionally frozen.\n+    // See e.g. #4904.\n+    if !a.is_null() {\n+        let a: *mut BoxRepr = transmute(a);\n+        let old_ref_count = (*a).header.ref_count;\n+        let new_ref_count =\n+            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n+\n+        debug_borrow(\"return_to_mut:\",\n+                     a, old_ref_count, new_ref_count, file, line);\n+\n+        (*a).header.ref_count = new_ref_count;\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn check_not_borrowed(a: *u8,\n+                                 file: *c_char,\n+                                 line: size_t) {\n+    let a: *mut BoxRepr = transmute(a);\n+    let ref_count = (*a).header.ref_count;\n+    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n+    if (ref_count & FROZEN_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    }\n+}\n+\n+\n+extern {\n+    #[rust_stack]\n+    pub fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n+\n+    #[rust_stack]\n+    pub fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n+\n+    #[rust_stack]\n+    pub fn rust_try_get_task() -> *rust_task;\n+}"}, {"sha": "dd27c03ff516474f8496b95913f537fa5741fa40", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -399,12 +399,6 @@ impl<T: Owned> GenericChan<T> for SharedChan<T> {\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    #[cfg(stage0)] // odd type checking errors\n-    fn try_send(&self, _val: T) -> bool {\n-        fail!()\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn try_send(&self, val: T) -> bool {\n         unsafe {\n             let (next_pone, next_cone) = oneshot();\n@@ -448,12 +442,6 @@ impl<T: Owned> GenericPort<T> for SharedPort<T> {\n         }\n     }\n \n-    #[cfg(stage0)] // odd type checking errors\n-    fn try_recv(&self) -> Option<T> {\n-        fail!()\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn try_recv(&self) -> Option<T> {\n         unsafe {\n             let (next_link_port, next_link_chan) = oneshot();"}, {"sha": "09ba869549fd04f70d4364b8ae0807575422cc2c", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -207,7 +207,7 @@ fn align_down(sp: *mut uint) -> *mut uint {\n }\n \n // XXX: ptr::offset is positive ints only\n-#[inline(always)]\n+#[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T"}, {"sha": "55861f127bb4412864d5f423138b98e6d6b8fc13", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -297,7 +297,8 @@ impl<T: Reader> ReaderUtil for T {\n \n             do (|| {\n                 while total_read < len {\n-                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n+                    let len = buf.len();\n+                    let slice = vec::mut_slice(*buf, start_len + total_read, len);\n                     match self.read(slice) {\n                         Some(nread) => {\n                             total_read += nread;"}, {"sha": "f62c9fb2c660c42b88f9d6cb8cecf16b370df69a", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -10,11 +10,24 @@\n \n //! The local, garbage collected heap\n \n+use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n+use repr::BoxRepr;\n+use rt;\n+use rt::OldTaskContext;\n+use rt::local::Local;\n+use rt::task::Task;\n \n type MemoryRegion = c_void;\n-type BoxedRegion = c_void;\n+\n+struct Env { priv opaque: () }\n+\n+struct BoxedRegion {\n+    env: *Env,\n+    backing_region: *MemoryRegion,\n+    live_allocs: *BoxRepr\n+}\n \n pub type OpaqueBox = c_void;\n pub type TypeDesc = c_void;\n@@ -49,6 +62,12 @@ impl LocalHeap {\n         }\n     }\n \n+    pub fn realloc(&mut self, ptr: *OpaqueBox, size: uint) -> *OpaqueBox {\n+        unsafe {\n+            return rust_boxed_region_realloc(self.boxed_region, ptr, size as size_t);\n+        }\n+    }\n+\n     pub fn free(&mut self, box: *OpaqueBox) {\n         unsafe {\n             return rust_boxed_region_free(self.boxed_region, box);\n@@ -65,6 +84,40 @@ impl Drop for LocalHeap {\n     }\n }\n \n+// A little compatibility function\n+pub unsafe fn local_free(ptr: *libc::c_char) {\n+    match rt::context() {\n+        OldTaskContext => {\n+            rust_upcall_free_noswitch(ptr);\n+\n+            extern {\n+                #[fast_ffi]\n+                unsafe fn rust_upcall_free_noswitch(ptr: *libc::c_char);\n+            }\n+        }\n+        _ => {\n+            do Local::borrow::<Task,()> |task| {\n+                task.heap.free(ptr as *libc::c_void);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn live_allocs() -> *BoxRepr {\n+    let region = match rt::context() {\n+        OldTaskContext => {\n+            unsafe { rust_current_boxed_region() }\n+        }\n+        _ => {\n+            do Local::borrow::<Task, *BoxedRegion> |task| {\n+                task.heap.boxed_region\n+            }\n+        }\n+    };\n+\n+    return unsafe { (*region).live_allocs };\n+}\n+\n extern {\n     fn rust_new_memory_region(synchronized: uintptr_t,\n                                detailed_leaks: uintptr_t,\n@@ -76,5 +129,9 @@ extern {\n     fn rust_boxed_region_malloc(region: *BoxedRegion,\n                                 td: *TypeDesc,\n                                 size: size_t) -> *OpaqueBox;\n+    fn rust_boxed_region_realloc(region: *BoxedRegion,\n+                                 ptr: *OpaqueBox,\n+                                 size: size_t) -> *OpaqueBox;\n     fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n+    fn rust_current_boxed_region() -> *BoxedRegion;\n }"}, {"sha": "84186180aa6500d8dcb4ac6d30b06c4d3b07be95", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use either::*;\n+use libc;\n \n pub trait Logger {\n     fn log(&mut self, msg: Either<~str, &'static str>);\n@@ -20,6 +21,10 @@ impl Logger for StdErrLogger {\n     fn log(&mut self, msg: Either<~str, &'static str>) {\n         use io::{Writer, WriterUtil};\n \n+        if !should_log_console() {\n+            return;\n+        }\n+\n         let s: &str = match msg {\n             Left(ref s) => {\n                 let s: &str = *s;\n@@ -44,7 +49,6 @@ pub fn init(crate_map: *u8) {\n     use str;\n     use ptr;\n     use option::{Some, None};\n-    use libc::c_char;\n \n     let log_spec = os::getenv(\"RUST_LOG\");\n     match log_spec {\n@@ -61,8 +65,16 @@ pub fn init(crate_map: *u8) {\n             }\n         }\n     }\n+}\n \n-    extern {\n-        fn rust_update_log_settings(crate_map: *u8, settings: *c_char);\n-    }\n+pub fn console_on() { unsafe { rust_log_console_on() } }\n+pub fn console_off() { unsafe { rust_log_console_off() } }\n+fn should_log_console() -> bool { unsafe { rust_should_log_console() != 0 } }\n+\n+extern {\n+    fn rust_update_log_settings(crate_map: *u8, settings: *libc::c_char);\n+    fn rust_log_console_on();\n+    fn rust_log_console_off();\n+    fn rust_should_log_console() -> libc::uintptr_t;\n }\n+"}, {"sha": "bbf1cf0d9b797caceb68160f80914f6d2156bef0", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -58,22 +58,23 @@ Several modules in `core` are clients of `rt`:\n #[deny(unused_imports)];\n #[deny(unused_mut)];\n #[deny(unused_variable)];\n+#[deny(unused_unsafe)];\n \n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use from_str::FromStr;\n+use iter::Times;\n use iterator::IteratorUtil;\n-use option::{Some, None};\n-use os;\n+use option::Some;\n use ptr::RawPtr;\n-use uint;\n use rt::sched::{Scheduler, Coroutine, Shutdown};\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n+use unstable::atomics::{AtomicInt, SeqCst};\n+use unstable::sync::UnsafeAtomicRcBox;\n use vec::{OwnedVector, MutableVector};\n \n /// The global (exchange) heap.\n@@ -122,7 +123,7 @@ mod thread;\n pub mod env;\n \n /// The local, managed heap\n-mod local_heap;\n+pub mod local_heap;\n \n /// The Logger trait and implementations\n pub mod logging;\n@@ -148,7 +149,7 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n-/// A concurrent data structure with which parent tasks wait on child tasks.\n+/// For waiting on child tasks.\n pub mod join_latch;\n \n pub mod metrics;\n@@ -157,6 +158,12 @@ pub mod metrics;\n /// Just stuff\n pub mod util;\n \n+// Global command line argument storage\n+pub mod args;\n+\n+// Support for dynamic borrowck\n+pub mod borrowck;\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to\n@@ -171,71 +178,104 @@ pub mod util;\n /// # Return value\n ///\n /// The return value is used as the process return code. 0 on success, 101 on error.\n-pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n+pub fn start(argc: int, argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n \n-    init(crate_map);\n-    run(main);\n+    init(argc, argv, crate_map);\n+    let exit_code = run(main);\n     cleanup();\n \n-    return 0;\n+    return exit_code;\n }\n \n-/// One-time runtime initialization. Currently all this does is set up logging\n-/// based on the RUST_LOG environment variable.\n-pub fn init(crate_map: *u8) {\n-    logging::init(crate_map);\n+/// One-time runtime initialization.\n+///\n+/// Initializes global state, including frobbing\n+/// the crate's logging flags, registering GC\n+/// metadata, and storing the process arguments.\n+pub fn init(argc: int, argv: **u8, crate_map: *u8) {\n+    // XXX: Derefing these pointers is not safe.\n+    // Need to propagate the unsafety to `start`.\n+    unsafe {\n+        args::init(argc, argv);\n+        logging::init(crate_map);\n+        rust_update_gc_metadata(crate_map);\n+    }\n+\n+    extern {\n+        fn rust_update_gc_metadata(crate_map: *u8);\n+    }\n }\n \n+/// One-time runtime cleanup.\n pub fn cleanup() {\n+    args::cleanup();\n     global_heap::cleanup();\n }\n \n-pub fn run(main: ~fn()) {\n-    let nthreads = match os::getenv(\"RUST_THREADS\") {\n-        Some(nstr) => FromStr::from_str(nstr).get(),\n-        None => unsafe {\n-            // Using more threads than cores in test code\n-            // to force the OS to preempt them frequently.\n-            // Assuming that this help stress test concurrent types.\n-            util::num_cpus() * 2\n-        }\n-    };\n+/// Execute the main function in a scheduler.\n+///\n+/// Configures the runtime according to the environment, by default\n+/// using a task scheduler with the same number of threads as cores.\n+/// Returns a process exit code.\n+pub fn run(main: ~fn()) -> int {\n+\n+    static DEFAULT_ERROR_CODE: int = 101;\n \n+    let nthreads = util::default_sched_threads();\n+\n+    // The shared list of sleeping schedulers. Schedulers wake each other\n+    // occassionally to do new work.\n     let sleepers = SleeperList::new();\n+    // The shared work queue. Temporary until work stealing is implemented.\n     let work_queue = WorkQueue::new();\n \n-    let mut handles = ~[];\n+    // The schedulers.\n     let mut scheds = ~[];\n+    // Handles to the schedulers. When the main task ends these will be\n+    // sent the Shutdown message to terminate the schedulers.\n+    let mut handles = ~[];\n \n-    for uint::range(0, nthreads) |_| {\n+    for nthreads.times {\n+        // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n         let handle = sched.make_handle();\n \n-        handles.push(handle);\n         scheds.push(sched);\n+        handles.push(handle);\n     }\n \n-    let main_cell = Cell::new(main);\n+    // Create a shared cell for transmitting the process exit\n+    // code from the main task to this function.\n+    let exit_code = UnsafeAtomicRcBox::new(AtomicInt::new(0));\n+    let exit_code_clone = exit_code.clone();\n+\n+    // When the main task exits, after all the tasks in the main\n+    // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n-    let mut new_task = ~Task::new_root();\n-    let on_exit: ~fn(bool) = |exit_status| {\n+    let on_exit: ~fn(bool) = |exit_success| {\n \n         let mut handles = handles.take();\n-        // Tell schedulers to exit\n         for handles.mut_iter().advance |handle| {\n             handle.send(Shutdown);\n         }\n \n-        rtassert!(exit_status);\n+        unsafe {\n+            let exit_code = if exit_success { 0 } else { DEFAULT_ERROR_CODE };\n+            (*exit_code_clone.get()).store(exit_code, SeqCst);\n+        }\n     };\n+\n+    // Create and enqueue the main task.\n+    let main_cell = Cell::new(main);\n+    let mut new_task = ~Task::new_root();\n     new_task.on_exit = Some(on_exit);\n     let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n                                           new_task, main_cell.take());\n     scheds[0].enqueue_task(main_task);\n \n+    // Run each scheduler in a thread.\n     let mut threads = ~[];\n-\n     while !scheds.is_empty() {\n         let sched = scheds.pop();\n         let sched_cell = Cell::new(sched);\n@@ -248,7 +288,12 @@ pub fn run(main: ~fn()) {\n     }\n \n     // Wait for schedulers\n-    let _threads = threads;\n+    { let _threads = threads; }\n+\n+    // Return the exit code\n+    unsafe {\n+        (*exit_code.get()).load(SeqCst)\n+    }\n }\n \n /// Possible contexts in which Rust code may be executing."}, {"sha": "bbe4aa25e2967d5eb01a31d59cec5b2285e21d63", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -646,12 +646,12 @@ impl Scheduler {\n     }\n }\n \n-// The cases for the below function.                                              \n+// The cases for the below function.\n enum ResumeAction {\n     SendHome,\n     Requeue,\n     ResumeNow,\n-    Homeless                                                                      \n+    Homeless\n }\n \n impl SchedHandle {"}, {"sha": "97c3b6a749bc9d8d6852f3ff922651749517988b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -15,6 +15,7 @@\n \n use borrow;\n use cast::transmute;\n+use cleanup;\n use libc::{c_void, uintptr_t};\n use ptr;\n use prelude::*;\n@@ -118,6 +119,10 @@ impl Task {\n             }\n             _ => ()\n         }\n+\n+        // Destroy remaining boxes\n+        unsafe { cleanup::annihilate(); }\n+\n         self.destroyed = true;\n     }\n }\n@@ -248,6 +253,18 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn comm_shared_chan() {\n+        use comm::*;\n+\n+        do run_in_newsched_task() {\n+            let (port, chan) = stream();\n+            let chan = SharedChan::new(chan);\n+            chan.send(10);\n+            assert!(port.recv() == 10);\n+        }\n+    }\n+\n     #[test]\n     fn linked_failure() {\n         do run_in_newsched_task() {\n@@ -257,4 +274,45 @@ mod test {\n             assert!(res.is_err());\n         }\n     }\n+\n+    #[test]\n+    fn heap_cycles() {\n+        use option::{Option, Some, None};\n+\n+        do run_in_newsched_task {\n+            struct List {\n+                next: Option<@mut List>,\n+            }\n+\n+            let a = @mut List { next: None };\n+            let b = @mut List { next: Some(a) };\n+\n+            a.next = Some(b);\n+        }\n+    }\n+\n+    // XXX: This is a copy of test_future_result in std::task.\n+    // It can be removed once the scheduler is turned on by default.\n+    #[test]\n+    fn future_result() {\n+        do run_in_newsched_task {\n+            use option::{Some, None};\n+            use task::*;\n+\n+            let mut result = None;\n+            let mut builder = task();\n+            builder.future_result(|r| result = Some(r));\n+            do builder.spawn {}\n+            assert_eq!(result.unwrap().recv(), Success);\n+\n+            result = None;\n+            let mut builder = task();\n+            builder.future_result(|r| result = Some(r));\n+            builder.unlinked();\n+            do builder.spawn {\n+                fail!();\n+            }\n+            assert_eq!(result.unwrap().recv(), Failure);\n+        }\n+    }\n }"}, {"sha": "b0e4968401474750e2c449e22c3877d918e51185", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -74,7 +74,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_TEST_THREADS\") {\n             Some(nstr) => FromStr::from_str(nstr).get(),\n-            None => unsafe {\n+            None => {\n                 // Using more threads than cores in test code\n                 // to force the OS to preempt them frequently.\n                 // Assuming that this help stress test concurrent types."}, {"sha": "5219ae1d5406d8e4c706f1e1a2640a9ba92b47dd", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -9,8 +9,11 @@\n // except according to those terms.\n \n use container::Container;\n+use from_str::FromStr;\n use iterator::IteratorUtil;\n use libc;\n+use option::{Some, None};\n+use os;\n use str::StrSlice;\n \n /// Get the number of cores available\n@@ -24,6 +27,15 @@ pub fn num_cpus() -> uint {\n     }\n }\n \n+/// Get's the number of scheduler threads requested by the environment\n+/// either `RUST_THREADS` or `num_cpus`.\n+pub fn default_sched_threads() -> uint {\n+    match os::getenv(\"RUST_THREADS\") {\n+        Some(nstr) => FromStr::from_str(nstr).get(),\n+        None => num_cpus()\n+    }\n+}\n+\n pub fn dumb_println(s: &str) {\n     use io::WriterUtil;\n     let dbg = ::libc::STDERR_FILENO as ::io::fd_t;"}, {"sha": "14465eb7dfd3afade41774d752c0c5e18ee99955", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -143,7 +143,7 @@ mod test {\n             let count_ptr: *mut int = &mut count;\n             let mut loop_ = Loop::new();\n             let mut timer = TimerWatcher::new(&mut loop_);\n-            do timer.start(10, 20) |timer, status| {\n+            do timer.start(1, 2) |timer, status| {\n                 assert!(status.is_none());\n                 unsafe {\n                     *count_ptr += 1;\n@@ -160,14 +160,14 @@ mod test {\n                         let mut timer2 = TimerWatcher::new(&mut loop_);\n                         do timer2.start(10, 0) |timer2, _| {\n \n-                            unsafe { *count_ptr += 1; }\n+                            *count_ptr += 1;\n \n                             timer2.close(||());\n \n                             // Restart the original timer\n                             let mut timer = timer;\n-                            do timer.start(10, 0) |timer, _| {\n-                                unsafe { *count_ptr += 1; }\n+                            do timer.start(1, 0) |timer, _| {\n+                                *count_ptr += 1;\n                                 timer.close(||());\n                             }\n                         }"}, {"sha": "060de3f4d5d5e34302d83b63ca296e8959fbe920", "filename": "src/libstd/run.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -915,7 +915,7 @@ priv fn waitpid(pid: pid_t) -> int {\n #[cfg(test)]\n mod tests {\n     use io;\n-    use libc::{c_int};\n+    use libc::{c_int, uintptr_t};\n     use option::{Option, None, Some};\n     use os;\n     use path::Path;\n@@ -958,7 +958,10 @@ mod tests {\n \n         assert_eq!(status, 0);\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        assert_eq!(error, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n     }\n \n     #[test]\n@@ -1043,7 +1046,10 @@ mod tests {\n \n         assert_eq!(status, 0);\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        assert_eq!(error, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n     }\n \n     #[test]\n@@ -1057,14 +1063,20 @@ mod tests {\n \n         assert_eq!(status, 0);\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        assert_eq!(error, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n \n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n         assert_eq!(status, 0);\n         assert_eq!(output, ~[]);\n-        assert_eq!(error, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n     }\n \n     #[test]\n@@ -1148,6 +1160,7 @@ mod tests {\n \n     #[test]\n     fn test_inherit_env() {\n+        if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n         let output = str::from_bytes(prog.finish_with_output().output);\n@@ -1169,4 +1182,12 @@ mod tests {\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n     }\n+\n+    fn running_on_valgrind() -> bool {\n+        unsafe { rust_running_on_valgrind() != 0 }\n+    }\n+\n+    extern {\n+        fn rust_running_on_valgrind() -> uintptr_t;\n+    }\n }"}, {"sha": "04f5247782b0ed1a87130029b1f5eb269af8cf23", "filename": "src/libstd/str.rs", "status": "modified", "additions": 341, "deletions": 341, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -23,11 +23,11 @@ use cast;\n use char;\n use char::Char;\n use clone::Clone;\n-use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator};\n+use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIterator};\n use libc;\n+use num::Zero;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n use ptr;\n@@ -37,8 +37,6 @@ use uint;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, Equiv, TotalEq};\n-\n /*\n Section: Conditions\n */\n@@ -108,21 +106,21 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n }\n \n /// Copy a slice into a new unique str\n-#[inline(always)]\n+#[inline]\n pub fn to_owned(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_owned(s, 0, s.len()) }\n }\n \n impl ToStr for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n impl<'self> ToStr for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n impl ToStr for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { to_owned(*self) }\n }\n \n@@ -243,26 +241,26 @@ pub trait CharEq {\n     fn only_ascii(&self) -> bool;\n }\n impl CharEq for char {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { *self == c }\n \n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n impl<'self> CharEq for &'self fn(char) -> bool {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n impl CharEq for extern \"Rust\" fn(char) -> bool {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n \n impl<'self, C: CharEq> CharEq for &'self [C] {\n-    #[inline(always)]\n+    #[inline]\n     fn matches(&self, c: char) -> bool {\n         self.iter().any_(|m| m.matches(c))\n     }\n@@ -291,6 +289,10 @@ pub type WordIterator<'self> =\n     FilterIterator<'self, &'self str,\n              StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n \n+/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n+pub type AnyLineIterator<'self> =\n+    MapIterator<'self, &'self str, &'self str, StrCharSplitIterator<'self, char>>;\n+\n impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n@@ -400,56 +402,6 @@ impl<'self> Iterator<&'self str> for StrStrSplitIterator<'self> {\n     }\n }\n \n-/// Levenshtein Distance between two strings\n-pub fn levdistance(s: &str, t: &str) -> uint {\n-\n-    let slen = s.len();\n-    let tlen = t.len();\n-\n-    if slen == 0 { return tlen; }\n-    if tlen == 0 { return slen; }\n-\n-    let mut dcol = vec::from_fn(tlen + 1, |x| x);\n-\n-    for s.iter().enumerate().advance |(i, sc)| {\n-\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for t.iter().enumerate().advance |(j, tc)| {\n-\n-            let next = dcol[j + 1];\n-\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = ::cmp::min(current, next);\n-                dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-\n-            current = next;\n-        }\n-    }\n-\n-    return dcol[tlen];\n-}\n-\n-/**\n- * Splits a string into substrings separated by LF ('\\n')\n- * and/or CR LF (\"\\r\\n\")\n- */\n-pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    for s.line_iter().advance |s| {\n-        let l = s.len();\n-        if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n-        } else {\n-            if !it( s ) { return false; }\n-        }\n-    }\n-    return true;\n-}\n-\n /** Splits a string into substrings with possibly internal whitespace,\n  *  each of them at most `lim` bytes long. The substrings have leading and trailing\n  *  whitespace removed, and are only cut at whitespace boundaries.\n@@ -576,196 +528,6 @@ pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n-#[inline]\n-fn cmp(a: &str, b: &str) -> Ordering {\n-    let low = uint::min(a.len(), b.len());\n-\n-    for uint::range(0, low) |idx| {\n-        match a[idx].cmp(&b[idx]) {\n-          Greater => return Greater,\n-          Less => return Less,\n-          Equal => ()\n-        }\n-    }\n-\n-    a.len().cmp(&b.len())\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> TotalOrd for &'self str {\n-    #[inline]\n-    fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for ~str {\n-    #[inline]\n-    fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for @str {\n-    #[inline]\n-    fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-/// Bytewise slice less than\n-#[inline]\n-fn lt(a: &str, b: &str) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let end = uint::min(a_len, b_len);\n-\n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (a[i], b[i]);\n-        if c_a < c_b { return true; }\n-        if c_a > c_b { return false; }\n-        i += 1;\n-    }\n-\n-    return a_len < b_len;\n-}\n-\n-/// Bytewise less than or equal\n-#[inline]\n-pub fn le(a: &str, b: &str) -> bool {\n-    !lt(b, a)\n-}\n-\n-/// Bytewise greater than or equal\n-#[inline]\n-fn ge(a: &str, b: &str) -> bool {\n-    !lt(a, b)\n-}\n-\n-/// Bytewise greater than\n-#[inline]\n-fn gt(a: &str, b: &str) -> bool {\n-    !le(a, b)\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Eq for &'self str {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for ~str {\n-    #[inline(always)]\n-    fn eq(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for @str {\n-    #[inline(always)]\n-    fn eq(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> TotalEq for &'self str {\n-    #[inline(always)]\n-    fn equals(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for ~str {\n-    #[inline(always)]\n-    fn equals(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for @str {\n-    #[inline(always)]\n-    fn equals(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for ~str {\n-    #[inline(always)]\n-    fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Ord for &'self str {\n-    #[inline(always)]\n-    fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for @str {\n-    #[inline(always)]\n-    fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for &'self str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for @str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for ~str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n-\n-/*\n-Section: Iterating through strings\n-*/\n-\n-/// Apply a function to each character\n-pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n-    let mut result = ~\"\";\n-    result.reserve(ss.len());\n-    for ss.iter().advance |cc| {\n-        result.push_char(ff(cc));\n-    }\n-    result\n-}\n-\n /*\n Section: Searching\n */\n@@ -820,30 +582,6 @@ pub fn is_utf16(v: &[u16]) -> bool {\n     return true;\n }\n \n-/// Converts to a vector of `u16` encoded as UTF-16\n-pub fn to_utf16(s: &str) -> ~[u16] {\n-    let mut u = ~[];\n-    for s.iter().advance |ch| {\n-        // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let mut ch = ch as u32;\n-\n-        if (ch & 0xFFFF_u32) == ch {\n-            // The BMP falls through (assuming non-surrogate, as it\n-            // should)\n-            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n-            u.push(ch as u16)\n-        } else {\n-            // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n-            ch -= 0x1_0000_u32;\n-            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u.push_all([w1, w2])\n-        }\n-    }\n-    u\n-}\n-\n /// Iterates over the utf-16 characters in the specified slice, yielding each\n /// decoded unicode character to the function provided.\n ///\n@@ -967,7 +705,7 @@ impl<'self> StrUtil for &'self str {\n /**\n  * Deprecated. Use the `as_c_str` method on strings instead.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     s.as_c_str(f)\n }\n@@ -980,7 +718,7 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n  * indexable area for a null byte, as is the case in slices pointing\n  * to full strings, or suffixes of them.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = transmute(&s);\n@@ -989,40 +727,6 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     }\n }\n \n-/**\n- * Returns the byte offset of an inner slice relative to an enclosing outer slice\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let string = \"a\\nb\\nc\";\n- * let mut lines = ~[];\n- * for string.line_iter().advance |line| { lines.push(line) }\n- *\n- * assert!(subslice_offset(string, lines[0]) == 0); // &\"a\"\n- * assert!(subslice_offset(string, lines[1]) == 2); // &\"b\"\n- * assert!(subslice_offset(string, lines[2]) == 4); // &\"c\"\n- * ~~~\n- */\n-#[inline(always)]\n-pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n-    do as_buf(outer) |a, a_len| {\n-        do as_buf(inner) |b, b_len| {\n-            let a_start: uint;\n-            let a_end: uint;\n-            let b_start: uint;\n-            let b_end: uint;\n-            unsafe {\n-                a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n-                b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n-            }\n-            assert!(a_start <= b_start);\n-            assert!(b_end <= a_end);\n-            b_start - a_start\n-        }\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -1207,12 +911,138 @@ pub mod raw {\n #[cfg(not(test))]\n pub mod traits {\n     use ops::Add;\n-    impl<'self> Add<&'self str,~str> for ~str {\n-        #[inline(always)]\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use super::{Str, eq_slice};\n+\n+    impl<'self> Add<&'self str,~str> for &'self str {\n+        #[inline]\n         fn add(&self, rhs: & &'self str) -> ~str {\n-            self.append((*rhs))\n+            let mut ret = self.to_owned();\n+            ret.push_str(*rhs);\n+            ret\n+        }\n+    }\n+\n+    impl<'self> TotalOrd for &'self str {\n+        #[inline]\n+        fn cmp(&self, other: & &'self str) -> Ordering {\n+            for self.bytes_iter().zip(other.bytes_iter()).advance |(s_b, o_b)| {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    impl TotalOrd for ~str {\n+        #[inline]\n+        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl TotalOrd for @str {\n+        #[inline]\n+        fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'self> Eq for &'self str {\n+        #[inline]\n+        fn eq(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for ~str {\n+        #[inline]\n+        fn eq(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline]\n+        fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for @str {\n+        #[inline]\n+        fn eq(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline]\n+        fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl<'self> TotalEq for &'self str {\n+        #[inline]\n+        fn equals(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for ~str {\n+        #[inline]\n+        fn equals(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for @str {\n+        #[inline]\n+        fn equals(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n         }\n     }\n+\n+    impl<'self> Ord for &'self str {\n+        #[inline]\n+        fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n+        #[inline]\n+        fn le(&self, other: & &'self str) -> bool { self.cmp(other) != Greater }\n+        #[inline]\n+        fn ge(&self, other: & &'self str) -> bool { self.cmp(other) != Less }\n+        #[inline]\n+        fn gt(&self, other: & &'self str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for ~str {\n+        #[inline]\n+        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n+        #[inline]\n+        fn le(&self, other: &~str) -> bool { self.cmp(other) != Greater }\n+        #[inline]\n+        fn ge(&self, other: &~str) -> bool { self.cmp(other) != Less }\n+        #[inline]\n+        fn gt(&self, other: &~str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for @str {\n+        #[inline]\n+        fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n+        #[inline]\n+        fn le(&self, other: &@str) -> bool { self.cmp(other) != Greater }\n+        #[inline]\n+        fn ge(&self, other: &@str) -> bool { self.cmp(other) != Less }\n+        #[inline]\n+        fn gt(&self, other: &@str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for &'self str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for @str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for ~str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n }\n \n #[cfg(test)]\n@@ -1225,17 +1055,17 @@ pub trait Str {\n }\n \n impl<'self> Str for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n }\n impl<'self> Str for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n     }\n }\n impl<'self> Str for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n     }\n@@ -1256,6 +1086,7 @@ pub trait StrSlice<'self> {\n     fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n     fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n+    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n@@ -1282,6 +1113,7 @@ pub trait StrSlice<'self> {\n     fn replace(&self, from: &str, to: &str) -> ~str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n+    fn to_utf16(&self) -> ~[u16];\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n@@ -1296,6 +1128,12 @@ pub trait StrSlice<'self> {\n     fn repeat(&self, nn: uint) -> ~str;\n \n     fn slice_shift_char(&self) -> (char, &'self str);\n+\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str;\n+\n+    fn lev_distance(&self, t: &str) -> uint;\n+\n+    fn subslice_offset(&self, inner: &str) -> uint;\n }\n \n /// Extension methods for strings\n@@ -1437,6 +1275,17 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n     }\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or (`\\r\\n`).\n+    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n+        do self.line_iter().transform |line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        }\n+    }\n+\n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace).\n     #[inline]\n@@ -1462,7 +1311,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n     /// Returns the size in bytes not counting the null terminator\n-    #[inline(always)]\n+    #[inline]\n     fn len(&self) -> uint {\n         do as_buf(*self) |_p, n| { n - 1u }\n     }\n@@ -1586,7 +1435,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n      * assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n      * assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n@@ -1605,7 +1454,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n      * assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n      * assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n@@ -1627,7 +1476,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n      * assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n      * assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n@@ -1679,6 +1528,30 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { ::cast::transmute(v) }\n     }\n \n+    /// Converts to a vector of `u16` encoded as UTF-16.\n+    fn to_utf16(&self) -> ~[u16] {\n+        let mut u = ~[];\n+        for self.iter().advance |ch| {\n+            // Arithmetic with u32 literals is easier on the eyes than chars.\n+            let mut ch = ch as u32;\n+\n+            if (ch & 0xFFFF_u32) == ch {\n+                // The BMP falls through (assuming non-surrogate, as it\n+                // should)\n+                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+                u.push(ch as u16)\n+            } else {\n+                // Supplementary planes break into surrogates.\n+                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+                ch -= 0x1_0000_u32;\n+                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+                u.push_all([w1, w2])\n+            }\n+        }\n+        u\n+    }\n+\n     /**\n      * Returns false if the index points into the middle of a multi-byte\n      * character sequence.\n@@ -1921,6 +1794,85 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n \n+    /// Apply a function to each character.\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n+        let mut result = with_capacity(self.len());\n+        for self.iter().advance |cc| {\n+            result.push_char(ff(cc));\n+        }\n+        result\n+    }\n+\n+    /// Levenshtein Distance between two strings.\n+    fn lev_distance(&self, t: &str) -> uint {\n+        let slen = self.len();\n+        let tlen = t.len();\n+\n+        if slen == 0 { return tlen; }\n+        if tlen == 0 { return slen; }\n+\n+        let mut dcol = vec::from_fn(tlen + 1, |x| x);\n+\n+        for self.iter().enumerate().advance |(i, sc)| {\n+\n+            let mut current = i;\n+            dcol[0] = current + 1;\n+\n+            for t.iter().enumerate().advance |(j, tc)| {\n+\n+                let next = dcol[j + 1];\n+\n+                if sc == tc {\n+                    dcol[j + 1] = current;\n+                } else {\n+                    dcol[j + 1] = ::cmp::min(current, next);\n+                    dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                }\n+\n+                current = next;\n+            }\n+        }\n+\n+        return dcol[tlen];\n+    }\n+\n+\n+    /**\n+     * Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+     *\n+     * Fails if `inner` is not a direct slice contained within self.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let string = \"a\\nb\\nc\";\n+     * let mut lines = ~[];\n+     * for string.line_iter().advance |line| { lines.push(line) }\n+     *\n+     * assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+     * assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+     * assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+     * ~~~\n+     */\n+    #[inline]\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        do as_buf(*self) |a, a_len| {\n+            do as_buf(inner) |b, b_len| {\n+                let a_start: uint;\n+                let a_end: uint;\n+                let b_start: uint;\n+                let b_end: uint;\n+                unsafe {\n+                    a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n+                    b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n+                }\n+                assert!(a_start <= b_start);\n+                assert!(b_end <= a_end);\n+                b_start - a_start\n+            }\n+        }\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -1973,7 +1925,7 @@ pub trait OwnedStr {\n \n impl OwnedStr for ~str {\n     /// Appends a string slice to the back of a string, without overallocating\n-    #[inline(always)]\n+    #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n         unsafe {\n             let llen = self.len();\n@@ -2126,7 +2078,7 @@ impl OwnedStr for ~str {\n      * * s - A string\n      * * n - The number of bytes to reserve space for\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n             let v: *mut ~[u8] = cast::transmute(self);\n@@ -2154,7 +2106,7 @@ impl OwnedStr for ~str {\n      * * s - A string\n      * * n - The number of bytes to reserve space for\n      */\n-    #[inline(always)]\n+    #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n@@ -2179,7 +2131,7 @@ impl OwnedStr for ~str {\n }\n \n impl Clone for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn clone(&self) -> ~str {\n         to_owned(*self)\n     }\n@@ -2250,6 +2202,22 @@ impl<'self> Iterator<u8> for StrBytesRevIterator<'self> {\n     }\n }\n \n+// This works because every lifetime is a sub-lifetime of 'static\n+impl<'self> Zero for &'self str {\n+    fn zero() -> &'self str { \"\" }\n+    fn is_zero(&self) -> bool { self.is_empty() }\n+}\n+\n+impl Zero for ~str {\n+    fn zero() -> ~str { ~\"\" }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl Zero for @str {\n+    fn zero() -> @str { @\"\" }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use iterator::IteratorUtil;\n@@ -2280,10 +2248,10 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert!((le(&\"\", &\"\")));\n-        assert!((le(&\"\", &\"foo\")));\n-        assert!((le(&\"foo\", &\"foo\")));\n-        assert!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!(\"\" <= \"\");\n+        assert!(\"\" <= \"foo\");\n+        assert!(\"foo\" <= \"foo\");\n+        assert!(\"foo\" != ~\"bar\");\n     }\n \n     #[test]\n@@ -3003,23 +2971,23 @@ mod tests {\n         let a = \"kernelsprite\";\n         let b = a.slice(7, a.len());\n         let c = a.slice(0, a.len() - 6);\n-        assert_eq!(subslice_offset(a, b), 7);\n-        assert_eq!(subslice_offset(a, c), 0);\n+        assert_eq!(a.subslice_offset(b), 7);\n+        assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n         for string.line_iter().advance |line| { lines.push(line) }\n-        assert_eq!(subslice_offset(string, lines[0]), 0);\n-        assert_eq!(subslice_offset(string, lines[1]), 2);\n-        assert_eq!(subslice_offset(string, lines[2]), 4);\n+        assert_eq!(string.subslice_offset(lines[0]), 0);\n+        assert_eq!(string.subslice_offset(lines[1]), 2);\n+        assert_eq!(string.subslice_offset(lines[2]), 4);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_subslice_offset_2() {\n         let a = \"alchemiter\";\n         let b = \"cruxtruder\";\n-        subslice_offset(a, b);\n+        a.subslice_offset(b);\n     }\n \n     #[test]\n@@ -3069,8 +3037,8 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert_eq!(~\"\", map(\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert_eq!(~\"YMCA\", map(\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]\n@@ -3114,10 +3082,10 @@ mod tests {\n \n         for pairs.each |p| {\n             let (s, u) = copy *p;\n-            assert!(to_utf16(s) == u);\n+            assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n-            assert!(from_utf16(to_utf16(s)) == s);\n-            assert!(to_utf16(from_utf16(u)) == u);\n+            assert!(from_utf16(s.to_utf16()) == s);\n+            assert!(from_utf16(u).to_utf16() == u);\n         }\n     }\n \n@@ -3188,6 +3156,24 @@ mod tests {\n         assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n     }\n \n+    #[test]\n+    fn test_add() {\n+        macro_rules! t (\n+            ($s1:expr, $s2:expr, $e:expr) => {\n+                assert_eq!($s1 + $s2, $e);\n+                assert_eq!($s1.to_owned() + $s2, $e);\n+                assert_eq!($s1.to_managed() + $s2, $e);\n+            }\n+        );\n+\n+        t!(\"foo\",  \"bar\", ~\"foobar\");\n+        t!(\"foo\", @\"bar\", ~\"foobar\");\n+        t!(\"foo\", ~\"bar\", ~\"foobar\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", @\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n     #[test]\n     fn test_iterator() {\n         use iterator::*;\n@@ -3337,4 +3323,18 @@ mod tests {\n         t(\"zzz\", \"zz\", ~[\"\",\"z\"]);\n         t(\"zzzzz\", \"zz\", ~[\"\",\"\",\"z\"]);\n     }\n+\n+    #[test]\n+    fn test_str_zero() {\n+        use num::Zero;\n+        fn t<S: Zero + Str>() {\n+            let s: S = Zero::zero();\n+            assert_eq!(s.as_slice(), \"\");\n+            assert!(s.is_zero());\n+        }\n+\n+        t::<&str>();\n+        t::<@str>();\n+        t::<~str>();\n+    }\n }"}, {"sha": "c71765f911afae34a03e937a8dba16798b841a57", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 109, "deletions": 43, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -17,26 +17,27 @@ use cast;\n use old_iter::BaseIter;\n use iterator::IteratorUtil;\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n+use to_bytes::IterBytes;\n \n-/// Datatype to hold one ascii character. It is 8 bit long.\n+/// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, Eq)]\n pub struct Ascii { priv chr: u8 }\n \n impl Ascii {\n     /// Converts a ascii character into a `u8`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_byte(self) -> u8 {\n         self.chr\n     }\n \n     /// Converts a ascii character into a `char`.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_char(self) -> char {\n         self.chr as char\n     }\n \n     /// Convert to lowercase.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_lower(self) -> Ascii {\n         if self.chr >= 65 && self.chr <= 90 {\n             Ascii{chr: self.chr | 0x20 }\n@@ -46,7 +47,7 @@ impl Ascii {\n     }\n \n     /// Convert to uppercase.\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_upper(self) -> Ascii {\n         if self.chr >= 97 && self.chr <= 122 {\n             Ascii{chr: self.chr & !0x20 }\n@@ -56,14 +57,14 @@ impl Ascii {\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n-    #[inline(always)]\n+    #[inline]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n         self.to_lower().chr == other.to_lower().chr\n     }\n }\n \n impl ToStr for Ascii {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { str::from_bytes(['\\'' as u8, self.chr, '\\'' as u8]) }\n }\n \n@@ -72,18 +73,26 @@ pub trait AsciiCast<T> {\n     /// Convert to an ascii type\n     fn to_ascii(&self) -> T;\n \n+    /// Convert to an ascii type, not doing any range asserts\n+    unsafe fn to_ascii_nocheck(&self) -> T;\n+\n     /// Check if convertible to ascii\n     fn is_ascii(&self) -> bool;\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n-        unsafe{ cast::transmute(*self) }\n+        unsafe {self.to_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n+        cast::transmute(*self)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         for self.each |b| {\n             if !b.is_ascii() { return false; }\n@@ -93,40 +102,55 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n-        let (p,len): (*u8, uint) = unsafe{ cast::transmute(*self) };\n-        unsafe{ cast::transmute((p, len - 1))}\n+        unsafe {self.to_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n+        let (p,len): (*u8, uint) = cast::transmute(*self);\n+        cast::transmute((p, len - 1))\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         self.bytes_iter().all(|b| b.is_ascii())\n     }\n }\n \n impl AsciiCast<Ascii> for u8 {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n+        unsafe {self.to_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n         Ascii{ chr: *self }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         *self & 128 == 0u8\n     }\n }\n \n impl AsciiCast<Ascii> for char {\n-    #[inline(always)]\n+    #[inline]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n+        unsafe {self.to_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n         Ascii{ chr: *self as u8 }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn is_ascii(&self) -> bool {\n         *self - ('\\x7F' & *self) == '\\x00'\n     }\n@@ -135,26 +159,38 @@ impl AsciiCast<Ascii> for char {\n /// Trait for copyless casting to an ascii vector.\n pub trait OwnedAsciiCast {\n     /// Take ownership and cast to an ascii vector without trailing zero element.\n-    fn to_ascii_consume(self) -> ~[Ascii];\n+    fn into_ascii(self) -> ~[Ascii];\n+\n+    /// Take ownership and cast to an ascii vector without trailing zero element.\n+    /// Does not perform validation checks.\n+    unsafe fn into_ascii_nocheck(self) -> ~[Ascii];\n }\n \n impl OwnedAsciiCast for ~[u8] {\n-    #[inline(always)]\n-    fn to_ascii_consume(self) -> ~[Ascii] {\n+    #[inline]\n+    fn into_ascii(self) -> ~[Ascii] {\n         assert!(self.is_ascii());\n-        unsafe {cast::transmute(self)}\n+        unsafe {self.into_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+        cast::transmute(self)\n     }\n }\n \n impl OwnedAsciiCast for ~str {\n-    #[inline(always)]\n-    fn to_ascii_consume(self) -> ~[Ascii] {\n+    #[inline]\n+    fn into_ascii(self) -> ~[Ascii] {\n         assert!(self.is_ascii());\n-        let mut s = self;\n-        unsafe {\n-            str::raw::pop_byte(&mut s);\n-            cast::transmute(s)\n-        }\n+        unsafe {self.into_ascii_nocheck()}\n+    }\n+\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+        let mut r: ~[Ascii] = cast::transmute(self);\n+        r.pop();\n+        r\n     }\n }\n \n@@ -169,39 +205,66 @@ pub trait AsciiStr {\n     /// Convert to vector representing a upper cased ascii string.\n     fn to_upper(&self) -> ~[Ascii];\n \n+    /// Compares two Ascii strings ignoring case\n+    fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n }\n \n impl<'self> AsciiStr for &'self [Ascii] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str_ascii(&self) -> ~str {\n         let mut cpy = self.to_owned();\n         cpy.push(0u8.to_ascii());\n         unsafe {cast::transmute(cpy)}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn to_lower(&self) -> ~[Ascii] {\n         self.map(|a| a.to_lower())\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn to_upper(&self) -> ~[Ascii] {\n         self.map(|a| a.to_upper())\n     }\n+\n+    #[inline]\n+    fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n+        do self.iter().zip(other.iter()).all |(&a, &b)| { a.eq_ignore_case(b) }\n+    }\n }\n \n impl ToStrConsume for ~[Ascii] {\n-    #[inline(always)]\n-    fn to_str_consume(self) -> ~str {\n+    #[inline]\n+    fn into_str(self) -> ~str {\n         let mut cpy = self;\n         cpy.push(0u8.to_ascii());\n         unsafe {cast::transmute(cpy)}\n     }\n }\n \n+impl IterBytes for Ascii {\n+    #[inline]\n+    fn iter_bytes(&self, _lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+        f([self.to_byte()])\n+    }\n+}\n+\n+/// Trait to convert to a owned byte array by consuming self\n+pub trait ToBytesConsume {\n+    /// Converts to a owned byte array by consuming self\n+    fn into_bytes(self) -> ~[u8];\n+}\n+\n+impl ToBytesConsume for ~[Ascii] {\n+    fn into_bytes(self) -> ~[u8] {\n+        unsafe {cast::transmute(self)}\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use to_bytes::ToBytes;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n@@ -245,6 +308,8 @@ mod tests {\n         assert_eq!(\"YMCA\".to_ascii().to_lower().to_str_ascii(), ~\"ymca\");\n         assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().to_str_ascii(), ~\"ABCDEFXYZ:.;\");\n \n+        assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n+\n         assert!(\"\".is_ascii());\n         assert!(\"a\".is_ascii());\n         assert!(!\"\\u2009\".is_ascii());\n@@ -253,21 +318,22 @@ mod tests {\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        // FIXME: #4318 Compiler crashes on moving self\n-        //assert_eq!(~\"( ;\".to_ascii_consume(), v2ascii!(~[40, 32, 59]));\n-        //assert_eq!(~[40u8, 32u8, 59u8].to_ascii_consume(), v2ascii!(~[40, 32, 59]));\n-        //assert_eq!(~\"( ;\".to_ascii_consume_with_null(), v2ascii!(~[40, 32, 59, 0]));\n-        //assert_eq!(~[40u8, 32u8, 59u8].to_ascii_consume_with_null(),\n-        //           v2ascii!(~[40, 32, 59, 0]));\n+        assert_eq!((~\"( ;\").into_ascii(), v2ascii!(~[40, 32, 59]));\n+        assert_eq!((~[40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n     }\n \n     #[test]\n     fn test_ascii_to_str() { assert_eq!(v2ascii!([40, 32, 59]).to_str_ascii(), ~\"( ;\"); }\n \n     #[test]\n-    fn test_ascii_to_str_consume() {\n-        // FIXME: #4318 Compiler crashes on moving self\n-        //assert_eq!(v2ascii!(~[40, 32, 59]).to_str_consume(), ~\"( ;\");\n+    fn test_ascii_into_str() {\n+        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), ~\"( ;\");\n+    }\n+\n+    #[test]\n+    fn test_ascii_to_bytes() {\n+        assert_eq!(v2ascii!(~[40, 32, 59]).to_bytes(false), ~[40u8, 32u8, 59u8]);\n+        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), ~[40u8, 32u8, 59u8]);\n     }\n \n     #[test] #[should_fail]"}, {"sha": "523c5d633cf4400e984b3920cc917ff2307ad359", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -57,25 +57,25 @@ pub mod rustrt {\n  * Useful for calling certain function in the Rust runtime or otherwise\n  * performing dark magick.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { intrinsics::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns a pointer to a type descriptor.\n-#[inline(always)]\n+#[inline]\n pub fn get_type_desc_val<T>(_val: &T) -> *TypeDesc {\n     get_type_desc::<T>()\n }\n \n /// Returns the size of a type\n-#[inline(always)]\n+#[inline]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n /// Returns the size of the type that `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -85,14 +85,14 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n  *\n  * Useful for building structures containing variable-length arrays.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn nonzero_size_of<T>() -> uint {\n     let s = size_of::<T>();\n     if s == 0 { 1 } else { s }\n }\n \n /// Returns the size of the type of the value that `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n     nonzero_size_of::<T>()\n }\n@@ -104,33 +104,33 @@ pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n  * This is the alignment used for struct fields. It may be smaller\n  * than the preferred alignment.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n /// Returns the ABI-required minimum alignment of the type of the value that\n /// `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n \n /// Returns the preferred alignment of a type\n-#[inline(always)]\n+#[inline]\n pub fn pref_align_of<T>() -> uint {\n     unsafe { intrinsics::pref_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of the type of the value that\n /// `_val` points to\n-#[inline(always)]\n+#[inline]\n pub fn pref_align_of_val<T>(_val: &T) -> uint {\n     pref_align_of::<T>()\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n-#[inline(always)]\n+#[inline]\n pub fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::transmute_copy(&t);\n@@ -180,10 +180,13 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+    use cell::Cell;\n     use option::Option;\n+    use either::Left;\n     use rt::{context, OldTaskContext, TaskContext};\n     use rt::task::{Task, Unwinder};\n     use rt::local::Local;\n+    use rt::logging::Logger;\n \n     let context = context();\n     match context {\n@@ -200,19 +203,28 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                 let msg = str::raw::from_c_str(msg);\n                 let file = str::raw::from_c_str(file);\n \n-                let outmsg = fmt!(\"%s at line %i of file %s\", msg, line as int, file);\n+                let outmsg = fmt!(\"task failed: '%s' at line %i of file %s\",\n+                                  msg, line as int, file);\n \n                 // XXX: Logging doesn't work correctly in non-task context because it\n                 // invokes the local heap\n                 if context == TaskContext {\n-                    error!(outmsg);\n+                    // XXX: Logging doesn't work here - the check to call the log\n+                    // function never passes - so calling the log function directly.\n+                    let outmsg = Cell::new(outmsg);\n+                    do Local::borrow::<Task, ()> |task| {\n+                        task.logger.log(Left(outmsg.take()));\n+                    }\n                 } else {\n-                    rtdebug!(\"%s\", outmsg);\n+                    rterrln!(\"%s\", outmsg);\n                 }\n \n                 gc::cleanup_stack_for_failure();\n \n                 let task = Local::unsafe_borrow::<Task>();\n+                if (*task).unwinder.unwinding {\n+                    rtabort!(\"unwinding again\");\n+                }\n                 (*task).unwinder.begin_unwind();\n             }\n         }"}, {"sha": "63eb768d1c9cdc109230b2a33bba7f339992f053", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -79,7 +79,6 @@ use cast;\n use cell::Cell;\n use container::Map;\n use comm::{Chan, GenericChan};\n-use ptr;\n use hashmap::HashSet;\n use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n@@ -99,10 +98,6 @@ use rt::task::Task;\n #[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n-macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n-)\n-\n type TaskSet = HashSet<*rust_task>;\n \n fn new_taskset() -> TaskSet {\n@@ -162,14 +157,14 @@ struct AncestorNode {\n struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n-#[inline(always)]\n+#[inline]\n fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n     unsafe {\n         x.with(blk)\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe {\n@@ -583,13 +578,29 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     }\n }\n \n-fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n+fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n-    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n-        ~running_task.new_child()\n+    let mut task = if opts.linked {\n+        do Local::borrow::<Task, ~Task>() |running_task| {\n+            ~running_task.new_child()\n+        }\n+    } else {\n+        // An unlinked task is a new root in the task tree\n+        ~Task::new_root()\n     };\n \n+    if opts.notify_chan.is_some() {\n+        let notify_chan = opts.notify_chan.swap_unwrap();\n+        let notify_chan = Cell::new(notify_chan);\n+        let on_exit: ~fn(bool) = |success| {\n+            notify_chan.take().send(\n+                if success { Success } else { Failure }\n+            )\n+        };\n+        task.on_exit = Some(on_exit);\n+    }\n+\n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      task, f);\n@@ -644,23 +655,16 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: ~fn())\n                        -> ~fn() {\n-        let child_data = Cell::new((child_arc, ancestors));\n+        let child_data = Cell::new((notify_chan, child_arc, ancestors));\n         let result: ~fn() = || {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut (child_arc, ancestors) = child_data.take();\n+            let mut (notify_chan, child_arc, ancestors) = child_data.take();\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must\n             // send Something on the notify channel.\n \n-            //let mut notifier = None;//notify_chan.map(|c| AutoNotify(c));\n-            let notifier = match notify_chan {\n-                Some(ref notify_chan_value) => {\n-                    let moved_ncv = move_it!(*notify_chan_value);\n-                    Some(AutoNotify(moved_ncv))\n-                }\n-                _ => None\n-            };\n+            let notifier = notify_chan.map_consume(|c| AutoNotify(c));\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n                 let group = @@mut TCB(child,"}, {"sha": "822aab0a02719f5a66c01b43c36810fc800f39d6", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,6 +14,7 @@ The `ToBytes` and `IterBytes` traits\n \n */\n \n+use cast;\n use io;\n use io::Writer;\n use option::{None, Option, Some};\n@@ -48,7 +49,7 @@ pub trait IterBytes {\n }\n \n impl IterBytes for bool {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f([\n             *self as u8\n@@ -57,7 +58,7 @@ impl IterBytes for bool {\n }\n \n impl IterBytes for u8 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f([\n             *self\n@@ -66,7 +67,7 @@ impl IterBytes for u8 {\n }\n \n impl IterBytes for u16 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -83,7 +84,7 @@ impl IterBytes for u16 {\n }\n \n impl IterBytes for u32 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -104,7 +105,7 @@ impl IterBytes for u32 {\n }\n \n impl IterBytes for u64 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         if lsb0 {\n             f([\n@@ -133,72 +134,101 @@ impl IterBytes for u64 {\n }\n \n impl IterBytes for i8 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i16 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i32 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for i64 {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for char {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n #[cfg(target_word_size = \"32\")]\n impl IterBytes for uint {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl IterBytes for uint {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for int {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n+impl IterBytes for float {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as f64).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl IterBytes for f32 {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        let i: u32 = unsafe {\n+            // 0.0 == -0.0 so they should also have the same hashcode\n+            cast::transmute(if *self == -0.0 { 0.0 } else { *self })\n+        };\n+        i.iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl IterBytes for f64 {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        let i: u64 = unsafe {\n+            // 0.0 == -0.0 so they should also have the same hashcode\n+            cast::transmute(if *self == -0.0 { 0.0 } else { *self })\n+        };\n+        i.iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n \n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n-  #[inline(always)]\n+  #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n@@ -207,7 +237,7 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n }\n \n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n-  #[inline(always)]\n+  #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b, ref c) => {\n@@ -223,28 +253,28 @@ fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n }\n \n impl<A:IterBytes> IterBytes for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<'self> IterBytes for &'self str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         f(self.as_bytes())\n     }\n }\n \n impl IterBytes for ~str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         // this should possibly include the null terminator, but that\n         // breaks .find_equiv on hashmaps.\n@@ -253,7 +283,7 @@ impl IterBytes for ~str {\n }\n \n impl IterBytes for @str {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         // this should possibly include the null terminator, but that\n         // breaks .find_equiv on hashmaps.\n@@ -262,7 +292,7 @@ impl IterBytes for @str {\n }\n \n impl<A:IterBytes> IterBytes for Option<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         match *self {\n           Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n@@ -272,21 +302,21 @@ impl<A:IterBytes> IterBytes for Option<A> {\n }\n \n impl<'self,A:IterBytes> IterBytes for &'self A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for ~A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)\n     }\n@@ -295,7 +325,7 @@ impl<A:IterBytes> IterBytes for ~A {\n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n impl<A> IterBytes for *const A {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }"}, {"sha": "3e782e728fe3c52b3b781534d8203cfbafbc1074", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -31,16 +31,16 @@ pub trait ToStr {\n /// Trait for converting a type to a string, consuming it in the process.\n pub trait ToStrConsume {\n     /// Cosume and convert to a string.\n-    fn to_str_consume(self) -> ~str;\n+    fn into_str(self) -> ~str;\n }\n \n impl ToStr for () {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str { ~\"()\" }\n }\n \n impl<A:ToStr> ToStr for (A,) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         match *self {\n             (ref a,) => {\n@@ -51,7 +51,7 @@ impl<A:ToStr> ToStr for (A,) {\n }\n \n impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n         for self.each |key, value| {\n@@ -71,7 +71,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n }\n \n impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n         for self.each |element| {\n@@ -89,7 +89,7 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n }\n \n impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         // FIXME(#4653): this causes an llvm assertion\n         //let &(ref a, ref b) = self;\n@@ -102,7 +102,7 @@ impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n }\n \n impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         // FIXME(#4653): this causes an llvm assertion\n         //let &(ref a, ref b, ref c) = self;\n@@ -119,7 +119,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n }\n \n impl<'self,A:ToStr> ToStr for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n@@ -137,7 +137,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n }\n \n impl<A:ToStr> ToStr for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n@@ -155,7 +155,7 @@ impl<A:ToStr> ToStr for ~[A] {\n }\n \n impl<A:ToStr> ToStr for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {"}, {"sha": "aaeaa489834f2f0221a1c384a3f9ae0d6108393b", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -34,17 +34,17 @@ pub struct TrieMap<T> {\n \n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n     /// Clear the map, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) {\n         self.root = TrieNode::new();\n         self.length = 0;\n@@ -53,37 +53,37 @@ impl<T> Mutable for TrieMap<T> {\n \n impl<T> Map<uint, T> for TrieMap<T> {\n     /// Return true if the map contains a value for the specified key\n-    #[inline(always)]\n+    #[inline]\n     fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all key-value pairs in order\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each(f)\n     }\n \n     /// Visit all keys in order\n-    #[inline(always)]\n+    #[inline]\n     fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    #[inline(always)]\n+    #[inline]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         self.root.mutate_values(f)\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[inline(hint)]\n+    #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n         let mut idx = 0;\n@@ -104,22 +104,22 @@ impl<T> Map<uint, T> for TrieMap<T> {\n     }\n \n     /// Return a mutable reference to the value corresponding to the key\n-    #[inline(always)]\n+    #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n-    #[inline(always)]\n+    #[inline]\n     fn insert(&mut self, key: uint, value: T) -> bool {\n         self.swap(key, value).is_none()\n     }\n \n     /// Remove a key-value pair from the map. Return true if the key\n     /// was present in the map, otherwise false.\n-    #[inline(always)]\n+    #[inline]\n     fn remove(&mut self, key: &uint) -> bool {\n         self.pop(key).is_some()\n     }\n@@ -147,25 +147,25 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n     /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all keys in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n@@ -178,59 +178,59 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    #[inline(always)]\n+    #[inline]\n     fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    #[inline(always)]\n+    #[inline]\n     fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl Container for TrieSet {\n     /// Return the number of elements in the set\n-    #[inline(always)]\n+    #[inline]\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    #[inline(always)]\n+    #[inline]\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {\n     /// Clear the set, removing all values.\n-    #[inline(always)]\n+    #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl TrieSet {\n     /// Create an empty TrieSet\n-    #[inline(always)]\n+    #[inline]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n     /// Return true if the set contains a value\n-    #[inline(always)]\n+    #[inline]\n     pub fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n \n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     pub fn insert(&mut self, value: uint) -> bool {\n         self.map.insert(value, ())\n     }\n \n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n-    #[inline(always)]\n+    #[inline]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         self.map.remove(value)\n     }\n@@ -242,7 +242,7 @@ struct TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    #[inline(always)]\n+    #[inline]\n     fn new() -> TrieNode<T> {\n         // FIXME: #5244: [Nothing, ..SIZE] should be possible without Copy\n         TrieNode{count: 0,\n@@ -291,7 +291,7 @@ impl<T> TrieNode<T> {\n }\n \n // if this was done via a trait, the key could be generic\n-#[inline(always)]\n+#[inline]\n fn chunk(n: uint, idx: uint) -> uint {\n     let sh = uint::bits - (SHIFT * (idx + 1));\n     (n >> sh) & MASK"}, {"sha": "fefd55c354158a19e3c68e2f2e511aa26005bbf4", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -29,25 +29,25 @@ pub trait CopyableTuple<T, U> {\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n     /// Return the first element of self\n-    #[inline(always)]\n+    #[inline]\n     fn first(&self) -> T {\n         match *self {\n-            (t, _) => t,\n+            (ref t, _) => copy *t,\n         }\n     }\n \n     /// Return the second element of self\n-    #[inline(always)]\n+    #[inline]\n     fn second(&self) -> U {\n         match *self {\n-            (_, u) => u,\n+            (_, ref u) => copy *u,\n         }\n     }\n \n     /// Return the results of swapping the two elements of self\n-    #[inline(always)]\n+    #[inline]\n     fn swap(&self) -> (U, T) {\n-        match *self {\n+        match copy *self {\n             (t, u) => (u, t),\n         }\n     }\n@@ -63,13 +63,13 @@ pub trait ImmutableTuple<T, U> {\n }\n \n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n-    #[inline(always)]\n+    #[inline]\n     fn first_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn second_ref<'a>(&'a self) -> &'a U {\n         match *self {\n             (_, ref u) => u,\n@@ -83,7 +83,7 @@ pub trait ExtendedTupleOps<A,B> {\n }\n \n impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n-    #[inline(always)]\n+    #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -92,7 +92,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -103,7 +103,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n }\n \n impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n-    #[inline(always)]\n+    #[inline]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -112,7 +112,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -135,6 +135,7 @@ macro_rules! tuple_impls {\n         pub mod inner {\n             use clone::Clone;\n             #[cfg(not(test))] use cmp::*;\n+            #[cfg(not(test))] use num::Zero;\n \n             $(\n                 pub trait $cloneable_trait<$($T),+> {\n@@ -143,7 +144,7 @@ macro_rules! tuple_impls {\n \n                 impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T),+) {\n                     $(\n-                        #[inline(always)]\n+                        #[inline]\n                         fn $get_fn(&self) -> $T {\n                             self.$get_ref_fn().clone()\n                         }\n@@ -156,7 +157,7 @@ macro_rules! tuple_impls {\n \n                 impl<$($T),+> $immutable_trait<$($T),+> for ($($T),+) {\n                     $(\n-                        #[inline(always)]\n+                        #[inline]\n                         fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n                             match *self { $get_pattern => $ret }\n                         }\n@@ -171,35 +172,35 @@ macro_rules! tuple_impls {\n \n                 #[cfg(not(test))]\n                 impl<$($T:Eq),+> Eq for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn eq(&self, other: &($($T),+)) -> bool {\n                         $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n                     }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn ne(&self, other: &($($T),+)) -> bool {\n                         !(*self == *other)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n                 impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn equals(&self, other: &($($T),+)) -> bool {\n                         $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                     }\n                 }\n \n                 #[cfg(not(test))]\n                 impl<$($T:Ord),+> Ord for ($($T),+) {\n-                    #[inline(always)]\n+                    #[inline]\n                     fn lt(&self, other: &($($T),+)) -> bool {\n                         lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn ge(&self, other: &($($T),+)) -> bool { !(*self).lt(other) }\n-                    #[inline(always)]\n+                    #[inline]\n                     fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n                 }\n \n@@ -210,6 +211,18 @@ macro_rules! tuple_impls {\n                         lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                 }\n+\n+                #[cfg(not(test))]\n+                impl<$($T:Zero),+> Zero for ($($T),+) {\n+                    #[inline]\n+                    fn zero() -> ($($T),+) {\n+                        ($(Zero::zero::<$T>()),+)\n+                    }\n+                    #[inline]\n+                    fn is_zero(&self) -> bool {\n+                        $(self.$get_ref_fn().is_zero())&&+\n+                    }\n+                }\n             )+\n         }\n     }"}, {"sha": "6e7a7e2b129ce4b7ea85a2190161054d13a7c0d7", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -82,7 +82,7 @@ impl AtomicFlag {\n     /**\n      * Clears the atomic flag\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn clear(&mut self, order: Ordering) {\n         unsafe {atomic_store(&mut self.v, 0, order)}\n     }\n@@ -91,7 +91,7 @@ impl AtomicFlag {\n      * Sets the flag if it was previously unset, returns the previous value of the\n      * flag.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn test_and_set(&mut self, order: Ordering) -> bool {\n         unsafe {atomic_compare_and_swap(&mut self.v, 0, 1, order) > 0}\n     }\n@@ -102,26 +102,26 @@ impl AtomicBool {\n         AtomicBool { v: if v { 1 } else { 0 } }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(&self.v, order) > 0 }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: bool, order: Ordering) {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { 1 } else { 0 };\n \n         unsafe { atomic_swap(&mut self.v, val, order) > 0}\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { 1 } else { 0 };\n         let new = if new { 1 } else { 0 };\n@@ -135,34 +135,34 @@ impl AtomicInt {\n         AtomicInt { v:v }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: int, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_add).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_sub).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n@@ -173,34 +173,34 @@ impl AtomicUint {\n         AtomicUint { v:v }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, val: uint, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_add).\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n     /// Returns the old value (like __sync_fetch_and_sub)..\n-    #[inline(always)]\n+    #[inline]\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n@@ -211,22 +211,22 @@ impl<T> AtomicPtr<T> {\n         AtomicPtr { p:p }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe { atomic_load(&self.p, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(&mut self.p, ptr, order); }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(&mut self.p, ptr, order) }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_compare_and_swap(&mut self.p, old, new, order) }\n     }\n@@ -249,7 +249,7 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n             let val = cast::transmute(val);\n@@ -265,7 +265,7 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub fn take(&mut self, order: Ordering) -> Option<~T> {\n         unsafe {\n             self.swap(cast::transmute(0), order)\n@@ -286,7 +286,7 @@ impl<T> Drop for AtomicOption<T> {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -297,7 +297,7 @@ pub unsafe fn atomic_store<T>(dst: &mut T, val: T, order:Ordering) {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n     let dst = cast::transmute(dst);\n \n@@ -307,7 +307,7 @@ pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n     })\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -320,7 +320,7 @@ pub unsafe fn atomic_swap<T>(dst: &mut T, val: T, order: Ordering) -> T {\n }\n \n /// Returns the old value (like __sync_fetch_and_add).\n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -333,7 +333,7 @@ pub unsafe fn atomic_add<T>(dst: &mut T, val: T, order: Ordering) -> T {\n }\n \n /// Returns the old value (like __sync_fetch_and_sub).\n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let val = cast::transmute(val);\n@@ -345,7 +345,7 @@ pub unsafe fn atomic_sub<T>(dst: &mut T, val: T, order: Ordering) -> T {\n     })\n }\n \n-#[inline(always)]\n+#[inline]\n pub unsafe fn atomic_compare_and_swap<T>(dst:&mut T, old:T, new:T, order: Ordering) -> T {\n     let dst = cast::transmute(dst);\n     let old = cast::transmute(old);"}, {"sha": "64dd5bba6bcf828de6f19e2443ce64e7c9fa3412", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -15,7 +15,6 @@ Dynamic library facilities.\n A simple wrapper over the platforms dynamic library facilities\n \n */\n-use ptr;\n use cast;\n use path;\n use libc;\n@@ -42,19 +41,15 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n-        let open_wrapper = |raw_ptr| {\n-            do dl::check_for_errors_in {\n-                unsafe {\n-                    DynamicLibrary { handle: dl::open(raw_ptr) }\n+        do dl::check_for_errors_in {\n+            unsafe {\n+                DynamicLibrary { handle:\n+                    match filename {\n+                        Some(name) => dl::open_external(name),\n+                        None => dl::open_internal()\n+                    }\n                 }\n             }\n-        };\n-\n-        match filename {\n-            Some(name) => do name.to_str().as_c_str |raw_name| {\n-                open_wrapper(raw_name)\n-            },\n-            None => open_wrapper(ptr::null())\n         }\n     }\n \n@@ -74,6 +69,7 @@ impl DynamicLibrary {\n }\n \n #[test]\n+#[ignore(cfg(windows))]\n priv fn test_loading_cosine () {\n     // The math library does not need to be loaded since it is already\n     // statically linked in\n@@ -106,13 +102,20 @@ priv fn test_loading_cosine () {\n #[cfg(target_os = \"freebsd\")]\n mod dl {\n     use libc;\n+    use path;\n     use ptr;\n     use str;\n     use task;\n     use result::*;\n \n-    pub unsafe fn open(filename: *libc::c_char) -> *libc::c_void {\n-        dlopen(filename, Lazy as libc::c_int)\n+    pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        do filename.to_str().as_c_str |raw_name| {\n+            dlopen(raw_name, Lazy as libc::c_int)\n+        }\n+    }\n+\n+    pub unsafe fn open_internal() -> *libc::c_void {\n+        dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n@@ -159,11 +162,22 @@ mod dl {\n mod dl {\n     use os;\n     use libc;\n+    use path;\n+    use ptr;\n+    use str;\n     use task;\n     use result::*;\n \n-    pub unsafe fn open(filename: *libc::c_char) -> *libc::c_void {\n-        LoadLibrary(filename)\n+    pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        do os::win32::as_utf16_p(filename.to_str()) |raw_name| {\n+            LoadLibraryW(raw_name)\n+        }\n+    }\n+\n+    pub unsafe fn open_internal() -> *libc::c_void {\n+        let mut handle = ptr::null();\n+        GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n+        handle\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n@@ -192,7 +206,9 @@ mod dl {\n     #[link_name = \"kernel32\"]\n     extern \"stdcall\" {\n         fn SetLastError(error: u32);\n-        fn LoadLibrary(name: *libc::c_char) -> *libc::c_void;\n+        fn LoadLibraryW(name: *u16) -> *libc::c_void;\n+        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *u16,\n+                              handle: **libc::c_void) -> *libc::c_void;\n         fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;\n         fn FreeLibrary(handle: *libc::c_void);\n     }"}, {"sha": "d466488ce5e5d2260aa9c17010246a272d35d1d8", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -673,7 +673,7 @@ pub mod rt {\n         }\n         buf.push_str(s);\n     }\n-    #[inline(always)]\n+    #[inline]\n     pub fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }"}, {"sha": "f81252274c49c446537d27d94fa53e5dc9c829e9", "filename": "src/libstd/unstable/global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fglobal.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -105,7 +105,7 @@ unsafe fn global_data_modify_<T:Owned>(\n                 let dtor: ~fn() = match maybe_dtor {\n                     Some(dtor) => dtor,\n                     None => {\n-                        let dtor: ~fn() = || unsafe {\n+                        let dtor: ~fn() = || {\n                             let _destroy_value: ~T = transmute(data);\n                         };\n                         dtor"}, {"sha": "134250077853a304069a777749513073d91681be", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -130,36 +130,23 @@ pub extern \"rust-intrinsic\" {\n \n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);\n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memcpy64<T>(dst: *mut T, src: *T, count: u64);\n \n-    /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n-    #[cfg(stage0)]\n-    pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n-    /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic.\n-    #[cfg(stage0)]\n-    pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n-\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memmove32<T>(dst: *mut T, src: *T, count: u32);\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memmove64<T>(dst: *mut T, src: *T, count: u64);\n \n     /// Equivalent to the `llvm.memset.p0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memset32<T>(dst: *mut T, val: u8, count: u32);\n     /// Equivalent to the `llvm.memset.p0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memset64<T>(dst: *mut T, val: u8, count: u64);\n \n     pub fn sqrtf32(x: f32) -> f32;"}, {"sha": "f750b31a466b9b77c05af797947bc1708406f8ba", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 22, "deletions": 262, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -14,7 +14,6 @@ use iterator::IteratorUtil;\n use uint;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n-use managed::raw::BoxRepr;\n use str;\n use sys;\n use rt::{context, OldTaskContext};\n@@ -23,14 +22,11 @@ use rt::local::Local;\n use option::{Option, Some, None};\n use io;\n use rt::global_heap;\n+use rt::borrowck;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n \n-pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n-pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n-static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n-\n pub mod rustrt {\n     use unstable::lang::rust_task;\n     use libc::{c_void, c_char, uintptr_t};\n@@ -47,15 +43,6 @@ pub mod rustrt {\n                                               size: uintptr_t)\n                                            -> *c_char;\n \n-        #[fast_ffi]\n-        unsafe fn rust_upcall_free_noswitch(ptr: *c_char);\n-\n-        #[rust_stack]\n-        fn rust_take_task_borrow_list(task: *rust_task) -> *c_void;\n-\n-        #[rust_stack]\n-        fn rust_set_task_borrow_list(task: *rust_task, map: *c_void);\n-\n         #[rust_stack]\n         fn rust_try_get_task() -> *rust_task;\n \n@@ -78,161 +65,18 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n     }\n }\n \n-#[deriving(Eq)]\n-struct BorrowRecord {\n-    box: *mut BoxRepr,\n-    file: *c_char,\n-    line: size_t\n-}\n-\n-fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    unsafe {\n-        let cur_task: *rust_task = rustrt::rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                let v: ~[BorrowRecord] = transmute(ptr);\n-                Some(v)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n-    unsafe {\n-        let cur_task: *rust_task = rustrt::rust_try_get_task();\n-        if cur_task.is_not_null() {\n-            let mut borrow_list: ~[BorrowRecord] = {\n-                let ptr = rustrt::rust_take_task_borrow_list(cur_task);\n-                if ptr.is_null() { ~[] } else { transmute(ptr) }\n-            };\n-            borrow_list = f(borrow_list);\n-            rustrt::rust_set_task_borrow_list(cur_task, transmute(borrow_list));\n-        }\n-    }\n-}\n-\n-pub unsafe fn clear_task_borrow_list() {\n-    // pub because it is used by the box annihilator.\n-    let _ = try_take_task_borrow_list();\n-}\n-\n-unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n-    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n-\n-    match try_take_task_borrow_list() {\n-        None => { // not recording borrows\n-            let msg = \"borrowed\";\n-            do str::as_buf(msg) |msg_p, _| {\n-                fail_(msg_p as *c_char, file, line);\n-            }\n-        }\n-        Some(borrow_list) => { // recording borrows\n-            let mut msg = ~\"borrowed\";\n-            let mut sep = \" at \";\n-            for borrow_list.rev_iter().advance |entry| {\n-                if entry.box == box {\n-                    msg.push_str(sep);\n-                    let filename = str::raw::from_c_str(entry.file);\n-                    msg.push_str(filename);\n-                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n-                    sep = \" and at \";\n-                }\n-            }\n-            do str::as_buf(msg) |msg_p, _| {\n-                fail_(msg_p as *c_char, file, line)\n-            }\n-        }\n-    }\n-}\n-\n // FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n #[lang=\"exchange_malloc\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n \n-/// Because this code is so perf. sensitive, use a static constant so that\n-/// debug printouts are compiled out most of the time.\n-static ENABLE_DEBUG: bool = false;\n-\n-#[inline]\n-unsafe fn debug_borrow<T>(tag: &'static str,\n-                          p: *const T,\n-                          old_bits: uint,\n-                          new_bits: uint,\n-                          filename: *c_char,\n-                          line: size_t) {\n-    //! A useful debugging function that prints a pointer + tag + newline\n-    //! without allocating memory.\n-\n-    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n-        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n-    }\n-\n-    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n-                                   p: *const T,\n-                                   old_bits: uint,\n-                                   new_bits: uint,\n-                                   filename: *c_char,\n-                                   line: size_t) {\n-        let dbg = STDERR_FILENO as io::fd_t;\n-        dbg.write_str(tag);\n-        dbg.write_hex(p as uint);\n-        dbg.write_str(\" \");\n-        dbg.write_hex(old_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_hex(new_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_cstr(filename);\n-        dbg.write_str(\":\");\n-        dbg.write_hex(line as uint);\n-        dbg.write_str(\"\\n\");\n-    }\n-}\n-\n-trait DebugPrints {\n-    fn write_hex(&self, val: uint);\n-    unsafe fn write_cstr(&self, str: *c_char);\n-}\n-\n-impl DebugPrints for io::fd_t {\n-    fn write_hex(&self, mut i: uint) {\n-        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n-        static uint_nibbles: uint = ::uint::bytes << 1;\n-        let mut buffer = [0_u8, ..uint_nibbles+1];\n-        let mut c = uint_nibbles;\n-        while c > 0 {\n-            c -= 1;\n-            buffer[c] = letters[i & 0xF] as u8;\n-            i >>= 4;\n-        }\n-        self.write(buffer.slice(0, uint_nibbles));\n-    }\n-\n-    unsafe fn write_cstr(&self, p: *c_char) {\n-        use libc::strlen;\n-        use vec;\n-\n-        let len = strlen(p);\n-        let p: *u8 = transmute(p);\n-        do vec::raw::buf_as_slice(p, len as uint) |s| {\n-            self.write(s);\n-        }\n-    }\n-}\n-\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[lang=\"exchange_free\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn exchange_free(ptr: *c_char) {\n     global_heap::free(transmute(ptr))\n }\n@@ -258,138 +102,63 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n // problem occurs, call exit instead.\n #[lang=\"free\"]\n pub unsafe fn local_free(ptr: *c_char) {\n-    match context() {\n-        OldTaskContext => {\n-            rustrt::rust_upcall_free_noswitch(ptr);\n-        }\n-        _ => {\n-            do Local::borrow::<Task,()> |task| {\n-                task.heap.free(ptr as *c_void);\n-            }\n-        }\n-    }\n+    ::rt::local_heap::local_free(ptr);\n }\n \n #[lang=\"borrow_as_imm\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n-    let new_ref_count = old_ref_count | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & MUT_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).header.ref_count = new_ref_count;\n-\n-    old_ref_count\n+    borrowck::borrow_as_imm(a, file, line)\n }\n \n #[lang=\"borrow_as_mut\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a: *mut BoxRepr = transmute(a);\n-    let old_ref_count = (*a).header.ref_count;\n-    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).header.ref_count = new_ref_count;\n-\n-    old_ref_count\n+    borrowck::borrow_as_mut(a, file, line)\n }\n \n-\n #[lang=\"record_borrow\"]\n pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n                             file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before\n-        let a: *mut BoxRepr = transmute(a);\n-        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n-            borrow_list\n-        }\n-    }\n+    borrowck::record_borrow(a, old_ref_count, file, line)\n }\n \n #[lang=\"unrecord_borrow\"]\n pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n                               file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before, so we should find the record at\n-        // the end of the list\n-        let a: *mut BoxRepr = transmute(a);\n-        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            assert!(!borrow_list.is_empty());\n-            let br = borrow_list.pop();\n-            if br.box != a || br.file != file || br.line != line {\n-                let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do str::as_buf(err) |msg_p, _| {\n-                    fail_(msg_p as *c_char, file, line)\n-                }\n-            }\n-            borrow_list\n-        }\n-    }\n+    borrowck::unrecord_borrow(a, old_ref_count, file, line)\n }\n \n #[lang=\"return_to_mut\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n                             file: *c_char, line: size_t) {\n-    // Sometimes the box is null, if it is conditionally frozen.\n-    // See e.g. #4904.\n-    if !a.is_null() {\n-        let a: *mut BoxRepr = transmute(a);\n-        let old_ref_count = (*a).header.ref_count;\n-        let new_ref_count =\n-            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n-\n-        debug_borrow(\"return_to_mut:\",\n-                     a, old_ref_count, new_ref_count, file, line);\n-\n-        (*a).header.ref_count = new_ref_count;\n-    }\n+    borrowck::return_to_mut(a, orig_ref_count, file, line)\n }\n \n #[lang=\"check_not_borrowed\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn check_not_borrowed(a: *u8,\n                                  file: *c_char,\n                                  line: size_t) {\n-    let a: *mut BoxRepr = transmute(a);\n-    let ref_count = (*a).header.ref_count;\n-    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n-    if (ref_count & FROZEN_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n+    borrowck::check_not_borrowed(a, file, line)\n }\n \n #[lang=\"strdup_uniq\"]\n-#[inline(always)]\n+#[inline]\n pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n     str::raw::from_buf_len(ptr, len)\n }\n \n+#[lang=\"annihilate\"]\n+pub unsafe fn annihilate() {\n+    ::cleanup::annihilate()\n+}\n+\n #[lang=\"start\"]\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n     use rt;\n-    use sys::Closure;\n-    use ptr;\n-    use cast;\n     use os;\n \n     unsafe {\n@@ -399,17 +168,8 @@ pub fn start(main: *u8, argc: int, argv: **c_char,\n                               crate_map as *c_void) as int;\n         } else {\n             return do rt::start(argc, argv as **u8, crate_map) {\n-                unsafe {\n-                    // `main` is an `fn() -> ()` that doesn't take an environment\n-                    // XXX: Could also call this as an `extern \"Rust\" fn` once they work\n-                    let main = Closure {\n-                        code: main as *(),\n-                        env: ptr::null(),\n-                    };\n-                    let mainfn: &fn() = cast::transmute(main);\n-\n-                    mainfn();\n-                }\n+                let main: extern \"Rust\" fn() = transmute(main);\n+                main();\n             };\n         }\n     }"}, {"sha": "0a46ef619afd9d9381a9d11d5b3fda994cfa0f95", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -18,11 +18,6 @@ use task;\n \n pub mod at_exit;\n \n-// Currently only works for *NIXes\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n pub mod dynamic_lib;\n \n pub mod global;"}, {"sha": "162891124f60c041a52c3c79008d7b0bc288ff7e", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -40,7 +40,7 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get(&self) -> *mut T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -50,7 +50,7 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n         return r;\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get_immut(&self) -> *T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -118,7 +118,7 @@ fn LittleLock() -> LittleLock {\n }\n \n impl LittleLock {\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n             rust_lock_little_lock(self.l);\n@@ -169,7 +169,7 @@ impl<T:Owned> Exclusive<T> {\n     // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n     // the exclusive. Supporting that is a work in progress.\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n@@ -183,7 +183,7 @@ impl<T:Owned> Exclusive<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))"}, {"sha": "2a5d44c9ce26ce4181af23e6989e4a34249e4b59", "filename": "src/libstd/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -16,11 +16,11 @@ use prelude::*;\n use unstable::intrinsics;\n \n /// The identity function.\n-#[inline(always)]\n+#[inline]\n pub fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n-#[inline(always)]\n+#[inline]\n pub fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n@@ -30,7 +30,7 @@ pub fn ignore<T>(_x: T) { }\n /// an obvious borrowck hazard. Typically passing in `&mut T` will\n /// cause borrow check errors because it freezes whatever location\n /// that `&mut T` is stored in (either statically or dynamically).\n-#[inline(always)]\n+#[inline]\n pub fn with<T,R>(\n     ptr: @mut T,\n     value: T,\n@@ -46,7 +46,7 @@ pub fn with<T,R>(\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -68,7 +68,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  * Replace the value at a mutable location with a new one, returning the old\n  * value, without deinitialising or copying either one.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src"}, {"sha": "4339153c43ee4b2882a337ebeb99547d68a473ad", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 141, "deletions": 123, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -19,10 +19,11 @@ use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use old_iter::BaseIter;\n use old_iter;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator};\n use iter::FromIter;\n use kinds::Copy;\n use libc;\n+use num::Zero;\n use old_iter::CopyableIter;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n@@ -47,12 +48,8 @@ pub mod rustrt {\n         // to ~[] and reserve_shared_actual applies to @[].\n         #[fast_ffi]\n         unsafe fn vec_reserve_shared(t: *sys::TypeDesc,\n-                                     v: **raw::VecRepr,\n+                                     v: *mut *mut raw::VecRepr,\n                                      n: libc::size_t);\n-        #[fast_ffi]\n-        unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n-                                            v: **raw::VecRepr,\n-                                            n: libc::size_t);\n     }\n }\n \n@@ -78,11 +75,11 @@ pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     use managed;\n     if capacity(v) < n {\n         unsafe {\n-            let ptr: **raw::VecRepr = cast::transmute(v);\n+            let ptr: *mut *mut raw::VecRepr = cast::transmute(v);\n             let td = sys::get_type_desc::<T>();\n             if ((**ptr).box_header.ref_count ==\n                 managed::raw::RC_MANAGED_UNIQUE) {\n-                rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n+                ::at_vec::raw::reserve_raw(td, ptr, n);\n             } else {\n                 rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n             }\n@@ -110,23 +107,14 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n-#[inline(always)]\n+#[inline]\n pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(v);\n         (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n     }\n }\n \n-// A botch to tide us over until core and std are fully demuted.\n-#[allow(missing_doc)]\n-pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n-    unsafe {\n-        let v: &~[T] = transmute(v);\n-        as_const_buf(*v, |_p, len| len)\n-    }\n-}\n-\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -155,8 +143,10 @@ pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> ~[T] {\n  * to the value `t`.\n  */\n pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n-    // hack: manually inline from_fn for 2x plus speedup (sadly very important, from_elem is a\n-    // bottleneck in borrowck!)\n+    // FIXME (#7136): manually inline from_fn for 2x plus speedup (sadly very\n+    // important, from_elem is a bottleneck in borrowck!). Unfortunately it\n+    // still is substantially slower than using the unsafe\n+    // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         do as_mut_buf(v) |p, _len| {\n@@ -173,7 +163,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n \n /// Creates a new unique vector with the same contents as the slice\n pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n-    from_fn(t.len(), |i| t[i])\n+    from_fn(t.len(), |i| copy t[i])\n }\n \n /// Creates a new vector with a capacity of `capacity`\n@@ -195,7 +185,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| vec.push(x));\n@@ -212,7 +202,7 @@ pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n@@ -229,7 +219,7 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn build_sized_opt<A>(size: Option<uint>,\n                           builder: &fn(push: &fn(v: A)))\n                        -> ~[A] {\n@@ -277,7 +267,7 @@ pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     assert!(start <= end);\n     assert!(end <= v.len());\n@@ -290,7 +280,7 @@ pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n                     -> &'r mut [T] {\n     assert!(start <= end);\n@@ -304,7 +294,7 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n }\n \n /// Return a slice that points into another slice.\n-#[inline(always)]\n+#[inline]\n pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n                       -> &'r const [T] {\n     assert!(start <= end);\n@@ -447,9 +437,9 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n \n     for each(v) |elt| {\n         if f(elt) {\n-            lefts.push(*elt);\n+            lefts.push(copy *elt);\n         } else {\n-            rights.push(*elt);\n+            rights.push(copy *elt);\n         }\n     }\n \n@@ -639,7 +629,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n }\n \n /// Append an element to a vector\n-#[inline(always)]\n+#[inline]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = transmute(&mut *v);\n@@ -654,7 +644,7 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n }\n \n // This doesn't bother to make sure we have space.\n-#[inline(always)] // really pretty please\n+#[inline] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     let repr: **mut raw::VecRepr = transmute(v);\n     let fill = (**repr).unboxed.fill;\n@@ -681,7 +671,7 @@ fn push_slow<T>(v: &mut ~[T], initval: T) {\n /// vec::push_all(&mut a, [2, 3, 4]);\n /// assert!(a == ~[1, 2, 3, 4]);\n /// ~~~\n-#[inline(always)]\n+#[inline]\n pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -702,7 +692,7 @@ pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n /// vec::push_all_move(&mut a, ~[~2, ~3, ~4]);\n /// assert!(a == ~[~1, ~2, ~3, ~4]);\n /// ~~~\n-#[inline(always)]\n+#[inline]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n@@ -773,7 +763,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n@@ -782,7 +772,7 @@ pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n \n /// Appends one element to the vector provided. The vector itself is then\n /// returned for use again.\n-#[inline(always)]\n+#[inline]\n pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n     v.push(x);\n@@ -804,7 +794,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     let mut i: uint = 0u;\n \n     while i < n {\n-        v.push(*initval);\n+        v.push(copy *initval);\n         i += 1u;\n     }\n }\n@@ -976,7 +966,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(elem) { result.push(*elem); }\n+        if f(elem) { result.push(copy *elem); }\n     }\n     result\n }\n@@ -1032,7 +1022,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.each |&inner| {\n-            if first { first = false; } else { r.push(*sep); }\n+            if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n         r\n@@ -1050,7 +1040,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.each |&inner| {\n-            if first { first = false; } else { r.push(*sep); }\n+            if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n         r\n@@ -1083,7 +1073,7 @@ pub fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  */\n pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n                       f: &fn(t: &T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| v[*i])\n+    position_between(v, start, end, f).map(|i| copy v[*i])\n }\n \n /**\n@@ -1109,7 +1099,7 @@ pub fn rfind_between<T:Copy>(v: &[T],\n                              end: uint,\n                              f: &fn(t: &T) -> bool)\n                           -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| v[*i])\n+    rposition_between(v, start, end, f).map(|i| copy v[*i])\n }\n \n /// Find the first index containing a matching value\n@@ -1233,7 +1223,7 @@ pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut (ts, us) = (~[], ~[]);\n     for each(v) |p| {\n-        let (t, u) = *p;\n+        let (t, u) = copy *p;\n         ts.push(t);\n         us.push(u);\n     }\n@@ -1268,7 +1258,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut i = 0u;\n     assert_eq!(sz, u.len());\n     while i < sz {\n-        zipped.push((v[i], u[i]));\n+        zipped.push((copy v[i], copy u[i]));\n         i += 1u;\n     }\n     zipped\n@@ -1301,7 +1291,7 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-#[inline(always)]\n+#[inline]\n pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n     unsafe {\n         // Can't take two mutable loans from one vector, so instead just cast\n@@ -1365,8 +1355,8 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = v.len();\n     if i == 0 { return (rs); } else { i -= 1; }\n-    while i != 0 { rs.push(v[i]); i -= 1; }\n-    rs.push(v[0]);\n+    while i != 0 { rs.push(copy v[i]); i -= 1; }\n+    rs.push(copy v[0]);\n     rs\n }\n \n@@ -1409,7 +1399,7 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * }\n  * ~~~\n  */\n-#[inline(always)]\n+#[inline]\n pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     //            ^^^^\n     // NB---this CANNOT be &const [T]!  The reason\n@@ -1435,7 +1425,7 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n \n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n-#[inline(always)]\n+#[inline]\n pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     let mut i = 0;\n     let n = v.len();\n@@ -1453,7 +1443,7 @@ pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n  *\n  * Return true to continue, false to break.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     let mut i = 0;\n     for each(v) |p| {\n@@ -1485,7 +1475,7 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n  */\n pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n     let length = values.len();\n-    let mut permutation = vec::from_fn(length, |i| values[i]);\n+    let mut permutation = vec::from_fn(length, |i| copy values[i]);\n     if length <= 1 {\n         fun(permutation);\n         return true;\n@@ -1512,7 +1502,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         reverse_part(indices, k+1, length);\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n-            permutation[i] = values[indices[i]];\n+            permutation[i] = copy values[indices[i]];\n         }\n     }\n }\n@@ -1546,7 +1536,7 @@ pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n  * Allows for unsafe manipulation of vector contents, which is useful for\n  * foreign interop.\n  */\n-#[inline(always)]\n+#[inline]\n pub fn as_imm_buf<T,U>(s: &[T],\n                        /* NB---this CANNOT be const, see below */\n                        f: &fn(*T, uint) -> U) -> U {\n@@ -1565,7 +1555,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n }\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n-#[inline(always)]\n+#[inline]\n pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*const T,uint) = transmute(&s);\n@@ -1575,7 +1565,7 @@ pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n }\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n-#[inline(always)]\n+#[inline]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*mut T,uint) = transmute(&s);\n@@ -1618,49 +1608,49 @@ fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n \n #[cfg(not(test))]\n impl<'self,T:Eq> Eq for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T:TotalEq> TotalEq for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T:TotalEq> TotalEq for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<'self,T:Eq> Equiv<~[T]> for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n }\n \n@@ -1682,19 +1672,19 @@ fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n \n #[cfg(not(test))]\n impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T: TotalOrd> TotalOrd for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(not(test))]\n impl<T: TotalOrd> TotalOrd for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n }\n \n@@ -1719,37 +1709,37 @@ fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(not(test))]\n impl<'self,T:Ord> Ord for &'self [T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for ~[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(not(test))]\n impl<T:Ord> Ord for @[T] {\n-    #[inline(always)]\n+    #[inline]\n     fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n+    #[inline]\n     fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n \n@@ -1760,26 +1750,39 @@ pub mod traits {\n     use vec::append;\n \n     impl<'self,T:Copy> Add<&'self const [T],~[T]> for ~[T] {\n-        #[inline(always)]\n+        #[inline]\n         fn add(&self, rhs: & &'self const [T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<'self,T> Container for &'self const [T] {\n+impl<'self, T> Container for &'self const [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool {\n+    fn is_empty(&self) -> bool {\n         as_const_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n-    fn len(&const self) -> uint {\n+    fn len(&self) -> uint {\n         as_const_buf(*self, |_p, len| len)\n     }\n+}\n \n+impl<T> Container for ~[T] {\n+    /// Returns true if a vector contains no elements\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        as_const_buf(*self, |_p, len| len == 0u)\n+    }\n+\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        as_const_buf(*self, |_p, len| len)\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -1951,7 +1954,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_ref(&self, index: uint) -> *T {\n         let (ptr, _): (*T, uint) = transmute(*self);\n         ptr.offset(index)\n@@ -2022,9 +2025,9 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     }\n \n     /// Returns the element at the given index, without doing bounds checking.\n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n-        *self.unsafe_ref(index)\n+        copy *self.unsafe_ref(index)\n     }\n }\n \n@@ -2203,14 +2206,14 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n         let pair_ptr: &(*mut T, uint) = transmute(self);\n         let (ptr, _) = *pair_ptr;\n         ptr.offset(index)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     unsafe fn unsafe_set(&self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n@@ -2271,7 +2274,7 @@ pub mod raw {\n      * modifing its buffers, so it is up to the caller to ensure that\n      * the vector is actually the specified size.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n         let repr: **mut VecRepr = transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n@@ -2286,7 +2289,7 @@ pub mod raw {\n      * Modifying the vector may cause its buffer to be reallocated, which\n      * would also make any pointers to it invalid.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_ptr<T>(v: &[T]) -> *T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2295,7 +2298,7 @@ pub mod raw {\n     }\n \n     /** see `to_ptr()` */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_const_ptr<T>(v: &const [T]) -> *const T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2304,7 +2307,7 @@ pub mod raw {\n     }\n \n     /** see `to_ptr()` */\n-    #[inline(always)]\n+    #[inline]\n     pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n         unsafe {\n             let repr: **SliceRepr = transmute(&v);\n@@ -2316,7 +2319,7 @@ pub mod raw {\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n@@ -2329,7 +2332,7 @@ pub mod raw {\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n@@ -2341,17 +2344,17 @@ pub mod raw {\n     /**\n      * Unchecked vector indexing.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n-        as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n+        as_const_buf(v, |p, _len| copy *ptr::const_offset(p, i))\n     }\n \n     /**\n      * Unchecked vector index assignment.  Does not drop the\n      * old value and hence is only suitable when the vector\n      * is newly allocated.\n      */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n@@ -2370,7 +2373,7 @@ pub mod raw {\n     * * elts - The number of elements in the buffer\n     */\n     // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n@@ -2384,7 +2387,7 @@ pub mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    #[inline(always)]\n+    #[inline]\n     pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n                                  count: uint) {\n         assert!(dst.len() >= count);\n@@ -2450,7 +2453,7 @@ pub mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    #[inline(always)]\n+    #[inline]\n     pub fn copy_memory(dst: &mut [u8], src: &const [u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n@@ -2461,31 +2464,31 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[inline(always)]\n+    #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n         each(*self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n@@ -2615,28 +2618,27 @@ impl<A:Copy> old_iter::CopyableIter<A> for @[A] {\n     }\n }\n \n-impl<'self,A:Copy + Ord> old_iter::CopyableOrderedIter<A> for &'self [A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n+impl<A:Clone> Clone for ~[A] {\n+    #[inline]\n+    fn clone(&self) -> ~[A] {\n+        self.map(|item| item.clone())\n+    }\n }\n \n-// FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for ~[A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n+// This works because every lifetime is a sub-lifetime of 'static\n+impl<'self, A> Zero for &'self [A] {\n+    fn zero() -> &'self [A] { &'self [] }\n+    fn is_zero(&self) -> bool { self.is_empty() }\n }\n \n-// FIXME(#4148): This should be redundant\n-impl<A:Copy + Ord> old_iter::CopyableOrderedIter<A> for @[A] {\n-    fn min(&self) -> A { old_iter::min(self) }\n-    fn max(&self) -> A { old_iter::max(self) }\n+impl<A> Zero for ~[A] {\n+    fn zero() -> ~[A] { ~[] }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n }\n \n-impl<A:Clone> Clone for ~[A] {\n-    #[inline]\n-    fn clone(&self) -> ~[A] {\n-        self.map(|item| item.clone())\n-    }\n+impl<A> Zero for @[A] {\n+    fn zero() -> @[A] { @[] }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n }\n \n macro_rules! iterator {\n@@ -2704,7 +2706,7 @@ pub struct VecMutRevIterator<'self, T> {\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n impl<T> FromIter<T> for ~[T]{\n-    #[inline(always)]\n+    #[inline]\n     pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n         let mut v = ~[];\n         for iter |x| { v.push(x) }\n@@ -4293,4 +4295,20 @@ mod tests {\n         }\n         assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n     }\n+\n+    #[test]\n+    fn test_vec_zero() {\n+        use num::Zero;\n+        macro_rules! t (\n+            ($ty:ty) => {\n+                let v: $ty = Zero::zero();\n+                assert!(v.is_empty());\n+                assert!(v.is_zero());\n+            }\n+        );\n+\n+        t!(&[int]);\n+        t!(@[int]);\n+        t!(~[int]);\n+    }\n }"}, {"sha": "1758433aa7375c8927ae16fb6de23a27a5bf3f76", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -95,7 +95,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.name.iter_bytes(lsb0, f)\n     }"}, {"sha": "a4ded8fea8c40ad59b7d47f9198f275fa283e897", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -198,7 +198,7 @@ pub fn is_call_expr(e: @expr) -> bool {\n \n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.crate.iter_bytes(lsb0, f) && self.node.iter_bytes(lsb0, f)\n     }\n@@ -395,30 +395,30 @@ impl id_range {\n pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n         for generics.ty_params.each |p| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n         }\n         for generics.lifetimes.each |p| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n         }\n     };\n     visit::mk_vt(@visit::Visitor {\n         visit_mod: |m, sp, id, (t, vt)| {\n-            vfn(id, t);\n+            vfn(id, copy t);\n             visit::visit_mod(m, sp, id, (t, vt));\n         },\n \n         visit_view_item: |vi, (t, vt)| {\n             match vi.node {\n-              view_item_extern_mod(_, _, id) => vfn(id, t),\n+              view_item_extern_mod(_, _, id) => vfn(id, copy t),\n               view_item_use(ref vps) => {\n                   for vps.each |vp| {\n                       match vp.node {\n-                          view_path_simple(_, _, id) => vfn(id, t),\n-                          view_path_glob(_, id) => vfn(id, t),\n+                          view_path_simple(_, _, id) => vfn(id, copy t),\n+                          view_path_glob(_, id) => vfn(id, copy t),\n                           view_path_list(_, ref paths, id) => {\n-                              vfn(id, t);\n+                              vfn(id, copy t);\n                               for paths.each |p| {\n-                                  vfn(p.node.id, t);\n+                                  vfn(p.node.id, copy t);\n                               }\n                           }\n                       }\n@@ -429,85 +429,85 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_foreign_item: |ni, (t, vt)| {\n-            vfn(ni.id, t);\n+            vfn(ni.id, copy t);\n             visit::visit_foreign_item(ni, (t, vt));\n         },\n \n         visit_item: |i, (t, vt)| {\n-            vfn(i.id, t);\n+            vfn(i.id, copy t);\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.each |v| { vfn(v.node.id, t); },\n+                for (*enum_definition).variants.each |v| { vfn(v.node.id, copy t); },\n               _ => ()\n             }\n             visit::visit_item(i, (t, vt));\n         },\n \n         visit_local: |l, (t, vt)| {\n-            vfn(l.node.id, t);\n+            vfn(l.node.id, copy t);\n             visit::visit_local(l, (t, vt));\n         },\n         visit_block: |b, (t, vt)| {\n-            vfn(b.node.id, t);\n+            vfn(b.node.id, copy t);\n             visit::visit_block(b, (t, vt));\n         },\n         visit_stmt: |s, (t, vt)| {\n-            vfn(ast_util::stmt_id(s), t);\n+            vfn(ast_util::stmt_id(s), copy t);\n             visit::visit_stmt(s, (t, vt));\n         },\n         visit_pat: |p, (t, vt)| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n             visit::visit_pat(p, (t, vt));\n         },\n \n         visit_expr: |e, (t, vt)| {\n             {\n                 let r = e.get_callee_id();\n                 for r.iter().advance |callee_id| {\n-                    vfn(*callee_id, t);\n+                    vfn(*callee_id, copy t);\n                 }\n             }\n-            vfn(e.id, t);\n+            vfn(e.id, copy t);\n             visit::visit_expr(e, (t, vt));\n         },\n \n         visit_ty: |ty, (t, vt)| {\n             match ty.node {\n-              ty_path(_, id) => vfn(id, t),\n+              ty_path(_, id) => vfn(id, copy t),\n               _ => { /* fall through */ }\n             }\n             visit::visit_ty(ty, (t, vt));\n         },\n \n         visit_generics: |generics, (t, vt)| {\n-            visit_generics(generics, t);\n+            visit_generics(generics, copy t);\n             visit::visit_generics(generics, (t, vt));\n         },\n \n         visit_fn: |fk, d, a, b, id, (t, vt)| {\n-            vfn(id, t);\n+            vfn(id, copy t);\n \n             match *fk {\n                 visit::fk_item_fn(_, generics, _, _) => {\n-                    visit_generics(generics, t);\n+                    visit_generics(generics, copy t);\n                 }\n                 visit::fk_method(_, generics, m) => {\n-                    vfn(m.self_id, t);\n-                    visit_generics(generics, t);\n+                    vfn(m.self_id, copy t);\n+                    visit_generics(generics, copy t);\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n                 }\n             }\n \n             for d.inputs.each |arg| {\n-                vfn(arg.id, t)\n+                vfn(arg.id, copy t)\n             }\n-            visit::visit_fn(fk, d, a, b, id, (t, vt));\n+            visit::visit_fn(fk, d, a, b, id, (copy t, vt));\n         },\n \n         visit_struct_field: |f, (t, vt)| {\n-            vfn(f.node.id, t);\n+            vfn(f.node.id, copy t);\n             visit::visit_struct_field(f, (t, vt));\n         },\n "}, {"sha": "e096711262fb0b3ffa4fdd643a771049cd664eda", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -312,7 +312,7 @@ pub enum inline_attr {\n \n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n-    // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n+    // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     do attrs.iter().fold(ia_none) |ia,attr| {\n         match attr.node.value.node {\n           ast::meta_word(s) if \"inline\" == s => ia_hint,"}, {"sha": "e67ca5260b8f0d3eff3ffbb08d8b07a94eb17a19", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -318,7 +318,7 @@ pub fn expect<T:Copy>(diag: @span_handler,\n                        opt: Option<T>,\n                        msg: &fn() -> ~str) -> T {\n     match opt {\n-       Some(ref t) => (*t),\n+       Some(ref t) => copy *t,\n        None => diag.handler().bug(msg())\n     }\n }"}, {"sha": "22ce305b85752ff5be019fd15b2ae0502f6a0cbf", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -1052,7 +1052,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n               self_2.method(__arg_1_2, __arg_2_2)])\n ~~~\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: @ExtCtxt, span: span,\n@@ -1083,7 +1083,7 @@ Fold together the results of calling the derived method on all the\n fields. `use_foldl` controls whether this is done left-to-right\n (`true`) or right-to-left (`false`).\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: &fn(@ExtCtxt, span, @expr, @expr) -> @expr,\n                            base: @expr,\n@@ -1111,7 +1111,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n-#[inline(always)]\n+#[inline]\n pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: @ExtCtxt, span: span,\n@@ -1130,7 +1130,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n }\n \n /// cs_binop with binop == or\n-#[inline(always)]\n+#[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n@@ -1139,7 +1139,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx, span, substructure)\n }\n /// cs_binop with binop == and\n-#[inline(always)]\n+#[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {"}, {"sha": "f5170d284c60850d2033b1f9f7cdee570f35f387", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -31,6 +31,7 @@ pub mod encodable;\n pub mod decodable;\n pub mod rand;\n pub mod to_str;\n+pub mod zero;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -98,6 +99,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"Zero\" => expand!(zero::expand_deriving_zero),\n \n                             ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\"}, {"sha": "121d8351ee477f6f941aadd0abe71feeef214444", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use core::vec;\n+\n+pub fn expand_deriving_zero(cx: @ExtCtxt,\n+                            span: span,\n+                            mitem: @meta_item,\n+                            in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[],\n+                ret_ty: Self,\n+                const_nonmatching: false,\n+                combine_substructure: zero_substructure\n+            },\n+            MethodDef {\n+                name: \"is_zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[],\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                const_nonmatching: false,\n+                combine_substructure: |cx, span, substr| {\n+                    cs_and(|cx, span, _, _| cx.span_bug(span,\n+                                                        \"Non-matching enum \\\n+                                                         variant in \\\n+                                                         deriving(Zero)\"),\n+                           cx, span, substr)\n+                }\n+            }\n+        ]\n+    };\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn zero_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    let zero_ident = ~[\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"num\"),\n+        cx.ident_of(\"Zero\"),\n+        cx.ident_of(\"zero\")\n+    ];\n+    let zero_call = || {\n+        cx.expr_call_global(span, copy zero_ident, ~[])\n+    };\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            match *summary {\n+                Left(count) => {\n+                    if count == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let exprs = vec::from_fn(count, |_| zero_call());\n+                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let zero_fields = do fields.map |ident| {\n+                        cx.field_imm(span, *ident, zero_call())\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n+                }\n+            }\n+        }\n+        StaticEnum(*) => {\n+            cx.span_fatal(span, \"`Zero` cannot be derived for enums, \\\n+                                 only structs\")\n+        }\n+        _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n+    };\n+}"}, {"sha": "44e480dc7df2d1e3877f643216566b3169b695d2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -39,8 +39,6 @@ pub mod rt {\n     use parse;\n     use print::pprust;\n \n-    use core::str;\n-\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;"}, {"sha": "c1bf979cd319bda56ee393db234d1abd87dd645c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -969,7 +969,7 @@ mod test {\n     // change every identifier to \"zz\"\n     pub fn to_zz() -> @fn(ast::ident)->ast::ident {\n         let zz_id = token::str_to_ident(\"zz\");\n-        |id| {zz_id}\n+        |_id| {zz_id}\n     }\n \n     // maybe add to expand.rs..."}, {"sha": "81f540fd69f2b0b23b652afb1d4e2b6db4049109", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -103,7 +103,7 @@ impl<T:Copy> OptVec<T> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n         let mut index = 0;\n         old_iter::map_to_vec(self, |a| {\n@@ -145,31 +145,31 @@ impl<A> BaseIter<A> for OptVec<A> {\n }\n \n impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n         old_iter::eachi(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::any(self, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         old_iter::foldl(self, b0, blk)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         old_iter::position(self, f)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         old_iter::map_to_vec(self, op)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         old_iter::flat_map_to_vec(self, op)\n@@ -178,28 +178,21 @@ impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n }\n \n impl<A: Eq> old_iter::EqIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    #[inline(always)]\n+    #[inline]\n     fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n }\n \n impl<A: Copy> old_iter::CopyableIter<A> for OptVec<A> {\n-    #[inline(always)]\n+    #[inline]\n     fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         old_iter::filter_to_vec(self, pred)\n     }\n-    #[inline(always)]\n+    #[inline]\n     fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    #[inline(always)]\n+    #[inline]\n     fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         old_iter::find(self, f)\n     }\n }\n-\n-impl<A: Copy+Ord> old_iter::CopyableOrderedIter<A> for OptVec<A> {\n-    #[inline(always)]\n-    fn min(&self) -> A { old_iter::min(self) }\n-    #[inline(always)]\n-    fn max(&self) -> A { old_iter::max(self) }\n-}"}, {"sha": "472f807cd8b682a6b8f0241a73d07039d23f4358", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 69, "deletions": 29, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -69,52 +69,59 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         return lines.slice(i, j).to_owned();\n     }\n \n-    // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: ~[~str], chars: ~str, max: Option<uint>) -> ~[~str] {\n-\n-        let mut i = max.get_or_default(uint::max_value);\n-        for lines.each |line| {\n-            if line.trim().is_empty() {\n-                loop;\n-            }\n+    /// remove a \"[ \\t]*\\*\" block from each line, if possible\n+    fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n+        let mut i = uint::max_value;\n+        let mut can_trim = true;\n+        let mut first = true;\n+        for lines.iter().advance |line| {\n             for line.iter().enumerate().advance |(j, c)| {\n-                if j >= i {\n+                if j > i || !\"* \\t\".contains_char(c) {\n+                    can_trim = false;\n                     break;\n                 }\n-                if !chars.contains_char(c) {\n-                    i = j;\n+                if c == '*' {\n+                    if first {\n+                        i = j;\n+                        first = false;\n+                    } else if i != j {\n+                        can_trim = false;\n+                    }\n                     break;\n                 }\n             }\n+            if i > line.len() {\n+                can_trim = false;\n+            }\n+            if !can_trim {\n+                break;\n+            }\n         }\n \n-        return do lines.map |line| {\n-            let mut chars = ~[];\n-            for line.iter().advance |c| { chars.push(c) }\n-            if i > chars.len() {\n-                ~\"\"\n-            } else {\n-                str::from_chars(chars.slice(i, chars.len()).to_owned())\n+        if can_trim {\n+            do lines.map |line| {\n+                line.slice(i + 1, line.len()).to_owned()\n             }\n-        };\n+        } else {\n+            lines\n+        }\n     }\n \n     if comment.starts_with(\"//\") {\n         // FIXME #5475:\n-        // return comment.slice(3u, comment.len()).trim().to_owned();\n-        let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n-\n+        // return comment.slice(3u, comment.len()).to_owned();\n+        let r = comment.slice(3u, comment.len()); return r.to_owned();\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let mut lines = ~[];\n-        for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n-            lines.push(line.to_owned())\n-        }\n+        let lines = comment.slice(3u, comment.len() - 2u)\n+            .any_line_iter()\n+            .transform(|s| s.to_owned())\n+            .collect::<~[~str]>();\n+\n         let lines = vertical_trim(lines);\n-        let lines = block_trim(lines, ~\"\\t \", None);\n-        let lines = block_trim(lines, ~\"*\", Some(1u));\n-        let lines = block_trim(lines, ~\"\\t \", None);\n+        let lines = horizontal_trim(lines);\n+\n         return lines.connect(\"\\n\");\n     }\n \n@@ -372,3 +379,36 @@ pub fn gather_comments_and_literals(span_diagnostic:\n \n     (comments, literals)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test] fn test_block_doc_comment_1() {\n+        let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n+        let correct_stripped = \" Test \\n*  Test\\n   Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_2() {\n+        let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n+        let correct_stripped = \" Test\\n  Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_3() {\n+        let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n+        let correct_stripped = \" let a: *int;\\n *a = 5;\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_line_doc_comment() {\n+        let comment = \"/// Test\";\n+        let correct_stripped = \" Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+}"}, {"sha": "bb315bf2933957dffa8a71eb263565cb03004c8e", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -68,7 +68,7 @@ pub enum ObsoleteSyntax {\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n-    #[inline(always)]\n+    #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         (*self as uint).iter_bytes(lsb0, f)\n     }"}, {"sha": "273a59f0a3dee33570800f7bbcce991ea883136a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 71, "deletions": 72, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -400,6 +400,7 @@ impl ident_interner {\n     }\n }\n \n+\n // return a fresh interner, preloaded with special identifiers.\n fn mk_fresh_ident_interner() -> @ident_interner {\n     // the indices here must correspond to the numbers in\n@@ -446,39 +447,38 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"const\",              // 37\n         \"copy\",               // 38\n         \"do\",                 // 39\n-        \"drop\",               // 40\n-        \"else\",               // 41\n-        \"enum\",               // 42\n-        \"extern\",             // 43\n-        \"false\",              // 44\n-        \"fn\",                 // 45\n-        \"for\",                // 46\n-        \"if\",                 // 47\n-        \"impl\",               // 48\n-        \"let\",                // 49\n-        \"__log\",              // 50\n-        \"loop\",               // 51\n-        \"match\",              // 52\n-        \"mod\",                // 53\n-        \"mut\",                // 54\n-        \"once\",               // 55\n-        \"priv\",               // 56\n-        \"pub\",                // 57\n-        \"pure\",               // 58\n-        \"ref\",                // 59\n-        \"return\",             // 60\n+        \"else\",               // 40\n+        \"enum\",               // 41\n+        \"extern\",             // 42\n+        \"false\",              // 43\n+        \"fn\",                 // 44\n+        \"for\",                // 45\n+        \"if\",                 // 46\n+        \"impl\",               // 47\n+        \"let\",                // 48\n+        \"__log\",              // 49\n+        \"loop\",               // 50\n+        \"match\",              // 51\n+        \"mod\",                // 52\n+        \"mut\",                // 53\n+        \"once\",               // 54\n+        \"priv\",               // 55\n+        \"pub\",                // 56\n+        \"pure\",               // 57\n+        \"ref\",                // 58\n+        \"return\",             // 59\n         \"static\",             // 29 -- also a special ident\n         \"self\",               //  8 -- also a special ident\n-        \"struct\",             // 61\n-        \"super\",              // 62\n-        \"true\",               // 63\n-        \"trait\",              // 64\n-        \"type\",               // 65\n-        \"unsafe\",             // 66\n-        \"use\",                // 67\n-        \"while\",              // 68\n-\n-        \"be\",                 // 69\n+        \"struct\",             // 60\n+        \"super\",              // 61\n+        \"true\",               // 62\n+        \"trait\",              // 63\n+        \"type\",               // 64\n+        \"unsafe\",             // 65\n+        \"use\",                // 66\n+        \"while\",              // 67\n+\n+        \"be\",                 // 68\n     ];\n \n     @ident_interner {\n@@ -498,9 +498,7 @@ pub fn get_ident_interner() -> @ident_interner {\n             Some(interner) => *interner,\n             None => {\n                 let interner = mk_fresh_ident_interner();\n-                unsafe {\n-                    local_data::local_data_set(key, @interner);\n-                }\n+                local_data::local_data_set(key, @interner);\n                 interner\n             }\n         }\n@@ -615,41 +613,41 @@ pub mod keywords {\n         pub fn to_ident(&self) -> ident {\n             match *self {\n                 As => ident { name: 35, ctxt: 0 },\n-                   Break => ident { name: 36, ctxt: 0 },\n-                   Const => ident { name: 37, ctxt: 0 },\n-                   Copy => ident { name: 38, ctxt: 0 },\n-                   Do => ident { name: 39, ctxt: 0 },\n-                   Else => ident { name: 41, ctxt: 0 },\n-                   Enum => ident { name: 42, ctxt: 0 },\n-                   Extern => ident { name: 43, ctxt: 0 },\n-                   False => ident { name: 44, ctxt: 0 },\n-                   Fn => ident { name: 45, ctxt: 0 },\n-                   For => ident { name: 46, ctxt: 0 },\n-                   If => ident { name: 47, ctxt: 0 },\n-                   Impl => ident { name: 48, ctxt: 0 },\n-                   Let => ident { name: 49, ctxt: 0 },\n-                   __Log => ident { name: 50, ctxt: 0 },\n-                   Loop => ident { name: 51, ctxt: 0 },\n-                   Match => ident { name: 52, ctxt: 0 },\n-                   Mod => ident { name: 53, ctxt: 0 },\n-                   Mut => ident { name: 54, ctxt: 0 },\n-                   Once => ident { name: 55, ctxt: 0 },\n-                   Priv => ident { name: 56, ctxt: 0 },\n-                   Pub => ident { name: 57, ctxt: 0 },\n-                   Pure => ident { name: 58, ctxt: 0 },\n-                   Ref => ident { name: 59, ctxt: 0 },\n-                   Return => ident { name: 60, ctxt: 0 },\n-                   Static => ident { name: 29, ctxt: 0 },\n-                   Self => ident { name: 8, ctxt: 0 },\n-                   Struct => ident { name: 61, ctxt: 0 },\n-                   Super => ident { name: 62, ctxt: 0 },\n-                   True => ident { name: 63, ctxt: 0 },\n-                   Trait => ident { name: 64, ctxt: 0 },\n-                   Type => ident { name: 65, ctxt: 0 },\n-                   Unsafe => ident { name: 66, ctxt: 0 },\n-                   Use => ident { name: 67, ctxt: 0 },\n-                   While => ident { name: 68, ctxt: 0 },\n-                   Be => ident { name: 69, ctxt: 0 },\n+                Break => ident { name: 36, ctxt: 0 },\n+                Const => ident { name: 37, ctxt: 0 },\n+                Copy => ident { name: 38, ctxt: 0 },\n+                Do => ident { name: 39, ctxt: 0 },\n+                Else => ident { name: 40, ctxt: 0 },\n+                Enum => ident { name: 41, ctxt: 0 },\n+                Extern => ident { name: 42, ctxt: 0 },\n+                False => ident { name: 43, ctxt: 0 },\n+                Fn => ident { name: 44, ctxt: 0 },\n+                For => ident { name: 45, ctxt: 0 },\n+                If => ident { name: 46, ctxt: 0 },\n+                Impl => ident { name: 47, ctxt: 0 },\n+                Let => ident { name: 48, ctxt: 0 },\n+                __Log => ident { name: 49, ctxt: 0 },\n+                Loop => ident { name: 50, ctxt: 0 },\n+                Match => ident { name: 51, ctxt: 0 },\n+                Mod => ident { name: 52, ctxt: 0 },\n+                Mut => ident { name: 53, ctxt: 0 },\n+                Once => ident { name: 54, ctxt: 0 },\n+                Priv => ident { name: 55, ctxt: 0 },\n+                Pub => ident { name: 56, ctxt: 0 },\n+                Pure => ident { name: 57, ctxt: 0 },\n+                Ref => ident { name: 58, ctxt: 0 },\n+                Return => ident { name: 59, ctxt: 0 },\n+                Static => ident { name: 29, ctxt: 0 },\n+                Self => ident { name: 8, ctxt: 0 },\n+                Struct => ident { name: 60, ctxt: 0 },\n+                Super => ident { name: 61, ctxt: 0 },\n+                True => ident { name: 62, ctxt: 0 },\n+                Trait => ident { name: 63, ctxt: 0 },\n+                Type => ident { name: 64, ctxt: 0 },\n+                Unsafe => ident { name: 65, ctxt: 0 },\n+                Use => ident { name: 66, ctxt: 0 },\n+                While => ident { name: 67, ctxt: 0 },\n+                Be => ident { name: 68, ctxt: 0 },\n             }\n         }\n     }\n@@ -665,7 +663,7 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 69 => true,\n+            8 | 29 | 35 .. 68 => true,\n             _ => false,\n         },\n         _ => false\n@@ -675,7 +673,7 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 68 => true,\n+            8 | 29 | 35 .. 67 => true,\n             _ => false,\n         },\n         _ => false,\n@@ -685,13 +683,14 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            69 => true,\n+            68 => true,\n             _ => false,\n         },\n         _ => false,\n     }\n }\n \n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "e72d9b502dcd8b06567ef9f8d61305a8162f3c6b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -322,7 +322,7 @@ pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     let mut first = true;\n     for elts.each |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        op(s, *elt);\n+        op(s, copy *elt);\n     }\n     end(s);\n }\n@@ -334,13 +334,13 @@ pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n     let len = elts.len();\n     let mut i = 0u;\n     for elts.each |elt| {\n-        maybe_print_comment(s, get_span(*elt).hi);\n-        op(s, *elt);\n+        maybe_print_comment(s, get_span(copy *elt).hi);\n+        op(s, copy *elt);\n         i += 1u;\n         if i < len {\n             word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(*elt),\n-                                         Some(get_span(elts[i]).hi));\n+            maybe_print_trailing_comment(s, get_span(copy *elt),\n+                                         Some(get_span(copy elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n@@ -2118,7 +2118,7 @@ pub fn print_string(s: @ps, st: &str) {\n pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        f(s, t);\n+        f(s, copy t);\n         eof(s.s);\n     }\n }"}, {"sha": "278600bc0394cf4768f6c6b87bbce7824107ed7e", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -30,17 +30,8 @@ extern mod core(name = \"std\");\n extern mod extra(name = \"extra\");\n \n // For deriving(Encodable) purposes...\n-#[cfg(stage0)]\n-extern mod std(name = \"extra\");\n-#[cfg(not(stage0))]\n extern mod std(name = \"std\");\n \n-// For bootstrapping purposes.\n-#[cfg(stage0)]\n-pub use core::str;\n-#[cfg(stage0)]\n-pub use core::unstable;\n-\n use core::prelude::*;\n \n pub mod util {"}, {"sha": "bd5c178e7fe7d3e664449eb2368caf41f6155b41", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -36,7 +36,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for init.each() |v| { rv.intern(*v); }\n+        for init.each() |v| { rv.intern(copy *v); }\n         rv\n     }\n \n@@ -48,7 +48,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n \n         let vect = &mut *self.vect;\n         let new_idx = vect.len();\n-        self.map.insert(val, new_idx);\n+        self.map.insert(copy val, new_idx);\n         vect.push(val);\n         new_idx\n     }\n@@ -63,7 +63,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n         new_idx\n     }\n \n-    pub fn get(&self, idx: uint) -> T { self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> T { copy self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n "}, {"sha": "f24c393d7b482f7b5011db0eea03fde27b1208c0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 113, "deletions": 99, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -127,15 +127,15 @@ pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n-    for m.items.each |i| { (v.visit_item)(*i, (e, v)); }\n+    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+    for m.items.each |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n pub fn visit_view_item<E>(_vi: @view_item, (_e, _v): (E, vt<E>)) { }\n \n pub fn visit_local<E: Copy>(loc: @local, (e, v): (E, vt<E>)) {\n-    (v.visit_pat)(loc.node.pat, (e, v));\n-    (v.visit_ty)(loc.node.ty, (e, v));\n+    (v.visit_pat)(loc.node.pat, (copy e, v));\n+    (v.visit_ty)(loc.node.ty, (copy e, v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n@@ -149,8 +149,8 @@ fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, (e, v): (E, vt<E>)) {\n pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n     match i.node {\n         item_const(t, ex) => {\n-            (v.visit_ty)(t, (e, v));\n-            (v.visit_expr)(ex, (e, v));\n+            (v.visit_ty)(t, (copy e, v));\n+            (v.visit_expr)(ex, (copy e, v));\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             (v.visit_fn)(\n@@ -170,40 +170,40 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n-            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (e, v)); }\n+            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n         item_ty(t, ref tps) => {\n-            (v.visit_ty)(t, (e, v));\n+            (v.visit_ty)(t, (copy e, v));\n             (v.visit_generics)(tps, (e, v));\n         }\n         item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_generics)(tps, (e, v));\n+            (v.visit_generics)(tps, (copy e, v));\n             visit_enum_def(\n                 enum_definition,\n                 tps,\n                 (e, v)\n             );\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n-            (v.visit_generics)(tps, (e, v));\n+            (v.visit_generics)(tps, (copy e, v));\n             for traits.iter().advance |&p| {\n-                visit_trait_ref(p, (e, v));\n+                visit_trait_ref(p, (copy e, v));\n             }\n-            (v.visit_ty)(ty, (e, v));\n+            (v.visit_ty)(ty, (copy e, v));\n             for methods.each |m| {\n-                visit_method_helper(*m, (e, v))\n+                visit_method_helper(*m, (copy e, v))\n             }\n         }\n         item_struct(struct_def, ref generics) => {\n-            (v.visit_generics)(generics, (e, v));\n+            (v.visit_generics)(generics, (copy e, v));\n             (v.visit_struct_def)(struct_def, i.ident, generics, i.id, (e, v));\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n-            (v.visit_generics)(generics, (e, v));\n-            for traits.each |p| { visit_path(p.path, (e, v)); }\n+            (v.visit_generics)(generics, (copy e, v));\n+            for traits.each |p| { visit_path(p.path, (copy e, v)); }\n             for methods.each |m| {\n-                (v.visit_trait_method)(m, (e, v));\n+                (v.visit_trait_method)(m, (copy e, v));\n             }\n         }\n         item_mac(ref m) => visit_mac(m, (e, v))\n@@ -216,15 +216,19 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.each |va| { (v.visit_ty)(va.ty, (e, v)); }\n+                for variant_args.each |va| {\n+                    (v.visit_ty)(va.ty, (copy e, v));\n+                }\n             }\n             struct_variant_kind(struct_def) => {\n                 (v.visit_struct_def)(struct_def, vr.node.name, tps,\n-                                   vr.node.id, (e, v));\n+                                     vr.node.id, (copy e, v));\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.iter().advance |ex| { (v.visit_expr)(*ex, (e, v)) }\n+        for vr.node.disr_expr.iter().advance |ex| {\n+            (v.visit_expr)(*ex, (copy e, v))\n+        }\n     }\n }\n \n@@ -238,71 +242,75 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n         },\n         ty_tup(ref ts) => {\n             for ts.each |tt| {\n-                (v.visit_ty)(*tt, (e, v));\n+                (v.visit_ty)(*tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_path(p, _) => visit_path(p, (e, v)),\n         ty_fixed_length_vec(ref mt, ex) => {\n-            (v.visit_ty)(mt.ty, (e, v));\n-            (v.visit_expr)(ex, (e, v));\n+            (v.visit_ty)(mt.ty, (copy e, v));\n+            (v.visit_expr)(ex, (copy e, v));\n         },\n         ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n pub fn visit_path<E: Copy>(p: @Path, (e, v): (E, vt<E>)) {\n-    for p.types.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n+    for p.types.each |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(path, ref children) => {\n-            visit_path(path, (e, v));\n+            visit_path(path, (copy e, v));\n             for children.iter().advance |children| {\n-                for children.iter().advance |child| { (v.visit_pat)(*child, (e, v)); }\n+                for children.iter().advance |child| {\n+                    (v.visit_pat)(*child, (copy e, v));\n+                }\n             }\n         }\n         pat_struct(path, ref fields, _) => {\n-            visit_path(path, (e, v));\n+            visit_path(path, (copy e, v));\n             for fields.each |f| {\n-                (v.visit_pat)(f.pat, (e, v));\n+                (v.visit_pat)(f.pat, (copy e, v));\n             }\n         }\n         pat_tup(ref elts) => {\n             for elts.each |elt| {\n-                (v.visit_pat)(*elt, (e, v))\n+                (v.visit_pat)(*elt, (copy e, v))\n             }\n         },\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n         pat_ident(_, path, ref inner) => {\n-            visit_path(path, (e, v));\n-            for inner.iter().advance |subpat| { (v.visit_pat)(*subpat, (e, v)) }\n+            visit_path(path, (copy e, v));\n+            for inner.iter().advance |subpat| {\n+                (v.visit_pat)(*subpat, (copy e, v))\n+            }\n         }\n         pat_lit(ex) => (v.visit_expr)(ex, (e, v)),\n         pat_range(e1, e2) => {\n-            (v.visit_expr)(e1, (e, v));\n+            (v.visit_expr)(e1, (copy e, v));\n             (v.visit_expr)(e2, (e, v));\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n             for before.each |elt| {\n-                (v.visit_pat)(*elt, (e, v));\n+                (v.visit_pat)(*elt, (copy e, v));\n             }\n             for slice.iter().advance |elt| {\n-                (v.visit_pat)(*elt, (e, v));\n+                (v.visit_pat)(*elt, (copy e, v));\n             }\n             for after.each |tail| {\n-                (v.visit_pat)(*tail, (e, v));\n+                (v.visit_pat)(*tail, (copy e, v));\n             }\n         }\n     }\n@@ -311,7 +319,7 @@ pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n-            visit_fn_decl(fd, (e, v));\n+            visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n         foreign_item_const(t) => {\n@@ -324,22 +332,22 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.each |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, (e, v)),\n+            TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.each |tp| {\n-        visit_ty_param_bounds(tp.bounds, (e, v));\n+        visit_ty_param_bounds(tp.bounds, (copy e, v));\n     }\n }\n \n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.each |a| {\n-        (v.visit_pat)(a.pat, (e, v));\n-        (v.visit_ty)(a.ty, (e, v));\n+        (v.visit_pat)(a.pat, (copy e, v));\n+        (v.visit_ty)(a.ty, (copy e, v));\n     }\n     (v.visit_ty)(fd.output, (e, v));\n }\n@@ -365,15 +373,15 @@ pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n \n pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                          _id: node_id, (e, v): (E, vt<E>)) {\n-    visit_fn_decl(decl, (e, v));\n+    visit_fn_decl(decl, (copy e, v));\n     let generics = generics_of_fn(fk);\n-    (v.visit_generics)(&generics, (e, v));\n+    (v.visit_generics)(&generics, (copy e, v));\n     (v.visit_block)(body, (e, v));\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n-    (v.visit_generics)(&m.generics, (e, v));\n+    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    (v.visit_generics)(&m.generics, (copy e, v));\n     (v.visit_ty)(m.decl.output, (e, v));\n }\n \n@@ -392,7 +400,7 @@ pub fn visit_struct_def<E: Copy>(\n     (e, v): (E, vt<E>)\n ) {\n     for sd.fields.each |f| {\n-        (v.visit_struct_field)(*f, (e, v));\n+        (v.visit_struct_field)(*f, (copy e, v));\n     }\n }\n \n@@ -406,10 +414,10 @@ pub fn visit_struct_method<E: Copy>(m: @method, (e, v): (E, vt<E>)) {\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.node.view_items.each |vi| {\n-        (v.visit_view_item)(*vi, (e, v));\n+        (v.visit_view_item)(*vi, (copy e, v));\n     }\n     for b.node.stmts.each |s| {\n-        (v.visit_stmt)(*s, (e, v));\n+        (v.visit_stmt)(*s, (copy e, v));\n     }\n     visit_expr_opt(b.node.expr, (e, v));\n }\n@@ -435,7 +443,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E: Copy>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.each |ex| { (v.visit_expr)(*ex, (e, v)); }\n+    for exprs.each |ex| { (v.visit_expr)(*ex, (copy e, v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -444,53 +452,57 @@ pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n \n pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n     match ex.node {\n-        expr_vstore(x, _) => (v.visit_expr)(x, (e, v)),\n-        expr_vec(ref es, _) => visit_exprs(*es, (e, v)),\n+        expr_vstore(x, _) => (v.visit_expr)(x, (copy e, v)),\n+        expr_vec(ref es, _) => visit_exprs(*es, (copy e, v)),\n         expr_repeat(element, count, _) => {\n-            (v.visit_expr)(element, (e, v));\n-            (v.visit_expr)(count, (e, v));\n+            (v.visit_expr)(element, (copy e, v));\n+            (v.visit_expr)(count, (copy e, v));\n         }\n         expr_struct(p, ref flds, base) => {\n-            visit_path(p, (e, v));\n-            for flds.each |f| { (v.visit_expr)(f.node.expr, (e, v)); }\n-            visit_expr_opt(base, (e, v));\n+            visit_path(p, (copy e, v));\n+            for flds.each |f| {\n+                (v.visit_expr)(f.node.expr, (copy e, v));\n+            }\n+            visit_expr_opt(base, (copy e, v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.each |el| { (v.visit_expr)(*el, (e, v)) }\n+            for elts.each |el| { (v.visit_expr)(*el, (copy e, v)) }\n         }\n         expr_call(callee, ref args, _) => {\n-            visit_exprs(*args, (e, v));\n-            (v.visit_expr)(callee, (e, v));\n+            visit_exprs(*args, (copy e, v));\n+            (v.visit_expr)(callee, (copy e, v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n-            visit_exprs(*args, (e, v));\n-            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n-            (v.visit_expr)(callee, (e, v));\n+            visit_exprs(*args, (copy e, v));\n+            for tys.each |tp| {\n+                (v.visit_ty)(*tp, (copy e, v));\n+            }\n+            (v.visit_expr)(callee, (copy e, v));\n         }\n         expr_binary(_, _, a, b) => {\n-            (v.visit_expr)(a, (e, v));\n-            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (copy e, v));\n         }\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (e, v)),\n+        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_lit(_) => (),\n         expr_cast(x, t) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_ty)(t, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_ty)(t, (copy e, v));\n         }\n         expr_if(x, ref b, eo) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_block)(b, (e, v));\n-            visit_expr_opt(eo, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_block)(b, (copy e, v));\n+            visit_expr_opt(eo, (copy e, v));\n         }\n         expr_while(x, ref b) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_block)(b, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_block)(b, (copy e, v));\n         }\n-        expr_loop(ref b, _) => (v.visit_block)(b, (e, v)),\n+        expr_loop(ref b, _) => (v.visit_block)(b, (copy e, v)),\n         expr_match(x, ref arms) => {\n-            (v.visit_expr)(x, (e, v));\n-            for arms.each |a| { (v.visit_arm)(a, (e, v)); }\n+            (v.visit_expr)(x, (copy e, v));\n+            for arms.each |a| { (v.visit_arm)(a, (copy e, v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -499,54 +511,56 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n                 body,\n                 ex.span,\n                 ex.id,\n-                (e, v)\n+                (copy e, v)\n             );\n         }\n-        expr_block(ref b) => (v.visit_block)(b, (e, v)),\n+        expr_block(ref b) => (v.visit_block)(b, (copy e, v)),\n         expr_assign(a, b) => {\n-            (v.visit_expr)(b, (e, v));\n-            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (copy e, v));\n         }\n-        expr_copy(a) => (v.visit_expr)(a, (e, v)),\n+        expr_copy(a) => (v.visit_expr)(a, (copy e, v)),\n         expr_assign_op(_, _, a, b) => {\n-            (v.visit_expr)(b, (e, v));\n-            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (copy e, v));\n         }\n         expr_field(x, _, ref tys) => {\n-            (v.visit_expr)(x, (e, v));\n-            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n+            (v.visit_expr)(x, (copy e, v));\n+            for tys.each |tp| {\n+                (v.visit_ty)(*tp, (copy e, v));\n+            }\n         }\n         expr_index(_, a, b) => {\n-            (v.visit_expr)(a, (e, v));\n-            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (copy e, v));\n         }\n-        expr_path(p) => visit_path(p, (e, v)),\n+        expr_path(p) => visit_path(p, (copy e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n-        expr_ret(eo) => visit_expr_opt(eo, (e, v)),\n+        expr_ret(eo) => visit_expr_opt(eo, (copy e, v)),\n         expr_log(lv, x) => {\n-            (v.visit_expr)(lv, (e, v));\n-            (v.visit_expr)(x, (e, v));\n+            (v.visit_expr)(lv, (copy e, v));\n+            (v.visit_expr)(x, (copy e, v));\n         }\n-        expr_mac(ref mac) => visit_mac(mac, (e, v)),\n-        expr_paren(x) => (v.visit_expr)(x, (e, v)),\n+        expr_mac(ref mac) => visit_mac(mac, (copy e, v)),\n+        expr_paren(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_inline_asm(ref a) => {\n             for a.inputs.each |&(_, in)| {\n-                (v.visit_expr)(in, (e, v));\n+                (v.visit_expr)(in, (copy e, v));\n             }\n             for a.outputs.each |&(_, out)| {\n-                (v.visit_expr)(out, (e, v));\n+                (v.visit_expr)(out, (copy e, v));\n             }\n         }\n     }\n     (v.visit_expr_post)(ex, (e, v));\n }\n \n pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e, v)); }\n-    visit_expr_opt(a.guard, (e, v));\n-    (v.visit_block)(&a.body, (e, v));\n+    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (copy e, v)); }\n+    visit_expr_opt(a.guard, (copy e, v));\n+    (v.visit_block)(&a.body, (copy e, v));\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply"}, {"sha": "a95e183a1d12d2acb917c7a8b0b41f17d6589b1e", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5", "patch": "@@ -207,12 +207,14 @@ MORESTACK:\n \tsubl $12, %esp\n \n \t// Save the return value of the function we allocated space for\n+\tmovl %edx, 4(%esp)\n \tmovl %eax, (%esp)\n \n \tcall UPCALL_DEL_STACK\n \n \t// And restore it\n \tmovl (%esp), %eax\n+\tmovl 4(%esp), %edx\n \n \taddl $12,%esp\n "}, {"sha": "51e2849eb548043dfa6aef1cfdd351a22488b346", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e37856255a7d60a360873d326cb66360cecb20c8", "filename": "src/rt/rust_gc_metadata.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_gc_metadata.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_gc_metadata.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gc_metadata.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "8179c53e96d5e6e4aac7e699785b159d88b5d2c1", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "fe1b4622137eb0ad28f28bb9ec132fc47a984bad", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "6d36d2c960a2d4fdb739a4b05eda20bf39ab76d7", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "242c2ef0a81adedcaf554307223f74d1b79a43ca", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "b604f60cba6e2203d2ef8548291dbb8761d0f7ec", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "32b6df4e1dd595c572d1cab9a45b3731750798aa", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "614c1723c5fb75c0710b326e0f6688e59290dcb7", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "d5f03ac604b7605724c4aa70a33ca3b9e9a7a180", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "d4202abd2854e685a9e6c0774143bbf67b5eb6fd", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "1aaf5fee26ab4f08082288eda0e014f5ea75cdff", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e45bfc8ea5dc38a9f1c6c772ea59781f8fc4c42f", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "c0b98f2af07ce0e009af806b4ffd91719f097781", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "7a9be75488494b90ad627bca8aef533835975a84", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "796072c848587ea8f38af86618a241dd3be73af0", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "0f6ca37a3fbba83668c57d0112c4827392cbee70", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "8c8b26afa08b117cf080487a43b4fca4a376837d", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e12df5811eeea4d179ebcb4b76f57fdb5c900bb2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e1366a3a8694ceae71737777ad9b9a1366dc0def", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "377b2016bcbe91adaf35d3c0726e037b7e2ecc18", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "ec84551f7b0a58a858029e1fc9c8e11e8057357a", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "616740c850c5431d81d8c99a2b80630197ad2d2d", "filename": "src/test/debug-info/basic-types.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "4a3a65a90550c1770bedb5f50fb8929ca94ac1fd", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "ddfac9cbeea8f6312632990e585df7b034a73f27", "filename": "src/test/debug-info/struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "a50996871cee98e9e960b0abbcffdb91fd2cb6bc", "filename": "src/test/debug-info/tuple.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "f198a53729eb7add46570cfeb1e9754f1dc963c9", "filename": "src/test/debug-info/vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "6f1b4b815213b3bc8b4c080bbab2ba1293574b05", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "753e5339de9da1a2e08347d17cf01e2ddb6ef301", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "6e5b837e0aafbf6953f3c7b4606ae6b72841fb24", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "2d83e9746b580951f258bc2625405315e8a3ced8", "filename": "src/test/run-pass/borrowck-move-from-unsafe-ptr-ok.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs?ref=794923c99511398bc90400e380dd11770ec8e614"}, {"sha": "86e8f600cd53eb85bedf51de4025069222f14df1", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "f4fb10fea7248fe73d838c264ca56b992a9ede49", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "69da3c8d9862b68cec4096c622fd6e7811d8c7cd", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "2ee57624112fae4ecf4b0aa62c69fb3aaab0063b", "filename": "src/test/run-pass/deriving-zero.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "9cf047d425c3362189f33c42e3b1bd6d551fb4a0", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "25bf553ff35c38a42d810f35a394a574ae8fa785", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "afb1a4c76bbb20191e15156c948fe9a6ef831966", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "186d15c3490ae67945eb062b9d01360ae1061251", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "2e6db3bba07f3a0cd50be87e24c197e15c475698", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "64aa4ce3609ab81c041b886097c00ab74f1b2920", "filename": "src/test/run-pass/expr-match-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "bd87e7207d1491109bc92c24c1f6ff7de20c5fcc", "filename": "src/test/run-pass/expr-match-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e722c4f5c6a9026962e9bb334f05233bb912d3b0", "filename": "src/test/run-pass/extern-pub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pub.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "649fe3433b46c2eba0e7ead3c9e187686a180249", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "014aebeff9dac7b5294e705d0fa385e283c7a9ce", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "7cee6b4e8de661beb8f9f939f5112b08322ee770", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "c51094d26c88febea99babd915cc58d095e40dee", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "0e0bf2a13e171eb84b8c90834b5b6f52e6bc6ab1", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "7ac38966faa3eee58c2f2b728f1c2c91f9ed7712", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "e091554a357281527140554b55d36f024dd99d82", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "7a18cd02c2de7202175f2f687caa7effcb86c337", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "275622161d34f1ed28f2811d7f921fe1dea5fd66", "filename": "src/test/run-pass/sized-borrowed-pointer", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fsized-borrowed-pointer", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fsized-borrowed-pointer", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsized-borrowed-pointer?ref=794923c99511398bc90400e380dd11770ec8e614"}, {"sha": "3a290ba47ffb228dbaf66fb0a68f7f003a15967f", "filename": "src/test/run-pass/sized-owned-pointer", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fsized-owned-pointer", "raw_url": "https://github.com/rust-lang/rust/raw/794923c99511398bc90400e380dd11770ec8e614/src%2Ftest%2Frun-pass%2Fsized-owned-pointer", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsized-owned-pointer?ref=794923c99511398bc90400e380dd11770ec8e614"}, {"sha": "2d6b2141c5c73cdc7b9a42cbaad01f679813207d", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}, {"sha": "4e98543ae826ea7e7e8ea2fc0ab2da978be6e5ca", "filename": "src/test/run-pass/unfoldr-cross-crate.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4870dce3ebfd0e988a2e45360c724ebe912c3ad5/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfoldr-cross-crate.rs?ref=4870dce3ebfd0e988a2e45360c724ebe912c3ad5"}]}