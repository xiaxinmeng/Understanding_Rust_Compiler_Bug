{"sha": "a8aff7e95c92bbccd4093ca71e53353912a17024", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YWZmN2U5NWM5MmJiY2NkNDA5M2NhNzFlNTMzNTM5MTJhMTcwMjQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-06T19:30:22Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:46Z"}, "message": "libserialize: use unboxed closures", "tree": {"sha": "350cbe358ec67995ca22483437104c80823d8f5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350cbe358ec67995ca22483437104c80823d8f5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8aff7e95c92bbccd4093ca71e53353912a17024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8aff7e95c92bbccd4093ca71e53353912a17024", "html_url": "https://github.com/rust-lang/rust/commit/a8aff7e95c92bbccd4093ca71e53353912a17024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8aff7e95c92bbccd4093ca71e53353912a17024/comments", "author": null, "committer": null, "parents": [{"sha": "533a47bd9bb4aebe61af8d7ff9327af8cffdb583", "url": "https://api.github.com/repos/rust-lang/rust/commits/533a47bd9bb4aebe61af8d7ff9327af8cffdb583", "html_url": "https://github.com/rust-lang/rust/commit/533a47bd9bb4aebe61af8d7ff9327af8cffdb583"}], "stats": {"total": 565, "additions": 304, "deletions": 261}, "files": [{"sha": "37bd11ba59f45b6928ef17d72ee7760de956a6c7", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 196, "deletions": 161, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=a8aff7e95c92bbccd4093ca71e53353912a17024", "patch": "@@ -458,17 +458,19 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         escape_str(self.writer, v)\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant<F>(&mut self,\n+                            name: &str,\n+                            _id: uint,\n+                            cnt: uint,\n+                            f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -483,100 +485,113 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                   name: &str,\n+                                   id: uint,\n+                                   cnt: uint,\n+                                   f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         _: &str,\n+                                         idx: uint,\n+                                         f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self,\n-                   _: &str,\n-                   _: uint,\n-                   f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n         write!(self.writer, \"}}\")\n     }\n \n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 { try!(write!(self.writer, \",\")); }\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self,\n-                      idx: uint,\n-                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct(&mut self,\n-                         _name: &str,\n-                         len: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n     fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n-    fn emit_option_some(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"[\"));\n         try!(f(self));\n         write!(self.writer, \"]\")\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n         write!(self.writer, \"}}\")\n     }\n \n-    fn emit_map_elt_key(&mut self,\n-                        idx: uint,\n-                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n+        F: FnMut(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 { try!(write!(self.writer, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n@@ -594,9 +609,9 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self,\n-                        _idx: uint,\n-                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n@@ -663,17 +678,20 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         escape_str(self.writer, v)\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant<F>(&mut self,\n+                            name: &str,\n+                            _id: uint,\n+                            cnt: uint,\n+                            f: F)\n+                            -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n@@ -697,36 +715,39 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n         try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                   name: &str,\n+                                   id: uint,\n+                                   cnt: uint,\n+                                   f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         _: &str,\n+                                         idx: uint,\n+                                         f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n-    fn emit_struct(&mut self,\n-                   _: &str,\n-                   len: uint,\n-                   f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"{{}}\")\n         } else {\n@@ -740,10 +761,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -755,40 +775,43 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple(&mut self,\n-                  len: uint,\n-                  f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self,\n-                      idx: uint,\n-                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct(&mut self,\n-                         _: &str,\n-                         len: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n     fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_seq(&mut self,\n-                len: uint,\n-                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"[]\")\n         } else {\n@@ -802,9 +825,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self,\n-                    idx: uint,\n-                    f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -814,9 +837,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map(&mut self,\n-                len: uint,\n-                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"{{}}\")\n         } else {\n@@ -830,9 +853,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self,\n-                        idx: uint,\n-                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n+        F: FnMut(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -855,9 +878,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self,\n-                        _idx: uint,\n-                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \": \"));\n         f(self)\n     }\n@@ -2052,17 +2075,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         expect!(self.pop(), String)\n     }\n \n-    fn read_enum<T>(&mut self,\n-                    name: &str,\n-                    f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Decoder, uint| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_variant(names={})\", names);\n         let name = match self.pop() {\n             Json::String(s) => s,\n@@ -2103,46 +2125,48 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+    fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Decoder, uint| -> DecodeResult<T>)\n-                                   -> DecodeResult<T> {\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_struct_variant(names={})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n \n-    fn read_enum_struct_variant_field<T>(&mut self,\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n                                          name: &str,\n                                          idx: uint,\n-                                         f: |&mut Decoder| -> DecodeResult<T>)\n-                                         -> DecodeResult<T> {\n+                                         f: F)\n+                                         -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T>(&mut self,\n-                      name: &str,\n-                      len: uint,\n-                      f: |&mut Decoder| -> DecodeResult<T>)\n-                      -> DecodeResult<T> {\n+    fn read_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = try!(f(self));\n         self.pop();\n         Ok(value)\n     }\n \n-    fn read_struct_field<T>(&mut self,\n-                            name: &str,\n-                            idx: uint,\n-                            f: |&mut Decoder| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_struct_field<T, F>(&mut self,\n+                               name: &str,\n+                               idx: uint,\n+                               f: F)\n+                               -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n@@ -2165,12 +2189,11 @@ impl ::Decoder<DecoderError> for Decoder {\n         Ok(value)\n     }\n \n-    fn read_tuple<T>(&mut self,\n-                     tuple_len: uint,\n-                     f: |&mut Decoder| -> DecodeResult<T>)\n-                     -> DecodeResult<T> {\n+    fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple()\");\n-        self.read_seq(|d, len| {\n+        self.read_seq(move |d, len| {\n             if len == tuple_len {\n                 f(d)\n             } else {\n@@ -2179,39 +2202,47 @@ impl ::Decoder<DecoderError> for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T>(&mut self,\n-                         idx: uint,\n-                         f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n-    fn read_tuple_struct<T>(&mut self,\n-                            name: &str,\n-                            len: uint,\n-                            f: |&mut Decoder| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_tuple_struct<T, F>(&mut self,\n+                               name: &str,\n+                               len: uint,\n+                               f: F)\n+                               -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(len, f)\n     }\n \n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                idx: uint,\n-                                f: |&mut Decoder| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+    fn read_tuple_struct_arg<T, F>(&mut self,\n+                                   idx: uint,\n+                                   f: F)\n+                                   -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, bool) -> DecodeResult<T>,\n+    {\n         debug!(\"read_option()\");\n         match self.pop() {\n             Json::Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_seq()\");\n         let array = try!(expect!(self.pop(), Array));\n         let len = array.len();\n@@ -2221,14 +2252,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&mut self,\n-                       idx: uint,\n-                       f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map()\");\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n@@ -2239,14 +2272,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+       F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+       F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }"}, {"sha": "390b3976562ffacbb00d3a127e76f7f8ae20a9f1", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=a8aff7e95c92bbccd4093ca71e53353912a17024", "patch": "@@ -24,6 +24,7 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n+#![feature(unboxed_closures)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "98bd2f6bc930f68ff09a4724486a35fb8dd69333", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 107, "deletions": 100, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8aff7e95c92bbccd4093ca71e53353912a17024/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=a8aff7e95c92bbccd4093ca71e53353912a17024", "patch": "@@ -39,58 +39,61 @@ pub trait Encoder<E> {\n     fn emit_str(&mut self, v: &str) -> Result<(), E>;\n \n     // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_enum_variant(&mut self,\n-                         v_name: &str,\n-                         v_id: uint,\n-                         len: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_enum_variant_arg(&mut self,\n-                             a_idx: uint,\n-                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_enum_struct_variant(&mut self,\n-                                v_name: &str,\n-                                v_id: uint,\n-                                len: uint,\n-                                f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      f_name: &str,\n-                                      f_idx: uint,\n-                                      f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_struct(&mut self,\n-                   name: &str,\n-                   len: uint,\n-                   f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_struct_field(&mut self,\n-                         f_name: &str,\n-                         f_idx: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_tuple(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_tuple_struct(&mut self,\n-                         name: &str,\n-                         len: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_tuple_struct_arg(&mut self,\n-                             f_idx: uint,\n-                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_variant<F>(&mut self, v_name: &str,\n+                            v_id: uint,\n+                            len: uint,\n+                            f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n+                                   v_id: uint,\n+                                   len: uint,\n+                                   f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         f_name: &str,\n+                                         f_idx: uint,\n+                                         f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n     // Specialized types:\n-    fn emit_option(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_option<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n     fn emit_option_none(&mut self) -> Result<(), E>;\n-    fn emit_option_some(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_option_some<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n-    fn emit_seq(&mut self, len: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n-    fn emit_map(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n }\n \n pub trait Decoder<E> {\n@@ -113,57 +116,57 @@ pub trait Decoder<E> {\n     fn read_str(&mut self) -> Result<String, E>;\n \n     // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-\n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Self, uint| -> Result<T, E>)\n-                            -> Result<T, E>;\n-    fn read_enum_variant_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> Result<T, E>)\n-                                -> Result<T, E>;\n-\n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Self, uint| -> Result<T, E>)\n-                                   -> Result<T, E>;\n-    fn read_enum_struct_variant_field<T>(&mut self,\n-                                         &f_name: &str,\n-                                         f_idx: uint,\n-                                         f: |&mut Self| -> Result<T, E>)\n-                                         -> Result<T, E>;\n-\n-    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> Result<T, E>)\n-                      -> Result<T, E>;\n-    fn read_struct_field<T>(&mut self,\n-                            f_name: &str,\n-                            f_idx: uint,\n-                            f: |&mut Self| -> Result<T, E>)\n-                            -> Result<T, E>;\n-\n-    fn read_tuple<T>(&mut self, len: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-\n-    fn read_tuple_struct<T>(&mut self,\n-                            s_name: &str,\n-                            len: uint,\n-                            f: |&mut Self| -> Result<T, E>)\n-                            -> Result<T, E>;\n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> Result<T, E>)\n-                                -> Result<T, E>;\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                            &f_name: &str,\n+                                            f_idx: uint,\n+                                            f: F)\n+                                            -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_struct_field<T, F>(&mut self,\n+                               f_name: &str,\n+                               f_idx: uint,\n+                               f: F)\n+                               -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n     // Specialized types:\n-    fn read_option<T>(&mut self, f: |&mut Self, bool| -> Result<T, E>) -> Result<T, E>;\n+    fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, bool) -> Result<T, E>;\n \n-    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n-    fn read_map<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n     // Failure\n     fn error(&mut self, err: &str) -> E;\n@@ -585,13 +588,14 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n // Helper routines\n \n pub trait EncoderHelpers<E> {\n-    fn emit_from_vec<T>(&mut self,\n-                        v: &[T],\n-                        f: |&mut Self, v: &T| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self, &T) -> Result<(), E>;\n }\n \n impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T| -> Result<(), E>) -> Result<(), E> {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), E> where\n+        F: FnMut(&mut S, &T) -> Result<(), E>,\n+    {\n         self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n                 try!(this.emit_seq_elt(i, |this| {\n@@ -604,11 +608,14 @@ impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n }\n \n pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<Vec<T>, E>;\n+    fn read_to_vec<T, F>(&mut self, f: F) -> Result<Vec<T>, E> where\n+        F: FnMut(&mut Self) -> Result<T, E>;\n }\n \n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<Vec<T>, E> {\n+    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, E> where F:\n+        FnMut(&mut D) -> Result<T, E>,\n+    {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {"}]}