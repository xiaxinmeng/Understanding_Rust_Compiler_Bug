{"sha": "ba359d8a51d106907332a90c59e1a339b1fc3656", "node_id": "C_kwDOAAsO6NoAKGJhMzU5ZDhhNTFkMTA2OTA3MzMyYTkwYzU5ZTFhMzM5YjFmYzM2NTY", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-08-03T11:30:13Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-11-09T07:13:15Z"}, "message": "Add support for custom MIR parsing", "tree": {"sha": "52bb14b4c8f4deb95971e20ab3190612a69923a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52bb14b4c8f4deb95971e20ab3190612a69923a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba359d8a51d106907332a90c59e1a339b1fc3656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba359d8a51d106907332a90c59e1a339b1fc3656", "html_url": "https://github.com/rust-lang/rust/commit/ba359d8a51d106907332a90c59e1a339b1fc3656", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba359d8a51d106907332a90c59e1a339b1fc3656/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc2504a83ca6ee8f6717dedd0721b90ffcbe1300", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2504a83ca6ee8f6717dedd0721b90ffcbe1300", "html_url": "https://github.com/rust-lang/rust/commit/bc2504a83ca6ee8f6717dedd0721b90ffcbe1300"}], "stats": {"total": 962, "additions": 921, "deletions": 41}, "files": [{"sha": "4a4887f19702f91149c053108308eaf0333c77d0", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -18,6 +18,7 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -129,6 +130,19 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+\n+    if input_body.borrow().should_skip() {\n+        debug!(\"Skipping borrowck because of injected body\");\n+        // Let's make up a borrowck result! Fun times!\n+        let result = BorrowCheckResult {\n+            concrete_opaque_types: VecMap::new(),\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+            tainted_by_errors: None,\n+        };\n+        return tcx.arena.alloc(result);\n+    }\n+\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n     let infcx ="}, {"sha": "e94e038f9283b701a2d73d2481329b772ecf4ea1", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -152,6 +152,8 @@ declare_features! (\n     (active, anonymous_lifetime_in_impl_trait, \"1.63.0\", None, None),\n     /// Allows identifying the `compiler_builtins` crate.\n     (active, compiler_builtins, \"1.13.0\", None, None),\n+    /// Allows writing custom MIR\n+    (active, custom_mir, \"1.65.0\", None, None),\n     /// Outputs useful `assert!` messages\n     (active, generic_assert, \"1.63.0\", None, None),\n     /// Allows using the `rust-intrinsic`'s \"ABI\"."}, {"sha": "dc3a74956843eb86c36f5b7e3dff6d0d33027ade", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -810,6 +810,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_def_path, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\"), DuplicatesOk),\n+    gated!(\n+        custom_mir, Normal, template!(List: r#\"dialect = \"...\", phase = \"...\"\"#),\n+        ErrorFollowing, \"the `#[custom_mir]` attribute is just used for the Rust test suite\",\n+    ),\n     rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word), WarnFollowing),"}, {"sha": "5290d5aae46cace29409d3701790972ce37b4810", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -138,6 +138,48 @@ impl MirPhase {\n             }\n         }\n     }\n+\n+    /// Parses an `MirPhase` from a pair of strings. Panics if this isn't possible for any reason.\n+    pub fn parse(dialect: String, phase: Option<String>) -> Self {\n+        match &*dialect.to_ascii_lowercase() {\n+            \"built\" => {\n+                assert!(phase.is_none(), \"Cannot specify a phase for `Built` MIR\");\n+                MirPhase::Built\n+            }\n+            \"analysis\" => Self::Analysis(AnalysisPhase::parse(phase)),\n+            \"runtime\" => Self::Runtime(RuntimePhase::parse(phase)),\n+            _ => panic!(\"Unknown MIR dialect {}\", dialect),\n+        }\n+    }\n+}\n+\n+impl AnalysisPhase {\n+    pub fn parse(phase: Option<String>) -> Self {\n+        let Some(phase) = phase else {\n+            return Self::Initial;\n+        };\n+\n+        match &*phase.to_ascii_lowercase() {\n+            \"initial\" => Self::Initial,\n+            \"post_cleanup\" | \"post-cleanup\" | \"postcleanup\" => Self::PostCleanup,\n+            _ => panic!(\"Unknown analysis phase {}\", phase),\n+        }\n+    }\n+}\n+\n+impl RuntimePhase {\n+    pub fn parse(phase: Option<String>) -> Self {\n+        let Some(phase) = phase else {\n+            return Self::Initial;\n+        };\n+\n+        match &*phase.to_ascii_lowercase() {\n+            \"initial\" => Self::Initial,\n+            \"post_cleanup\" | \"post-cleanup\" | \"postcleanup\" => Self::PostCleanup,\n+            \"optimized\" => Self::Optimized,\n+            _ => panic!(\"Unknown runtime phase {}\", phase),\n+        }\n+    }\n }\n \n impl Display for MirPhase {\n@@ -293,6 +335,13 @@ pub struct Body<'tcx> {\n     /// potentially allow things like `[u8; std::mem::size_of::<T>() * 0]` due to this.\n     pub is_polymorphic: bool,\n \n+    /// The phase at which this MIR should be \"injected\" into the compilation process.\n+    ///\n+    /// Everything that comes before this `MirPhase` should be skipped.\n+    ///\n+    /// This is only `Some` if the function that this body comes from was annotated with `rustc_custom_mir`.\n+    pub injection_phase: Option<MirPhase>,\n+\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n }\n \n@@ -339,6 +388,7 @@ impl<'tcx> Body<'tcx> {\n             span,\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n+            injection_phase: None,\n             tainted_by_errors,\n         };\n         body.is_polymorphic = body.has_non_region_param();\n@@ -366,6 +416,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n+            injection_phase: None,\n             tainted_by_errors: None,\n         };\n         body.is_polymorphic = body.has_non_region_param();\n@@ -508,6 +559,14 @@ impl<'tcx> Body<'tcx> {\n     pub fn generator_kind(&self) -> Option<GeneratorKind> {\n         self.generator.as_ref().map(|generator| generator.generator_kind)\n     }\n+\n+    #[inline]\n+    pub fn should_skip(&self) -> bool {\n+        let Some(injection_phase) = self.injection_phase else {\n+            return false;\n+        };\n+        injection_phase > self.phase\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "68d8766c9073414e507e011887a0cfd5af63785e", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,155 @@\n+//! Provides the implementation of the `custom_mir` attribute.\n+//!\n+//! Up until MIR building, this attribute has absolutely no effect. The `mir!` macro is a normal\n+//! decl macro that expands like any other, and the code goes through parsing, name resolution and\n+//! type checking like all other code. In MIR building we finally detect whether this attribute is\n+//! present, and if so we branch off into this module, which implements the attribute by\n+//! implementing a custom lowering from THIR to MIR.\n+//!\n+//! The result of this lowering is returned \"normally\" from the `mir_built` query, with the only\n+//! notable difference being that the `injected` field in the body is set. Various components of the\n+//! MIR pipeline, like borrowck and the pass manager will then consult this field (via\n+//! `body.should_skip()`) to skip the parts of the MIR pipeline that precede the MIR phase the user\n+//! specified.\n+//!\n+//! This file defines the general framework for the custom parsing. The parsing for all the\n+//! \"top-level\" constructs can be found in the `parse` submodule, while the parsing for statements,\n+//! terminators, and everything below can be found in the `parse::instruction` submodule.\n+//!\n+\n+use rustc_ast::Attribute;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    mir::*,\n+    thir::*,\n+    ty::{Ty, TyCtxt},\n+};\n+use rustc_span::Span;\n+\n+mod parse;\n+\n+pub(super) fn build_custom_mir<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    did: DefId,\n+    thir: &Thir<'tcx>,\n+    expr: ExprId,\n+    params: &IndexVec<ParamId, Param<'tcx>>,\n+    return_ty: Ty<'tcx>,\n+    return_ty_span: Span,\n+    span: Span,\n+    attr: &Attribute,\n+) -> Body<'tcx> {\n+    let mut body = Body {\n+        basic_blocks: BasicBlocks::new(IndexVec::new()),\n+        source: MirSource::item(did),\n+        phase: MirPhase::Built,\n+        source_scopes: IndexVec::new(),\n+        generator: None,\n+        local_decls: LocalDecls::new(),\n+        user_type_annotations: IndexVec::new(),\n+        arg_count: params.len(),\n+        spread_arg: None,\n+        var_debug_info: Vec::new(),\n+        span,\n+        required_consts: Vec::new(),\n+        is_polymorphic: false,\n+        tainted_by_errors: None,\n+        injection_phase: None,\n+        pass_count: 1,\n+    };\n+\n+    body.local_decls.push(LocalDecl::new(return_ty, return_ty_span));\n+    body.basic_blocks_mut().push(BasicBlockData::new(None));\n+    body.source_scopes.push(SourceScopeData {\n+        span,\n+        parent_scope: None,\n+        inlined: None,\n+        inlined_parent_scope: None,\n+        local_data: ClearCrossCrate::Clear,\n+    });\n+    body.injection_phase = Some(parse_attribute(attr));\n+\n+    let mut pctxt = ParseCtxt {\n+        tcx,\n+        thir,\n+        source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+        body: &mut body,\n+        local_map: FxHashMap::default(),\n+        block_map: FxHashMap::default(),\n+    };\n+\n+    let res = (|| {\n+        pctxt.parse_args(&params)?;\n+        pctxt.parse_body(expr)\n+    })();\n+    if let Err(err) = res {\n+        tcx.sess.diagnostic().span_fatal(\n+            err.span,\n+            format!(\"Could not parse {}, found: {:?}\", err.expected, err.item_description),\n+        )\n+    }\n+\n+    body\n+}\n+\n+fn parse_attribute(attr: &Attribute) -> MirPhase {\n+    let meta_items = attr.meta_item_list().unwrap();\n+    let mut dialect: Option<String> = None;\n+    let mut phase: Option<String> = None;\n+\n+    for nested in meta_items {\n+        let name = nested.name_or_empty();\n+        let value = nested.value_str().unwrap().as_str().to_string();\n+        match name.as_str() {\n+            \"dialect\" => {\n+                assert!(dialect.is_none());\n+                dialect = Some(value);\n+            }\n+            \"phase\" => {\n+                assert!(phase.is_none());\n+                phase = Some(value);\n+            }\n+            other => {\n+                panic!(\"Unexpected key {}\", other);\n+            }\n+        }\n+    }\n+\n+    let Some(dialect) = dialect else {\n+        assert!(phase.is_none());\n+        return MirPhase::Built;\n+    };\n+\n+    MirPhase::parse(dialect, phase)\n+}\n+\n+struct ParseCtxt<'tcx, 'body> {\n+    tcx: TyCtxt<'tcx>,\n+    thir: &'body Thir<'tcx>,\n+    source_info: SourceInfo,\n+\n+    body: &'body mut Body<'tcx>,\n+    local_map: FxHashMap<LocalVarId, Local>,\n+    block_map: FxHashMap<LocalVarId, BasicBlock>,\n+}\n+\n+struct ParseError {\n+    span: Span,\n+    item_description: String,\n+    expected: String,\n+}\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    fn expr_error(&self, expr: ExprId, expected: &'static str) -> ParseError {\n+        let expr = &self.thir[expr];\n+        ParseError {\n+            span: expr.span,\n+            item_description: format!(\"{:?}\", expr.kind),\n+            expected: expected.to_string(),\n+        }\n+    }\n+}\n+\n+type PResult<T> = Result<T, ParseError>;"}, {"sha": "52cb0a4826d071eb75801f5b2e04c3133983aa87", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,245 @@\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{mir::*, thir::*, ty::Ty};\n+use rustc_span::Span;\n+\n+use super::{PResult, ParseCtxt, ParseError};\n+\n+mod instruction;\n+\n+/// Helper macro for parsing custom MIR.\n+///\n+/// Example usage looks something like:\n+/// ```rust,ignore (incomplete example)\n+/// parse_by_kind!(\n+///     self, // : &ParseCtxt\n+///     expr_id, // what you're matching against\n+///     \"assignment\", // the thing you're trying to parse\n+///     @call(\"mir_assign\", args) => { args[0] }, // match invocations of the `mir_assign` special function\n+///     ExprKind::Assign { lhs, .. } => { lhs }, // match thir assignment expressions\n+///     // no need for fallthrough case - reasonable error is automatically generated\n+/// )\n+/// ```\n+macro_rules! parse_by_kind {\n+    (\n+        $self:ident,\n+        $expr_id:expr,\n+        $expected:literal,\n+        $(\n+            @call($name:literal, $args:ident) => $call_expr:expr,\n+        )*\n+        $(\n+            $pat:pat => $expr:expr,\n+        )*\n+    ) => {{\n+        let expr_id = $self.preparse($expr_id);\n+        let expr = &$self.thir[expr_id];\n+        match &expr.kind {\n+            $(\n+                ExprKind::Call { ty, fun: _, args: $args, .. } if {\n+                    match ty.kind() {\n+                        ty::FnDef(did, _) => {\n+                            $self.tcx.is_diagnostic_item(rustc_span::Symbol::intern($name), *did)\n+                        }\n+                        _ => false,\n+                    }\n+                } => $call_expr,\n+            )*\n+            $(\n+                $pat => $expr,\n+            )*\n+            #[allow(unreachable_patterns)]\n+            _ => return Err($self.expr_error(expr_id, $expected))\n+        }\n+    }};\n+}\n+pub(crate) use parse_by_kind;\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    /// Expressions should only ever be matched on after preparsing them. This removes extra scopes\n+    /// we don't care about.\n+    fn preparse(&self, expr_id: ExprId) -> ExprId {\n+        let expr = &self.thir[expr_id];\n+        match expr.kind {\n+            ExprKind::Scope { value, .. } => self.preparse(value),\n+            _ => expr_id,\n+        }\n+    }\n+\n+    fn statement_as_expr(&self, stmt_id: StmtId) -> PResult<ExprId> {\n+        match &self.thir[stmt_id].kind {\n+            StmtKind::Expr { expr, .. } => Ok(*expr),\n+            kind @ StmtKind::Let { pattern, .. } => {\n+                return Err(ParseError {\n+                    span: pattern.span,\n+                    item_description: format!(\"{:?}\", kind),\n+                    expected: \"expression\".to_string(),\n+                });\n+            }\n+        }\n+    }\n+\n+    pub fn parse_args(&mut self, params: &IndexVec<ParamId, Param<'tcx>>) -> PResult<()> {\n+        for param in params.iter() {\n+            let (var, span) = {\n+                let pat = param.pat.as_ref().unwrap();\n+                match &pat.kind {\n+                    PatKind::Binding { var, .. } => (*var, pat.span),\n+                    _ => {\n+                        return Err(ParseError {\n+                            span: pat.span,\n+                            item_description: format!(\"{:?}\", pat.kind),\n+                            expected: \"local\".to_string(),\n+                        });\n+                    }\n+                }\n+            };\n+            let decl = LocalDecl::new(param.ty, span);\n+            let local = self.body.local_decls.push(decl);\n+            self.local_map.insert(var, local);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Bodies are of the form:\n+    ///\n+    /// ```text\n+    /// {\n+    ///     let bb1: BasicBlock;\n+    ///     let bb2: BasicBlock;\n+    ///     {\n+    ///         let RET: _;\n+    ///         let local1;\n+    ///         let local2;\n+    ///\n+    ///         {\n+    ///             { // entry block\n+    ///                 statement1;\n+    ///                 terminator1\n+    ///             };\n+    ///\n+    ///             bb1 = {\n+    ///                 statement2;\n+    ///                 terminator2\n+    ///             };\n+    ///\n+    ///             bb2 = {\n+    ///                 statement3;\n+    ///                 terminator3\n+    ///             }\n+    ///\n+    ///             RET\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// This allows us to easily parse the basic blocks declarations, local declarations, and\n+    /// basic block definitions in order.\n+    pub fn parse_body(&mut self, expr_id: ExprId) -> PResult<()> {\n+        let body = parse_by_kind!(self, expr_id, \"whole body\",\n+            ExprKind::Block { block } => self.thir[*block].expr.unwrap(),\n+        );\n+        let (block_decls, rest) = parse_by_kind!(self, body, \"body with block decls\",\n+            ExprKind::Block { block } => {\n+                let block = &self.thir[*block];\n+                (&block.stmts, block.expr.unwrap())\n+            },\n+        );\n+        self.parse_block_decls(block_decls.iter().copied())?;\n+\n+        let (local_decls, rest) = parse_by_kind!(self, rest, \"body with local decls\",\n+            ExprKind::Block { block } => {\n+                let block = &self.thir[*block];\n+                (&block.stmts, block.expr.unwrap())\n+            },\n+        );\n+        self.parse_local_decls(local_decls.iter().copied())?;\n+\n+        let block_defs = parse_by_kind!(self, rest, \"body with block defs\",\n+            ExprKind::Block { block } => &self.thir[*block].stmts,\n+        );\n+        for (i, block_def) in block_defs.iter().enumerate() {\n+            let block = self.parse_block_def(self.statement_as_expr(*block_def)?)?;\n+            self.body.basic_blocks_mut()[BasicBlock::from_usize(i)] = block;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_block_decls(&mut self, stmts: impl Iterator<Item = StmtId>) -> PResult<()> {\n+        for stmt in stmts {\n+            let (var, _, _) = self.parse_let_statement(stmt)?;\n+            let data = BasicBlockData::new(None);\n+            let block = self.body.basic_blocks_mut().push(data);\n+            self.block_map.insert(var, block);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_local_decls(&mut self, mut stmts: impl Iterator<Item = StmtId>) -> PResult<()> {\n+        let (ret_var, ..) = self.parse_let_statement(stmts.next().unwrap())?;\n+        self.local_map.insert(ret_var, Local::from_u32(0));\n+\n+        for stmt in stmts {\n+            let (var, ty, span) = self.parse_let_statement(stmt)?;\n+            let decl = LocalDecl::new(ty, span);\n+            let local = self.body.local_decls.push(decl);\n+            self.local_map.insert(var, local);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_let_statement(&mut self, stmt_id: StmtId) -> PResult<(LocalVarId, Ty<'tcx>, Span)> {\n+        let pattern = match &self.thir[stmt_id].kind {\n+            StmtKind::Let { pattern, .. } => pattern,\n+            StmtKind::Expr { expr, .. } => {\n+                return Err(self.expr_error(*expr, \"let statement\"));\n+            }\n+        };\n+\n+        self.parse_var(pattern)\n+    }\n+\n+    fn parse_var(&mut self, mut pat: &Pat<'tcx>) -> PResult<(LocalVarId, Ty<'tcx>, Span)> {\n+        // Make sure we throw out any `AscribeUserType` we find\n+        loop {\n+            match &pat.kind {\n+                PatKind::Binding { var, ty, .. } => break Ok((*var, *ty, pat.span)),\n+                PatKind::AscribeUserType { subpattern, .. } => {\n+                    pat = subpattern;\n+                }\n+                _ => {\n+                    break Err(ParseError {\n+                        span: pat.span,\n+                        item_description: format!(\"{:?}\", pat.kind),\n+                        expected: \"local\".to_string(),\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_block_def(&self, expr_id: ExprId) -> PResult<BasicBlockData<'tcx>> {\n+        let block = parse_by_kind!(self, expr_id, \"basic block\",\n+            ExprKind::Block { block } => &self.thir[*block],\n+        );\n+\n+        let mut data = BasicBlockData::new(None);\n+        for stmt_id in &*block.stmts {\n+            let stmt = self.statement_as_expr(*stmt_id)?;\n+            let statement = self.parse_statement(stmt)?;\n+            data.statements.push(Statement { source_info: self.source_info, kind: statement });\n+        }\n+\n+        let Some(trailing) = block.expr else {\n+            return Err(self.expr_error(expr_id, \"terminator\"))\n+        };\n+        let terminator = self.parse_terminator(trailing)?;\n+        data.terminator = Some(Terminator { source_info: self.source_info, kind: terminator });\n+\n+        Ok(data)\n+    }\n+}"}, {"sha": "6d6176584f5f47d3cadcc769843afea83350679d", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,72 @@\n+use rustc_middle::{mir::*, thir::*, ty};\n+\n+use super::{parse_by_kind, PResult, ParseCtxt};\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"statement\",\n+            @call(\"mir_retag\", args) => {\n+                Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n+            },\n+            @call(\"mir_retag_raw\", args) => {\n+                Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n+            },\n+            ExprKind::Assign { lhs, rhs } => {\n+                let lhs = self.parse_place(*lhs)?;\n+                let rhs = self.parse_rvalue(*rhs)?;\n+                Ok(StatementKind::Assign(Box::new((lhs, rhs))))\n+            },\n+        )\n+    }\n+\n+    pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"terminator\",\n+            @call(\"mir_return\", _args) => {\n+                Ok(TerminatorKind::Return)\n+            },\n+            @call(\"mir_goto\", args) => {\n+                Ok(TerminatorKind::Goto { target: self.parse_block(args[0])? } )\n+            },\n+        )\n+    }\n+\n+    fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"rvalue\",\n+            ExprKind::Borrow { borrow_kind, arg } => Ok(\n+                Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n+            ),\n+            ExprKind::AddressOf { mutability, arg } => Ok(\n+                Rvalue::AddressOf(*mutability, self.parse_place(*arg)?)\n+            ),\n+            _ => self.parse_operand(expr_id).map(Rvalue::Use),\n+        )\n+    }\n+\n+    fn parse_operand(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"operand\",\n+            @call(\"mir_move\", args) => self.parse_place(args[0]).map(Operand::Move),\n+            _ => self.parse_place(expr_id).map(Operand::Copy),\n+        )\n+    }\n+\n+    fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"place\",\n+            ExprKind::Deref { arg } => Ok(\n+                self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n+            ),\n+            _ => self.parse_local(expr_id).map(Place::from),\n+        )\n+    }\n+\n+    fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n+        parse_by_kind!(self, expr_id, \"local\",\n+            ExprKind::VarRef { id } => Ok(self.local_map[id]),\n+        )\n+    }\n+\n+    fn parse_block(&self, expr_id: ExprId) -> PResult<BasicBlock> {\n+        parse_by_kind!(self, expr_id, \"basic block\",\n+            ExprKind::VarRef { id } => Ok(self.block_map[id]),\n+        )\n+    }\n+}"}, {"sha": "437ac8d82a1a3136bd38ff9d6f51b33f42884a77", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -481,6 +481,22 @@ fn construct_fn<'tcx>(\n         (None, fn_sig.output())\n     };\n \n+    if let Some(custom_mir_attr) =\n+        tcx.hir().attrs(fn_id).iter().find(|attr| attr.name_or_empty() == sym::custom_mir)\n+    {\n+        return custom::build_custom_mir(\n+            tcx,\n+            fn_def.did.to_def_id(),\n+            thir,\n+            expr,\n+            arguments,\n+            return_ty,\n+            return_ty_span,\n+            span,\n+            custom_mir_attr,\n+        );\n+    }\n+\n     let infcx = tcx.infer_ctxt().build();\n     let mut builder = Builder::new(\n         thir,\n@@ -1033,6 +1049,7 @@ pub(crate) fn parse_float_into_scalar(\n \n mod block;\n mod cfg;\n+mod custom;\n mod expr;\n mod matches;\n mod misc;"}, {"sha": "c4639d3a513dfb7e4e13a32c741e312988abe218", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -51,11 +51,17 @@ impl<'tcx> Cx<'tcx> {\n         trace!(?expr.ty);\n \n         // Now apply adjustments, if any.\n-        for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n-            trace!(?expr, ?adjustment);\n-            let span = expr.span;\n-            expr =\n-                self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n+        if self.apply_adjustments {\n+            for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n+                trace!(?expr, ?adjustment);\n+                let span = expr.span;\n+                expr = self.apply_adjustment(\n+                    hir_expr,\n+                    expr,\n+                    adjustment,\n+                    adjustment_span.unwrap_or(span),\n+                );\n+            }\n         }\n \n         trace!(?expr.ty, \"after adjustments\");"}, {"sha": "b5c4b7b137d4c28a2ea2399e6bf1d8dfad156068", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -80,22 +80,31 @@ struct Cx<'tcx> {\n     /// for the receiver.\n     adjustment_span: Option<(HirId, Span)>,\n \n+    /// False to indicate that adjustments should not be applied. Only used for `custom_mir`\n+    apply_adjustments: bool,\n+\n     /// The `DefId` of the owner of this body.\n     body_owner: DefId,\n }\n \n impl<'tcx> Cx<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n+        let did = def.did;\n+        let hir = tcx.hir();\n         Cx {\n             tcx,\n             thir: Thir::new(),\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n             rvalue_scopes: &typeck_results.rvalue_scopes,\n-            body_owner: def.did.to_def_id(),\n+            body_owner: did.to_def_id(),\n             adjustment_span: None,\n+            apply_adjustments: hir\n+                .attrs(hir.local_def_id_to_hir_id(did))\n+                .iter()\n+                .all(|attr| attr.name_or_empty() != rustc_span::sym::custom_mir),\n         }\n     }\n "}, {"sha": "e783d189137749cabfc28a12872bf7ff4ad64006", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -471,6 +471,14 @@ fn unsafety_check_result<'tcx>(\n     // `mir_built` force this.\n     let body = &tcx.mir_built(def).borrow();\n \n+    if body.should_skip() {\n+        return tcx.arena.alloc(UnsafetyCheckResult {\n+            violations: Vec::new(),\n+            used_unsafe_blocks: FxHashSet::default(),\n+            unused_unsafes: Some(Vec::new()),\n+        });\n+    }\n+\n     let param_env = tcx.param_env(def.did);\n \n     let mut checker = UnsafetyChecker::new(body, def.did, tcx, param_env);"}, {"sha": "27dbc3e22c97a58ac53b09eec34d355229906ce3", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -96,45 +96,48 @@ fn run_passes_inner<'tcx>(\n     phase_change: Option<MirPhase>,\n     validate_each: bool,\n ) {\n-    let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir;\n+    let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir & !body.should_skip();\n     let overridden_passes = &tcx.sess.opts.unstable_opts.mir_enable_passes;\n     trace!(?overridden_passes);\n \n-    for pass in passes {\n-        let name = pass.name();\n-\n-        let overridden =\n-            overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(|(_name, polarity)| {\n-                trace!(\n-                    pass = %name,\n-                    \"{} as requested by flag\",\n-                    if *polarity { \"Running\" } else { \"Not running\" },\n-                );\n-                *polarity\n-            });\n-        if !overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess)) {\n-            continue;\n+    if !body.should_skip() {\n+        for pass in passes {\n+            let name = pass.name();\n+\n+            let overridden = overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(\n+                |(_name, polarity)| {\n+                    trace!(\n+                        pass = %name,\n+                        \"{} as requested by flag\",\n+                        if *polarity { \"Running\" } else { \"Not running\" },\n+                    );\n+                    *polarity\n+                },\n+            );\n+            if !overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess)) {\n+                continue;\n+            }\n+\n+            let dump_enabled = pass.is_mir_dump_enabled();\n+\n+            if dump_enabled {\n+                dump_mir_for_pass(tcx, body, &name, false);\n+            }\n+            if validate {\n+                validate_body(tcx, body, format!(\"before pass {}\", name));\n+            }\n+\n+            pass.run_pass(tcx, body);\n+\n+            if dump_enabled {\n+                dump_mir_for_pass(tcx, body, &name, true);\n+            }\n+            if validate {\n+                validate_body(tcx, body, format!(\"after pass {}\", name));\n+            }\n+\n+            body.pass_count += 1;\n         }\n-\n-        let dump_enabled = pass.is_mir_dump_enabled();\n-\n-        if dump_enabled {\n-            dump_mir_for_pass(tcx, body, &name, false);\n-        }\n-        if validate {\n-            validate_body(tcx, body, format!(\"before pass {}\", name));\n-        }\n-\n-        pass.run_pass(tcx, body);\n-\n-        if dump_enabled {\n-            dump_mir_for_pass(tcx, body, &name, true);\n-        }\n-        if validate {\n-            validate_body(tcx, body, format!(\"after pass {}\", name));\n-        }\n-\n-        body.pass_count += 1;\n     }\n \n     if let Some(new_phase) = phase_change {"}, {"sha": "54a61483a11a326032c4dd4ddb7351d8e31cf7b9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -584,6 +584,7 @@ symbols! {\n         custom_attribute,\n         custom_derive,\n         custom_inner_attributes,\n+        custom_mir,\n         custom_test_frameworks,\n         d,\n         d32,"}, {"sha": "cec603dcb10edc8718f677f9ef5cd7d5563a2c12", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -59,6 +59,9 @@ use crate::marker::DiscriminantKind;\n use crate::marker::Tuple;\n use crate::mem;\n \n+#[cfg(not(bootstrap))]\n+pub mod mir;\n+\n // These imports are used for simplifying intra-doc links\n #[allow(unused_imports)]\n #[cfg(all(target_has_atomic = \"8\", target_has_atomic = \"32\", target_has_atomic = \"ptr\"))]"}, {"sha": "1bacdc39148a1cef5e79673cd9379366eddf98c0", "filename": "library/core/src/intrinsics/mir.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,123 @@\n+//! Rustc internal tooling for hand-writing MIR.\n+//!\n+//! If for some reasons you are not writing rustc tests and have found yourself considering using\n+//! this feature, turn back. This is *exceptionally* unstable. There is no attempt at all to make\n+//! anything work besides those things which the rustc test suite happened to need. If you make a\n+//! typo you'll probably ICE. Really, this is not the solution to your problems. Consider instead\n+//! supporting the [stable MIR project group](https://github.com/rust-lang/project-stable-mir).\n+//!\n+//! The documentation for this module describes how to use this feature. If you are interested in\n+//! hacking on the implementation, most of that documentation lives at\n+//! `rustc_mir_building/src/build/custom/mod.rs`.\n+//!\n+//! Typical usage will look like this:\n+//!\n+//! ```rust\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! pub fn simple(x: i32) -> i32 {\n+//!     mir!(\n+//!         let temp1: i32;\n+//!         let temp2: _;\n+//!\n+//!         {\n+//!             temp1 = x;\n+//!             Goto(exit)\n+//!         }\n+//!\n+//!         exit = {\n+//!             temp2 = Move(temp1);\n+//!             RET = temp2;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//! ```\n+//!\n+//! Hopefully most of this is fairly self-explanatory. Expanding on some notable details:\n+//!\n+//!  - The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n+//!    attribute only works on functions - there is no way to insert custom MIR into the middle of\n+//!    another function.\n+//!  - The `dialect` and `phase` parameters indicate which version of MIR you are inserting here.\n+//!    This will normally be the phase that corresponds to the thing you are trying to test. The\n+//!    phase can be omitted for dialects that have just one.\n+//!  - You should define your function signature like you normally would. Externally, this function\n+//!    can be called like any other function.\n+//!  - Type inference works - you don't have to spell out the type of all of your locals.\n+//!\n+//! For now, all statements and terminators are parsed from nested invocations of the special\n+//! functions provided in this module. We additionally want to (but do not yet) support more\n+//! \"normal\" Rust syntax in places where it makes sense. Also, most kinds of instructions are not\n+//! supported yet.\n+//!\n+\n+#![unstable(\n+    feature = \"custom_mir\",\n+    reason = \"MIR is an implementation detail and extremely unstable\",\n+    issue = \"none\"\n+)]\n+#![allow(unused_variables, non_snake_case, missing_debug_implementations)]\n+\n+/// Type representing basic blocks.\n+///\n+/// All terminators will have this type as a return type. It helps achieve some type safety.\n+pub struct BasicBlock;\n+\n+macro_rules! define {\n+    ($name:literal, $($sig:tt)*) => {\n+        #[rustc_diagnostic_item = $name]\n+        pub $($sig)* { panic!() }\n+    }\n+}\n+\n+define!(\"mir_return\", fn Return() -> BasicBlock);\n+define!(\"mir_goto\", fn Goto(destination: BasicBlock) -> BasicBlock);\n+define!(\"mir_retag\", fn Retag<T>(place: T));\n+define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n+define!(\"mir_move\", fn Move<T>(place: T) -> T);\n+\n+/// Convenience macro for generating custom MIR.\n+///\n+/// See the module documentation for syntax details. This macro is not magic - it only transforms\n+/// your MIR into something that is easier to parse in the compiler.\n+#[rustc_macro_transparency = \"transparent\"]\n+pub macro mir {\n+    (\n+        $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n+\n+        $entry_block:block\n+\n+        $(\n+            $block_name:ident = $block:block\n+        )*\n+    ) => {{\n+        // First, we declare all basic blocks.\n+        $(\n+            let $block_name: ::core::intrinsics::mir::BasicBlock;\n+        )*\n+\n+        {\n+            // Now all locals\n+            #[allow(non_snake_case)]\n+            let RET;\n+            $(\n+                let $local_decl $(: $local_decl_ty)? ;\n+            )*\n+\n+            {\n+                // Finally, the contents of the basic blocks\n+                $entry_block;\n+                $(\n+                    $block;\n+                )*\n+\n+                RET\n+            }\n+        }\n+    }}\n+}"}, {"sha": "4a5ddde4081e2e26e2234023cf425c221259340b", "filename": "src/test/mir-opt/building/custom/references.immut_ref.built.after.mir", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,14 @@\n+// MIR for `immut_ref` after built\n+\n+fn immut_ref(_1: &i32) -> &i32 {\n+    let mut _0: &i32;                    // return place in scope 0 at $DIR/references.rs:+0:30: +0:34\n+    let mut _2: *const i32;              // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = &raw const (*_1);           // scope 0 at $DIR/references.rs:+0:1: +0:34\n+        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+0:1: +0:34\n+        _0 = &(*_2);                     // scope 0 at $DIR/references.rs:+0:1: +0:34\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+0:1: +0:34\n+        return;                          // scope 0 at $DIR/references.rs:+0:1: +0:34\n+    }\n+}"}, {"sha": "ec8509f69d14ef69e04bb257bae38208f1c07f56", "filename": "src/test/mir-opt/building/custom/references.mut_ref.built.after.mir", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,14 @@\n+// MIR for `mut_ref` after built\n+\n+fn mut_ref(_1: &mut i32) -> &mut i32 {\n+    let mut _0: &mut i32;                // return place in scope 0 at $DIR/references.rs:+0:32: +0:40\n+    let mut _2: *mut i32;                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = &raw mut (*_1);             // scope 0 at $DIR/references.rs:+0:1: +0:40\n+        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+0:1: +0:40\n+        _0 = &mut (*_2);                 // scope 0 at $DIR/references.rs:+0:1: +0:40\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+0:1: +0:40\n+        return;                          // scope 0 at $DIR/references.rs:+0:1: +0:40\n+    }\n+}"}, {"sha": "dee85722e8656daaffc42780c5d8ef5946dc0023", "filename": "src/test/mir-opt/building/custom/references.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,43 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+use core::ptr::{addr_of, addr_of_mut};\n+\n+// EMIT_MIR references.mut_ref.built.after.mir\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub fn mut_ref(x: &mut i32) -> &mut i32 {\n+    mir!(\n+        let t: *mut i32;\n+\n+        {\n+            t = addr_of_mut!(*x);\n+            RetagRaw(t);\n+            RET = &mut *t;\n+            Retag(RET);\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR references.immut_ref.built.after.mir\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub fn immut_ref(x: &i32) -> &i32 {\n+    mir!(\n+        let t: *const i32;\n+\n+        {\n+            t = addr_of!(*x);\n+            RetagRaw(t);\n+            RET = & *t;\n+            Retag(RET);\n+            Return()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    let mut x = 5;\n+    assert_eq!(*mut_ref(&mut x), 5);\n+    assert_eq!(*immut_ref(&x), 5);\n+}"}, {"sha": "ec6dbe1d0526b7799436afe1729994cb59411936", "filename": "src/test/mir-opt/building/custom/simple_assign.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,37 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR simple_assign.simple.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn simple(x: i32) -> i32 {\n+    mir!(\n+        let temp1: i32;\n+        let temp2: _;\n+\n+        {\n+            temp1 = x;\n+            Goto(exit)\n+        }\n+\n+        exit = {\n+            temp2 = Move(temp1);\n+            RET = temp2;\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR simple_assign.simple_ref.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn simple_ref(x: &mut i32) -> &mut i32 {\n+    mir!({\n+        RET = Move(x);\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    assert_eq!(5, simple(5));\n+}"}, {"sha": "a5a2834c2e1bf14e264c968461cb41e90b65eb4e", "filename": "src/test/mir-opt/building/custom/simple_assign.simple.built.after.mir", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,18 @@\n+// MIR for `simple` after built\n+\n+fn simple(_1: i32) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/simple_assign.rs:+0:26: +0:29\n+    let mut _2: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = _1;                         // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+        goto -> bb1;                     // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+    }\n+\n+    bb1: {\n+        _3 = move _2;                    // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+        _0 = _3;                         // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+        return;                          // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+    }\n+}"}, {"sha": "6c90f0130a2e65b737af298e48d15638397d6784", "filename": "src/test/mir-opt/building/custom/simple_assign.simple_ref.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `simple_ref` after built\n+\n+fn simple_ref(_1: &mut i32) -> &mut i32 {\n+    let mut _0: &mut i32;                // return place in scope 0 at $DIR/simple_assign.rs:+0:35: +0:43\n+\n+    bb0: {\n+        _0 = move _1;                    // scope 0 at $DIR/simple_assign.rs:+0:1: +0:43\n+        return;                          // scope 0 at $DIR/simple_assign.rs:+0:1: +0:43\n+    }\n+}"}, {"sha": "0126dde2f7d4b7e0754e6ba98aa0241db8085b75", "filename": "src/test/ui/feature-gates/feature-gate-custom_mir.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.rs?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,12 @@\n+#![feature(core_intrinsics)]\n+\n+extern crate core;\n+\n+#[custom_mir(dialect = \"built\")] //~ ERROR the `#[custom_mir]` attribute is just used for the Rust test suite\n+pub fn foo(_x: i32) -> i32 {\n+    0\n+}\n+\n+fn main() {\n+    assert_eq!(2, foo(2));\n+}"}, {"sha": "3c149d30d82bd4f80aa4405a235de7fc89ffdc87", "filename": "src/test/ui/feature-gates/feature-gate-custom_mir.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba359d8a51d106907332a90c59e1a339b1fc3656/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_mir.stderr?ref=ba359d8a51d106907332a90c59e1a339b1fc3656", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: the `#[custom_mir]` attribute is just used for the Rust test suite\n+  --> $DIR/feature-gate-custom_mir.rs:5:1\n+   |\n+LL | #[custom_mir(dialect = \"built\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(custom_mir)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}