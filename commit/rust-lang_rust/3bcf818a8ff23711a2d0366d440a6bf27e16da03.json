{"sha": "3bcf818a8ff23711a2d0366d440a6bf27e16da03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2Y4MThhOGZmMjM3MTFhMmQwMzY2ZDQ0MGE2YmYyN2UxNmRhMDM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-27T00:59:53Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-27T01:13:22Z"}, "message": "Refactor `resolve_crate_relative_path` and `resolve_module_relative_path`\nto return a `NameBinding` instead of a `Def`", "tree": {"sha": "38d7776d9b589ddbc3358d8adccf34d707e9e695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38d7776d9b589ddbc3358d8adccf34d707e9e695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcf818a8ff23711a2d0366d440a6bf27e16da03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcf818a8ff23711a2d0366d440a6bf27e16da03", "html_url": "https://github.com/rust-lang/rust/commit/3bcf818a8ff23711a2d0366d440a6bf27e16da03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcf818a8ff23711a2d0366d440a6bf27e16da03/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6da115374ffd344f9bc748df36a50b55e61b4ea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6da115374ffd344f9bc748df36a50b55e61b4ea8", "html_url": "https://github.com/rust-lang/rust/commit/6da115374ffd344f9bc748df36a50b55e61b4ea8"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "535c0cc7fe1916929979f0fb2f774a91534c570f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf818a8ff23711a2d0366d440a6bf27e16da03/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf818a8ff23711a2d0366d440a6bf27e16da03/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3bcf818a8ff23711a2d0366d440a6bf27e16da03", "patch": "@@ -1683,8 +1683,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Ok(def) =>\n-                                    self.record_def(item.id, PathResolution::new(def, 0)),\n+                                Ok(binding) => {\n+                                    let def = binding.def().unwrap();\n+                                    self.record_def(item.id, PathResolution::new(def, 0));\n+                                }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n                                 Err(false) => {\n                                     resolve_error(self,\n@@ -2547,8 +2549,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mk_res = |def| PathResolution::new(def, path_depth);\n \n         if path.global {\n-            let def = self.resolve_crate_relative_path(span, segments, namespace);\n-            return def.map(mk_res);\n+            let binding = self.resolve_crate_relative_path(span, segments, namespace);\n+            return binding.map(|binding| mk_res(binding.def().unwrap()));\n         }\n \n         // Try to find a path to an item in a module.\n@@ -2584,9 +2586,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let unqualified_def = resolve_identifier_with_fallback(self, false);\n-        let def = self.resolve_module_relative_path(span, segments, namespace);\n-        match (def, unqualified_def) {\n-            (Ok(d), Some(ref ud)) if d == ud.def => {\n+        let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n+        match (qualified_binding, unqualified_def) {\n+            (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2596,7 +2598,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n \n-        def.map(mk_res)\n+        qualified_binding.map(|binding| mk_res(binding.def().unwrap()))\n     }\n \n     // Resolve a single identifier\n@@ -2707,7 +2709,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Result<Def, bool /* true if an error was reported */> {\n+                                    -> Result<&'a NameBinding<'a>,\n+                                              bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2740,7 +2743,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n-            binding.def().unwrap()\n+            binding\n         }).ok_or(false)\n     }\n \n@@ -2750,7 +2753,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Result<Def, bool /* true if an error was reported */> {\n+                                   -> Result<&'a NameBinding<'a>,\n+                                             bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2790,7 +2794,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n-            binding.def().unwrap()\n+            binding\n         }).ok_or(false)\n     }\n "}]}