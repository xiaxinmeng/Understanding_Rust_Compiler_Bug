{"sha": "5d9fd882b7ebb911daf0f21ca81f4acc599c2686", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOWZkODgyYjdlYmI5MTFkYWYwZjIxY2E4MWY0YWNjNTk5YzI2ODY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:21Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:21Z"}, "message": "Add std::iterator::order with lexical ordering functions for sequences\n\nUse Eq + Ord for lexicographical ordering of sequences.\n\nFor each of <, <=, >= or > as R, use::\n\n    [x, ..xs] R [y, ..ys]  =  if x != y { x R y } else { xs R ys }\n\nPrevious code using `a < b` and then `!(b < a)` for short-circuiting\nfails on cases such as  [1.0, 2.0] < [0.0/0.0, 3.0], where the first\nelement was effectively considered equal.", "tree": {"sha": "da9a5ac786a286381ad6b0204dea4f1cfecddc8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da9a5ac786a286381ad6b0204dea4f1cfecddc8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9fd882b7ebb911daf0f21ca81f4acc599c2686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9fd882b7ebb911daf0f21ca81f4acc599c2686", "html_url": "https://github.com/rust-lang/rust/commit/5d9fd882b7ebb911daf0f21ca81f4acc599c2686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9fd882b7ebb911daf0f21ca81f4acc599c2686/comments", "author": null, "committer": null, "parents": [{"sha": "98ec79c9576052d9fededd3b72b47d387c1c455d", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ec79c9576052d9fededd3b72b47d387c1c455d", "html_url": "https://github.com/rust-lang/rust/commit/98ec79c9576052d9fededd3b72b47d387c1c455d"}], "stats": {"total": 110, "additions": 110, "deletions": 0}, "files": [{"sha": "3d56149fdbaeb7d46a140d0f7efa1d155593f09a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5d9fd882b7ebb911daf0f21ca81f4acc599c2686/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9fd882b7ebb911daf0f21ca81f4acc599c2686/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=5d9fd882b7ebb911daf0f21ca81f4acc599c2686", "patch": "@@ -1591,6 +1591,116 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n \n+/// Functions for lexicographical ordering of sequences.\n+///\n+/// Lexicographical ordering through `<`, `<=`, `>=`, `>` requires\n+/// that the elements implement both `Eq` and `Ord`.\n+///\n+/// If two sequences are equal up until the point where one ends,\n+/// the shorter sequence compares less.\n+pub mod order {\n+    use cmp;\n+    use cmp::{TotalEq, TotalOrd, Ord, Eq};\n+    use option::{Some, None};\n+    use super::Iterator;\n+\n+    /// Compare `a` and `b` for equality using `TotalOrd`\n+    pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if !x.equals(&y) { return false },\n+            }\n+        }\n+    }\n+\n+    /// Order `a` and `b` lexicographically using `TotalOrd`\n+    pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return cmp::Equal,\n+                (None, _   ) => return cmp::Less,\n+                (_   , None) => return cmp::Greater,\n+                (Some(x), Some(y)) => match x.cmp(&y) {\n+                    cmp::Equal => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Compare `a` and `b` for equality (Using partial equality, `Eq`)\n+    pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if !x.eq(&y) { return false },\n+            }\n+        }\n+    }\n+\n+    /// Compare `a` and `b` for nonequality (Using partial equality, `Eq`)\n+    pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _) | (_, None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return true },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` < `b` lexicographically (Using partial order, `Ord`)\n+    pub fn lt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.lt(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` <= `b` lexicographically (Using partial order, `Ord`)\n+    pub fn le<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.le(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` > `b` lexicographically (Using partial order, `Ord`)\n+    pub fn gt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.gt(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` >= `b` lexicographically (Using partial order, `Ord`)\n+    pub fn ge<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.ge(&y) },\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}