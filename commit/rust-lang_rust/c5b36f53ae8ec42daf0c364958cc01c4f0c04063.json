{"sha": "c5b36f53ae8ec42daf0c364958cc01c4f0c04063", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YjM2ZjUzYWU4ZWM0MmRhZjBjMzY0OTU4Y2MwMWM0ZjBjMDQwNjM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-04T14:58:34Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T02:45:05Z"}, "message": "Normalize chain elements\n\nInstead of passing around a list of subexpressions ([`a`, `a.b`, `a.b.c`]),\nwe now use a list of chain element ([`a`, `.b`, `.c`]). This should make it\neasier to extract comments between chain elements.", "tree": {"sha": "058e0df1c47069cc801c4a19f585dc542e5a789c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/058e0df1c47069cc801c4a19f585dc542e5a789c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5b36f53ae8ec42daf0c364958cc01c4f0c04063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b36f53ae8ec42daf0c364958cc01c4f0c04063", "html_url": "https://github.com/rust-lang/rust/commit/c5b36f53ae8ec42daf0c364958cc01c4f0c04063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5b36f53ae8ec42daf0c364958cc01c4f0c04063/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ee126052659ebb5fd8c8c80e0fe371bfe9d95f", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ee126052659ebb5fd8c8c80e0fe371bfe9d95f", "html_url": "https://github.com/rust-lang/rust/commit/86ee126052659ebb5fd8c8c80e0fe371bfe9d95f"}], "stats": {"total": 144, "additions": 80, "deletions": 64}, "files": [{"sha": "ce0940362ff1a4a4e7b15fd018b500412ed9e019", "filename": "src/chains.rs", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c5b36f53ae8ec42daf0c364958cc01c4f0c04063/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b36f53ae8ec42daf0c364958cc01c4f0c04063/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c5b36f53ae8ec42daf0c364958cc01c4f0c04063", "patch": "@@ -99,61 +99,33 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n // An expression plus trailing `?`s to be formatted together.\n #[derive(Debug)]\n struct ChainItem {\n-    // FIXME: we can't use a reference here because to convert `try!` to `?` we\n-    // synthesise the AST node. However, I think we could use `Cow` and that\n-    // would remove a lot of cloning.\n-    expr: ast::Expr,\n+    kind: ChainItemKind,\n     tries: usize,\n }\n \n-impl Rewrite for ChainItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let rewrite = self.expr.rewrite(context, shape.sub_width(self.tries)?)?;\n-        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n-    }\n+// FIXME: we can't use a reference here because to convert `try!` to `?` we\n+// synthesise the AST node. However, I think we could use `Cow` and that\n+// would remove a lot of cloning.\n+#[derive(Debug)]\n+enum ChainItemKind {\n+    Parent(ast::Expr),\n+    MethodCall(\n+        ast::PathSegment,\n+        Vec<ast::GenericArg>,\n+        Vec<ptr::P<ast::Expr>>,\n+        Span,\n+    ),\n+    StructField(ast::Ident),\n+    TupleField(ast::Ident, bool),\n }\n \n-impl ChainItem {\n-    // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n-    // `.c` and any trailing `?`s.\n-    fn rewrite_postfix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let shape = shape.sub_width(self.tries)?;\n-        let mut rewrite = match self.expr.node {\n-            ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n-                let types = match segment.args {\n-                    Some(ref params) => match **params {\n-                        ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n-                        _ => &[],\n-                    },\n-                    _ => &[],\n-                };\n-                Self::rewrite_method_call(\n-                    segment.ident,\n-                    types,\n-                    expressions,\n-                    self.expr.span,\n-                    context,\n-                    shape,\n-                )?\n-            }\n-            ast::ExprKind::Field(ref nested, ref field) => {\n-                let space =\n-                    if Self::is_tup_field_access(&self.expr) && Self::is_tup_field_access(nested) {\n-                        \" \"\n-                    } else {\n-                        \"\"\n-                    };\n-                let result = format!(\"{}.{}\", space, field.name);\n-                if result.len() <= shape.width {\n-                    result\n-                } else {\n-                    return None;\n-                }\n-            }\n-            _ => unreachable!(),\n-        };\n-        rewrite.push_str(&\"?\".repeat(self.tries));\n-        Some(rewrite)\n+impl ChainItemKind {\n+    fn is_block_like(&self, context: &RewriteContext, reps: &str) -> bool {\n+        match self {\n+            ChainItemKind::Parent(ref expr) => is_block_expr(context, expr, reps),\n+            ChainItemKind::MethodCall(..) => reps.contains('\\n'),\n+            ChainItemKind::StructField(..) | ChainItemKind::TupleField(..) => false,\n+        }\n     }\n \n     fn is_tup_field_access(expr: &ast::Expr) -> bool {\n@@ -165,6 +137,50 @@ impl ChainItem {\n         }\n     }\n \n+    fn from_ast(expr: &ast::Expr) -> ChainItemKind {\n+        match expr.node {\n+            ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n+                let types = if let Some(ref generic_args) = segment.args {\n+                    if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n+                        data.args.clone()\n+                    } else {\n+                        vec![]\n+                    }\n+                } else {\n+                    vec![]\n+                };\n+                ChainItemKind::MethodCall(segment.clone(), types, expressions.clone(), expr.span)\n+            }\n+            ast::ExprKind::Field(ref nested, field) => {\n+                if Self::is_tup_field_access(expr) {\n+                    ChainItemKind::TupleField(field, Self::is_tup_field_access(nested))\n+                } else {\n+                    ChainItemKind::StructField(field)\n+                }\n+            }\n+            _ => ChainItemKind::Parent(expr.clone()),\n+        }\n+    }\n+}\n+\n+impl Rewrite for ChainItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let shape = shape.sub_width(self.tries)?;\n+        let rewrite = match self.kind {\n+            ChainItemKind::Parent(ref expr) => expr.rewrite(context, shape)?,\n+            ChainItemKind::MethodCall(ref segment, ref types, ref exprs, span) => {\n+                Self::rewrite_method_call(segment.ident, types, exprs, span, context, shape)?\n+            }\n+            ChainItemKind::StructField(ident) => format!(\".{}\", ident.name),\n+            ChainItemKind::TupleField(ident, nested) => {\n+                format!(\"{}.{}\", if nested { \" \" } else { \"\" }, ident.name)\n+            }\n+        };\n+        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n+    }\n+}\n+\n+impl ChainItem {\n     fn rewrite_method_call(\n         method_name: ast::Ident,\n         types: &[ast::GenericArg],\n@@ -206,12 +222,12 @@ impl Chain {\n         // Un-parse the expression tree into ChainItems\n         let mut children = vec![];\n         let mut sub_tries = 0;\n-        for subexpr in subexpr_list {\n+        for subexpr in &subexpr_list {\n             match subexpr.node {\n                 ast::ExprKind::Try(_) => sub_tries += 1,\n                 _ => {\n                     children.push(ChainItem {\n-                        expr: subexpr,\n+                        kind: ChainItemKind::from_ast(subexpr),\n                         tries: sub_tries,\n                     });\n                     sub_tries = 0;\n@@ -427,7 +443,7 @@ impl<'a> ChainFormatterShared<'a> {\n             // First we try to 'overflow' the last child and see if it looks better than using\n             // vertical layout.\n             if let Some(one_line_shape) = last_shape.offset_left(almost_total) {\n-                if let Some(rw) = last.rewrite_postfix(context, one_line_shape) {\n+                if let Some(rw) = last.rewrite(context, one_line_shape) {\n                     // We allow overflowing here only if both of the following conditions match:\n                     // 1. The entire chain fits in a single line except the last child.\n                     // 2. `last_child_str.lines().count() >= 5`.\n@@ -443,7 +459,7 @@ impl<'a> ChainFormatterShared<'a> {\n                         // better.\n                         let last_shape = child_shape\n                             .sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n-                        match last.rewrite_postfix(context, last_shape) {\n+                        match last.rewrite(context, last_shape) {\n                             Some(ref new_rw) if !could_fit_single_line => {\n                                 last_subexpr_str = Some(new_rw.clone());\n                             }\n@@ -464,7 +480,7 @@ impl<'a> ChainFormatterShared<'a> {\n             }\n         }\n \n-        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n+        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite(context, last_shape));\n         self.rewrites.push(last_subexpr_str?);\n         Some(())\n     }\n@@ -525,18 +541,18 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n     ) -> Option<()> {\n         let mut root_rewrite: String = parent.rewrite(context, shape)?;\n \n-        let mut root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n+        let mut root_ends_with_block = parent.kind.is_block_like(context, &root_rewrite);\n         let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n             let item = &self.shared.children[self.shared.children.len() - 1];\n             let shape = shape.offset_left(root_rewrite.len())?;\n-            match &item.rewrite_postfix(context, shape) {\n+            match &item.rewrite(context, shape) {\n                 Some(rewrite) => root_rewrite.push_str(rewrite),\n                 None => break,\n             }\n \n-            root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+            root_ends_with_block = item.kind.is_block_like(context, &root_rewrite);\n \n             self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n             if self.shared.children.is_empty() {\n@@ -560,9 +576,9 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n         for item in self.shared.children[1..].iter().rev() {\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            let rewrite = item.rewrite(context, child_shape)?;\n             self.is_block_like\n-                .push(is_block_expr(context, &item.expr, &rewrite));\n+                .push(item.kind.is_block_like(context, &rewrite));\n             self.shared.rewrites.push(rewrite);\n         }\n         Some(())\n@@ -620,18 +636,18 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n             trimmed_last_line_width(&root_rewrite)\n         };\n \n-        if !multiline || is_block_expr(context, &parent.expr, &root_rewrite) {\n+        if !multiline || parent.kind.is_block_like(context, &root_rewrite) {\n             let item = &self.shared.children[self.shared.children.len() - 1];\n             let child_shape = parent_shape\n                 .visual_indent(self.offset)\n                 .sub_width(self.offset)?;\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            let rewrite = item.rewrite(context, child_shape)?;\n             match wrap_str(rewrite, context.config.max_width(), shape) {\n                 Some(rewrite) => root_rewrite.push_str(&rewrite),\n                 None => {\n                     // We couldn't fit in at the visual indent, try the last\n                     // indent.\n-                    let rewrite = item.rewrite_postfix(context, parent_shape)?;\n+                    let rewrite = item.rewrite(context, parent_shape)?;\n                     root_rewrite.push_str(&rewrite);\n                     self.offset = 0;\n                 }\n@@ -653,7 +669,7 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n         for item in self.shared.children[1..].iter().rev() {\n-            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            let rewrite = item.rewrite(context, child_shape)?;\n             self.shared.rewrites.push(rewrite);\n         }\n         Some(())"}]}