{"sha": "a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjU2MjZhZDFiNWJjNDdjZWRkZmIwZDYwMGNmNmZkOGE2ZGFkOGM=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-02T04:31:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-08T00:25:35Z"}, "message": "String split renaming:\n* Renamed str::split -> str::split_byte\n* Renamed str::splitn -> str::splitn_byte\n* Renamed str::split_func -> str::split\n* Renamed str::split_char -> str::split_char\n* Renamed str::split_chars_iter -> str::split_char_iter\n* Added u8::is_ascii\n* Fixed the behavior of str::split_str, so that it matches split_chars\n  and split (i.e. [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n* Fixed str::split_byte and str::splitn_byte so that they handle\n  splitting UTF-8 strings on a given UTF-8/ASCII byte and also handle \"\"\n  as the others do", "tree": {"sha": "9615505c4b94fd5e84128a40b21d5917e91a75bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9615505c4b94fd5e84128a40b21d5917e91a75bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "html_url": "https://github.com/rust-lang/rust/commit/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159aebc28bdd3e7667cb269d64dee844699dc3b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/159aebc28bdd3e7667cb269d64dee844699dc3b0", "html_url": "https://github.com/rust-lang/rust/commit/159aebc28bdd3e7667cb269d64dee844699dc3b0"}], "stats": {"total": 336, "additions": 192, "deletions": 144}, "files": [{"sha": "b22a225e46baf87d01f9f9a4a065659a61797c4a", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -94,7 +94,7 @@ fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n     let p = gpg([\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n                  data]);\n     let res = \"Primary key fingerprint: \" + keyfp;\n-    for line in str::split(p.err, '\\n' as u8) {\n+    for line in str::split_byte(p.err, '\\n' as u8) {\n         if line == res {\n             ret true;\n         }"}, {"sha": "68810fcd81b6b93a959f0e8b27896a73f07081f7", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -443,7 +443,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n               none {\n                 let name =\n                     {\n-                        let os = str::split(fs::basename(output), '.' as u8);\n+                        let os = str::split_byte(\n+                                   fs::basename(output), '.' as u8);\n                         if (vec::len(os) < 2u) {\n                             sess.fatal(#fmt(\"Output file name %s doesn't\\\n                               appear to have an extension\", output));\n@@ -578,7 +579,7 @@ fn link_binary(sess: session,\n             } else { ret filename; }\n         };\n         fn rmext(filename: str) -> str {\n-            let parts = str::split(filename, '.' as u8);\n+            let parts = str::split_byte(filename, '.' as u8);\n             vec::pop(parts);\n             ret str::connect(parts, \".\");\n         }"}, {"sha": "27eb9933275029ce1e92596760fe060cf2bf663f", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -128,8 +128,8 @@ fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n            abs1, abs2);\n     let normal1 = fs::normalize(abs1);\n     let normal2 = fs::normalize(abs2);\n-    let split1 = str::split(normal1, os_fs::path_sep as u8);\n-    let split2 = str::split(normal2, os_fs::path_sep as u8);\n+    let split1 = str::split_byte(normal1, os_fs::path_sep as u8);\n+    let split2 = str::split_byte(normal2, os_fs::path_sep as u8);\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     assert len1 > 0u;"}, {"sha": "c6e44bfed05d6a2ba0c73208db2abe6ee06cbe0b", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -120,7 +120,7 @@ fn get_used_libraries(cstore: cstore) -> [str] {\n }\n \n fn add_used_link_args(cstore: cstore, args: str) {\n-    p(cstore).used_link_args += str::split(args, ' ' as u8);\n+    p(cstore).used_link_args += str::split_byte(args, ' ' as u8);\n }\n \n fn get_used_link_args(cstore: cstore) -> [str] {"}, {"sha": "375625fc79450e034f12fbd3c7ce1126c9bd3ecc", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -199,7 +199,7 @@ fn check_error_patterns(props: test_props,\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n-    for line: str in str::split(procres.stdout, '\\n' as u8) {\n+    for line: str in str::split_byte(procres.stdout, '\\n' as u8) {\n         if str::find(line, next_err_pat) > 0 {\n             #debug(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -246,7 +246,7 @@ fn check_expected_errors(expected_errors: [errors::expected_error],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line: str in str::split(procres.stdout, '\\n' as u8) {\n+    for line: str in str::split_byte(procres.stdout, '\\n' as u8) {\n         let was_expected = false;\n         vec::iteri(expected_errors) {|i, ee|\n             if !found_flags[i] {\n@@ -349,7 +349,7 @@ fn split_maybe_args(argstr: option<str>) -> [str] {\n     }\n \n     alt argstr {\n-      option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n+      option::some(s) { rm_whitespace(str::split_byte(s, ' ' as u8)) }\n       option::none { [] }\n     }\n }\n@@ -411,7 +411,7 @@ fn output_base_name(config: config, testfile: str) -> str {\n     let base = config.build_base;\n     let filename =\n         {\n-            let parts = str::split(fs::basename(testfile), '.' as u8);\n+            let parts = str::split_byte(fs::basename(testfile), '.' as u8);\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n             str::connect(parts, \".\")\n         };"}, {"sha": "16cc0fddf2b4c55383b34c962a53637085444db4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 166, "deletions": 127, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -38,10 +38,10 @@ export\n    chars,\n    substr,\n    slice,\n+   split_byte,\n+   splitn_byte,\n    split,\n-   splitn,\n    split_str,\n-   split_func,\n    split_char,\n    lines,\n    lines_any,\n@@ -63,8 +63,8 @@ export\n    map,\n    bytes_iter,\n    chars_iter,\n-   split_chars_iter,\n-   splitn_chars_iter,\n+   split_char_iter,\n+   splitn_char_iter,\n    words_iter,\n    lines_iter,\n \n@@ -397,8 +397,6 @@ fn bytes(s: str) -> [u8] unsafe {\n Function: chars\n \n Convert a string to a vector of characters\n-\n-FIXME: rename to 'chars'\n */\n fn chars(s: str) -> [char] {\n     let buf: [char] = [];\n@@ -446,108 +444,109 @@ fn slice(s: str, begin: uint, end: uint) -> str {\n     from_chars(vec::slice(chars(s), begin, end))\n }\n \n-/*\n-Function: split\n-\n-Split a string at each occurance of a given separator\n-\n-Returns:\n+// Function: split_byte\n+//\n+// Splits a string into substrings at each occurrence of a given byte\n+//\n+// The byte must be a valid UTF-8/ASCII byte\n+fn split_byte(ss: str, sep: u8) -> [str] unsafe {\n+    // still safe if we only split on an ASCII byte\n+    assert u8::is_ascii(sep);\n+\n+    let vv = [];\n+    let start = 0u, current = 0u;\n+\n+    str::bytes_iter(ss) {|cc|\n+        if sep == cc {\n+            vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n+            start = current + 1u;\n+        }\n+        current += 1u;\n+    }\n \n-A vector containing all the strings between each occurance of the separator\n+    vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n+    ret vv;\n+}\n \n-FIXME: should be renamed to split_byte\n-*/\n-fn split(s: str, sep: u8) -> [str] {\n-    let v: [str] = [];\n-    let accum: str = \"\";\n-    let ends_with_sep: bool = false;\n-    for c: u8 in s {\n-        if c == sep {\n-            v += [accum];\n-            accum = \"\";\n-            ends_with_sep = true;\n-        } else { accum += from_byte(c); ends_with_sep = false; }\n+// Function: splitn_byte\n+//\n+// Splits a string into substrings at each occurrence of a given byte\n+// up to 'count' times\n+//\n+// The byte must be a valid UTF-8/ASCII byte\n+fn splitn_byte(ss: str, sep: u8, count: uint) -> [str] unsafe {\n+    // still safe if we only split on an ASCII byte\n+    assert u8::is_ascii(sep);\n+\n+    let vv = [];\n+    let start = 0u, current = 0u, len = byte_len(ss);\n+    let splits_done = 0u;\n+\n+    while splits_done < count && current < len {\n+        if sep == ss[current] {\n+            vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n+            start = current + 1u;\n+            splits_done += 1u;\n+        }\n+        current += 1u;\n     }\n-    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n-    ret v;\n+\n+    vec::push(vv, str::unsafe::slice_bytes(ss, start, len));\n+    ret vv;\n }\n \n /*\n-Function: splitn\n-\n-Split a string at each occurance of a given separator up to count times.\n+Function: split_str\n \n-Returns:\n+Splits a string into a vector of the substrings separated by a given string\n \n-A vector containing all the strings between each occurance of the separator\n+Note that this has recently been changed.  For example:\n+>  assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n \n-FIXME: rename to 'splitn_char'\n+FIXME: Boyer-Moore variation\n */\n-fn splitn(s: str, sep: u8, count: uint) -> [str] {\n-    let v = [];\n-    let accum = \"\";\n-    let n = count;\n-    let ends_with_sep: bool = false;\n-    for c in s {\n-        if n > 0u && c == sep {\n-            n -= 1u;\n-            v += [accum];\n-            accum = \"\";\n-            ends_with_sep = true;\n-        } else { accum += from_byte(c); ends_with_sep = false; }\n-    }\n-    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n-    ret v;\n-}\n-\n-/*\n-Function: split_str\n+fn split_str(ss: str, sep: str) -> [str] unsafe {\n+    // unsafe is justified: we are splitting\n+    // UTF-8 with UTF-8, so the results will be OK\n \n-Splits a string at each occurrence of the given separator string. Empty\n-leading fields are suppressed, and empty trailing fields are preserved.\n+    let sep_len = str::byte_len(sep);\n+    assert sep_len > 0u;\n+    let vv = [];\n+    let start = 0u, start_match = 0u, current = 0u, matching = 0u;\n \n-Returns:\n+    str::bytes_iter(ss) {|cc|\n+        if sep[matching] == cc {\n+            matching += 1u;\n+        } else {\n+            start_match += 1u;\n+        }\n \n-A vector containing all the strings between each occurrence of the separator.\n+        if matching == sep_len {\n+            // found a separator\n+            // push whatever is before it, including \"\"\n+            vec::push(vv, str::unsafe::slice_bytes(ss, start, start_match));\n \n-FIXME: should behave like split and split_char:\n-         assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n-*/\n-fn split_str(s: str, sep: str) -> [str] {\n-    assert byte_len(sep) > 0u;\n-    let v: [str] = [], accum = [], sep_match = 0u, leading = true;\n-    for c: u8 in s {\n-        // Did we match the entire separator?\n-        if sep_match == byte_len(sep) {\n-            if !leading { vec::push(v, from_bytes(accum)); }\n-            accum = [];\n-            sep_match = 0u;\n+            // reset cursors and counters\n+            start = current + 1u;\n+            start_match = current + 1u;\n+            matching = 0u;\n         }\n \n-        if c == sep[sep_match] {\n-            sep_match += 1u;\n-        } else {\n-            sep_match = 0u;\n-            vec::push(accum, c);\n-            leading = false;\n-        }\n+        current += 1u;\n     }\n \n-    if vec::len(accum) > 0u { vec::push(v, from_bytes(accum)); }\n-    if sep_match == byte_len(sep) { vec::push(v, \"\"); }\n-\n-    ret v;\n+    // whether we have a \"\", or something meaningful, push it\n+    vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n+    ret vv;\n }\n \n /*\n-Function: split_func\n+Function: split\n \n-Splits a string into substrings using a function\n+Splits a string into substrings using a character function\n (unicode safe)\n-\n-FIXME: rename to 'split'\n */\n-fn split_func(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n+fn split(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n     let vv: [str] = [];\n     let accum: str = \"\";\n     let ends_with_sep: bool = false;\n@@ -573,9 +572,11 @@ fn split_func(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n Function: split_char\n \n Splits a string into a vector of the substrings separated by a given character\n+\n+FIXME: also add  splitn_char\n */\n fn split_char(ss: str, cc: char) -> [str] {\n-   split_func(ss, {|kk| kk == cc})\n+   split(ss, {|kk| kk == cc})\n }\n \n /*\n@@ -585,7 +586,7 @@ Splits a string into a vector of the substrings\n separated by LF ('\\n')\n */\n fn lines(ss: str) -> [str] {\n-    split_func(ss, {|cc| cc == '\\n'})\n+    split(ss, {|cc| cc == '\\n'})\n }\n \n /*\n@@ -605,7 +606,7 @@ Splits a string into a vector of the substrings\n separated by whitespace\n */\n fn words(ss: str) -> [str] {\n-    ret vec::filter( split_func(ss, {|cc| char::is_whitespace(cc)}),\n+    ret vec::filter( split(ss, {|cc| char::is_whitespace(cc)}),\n                      {|w| 0u < str::char_len(w)});\n }\n \n@@ -794,25 +795,25 @@ fn chars_iter(s: str, it: fn(char)) {\n }\n \n /*\n-Function: split_chars_iter\n+Function: split_char_iter\n \n Apply a function to each substring after splitting\n by character\n */\n-fn split_chars_iter(ss: str, cc: char, ff: fn(&&str)) {\n+fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n /*\n-Function: splitn_chars_iter\n+Function: splitn_char_iter\n \n Apply a function to each substring after splitting\n by character, up to nn times\n \n FIXME: make this use chars when splitn/splitn_char is fixed\n */\n-fn splitn_chars_iter(ss: str, sep: u8, count: uint, ff: fn(&&str)) {\n-   vec::iter(splitn(ss, sep, count), ff)\n+fn splitn_char_iter(ss: str, sep: u8, count: uint, ff: fn(&&str)) unsafe {\n+   vec::iter(splitn_byte(ss, sep, count), ff)\n }\n \n /*\n@@ -880,7 +881,7 @@ Returns:\n \n The index of the first occurance of `needle`, or -1 if not found.\n \n-FIXME: UTF-8?\n+FIXME: UTF-8\n */\n fn find(haystack: str, needle: str) -> int {\n     let haystack_len: int = byte_len(haystack) as int;\n@@ -960,12 +961,10 @@ Section: String properties\n Function: is_ascii\n \n Determines if a string contains only ASCII characters\n-\n-FIXME: possibly implement using char::is_ascii when it exists\n */\n fn is_ascii(s: str) -> bool {\n     let i: uint = byte_len(s);\n-    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n+    while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n@@ -997,7 +996,7 @@ Function: byte_len\n \n Returns the length in bytes of a string\n \n-FIXME: rename to 'len_bytes'?\n+FIXME: rename to 'len_bytes'\n */\n pure fn byte_len(s: str) -> uint unsafe {\n     let v: [u8] = ::unsafe::reinterpret_cast(s);\n@@ -1013,7 +1012,7 @@ Function: char_len\n \n Count the number of unicode characters in a string\n \n-FIXME: rename to 'len_chars'?\n+FIXME: rename to 'len_chars'\n */\n fn char_len(s: str) -> uint {\n     ret char_len_range(s, 0u, byte_len(s));\n@@ -1315,7 +1314,6 @@ fn reserve(&ss: str, nn: uint) {\n // These functions may create invalid UTF-8 strings and eat your baby.\n mod unsafe {\n    export\n-      // UNSAFE\n       from_bytes,\n       from_byte,\n       slice_bytes,\n@@ -1339,7 +1337,7 @@ mod unsafe {\n    unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]) }\n \n    /*\n-   Function: slice\n+   Function: slice_bytes\n \n    Takes a bytewise (not UTF-8) slice from a string.\n    Returns the substring from [`begin`..`end`).\n@@ -1374,7 +1372,6 @@ mod unsafe {\n        assert (end <= byte_len(s));\n        ret slice_bytes(s, begin, end);\n    }\n-\n }\n \n \n@@ -1418,25 +1415,39 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_split() {\n+    fn test_split_byte() {\n         fn t(s: str, c: char, u: [str]) {\n-            log(debug, \"split: \" + s);\n-            let v = split(s, c as u8);\n-            #debug(\"split to: \");\n+            log(debug, \"split_byte: \" + s);\n+            let v = split_byte(s, c as u8);\n+            #debug(\"split_byte to: \");\n             log(debug, v);\n             assert (vec::all2(v, u, { |a,b| a == b }));\n         }\n         t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n         t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n         t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+\n+        assert [\"\", \"\", \"\", \"hello\", \"there\", \"\"]\n+            == split_byte(\"...hello.there.\", '.' as u8);\n+\n+        assert [\"\"] == split_byte(\"\", 'z' as u8);\n+        assert [\"\",\"\"] == split_byte(\"z\", 'z' as u8);\n+        assert [\"ok\"] == split_byte(\"ok\", 'z' as u8);\n     }\n \n     #[test]\n-    fn test_splitn() {\n+    fn test_split_byte_2() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+            == split_byte(data, 'V' as u8);\n+    }\n+\n+    #[test]\n+    fn test_splitn_byte() {\n         fn t(s: str, c: char, n: uint, u: [str]) {\n-            log(debug, \"splitn: \" + s);\n-            let v = splitn(s, c as u8, n);\n-            #debug(\"split to: \");\n+            log(debug, \"splitn_byte: \" + s);\n+            let v = splitn_byte(s, c as u8, n);\n+            #debug(\"split_byte to: \");\n             log(debug, v);\n             #debug(\"comparing vs. \");\n             log(debug, u);\n@@ -1450,6 +1461,20 @@ mod tests {\n         t(\".hello.there\", '.', 1u, [\"\", \"hello.there\"]);\n         t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n         t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+\n+        assert [\"\"] == splitn_byte(\"\", 'z' as u8, 5u);\n+        assert [\"\",\"\"] == splitn_byte(\"z\", 'z' as u8, 5u);\n+        assert [\"ok\"] == splitn_byte(\"ok\", 'z' as u8, 5u);\n+        assert [\"z\"] == splitn_byte(\"z\", 'z' as u8, 0u);\n+        assert [\"w.x.y\"] == splitn_byte(\"w.x.y\", '.' as u8, 0u);\n+        assert [\"w\",\"x.y\"] == splitn_byte(\"w.x.y\", '.' as u8, 1u);\n+    }\n+\n+    #[test]\n+    fn test_splitn_byte_2() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+            == splitn_byte(data, 'V' as u8, 1u);\n     }\n \n     #[test]\n@@ -1459,34 +1484,48 @@ mod tests {\n             assert eq(v[i], k);\n         }\n \n-        //FIXME: should behave like split and split_char:\n-        //assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n-\n         t(\"abc::hello::there\", \"::\", 0, \"abc\");\n         t(\"abc::hello::there\", \"::\", 1, \"hello\");\n         t(\"abc::hello::there\", \"::\", 2, \"there\");\n-        t(\"::hello::there\", \"::\", 0, \"hello\");\n+        t(\"::hello::there\", \"::\", 0, \"\");\n         t(\"hello::there::\", \"::\", 2, \"\");\n-        t(\"::hello::there::\", \"::\", 2, \"\");\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 0, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\");\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 1, \"Vi\u1ec7t Nam\");\n+        t(\"::hello::there::\", \"::\", 3, \"\");\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]\n+            == split_str (data, \"\u4e2d\u534e\");\n+\n+        assert [\"\", \"XXX\", \"YYY\", \"\"]\n+            == split_str(\"zzXXXzzYYYzz\", \"zz\");\n+\n+        assert [\"zz\", \"zYYYz\"]\n+            == split_str(\"zzXXXzYYYz\", \"XXX\");\n+\n+\n+        assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n+        assert [\"\"] == split_str(\"\", \".\");\n+        assert [\"\",\"\"] == split_str(\"zz\", \"zz\");\n+        assert [\"ok\"] == split_str(\"ok\", \"z\");\n+        assert [\"\",\"z\"] == split_str(\"zzz\", \"zz\");\n+        assert [\"\",\"\",\"z\"] == split_str(\"zzzzz\", \"zz\");\n     }\n \n+\n     #[test]\n-    fn test_split_func () {\n+    fn test_split () {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-            == split_func (data, {|cc| cc == '\u534e'});\n+            == split (data, {|cc| cc == '\u534e'});\n \n         assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n-            == split_func(\"zzXXXzYYYz\", char::is_lowercase);\n+            == split(\"zzXXXzYYYz\", char::is_lowercase);\n \n         assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n-            == split_func(\"zzXXXzYYYz\", char::is_uppercase);\n+            == split(\"zzXXXzYYYz\", char::is_uppercase);\n \n-        assert [\"\",\"\"] == split_func(\"z\", {|cc| cc == 'z'});\n-        assert [\"\"] == split_func(\"\", {|cc| cc == 'z'});\n-        assert [\"ok\"] == split_func(\"ok\", {|cc| cc == 'z'});\n+        assert [\"\",\"\"] == split(\"z\", {|cc| cc == 'z'});\n+        assert [\"\"] == split(\"\", {|cc| cc == 'z'});\n+        assert [\"ok\"] == split(\"ok\", {|cc| cc == 'z'});\n     }\n \n     #[test]\n@@ -1891,12 +1930,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_split_chars_iter() {\n+    fn test_split_char_iter() {\n         let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let ii = 0;\n \n-        split_chars_iter(data, ' ') {|xx|\n+        split_char_iter(data, ' ') {|xx|\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }\n@@ -1909,12 +1948,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_splitn_chars_iter() {\n+    fn test_splitn_char_iter() {\n         let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let ii = 0;\n \n-        splitn_chars_iter(data, ' ' as u8, 2u) {|xx|\n+        splitn_char_iter(data, ' ' as u8, 2u) {|xx|\n             alt ii {\n               0 { assert \"\\nMary\" == xx; }\n               1 { assert \"had\"    == xx; }"}, {"sha": "399f565436778f597ccccb4172ae63271be6beed", "filename": "src/libcore/u8.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibcore%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibcore%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu8.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -49,6 +49,9 @@ pure fn ge(x: u8, y: u8) -> bool { ret x >= y; }\n /* Predicate: gt */\n pure fn gt(x: u8, y: u8) -> bool { ret x > y; }\n \n+/* Predicate: is_ascii */\n+pure fn is_ascii(x: u8) -> bool { ret 0u8 == x & 128u8; }\n+\n /*\n Function: range\n "}, {"sha": "ef0ff7e6b57f7b3ba9b4d02aaf38092b7c993333", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -252,12 +252,16 @@ the first element of the returned vector will be the drive letter\n followed by a colon.\n */\n fn split(p: path) -> [path] {\n-    let split1 = str::split(p, os_fs::path_sep as u8);\n+    // FIXME: use UTF-8 safe str, and/or various other string formats\n+    let split1 = str::split_byte(p, os_fs::path_sep as u8);\n     let split2 = [];\n     for s in split1 {\n-        split2 += str::split(s, os_fs::alt_path_sep as u8);\n+        split2 += str::split_byte(s, os_fs::alt_path_sep as u8);\n     }\n-    ret split2;\n+\n+    // filter out \"\"\n+    let split3 = vec::filter(split2, {|seg| \"\" != seg});\n+    ret split3;\n }\n \n /*\n@@ -270,9 +274,10 @@ path includes directory components then they are included in the filename part\n of the result pair.\n */\n fn splitext(p: path) -> (str, str) {\n+    // FIXME: use UTF-8 safe str, and/or various other string formats\n     if str::is_empty(p) { (\"\", \"\") }\n     else {\n-        let parts = str::split(p, '.' as u8);\n+        let parts = str::split_byte(p, '.' as u8);\n         if vec::len(parts) > 1u {\n             let base = str::connect(vec::init(parts), \".\");\n             let ext = \".\" + option::get(vec::last(parts));"}, {"sha": "68f8f29748a45bad68bcb206aa5fe2333249774d", "filename": "src/libstd/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -49,7 +49,8 @@ Failure:\n String must be a valid IPv4 address\n */\n fn parse_addr(ip: str) -> ip_addr {\n-    let parts = vec::map(str::split(ip, \".\"[0]), {|s| uint::from_str(s) });\n+    let parts = vec::map(str::split_byte(ip, \".\"[0]),\n+                         {|s| uint::from_str(s) });\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)"}, {"sha": "61a083f1f534764ec5e3d421c5beee8c4f8475d4", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "patch": "@@ -33,8 +33,7 @@ fn read_grid(f: io::reader) -> grid_t {\n \n     let g = vec::init_fn(10u, {|_i| vec::init_elt_mut(10u, 0 as u8) });\n     while !f.eof() {\n-        // FIXME: replace with unicode compliant call\n-        let comps = str::split(str::trim(f.read_line()), ',' as u8);\n+        let comps = str::split_byte(str::trim(f.read_line()), ',' as u8);\n         if vec::len(comps) >= 3u {\n             let row     = uint::from_str(comps[0]) as u8;\n             let col     = uint::from_str(comps[1]) as u8;"}]}