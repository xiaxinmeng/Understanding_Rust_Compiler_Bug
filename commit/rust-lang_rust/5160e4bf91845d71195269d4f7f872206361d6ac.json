{"sha": "5160e4bf91845d71195269d4f7f872206361d6ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjBlNGJmOTE4NDVkNzExOTUyNjlkNGY3Zjg3MjIwNjM2MWQ2YWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-14T14:42:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-14T14:42:39Z"}, "message": "Rollup merge of #64431 - pnkfelix:issue-63479-fnptr-is-structural-match, r=varkor\n\nfn ptr is structural match\n\nMake fn ptr always structural match, regardless of whether the formal parameter types or return type are.\n\nFix #63479.", "tree": {"sha": "fa53184209ddad058f57b457ee637ea2cfdd2e6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa53184209ddad058f57b457ee637ea2cfdd2e6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5160e4bf91845d71195269d4f7f872206361d6ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdfPxfCRBK7hj4Ov3rIwAAdHIIAGulTNX48FCrhM8vlnCQ5z2j\nY74GinKYeJfQKPpyf07lOSGntJGp+wnTZzT7aVbOWTSiSNEZscfun56s4cWAeXzA\nw83zhOnuG7yMlBpbw5bt98bLxoaT2ytA/Dr92pWlu81ijnPcgYqs8ChxhkrM9uJY\nVz+/Dra9bVtixg2t0bVNeJVWGFPL/G7fHv4SnYvW7OsZCtTPzE7byVeJ5BoHKihj\nmMiXynFRfRlIsMJEC82CghRfCD4lOziQvhvzilHjsN4VCK0nPQ/XJIWo3L6Gv3kJ\nBGtDnb/yW6lJeRNL0C+WDAoxYYTRooWe6AE9Awc/hlVN2mbgJuUkWvsWcP556+w=\n=bvrn\n-----END PGP SIGNATURE-----\n", "payload": "tree fa53184209ddad058f57b457ee637ea2cfdd2e6f\nparent 4398eb7b544ef9fe672232f7e3b36ecd68b4024f\nparent c529294535fc748f29a9e2182a56e4ef9b4ba000\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568472159 +0200\ncommitter GitHub <noreply@github.com> 1568472159 +0200\n\nRollup merge of #64431 - pnkfelix:issue-63479-fnptr-is-structural-match, r=varkor\n\nfn ptr is structural match\n\nMake fn ptr always structural match, regardless of whether the formal parameter types or return type are.\n\nFix #63479.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5160e4bf91845d71195269d4f7f872206361d6ac", "html_url": "https://github.com/rust-lang/rust/commit/5160e4bf91845d71195269d4f7f872206361d6ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5160e4bf91845d71195269d4f7f872206361d6ac/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4398eb7b544ef9fe672232f7e3b36ecd68b4024f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4398eb7b544ef9fe672232f7e3b36ecd68b4024f", "html_url": "https://github.com/rust-lang/rust/commit/4398eb7b544ef9fe672232f7e3b36ecd68b4024f"}, {"sha": "c529294535fc748f29a9e2182a56e4ef9b4ba000", "url": "https://api.github.com/repos/rust-lang/rust/commits/c529294535fc748f29a9e2182a56e4ef9b4ba000", "html_url": "https://github.com/rust-lang/rust/commit/c529294535fc748f29a9e2182a56e4ef9b4ba000"}], "stats": {"total": 179, "additions": 178, "deletions": 1}, "files": [{"sha": "4aaa5e8ee259af8da1fd94e4eba4f73e313093fe", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=5160e4bf91845d71195269d4f7f872206361d6ac", "patch": "@@ -1229,7 +1229,13 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n                 ty::RawPtr(..) => {\n                     // `#[structural_match]` ignores substructure of\n                     // `*const _`/`*mut _`, so skip super_visit_with\n-\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n                     // (But still tell caller to continue search.)\n                     return false;\n                 }"}, {"sha": "5b378fb2a5928ec8787ec87008ef029901e3f004", "filename": "src/test/ui/rfc1445/fn-ptr-is-structurally-matchable.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs?ref=5160e4bf91845d71195269d4f7f872206361d6ac", "patch": "@@ -0,0 +1,135 @@\n+// run-pass\n+\n+// This file checks that fn ptrs are considered structurally matchable.\n+// See also rust-lang/rust#63479.\n+\n+fn main() {\n+    let mut count = 0;\n+\n+    // A type which is not structurally matchable:\n+    struct NotSM;\n+\n+    // And one that is:\n+    #[derive(PartialEq, Eq)]\n+    struct SM;\n+\n+    fn trivial() {}\n+\n+    fn sm_to(_: SM) {}\n+    fn not_sm_to(_: NotSM) {}\n+    fn to_sm() -> SM { SM }\n+    fn to_not_sm() -> NotSM { NotSM }\n+\n+    // To recreate the scenario of interest in #63479, we need to add\n+    // a ref-level-of-indirection so that we descend into the type.\n+\n+    fn r_sm_to(_: &SM) {}\n+    fn r_not_sm_to(_: &NotSM) {}\n+    fn r_to_r_sm(_: &()) -> &SM { &SM }\n+    fn r_to_r_not_sm(_: &()) -> &NotSM { &NotSM }\n+\n+    #[derive(PartialEq, Eq)]\n+    struct Wrap<T>(T);\n+\n+    // In the code below, we put the match input into a local so that\n+    // we can assign it an explicit type that is an fn ptr instead of\n+    // a singleton type of the fn itself that the type inference would\n+    // otherwise assign.\n+\n+    // Check that fn() is #[structural_match]\n+    const CFN1: Wrap<fn()> = Wrap(trivial);\n+    let input: Wrap<fn()> = Wrap(trivial);\n+    match Wrap(input) {\n+        Wrap(CFN1) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] when T is too.\n+    const CFN2: Wrap<fn(SM)> = Wrap(sm_to);\n+    let input: Wrap<fn(SM)> = Wrap(sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN2) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] when T is too.\n+    const CFN3: Wrap<fn() -> SM> = Wrap(to_sm);\n+    let input: Wrap<fn() -> SM> = Wrap(to_sm);\n+    match Wrap(input) {\n+        Wrap(CFN3) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN4: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    let input: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN4) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN5: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    let input: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN5) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(&T) is #[structural_match] when T is too.\n+    const CFN6: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    let input: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN6) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> &T is #[structural_match] when T is too.\n+    const CFN7: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    let input: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    match Wrap(input) {\n+        Wrap(CFN7) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN8: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    let input: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN8) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN9: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    let input: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN9) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that a type which has fn ptrs is `#[structural_match]`.\n+    #[derive(PartialEq, Eq)]\n+    struct Foo {\n+        alpha: fn(NotSM),\n+        beta: fn() -> NotSM,\n+        gamma: fn(SM),\n+        delta: fn() -> SM,\n+    }\n+\n+    const CFOO: Foo = Foo {\n+        alpha: not_sm_to,\n+        beta: to_not_sm,\n+        gamma: sm_to,\n+        delta: to_sm,\n+    };\n+\n+    let input = Foo { alpha: not_sm_to, beta: to_not_sm, gamma: sm_to, delta: to_sm };\n+    match input {\n+        CFOO => count += 1,\n+        Foo { .. } => {}\n+    };\n+\n+    // Final count must be 10 now if all\n+    assert_eq!(count, 10);\n+}"}, {"sha": "b3c91cec580bfc777b7b41c5827a5699c549a903", "filename": "src/test/ui/rfc1445/issue-63479-match-fnptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160e4bf91845d71195269d4f7f872206361d6ac/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs?ref=5160e4bf91845d71195269d4f7f872206361d6ac", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+\n+// The actual regression test from #63479. (Including this because my\n+// first draft at fn-ptr-is-structurally-matchable.rs failed to actually\n+// cover the case this hit; I've since expanded it accordingly, but the\n+// experience left me wary of leaving this regression test out.)\n+\n+#[derive(Eq)]\n+struct A {\n+  a: i64\n+}\n+\n+impl PartialEq for A {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.a.eq(&other.a)\n+    }\n+}\n+\n+type Fn = fn(&[A]);\n+\n+fn my_fn(_args: &[A]) {\n+  println!(\"hello world\");\n+}\n+\n+const TEST: Fn = my_fn;\n+\n+struct B(Fn);\n+\n+fn main() {\n+  let s = B(my_fn);\n+  match s {\n+    B(TEST) => println!(\"matched\"),\n+    _ => panic!(\"didn't match\")\n+  };\n+}"}]}