{"sha": "ac29ca75e025a101000596f2c68318d86098cf92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjljYTc1ZTAyNWExMDEwMDA1OTZmMmM2ODMxOGQ4NjA5OGNmOTI=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-03-29T01:00:17Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-02T19:02:17Z"}, "message": "Replace adt_def with name in mir::ProjectionElem::Downcast", "tree": {"sha": "fcc94f104e5d4f8d0517be4c6cb6888ff4137d93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcc94f104e5d4f8d0517be4c6cb6888ff4137d93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac29ca75e025a101000596f2c68318d86098cf92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac29ca75e025a101000596f2c68318d86098cf92", "html_url": "https://github.com/rust-lang/rust/commit/ac29ca75e025a101000596f2c68318d86098cf92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac29ca75e025a101000596f2c68318d86098cf92/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f694222887cf31f51e68927716c25736e62f037f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f694222887cf31f51e68927716c25736e62f037f", "html_url": "https://github.com/rust-lang/rust/commit/f694222887cf31f51e68927716c25736e62f037f"}], "stats": {"total": 222, "additions": 124, "deletions": 98}, "files": [{"sha": "d051b424d9a36127d382bdab5b19372e51b15400", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -25,7 +25,7 @@ use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -772,7 +772,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n-    pub user_ty: UserTypeProjections<'tcx>,\n+    pub user_ty: UserTypeProjections,\n \n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n@@ -1805,7 +1805,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection<'tcx>>),\n+    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1939,14 +1939,14 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// `PlaceProjection` etc below.\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Projection<'tcx, B, V, T> {\n+pub struct Projection<B, V, T> {\n     pub base: B,\n-    pub elem: ProjectionElem<'tcx, V, T>,\n+    pub elem: ProjectionElem<V, T>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum ProjectionElem<'tcx, V, T> {\n+pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n     Index(V),\n@@ -1980,16 +1980,18 @@ pub enum ProjectionElem<'tcx, V, T> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(&'tcx AdtDef, VariantIdx),\n+    ///\n+    /// The included Symbol is the name of the variant, used for printing MIR.\n+    Downcast(Option<Symbol>, VariantIdx),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n+pub type PlaceProjection<'tcx> = Projection<Place<'tcx>, Local, Ty<'tcx>>;\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n // at least on 64 bit systems, `PlaceElem` should not be larger than two pointers\n static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n@@ -1998,7 +2000,7 @@ static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n-pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n+pub type ProjectionKind = ProjectionElem<(), ()>;\n \n newtype_index! {\n     pub struct Field {\n@@ -2019,7 +2021,9 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+        self.elem(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index))\n     }\n \n     pub fn index(self, index: Local) -> Place<'tcx> {\n@@ -2080,8 +2084,11 @@ impl<'tcx> Debug for Place<'tcx> {\n                 )\n             },\n             Projection(ref data) => match data.elem {\n-                ProjectionElem::Downcast(ref adt_def, index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \"({:?} as {})\", data.base, name)\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \"({:?} as variant#{:?})\", data.base, index)\n                 }\n                 ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n                 ProjectionElem::Field(field, ty) => {\n@@ -2542,36 +2549,36 @@ pub struct Constant<'tcx> {\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjections<'tcx> {\n-    pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n+pub struct UserTypeProjections {\n+    pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections<'tcx> {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections {\n         contents\n     }\n }\n \n-impl<'tcx> UserTypeProjections<'tcx> {\n+impl<'tcx> UserTypeProjections {\n     pub fn none() -> Self {\n         UserTypeProjections { contents: vec![] }\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection<'tcx>, Span)>) -> Self {\n+    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection<'tcx>, Span)> {\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection, Span)> {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n+    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n \n     pub fn push_projection(\n         mut self,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         span: Span,\n     ) -> Self {\n         self.contents.push((user_ty.clone(), span));\n@@ -2580,7 +2587,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n \n     fn map_projections(\n         mut self,\n-        mut f: impl FnMut(UserTypeProjection<'tcx>) -> UserTypeProjection<'tcx>\n+        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection\n     ) -> Self {\n         self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n         self\n@@ -2628,14 +2635,14 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjection<'tcx> {\n+pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n-    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+    pub projs: Vec<ProjectionElem<(), ()>>,\n }\n \n-impl<'tcx> Copy for ProjectionKind<'tcx> { }\n+impl Copy for ProjectionKind { }\n \n-impl<'tcx> UserTypeProjection<'tcx> {\n+impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n         self.projs.push(ProjectionElem::Index(()));\n         self\n@@ -2662,15 +2669,17 @@ impl<'tcx> UserTypeProjection<'tcx> {\n         variant_index: VariantIdx,\n         field: Field,\n     ) -> Self {\n-        self.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        self.projs.push(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index));\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n }\n \n-CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n+CloneTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n-impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n@@ -3428,7 +3437,7 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n+impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<B, V, T>\n where\n     B: TypeFoldable<'tcx>,\n     V: TypeFoldable<'tcx>,"}, {"sha": "c464d64e3365bde5c2aa0f9a3f0a8223efba7939", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        elem: &ProjectionElem<'tcx, V, T>,\n+        elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n         -> PlaceTy<'tcx>\n     where\n@@ -124,12 +124,11 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                     }\n                 }\n             }\n-            ProjectionElem::Downcast(adt_def1, index) =>\n+            ProjectionElem::Downcast(_name, index) =>\n                 match self.to_ty(tcx).sty {\n                     ty::Adt(adt_def, substs) => {\n                         assert!(adt_def.is_enum());\n                         assert!(index.as_usize() < adt_def.variants.len());\n-                        assert_eq!(adt_def, adt_def1);\n                         PlaceTy::Downcast { adt_def,\n                                             substs,\n                                             variant_index: index }"}, {"sha": "213d24cb709eef6af92357c435b631d94b080606", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -137,7 +137,7 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n@@ -205,7 +205,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n@@ -700,7 +700,7 @@ macro_rules! make_mir_visitor {\n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      _variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -777,7 +777,7 @@ macro_rules! make_mir_visitor {\n                                                     min_length: _,\n                                                     from_end: _ } => {\n                     }\n-                    ProjectionElem::Downcast(_adt_def, _variant_index) => {\n+                    ProjectionElem::Downcast(_name, _variant_index) => {\n                     }\n                 }\n             }\n@@ -851,7 +851,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection,\n             ) {\n             }\n "}, {"sha": "03936a82c71512b80cb05d982d0ea83f2773218a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -125,7 +125,7 @@ pub struct CtxtInterners<'tcx> {\n     clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n-    projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n+    projs: InternedSet<'tcx, List<ProjectionKind>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n@@ -1802,7 +1802,7 @@ nop_list_lift!{Ty<'a> => Ty<'tcx>}\n nop_list_lift!{ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift!{ProjectionKind<'a> => ProjectionKind<'tcx>}\n+nop_list_lift!{ProjectionKind => ProjectionKind}\n \n // this is the impl for `&'a InternalSubsts<'a>`\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n@@ -2261,9 +2261,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, InternalSubsts<'t\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[ProjectionKind<'lcx>]>\n-    for Interned<'tcx, List<ProjectionKind<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [ProjectionKind<'lcx>] {\n+impl<'tcx> Borrow<[ProjectionKind]>\n+    for Interned<'tcx, List<ProjectionKind>> {\n+    fn borrow<'a>(&'a self) -> &'a [ProjectionKind] {\n         &self.0[..]\n     }\n }\n@@ -2391,22 +2391,22 @@ direct_interners!('tcx,\n );\n \n macro_rules! slice_interners {\n-    ($($field:ident: $method:ident($ty:ident)),+) => (\n+    ($($field:ident: $method:ident($ty:ty)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n-            &[$ty<'tcx>],\n+            &[$ty],\n             |a, v| List::from_arena(a, v),\n             Deref::deref,\n-            |xs: &[$ty<'_>]| xs.iter().any(keep_local)) -> List<$ty<'tcx>>);)+\n-    )\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty>);)+\n+    );\n }\n \n slice_interners!(\n-    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n-    predicates: _intern_predicates(Predicate),\n-    type_list: _intern_type_list(Ty),\n-    substs: _intern_substs(Kind),\n-    clauses: _intern_clauses(Clause),\n-    goal_list: _intern_goals(Goal),\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n+    predicates: _intern_predicates(Predicate<'tcx>),\n+    type_list: _intern_type_list(Ty<'tcx>),\n+    substs: _intern_substs(Kind<'tcx>),\n+    clauses: _intern_clauses(Clause<'tcx>),\n+    goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind)\n );\n \n@@ -2774,7 +2774,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn intern_projs(self, ps: &[ProjectionKind<'tcx>]) -> &'tcx List<ProjectionKind<'tcx>> {\n+    pub fn intern_projs(self, ps: &[ProjectionKind]) -> &'tcx List<ProjectionKind> {\n         if ps.len() == 0 {\n             List::empty()\n         } else {"}, {"sha": "262dc30033472b6bc7c90b8a313d8b920a6f0d13", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -936,7 +936,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_projs(&v)"}, {"sha": "cfcbcfc2a21e30299f104223fbbaadabb39507b8", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -13,6 +13,7 @@ use rustc::mir::{\n     Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -1765,20 +1766,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place<'_>, field: Field) -> String {\n+    fn describe_field(&self, base: &Place<'tcx>, field: Field) -> String {\n         match *base {\n             Place::Base(PlaceBase::Local(local)) => {\n                 let local = &self.mir.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field)\n+                self.describe_field_from_ty(&local.ty, field, None)\n             }\n             Place::Base(PlaceBase::Static(ref static_)) =>\n-                self.describe_field_from_ty(&static_.ty, field),\n+                self.describe_field_from_ty(&static_.ty, field, None),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) =>\n-                    def.variants[variant_index].fields[field.index()].ident.to_string(),\n+                ProjectionElem::Downcast(_, variant_index) => {\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).to_ty();\n+                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                }\n                 ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field)\n+                    self.describe_field_from_ty(&field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n@@ -1790,24 +1793,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field_index`nth field of `ty`\n-    fn describe_field_from_ty(&self, ty: &ty::Ty<'_>, field: Field) -> String {\n+    fn describe_field_from_ty(\n+        &self,\n+        ty: &ty::Ty<'_>,\n+        field: Field,\n+        variant_index: Option<VariantIdx>\n+    ) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field)\n+            self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n         } else {\n             match ty.sty {\n-                ty::Adt(def, _) => if def.is_enum() {\n-                    field.index().to_string()\n-                } else {\n-                    def.non_enum_variant().fields[field.index()]\n+                ty::Adt(def, _) => {\n+                    let variant = if let Some(idx) = variant_index {\n+                        assert!(def.is_enum());\n+                        &def.variants[idx]\n+                    } else {\n+                        def.non_enum_variant()\n+                    };\n+                    variant.fields[field.index()]\n                         .ident\n                         .to_string()\n                 },\n                 ty::Tuple(_) => field.index().to_string(),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(&ty, field)\n+                    self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n-                ty::Array(ty, _) | ty::Slice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::Array(ty, _) | ty::Slice(ty) =>\n+                    self.describe_field_from_ty(&ty, field, variant_index),\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // Convert the def-id into a node-id. node-ids are only valid for\n                     // the local code in the current crate, so this returns an `Option` in case"}, {"sha": "bf9cff1e4ae03c8f65f757f579591a2da615838c", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -174,7 +174,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         &mut self,\n         _place: &Place<'tcx>,\n         _variance: &ty::Variance,\n-        _user_ty: &UserTypeProjection<'tcx>,\n+        _user_ty: &UserTypeProjection,\n         _location: Location,\n     ) {\n     }"}, {"sha": "d3941f3013c00d5699b4cdf89911c3eec7a94e26", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -667,8 +667,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             },\n-            ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n-                ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+            ProjectionElem::Downcast(maybe_name, index) => match base_ty.sty {\n+                ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n                         PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n@@ -687,14 +687,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n-                _ => PlaceTy::Ty {\n-                    ty: span_mirbug_and_err!(\n-                        self,\n-                        place,\n-                        \"can't downcast {:?} as {:?}\",\n-                        base_ty,\n-                        adt_def1\n-                    ),\n+                _ => {\n+                    let ty = if let Some(name) = maybe_name {\n+                        span_mirbug_and_err!(\n+                            self,\n+                            place,\n+                            \"can't downcast {:?} as {:?}\",\n+                            base_ty,\n+                            name\n+                        )\n+                    } else {\n+                        span_mirbug_and_err!(self, place, \"can't downcast {:?}\", base_ty)\n+                    };\n+                    PlaceTy::Ty { ty }\n                 },\n             },\n             ProjectionElem::Field(field, fty) => {\n@@ -1161,7 +1166,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {"}, {"sha": "eab131d780cdc137aa44fdec585ba825e6bac14e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        pattern_user_ty: UserTypeProjections<'tcx>,\n+        pattern_user_ty: UserTypeProjections,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -584,7 +584,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             HirId,\n             Span,\n             Ty<'tcx>,\n-            UserTypeProjections<'tcx>,\n+            UserTypeProjections,\n         ),\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n@@ -1701,7 +1701,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mode: BindingMode,\n         var_id: HirId,\n         var_ty: Ty<'tcx>,\n-        user_ty: UserTypeProjections<'tcx>,\n+        user_ty: UserTypeProjections,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,"}, {"sha": "b06022196106a43d035bbfa2865042997f9d7219", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -693,7 +693,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+        let elem = ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name), variant_index);\n         let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()"}, {"sha": "b26547c4ff77e1bf427cc2531daa64497e5136cc", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -18,8 +18,7 @@ use rustc::ty::Ty;\n pub struct AbstractOperand;\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractType;\n-pub type AbstractElem<'tcx> =\n-    ProjectionElem<'tcx, AbstractOperand, AbstractType>;\n+pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType>;\n \n pub trait Lift {\n     type Abstract;\n@@ -38,7 +37,7 @@ impl<'tcx> Lift for Ty<'tcx> {\n     fn lift(&self) -> Self::Abstract { AbstractType }\n }\n impl<'tcx> Lift for PlaceElem<'tcx> {\n-    type Abstract = AbstractElem<'tcx>;\n+    type Abstract = AbstractElem;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n             ProjectionElem::Deref =>\n@@ -56,7 +55,7 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n                     from_end,\n                 },\n             ProjectionElem::Downcast(a, u) =>\n-                ProjectionElem::Downcast(a.clone(), u.clone()),\n+                ProjectionElem::Downcast(a, u.clone()),\n         }\n     }\n }"}, {"sha": "5806a01c687cb18b323e72a8704bcc2ddfa771d7", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -148,7 +148,7 @@ pub struct MoveData<'tcx> {\n     /// particular path being moved.)\n     pub loc_map: LocationMap<SmallVec<[MoveOutIndex; 4]>>,\n     pub path_map: IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n-    pub rev_lookup: MovePathLookup<'tcx>,\n+    pub rev_lookup: MovePathLookup,\n     pub inits: IndexVec<InitIndex, Init>,\n     /// Each Location `l` is mapped to the Inits that are effects\n     /// of executing the code at `l`.\n@@ -258,7 +258,7 @@ impl Init {\n \n /// Tables mapping from a place to its MovePathIndex.\n #[derive(Debug)]\n-pub struct MovePathLookup<'tcx> {\n+pub struct MovePathLookup {\n     locals: IndexVec<Local, MovePathIndex>,\n \n     /// projections are made from a base-place and a projection\n@@ -267,7 +267,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>\n }\n \n mod builder;\n@@ -278,7 +278,7 @@ pub enum LookupResult {\n     Parent(Option<MovePathIndex>)\n }\n \n-impl<'tcx> MovePathLookup<'tcx> {\n+impl MovePathLookup {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available"}, {"sha": "fc12443c0923a7ccb660ff2778557cf13422c9b9", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n         annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n         inferred_ty: Ty<'tcx>,\n         span: Span,\n-    ) -> UserTypeProjection<'tcx> {\n+    ) -> UserTypeProjection {\n         UserTypeProjection {\n             base: annotations.push(CanonicalUserTypeAnnotation {\n                 span,\n@@ -1094,7 +1094,7 @@ CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n-    UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n+    UserTypeProjection, PatternTypeProjection<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {"}, {"sha": "4f7b59a5a9a955ab9b8fcec79e59882c64116e21", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -558,7 +558,7 @@ where\n     pub fn place_projection(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n+        proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {"}, {"sha": "ad561bcce7d0deb42347fe511e0f792c188c533a", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac29ca75e025a101000596f2c68318d86098cf92/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=ac29ca75e025a101000596f2c68318d86098cf92", "patch": "@@ -412,8 +412,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n                 let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(adt, variant_index)\n-                        );\n+                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n+                                             variant_index));\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,"}]}