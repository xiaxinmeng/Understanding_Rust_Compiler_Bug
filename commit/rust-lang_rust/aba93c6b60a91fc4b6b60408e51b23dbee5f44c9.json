{"sha": "aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYTkzYzZiNjBhOTFmYzRiNmI2MDQwOGU1MWIyM2RiZWU1ZjQ0Yzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T22:36:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-22T22:36:51Z"}, "message": "auto merge of #5966 : alexcrichton/rust/issue-3083, r=graydon\n\nCloses #3083.\r\n\r\nThis takes a similar approach to #5797 where a set is present on the `tcx` of used mutable definitions. Everything is by default warned about, and analyses must explicitly add mutable definitions to this set so they're not warned about.\r\n\r\nMost of this was pretty straightforward, although there was one caveat that I ran into when implementing it. Apparently when the old modes are used (or maybe `legacy_modes`, I'm not sure) some different code paths are taken to cause spurious warnings to be issued which shouldn't be issued. I'm not really sure how modes even worked, so I was having a lot of trouble tracking this down. I figured that because they're a legacy thing that I'd just de-mode the compiler so that the warnings wouldn't be a problem anymore (or at least for the compiler).\r\n\r\nOther than that, the entire compiler compiles without warnings of unused mutable variables. To prevent bad warnings, #5965 should be landed (which in turn is waiting on #5963) before landing this. I figured I'd stick it out for review anyway though.", "tree": {"sha": "91d5ca30a8d1809161972cffa0b69b89a22750f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91d5ca30a8d1809161972cffa0b69b89a22750f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "html_url": "https://github.com/rust-lang/rust/commit/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6dd7dc1f2e1057719179e861a5a5ae55d6a8335", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6dd7dc1f2e1057719179e861a5a5ae55d6a8335", "html_url": "https://github.com/rust-lang/rust/commit/a6dd7dc1f2e1057719179e861a5a5ae55d6a8335"}, {"sha": "c389d0b0dd2273c9f7d16917a1738509f5522491", "url": "https://api.github.com/repos/rust-lang/rust/commits/c389d0b0dd2273c9f7d16917a1738509f5522491", "html_url": "https://github.com/rust-lang/rust/commit/c389d0b0dd2273c9f7d16917a1738509f5522491"}], "stats": {"total": 385, "additions": 265, "deletions": 120}, "files": [{"sha": "27e03d2bf3103c3b9dd68bbbc565b616c28a4f6a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -121,7 +121,7 @@ fn test_with_ref() {\n #[test]\n fn test_with_mut_ref() {\n     let good = ~[1, 2, 3];\n-    let mut v = ~[1, 2];\n+    let v = ~[1, 2];\n     let c = Cell(v);\n     do c.with_mut_ref() |v| { v.push(3); }\n     let v = c.take();"}, {"sha": "70c96c9c806e4a84799981120c144b82524aa292", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -67,7 +67,7 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n-            let mut outsz : size_t = 0;\n+            let outsz : size_t = 0;\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,"}, {"sha": "8328d42c35e9a9895a3d8b3ebd0060379d17ea26", "filename": "src/libcore/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -854,7 +854,7 @@ pub mod windows {\n             while i < s.len() {\n                 if is_sep(s[i]) {\n                     let pre = s.slice(2, i).to_owned();\n-                    let mut rest = s.slice(i, s.len()).to_owned();\n+                    let rest = s.slice(i, s.len()).to_owned();\n                     return Some((pre, rest));\n                 }\n                 i += 1;"}, {"sha": "919c7bbb036d65d49bc601aec78136c617ee5f25", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -742,7 +742,7 @@ struct XorShiftState {\n impl Rng for XorShiftState {\n     fn next(&self) -> u32 {\n         let x = self.x;\n-        let mut t = x ^ (x << 11);\n+        let t = x ^ (x << 11);\n         self.x = self.y;\n         self.y = self.z;\n         self.z = self.w;"}, {"sha": "03e44e00d88311d91581608050376eaf7cc7a927", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -210,7 +210,7 @@ pub impl ReprVisitor {\n     #[inline(always)]\n     fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n-            let mut u = ReprVisitor(ptr, self.writer);\n+            let u = ReprVisitor(ptr, self.writer);\n             let v = reflect::MovePtrAdaptor(u);\n             visit_tydesc(inner, @v as @TyVisitor);\n             true\n@@ -667,7 +667,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = intrinsic::get_tydesc::<T>();\n-        let mut u = ReprVisitor(ptr, writer);\n+        let u = ReprVisitor(ptr, writer);\n         let v = reflect::MovePtrAdaptor(u);\n         visit_tydesc(tydesc, @v as @TyVisitor)\n     }"}, {"sha": "4cbc8d7056970446f75f1cdcac35392c709af885", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -402,7 +402,7 @@ fn loop_smoke_test() {\n fn idle_new_then_close() {\n     do run_in_bare_thread {\n         let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        let idle_watcher = { IdleWatcher::new(&mut loop_) };\n         idle_watcher.close();\n     }\n }"}, {"sha": "bcfe8b2cfdf9f1efeb474d45831a745a1a370939", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -393,7 +393,7 @@ fn connect_read() {\n                 let buf = vec_from_uv_buf(buf);\n                 rtdebug!(\"read cb!\");\n                 if status.is_none() {\n-                    let bytes = buf.unwrap();\n+                    let _bytes = buf.unwrap();\n                     rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n                 } else {\n                     rtdebug!(\"status after read: %s\", status.get().to_str());"}, {"sha": "d4e547de3837b6e293b8d9767c0e4827cd9c1d1d", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -206,7 +206,7 @@ impl TcpListener for UvTcpListener {\n                     let mut server_stream_watcher = server_stream_watcher;\n                     let mut loop_ = loop_from_watcher(&server_stream_watcher);\n                     let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                    let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                    let client_tcp_watcher = client_tcp_watcher.as_stream();\n                     // XXX: Need's to be surfaced in interface\n                     server_stream_watcher.accept(client_tcp_watcher);\n                     Some(~UvStream::new(client_tcp_watcher))"}, {"sha": "f9d7f4a229c4277662e13d0a71b11ed8cc70c99e", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -343,7 +343,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n         fn force_destroy(&mut self) { destroy_repr(&mut self.r, true); }\n     }\n \n-    let mut repr = ProgRepr {\n+    let repr = ProgRepr {\n         pid: pid,\n         in_fd: pipe_input.out,\n         out_file: os::fdopen(pipe_output.in),"}, {"sha": "38d68175679cad33687cccaa6cd43e27e93c5a24", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -673,7 +673,7 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n \n         for t.each_chari |j, tc| {\n \n-            let mut next = dcol[j + 1];\n+            let next = dcol[j + 1];\n \n             if sc == tc {\n                 dcol[j + 1] = current;\n@@ -909,7 +909,7 @@ impl TotalOrd for @str {\n /// Bytewise slice less than\n fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n-    let mut end = uint::min(a_len, b_len);\n+    let end = uint::min(a_len, b_len);\n \n     let mut i = 0;\n     while i < end {\n@@ -1715,7 +1715,7 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n-        let mut u = v[i];\n+        let u = v[i];\n \n         if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n             f(u as char);"}, {"sha": "d872d38a27801ef77edef90b7cc2a72f8389121a", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -575,7 +575,7 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n             };\n             assert!(!new_task.is_null());\n             // Getting killed after here would leak the task.\n-            let mut notify_chan = if opts.notify_chan.is_none() {\n+            let notify_chan = if opts.notify_chan.is_none() {\n                 None\n             } else {\n                 Some(opts.notify_chan.swap_unwrap())"}, {"sha": "ee33e2ed20bba0c936f13b07f292ea21bae5254d", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -538,7 +538,7 @@ pub mod rt {\n     pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n         // For strings, precision is the maximum characters\n         // displayed\n-        let mut unpadded = match cv.precision {\n+        let unpadded = match cv.precision {\n           CountImplied => s,\n           CountIs(max) => if (max as uint) < str::char_len(s) {\n             str::slice(s, 0, max as uint)\n@@ -596,7 +596,7 @@ pub mod rt {\n     #[deriving(Eq)]\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    pub fn pad(cv: Conv, mut s: &str, head: Option<char>, mode: PadMode,\n+    pub fn pad(cv: Conv, s: &str, head: Option<char>, mode: PadMode,\n                buf: &mut ~str) {\n         let headsize = match head { Some(_) => 1, _ => 0 };\n         let uwidth : uint = match cv.width {"}, {"sha": "e478936ff65cc746529be05461976dae357252fa", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -1755,7 +1755,7 @@ impl<T: TotalOrd> TotalOrd for @[T] {\n \n fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n-    let mut end = uint::min(a_len, b_len);\n+    let end = uint::min(a_len, b_len);\n \n     let mut i = 0;\n     while i < end {\n@@ -3897,7 +3897,7 @@ mod tests {\n \n     #[test]\n     fn reversed_mut() {\n-        let mut v2 = reversed::<int>(~[10, 20]);\n+        let v2 = reversed::<int>(~[10, 20]);\n         assert!(v2[0] == 20);\n         assert!(v2[1] == 10);\n     }"}, {"sha": "a176b0163a499253d2e7c52f2e013e7bbc0540ea", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -273,7 +273,7 @@ pub mod write {\n                 let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n                 let LLVMOptAggressive = 3 as c_int; // -O3\n \n-                let mut CodeGenOptLevel = match opts.optimize {\n+                let CodeGenOptLevel = match opts.optimize {\n                   session::No => LLVMOptNone,\n                   session::Less => LLVMOptLess,\n                   session::Default => LLVMOptDefault,\n@@ -294,7 +294,7 @@ pub mod write {\n                     return;\n                 }\n \n-                let mut FileType;\n+                let FileType;\n                 if output_type == output_type_object ||\n                        output_type == output_type_exe {\n                    FileType = lib::llvm::ObjectFile;\n@@ -820,7 +820,7 @@ pub fn link_binary(sess: Session,\n     cc_args.push(output.to_str());\n     cc_args.push(obj_filename.to_str());\n \n-    let mut lib_cmd;\n+    let lib_cmd;\n     let os = sess.targ_cfg.os;\n     if os == session::os_macos {\n         lib_cmd = ~\"-dynamiclib\";"}, {"sha": "c4f37c2170dbbf930151fbbbe11bb08ef265bac3", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -349,7 +349,7 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n                 outputs: Option<@OutputFilenames>)\n     -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n-    let mut crate = time(time_passes, ~\"parsing\",\n+    let crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n     if upto == cu_parse { return (crate, None); }\n "}, {"sha": "8515e0c6e9b7c42fec5795ee7c2ea1e442b3164e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -1341,7 +1341,7 @@ pub static metadata_encoding_version : &'static [u8] =\n \n pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n-    let mut stats = Stats {\n+    let stats = Stats {\n         inline_bytes: 0,\n         attr_bytes: 0,\n         dep_bytes: 0,"}, {"sha": "6f3075717ed86cfe321a05c3128ee02e17118fdb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -367,7 +367,18 @@ pub impl CheckLoanCtxt {\n             // are only assigned once\n         } else {\n             match cmt.mutbl {\n-                McDeclared | McInherited => { /*ok*/ }\n+                McDeclared | McInherited => {\n+                    // Ok, but if this loan is a mutable loan, then mark the\n+                    // loan path (if it exists) as being used. This is similar\n+                    // to the check performed in loan.rs in issue_loan(). This\n+                    // type of use of mutable is different from issuing a loan,\n+                    // however.\n+                    for cmt.lp.each |lp| {\n+                        for lp.node_id().each |&id| {\n+                            self.tcx().used_mut_nodes.insert(id);\n+                        }\n+                    }\n+                }\n                 McReadOnly | McImmutable => {\n                     self.bccx.span_err(\n                         ex.span,"}, {"sha": "b8e0bba6b23487f1c27976c2b2fd07c6c6218bd7", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -305,7 +305,7 @@ pub impl GatherLoanCtxt {\n                 let mcx = &mem_categorization_ctxt {\n                     tcx: self.tcx(),\n                     method_map: self.bccx.method_map};\n-                let mut cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n+                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n                 debug!(\"after autoderef, cmt=%s\", self.bccx.cmt_to_repr(cmt));\n \n                 match autoref.kind {"}, {"sha": "aedd6bb5467c5004b82087013e6d91a7ed578402", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -274,7 +274,17 @@ pub impl LoanContext {\n         if !owns_lent_data ||\n             self.bccx.is_subregion_of(self.scope_region, scope_ub)\n         {\n-            if loan_kind.is_take() && !cmt.mutbl.is_mutable() {\n+            if cmt.mutbl.is_mutable() {\n+                // If this loan is a mutable loan, then mark the loan path (if\n+                // it exists) as being used. This is similar to the check\n+                // performed in check_loans.rs in check_assignment(), but this\n+                // is for a different purpose of having the 'mut' qualifier.\n+                for cmt.lp.each |lp| {\n+                    for lp.node_id().each |&id| {\n+                        self.tcx().used_mut_nodes.insert(id);\n+                    }\n+                }\n+            } else if loan_kind.is_take() {\n                 // We do not allow non-mutable data to be \"taken\"\n                 // under any circumstances.\n                 return Err(bckerr {"}, {"sha": "8fc94cf51e2a0db2f63eb38af18f722f29b6b22a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -481,7 +481,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                   left_ty: ty::t)\n                -> Option<~[@pat]> {\n     // Sad, but I can't get rid of this easily\n-    let mut r0 = copy *raw_pat(r[0]);\n+    let r0 = copy *raw_pat(r[0]);\n     match r0 {\n         pat{id: pat_id, node: n, span: pat_span} =>\n             match n {"}, {"sha": "bda97f4f530d1f65df6e5ddf9693a3c1f4ce955a", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use driver::session::Session;\n use driver::session;\n use middle::ty;\n+use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n use core::hashmap::HashMap;\n@@ -86,6 +87,7 @@ pub enum lint {\n \n     unused_variable,\n     dead_assignment,\n+    unused_mut,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -277,6 +279,13 @@ pub fn get_lint_dict() -> LintDict {\n             desc: \"detect assignments that will never be read\",\n             default: warn\n         }),\n+\n+        (~\"unused_mut\",\n+         LintSpec {\n+            lint: unused_mut,\n+            desc: \"detect mut variables which don't need to be mutable\",\n+            default: warn\n+        }),\n     ];\n     let mut map = HashMap::new();\n     do vec::consume(v) |_, (k, v)| {\n@@ -499,6 +508,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_deprecated_mutable_fields(cx, i);\n     check_item_deprecated_drop(cx, i);\n     check_item_unused_unsafe(cx, i);\n+    check_item_unused_mut(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -954,6 +964,53 @@ fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n+fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n+    let check_pat: @fn(@ast::pat) = |p| {\n+        let mut used = false;\n+        let mut bindings = 0;\n+        do pat_util::pat_bindings(tcx.def_map, p) |_, id, _, _| {\n+            used = used || tcx.used_mut_nodes.contains(&id);\n+            bindings += 1;\n+        }\n+        if !used {\n+            let msg = if bindings == 1 {\n+                ~\"variable does not need to be mutable\"\n+            } else {\n+                ~\"variables do not need to be mutable\"\n+            };\n+            tcx.sess.span_lint(unused_mut, p.id, it.id, p.span, msg);\n+        }\n+    };\n+\n+    let visit_fn_decl: @fn(&ast::fn_decl) = |fd| {\n+        for fd.inputs.each |arg| {\n+            if arg.is_mutbl {\n+                check_pat(arg.pat);\n+            }\n+        }\n+    };\n+\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_local: |l| {\n+                if l.node.is_mutbl {\n+                    check_pat(l.node.pat);\n+                }\n+            },\n+            visit_fn: |_, fd, _, _, _| visit_fn_decl(fd),\n+            visit_ty_method: |tm| visit_fn_decl(&tm.decl),\n+            visit_struct_method: |sm| visit_fn_decl(&sm.decl),\n+            visit_trait_method: |tm| {\n+                match *tm {\n+                    ast::required(ref tm) => visit_fn_decl(&tm.decl),\n+                    ast::provided(m) => visit_fn_decl(&m.decl),\n+                }\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n+    visit::visit_item(it, (), visit);\n+}\n+\n fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n             _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);"}, {"sha": "2b36ce4ce031a7841a08521f26ed229494ca2864", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -1516,9 +1516,8 @@ fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n \n         // Initializer:\n         self.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n-        if !local.node.is_mutbl {\n-            self.check_for_reassignments_in_pat(local.node.pat);\n-        }\n+        self.check_for_reassignments_in_pat(local.node.pat,\n+                                            local.node.is_mutbl);\n       }\n       None => {\n \n@@ -1702,12 +1701,15 @@ pub impl Liveness {\n         match expr.node {\n           expr_path(_) => {\n             match *self.tcx.def_map.get(&expr.id) {\n-              def_local(nid, false) => {\n-                // Assignment to an immutable variable or argument:\n-                // only legal if there is no later assignment.\n+              def_local(nid, mutbl) => {\n+                // Assignment to an immutable variable or argument: only legal\n+                // if there is no later assignment. If this local is actually\n+                // mutable, then check for a reassignment to flag the mutability\n+                // as being used.\n                 let ln = self.live_node(expr.id, expr.span);\n                 let var = self.variable(nid, expr.span);\n-                self.check_for_reassignment(ln, var, expr.span);\n+                self.check_for_reassignment(ln, var, expr.span,\n+                                            if mutbl {Some(nid)} else {None});\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n@@ -1731,23 +1733,28 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(@self, pat: @pat) {\n-        do self.pat_bindings(pat) |ln, var, sp, _id| {\n-            self.check_for_reassignment(ln, var, sp);\n+    fn check_for_reassignments_in_pat(@self, pat: @pat, mutbl: bool) {\n+        do self.pat_bindings(pat) |ln, var, sp, id| {\n+            self.check_for_reassignment(ln, var, sp,\n+                                        if mutbl {Some(id)} else {None});\n         }\n     }\n \n     fn check_for_reassignment(@self, ln: LiveNode, var: Variable,\n-                              orig_span: span) {\n+                              orig_span: span, mutbl: Option<node_id>) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n-            self.tcx.sess.span_err(\n-                span,\n-                ~\"re-assignment of immutable variable\");\n-\n-            self.tcx.sess.span_note(\n-                orig_span,\n-                ~\"prior assignment occurs here\");\n+            match mutbl {\n+              Some(id) => { self.tcx.used_mut_nodes.insert(id); }\n+              None => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    ~\"re-assignment of immutable variable\");\n+                self.tcx.sess.span_note(\n+                    orig_span,\n+                    ~\"prior assignment occurs here\");\n+              }\n+            }\n           }\n           Some(lnk) => {\n             self.tcx.sess.span_bug("}, {"sha": "51e6860432a2e40a6568f5dc575c62bf95ee4a2b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -351,6 +351,16 @@ pub impl MutabilityCategory {\n     }\n }\n \n+pub impl loan_path {\n+    fn node_id(&self) -> Option<ast::node_id> {\n+        match *self {\n+            lp_local(id) | lp_arg(id) => Some(id),\n+            lp_deref(lp, _) | lp_comp(lp, _) => lp.node_id(),\n+            lp_self => None\n+        }\n+    }\n+}\n+\n pub impl mem_categorization_ctxt {\n     fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {"}, {"sha": "43c6a184d13924514e8d570a440c2bad07621702", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -960,7 +960,7 @@ pub impl Resolver {\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n \n-        let mut module_;\n+        let module_;\n         match reduced_graph_parent {\n             ModuleReducedGraphParent(parent_module) => {\n                 module_ = parent_module;\n@@ -1527,7 +1527,7 @@ pub impl Resolver {\n                                      block: &blk,\n                                      parent: ReducedGraphParent,\n                                      visitor: vt<ReducedGraphParent>) {\n-        let mut new_parent;\n+        let new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n \n@@ -2427,7 +2427,7 @@ pub impl Resolver {\n \n         let merge_import_resolution = |ident,\n                                        name_bindings: @mut NameBindings| {\n-            let mut dest_import_resolution;\n+            let dest_import_resolution;\n             match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n@@ -2583,8 +2583,8 @@ pub impl Resolver {\n         let module_prefix_result = self.resolve_module_prefix(module_,\n                                                               module_path);\n \n-        let mut search_module;\n-        let mut start_index;\n+        let search_module;\n+        let start_index;\n         match module_prefix_result {\n             Failed => {\n                 self.session.span_err(span, ~\"unresolved name\");\n@@ -3221,7 +3221,7 @@ pub impl Resolver {\n                 allow_capturing_self: AllowCapturingSelfFlag)\n              -> Option<def_like> {\n         let mut def;\n-        let mut is_ty_param;\n+        let is_ty_param;\n \n         match def_like {\n             dl_def(d @ def_local(*)) | dl_def(d @ def_upvar(*)) |\n@@ -4530,7 +4530,7 @@ pub impl Resolver {\n                                  -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n-        let mut containing_module;\n+        let containing_module;\n         match self.resolve_module_path_for_import(self.current_module,\n                                                   module_path_idents,\n                                                   UseLexicalScope,\n@@ -4578,7 +4578,7 @@ pub impl Resolver {\n \n         let root_module = self.graph_root.get_module();\n \n-        let mut containing_module;\n+        let containing_module;\n         match self.resolve_module_path_from_root(root_module,\n                                                  module_path_idents,\n                                                  0,\n@@ -4622,7 +4622,7 @@ pub impl Resolver {\n                                         span: span)\n                                      -> Option<def> {\n         // Check the local set of ribs.\n-        let mut search_result;\n+        let search_result;\n         match namespace {\n             ValueNS => {\n                 search_result = self.search_ribs(&mut self.value_ribs, ident,"}, {"sha": "dc59fcecb5a1e06bc31013152e8253f9870fd0b8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -248,7 +248,7 @@ pub enum opt_result {\n pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n+    let bcx = bcx;\n     match *o {\n         lit(ExprLit(lit_expr)) => {\n             let datumblock = expr::trans_to_datum(bcx, lit_expr);"}, {"sha": "7a174be1e57242361d939aba4e512778639bc820", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -292,7 +292,7 @@ pub fn trans_fn_ref_with_vtables(\n     }\n \n     // Find the actual function pointer.\n-    let mut val = {\n+    let val = {\n         if def_id.crate == ast::local_crate {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n@@ -415,7 +415,7 @@ pub fn trans_lang_call_with_type_params(bcx: block,\n                                                     type_params,\n                                                     None,\n                                                     fty);\n-                    let mut llfnty = type_of::type_of(callee.bcx.ccx(),\n+                    let llfnty = type_of::type_of(callee.bcx.ccx(),\n                                                       substituted);\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n@@ -712,7 +712,7 @@ pub fn trans_arg_expr(bcx: block,\n         }\n     };\n     let mut arg_datum = arg_datumblock.datum;\n-    let mut bcx = arg_datumblock.bcx;\n+    let bcx = arg_datumblock.bcx;\n \n     debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n "}, {"sha": "4fc4cae464dab65acc9c5bc89d6672732faca178", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -261,7 +261,7 @@ pub fn build_closure(bcx0: block,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n-    let mut bcx = bcx0;;\n+    let bcx = bcx0;;\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars"}, {"sha": "8727db27fff0b52f3285535fc054f2b25c7a6884", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -192,7 +192,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         Some(&@AutoAddEnv(*)) => {\n             let mut bcx = bcx;\n-            let mut datum = unpack_datum!(bcx, {\n+            let datum = unpack_datum!(bcx, {\n                 trans_to_datum_unadjusted(bcx, expr)\n             });\n             add_env(bcx, expr, datum)\n@@ -1187,7 +1187,7 @@ fn trans_rec_or_struct(bcx: block,\n                        dest: Dest) -> block\n {\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n-    let mut bcx = bcx;\n+    let bcx = bcx;\n \n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n@@ -1505,7 +1505,7 @@ fn trans_lazy_binop(bcx: block,\n                     b: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n-    let mut bcx = bcx;\n+    let bcx = bcx;\n \n     let Result {bcx: past_lhs, val: lhs} = {\n         do base::with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {"}, {"sha": "cb15a2e8c644a852400e9ff1ac0de0be5da2fc22", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -567,7 +567,8 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+    let mut bcx = top_scope_block(fcx, None);\n+    let lltop = bcx.llbb;\n     match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n             let old = AtomicCmpXchg(bcx,"}, {"sha": "052bea1b022c5122d303871c6bb65e0a7f1a943e", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -102,7 +102,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n-    let mut llitem_ty = tpt.ty;\n+    let llitem_ty = tpt.ty;\n \n     let map_node = session::expect(ccx.sess, ccx.tcx.items.find(&fn_id.node),\n      || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\"}, {"sha": "7cdd7c8a6f278e8ec0bf4b88ea1c9079ee5bf855", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -304,6 +304,11 @@ struct ctxt_ {\n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n     used_unsafe: @mut HashSet<ast::node_id>,\n+\n+    // Set of nodes which mark locals as mutable which end up getting used at\n+    // some point. Local variable definitions not in this set can be warned\n+    // about.\n+    used_mut_nodes: @mut HashSet<ast::node_id>,\n }\n \n pub enum tbox_flag {\n@@ -933,6 +938,7 @@ pub fn mk_ctxt(s: session::Session,\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n+        used_mut_nodes: @mut HashSet::new(),\n      }\n }\n "}, {"sha": "e778986b2d1c3c5337d11a3d80653d232bed18c9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -180,7 +180,7 @@ pub struct Candidate {\n \n pub impl<'self> LookupContext<'self> {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n-        let mut self_ty = structurally_resolved_type(self.fcx,\n+        let self_ty = structurally_resolved_type(self.fcx,\n                                                      self.self_expr.span,\n                                                      self_ty);\n "}, {"sha": "ca9b3602d5d370782e6b018b0c1ad6b48dea72ee", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -1625,7 +1625,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // block syntax lambdas; that is, lambdas without explicit\n         // sigils.\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n-        let mut error_happened = false;\n+        let error_happened = false;\n         let (expected_sig,\n              expected_purity,\n              expected_sigil,\n@@ -1706,7 +1706,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    field: ast::ident,\n                    tys: &[@ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n-        let mut bot = check_expr(fcx, base);\n+        let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n@@ -2867,7 +2867,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n }\n \n pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n-    let mut node_id;\n+    let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n     match stmt.node {\n@@ -3124,7 +3124,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);\n \n     // Check that it is possible to represent this enum:\n-    let mut outer = true, did = local_def(id);\n+    let mut outer = true;\n+    let did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, |sty| {\n         match *sty {\n           ty::ty_enum(id, _) if id == did => {"}, {"sha": "ad173c6956060fdbc5cb05577fcbe7101f093d62", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use middle::resolve::Impl;\n-use middle::ty::{param_ty};\n+use middle::ty::param_ty;\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};"}, {"sha": "869825e607e56413260075f8db5ec79f8e1fed48", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -158,7 +158,7 @@ impl MethodRscope {\n                variance: Option<ty::region_variance>,\n                rcvr_generics: &ast::Generics)\n             -> MethodRscope {\n-        let mut region_param_names =\n+        let region_param_names =\n             RegionParamNames::from_generics(rcvr_generics);\n         MethodRscope {\n             self_ty: self_ty,"}, {"sha": "d1f6bf982a7ffe82163c3747d30767470a53c31c", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -891,7 +891,7 @@ mod tests {\n     #[test]\n     fn test_0_elements() {\n         let mut act;\n-        let mut exp;\n+        let exp;\n         act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n         assert!(act.eq_vec(exp));"}, {"sha": "b120e40ec25ca6ee8c4bc66662cb217b80129e29", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -113,7 +113,7 @@ pub impl<T> Deque<T> {\n     ///\n     /// Fails if the deque is empty\n     fn pop_front(&mut self) -> T {\n-        let mut result = self.elts[self.lo].swap_unwrap();\n+        let result = self.elts[self.lo].swap_unwrap();\n         self.lo = (self.lo + 1u) % self.elts.len();\n         self.nelts -= 1u;\n         result\n@@ -126,7 +126,7 @@ pub impl<T> Deque<T> {\n         if self.hi == 0u {\n             self.hi = self.elts.len() - 1u;\n         } else { self.hi -= 1u; }\n-        let mut result = self.elts[self.hi].swap_unwrap();\n+        let result = self.elts[self.hi].swap_unwrap();\n         self.elts[self.hi] = None;\n         self.nelts -= 1u;\n         result\n@@ -204,7 +204,7 @@ pub impl<T> Deque<T> {\n     ///\n     /// Fails if the deque is empty\n     fn pop_front(&mut self) -> T {\n-        let mut result = self.elts[self.lo].swap_unwrap();\n+        let result = self.elts[self.lo].swap_unwrap();\n         self.lo = (self.lo + 1u) % self.elts.len();\n         self.nelts -= 1u;\n         result\n@@ -217,7 +217,7 @@ pub impl<T> Deque<T> {\n         if self.hi == 0u {\n             self.hi = self.elts.len() - 1u;\n         } else { self.hi -= 1u; }\n-        let mut result = self.elts[self.hi].swap_unwrap();\n+        let result = self.elts[self.hi].swap_unwrap();\n         self.elts[self.hi] = None;\n         self.nelts -= 1u;\n         result"}, {"sha": "e736273a5eed13ee63a4f1244fc653301f823da6", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -220,7 +220,7 @@ pub impl<T> DList<T> {\n      * node. O(1).\n      */\n     fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let mut nobe = DList::new_link(data);\n+        let nobe = DList::new_link(data);\n         self.add_head(nobe);\n         nobe.get()\n     }\n@@ -233,7 +233,7 @@ pub impl<T> DList<T> {\n      * node. O(1).\n      */\n     fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let mut nobe = DList::new_link(data);\n+        let nobe = DList::new_link(data);\n         self.add_tail(nobe);\n         nobe.get()\n     }\n@@ -263,7 +263,7 @@ pub impl<T> DList<T> {\n         data: T,\n         neighbour: @mut DListNode<T>\n     ) -> @mut DListNode<T> {\n-        let mut nobe = DList::new_link(data);\n+        let nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n         nobe.get()\n     }\n@@ -293,7 +293,7 @@ pub impl<T> DList<T> {\n         data: T,\n         neighbour: @mut DListNode<T>\n     ) -> @mut DListNode<T> {\n-        let mut nobe = DList::new_link(data);\n+        let nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n         nobe.get()\n     }"}, {"sha": "36652380bff5893dc7ad9d0896660480543fc617", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -60,7 +60,7 @@ impl<T: Copy + Num + Ord>\n \n     /// Put self into lowest terms, with denom > 0.\n     fn reduce(&mut self) {\n-        let mut g : T = gcd(self.numer, self.denom);\n+        let g : T = gcd(self.numer, self.denom);\n \n         self.numer /= g;\n         self.denom /= g;\n@@ -505,4 +505,4 @@ mod test {\n             test(s);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "33bc393e4703a6dff9a6cac46d575301e6b8e0f2", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -838,8 +838,7 @@ pub mod node {\n                   option::None => break,\n                   option::Some(x) => {\n                     //FIXME (#2744): Replace with memcpy or something similar\n-                    let mut local_buf: ~[u8] =\n-                        cast::transmute(*x.content);\n+                    let local_buf: ~[u8] = cast::transmute(*x.content);\n                     let mut i = x.byte_offset;\n                     while i < x.byte_len {\n                         buf[offset] = local_buf[i];\n@@ -1156,7 +1155,7 @@ pub mod node {\n         }\n \n         pub fn empty() -> T {\n-            let mut stack : ~[@Node] = ~[];\n+            let stack : ~[@Node] = ~[];\n             T { stack: stack, stackpos: -1 }\n         }\n "}, {"sha": "7371250b38a91d81930c7ec467b83384e530b4a2", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -93,7 +93,7 @@ pub fn sha1() -> @Sha1 {\n         assert!((vec::len(st.h) == digest_buf_len));\n         assert!((vec::uniq_len(st.work_buf) == work_buf_len));\n         let mut t: int; // Loop counter\n-        let mut w = st.work_buf;\n+        let w = st.work_buf;\n \n         // Initialize the first 16 words of the vector w\n         t = 0;\n@@ -260,7 +260,7 @@ pub fn sha1() -> @Sha1 {\n             return s;\n         }\n     }\n-    let mut st = Sha1State {\n+    let st = Sha1State {\n          h: vec::from_elem(digest_buf_len, 0u32),\n          len_low: 0u32,\n          len_high: 0u32,"}, {"sha": "febaea637efe1f0ffee400baefb9d8acfa7e434d", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -239,7 +239,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n             }\n         }\n         assert!(left == right);\n-        let mut n = start-left;\n+        let n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n         array[left] = pivot;\n@@ -416,7 +416,7 @@ impl<T:Copy + Ord> MergeState<T> {\n     }\n \n     fn merge_at(&mut self, n: uint, array: &mut [T]) {\n-        let mut size = self.runs.len();\n+        let size = self.runs.len();\n         assert!(size >= 2);\n         assert!(n == size-2 || n == size-3);\n "}, {"sha": "addc1da6394eeda880ed4ed26e09a7f14efc5e9d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -427,8 +427,7 @@ fn run_tests(opts: &TestOpts,\n     let filtered_descs = filtered_tests.map(|t| t.desc);\n     callback(TeFiltered(filtered_descs));\n \n-    let mut (filtered_tests,\n-             filtered_benchs) =\n+    let (filtered_tests, filtered_benchs) =\n         do vec::partition(filtered_tests) |e| {\n         match e.testfn {\n             StaticTestFn(_) | DynTestFn(_) => true,"}, {"sha": "a763aa1592e8308f15a657b670ef249e6833330a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -147,7 +147,7 @@ pub fn empty_tm() -> Tm {\n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n     unsafe {\n-        let mut Timespec { sec, nsec } = clock;\n+        let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_gmtime(sec, nsec, &mut tm);\n         tm\n@@ -162,7 +162,7 @@ pub fn now_utc() -> Tm {\n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n     unsafe {\n-        let mut Timespec { sec, nsec } = clock;\n+        let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_localtime(sec, nsec, &mut tm);\n         tm"}, {"sha": "c170ee5c1195c1b79a3f18590883477b26fa96e5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -342,7 +342,7 @@ fn highlight_lines_internal(cm: @codemap::CodeMap,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let mut left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n+        let left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n         let mut s = ~\"\";\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line."}, {"sha": "6a877040f480879b0cf2e827e870cabb9ac4cd87", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -96,7 +96,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             }\n         }\n         fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n-            let mut rt_type;\n+            let rt_type;\n             match t {\n               TyHex(c) => match c {\n                 CaseUpper => rt_type = ~\"TyHexUpper\",\n@@ -272,16 +272,18 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     /* Translate each piece (portion of the fmt expression) by invoking the\n        corresponding function in core::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n+    let npieces = pieces.len();\n     do vec::consume(pieces) |i, pc| {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {\n                 let portion = mk_uniq_str(cx, fmt_sp, s);\n \n                 /* If this is the first portion, then initialize the local\n-                   buffer with it directly */\n+                   buffer with it directly. If it's actually the only piece,\n+                   then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, true, ident, portion));\n+                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, portion));\n                 } else {\n                     let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), portion];\n                     let call = mk_call_global(cx,"}, {"sha": "f851b9781ab83336d2510b5a511c5dc150f7f8f7", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -73,7 +73,7 @@ impl parser_attr for Parser {\n         self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n         self.expect(&token::RBRACKET);\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         return spanned(lo, hi, ast::attribute_ { style: style,\n                                                  value: meta_item,\n                                                  is_sugared_doc: false });\n@@ -141,16 +141,16 @@ impl parser_attr for Parser {\n             token::EQ => {\n                 self.bump();\n                 let lit = self.parse_lit();\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_name_value(name, lit))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_list(name, inner_items))\n             }\n             _ => {\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_word(name))\n             }\n         }"}, {"sha": "b73544e95d60802094fb5a6be9aad4bf3da36213", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -229,7 +229,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n-    let mut col: CharPos = rdr.col;\n+    let col: CharPos = rdr.col;\n     bump(rdr);\n     bump(rdr);\n "}, {"sha": "21ea9f819b0e8a5090d27a961aa4490534e6d890", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -810,7 +810,7 @@ pub impl Parser {\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     fn parse_arg_general(&self, require_name: bool) -> arg {\n-        let mut m;\n+        let m;\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             m = self.parse_arg_mode();\n@@ -1154,7 +1154,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n-        let mut ex: expr_;\n+        let ex: expr_;\n \n         if *self.token == token::LPAREN {\n             self.bump();\n@@ -1629,9 +1629,9 @@ pub impl Parser {\n     // parse a prefix-operator expr\n     fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n-        let mut hi;\n+        let hi;\n \n-        let mut ex;\n+        let ex;\n         match *self.token {\n           token::NOT => {\n             self.bump();\n@@ -1781,7 +1781,7 @@ pub impl Parser {\n           token::BINOPEQ(op) => {\n               self.bump();\n               let rhs = self.parse_expr();\n-              let mut aop;\n+              let aop;\n               match op {\n                   token::PLUS => aop = add,\n                   token::MINUS => aop = subtract,\n@@ -1956,7 +1956,7 @@ pub impl Parser {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block_no_value();\n-        let mut hi = body.span.hi;\n+        let hi = body.span.hi;\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n@@ -1984,7 +1984,7 @@ pub impl Parser {\n \n             let lo = self.last_span.lo;\n             let body = self.parse_block_no_value();\n-            let mut hi = body.span.hi;\n+            let hi = body.span.hi;\n             return self.mk_expr(lo, hi, expr_loop(body, opt_ident));\n         } else {\n             // This is a 'continue' expression\n@@ -2043,7 +2043,7 @@ pub impl Parser {\n \n             arms.push(ast::arm { pats: pats, guard: guard, body: blk });\n         }\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.bump();\n         return self.mk_expr(lo, hi, expr_match(discriminant, arms));\n     }\n@@ -2162,7 +2162,7 @@ pub impl Parser {\n             let hi1 = self.last_span.lo;\n             let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n                                                     fieldname);\n-            let mut subpat;\n+            let subpat;\n             if *self.token == token::COLON {\n                 self.bump();\n                 subpat = self.parse_pat(refutable);\n@@ -2183,7 +2183,7 @@ pub impl Parser {\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n-        let mut pat;\n+        let pat;\n         match *self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n@@ -2534,7 +2534,7 @@ pub impl Parser {\n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                true, false, false) {\n               iovi_item(i) => {\n-                let mut hi = i.span.hi;\n+                let hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n                 return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n               }\n@@ -2704,7 +2704,7 @@ pub impl Parser {\n                 }\n             }\n         }\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.bump();\n         let bloc = ast::blk_ {\n             view_items: view_items,\n@@ -3590,7 +3590,7 @@ pub impl Parser {\n         let purity = self.parse_fn_purity();\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n@@ -3798,7 +3798,7 @@ pub impl Parser {\n             }\n         }\n         self.bump();\n-        let mut actual_dtor = do the_dtor.map |dtor| {\n+        let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = copy *dtor;\n             codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,"}, {"sha": "17add33d67316f63eb2faf6c373caa686d940c8d", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -146,9 +146,9 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer %u\", linewidth);\n-    let mut token: ~[token] = vec::from_elem(n, EOF);\n-    let mut size: ~[int] = vec::from_elem(n, 0);\n-    let mut scan_stack: ~[uint] = vec::from_elem(n, 0u);\n+    let token: ~[token] = vec::from_elem(n, EOF);\n+    let size: ~[int] = vec::from_elem(n, 0);\n+    let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     @mut Printer {\n         out: @out,\n         buf_len: n,"}, {"sha": "ce772ca7c35f2eca5dfaccd6f6f8af6ec1975f6b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -1972,7 +1972,7 @@ pub fn print_ty_fn(s: @ps,\n \n pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n                                     next_pos: Option<BytePos>) {\n-    let mut cm;\n+    let cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n       Some(ref cmnt) => {"}, {"sha": "d1223cd889307ca4aeb5d45badf7ac5facf968ba", "filename": "src/test/compile-fail/unused-mut-variables.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba93c6b60a91fc4b6b60408e51b23dbee5f44c9/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs?ref=aba93c6b60a91fc4b6b60408e51b23dbee5f44c9", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Exercise the unused_mut attribute in some positive and negative cases\n+\n+#[allow(dead_assignment)];\n+#[allow(unused_variable)];\n+#[deny(unused_mut)];\n+\n+fn main() {\n+    // negative cases\n+    let mut a = 3; //~ ERROR: variable does not need to be mutable\n+    let mut a = 2, b = 3; //~ ERROR: variable does not need to be mutable\n+                          //~^ ERROR: variable does not need to be mutable\n+    let mut a = ~[3]; //~ ERROR: variable does not need to be mutable\n+\n+    // positive cases\n+    let mut a = 2;\n+    a = 3;\n+    let mut a = ~[];\n+    a.push(3);\n+    let mut a = ~[];\n+    do callback {\n+        a.push(3);\n+    }\n+}\n+\n+fn callback(f: &fn()) {}\n+\n+// make sure the lint attribute can be turned off\n+#[allow(unused_mut)]\n+fn foo(mut a: int) {\n+    let mut a = 3;\n+    let mut b = ~[2];\n+}"}]}