{"sha": "3c930e48e139767f16871e1a1e99316a04e0403d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjOTMwZTQ4ZTEzOTc2N2YxNjg3MWUxYTFlOTkzMTZhMDRlMDQwM2Q=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-28T06:38:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-28T06:38:08Z"}, "message": "add Miri build script (#745)\n\nadd Miri build script", "tree": {"sha": "cd38473bb4521241f51d106443859f473a38b66e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd38473bb4521241f51d106443859f473a38b66e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c930e48e139767f16871e1a1e99316a04e0403d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7NdQCRBK7hj4Ov3rIwAAdHIIAH+qyIOorHPgKKKHjuTARqvN\nDP4eeyf+pgnLQtyzLC/lLkPGUWkKvkjcfNuTABjDkTxCcdEDANWAv5lct0E+BsKa\n2SuZ8w1Tnh5tNg4SBu+NADG6+JBciJAFbpbIWBG+PODG2wjZc2hFpzvdn6+1hOBU\nzqZD2JKUcm1bbwORaygEKpgOeBUKgyBIlUKYYCv8bdkVHZHyp5ngazSDG74SqF08\njsDzsaTRAocX2AWlmz8JlH0b+v53OXjLRu30gI71fQdMbGfARipMt5ejZniFlude\nwJ7q9m5nWpd3TIg6MFtmsD9ETsaRDKtzN1JYwyrEUhexQd6ZjaCRRgY5b8YWd8c=\n=TQIK\n-----END PGP SIGNATURE-----\n", "payload": "tree cd38473bb4521241f51d106443859f473a38b66e\nparent 4e329ebab7bb313c66bc09e728d875352c5a10f9\nparent 543e57990c7033793cf5211202be2d211767c095\nauthor Ralf Jung <post@ralfj.de> 1559025488 +0200\ncommitter GitHub <noreply@github.com> 1559025488 +0200\n\nadd Miri build script (#745)\n\nadd Miri build script"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c930e48e139767f16871e1a1e99316a04e0403d", "html_url": "https://github.com/rust-lang/rust/commit/3c930e48e139767f16871e1a1e99316a04e0403d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c930e48e139767f16871e1a1e99316a04e0403d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e329ebab7bb313c66bc09e728d875352c5a10f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e329ebab7bb313c66bc09e728d875352c5a10f9", "html_url": "https://github.com/rust-lang/rust/commit/4e329ebab7bb313c66bc09e728d875352c5a10f9"}, {"sha": "543e57990c7033793cf5211202be2d211767c095", "url": "https://api.github.com/repos/rust-lang/rust/commits/543e57990c7033793cf5211202be2d211767c095", "html_url": "https://github.com/rust-lang/rust/commit/543e57990c7033793cf5211202be2d211767c095"}], "stats": {"total": 168, "additions": 113, "deletions": 55}, "files": [{"sha": "1ba55e0c724a527d0422ec4ef71eab94406ad930", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -16,7 +16,6 @@ env:\n   global:\n   - RUST_TEST_NOCAPTURE=1\n   - RUST_BACKTRACE=1\n-  - RUSTFLAGS=\"-C debug-assertions\"\n \n before_script:\n # Linux: install extra stuff for cross-compilation"}, {"sha": "6f7570edda5fdf518bf1d4c1f07a612490be37fc", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -40,12 +40,15 @@ rustc_version = { version = \"0.2.3\", optional = true }\n env_logger = \"0.6\"\n log = \"0.4\"\n shell-escape = \"0.1.4\"\n+hex = \"0.3.2\"\n+rand = \"0.6\"\n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n rustc-workspace-hack = \"1.0.0\"\n-hex = \"0.3.2\"\n-rand = \"0.6\"\n+# Depend on num-traits with default features to avoid having to rebuild\n+# between \"cargo build\" and \"cargo intall\".\n+num-traits = \"*\"\n \n [build-dependencies]\n vergen = \"3\""}, {"sha": "130072825e1cff22711940e0e796742d7ec9f7b9", "filename": "README.md", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -141,42 +141,30 @@ version of `rustc` that, instead of compiling your code, runs it.  It accepts\n all the same flags as `rustc` (though the ones only affecting code generation\n and linking obviously will have no effect) [and more][miri-flags].\n \n-To run the Miri driver, you need to have the `MIRI_SYSROOT` environment variable\n-set to an appropriate sysroot.  You can generate such a sysroot with the\n-following incantation:\n-\n-```\n-cargo run --bin cargo-miri -- miri setup\n-```\n-\n-This basically runs the `cargo-miri` binary (which backs the `cargo miri`\n-subcommand) with `cargo`, and asks it to `setup`.  It should in the end print\n-the directory where the libstd was built.  In the following, we will assume it\n-is `~/.cache/miri/HOST`; you may have to adjust that if you are not using Linux.\n-\n-Now you can run the driver directly using\n+Running the Miri driver requires some fiddling with environment variables, so\n+the `miri` script helps you do that.  For example, you can run the driver on a\n+particular file by doing\n \n ```sh\n-MIRI_SYSROOT=~/.cache/miri/HOST cargo run tests/run-pass/format.rs # or whatever test you like\n+./miri run tests/run-pass/format.rs\n+./miri run tests/run-pass/hello.rs --target i686-unknown-linux-gnu\n ```\n \n-and you can run the test suite using\n+and you can run the test suite using:\n \n ```\n-cargo test\n+./miri test\n ```\n \n-We recommend adding the `--release` flag to make tests run faster.\n-\n-`cargo test --release FILTER` only runs those tests that contain `FILTER` in\n-their filename (including the base directory, e.g. `cargo test --release fail`\n-will run all compile-fail tests).\n+`./miri test FILTER` only runs those tests that contain `FILTER` in their\n+filename (including the base directory, e.g. `./miri test fail` will run all\n+compile-fail tests).\n \n You can get a trace of which MIR statements are being executed by setting the\n `MIRI_LOG` environment variable.  For example:\n \n ```sh\n-MIRI_LOG=info cargo run tests/run-pass/vecs.rs\n+MIRI_LOG=info ./miri run tests/run-pass/vecs.rs\n ```\n \n Setting `MIRI_LOG` like this will configure logging for Miri itself as well as\n@@ -185,7 +173,7 @@ can also do more targeted configuration, e.g. the following helps debug the\n stacked borrows implementation:\n \n ```sh\n-MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows cargo run tests/run-pass/vecs.rs\n+MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows ./miri run tests/run-pass/vecs.rs\n ```\n \n In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n@@ -199,7 +187,7 @@ is probably easier to test it with the cargo wrapper.  You can install your\n development version of Miri using\n \n ```\n-cargo install --path . --force\n+./miri install\n ```\n \n and then you can use it as if it was installed by `rustup`.  Make sure you use\n@@ -235,18 +223,7 @@ rustup override set custom\n ```\n \n With this, you should now have a working development setup!  See\n-[above][testing-miri] for how to proceed working with the Miri driver.  Notice\n-that rustc's sysroot is already built for Miri in this case, so you can set\n-`MIRI_SYSROOT=$(rustc --print sysroot)`.\n-\n-Running `cargo miri` in this setup is a bit more complicated, because the Miri\n-binary you just created needs help to find the libraries it links against.  On\n-Linux, you can set the rpath to make this \"just work\":\n-\n-```sh\n-export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/lib\"\n-cargo install --path . --force\n-```\n+[above][testing-miri] for how to proceed working with the Miri driver.\n \n ### Miri `-Z` flags and environment variables\n [miri-flags]: #miri--z-flags-and-environment-variables"}, {"sha": "a5f7271b246e39eb4d381785336d2dcb7faa4708", "filename": "miri", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/miri", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -0,0 +1,83 @@\n+#!/bin/sh\n+set -e\n+# I'd love to use `jq` for parsing the JSON properly, but macOS is totally underequipped for this kind of work.\n+TARGET=$(rustc --print target-spec-json -Z unstable-options | grep llvm-target | cut -d '\"' -f 4)\n+SYSROOT=$(rustc --print sysroot)\n+# We set the rpath so that Miri finds the private rustc libraries it needs.\n+# We enable debug-assertions to get tracing.\n+# We enable line-only debuginfo for backtraces.\n+export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$SYSROOT/lib/rustlib/$TARGET/lib -C debug-assertions -C debuginfo=1\"\n+\n+## Helper functions\n+\n+# Build a sysroot and set MIRI_SYSROOT to use it.  Arguments are passed to `cargo miri setup`.\n+build_sysroot() {\n+    # Build once, for the user to see.\n+    cargo run --release --bin cargo-miri -- miri setup \"$@\"\n+    # Call again, to just set env var.\n+    eval $(cargo run --release -q --bin cargo-miri -- miri setup --env \"$@\")\n+    export MIRI_SYSROOT\n+}\n+\n+# Prepare and set MIRI_SYSROOT.  Respects `MIRI_TEST_TARGET` and takes into account\n+# locally built vs. distributed rustc.\n+find_sysroot() {\n+    # Get ourselves a sysroot\n+    if [ -n \"$MIRI_SYSROOT\" ]; then\n+        # Sysroot already set, use that.\n+        true\n+    elif echo \"$SYSROOT\" | egrep -q 'build/[^/]+/stage'; then\n+        # A local rustc build.\n+        if [ -n \"$MIRI_TEST_TARGET\" ]; then\n+            # Foreign targets still need a build.  Use the rustc sources.\n+            export XARGO_RUST_SRC=\"$SYSROOT/../../../src\"\n+            build_sysroot --target \"$MIRI_TEST_TARGET\"\n+        else\n+            # Assume we have a proper host libstd in $SYSROOT.\n+            true\n+        fi\n+    else\n+        # A normal toolchain.  We have to build a sysroot either way.\n+        if [ -n \"$MIRI_TEST_TARGET\" ]; then\n+            build_sysroot --target \"$MIRI_TEST_TARGET\"\n+        else\n+            build_sysroot\n+        fi\n+    fi\n+}\n+\n+## Main\n+\n+COMMAND=\"$1\"\n+shift\n+\n+case \"$COMMAND\" in\n+install)\n+    # \"--locked\" to respect the Cargo.lock file if it exists,\n+    # \"--offline\" to avoid querying the registry (for yanked packages).\n+    exec cargo \"$COMMAND\" --path \"$(dirname \"$0\")\" --force --locked --offline \"$@\"\n+    ;;\n+build)\n+    # Build, and let caller control flags.\n+    exec cargo \"$COMMAND\" --release \"$@\"\n+    ;;\n+test|run)\n+    # In \"run\" mode, scan for \"--target\" to set the \"MIRI_TEST_TARGET\" env var so\n+    # that we set the MIRI_SYSROOT up the right way.\n+    if [ \"$COMMAND\" = \"run\" ] && [ -z \"$MIRI_TEST_TARGET\" ]; then\n+        for ARG in \"$@\"; do\n+            if [ \"$LAST_ARG\" = \"--target\" ]; then\n+                # Found it!\n+                export MIRI_TEST_TARGET=\"$ARG\"\n+                break\n+            fi\n+            LAST_ARG=\"$ARG\"\n+        done\n+    fi\n+    # First build and get a sysroot.\n+    cargo build --release\n+    find_sysroot\n+    # Then run the actual command.\n+    exec cargo \"$COMMAND\" --release \"$@\"\n+    ;;\n+esac"}, {"sha": "55c53e7361a515b5311c2fc5d6a898c50d92ae1b", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -243,6 +243,7 @@ path = \"lib.rs\"\n     File::create(dir.join(\"lib.rs\")).unwrap();\n     // Run xargo.\n     let target = get_arg_flag_value(\"--target\");\n+    let print_env = !ask_user && has_arg_flag(\"--env\"); // whether we just print the necessary environment variable\n     let mut command = Command::new(\"xargo\");\n     command.arg(\"build\").arg(\"-q\")\n         .current_dir(&dir)\n@@ -265,7 +266,9 @@ path = \"lib.rs\"\n     };\n     let sysroot = if is_host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n-    if !ask_user {\n+    if print_env {\n+        println!(\"MIRI_SYSROOT={}\", sysroot.display());\n+    } else if !ask_user {\n         println!(\"A libstd for Miri is now available in `{}`\", sysroot.display());\n     }\n }"}, {"sha": "4df12613fb831088ffa0a67ef82dee941caf50cc", "filename": "travis.sh", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c930e48e139767f16871e1a1e99316a04e0403d/travis.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3c930e48e139767f16871e1a1e99316a04e0403d/travis.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/travis.sh?ref=3c930e48e139767f16871e1a1e99316a04e0403d", "patch": "@@ -3,36 +3,29 @@ set -euo pipefail\n \n # Determine configuration\n if [ \"$TRAVIS_OS_NAME\" == osx ]; then\n-  MIRI_SYSROOT_BASE=~/Library/Caches/miri.miri.miri/\n   FOREIGN_TARGET=i686-apple-darwin\n else\n-  MIRI_SYSROOT_BASE=~/.cache/miri/\n   FOREIGN_TARGET=i686-unknown-linux-gnu\n fi\n \n # Prepare\n echo \"Build and install miri\"\n-cargo build --release --all-features --all-targets\n-cargo install --all-features --force --path .\n-echo\n-\n-echo \"Get ourselves a MIR-full libstd for the host and a foreign architecture\"\n-cargo miri setup\n-cargo miri setup --target \"$FOREIGN_TARGET\"\n+./miri build --all-features --all-targets\n+./miri install\n echo\n \n # Test\n function run_tests {\n-  cargo test --release --all-features\n-  test-cargo-miri/run-test.py\n+    ./miri test\n+    # \"miri test\" has built the sysroot for us, now this should pass without\n+    # any interactive questions.\n+    test-cargo-miri/run-test.py\n }\n \n echo \"Test host architecture\"\n-export MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST\n run_tests\n echo\n \n echo \"Test foreign architecture ($FOREIGN_TARGET)\"\n-export MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\" MIRI_TEST_TARGET=\"$FOREIGN_TARGET\"\n-run_tests\n+MIRI_TEST_TARGET=\"$FOREIGN_TARGET\" run_tests\n echo"}]}