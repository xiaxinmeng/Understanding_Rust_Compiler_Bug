{"sha": "ddccaecb79246f0c2bffb0ef9614939ee9a25835", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkY2NhZWNiNzkyNDZmMGMyYmZmYjBlZjk2MTQ5MzllZTlhMjU4MzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-12T17:55:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-12T17:55:32Z"}, "message": "Merge #6524\n\n6524: Add support for loading rustc private crates r=matklad a=xldenis\n\nThis PR presents a solution to the problem of making`rustc_private` crates visible to `rust-analyzer`. \r\nCurrently developers add dependencies to those crates behind a `cfg(NOT_A_TARGET)` target to prevent `cargo` from building them.\r\nThis solution is unsatisfactory since it requires modifying `Cargo.toml` and causes problems for collaboration or CI. \r\n\r\nThe proposed solution suggested by @matklad is to allow users to give RA a path where the `rustc` sources could be found and then load that like a normal workspace. \r\n\r\nThis PR implements this solution by adding a `rustcSource` configuration item and adding the cargo metadata to the crate graph if it is provided. \r\n\r\n------\r\n\r\nI have no idea how this should be tested, or if this code is generally tested at all. I've locally run the extension with these changes and it correctly loads the relevant crates on a `rustc_private` project of mine. \n\nCo-authored-by: Xavier Denis <xldenis@gmail.com>", "tree": {"sha": "6dd43dd27d4ba2ae1ea7f8c9c4ca81c160d31848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd43dd27d4ba2ae1ea7f8c9c4ca81c160d31848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddccaecb79246f0c2bffb0ef9614939ee9a25835", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrXcUCRBK7hj4Ov3rIwAAdHIIAIctW1KusQMbMCieFHNj3Z7p\nApvh/d/nfWX3NVY1JN5UBLu8HJ68kGzJb5JvH5w6GwCZy3zUzF/e3CAN7lsgUbBZ\nNFoSciVrLgL0X3szK2c9fQbBvZ2c0rlWxerm/OcnKFeS6qODBLNO8XfXvoFVnbRE\nDibbhEOW0AaOT+SYksaWQ7+m4/Do3CLpe2U1mWk054NooD+e1ICmHs8Yb1qtDTBT\nTpqEQ+tZ00roYmOWHVzdAc/LOOTFqxpmOdzOeN+UKX/HcOZZt+IgRMBBaSVDFGS/\neKwwzfHBMYOugH/2ytstf3YEx+ei/21hqMXghV0INPI/ZxidEluUVg5kyG8UnEo=\n=IJfM\n-----END PGP SIGNATURE-----\n", "payload": "tree 6dd43dd27d4ba2ae1ea7f8c9c4ca81c160d31848\nparent cf73b6851b4e8f80c170d1ba8912f3c27b816c34\nparent 89ce6b6664c9451c3c6ab9446fcd40697c5b0267\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1605203732 +0000\ncommitter GitHub <noreply@github.com> 1605203732 +0000\n\nMerge #6524\n\n6524: Add support for loading rustc private crates r=matklad a=xldenis\n\nThis PR presents a solution to the problem of making`rustc_private` crates visible to `rust-analyzer`. \r\nCurrently developers add dependencies to those crates behind a `cfg(NOT_A_TARGET)` target to prevent `cargo` from building them.\r\nThis solution is unsatisfactory since it requires modifying `Cargo.toml` and causes problems for collaboration or CI. \r\n\r\nThe proposed solution suggested by @matklad is to allow users to give RA a path where the `rustc` sources could be found and then load that like a normal workspace. \r\n\r\nThis PR implements this solution by adding a `rustcSource` configuration item and adding the cargo metadata to the crate graph if it is provided. \r\n\r\n------\r\n\r\nI have no idea how this should be tested, or if this code is generally tested at all. I've locally run the extension with these changes and it correctly loads the relevant crates on a `rustc_private` project of mine. \n\nCo-authored-by: Xavier Denis <xldenis@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddccaecb79246f0c2bffb0ef9614939ee9a25835", "html_url": "https://github.com/rust-lang/rust/commit/ddccaecb79246f0c2bffb0ef9614939ee9a25835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddccaecb79246f0c2bffb0ef9614939ee9a25835/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf73b6851b4e8f80c170d1ba8912f3c27b816c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf73b6851b4e8f80c170d1ba8912f3c27b816c34", "html_url": "https://github.com/rust-lang/rust/commit/cf73b6851b4e8f80c170d1ba8912f3c27b816c34"}, {"sha": "89ce6b6664c9451c3c6ab9446fcd40697c5b0267", "url": "https://api.github.com/repos/rust-lang/rust/commits/89ce6b6664c9451c3c6ab9446fcd40697c5b0267", "html_url": "https://github.com/rust-lang/rust/commit/89ce6b6664c9451c3c6ab9446fcd40697c5b0267"}], "stats": {"total": 302, "additions": 233, "deletions": 69}, "files": [{"sha": "608a031d49293b1a13fb09ec6ed3e83a51e6605d", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=ddccaecb79246f0c2bffb0ef9614939ee9a25835", "patch": "@@ -64,6 +64,9 @@ pub struct CargoConfig {\n \n     /// rustc target\n     pub target: Option<String>,\n+\n+    /// rustc private crate source\n+    pub rustc_source: Option<AbsPathBuf>,\n }\n \n pub type Package = Idx<PackageData>;"}, {"sha": "4531b19280c1458932ed063ea3cbaad58e089191", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 204, "deletions": 67, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=ddccaecb79246f0c2bffb0ef9614939ee9a25835", "patch": "@@ -9,6 +9,7 @@ use std::{\n     fmt,\n     fs::{self, read_dir, ReadDir},\n     io,\n+    path::Component,\n     process::Command,\n };\n \n@@ -31,18 +32,22 @@ pub use proc_macro_api::ProcMacroClient;\n #[derive(Clone, Eq, PartialEq)]\n pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n-    Cargo { cargo: CargoWorkspace, sysroot: Sysroot },\n+    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n     Json { project: ProjectJson, sysroot: Option<Sysroot> },\n }\n \n impl fmt::Debug for ProjectWorkspace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot } => f\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n                 .debug_struct(\"Cargo\")\n                 .field(\"n_packages\", &cargo.packages().len())\n                 .field(\"n_sysroot_crates\", &sysroot.crates().len())\n+                .field(\n+                    \"n_rustc_compiler_crates\",\n+                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n+                )\n                 .finish(),\n             ProjectWorkspace::Json { project, sysroot } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n@@ -200,7 +205,19 @@ impl ProjectWorkspace {\n                 } else {\n                     Sysroot::default()\n                 };\n-                ProjectWorkspace::Cargo { cargo, sysroot }\n+\n+                let rustc = if let Some(rustc_dir) = &cargo_config.rustc_source {\n+                    Some(\n+                        CargoWorkspace::from_cargo_metadata(&rustc_dir, cargo_config)\n+                            .with_context(|| {\n+                                format!(\"Failed to read Cargo metadata for Rust sources\")\n+                            })?,\n+                    )\n+                } else {\n+                    None\n+                };\n+\n+                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n             }\n         };\n \n@@ -238,31 +255,43 @@ impl ProjectWorkspace {\n                     })\n                 }))\n                 .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot } => cargo\n-                .packages()\n-                .map(|pkg| {\n-                    let is_member = cargo[pkg].is_member;\n-                    let pkg_root = cargo[pkg].root().to_path_buf();\n-\n-                    let mut include = vec![pkg_root.clone()];\n-                    include.extend(cargo[pkg].out_dir.clone());\n-\n-                    let mut exclude = vec![pkg_root.join(\".git\")];\n-                    if is_member {\n-                        exclude.push(pkg_root.join(\"target\"));\n-                    } else {\n-                        exclude.push(pkg_root.join(\"tests\"));\n-                        exclude.push(pkg_root.join(\"examples\"));\n-                        exclude.push(pkg_root.join(\"benches\"));\n-                    }\n-                    PackageRoot { is_member, include, exclude }\n-                })\n-                .chain(sysroot.crates().map(|krate| PackageRoot {\n-                    is_member: false,\n-                    include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                    exclude: Vec::new(),\n-                }))\n-                .collect(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let roots = cargo\n+                    .packages()\n+                    .map(|pkg| {\n+                        let is_member = cargo[pkg].is_member;\n+                        let pkg_root = cargo[pkg].root().to_path_buf();\n+\n+                        let mut include = vec![pkg_root.clone()];\n+                        include.extend(cargo[pkg].out_dir.clone());\n+\n+                        let mut exclude = vec![pkg_root.join(\".git\")];\n+                        if is_member {\n+                            exclude.push(pkg_root.join(\"target\"));\n+                        } else {\n+                            exclude.push(pkg_root.join(\"tests\"));\n+                            exclude.push(pkg_root.join(\"examples\"));\n+                            exclude.push(pkg_root.join(\"benches\"));\n+                        }\n+                        PackageRoot { is_member, include, exclude }\n+                    })\n+                    .chain(sysroot.crates().map(|krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    }));\n+                if let Some(rustc_packages) = rustc {\n+                    roots\n+                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n+                            is_member: false,\n+                            include: vec![rustc_packages[krate].root().to_path_buf()],\n+                            exclude: Vec::new(),\n+                        }))\n+                        .collect()\n+                } else {\n+                    roots.collect()\n+                }\n+            }\n         }\n     }\n \n@@ -273,7 +302,7 @@ impl ProjectWorkspace {\n                 .filter_map(|(_, krate)| krate.proc_macro_dylib_path.as_ref())\n                 .cloned()\n                 .collect(),\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => cargo\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot, rustc: _rustc_crates } => cargo\n                 .packages()\n                 .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n                 .cloned()\n@@ -284,8 +313,9 @@ impl ProjectWorkspace {\n     pub fn n_packages(&self) -> usize {\n         match self {\n             ProjectWorkspace::Json { project, .. } => project.n_crates(),\n-            ProjectWorkspace::Cargo { cargo, sysroot } => {\n-                cargo.packages().len() + sysroot.crates().len()\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n+                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n             }\n         }\n     }\n@@ -365,58 +395,33 @@ impl ProjectWorkspace {\n                     }\n                 }\n             }\n-            ProjectWorkspace::Cargo { cargo, sysroot } => {\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n                 let (public_deps, libproc_macro) =\n                     sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n \n                 let mut cfg_options = CfgOptions::default();\n                 cfg_options.extend(get_rustc_cfg_options(target));\n \n                 let mut pkg_to_lib_crate = FxHashMap::default();\n-                let mut pkg_crates = FxHashMap::default();\n \n                 // Add test cfg for non-sysroot crates\n                 cfg_options.insert_atom(\"test\".into());\n                 cfg_options.insert_atom(\"debug_assertions\".into());\n \n+                let mut pkg_crates = FxHashMap::default();\n+\n                 // Next, create crates for each package, target pair\n                 for pkg in cargo.packages() {\n                     let mut lib_tgt = None;\n                     for &tgt in cargo[pkg].targets.iter() {\n-                        let root = cargo[tgt].root.as_path();\n-                        if let Some(file_id) = load(root) {\n-                            let edition = cargo[pkg].edition;\n-                            let cfg_options = {\n-                                let mut opts = cfg_options.clone();\n-                                for feature in cargo[pkg].features.iter() {\n-                                    opts.insert_key_value(\"feature\".into(), feature.into());\n-                                }\n-                                opts.extend(cargo[pkg].cfgs.iter().cloned());\n-                                opts\n-                            };\n-                            let mut env = Env::default();\n-                            if let Some(out_dir) = &cargo[pkg].out_dir {\n-                                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                                if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                                    env.set(\"OUT_DIR\", out_dir);\n-                                }\n-                            }\n-                            let proc_macro = cargo[pkg]\n-                                .proc_macro_dylib_path\n-                                .as_ref()\n-                                .map(|it| proc_macro_client.by_dylib_path(&it))\n-                                .unwrap_or_default();\n-\n-                            let display_name =\n-                                CrateDisplayName::from_canonical_name(cargo[pkg].name.clone());\n-                            let crate_id = crate_graph.add_crate_root(\n-                                file_id,\n-                                edition,\n-                                Some(display_name),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.clone(),\n-                            );\n+                        if let Some(crate_id) = add_target_crate_root(\n+                            &mut crate_graph,\n+                            &cargo[pkg],\n+                            &cargo[tgt],\n+                            &cfg_options,\n+                            proc_macro_client,\n+                            load,\n+                        ) {\n                             if cargo[tgt].kind == TargetKind::Lib {\n                                 lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n                                 pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -484,6 +489,92 @@ impl ProjectWorkspace {\n                         }\n                     }\n                 }\n+\n+                let mut rustc_pkg_crates = FxHashMap::default();\n+\n+                // If the user provided a path to rustc sources, we add all the rustc_private crates\n+                // and create dependencies on them for the crates in the current workspace\n+                if let Some(rustc_workspace) = rustc {\n+                    for pkg in rustc_workspace.packages() {\n+                        for &tgt in rustc_workspace[pkg].targets.iter() {\n+                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                                continue;\n+                            }\n+                            // Exclude alloc / core / std\n+                            if rustc_workspace[tgt]\n+                                .root\n+                                .components()\n+                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                            {\n+                                continue;\n+                            }\n+\n+                            if let Some(crate_id) = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                &rustc_workspace[tgt],\n+                                &cfg_options,\n+                                proc_macro_client,\n+                                load,\n+                            ) {\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                                // Add dependencies on the core / std / alloc for rustc\n+                                for (name, krate) in public_deps.iter() {\n+                                    if let Err(_) =\n+                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n+                                    {\n+                                        log::error!(\n+                                            \"cyclic dependency on {} for {}\",\n+                                            name,\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                            }\n+                        }\n+                    }\n+                    // Now add a dep edge from all targets of upstream to the lib\n+                    // target of downstream.\n+                    for pkg in rustc_workspace.packages() {\n+                        for dep in rustc_workspace[pkg].dependencies.iter() {\n+                            let name = CrateName::new(&dep.name).unwrap();\n+                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &rustc_workspace[pkg].name,\n+                                            &rustc_workspace[dep.pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+                    for dep in rustc_workspace.packages() {\n+                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                            for pkg in cargo.packages() {\n+                                if !cargo[pkg].is_member {\n+                                    continue;\n+                                }\n+                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &cargo[pkg].name,\n+                                            &rustc_workspace[dep].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n         if crate_graph.patch_cfg_if() {\n@@ -537,6 +628,52 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     Ok(stdout.trim().to_string())\n }\n \n+fn add_target_crate_root(\n+    crate_graph: &mut CrateGraph,\n+    pkg: &cargo_workspace::PackageData,\n+    tgt: &cargo_workspace::TargetData,\n+    cfg_options: &CfgOptions,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> Option<CrateId> {\n+    let root = tgt.root.as_path();\n+    if let Some(file_id) = load(root) {\n+        let edition = pkg.edition;\n+        let cfg_options = {\n+            let mut opts = cfg_options.clone();\n+            for feature in pkg.features.iter() {\n+                opts.insert_key_value(\"feature\".into(), feature.into());\n+            }\n+            opts.extend(pkg.cfgs.iter().cloned());\n+            opts\n+        };\n+        let mut env = Env::default();\n+        if let Some(out_dir) = &pkg.out_dir {\n+            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                env.set(\"OUT_DIR\", out_dir);\n+            }\n+        }\n+        let proc_macro = pkg\n+            .proc_macro_dylib_path\n+            .as_ref()\n+            .map(|it| proc_macro_client.by_dylib_path(&it))\n+            .unwrap_or_default();\n+\n+        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n+        let crate_id = crate_graph.add_crate_root(\n+            file_id,\n+            edition,\n+            Some(display_name),\n+            cfg_options,\n+            env,\n+            proc_macro.clone(),\n+        );\n+\n+        return Some(crate_id);\n+    }\n+    None\n+}\n fn sysroot_to_crate_graph(\n     crate_graph: &mut CrateGraph,\n     sysroot: &Sysroot,"}, {"sha": "74a021dbf9ab5a3d284b8833c352724121b7ef9f", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=ddccaecb79246f0c2bffb0ef9614939ee9a25835", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, path::PathBuf};\n+use std::{convert::TryFrom, ffi::OsString, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use hir::PrefixKind;\n@@ -227,12 +227,25 @@ impl Config {\n         self.notifications =\n             NotificationsConfig { cargo_toml_not_found: data.notifications_cargoTomlNotFound };\n         self.cargo_autoreload = data.cargo_autoreload;\n+\n+        let rustc_source = if let Some(rustc_source) = data.rustcSource {\n+            let rustpath: PathBuf = rustc_source.into();\n+            AbsPathBuf::try_from(rustpath)\n+                .map_err(|_| {\n+                    log::error!(\"rustc source directory must be an absolute path\");\n+                })\n+                .ok()\n+        } else {\n+            None\n+        };\n+\n         self.cargo = CargoConfig {\n             no_default_features: data.cargo_noDefaultFeatures,\n             all_features: data.cargo_allFeatures,\n             features: data.cargo_features.clone(),\n             load_out_dirs_from_check: data.cargo_loadOutDirsFromCheck,\n             target: data.cargo_target.clone(),\n+            rustc_source: rustc_source,\n         };\n         self.runnables = RunnablesConfig {\n             override_cargo: data.runnables_overrideCargo,\n@@ -535,5 +548,6 @@ config_data! {\n         rustfmt_overrideCommand: Option<Vec<String>> = None,\n \n         withSysroot: bool = true,\n+        rustcSource : Option<String> = None,\n     }\n }"}, {"sha": "11c8d0e5f8c901d586f8bc77131f4dd6ac234668", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddccaecb79246f0c2bffb0ef9614939ee9a25835/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=ddccaecb79246f0c2bffb0ef9614939ee9a25835", "patch": "@@ -246,7 +246,9 @@ impl GlobalState {\n             .iter()\n             .enumerate()\n             .filter_map(|(id, w)| match w {\n-                ProjectWorkspace::Cargo { cargo, sysroot: _ } => Some((id, cargo.workspace_root())),\n+                ProjectWorkspace::Cargo { cargo, sysroot: _, rustc: _ } => {\n+                    Some((id, cargo.workspace_root()))\n+                }\n                 ProjectWorkspace::Json { project, .. } => {\n                     // Enable flychecks for json projects if a custom flycheck command was supplied\n                     // in the workspace configuration."}, {"sha": "6db78a99a3b53006c936b648eac2c79607d0471e", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddccaecb79246f0c2bffb0ef9614939ee9a25835/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ddccaecb79246f0c2bffb0ef9614939ee9a25835/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=ddccaecb79246f0c2bffb0ef9614939ee9a25835", "patch": "@@ -687,6 +687,14 @@\n                     },\n                     \"default\": [],\n                     \"description\": \"Additional arguments to be passed to cargo for runnables such as tests or binaries.\\nFor example, it may be '--release'\"\n+                },\n+                \"rust-analyzer.rustcSource\": {\n+                    \"type\": [\n+                        \"null\",\n+                        \"string\"\n+                    ],\n+                    \"default\": null,\n+                    \"description\": \"Path to the rust compiler sources, for usage in rustc_private projects.\"\n                 }\n             }\n         },"}]}