{"sha": "adbce60d6f131e5b3789f01417dedb05e4489898", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYmNlNjBkNmYxMzFlNWIzNzg5ZjAxNDE3ZGVkYjA1ZTQ0ODk4OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T05:24:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T05:24:49Z"}, "message": "Auto merge of #43630 - Mark-Simulacrum:rustbuild-cleanups, r=alexcrichton\n\nRustbuild cleanups/fixes and improvements\n\nEach commit is a standalone change, and can/should be reviewed separately.\n\nThis adds two new functionalities:\n\n - `--target` and `--host` can be passed without changing config.toml, and we'll respect the users' wishes, instead of requiring that all possible targets are passed.\n   - Note that this means that `./x.py clean` won't be quite as wide-spread as before, since it limits itself to the configured hosts, not all hosts. This could be considered a feature as well.\n - `ignore-git` field in `config.toml` which tells Rustbuild to not attempt to load git hashes from `.git`.\n\nThis is a precursor to eventual further simplification of the configuration system, but I want to get this merged first so that later work can be made in individual PRs.\n\nr? @alexcrichton", "tree": {"sha": "c35452a47f65da02696beb0bbac0348abf92f228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35452a47f65da02696beb0bbac0348abf92f228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adbce60d6f131e5b3789f01417dedb05e4489898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adbce60d6f131e5b3789f01417dedb05e4489898", "html_url": "https://github.com/rust-lang/rust/commit/adbce60d6f131e5b3789f01417dedb05e4489898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adbce60d6f131e5b3789f01417dedb05e4489898/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ed03e5490b481804db27627e16e147680ed207d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed03e5490b481804db27627e16e147680ed207d", "html_url": "https://github.com/rust-lang/rust/commit/0ed03e5490b481804db27627e16e147680ed207d"}, {"sha": "01641c70331d704fdab05914f21921e453ae61bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/01641c70331d704fdab05914f21921e453ae61bb", "html_url": "https://github.com/rust-lang/rust/commit/01641c70331d704fdab05914f21921e453ae61bb"}], "stats": {"total": 428, "additions": 239, "deletions": 189}, "files": [{"sha": "962be2e608501659cfafe2e0a7d559e1a0c1263a", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -258,6 +258,9 @@\n # saying that the FileCheck executable is missing, you may want to disable this.\n #codegen-tests = true\n \n+# Flag indicating whether git info will be retrieved from .git automatically.\n+#ignore-git = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "d02bc7972ae9a0980c7a7768446b206bc0f7b010", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -21,11 +21,10 @@ extern crate bootstrap;\n \n use std::env;\n \n-use bootstrap::{Flags, Config, Build};\n+use bootstrap::{Config, Build};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n-    let flags = Flags::parse(&args);\n-    let config = Config::parse(&flags.build, flags.config.clone());\n-    Build::new(flags, config).build();\n+    let config = Config::parse(&args);\n+    Build::new(config).build();\n }"}, {"sha": "db2c6dfeb9f74df1f6142da0d51f5e7bfc75638f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -120,28 +120,19 @@ impl StepDescription {\n     fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n         let build = builder.build;\n         let hosts = if self.only_build_targets || self.only_build {\n-            &build.config.host[..1]\n+            build.build_triple()\n         } else {\n             &build.hosts\n         };\n \n-        // Determine the actual targets participating in this rule.\n-        // NOTE: We should keep the full projection from build triple to\n-        // the hosts for the dist steps, now that the hosts array above is\n-        // truncated to avoid duplication of work in that case. Therefore\n-        // the original non-shadowed hosts array is used below.\n+        // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            // If --target was specified but --host wasn't specified,\n-            // don't run any host-only tests. Also, respect any `--host`\n-            // overrides as done for `hosts`.\n-            if build.flags.host.len() > 0 {\n-                &build.flags.host[..]\n-            } else if build.flags.target.len() > 0 {\n+            if build.config.run_host_only {\n                 &[]\n             } else if self.only_build {\n-                &build.config.host[..1]\n+                build.build_triple()\n             } else {\n-                &build.config.host[..]\n+                &build.hosts\n             }\n         } else {\n             &build.targets\n@@ -288,7 +279,7 @@ impl<'a> Builder<'a> {\n \n         let builder = Builder {\n             build: build,\n-            top_stage: build.flags.stage.unwrap_or(2),\n+            top_stage: build.config.stage.unwrap_or(2),\n             kind: kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n@@ -307,7 +298,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn run(build: &Build) {\n-        let (kind, paths) = match build.flags.cmd {\n+        let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n@@ -319,7 +310,7 @@ impl<'a> Builder<'a> {\n \n         let builder = Builder {\n             build: build,\n-            top_stage: build.flags.stage.unwrap_or(2),\n+            top_stage: build.config.stage.unwrap_or(2),\n             kind: kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n@@ -414,22 +405,19 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n-        self.ensure(tool::Rustdoc { target_compiler: compiler })\n+    pub fn rustdoc(&self, host: Interned<String>) -> PathBuf {\n+        self.ensure(tool::Rustdoc { host })\n     }\n \n-    pub fn rustdoc_cmd(&self, compiler: Compiler) -> Command {\n+    pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n+        let compiler = self.compiler(self.top_stage, host);\n         cmd\n             .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-            .env(\"RUSTC_SYSROOT\", if compiler.is_snapshot(&self.build) {\n-                INTERNER.intern_path(self.build.rustc_snapshot_libdir())\n-            } else {\n-                self.sysroot(compiler)\n-            })\n-            .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n             .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(host));\n         cmd\n     }\n \n@@ -483,7 +471,7 @@ impl<'a> Builder<'a> {\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n              .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n              .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || cmd == \"test\" {\n-                 self.rustdoc(compiler)\n+                 self.rustdoc(compiler.host)\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n              })\n@@ -543,12 +531,12 @@ impl<'a> Builder<'a> {\n         // Ignore incremental modes except for stage0, since we're\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n-        if self.flags.incremental && compiler.stage == 0 {\n+        if self.config.incremental && compiler.stage == 0 {\n             let incr_dir = self.incremental_dir(compiler);\n             cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n         }\n \n-        if let Some(ref on_fail) = self.flags.on_fail {\n+        if let Some(ref on_fail) = self.config.on_fail {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n "}, {"sha": "0f25da8a238d012d2d39af45f1bd695a3e796fc2", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -32,6 +32,7 @@\n //! everything.\n \n use std::process::Command;\n+use std::iter;\n \n use build_helper::{cc2ar, output};\n use gcc;\n@@ -43,47 +44,41 @@ use cache::Interned;\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    //\n-    // This includes targets that aren't necessarily passed on the commandline\n-    // (FIXME: Perhaps it shouldn't?)\n-    for target in &build.config.target {\n+    for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false)\n-           .target(target).host(&build.build);\n+           .target(&target).host(&build.build);\n \n         let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", *target, config, build);\n+            set_compiler(&mut cfg, \"gcc\", target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n-        let ar = cc2ar(compiler.path(), target);\n-        build.verbose(&format!(\"CC_{} = {:?}\", target, compiler.path()));\n+        let ar = cc2ar(compiler.path(), &target);\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n         if let Some(ref ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n         }\n-        build.cc.insert(*target, (compiler, ar));\n+        build.cc.insert(target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    //\n-    // This includes hosts that aren't necessarily passed on the commandline\n-    // (FIXME: Perhaps it shouldn't?)\n-    for host in &build.config.host {\n+    for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n-           .target(host).host(&build.build);\n-        let config = build.config.target_config.get(host);\n+           .target(&host).host(&build.build);\n+        let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", *host, config, build);\n+            set_compiler(&mut cfg, \"g++\", host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n-        build.cxx.insert(*host, compiler);\n+        build.cxx.insert(host, compiler);\n     }\n }\n "}, {"sha": "9c1ae83d3828189362fe6af0a9e8858f5bcdd37a", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -21,6 +21,7 @@ use std::process::Command;\n use build_helper::output;\n \n use Build;\n+use config::Config;\n \n // The version number\n pub const CFG_RELEASE_NUM: &str = \"1.21.0\";\n@@ -41,9 +42,9 @@ struct Info {\n }\n \n impl GitInfo {\n-    pub fn new(dir: &Path) -> GitInfo {\n+    pub fn new(config: &Config, dir: &Path) -> GitInfo {\n         // See if this even begins to look like a git dir\n-        if !dir.join(\".git\").exists() {\n+        if config.ignore_git || !dir.join(\".git\").exists() {\n             return GitInfo { inner: None }\n         }\n "}, {"sha": "d4d6fdc5c1b7db436ef02916e15abdb8b8ace82b", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -164,7 +164,7 @@ impl Step for Cargotest {\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n                           .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler)));\n+                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n     }\n }\n \n@@ -565,7 +565,7 @@ impl Step for Compiletest {\n \n         // Avoid depending on rustdoc when we don't need it.\n         if mode == \"rustdoc\" || mode == \"run-make\" {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n+            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n         }\n \n         cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n@@ -625,7 +625,7 @@ impl Step for Compiletest {\n             cmd.arg(\"--system-llvm\");\n         }\n \n-        cmd.args(&build.flags.cmd.test_args());\n+        cmd.args(&build.config.cmd.test_args());\n \n         if build.is_verbose() {\n             cmd.arg(\"--verbose\");\n@@ -814,13 +814,13 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n     }\n \n     println!(\"doc tests for: {}\", markdown.display());\n-    let mut cmd = builder.rustdoc_cmd(compiler);\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n     cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n-    let test_args = build.flags.cmd.test_args().join(\" \");\n+    let test_args = build.config.cmd.test_args().join(\" \");\n     cmd.arg(\"--test-args\").arg(test_args);\n \n     if build.config.quiet_tests {\n@@ -1051,7 +1051,7 @@ impl Step for Crate {\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         cargo.arg(\"--\");\n-        cargo.args(&build.flags.cmd.test_args());\n+        cargo.args(&build.config.cmd.test_args());\n \n         if build.config.quiet_tests {\n             cargo.arg(\"--quiet\");\n@@ -1147,6 +1147,7 @@ pub struct Distcheck;\n \n impl Step for Distcheck {\n     type Output = ();\n+    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"distcheck\")\n@@ -1160,16 +1161,6 @@ impl Step for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        if *build.build != *\"x86_64-unknown-linux-gnu\" {\n-            return\n-        }\n-        if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-            return\n-        }\n-        if !build.config.target.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-            return\n-        }\n-\n         println!(\"Distcheck\");\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n@@ -1236,7 +1227,7 @@ impl Step for Bootstrap {\n         if !build.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }\n-        cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n+        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n         try_run(build, &mut cmd);\n     }\n "}, {"sha": "119340a0190c4c11271d61e847ffaa600e61c03a", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -26,7 +26,7 @@ pub fn clean(build: &Build) {\n     rm_rf(&build.out.join(\"tmp\"));\n     rm_rf(&build.out.join(\"dist\"));\n \n-    for host in build.config.host.iter() {\n+    for host in &build.hosts {\n         let entries = match build.out.join(host).read_dir() {\n             Ok(iter) => iter,\n             Err(_) => continue,"}, {"sha": "33c3638a894730a85a0dc6bb2846ae05011f734f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -32,6 +32,7 @@ use serde_json;\n use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n use native;\n+use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n@@ -198,6 +199,12 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n         }\n+\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Libstd,\n+        });\n     }\n }\n \n@@ -389,6 +396,11 @@ impl Step for TestLink {\n                 target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Libtest,\n+        });\n     }\n }\n \n@@ -567,6 +579,11 @@ impl Step for RustcLink {\n                  target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Librustc,\n+        });\n     }\n }\n \n@@ -679,10 +696,10 @@ impl Step for Assemble {\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.build.flags.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n+        if builder.build.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n             builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n             let compiler = build_compiler;\n-            for stage in 0..min(target_compiler.stage, builder.flags.keep_stage.unwrap()) {\n+            for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n                 let target_compiler = builder.compiler(stage, target_compiler.host);\n                 let target = target_compiler.host;\n                 builder.ensure(StdLink { compiler, target_compiler, target });"}, {"sha": "aa688fc66e267831e71a7a3824720cdc8aa6ea8f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -19,11 +19,14 @@ use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::PathBuf;\n use std::process;\n+use std::cmp;\n \n use num_cpus;\n use toml;\n use util::{exe, push_exe_path};\n use cache::{INTERNER, Interned};\n+use flags::Flags;\n+pub use flags::Subcommand;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -51,6 +54,17 @@ pub struct Config {\n     pub extended: bool,\n     pub sanitizers: bool,\n     pub profiler: bool,\n+    pub ignore_git: bool,\n+\n+    pub run_host_only: bool,\n+\n+    pub on_fail: Option<String>,\n+    pub stage: Option<u32>,\n+    pub keep_stage: Option<u32>,\n+    pub src: PathBuf,\n+    pub jobs: Option<u32>,\n+    pub cmd: Subcommand,\n+    pub incremental: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -79,8 +93,8 @@ pub struct Config {\n     pub rust_dist_src: bool,\n \n     pub build: Interned<String>,\n-    pub host: Vec<Interned<String>>,\n-    pub target: Vec<Interned<String>>,\n+    pub hosts: Vec<Interned<String>>,\n+    pub targets: Vec<Interned<String>>,\n     pub local_rebuild: bool,\n \n     // dist misc\n@@ -249,6 +263,7 @@ struct Rust {\n     optimize_tests: Option<bool>,\n     debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n+    ignore_git: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -265,7 +280,9 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n@@ -277,11 +294,22 @@ impl Config {\n         config.docs = true;\n         config.rust_rpath = true;\n         config.rust_codegen_units = 1;\n-        config.build = INTERNER.intern_str(build);\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n+        config.ignore_git = false;\n         config.rust_dist_src = true;\n \n+        config.on_fail = flags.on_fail;\n+        config.stage = flags.stage;\n+        config.src = flags.src;\n+        config.jobs = flags.jobs;\n+        config.cmd = flags.cmd;\n+        config.incremental = flags.incremental;\n+        config.keep_stage = flags.keep_stage;\n+\n+        // If --target was specified but --host wasn't specified, don't run any host-only tests.\n+        config.run_host_only = flags.host.is_empty() && !flags.target.is_empty();\n+\n         let toml = file.map(|file| {\n             let mut f = t!(File::open(&file));\n             let mut contents = String::new();\n@@ -298,20 +326,37 @@ impl Config {\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n         set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        config.host.push(config.build.clone());\n+        set(&mut config.build, flags.build);\n+        if config.build.is_empty() {\n+            // set by bootstrap.py\n+            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n+        }\n+        config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n-            if !config.host.contains(&host) {\n-                config.host.push(host);\n+            if !config.hosts.contains(&host) {\n+                config.hosts.push(host);\n             }\n         }\n-        for target in config.host.iter().cloned()\n+        for target in config.hosts.iter().cloned()\n             .chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n         {\n-            if !config.target.contains(&target) {\n-                config.target.push(target);\n+            if !config.targets.contains(&target) {\n+                config.targets.push(target);\n             }\n         }\n+        config.hosts = if !flags.host.is_empty() {\n+            flags.host\n+        } else {\n+            config.hosts\n+        };\n+        config.targets = if !flags.target.is_empty() {\n+            flags.target\n+        } else {\n+            config.targets\n+        };\n+\n+\n         config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n@@ -327,6 +372,7 @@ impl Config {\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n+        config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n@@ -373,6 +419,7 @@ impl Config {\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n+            set(&mut config.ignore_git, rust.ignore_git);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n@@ -505,11 +552,11 @@ impl Config {\n             match key {\n                 \"CFG_BUILD\" if value.len() > 0 => self.build = INTERNER.intern_str(value),\n                 \"CFG_HOST\" if value.len() > 0 => {\n-                    self.host.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+                    self.hosts.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n \n                 }\n                 \"CFG_TARGET\" if value.len() > 0 => {\n-                    self.target.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+                    self.targets.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n                 }\n                 \"CFG_EXPERIMENTAL_TARGETS\" if value.len() > 0 => {\n                     self.llvm_experimental_targets = Some(value.to_string());"}, {"sha": "bfcfb5f9a37f8d994017461956d437aa83f1ef7b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -413,8 +413,7 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(image.join(\"bin\")));\n             cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.ensure(tool::Rustdoc { target_compiler: compiler }),\n-                &image.join(\"bin\"), 0o755);\n+            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n@@ -546,7 +545,7 @@ impl Step for Std {\n         // We want to package up as many target libraries as possible\n         // for the `rust-std` package, so if this is a host target we\n         // depend on librustc and otherwise we just depend on libtest.\n-        if build.config.host.iter().any(|t| t == target) {\n+        if build.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n             builder.ensure(compile::Test { compiler, target });"}, {"sha": "f0e0874abed604ba305e5544f176af65e41f2d5d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -260,7 +260,7 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n         t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n     }\n \n-    let mut cmd = builder.rustdoc_cmd(compiler);\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n \n     let out = out.join(\"book\");\n \n@@ -343,7 +343,7 @@ impl Step for Standalone {\n             }\n \n             let html = out.join(filename).with_extension(\"html\");\n-            let rustdoc = builder.rustdoc(compiler);\n+            let rustdoc = builder.rustdoc(compiler.host);\n             if up_to_date(&path, &html) &&\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n@@ -353,7 +353,7 @@ impl Step for Standalone {\n                 continue\n             }\n \n-            let mut cmd = builder.rustdoc_cmd(compiler);\n+            let mut cmd = builder.rustdoc_cmd(compiler.host);\n             cmd.arg(\"--html-after-content\").arg(&footer)\n                .arg(\"--html-before-content\").arg(&version_info)\n                .arg(\"--html-in-header\").arg(&favicon)\n@@ -408,7 +408,7 @@ impl Step for Std {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -493,7 +493,7 @@ impl Step for Test {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -554,7 +554,7 @@ impl Step for Rustc {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {"}, {"sha": "a9cefb65f4963af4b6c4979ee7856e2ddd1fd5fd", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -33,7 +33,8 @@ pub struct Flags {\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: Interned<String>,\n+    pub build: Option<Interned<String>>,\n+\n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n@@ -68,6 +69,14 @@ pub enum Subcommand {\n     },\n }\n \n+impl Default for Subcommand {\n+    fn default() -> Subcommand {\n+        Subcommand::Build {\n+            paths: vec![PathBuf::from(\"nowhere\")],\n+        }\n+    }\n+}\n+\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n@@ -243,10 +252,8 @@ Arguments:\n \n         // All subcommands can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n-            let flags = Flags::parse(&[\"build\".to_string()]);\n-            let mut config = Config::parse(&flags.build, cfg_file.clone());\n-            config.build = flags.build.clone();\n-            let mut build = Build::new(flags, config);\n+            let config = Config::parse(&[\"build\".to_string()]);\n+            let mut build = Build::new(config);\n             metadata::build(&mut build);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n@@ -320,9 +327,7 @@ Arguments:\n             stage: stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: INTERNER.intern_string(matches.opt_str(\"build\").unwrap_or_else(|| {\n-                env::var(\"BUILD\").unwrap()\n-            })),\n+            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))"}, {"sha": "89690e444d1f6d9bfb997d1b26faba7cb29b0cac", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -28,7 +28,7 @@ pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n }\n \n pub fn install_std(builder: &Builder, stage: u32) {\n-    for target in builder.build.config.target.iter() {\n+    for target in &builder.build.targets {\n         install_sh(builder, \"std\", \"rust-std\", stage, Some(*target));\n     }\n }"}, {"sha": "1452a38f6ed283b1433d1a63ea28cc144406473e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -136,13 +136,13 @@ extern crate toml;\n extern crate libc;\n \n use std::cell::Cell;\n-use std::cmp;\n use std::collections::{HashSet, HashMap};\n use std::env;\n use std::fs::{self, File};\n use std::io::Read;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n+use std::slice;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n \n@@ -187,7 +187,7 @@ mod job {\n }\n \n pub use config::Config;\n-pub use flags::{Flags, Subcommand};\n+use flags::Subcommand;\n use cache::{Interned, INTERNER};\n \n /// A structure representing a Rust compiler.\n@@ -215,9 +215,6 @@ pub struct Build {\n     // User-specified configuration via config.toml\n     config: Config,\n \n-    // User-specified configuration via CLI flags\n-    flags: Flags,\n-\n     // Derived properties from the above two configurations\n     src: PathBuf,\n     out: PathBuf,\n@@ -288,9 +285,9 @@ impl Build {\n     /// line and the filesystem `config`.\n     ///\n     /// By default all build output will be placed in the current directory.\n-    pub fn new(flags: Flags, config: Config) -> Build {\n+    pub fn new(config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone();\n+        let src = config.src.clone();\n         let out = cwd.join(\"build\");\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n@@ -302,43 +299,21 @@ impl Build {\n             }\n             None => false,\n         };\n-        let rust_info = channel::GitInfo::new(&src);\n-        let cargo_info = channel::GitInfo::new(&src.join(\"src/tools/cargo\"));\n-        let rls_info = channel::GitInfo::new(&src.join(\"src/tools/rls\"));\n-\n-        let hosts = if !flags.host.is_empty() {\n-            for host in flags.host.iter() {\n-                if !config.host.contains(host) {\n-                    panic!(\"specified host `{}` is not in configuration\", host);\n-                }\n-            }\n-            flags.host.clone()\n-        } else {\n-            config.host.clone()\n-        };\n-        let targets = if !flags.target.is_empty() {\n-            for target in flags.target.iter() {\n-                if !config.target.contains(target) {\n-                    panic!(\"specified target `{}` is not in configuration\", target);\n-                }\n-            }\n-            flags.target.clone()\n-        } else {\n-            config.target.clone()\n-        };\n+        let rust_info = channel::GitInfo::new(&config, &src);\n+        let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n+        let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n \n         Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n-            fail_fast: flags.cmd.fail_fast(),\n-            verbosity: cmp::max(flags.verbose, config.verbose),\n+            fail_fast: config.cmd.fail_fast(),\n+            verbosity: config.verbose,\n \n-            build: config.host[0].clone(),\n-            hosts: hosts,\n-            targets: targets,\n+            build: config.build,\n+            hosts: config.hosts.clone(),\n+            targets: config.targets.clone(),\n \n-            flags: flags,\n             config: config,\n             src: src,\n             out: out,\n@@ -357,13 +332,19 @@ impl Build {\n         }\n     }\n \n+    pub fn build_triple(&self) -> &[Interned<String>] {\n+        unsafe {\n+            slice::from_raw_parts(&self.build, 1)\n+        }\n+    }\n+\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n             job::setup(self);\n         }\n \n-        if let Subcommand::Clean = self.flags.cmd {\n+        if let Subcommand::Clean = self.config.cmd {\n             return clean::clean(self);\n         }\n \n@@ -608,7 +589,7 @@ impl Build {\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n-        self.flags.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n+        self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -727,7 +708,7 @@ impl Build {\n     fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n         !self.config.full_bootstrap &&\n             compiler.stage >= 2 &&\n-            self.config.host.iter().any(|h| *h == target)\n+            self.hosts.iter().any(|h| *h == target)\n     }\n \n     /// Returns the directory that OpenSSL artifacts are compiled into if"}, {"sha": "436a13500f254054913b0259d0173ed3b847d315", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -85,7 +85,7 @@ pub fn check(build: &mut Build) {\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n-    let building_llvm = build.config.host.iter()\n+    let building_llvm = build.hosts.iter()\n         .filter_map(|host| build.config.target_config.get(host))\n         .any(|config| config.llvm_config.is_none());\n     if building_llvm || build.config.sanitizers {\n@@ -114,7 +114,7 @@ pub fn check(build: &mut Build) {\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n-    for target in &build.config.target {\n+    for target in &build.targets {\n         // On emscripten we don't actually need the C compiler to just\n         // build the target artifacts, only for testing. For the sake\n         // of easier bot configuration, just skip detection.\n@@ -128,7 +128,7 @@ pub fn check(build: &mut Build) {\n         }\n     }\n \n-    for host in build.config.host.iter() {\n+    for host in &build.hosts {\n         cmd_finder.must_have(build.cxx(*host).unwrap());\n \n         // The msvc hosts don't use jemalloc, turn it off globally to\n@@ -144,7 +144,7 @@ pub fn check(build: &mut Build) {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n-    for target in &build.config.target {\n+    for target in &build.targets {\n         // Can't compile for iOS unless we're on macOS\n         if target.contains(\"apple-ios\") &&\n            !build.build.contains(\"apple-darwin\") {"}, {"sha": "d798e8de3dffae66fff02079891f75b21586fe9b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -23,10 +23,10 @@ use channel::GitInfo;\n use cache::Interned;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-struct CleanTools {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n+pub struct CleanTools {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+    pub mode: Mode,\n }\n \n impl Step for CleanTools {\n@@ -82,7 +82,6 @@ impl Step for ToolBuild {\n         let target = self.target;\n         let tool = self.tool;\n \n-        builder.ensure(CleanTools { compiler, target, mode: self.mode });\n         match self.mode {\n             Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n             Mode::Libtest => builder.ensure(compile::Test { compiler, target }),\n@@ -93,36 +92,46 @@ impl Step for ToolBuild {\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Tool, target, \"build\");\n-        let dir = build.src.join(\"src/tools\").join(tool);\n-        cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n-\n-        // We don't want to build tools dynamically as they'll be running across\n-        // stages and such and it's just easier if they're not dynamically linked.\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        if let Some(dir) = build.openssl_install_dir(target) {\n-            cargo.env(\"OPENSSL_STATIC\", \"1\");\n-            cargo.env(\"OPENSSL_DIR\", dir);\n-            cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n-        }\n+        let mut cargo = prepare_tool_cargo(builder, compiler, target, tool);\n+        build.run(&mut cargo);\n+        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+    }\n+}\n \n-        cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n+fn prepare_tool_cargo(\n+    builder: &Builder,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    tool: &'static str,\n+) -> Command {\n+    let build = builder.build;\n+    let mut cargo = builder.cargo(compiler, Mode::Tool, target, \"build\");\n+    let dir = build.src.join(\"src/tools\").join(tool);\n+    cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n+\n+    // We don't want to build tools dynamically as they'll be running across\n+    // stages and such and it's just easier if they're not dynamically linked.\n+    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+    if let Some(dir) = build.openssl_install_dir(target) {\n+        cargo.env(\"OPENSSL_STATIC\", \"1\");\n+        cargo.env(\"OPENSSL_DIR\", dir);\n+        cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n+    }\n \n-        let info = GitInfo::new(&dir);\n-        if let Some(sha) = info.sha() {\n-            cargo.env(\"CFG_COMMIT_HASH\", sha);\n-        }\n-        if let Some(sha_short) = info.sha_short() {\n-            cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n-        }\n-        if let Some(date) = info.commit_date() {\n-            cargo.env(\"CFG_COMMIT_DATE\", date);\n-        }\n+    cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n \n-        build.run(&mut cargo);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+    let info = GitInfo::new(&build.config, &dir);\n+    if let Some(sha) = info.sha() {\n+        cargo.env(\"CFG_COMMIT_HASH\", sha);\n+    }\n+    if let Some(sha_short) = info.sha_short() {\n+        cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n     }\n+    if let Some(date) = info.commit_date() {\n+        cargo.env(\"CFG_COMMIT_DATE\", date);\n+    }\n+    cargo\n }\n \n macro_rules! tool {\n@@ -226,7 +235,7 @@ impl Step for RemoteTestServer {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n-    pub target_compiler: Compiler,\n+    pub host: Interned<String>,\n }\n \n impl Step for Rustdoc {\n@@ -240,27 +249,39 @@ impl Step for Rustdoc {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Rustdoc {\n-            target_compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            host: run.host,\n         });\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let target_compiler = self.target_compiler;\n+        let build = builder.build;\n+        let target_compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = target_compiler.host;\n         let build_compiler = if target_compiler.stage == 0 {\n             builder.compiler(0, builder.build.build)\n+        } else if target_compiler.stage >= 2 {\n+            // Past stage 2, we consider the compiler to be ABI-compatible and hence capable of\n+            // building rustdoc itself.\n+            builder.compiler(target_compiler.stage, builder.build.build)\n         } else {\n             // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n             // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n             // compilers, which isn't what we want.\n             builder.compiler(target_compiler.stage - 1, builder.build.build)\n         };\n \n-        let tool_rustdoc = builder.ensure(ToolBuild {\n-            compiler: build_compiler,\n-            target: target_compiler.host,\n-            tool: \"rustdoc\",\n-            mode: Mode::Librustc,\n-        });\n+        builder.ensure(compile::Rustc { compiler: build_compiler, target });\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n+\n+        let mut cargo = prepare_tool_cargo(builder, build_compiler, target, \"rustdoc\");\n+        build.run(&mut cargo);\n+        // Cargo adds a number of paths to the dylib search path on windows, which results in\n+        // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n+        // rustdoc a different name.\n+        let tool_rustdoc = build.cargo_out(build_compiler, Mode::Tool, target)\n+            .join(exe(\"rustdoc-tool-binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {"}, {"sha": "344f617ef95bc069da4e78c66caf95e98d14da91", "filename": "src/tools/rustdoc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Ftools%2Frustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/adbce60d6f131e5b3789f01417dedb05e4489898/src%2Ftools%2Frustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc%2FCargo.toml?ref=adbce60d6f131e5b3789f01417dedb05e4489898", "patch": "@@ -3,8 +3,11 @@ name = \"rustdoc-tool\"\n version = \"0.0.0\"\n authors = [\"The Rust Project Developers\"]\n \n+# Cargo adds a number of paths to the dylib search path on windows, which results in\n+# the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n+# rustdoc a different name.\n [[bin]]\n-name = \"rustdoc\"\n+name = \"rustdoc-tool-binary\"\n path = \"main.rs\"\n \n [dependencies]"}]}