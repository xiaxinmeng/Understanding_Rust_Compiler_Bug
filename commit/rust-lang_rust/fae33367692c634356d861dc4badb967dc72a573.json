{"sha": "fae33367692c634356d861dc4badb967dc72a573", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZTMzMzY3NjkyYzYzNDM1NmQ4NjFkYzRiYWRiOTY3ZGM3MmE1NzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-08T23:20:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-08T23:29:54Z"}, "message": "Merge remote-tracking branch 'mozilla/master'\n\nConflicts:\n\tsrc/libextra/test.rs\n\tsrc/libstd/rt/global_heap.rs\n\tsrc/libstd/unstable/lang.rs\n\tsrc/libstd/vec.rs", "tree": {"sha": "d73190f2523bed7d010da69442b0c28973631ac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d73190f2523bed7d010da69442b0c28973631ac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fae33367692c634356d861dc4badb967dc72a573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fae33367692c634356d861dc4badb967dc72a573", "html_url": "https://github.com/rust-lang/rust/commit/fae33367692c634356d861dc4badb967dc72a573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fae33367692c634356d861dc4badb967dc72a573/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b227583dadd1500bba7752c7e5d9f2ac931611bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b227583dadd1500bba7752c7e5d9f2ac931611bc", "html_url": "https://github.com/rust-lang/rust/commit/b227583dadd1500bba7752c7e5d9f2ac931611bc"}, {"sha": "f503e539bf60416a731f9ecc12b6aab31ef2fe87", "url": "https://api.github.com/repos/rust-lang/rust/commits/f503e539bf60416a731f9ecc12b6aab31ef2fe87", "html_url": "https://github.com/rust-lang/rust/commit/f503e539bf60416a731f9ecc12b6aab31ef2fe87"}], "stats": {"total": 10895, "additions": 5149, "deletions": 5746}, "files": [{"sha": "24cd280386af4334725985c85111ec8ca13098aa", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -139,11 +139,11 @@ endif\n \n # version-string calculation\n CFG_GIT_DIR := $(CFG_SRC_DIR).git\n-CFG_RELEASE = 0.7\n+CFG_RELEASE = 0.8-pre\n CFG_VERSION = $(CFG_RELEASE)\n # windows exe's need numeric versions - don't use anything but\n # numbers and dots here\n-CFG_VERSION_WIN = 0.7\n+CFG_VERSION_WIN = 0.8\n \n ifneq ($(wildcard $(CFG_GIT)),)\n ifneq ($(wildcard $(CFG_GIT_DIR)),)"}, {"sha": "12782fa9fdb626a23115e0d15c0ab88c1865c8b3", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/configure", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -402,7 +402,7 @@ fi\n step_msg \"looking for build programs\"\n \n probe_need CFG_PERL        perl\n-probe_need CFG_CURL        curl\n+probe_need CFG_CURLORWGET  curl wget\n probe_need CFG_PYTHON      python2.7 python2.6 python2 python\n \n python_version=$($CFG_PYTHON -V 2>&1)"}, {"sha": "42a010b114ab20c46e3778fa41452b7a40256cb9", "filename": "doc/rust.md", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -207,7 +207,7 @@ The keywords are the following strings:\n as\n break\n copy\n-do drop\n+do\n else enum extern\n false fn for\n if impl\n@@ -1107,20 +1107,20 @@ The derived types are borrowed pointers with the `'static` lifetime,\n fixed-size arrays, tuples, and structs.\n \n ~~~~\n-static bit1: uint = 1 << 0;\n-static bit2: uint = 1 << 1;\n+static BIT1: uint = 1 << 0;\n+static BIT2: uint = 1 << 1;\n \n-static bits: [uint, ..2] = [bit1, bit2];\n-static string: &'static str = \"bitstring\";\n+static BITS: [uint, ..2] = [BIT1, BIT2];\n+static STRING: &'static str = \"bitstring\";\n \n struct BitsNStrings<'self> {\n     mybits: [uint, ..2],\n     mystring: &'self str\n }\n \n static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n-    mybits: bits,\n-    mystring: string\n+    mybits: BITS,\n+    mystring: STRING\n };\n ~~~~\n \n@@ -2869,24 +2869,19 @@ The kinds are:\n   : Types of this kind can be safely sent between tasks.\n     This kind includes scalars, owning pointers, owned closures, and\n     structural types containing only other owned types. All `Send` types are `Static`.\n-`Static`\n-  : Types of this kind do not contain any borrowed pointers;\n-    this can be a useful guarantee for code that breaks borrowing assumptions using [`unsafe` operations](#unsafe-functions).\n `Copy`\n   : This kind includes all types that can be copied. All types with\n     sendable kind are copyable, as are managed boxes, managed closures,\n     trait types, and structural types built out of these.\n     Types with destructors (types that implement `Drop`) can not implement `Copy`.\n `Drop`\n   : This is not strictly a kind, but its presence interacts with kinds: the `Drop`\n-    trait provides a single method `finalize` that takes no parameters, and is run\n+    trait provides a single method `drop` that takes no parameters, and is run\n     when values of the type are dropped. Such a method is called a \"destructor\",\n     and are always executed in \"top-down\" order: a value is completely destroyed\n     before any of the values it owns run their destructors. Only `Send` types\n     that do not implement `Copy` can implement `Drop`.\n \n-> **Note:** The `finalize` method may be renamed in future versions of Rust.\n-\n _Default_\n   : Types with destructors, closure environments,\n     and various other _non-first-class_ types,"}, {"sha": "5ed61d6930143a2bdb3744bf4c11c2984bf76dd0", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -108,7 +108,7 @@ impl Iterator<int> for ZeroStream {\n ## Container iterators\n \n Containers implement iteration over the contained elements by returning an\n-iterator object. For example, vectors have four iterators available:\n+iterator object. For example, vector slices have four iterators available:\n \n * `vector.iter()`, for immutable references to the elements\n * `vector.mut_iter()`, for mutable references to the elements"}, {"sha": "c8280a991827e56f322e749cc1746ba30e71913f", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -237,8 +237,8 @@ can specify a variable's type by following it with a colon, then the type\n name. Static items, on the other hand, always require a type annotation.\n \n ~~~~\n-static monster_factor: float = 57.8;\n-let monster_size = monster_factor * 10.0;\n+static MONSTER_FACTOR: float = 57.8;\n+let monster_size = MONSTER_FACTOR * 10.0;\n let monster_size: int = 50;\n ~~~~\n "}, {"sha": "61a170c21d51e3da2278dd12f3c2663c9ff6edd4", "filename": "mk/platform.mk", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -323,9 +323,9 @@ AR_i686-pc-mingw32=$(AR)\n CFG_LIB_NAME_i686-pc-mingw32=$(1).dll\n CFG_LIB_GLOB_i686-pc-mingw32=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i686-pc-mingw32=$(1)-*.dylib.dSYM\n-CFG_GCCISH_CFLAGS_i686-pc-mingw32 := -Wall -Werror -g -march=i686\n+CFG_GCCISH_CFLAGS_i686-pc-mingw32 := -Wall -Werror -g -m32 -march=i686 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CXXFLAGS_i686-pc-mingw32 := -fno-rtti\n-CFG_GCCISH_LINK_FLAGS_i686-pc-mingw32 := -shared -fPIC -g\n+CFG_GCCISH_LINK_FLAGS_i686-pc-mingw32 := -shared -fPIC -g -m32\n CFG_GCCISH_DEF_FLAG_i686-pc-mingw32 :=\n CFG_GCCISH_PRE_LIB_FLAGS_i686-pc-mingw32 :=\n CFG_GCCISH_POST_LIB_FLAGS_i686-pc-mingw32 :=\n@@ -367,6 +367,31 @@ CFG_LDPATH_i586-mingw32msvc :=\n CFG_RUN_i586-mingw32msvc=\n CFG_RUN_TARG_i586-mingw32msvc=\n \n+# x86_64-w64-mingw32 configuration\n+CC_x86_64-w64-mingw32=$(CC)\n+CXX_x86_64-w64-mingw32=$(CXX)\n+CPP_x86_64-w64-mingw32=$(CPP)\n+AR_x86_64-w64-mingw32=$(AR)\n+CFG_LIB_NAME_x86_64-w64-mingw32=$(1).dll\n+CFG_LIB_GLOB_x86_64-w64-mingw32=$(1)-*.dll\n+CFG_LIB_DSYM_GLOB_x86_64-w64-mingw32=$(1)-*.dylib.dSYM\n+CFG_GCCISH_CFLAGS_x86_64-w64-mingw32 := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600\n+CFG_GCCISH_CXXFLAGS_x86_64-w64-mingw32 := -fno-rtti\n+CFG_GCCISH_LINK_FLAGS_x86_64-w64-mingw32 := -shared -fPIC -g -m64\n+CFG_GCCISH_DEF_FLAG_x86_64-w64-mingw32 :=\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-w64-mingw32 :=\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-w64-mingw32 :=\n+CFG_DEF_SUFFIX_x86_64-w64-mingw32 := .mingw32.def\n+CFG_INSTALL_NAME_x86_64-w64-mingw32 =\n+CFG_LIBUV_LINK_FLAGS_x86_64-w64-mingw32 := -lWs2_32 -lpsapi -liphlpapi\n+CFG_EXE_SUFFIX_x86_64-w64-mingw32 := .exe\n+CFG_WINDOWSY_x86_64-w64-mingw32 := 1\n+CFG_UNIXY_x86_64-w64-mingw32 :=\n+CFG_PATH_MUNGE_x86_64-w64-mingw32 :=\n+CFG_LDPATH_x86_64-w64-mingw32 :=$(CFG_LDPATH_x86_64-w64-mingw32):$(PATH)\n+CFG_RUN_x86_64-w64-mingw32=PATH=\"$(CFG_LDPATH_x86_64-w64-mingw32):$(1)\" $(2)\n+CFG_RUN_TARG_x86_64-w64-mingw32=$(call CFG_RUN_x86_64-w64-mingw32,$(HLIB$(1)_H_$(CFG_BUILD_TRIPLE)),$(2))\n+\n # x86_64-unknown-freebsd configuration\n CC_x86_64-unknown-freebsd=$(CC)\n CXX_x86_64-unknown-freebsd=$(CXX)"}, {"sha": "6b6f515ce2b5af9295621783f6bec5323762e74b", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -15,7 +15,7 @@\n \n # The names of crates that must be tested\n TEST_TARGET_CRATES = std extra\n-TEST_HOST_CRATES = syntax rustc rustdoc rusti rust rustpkg\n+TEST_HOST_CRATES = syntax rustc rustdoc rust rustpkg rusti\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n@@ -157,6 +157,7 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n \n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n+\tcheck-stage2-rustpkg check-stage2-rusti \\\n \tcheck-stage2-rfail check-stage2-cfail\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n "}, {"sha": "0e83147501cbfb6b617cbfde47370f238a1a429e", "filename": "mk/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -50,7 +50,7 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTPKG_$(4)):\t\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_EXTRALIB_$(4))\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n \n $$(TBIN$(1)_T_$(4)_H_$(3))/rustpkg$$(X_$(4)):\t\t\t\t\\\n \t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\"}, {"sha": "38289f6274180a63c401d0f1754e9481f2f25f75", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n #[deriving(Eq)]\n pub enum mode {\n     mode_compile_fail,"}, {"sha": "7d9a7c3ea75dcc75f49b1eadba8af12a6dd7d897", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,21 +11,16 @@\n #[crate_type = \"bin\"];\n \n #[allow(non_camel_case_types)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after snapshot\n+#[deny(warnings)];\n \n-#[no_core]; // XXX: Remove after snapshot\n-#[no_std];\n+extern mod extra;\n \n-extern mod core(name = \"std\", vers = \"0.7\");\n-extern mod extra(name = \"extra\", vers = \"0.7\");\n-\n-use core::prelude::*;\n-use core::*;\n+use std::os;\n \n use extra::getopts;\n use extra::test;\n \n-use core::result::{Ok, Err};\n-\n use common::config;\n use common::mode_run_pass;\n use common::mode_run_fail;\n@@ -42,13 +37,6 @@ pub mod runtest;\n pub mod common;\n pub mod errors;\n \n-mod std {\n-    pub use core::cmp;\n-    pub use core::str;\n-    pub use core::sys;\n-    pub use core::unstable;\n-}\n-\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);\n@@ -98,8 +86,8 @@ pub fn parse_config(args: ~[~str]) -> config {\n         run_ignored: getopts::opt_present(matches, \"ignored\"),\n         filter:\n              if !matches.free.is_empty() {\n-                 option::Some(copy matches.free[0])\n-             } else { option::None },\n+                 Some(copy matches.free[0])\n+             } else { None },\n         logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n         runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n@@ -148,8 +136,8 @@ pub fn log_config(config: &config) {\n \n pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n     match *maybestr {\n-        option::None => \"(none)\",\n-        option::Some(ref s) => {\n+        None => \"(none)\",\n+        Some(ref s) => {\n             let s: &'a str = *s;\n             s\n         }\n@@ -161,7 +149,7 @@ pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n }\n \n pub fn str_opt(maybestr: ~str) -> Option<~str> {\n-    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n+    if maybestr != ~\"(none)\" { Some(maybestr) } else { None }\n }\n \n pub fn str_mode(s: ~str) -> mode {\n@@ -199,8 +187,8 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n         logfile: copy config.logfile,\n         run_tests: true,\n         run_benchmarks: false,\n-        save_results: option::None,\n-        compare_results: option::None\n+        save_results: None,\n+        compare_results: None\n     }\n }\n \n@@ -268,7 +256,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n }\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n-    use core::cell::Cell;\n+    use std::cell::Cell;\n     let config = Cell::new(copy *config);\n     let testfile = Cell::new(testfile.to_str());\n     test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })"}, {"sha": "780a917c019b22cca0a31da042d2e1b2aea1e707", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n-use core::io;\n+use std::io;\n \n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n "}, {"sha": "9cd489f05766afd2591bffb4be2210a51172efd5", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use common::config;\n use common;\n \n-use core::io;\n-use core::os;\n+use std::io;\n+use std::os;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out"}, {"sha": "0e61b45d6199f4795feca9b4be7640664daa34a9", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n-use core::os;\n-use core::run;\n-use core::str;\n+use std::os;\n+use std::run;\n+use std::str;\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {"}, {"sha": "91016ba91fa555a8c5c7ea6d971394cc096d7867", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use common::mode_run_pass;\n use common::mode_run_fail;\n use common::mode_compile_fail;\n@@ -22,10 +20,10 @@ use procsrv;\n use util;\n use util::logv;\n \n-use core::io;\n-use core::os;\n-use core::uint;\n-use core::vec;\n+use std::io;\n+use std::os;\n+use std::uint;\n+use std::vec;\n \n pub fn run(config: config, testfile: ~str) {\n     if config.verbose {\n@@ -79,8 +77,8 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     };\n \n     // The value our Makefile configures valgrind to return on failure\n-    static valgrind_err: int = 100;\n-    if ProcRes.status == valgrind_err {\n+    static VALGRIND_ERR: int = 100;\n+    if ProcRes.status == VALGRIND_ERR {\n         fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &ProcRes);\n     }\n \n@@ -102,8 +100,8 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n \n fn check_correct_failure_status(ProcRes: &ProcRes) {\n     // The value the rust runtime returns on failure\n-    static rust_err: int = 101;\n-    if ProcRes.status != rust_err {\n+    static RUST_ERR: int = 101;\n+    if ProcRes.status != RUST_ERR {\n         fatal_ProcRes(\n             fmt!(\"failure produced the wrong error code: %d\",\n                  ProcRes.status),\n@@ -601,9 +599,8 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n     // If we've got another tool to run under (valgrind),\n     // then split apart its command\n-    let toolargs = split_maybe_args(&config.runtool);\n-\n-    let mut args = toolargs + [make_exe_name(config, testfile).to_str()];\n+    let mut args = split_maybe_args(&config.runtool);\n+    args.push(make_exe_name(config, testfile).to_str());\n     let prog = args.shift();\n     return ProcArgs {prog: prog, args: args};\n }"}, {"sha": "5af469ff8417c17d82865bddd0a18d2e0c4668de", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use common::config;\n \n-use core::io;\n-use core::os::getenv;\n+use std::io;\n+use std::os::getenv;\n \n pub fn make_new_path(path: &str) -> ~str {\n "}, {"sha": "e81a3230e134384101441c8cc6a206a54e5af6e1", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_core];\n-#[no_std];\n-\n-extern mod core(name = \"std\", vers = \"0.7\");\n-\n #[cfg(rustpkg)]\n extern mod this(name = \"rustpkg\");\n "}, {"sha": "6aa953071476770b1fff2aa9f959e477b83e4a08", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -7,7 +7,7 @@\n \t<!ENTITY rustIdent \"[a-zA-Z_][a-zA-Z_0-9]*\">\n \t<!ENTITY rustIntSuf \"([iu](8|16|32|64)?)?\">\n ]>\n-<language name=\"Rust\" version=\"0.7\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n+<language name=\"Rust\" version=\"0.8-pre\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n <highlighting>\n \t<list name=\"fn\">\n \t\t<item> fn </item>"}, {"sha": "3b70f9b967fb639aa1da07be95145f21f7ec5cda", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -43,7 +43,7 @@ fi\n \n cp ${PREFIX}/bin/rustc ${TARG_DIR}/stage0/bin/\n cp ${PREFIX}/lib/rustc/${TARG_DIR}/${LIBDIR}/* ${TARG_DIR}/stage0/${LIBDIR}/\n+cp ${PREFIX}/lib/libextra*${LIB_SUF} ${TARG_DIR}/stage0/${LIBDIR}/\n cp ${PREFIX}/lib/librust*${LIB_SUF} ${TARG_DIR}/stage0/${LIBDIR}/\n-cp ${PREFIX}/lib/libcore*${LIB_SUF} ${TARG_DIR}/stage0/${LIBDIR}/\n cp ${PREFIX}/lib/libstd*${LIB_SUF} ${TARG_DIR}/stage0/${LIBDIR}/\n cp ${PREFIX}/lib/libsyntax*${LIB_SUF} ${TARG_DIR}/stage0/${LIBDIR}/"}, {"sha": "36b00a3dedf2cdd7579d8bd206e62328778da3ab", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1,6 +1,6 @@\n # xfail-license\n \n-import re, os, sys, glob, tarfile, shutil, subprocess, tempfile\n+import re, os, sys, glob, tarfile, shutil, subprocess, tempfile, distutils.spawn\n \n try:\n   import hashlib\n@@ -132,7 +132,13 @@ def local_rev_committer_date():\n def get_url_to_file(u,f):\n     # no security issue, just to stop partial download leaving a stale file\n     tmpf = f + '.tmp'\n-    returncode = subprocess.call([\"curl\", \"-o\", tmpf, u])\n+\n+    returncode = -1\n+    if distutils.spawn.find_executable(\"curl\"):\n+        returncode = subprocess.call([\"curl\", \"-o\", tmpf, u])\n+    elif distutils.spawn.find_executable(\"wget\"):\n+        returncode = subprocess.call([\"wget\", \"-O\", tmpf, u])\n+\n     if returncode != 0:\n         os.unlink(tmpf)\n         raise"}, {"sha": "afcbc0a9859d7aa1e2f9b2c29792cfc9fbf1f978", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -250,6 +250,7 @@ def emit_decomp_module(f, canon, compat):\n // The following code was generated by \"src/etc/unicode.py\"\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n ''')\n "}, {"sha": "f40bed8640dce16e2f0d46475a0e1c3c6f3eedc0", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -95,7 +95,7 @@ syn region    rustDeriving    start=\"deriving(\" end=\")\" contains=rustTrait\n \" Number literals\n syn match     rustNumber      display \"\\<[0-9][0-9_]*\\>\"\n syn match     rustNumber      display \"\\<[0-9][0-9_]*\\(u\\|u8\\|u16\\|u32\\|u64\\)\\>\"\n-syn match     rustNumber      display \"\\<[0-9][0-9_]*\\(i8\\|i16\\|i32\\|i64\\)\\>\"\n+syn match     rustNumber      display \"\\<[0-9][0-9_]*\\(i\\|i8\\|i16\\|i32\\|i64\\)\\>\"\n \n syn match     rustHexNumber   display \"\\<0x[a-fA-F0-9_]\\+\\>\"\n syn match     rustHexNumber   display \"\\<0x[a-fA-F0-9_]\\+\\(u\\|u8\\|u16\\|u32\\|u64\\)\\>\""}, {"sha": "3c1fc72e95783c14f5ff47a7c1a3654b9598c497", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 233, "deletions": 121, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,24 +10,59 @@\n \n //! Base64 binary-to-text encoding\n \n+/// Available encoding character sets\n+pub enum CharacterSet {\n+    /// The standard character set (uses '+' and '/')\n+    Standard,\n+    /// The URL safe character set (uses '-' and '_')\n+    UrlSafe\n+}\n \n-use std::vec;\n-\n-/// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 {\n-    /// Converts the value of `self` to a base64 value, returning the owned\n-    /// string\n-    fn to_base64(&self) -> ~str;\n+/// Contains configuration parameters for to_base64\n+pub struct Config {\n+    /// Character set to use\n+    char_set: CharacterSet,\n+    /// True to pad output with '=' characters\n+    pad: bool,\n+    /// Some(len) to wrap lines at len, None to disable line wrapping\n+    line_length: Option<uint>\n }\n \n-static CHARS: [char, ..64] = [\n+/// Configuration for RFC 4648 standard base64 encoding\n+pub static STANDARD: Config =\n+    Config {char_set: Standard, pad: true, line_length: None};\n+\n+/// Configuration for RFC 4648 base64url encoding\n+pub static URL_SAFE: Config =\n+    Config {char_set: UrlSafe, pad: false, line_length: None};\n+\n+/// Configuration for RFC 2045 MIME base64 encoding\n+pub static MIME: Config =\n+    Config {char_set: Standard, pad: true, line_length: Some(76)};\n+\n+static STANDARD_CHARS: [char, ..64] = [\n     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n ];\n \n+static URLSAFE_CHARS: [char, ..64] = [\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+];\n+\n+/// A trait for converting a value to base64 encoding.\n+pub trait ToBase64 {\n+    /// Converts the value of `self` to a base64 value following the specified\n+    /// format configuration, returning the owned string.\n+    fn to_base64(&self, config: Config) -> ~str;\n+}\n+\n impl<'self> ToBase64 for &'self [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n@@ -36,55 +71,81 @@ impl<'self> ToBase64 for &'self [u8] {\n      *\n      * ~~~ {.rust}\n      * extern mod extra;\n-     * use extra::base64::ToBase64;\n+     * use extra::base64::{ToBase64, standard};\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64();\n+     *     let str = [52,32].to_base64(standard);\n      *     println(fmt!(\"%s\", str));\n      * }\n      * ~~~\n      */\n-    fn to_base64(&self) -> ~str {\n+    fn to_base64(&self, config: Config) -> ~str {\n+        let chars = match config.char_set {\n+            Standard => STANDARD_CHARS,\n+            UrlSafe => URLSAFE_CHARS\n+        };\n+\n         let mut s = ~\"\";\n+        let mut i = 0;\n+        let mut cur_length = 0;\n         let len = self.len();\n-        s.reserve(((len + 3u) / 4u) * 3u);\n+        while i < len - (len % 3) {\n+            match config.line_length {\n+                Some(line_length) =>\n+                    if cur_length >= line_length {\n+                        s.push_str(\"\\r\\n\");\n+                        cur_length = 0;\n+                    },\n+                None => ()\n+            }\n \n-        let mut i = 0u;\n-\n-        while i < len - (len % 3u) {\n-            let n = (self[i] as uint) << 16u |\n-                    (self[i + 1u] as uint) << 8u |\n-                    (self[i + 2u] as uint);\n+            let n = (self[i] as u32) << 16 |\n+                    (self[i + 1] as u32) << 8 |\n+                    (self[i + 2] as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char(CHARS[(n >> 6u) & 63u]);\n-            s.push_char(CHARS[n & 63u]);\n+            s.push_char(chars[(n >> 18) & 63]);\n+            s.push_char(chars[(n >> 12) & 63]);\n+            s.push_char(chars[(n >> 6 ) & 63]);\n+            s.push_char(chars[n & 63]);\n+\n+            cur_length += 4;\n+            i += 3;\n+        }\n \n-            i += 3u;\n+        if len % 3 != 0 {\n+            match config.line_length {\n+                Some(line_length) =>\n+                    if cur_length >= line_length {\n+                        s.push_str(\"\\r\\n\");\n+                    },\n+                None => ()\n+            }\n         }\n \n         // Heh, would be cool if we knew this was exhaustive\n         // (the dream of bounded integer types)\n         match len % 3 {\n-          0 => (),\n-          1 => {\n-            let n = (self[i] as uint) << 16u;\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char('=');\n-            s.push_char('=');\n-          }\n-          2 => {\n-            let n = (self[i] as uint) << 16u |\n-                (self[i + 1u] as uint) << 8u;\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char(CHARS[(n >> 6u) & 63u]);\n-            s.push_char('=');\n-          }\n-          _ => fail!(\"Algebra is broken, please alert the math police\")\n+            0 => (),\n+            1 => {\n+                let n = (self[i] as u32) << 16;\n+                s.push_char(chars[(n >> 18) & 63]);\n+                s.push_char(chars[(n >> 12) & 63]);\n+                if config.pad {\n+                    s.push_str(\"==\");\n+                }\n+            }\n+            2 => {\n+                let n = (self[i] as u32) << 16 |\n+                    (self[i + 1u] as u32) << 8;\n+                s.push_char(chars[(n >> 18) & 63]);\n+                s.push_char(chars[(n >> 12) & 63]);\n+                s.push_char(chars[(n >> 6 ) & 63]);\n+                if config.pad {\n+                    s.push_char('=');\n+                }\n+            }\n+            _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n         s\n     }\n@@ -99,23 +160,25 @@ impl<'self> ToBase64 for &'self str {\n      *\n      * ~~~ {.rust}\n      * extern mod extra;\n-     * use extra::base64::ToBase64;\n+     * use extra::base64::{ToBase64, standard};\n      *\n      * fn main () {\n-     *     let str = \"Hello, World\".to_base64();\n+     *     let str = \"Hello, World\".to_base64(standard);\n      *     println(fmt!(\"%s\",str));\n      * }\n      * ~~~\n      *\n      */\n-    fn to_base64(&self) -> ~str {\n-        self.as_bytes().to_base64()\n+    fn to_base64(&self, config: Config) -> ~str {\n+        self.as_bytes().to_base64(config)\n     }\n }\n \n-#[allow(missing_doc)]\n+/// A trait for converting from base64 encoded values.\n pub trait FromBase64 {\n-    fn from_base64(&self) -> ~[u8];\n+    /// Converts the value of `self`, interpreted as base64 encoded data, into\n+    /// an owned vector of bytes, returning the vector.\n+    fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n impl<'self> FromBase64 for &'self [u8] {\n@@ -127,69 +190,64 @@ impl<'self> FromBase64 for &'self [u8] {\n      *\n      * ~~~ {.rust}\n      * extern mod extra;\n-     * use extra::base64::ToBase64;\n-     * use extra::base64::FromBase64;\n+     * use extra::base64::{ToBase64, FromBase64, standard};\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64();\n+     *     let str = [52,32].to_base64(standard);\n      *     println(fmt!(\"%s\", str));\n      *     let bytes = str.from_base64();\n      *     println(fmt!(\"%?\",bytes));\n      * }\n      * ~~~\n      */\n-    fn from_base64(&self) -> ~[u8] {\n-        if self.len() % 4u != 0u { fail!(\"invalid base64 length\"); }\n+    fn from_base64(&self) -> Result<~[u8], ~str> {\n+        let mut r = ~[];\n+        let mut buf: u32 = 0;\n+        let mut modulus = 0;\n \n-        let len = self.len();\n-        let mut padding = 0u;\n+        let mut it = self.iter();\n+        for it.advance |&byte| {\n+            let ch = byte as char;\n+            let val = byte as u32;\n \n-        if len != 0u {\n-            if self[len - 1u] == '=' as u8 { padding += 1u; }\n-            if self[len - 2u] == '=' as u8 { padding += 1u; }\n-        }\n+            match ch {\n+                'A'..'Z'  => buf |= val - 0x41,\n+                'a'..'z'  => buf |= val - 0x47,\n+                '0'..'9'  => buf |= val + 0x04,\n+                '+'|'-'   => buf |= 0x3E,\n+                '/'|'_'   => buf |= 0x3F,\n+                '\\r'|'\\n' => loop,\n+                '='       => break,\n+                _         => return Err(~\"Invalid Base64 character\")\n+            }\n \n-        let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n-\n-        let mut i = 0u;\n-        while i < len {\n-            let mut n = 0u;\n-\n-            for 4u.times {\n-                let ch = self[i] as char;\n-                n <<= 6u;\n-\n-                match ch {\n-                    'A'..'Z' => n |= (ch as uint) - 0x41,\n-                    'a'..'z' => n |= (ch as uint) - 0x47,\n-                    '0'..'9' => n |= (ch as uint) + 0x04,\n-                    '+'      => n |= 0x3E,\n-                    '/'      => n |= 0x3F,\n-                    '='      => {\n-                        match len - i {\n-                            1u => {\n-                                r.push(((n >> 16u) & 0xFFu) as u8);\n-                                r.push(((n >> 8u ) & 0xFFu) as u8);\n-                                return copy r;\n-                            }\n-                            2u => {\n-                                r.push(((n >> 10u) & 0xFFu) as u8);\n-                                return copy r;\n-                            }\n-                            _ => fail!(\"invalid base64 padding\")\n-                        }\n-                    }\n-                    _ => fail!(\"invalid base64 character\")\n-                }\n+            buf <<= 6;\n+            modulus += 1;\n+            if modulus == 4 {\n+                modulus = 0;\n+                r.push((buf >> 22) as u8);\n+                r.push((buf >> 14) as u8);\n+                r.push((buf >> 6 ) as u8);\n+            }\n+        }\n \n-                i += 1u;\n-            };\n+        if !it.all(|&byte| {byte as char == '='}) {\n+            return Err(~\"Invalid Base64 character\");\n+        }\n \n-            r.push(((n >> 16u) & 0xFFu) as u8);\n-            r.push(((n >> 8u ) & 0xFFu) as u8);\n-            r.push(((n       ) & 0xFFu) as u8);\n+        match modulus {\n+            2 => {\n+                r.push((buf >> 10) as u8);\n+            }\n+            3 => {\n+                r.push((buf >> 16) as u8);\n+                r.push((buf >> 8 ) as u8);\n+            }\n+            0 => (),\n+            _ => return Err(~\"Invalid Base64 length\")\n         }\n-        r\n+\n+        Ok(r)\n     }\n }\n \n@@ -199,20 +257,20 @@ impl<'self> FromBase64 for &'self str {\n      * to the byte values it encodes.\n      *\n      * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those values.\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n      * This converts a string literal to base64 and back.\n      *\n      * ~~~ {.rust}\n      * extern mod extra;\n-     * use extra::base64::ToBase64;\n-     * use extra::base64::FromBase64;\n+     * use extra::base64::{ToBase64, FromBase64, standard};\n      * use std::str;\n      *\n      * fn main () {\n-     *     let hello_str = \"Hello, World\".to_base64();\n+     *     let hello_str = \"Hello, World\".to_base64(standard);\n      *     println(fmt!(\"%s\",hello_str));\n      *     let bytes = hello_str.from_base64();\n      *     println(fmt!(\"%?\",bytes));\n@@ -221,32 +279,86 @@ impl<'self> FromBase64 for &'self str {\n      * }\n      * ~~~\n      */\n-    fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> Result<~[u8], ~str> {\n         self.as_bytes().from_base64()\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_to_base64() {\n-        assert_eq!(\"\".to_base64(), ~\"\");\n-        assert_eq!(\"f\".to_base64(), ~\"Zg==\");\n-        assert_eq!(\"fo\".to_base64(), ~\"Zm8=\");\n-        assert_eq!(\"foo\".to_base64(), ~\"Zm9v\");\n-        assert_eq!(\"foob\".to_base64(), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".to_base64(), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".to_base64(), ~\"Zm9vYmFy\");\n-    }\n+#[test]\n+fn test_to_base64_basic() {\n+    assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n+    assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n+    assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n+    assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n+    assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n+    assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n+    assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n+}\n+\n+#[test]\n+fn test_to_base64_line_break() {\n+    assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n+        .contains(\"\\r\\n\"));\n+    assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n+        ~\"Zm9v\\r\\nYmFy\");\n+}\n+\n+#[test]\n+fn test_to_base64_padding() {\n+    assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n+    assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+}\n+\n+#[test]\n+fn test_to_base64_url_safe() {\n+    assert_eq!([251, 255].to_base64(URL_SAFE), ~\"-_8\");\n+    assert_eq!([251, 255].to_base64(STANDARD), ~\"+/8=\");\n+}\n+\n+#[test]\n+fn test_from_base64_basic() {\n+    assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n+    assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n+    assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n+}\n+\n+#[test]\n+fn test_from_base64_newlines() {\n+    assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n+        \"foobar\".as_bytes().to_owned());\n+}\n+\n+#[test]\n+fn test_from_base64_urlsafe() {\n+    assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n+}\n+\n+#[test]\n+fn test_from_base64_invalid_char() {\n+    assert!(\"Zm$=\".from_base64().is_err())\n+    assert!(\"Zg==$\".from_base64().is_err());\n+}\n+\n+#[test]\n+fn test_from_base64_invalid_padding() {\n+    assert!(\"Z===\".from_base64().is_err());\n+}\n+\n+#[test]\n+fn test_base64_random() {\n+    use std::rand::{task_rng, random, RngUtil};\n+    use std::vec;\n \n-    #[test]\n-    fn test_from_base64() {\n-        assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+    for 1000.times {\n+        let v: ~[u8] = do vec::build |push| {\n+            for task_rng().gen_uint_range(1, 100).times {\n+                push(random());\n+            }\n+        };\n+        assert_eq!(v.to_base64(STANDARD).from_base64().get(), v);\n     }\n }"}, {"sha": "72b6e6dc6500a02038c4b2b0b23a4cd05c0988cf", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -872,7 +872,7 @@ mod tests {\n     use std::rand;\n     use std::rand::Rng;\n \n-    static bench_bits : uint = 1 << 14;\n+    static BENCH_BITS : uint = 1 << 14;\n \n     #[test]\n     fn test_to_str() {\n@@ -1452,19 +1452,19 @@ mod tests {\n     fn bench_big_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut storage = ~[];\n-        storage.grow(bench_bits / uint::bits, &0);\n+        storage.grow(BENCH_BITS / uint::bits, &0);\n         let mut bitv = BigBitv::new(storage);\n         do b.iter {\n-            bitv.set((r.next() as uint) % bench_bits, true);\n+            bitv.set((r.next() as uint) % BENCH_BITS, true);\n         }\n     }\n \n     #[bench]\n     fn bench_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(bench_bits, false);\n+        let mut bitv = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n-            bitv.set((r.next() as uint) % bench_bits, true);\n+            bitv.set((r.next() as uint) % BENCH_BITS, true);\n         }\n     }\n \n@@ -1491,14 +1491,14 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n-            bitv.insert((r.next() as uint) % bench_bits);\n+            bitv.insert((r.next() as uint) % BENCH_BITS);\n         }\n     }\n \n     #[bench]\n     fn bench_bitv_big_union(b: &mut BenchHarness) {\n-        let mut b1 = Bitv::new(bench_bits, false);\n-        let b2 = Bitv::new(bench_bits, false);\n+        let mut b1 = Bitv::new(BENCH_BITS, false);\n+        let b2 = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n             b1.union(&b2);\n         }"}, {"sha": "0f2d44f57e34c457762a38ec3160cded370aca3e", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -240,7 +240,6 @@ impl Digest for Sha1 {\n \n #[cfg(test)]\n mod tests {\n-    use std::vec;\n \n     use digest::{Digest, DigestUtil};\n     use sha1::Sha1;\n@@ -337,7 +336,7 @@ mod tests {\n         for tests.iter().advance |t| {\n             (*sh).input_str(t.input);\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);\n@@ -357,7 +356,7 @@ mod tests {\n                 left = left - take;\n             }\n             sh.result(out);\n-            assert!(vec::eq(t.output, out));\n+            assert!(t.output.as_slice() == out);\n \n             let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);"}, {"sha": "36ebf295aabaa1f8d9f6364b0ad0372f012a7528", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 288, "deletions": 94, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,17 +11,17 @@\n //! A double-ended queue implemented as a circular buffer\n \n use std::uint;\n-use std::util::replace;\n use std::vec;\n-use std::cast::transmute;\n+use std::iterator::FromIterator;\n \n-static initial_capacity: uint = 32u; // 2^5\n+static INITIAL_CAPACITY: uint = 8u; // 2^3\n+static MINIMUM_CAPACITY: uint = 2u;\n \n #[allow(missing_doc)]\n+#[deriving(Clone)]\n pub struct Deque<T> {\n     priv nelts: uint,\n     priv lo: uint,\n-    priv hi: uint,\n     priv elts: ~[Option<T>]\n }\n \n@@ -39,26 +39,36 @@ impl<T> Mutable for Deque<T> {\n         for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n-        self.hi = 0;\n     }\n }\n \n impl<T> Deque<T> {\n     /// Create an empty Deque\n     pub fn new() -> Deque<T> {\n-        Deque{nelts: 0, lo: 0, hi: 0,\n-              elts: vec::from_fn(initial_capacity, |_| None)}\n+        Deque::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty Deque with space for at least `n` elements.\n+    pub fn with_capacity(n: uint) -> Deque<T> {\n+        Deque{nelts: 0, lo: 0,\n+              elts: vec::from_fn(uint::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.raw_index(0)) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+    pub fn peek_back<'a>(&'a self) -> &'a T {\n+        if self.nelts > 0 {\n+            get(self.elts, self.raw_index(self.nelts - 1))\n+        } else {\n+            fail!(\"peek_back: empty deque\");\n+        }\n+    }\n \n     /// Retrieve an element in the deque by index\n     ///\n@@ -68,16 +78,6 @@ impl<T> Deque<T> {\n         get(self.elts, idx)\n     }\n \n-    /// Iterate over the elements in the deque\n-    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n-        self.eachi(|_i, e| f(e))\n-    }\n-\n-    /// Iterate over the elements in the deque by index\n-    pub fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n-        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n-    }\n-\n     /// Remove and return the first element in the deque\n     ///\n     /// Fails if the deque is empty\n@@ -88,43 +88,39 @@ impl<T> Deque<T> {\n         result\n     }\n \n+    /// Return index in underlying vec for a given logical element index\n+    fn raw_index(&self, idx: uint) -> uint {\n+        raw_index(self.lo, self.elts.len(), idx)\n+    }\n+\n     /// Remove and return the last element in the deque\n     ///\n     /// Fails if the deque is empty\n     pub fn pop_back(&mut self) -> T {\n-        if self.hi == 0u {\n-            self.hi = self.elts.len() - 1u;\n-        } else { self.hi -= 1u; }\n-        let result = self.elts[self.hi].swap_unwrap();\n-        self.elts[self.hi] = None;\n-        self.nelts -= 1u;\n-        result\n+        self.nelts -= 1;\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi].swap_unwrap()\n     }\n \n     /// Prepend an element to the deque\n     pub fn add_front(&mut self, t: T) {\n-        let oldlo = self.lo;\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        }\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n         } else { self.lo -= 1u; }\n-        if self.lo == self.hi {\n-            self.elts = grow(self.nelts, oldlo, self.elts);\n-            self.lo = self.elts.len() - 1u;\n-            self.hi = self.nelts;\n-        }\n         self.elts[self.lo] = Some(t);\n         self.nelts += 1u;\n     }\n \n     /// Append an element to the deque\n     pub fn add_back(&mut self, t: T) {\n-        if self.lo == self.hi && self.nelts != 0u {\n-            self.elts = grow(self.nelts, self.lo, self.elts);\n-            self.lo = 0u;\n-            self.hi = self.nelts;\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n-        self.elts[self.hi] = Some(t);\n-        self.hi = (self.hi + 1u) % self.elts.len();\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n \n@@ -155,107 +151,155 @@ impl<T> Deque<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n-    DequeIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n-    DequeMutIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Back-to-front iterator.\n     pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-    DequeRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                         lo: self.lo}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n     pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-    DequeMutRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                            lo: self.lo}\n     }\n }\n \n macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $step:expr) => {\n+    (impl $name:ident -> $elem:ty, $getter:ident, $step:expr) => {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n-                if self.used >= self.nelts {\n+                if self.nelts == 0 {\n                     return None;\n                 }\n-                let ret = unsafe {\n-                    match self.vec[self.idx % self.vec.len()] {\n-                        Some(ref e) => Some(transmute(e)),\n-                        None => None\n-                    }\n-                };\n-                self.idx += $step;\n-                self.used += 1;\n-                ret\n+                let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n+                self.index += $step;\n+                self.nelts -= 1;\n+                Some(self.elts[raw_index]. $getter ())\n             }\n         }\n     }\n }\n \n /// Deque iterator\n pub struct DequeIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeIterator -> &'self T, 1}\n+iterator!{impl DequeIterator -> &'self T, get_ref, 1}\n \n /// Deque reverse iterator\n pub struct DequeRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeRevIterator -> &'self T, -1}\n+iterator!{impl DequeRevIterator -> &'self T, get_ref, -1}\n \n /// Deque mutable iterator\n pub struct DequeMutIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n-\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutIterator -> &'self mut T, 1}\n+iterator!{impl DequeMutIterator -> &'self mut T, get_mut_ref, 1}\n \n /// Deque mutable reverse iterator\n pub struct DequeMutRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutRevIterator -> &'self mut T, -1}\n+iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n-fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n+fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     assert_eq!(nelts, elts.len());\n-    let mut rv = ~[];\n-\n-    do rv.grow_fn(nelts + 1) |i| {\n-        replace(&mut elts[(lo + i) % nelts], None)\n+    let lo = *loptr;\n+    let newlen = nelts * 2;\n+    elts.reserve(newlen);\n+\n+    /* fill with None */\n+    for uint::range(elts.len(), elts.capacity()) |_| {\n+        elts.push(None);\n+    }\n+\n+    /*\n+      Move the shortest half into the newly reserved area.\n+      lo ---->|\n+      nelts ----------->|\n+        [o o o|o o o o o]\n+      A [. . .|o o o o o o o o|. . . . .]\n+      B [o o o|. . . . . . . .|o o o o o]\n+     */\n+\n+    assert!(newlen - nelts/2 >= nelts);\n+    if lo <= (nelts - lo) { // A\n+        for uint::range(0, lo) |i| {\n+            elts.swap(i, nelts + i);\n+        }\n+    } else {                // B\n+        for uint::range(lo, nelts) |i| {\n+            elts.swap(i, newlen - nelts + i);\n+        }\n+        *loptr += newlen - nelts;\n     }\n-\n-    rv\n }\n \n fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n     match elts[i] { Some(ref t) => t, _ => fail!() }\n }\n \n+/// Return index in underlying vec for a given logical element index\n+fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n+    if lo >= len - index {\n+        lo + index - len\n+    } else {\n+        lo + index\n+    }\n+}\n+\n+impl<A: Eq> Eq for Deque<A> {\n+    fn eq(&self, other: &Deque<A>) -> bool {\n+        self.nelts == other.nelts &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+    }\n+    fn ne(&self, other: &Deque<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n+    fn from_iterator(iterator: &mut T) -> Deque<A> {\n+        let mut deq = Deque::new();\n+        for iterator.advance |elt| {\n+            deq.add_back(elt);\n+        }\n+        deq\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::cmp::Eq;\n     use std::kinds::Copy;\n-    use std::int;\n+    use std::{int, uint};\n+    use extra::test;\n \n     #[test]\n     fn test_simple() {\n@@ -369,6 +413,61 @@ mod tests {\n         assert_eq!(copy *deq.get(3), copy d);\n     }\n \n+    #[test]\n+    fn test_add_front_grow() {\n+        let mut deq = Deque::new();\n+        for int::range(0, 66) |i| {\n+            deq.add_front(i);\n+        }\n+        assert_eq!(deq.len(), 66);\n+\n+        for int::range(0, 66) |i| {\n+            assert_eq!(*deq.get(i), 65 - i);\n+        }\n+\n+        let mut deq = Deque::new();\n+        for int::range(0, 66) |i| {\n+            deq.add_back(i);\n+        }\n+\n+        for int::range(0, 66) |i| {\n+            assert_eq!(*deq.get(i), i);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_new(b: &mut test::BenchHarness) {\n+        do b.iter {\n+            let _ = Deque::new::<u64>();\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_add_back(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            deq.add_back(0);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_add_front(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            deq.add_front(0);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_grow(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            for 65.times {\n+                deq.add_front(1);\n+            }\n+        }\n+    }\n+\n     #[deriving(Eq)]\n     enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n \n@@ -417,22 +516,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_eachi() {\n-        let mut deq = Deque::new();\n-        deq.add_back(1);\n-        deq.add_back(2);\n-        deq.add_back(3);\n-\n-        for deq.eachi |i, e| {\n-            assert_eq!(*e, i + 1);\n-        }\n-\n-        deq.pop_front();\n-\n-        for deq.eachi |i, e| {\n-            assert_eq!(*e, i + 2);\n-        }\n-\n+    fn test_with_capacity() {\n+        let mut d = Deque::with_capacity(0);\n+        d.add_back(1);\n+        assert_eq!(d.len(), 1);\n+        let mut d = Deque::with_capacity(50);\n+        d.add_back(1);\n+        assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n@@ -462,6 +552,8 @@ mod tests {\n     #[test]\n     fn test_iter() {\n         let mut d = Deque::new();\n+        assert_eq!(d.iter().next(), None);\n+\n         for int::range(0,5) |i| {\n             d.add_back(i);\n         }\n@@ -476,6 +568,8 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let mut d = Deque::new();\n+        assert_eq!(d.rev_iter().next(), None);\n+\n         for int::range(0,5) |i| {\n             d.add_back(i);\n         }\n@@ -486,4 +580,104 @@ mod tests {\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n+\n+    #[test]\n+    fn test_mut_iter() {\n+        let mut d = Deque::new();\n+        assert!(d.mut_iter().next().is_none());\n+\n+        for uint::range(0,3) |i| {\n+            d.add_front(i);\n+        }\n+\n+        for d.mut_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(*elt, 2 - i);\n+            *elt = i;\n+        }\n+\n+        {\n+            let mut it = d.mut_iter();\n+            assert_eq!(*it.next().unwrap(), 0);\n+            assert_eq!(*it.next().unwrap(), 1);\n+            assert_eq!(*it.next().unwrap(), 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mut_rev_iter() {\n+        let mut d = Deque::new();\n+        assert!(d.mut_rev_iter().next().is_none());\n+\n+        for uint::range(0,3) |i| {\n+            d.add_front(i);\n+        }\n+\n+        for d.mut_rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(*elt, i);\n+            *elt = i;\n+        }\n+\n+        {\n+            let mut it = d.mut_rev_iter();\n+            assert_eq!(*it.next().unwrap(), 0);\n+            assert_eq!(*it.next().unwrap(), 1);\n+            assert_eq!(*it.next().unwrap(), 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_iterator() {\n+        use std::iterator;\n+        let v = ~[1,2,3,4,5,6,7];\n+        let deq: Deque<int> = v.iter().transform(|&x| x).collect();\n+        let u: ~[int] = deq.iter().transform(|&x| x).collect();\n+        assert_eq!(u, v);\n+\n+        let mut seq = iterator::Counter::new(0u, 2).take_(256);\n+        let deq: Deque<uint> = seq.collect();\n+        for deq.iter().enumerate().advance |(i, &x)| {\n+            assert_eq!(2*i, x);\n+        }\n+        assert_eq!(deq.len(), 256);\n+    }\n+\n+    #[test]\n+    fn test_clone() {\n+        let mut d = Deque::new();\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        d.add_back(137);\n+        assert_eq!(d.len(), 4u);\n+        let mut e = d.clone();\n+        assert_eq!(e.len(), 4u);\n+        while !d.is_empty() {\n+            assert_eq!(d.pop_back(), e.pop_back());\n+        }\n+        assert_eq!(d.len(), 0u);\n+        assert_eq!(e.len(), 0u);\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        let mut d = Deque::new();\n+        assert_eq!(&d, &Deque::with_capacity(0));\n+        d.add_front(137);\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        let mut e = Deque::with_capacity(0);\n+        e.add_back(42);\n+        e.add_back(17);\n+        e.add_back(137);\n+        e.add_back(137);\n+        assert_eq!(&e, &d);\n+        e.pop_back();\n+        e.add_back(0);\n+        assert!(e != d);\n+        e.clear();\n+        assert_eq!(e, Deque::new());\n+    }\n }"}, {"sha": "502e45e1d4748c946a955215c1c4ffd27f06d38b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -748,7 +748,7 @@ pub mod writer {\n \n     // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n-    static debug: bool = true;\n+    static DEBUG: bool = true;\n \n     impl Encoder {\n         // used internally to emit things like the vector length and so on\n@@ -764,7 +764,7 @@ pub mod writer {\n             // efficiency.  When debugging, though, we can emit such\n             // labels and then they will be checked by decoder to\n             // try and check failures more quickly.\n-            if debug { self.wr_tagged_str(EsLabel as uint, label) }\n+            if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n         }\n     }\n "}, {"sha": "7bec1d600b43b80db5c4a983c33f70b2d982879c", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,7 +21,7 @@ Rust extras are part of the standard Rust distribution.\n */\n \n #[link(name = \"extra\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/libextra\")];\n \n@@ -40,10 +40,8 @@ pub mod uv_ll;\n \n // General io and system-services modules\n \n+#[path = \"net/mod.rs\"]\n pub mod net;\n-pub mod net_ip;\n-pub mod net_tcp;\n-pub mod net_url;\n \n // libuv modules\n pub mod uv;\n@@ -74,7 +72,6 @@ pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n pub mod priority_queue;\n-pub mod rope;\n pub mod smallintmap;\n \n pub mod sort;"}, {"sha": "88c61e60d86b4186cf8127ef3ae1494062640f56", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -39,20 +39,20 @@ pub mod rustrt {\n     }\n }\n \n-static lz_none : c_int = 0x0;   // Huffman-coding only.\n-static lz_fast : c_int = 0x1;   // LZ with only one probe\n-static lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n-static lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n+static LZ_NONE : c_int = 0x0;   // Huffman-coding only.\n+static LZ_FAST : c_int = 0x1;   // LZ with only one probe\n+static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n+static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n                                                    &mut outsz,\n-                                                   lz_norm);\n+                                                   LZ_NORM);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n@@ -63,7 +63,7 @@ pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res ="}, {"sha": "de0a988f94c8ee68e02db4914787215e4b240cfd", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -55,7 +55,6 @@ use std::io;\n use std::comm::GenericChan;\n use std::comm::GenericPort;\n use std::sys::size_of;\n-use std::vec;\n \n /**\n A FlatPort, consisting of a `BytePort` that receives byte vectors,\n@@ -274,7 +273,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n             }\n         };\n \n-        if vec::eq(command, CONTINUE) {\n+        if CONTINUE.as_slice() == command {\n             let msg_len = match self.byte_port.try_recv(size_of::<u64>()) {\n                 Some(bytes) => {\n                     io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n@@ -931,7 +930,7 @@ mod test {\n         fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n-            let bytes = CONTINUE.to_owned() + [0];\n+            let bytes = CONTINUE.to_owned() + &[0u8];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert!(res.is_none());\n@@ -955,7 +954,7 @@ mod test {\n                     1, sys::size_of::<u64>()) |len_bytes| {\n                     len_bytes.to_owned()\n                 };\n-                let bytes = CONTINUE.to_owned() + len_bytes + [0, 0, 0, 0];\n+                let bytes = CONTINUE.to_owned() + len_bytes + &[0u8, 0, 0, 0];\n \n                 let port = loader(bytes);\n "}, {"sha": "c481fb8f5440d0ffb7db302c8bb218bbc40d63d2", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -176,7 +176,7 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    opts.iter().position_(|opt| opt.name == nm)\n+    opts.iter().position(|opt| opt.name == nm)\n }\n \n /**"}, {"sha": "ad8dcf98317a45dcec1b6cf4b60dec65178d709d", "filename": "src/libextra/iter.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Composable internal iterators\n+\n+Internal iterators are functions implementing the protocol used by the `for` loop.\n+\n+An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n+breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n+tied to specific traits. For example:\n+\n+~~~ {.rust}\n+println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+~~~\n+\n+An external iterator object implementing the interface in the `iterator` module can be used as an\n+internal iterator by calling the `advance` method. For example:\n+\n+~~~ {.rust}\n+let xs = [0u, 1, 2, 3, 4, 5];\n+let ys = [30, 40, 50, 60];\n+let mut it = xs.iter().chain(ys.iter());\n+for it.advance |&x: &uint| {\n+    println(x.to_str());\n+}\n+~~~\n+\n+Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n+to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n+much easier to implement.\n+\n+*/\n+\n+use std::vec;\n+use std::cmp::Ord;\n+use std::option::{Option, Some, None};\n+use std::num::{One, Zero};\n+use std::ops::{Add, Mul};\n+\n+#[allow(missing_doc)]\n+pub trait FromIter<T> {\n+    /// Build a container with elements from an internal iterator.\n+    ///\n+    /// # Example:\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = ~[1, 2, 3];\n+    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+    /// assert_eq!(xs, ys);\n+    /// ~~~\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for any values yielded by an internal iterator.\n+ *\n+ * Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5];\n+ * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+ * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn any<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    for iter |x| {\n+        if predicate(x) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for all values yielded by an internal iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n+ * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If we ever break, iter will return false, so this will only return true\n+    // if predicate returns true for everything.\n+    iter(|x| predicate(x))\n+}\n+\n+/**\n+ * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5, 6];\n+ * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn find<T>(predicate: &fn(&T) -> bool,\n+               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    for iter |x| {\n+        if predicate(&x) {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+/**\n+ * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x > *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x < *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n+ * forces the iterator to yield borrowed pointers.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+ *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+ * }\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the sum of the items yielding by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n+}\n+\n+/**\n+ * Return the product of the items yielded by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+}\n+\n+impl<T> FromIter<T> for ~[T]{\n+    #[inline]\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n+        let mut v = ~[];\n+        for iter |x| { v.push(x) }\n+        v\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    use int;\n+    use uint;\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[1, 2, 3];\n+        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+        assert_eq!(xs, ys);\n+    }\n+\n+    #[test]\n+    fn test_any() {\n+        let xs = ~[1u, 2, 3, 4, 5];\n+        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+    }\n+\n+    #[test]\n+    fn test_all() {\n+        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n+        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        let xs = ~[1u, 2, 3, 4, 5, 6];\n+        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+    }\n+\n+    #[test]\n+    fn test_min() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+    }\n+\n+    #[test]\n+    fn test_sum() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+    }\n+\n+    #[test]\n+    fn test_empty_sum() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n+    }\n+\n+    #[test]\n+    fn test_product() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+    }\n+\n+    #[test]\n+    fn test_empty_product() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n+    }\n+}"}, {"sha": "67ffd53a0e80497d46619b15f895846592dea7ff", "filename": "src/libextra/json.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -24,7 +24,6 @@ use std::io::{WriterUtil, ReaderUtil};\n use std::io;\n use std::str;\n use std::to_str;\n-use std::vec;\n \n use serialize::Encodable;\n use serialize;\n@@ -482,22 +481,30 @@ pub fn to_pretty_str(json: &Json) -> ~str {\n     io::with_str_writer(|wr| to_pretty_writer(wr, json))\n }\n \n+static BUF_SIZE : uint = 64000;\n+\n #[allow(missing_doc)]\n pub struct Parser {\n     priv rdr: @io::Reader,\n+    priv buf: ~[char],\n+    priv buf_idx: uint,\n     priv ch: char,\n     priv line: uint,\n     priv col: uint,\n }\n \n /// Decode a json value from an io::reader\n pub fn Parser(rdr: @io::Reader) -> Parser {\n-    Parser {\n+    let mut p = Parser {\n         rdr: rdr,\n-        ch: rdr.read_char(),\n+        buf: rdr.read_chars(BUF_SIZE),\n+        buf_idx: 0,\n+        ch: 0 as char,\n         line: 1,\n-        col: 1,\n-    }\n+        col: 0,\n+    };\n+    p.bump();\n+    p\n }\n \n impl Parser {\n@@ -522,13 +529,26 @@ impl Parser {\n     fn eof(&self) -> bool { self.ch == -1 as char }\n \n     fn bump(&mut self) {\n-        self.ch = self.rdr.read_char();\n+        if self.eof() {\n+            return;\n+        }\n+\n+        self.col += 1u;\n+\n+        if self.buf_idx >= self.buf.len() {\n+            self.buf = self.rdr.read_chars(BUF_SIZE);\n+            if self.buf.len() == 0 {\n+                self.ch = -1 as char;\n+                return;\n+            }\n+            self.buf_idx = 0;\n+        }\n+        self.ch = self.buf[self.buf_idx];\n+        self.buf_idx += 1;\n \n         if self.ch == '\\n' {\n             self.line += 1u;\n             self.col = 1u;\n-        } else {\n-            self.col += 1u;\n         }\n     }\n \n@@ -941,7 +961,7 @@ impl serialize::Decoder for Decoder {\n         let name = match self.stack.pop() {\n             String(s) => s,\n             List(list) => {\n-                do vec::consume_reverse(list) |_i, v| {\n+                for list.consume_rev_iter().advance |v| {\n                     self.stack.push(v);\n                 }\n                 match self.stack.pop() {\n@@ -951,7 +971,7 @@ impl serialize::Decoder for Decoder {\n             }\n             ref json => fail!(\"invalid variant: %?\", *json),\n         };\n-        let idx = match names.iter().position_(|n| str::eq_slice(*n, name)) {\n+        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n             None => fail!(\"Unknown variant name: %?\", name),\n         };\n@@ -1059,7 +1079,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n-                do vec::consume_reverse(list) |_i, v| {\n+                for list.consume_rev_iter().advance |v| {\n                     self.stack.push(v);\n                 }\n                 len"}, {"sha": "6876b3510b6cadff24b6bd7f4c9ab491f16d626a", "filename": "src/libextra/net/ip.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -22,20 +22,20 @@ use std::str;\n use iotask = uv::iotask::IoTask;\n use interact = uv::iotask::interact;\n \n-use sockaddr_in = super::uv_ll::sockaddr_in;\n-use sockaddr_in6 = super::uv_ll::sockaddr_in6;\n-use addrinfo = super::uv_ll::addrinfo;\n-use uv_getaddrinfo_t = super::uv_ll::uv_getaddrinfo_t;\n-use uv_ip4_name = super::uv_ll::ip4_name;\n-use uv_ip4_port = super::uv_ll::ip4_port;\n-use uv_ip6_name = super::uv_ll::ip6_name;\n-use uv_ip6_port = super::uv_ll::ip6_port;\n-use uv_getaddrinfo = super::uv_ll::getaddrinfo;\n-use uv_freeaddrinfo = super::uv_ll::freeaddrinfo;\n-use create_uv_getaddrinfo_t = super::uv_ll::getaddrinfo_t;\n-use set_data_for_req = super::uv_ll::set_data_for_req;\n-use get_data_for_req = super::uv_ll::get_data_for_req;\n-use ll = super::uv_ll;\n+use sockaddr_in = uv_ll::sockaddr_in;\n+use sockaddr_in6 = uv_ll::sockaddr_in6;\n+use addrinfo = uv_ll::addrinfo;\n+use uv_getaddrinfo_t = uv_ll::uv_getaddrinfo_t;\n+use uv_ip4_name = uv_ll::ip4_name;\n+use uv_ip4_port = uv_ll::ip4_port;\n+use uv_ip6_name = uv_ll::ip6_name;\n+use uv_ip6_port = uv_ll::ip6_port;\n+use uv_getaddrinfo = uv_ll::getaddrinfo;\n+use uv_freeaddrinfo = uv_ll::freeaddrinfo;\n+use create_uv_getaddrinfo_t = uv_ll::getaddrinfo_t;\n+use set_data_for_req = uv_ll::set_data_for_req;\n+use get_data_for_req = uv_ll::get_data_for_req;\n+use ll = uv_ll;\n \n /// An IP address\n pub enum IpAddr {\n@@ -203,7 +203,7 @@ pub mod v4 {\n         }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-        } else if parts.iter().any_(|x| *x == 256u) {\n+        } else if parts.iter().any(|x| *x == 256u) {\n             Err(fmt!(\"invalid octal in addr '%s'\", ip))\n         } else {\n             Ok(Ipv4Rep {\n@@ -363,9 +363,9 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n #[cfg(test)]\n mod test {\n \n-    use net_ip::*;\n-    use net_ip::v4;\n-    use net_ip::v6;\n+    use net::ip::*;\n+    use net::ip::v4;\n+    use net::ip::v6;\n     use uv;\n \n     use std::result;", "previous_filename": "src/libextra/net_ip.rs"}, {"sha": "463260bd3dcdfc837fa18a7f730dd8d60d2ff7aa", "filename": "src/libextra/net/mod.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -13,13 +13,13 @@ Top-level module for network-related functionality.\n \n Basically, including this module gives you:\n \n-* `net_tcp`\n-* `net_ip`\n-* `net_url`\n+* `tcp`\n+* `ip`\n+* `url`\n \n See each of those three modules for documentation on what they do.\n */\n \n-pub use tcp = net_tcp;\n-pub use ip = net_ip;\n-pub use url = net_url;\n+pub mod tcp;\n+pub mod ip;\n+pub mod url;", "previous_filename": "src/libextra/net.rs"}, {"sha": "e0ed313bc02699c7c87e1c6ee8581c61c70243e7", "filename": "src/libextra/net/tcp.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Ftcp.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -16,7 +16,7 @@\n \n use future;\n use future_spawn = future::spawn;\n-use ip = net_ip;\n+use ip = net::ip;\n use uv;\n use uv::iotask;\n use uv::iotask::IoTask;", "previous_filename": "src/libextra/net_tcp.rs"}, {"sha": "307f75dc98bea13abed902c7765551255f088969", "filename": "src/libextra/net/url.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnet%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Furl.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -522,7 +522,7 @@ fn get_authority(rawurl: &str) ->\n     let host_is_end_plus_one: &fn() -> bool = || {\n         let xs = ['?', '#', '/'];\n         end+1 == len\n-            && !xs.iter().any_(|x| *x == (rawurl[end] as char))\n+            && !xs.iter().any(|x| *x == (rawurl[end] as char))\n     };\n \n     // finish up\n@@ -800,7 +800,7 @@ fn test_get_path() {\n #[cfg(test)]\n mod tests {\n \n-    use net_url::*;\n+    use net::url::*;\n \n     use std::hashmap::HashMap;\n ", "previous_filename": "src/libextra/net_url.rs"}, {"sha": "a0b95924e09dc46009514365cc421ac36009feb6", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -17,6 +17,7 @@ A BigInt is a combination of BigUint and Sign.\n */\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::int;\n@@ -206,7 +207,7 @@ impl Add<BigUint, BigUint> for BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let sum = do vec::from_fn(new_len) |i| {\n+        let mut sum = do vec::from_fn(new_len) |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -215,8 +216,8 @@ impl Add<BigUint, BigUint> for BigUint {\n             carry = hi;\n             lo\n         };\n-        if carry == 0 { return BigUint::new(sum) };\n-        return BigUint::new(sum + [carry]);\n+        if carry != 0 { sum.push(carry); }\n+        return BigUint::new(sum);\n     }\n }\n \n@@ -283,15 +284,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do a.data.iter().transform |ai| {\n+            let mut prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n             }.collect::<~[BigDigit]>();\n-            if carry == 0 { return BigUint::new(prod) };\n-            return BigUint::new(prod + [carry]);\n+            if carry != 0 { prod.push(carry); }\n+            return BigUint::new(prod);\n         }\n \n \n@@ -519,10 +520,12 @@ impl ToStrRadix for BigUint {\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            let s = vec::reversed(v).map(|n| {\n-                let s = uint::to_str_radix(*n as uint, radix);\n-                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            }).concat();\n+            let mut s = str::with_capacity(v.len() * l);\n+            for v.rev_iter().advance |n| {\n+                let ss = uint::to_str_radix(*n as uint, radix);\n+                s.push_str(\"0\".repeat(l - ss.len()));\n+                s.push_str(ss);\n+            }\n             s.trim_left_chars(&'0').to_owned()\n         }\n     }\n@@ -618,15 +621,15 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do self.data.iter().transform |elem| {\n+        let mut shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n         }.collect::<~[BigDigit]>();\n-        if carry == 0 { return BigUint::new(shifted); }\n-        return BigUint::new(shifted + [carry]);\n+        if carry != 0 { shifted.push(carry); }\n+        return BigUint::new(shifted);\n     }\n \n \n@@ -1628,7 +1631,6 @@ mod bigint_tests {\n     use std::int;\n     use std::num::{IntConvertible, Zero, One, FromStrRadix};\n     use std::uint;\n-    use std::vec;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -1645,9 +1647,11 @@ mod bigint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let vs = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ];\n-        let mut nums = vec::reversed(vs)\n-            .map(|s| BigInt::from_slice(Minus, *s));\n+        let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let mut nums = ~[];\n+        for vs.rev_iter().advance |s| {\n+            nums.push(BigInt::from_slice(Minus, *s));\n+        }\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n "}, {"sha": "00224f8b06d985cca8b000684352166b0e972dc2", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -191,6 +191,8 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n \n #[cfg(test)]\n mod test {\n+    #[allow(non_uppercase_statics)];\n+\n     use super::*;\n     use std::num::{Zero,One,Real};\n "}, {"sha": "d737698cfe2ca0055c3ac16c8948f0fa84000bab", "filename": "src/libextra/par.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -20,10 +20,10 @@ use future_spawn = future::spawn;\n  * The maximum number of tasks this module will spawn for a single\n  * operation.\n  */\n-static max_tasks : uint = 32u;\n+static MAX_TASKS : uint = 32u;\n \n /// The minimum number of elements each task will process.\n-static min_granularity : uint = 1024u;\n+static MIN_GRANULARITY : uint = 1024u;\n \n /**\n  * An internal helper to map a function over a large vector and\n@@ -38,13 +38,13 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n     -> ~[B] {\n \n     let len = xs.len();\n-    if len < min_granularity {\n+    if len < MIN_GRANULARITY {\n         info!(\"small slice\");\n         // This is a small vector, fall back on the normal map.\n         ~[f()(0u, xs)]\n     }\n     else {\n-        let num_tasks = uint::min(max_tasks, len / min_granularity);\n+        let num_tasks = uint::min(MAX_TASKS, len / MIN_GRANULARITY);\n \n         let items_per_task = len / num_tasks;\n \n@@ -53,7 +53,7 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"spawning tasks\");\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n-            do vec::as_imm_buf(xs) |p, _len| {\n+            do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;\n                 let f = do future_spawn() || {\n@@ -78,11 +78,10 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n         assert_eq!(num_tasks, futures.len());\n \n-        let r = do vec::map_consume(futures) |ys| {\n+        do futures.consume_iter().transform |ys| {\n             let mut ys = ys;\n             ys.get()\n-        };\n-        r\n+        }.collect()\n     }\n }\n \n@@ -137,8 +136,8 @@ pub fn any<A:Copy + Send>(\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any_(f);\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n         result\n     });\n-    mapped.iter().any_(|&x| x)\n+    mapped.iter().any(|&x| x)\n }"}, {"sha": "1f7ba9f65303c824814e7a6ee2d5379ab9e8ba87", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -186,6 +186,9 @@ pub struct PriorityQueueIterator <'self, T> {\n impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self T)> { self.iter.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[cfg(test)]"}, {"sha": "8374c1a86e31da4d4b4463b5aee346a672b5b9ec", "filename": "src/libextra/rope.rs", "status": "removed", "additions": 0, "deletions": 1442, "changes": 1442, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -1,1442 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * High-level text containers.\n- *\n- * Ropes are a high-level representation of text that offers\n- * much better performance than strings for common operations,\n- * and generally reduce memory allocations and copies, while only\n- * entailing a small degradation of less common operations.\n- *\n- * More precisely, where a string is represented as a memory buffer,\n- * a rope is a tree structure whose leaves are slices of immutable\n- * strings. Therefore, concatenation, appending, prepending, substrings,\n- * etc. are operations that require only trivial tree manipulation,\n- * generally without having to copy memory. In addition, the tree\n- * structure of ropes makes them suitable as a form of index to speed-up\n- * access to Unicode characters by index in long chunks of text.\n- *\n- * The following operations are algorithmically faster in ropes:\n- *\n- * * extracting a subrope is logarithmic (linear in strings);\n- * * appending/prepending is near-constant time (linear in strings);\n- * * concatenation is near-constant time (linear in strings);\n- * * char length is constant-time (linear in strings);\n- * * access to a character by index is logarithmic (linear in strings);\n- */\n-\n-#[allow(missing_doc)];\n-\n-\n-use std::uint;\n-use std::vec;\n-use std::str;\n-\n-/// The type of ropes.\n-pub type Rope = node::Root;\n-\n-/*\n- Section: Creating a rope\n- */\n-\n-/// Create an empty rope\n-pub fn empty() -> Rope {\n-   return node::Empty;\n-}\n-\n-/**\n- * Adopt a string as a rope.\n- *\n- * # Arguments\n- *\n- * * str - A valid string.\n- *\n- * # Return value\n- *\n- * A rope representing the same string as `str`. Depending of the length\n- * of `str`, this rope may be empty, flat or complex.\n- *\n- * # Performance notes\n- *\n- * * this operation does not copy the string;\n- * * the function runs in linear time.\n- */\n-pub fn of_str(str: @~str) -> Rope {\n-    return of_substr(str, 0u, str.len());\n-}\n-\n-/**\n- * As `of_str` but for a substring.\n- *\n- * # Arguments\n- * * byte_offset - The offset of `str` at which the rope starts.\n- * * byte_len - The number of bytes of `str` to use.\n- *\n- * # Return value\n- *\n- * A rope representing the same string as `str.slice(byte_offset,\n- * byte_offset + byte_len)`.  Depending on `byte_len`, this rope may\n- * be empty, flat or complex.\n- *\n- * # Performance note\n- *\n- * This operation does not copy the substring.\n- *\n- * # Safety notes\n- *\n- * * this function does _not_ check the validity of the substring;\n- * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n- */\n-pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n-    if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str.len() { fail!(); }\n-    return node::Content(node::of_substr(str, byte_offset, byte_len));\n-}\n-\n-/*\n-Section: Adding things to a rope\n- */\n-\n-/**\n- * Add one char to the end of the rope\n- *\n- * # Performance note\n- *\n- * * this function executes in near-constant time\n- */\n-pub fn append_char(rope: Rope, char: char) -> Rope {\n-    return append_str(rope, @str::from_chars([char]));\n-}\n-\n-/**\n- * Add one string to the end of the rope\n- *\n- * # Performance note\n- *\n- * * this function executes in near-linear time\n- */\n-pub fn append_str(rope: Rope, str: @~str) -> Rope {\n-    return append_rope(rope, of_str(str))\n-}\n-\n-/**\n- * Add one char to the beginning of the rope\n- *\n- * # Performance note\n- * * this function executes in near-constant time\n- */\n-pub fn prepend_char(rope: Rope, char: char) -> Rope {\n-    return prepend_str(rope, @str::from_chars([char]));\n-}\n-\n-/**\n- * Add one string to the beginning of the rope\n- *\n- * # Performance note\n- * * this function executes in near-linear time\n- */\n-pub fn prepend_str(rope: Rope, str: @~str) -> Rope {\n-    return append_rope(of_str(str), rope)\n-}\n-\n-/// Concatenate two ropes\n-pub fn append_rope(left: Rope, right: Rope) -> Rope {\n-   match (left) {\n-     node::Empty => return right,\n-     node::Content(left_content) => {\n-       match (right) {\n-         node::Empty => return left,\n-         node::Content(right_content) => {\n-           return node::Content(node::concat2(left_content, right_content));\n-         }\n-       }\n-     }\n-   }\n-}\n-\n-/**\n- * Concatenate many ropes.\n- *\n- * If the ropes are balanced initially and have the same height, the resulting\n- * rope remains balanced. However, this function does not take any further\n- * measure to ensure that the result is balanced.\n- */\n-pub fn concat(v: ~[Rope]) -> Rope {\n-    //Copy `v` into a mut vector\n-    let mut len = v.len();\n-    if len == 0u { return node::Empty; }\n-    let mut ropes = vec::from_elem(len, v[0]);\n-    for uint::range(1u, len) |i| {\n-       ropes[i] = v[i];\n-    }\n-\n-    //Merge progresively\n-    while len > 1u {\n-        for uint::range(0u, len/2u) |i| {\n-            ropes[i] = append_rope(ropes[2u*i], ropes[2u*i+1u]);\n-        }\n-        if len%2u != 0u {\n-            ropes[len/2u] = ropes[len - 1u];\n-            len = len/2u + 1u;\n-        } else {\n-            len = len/2u;\n-        }\n-    }\n-\n-    //Return final rope\n-    return ropes[0];\n-}\n-\n-\n-/*\n-Section: Keeping ropes healthy\n- */\n-\n-\n-/**\n- * Balance a rope.\n- *\n- * # Return value\n- *\n- * A copy of the rope in which small nodes have been grouped in memory,\n- * and with a reduced height.\n- *\n- * If you perform numerous rope concatenations, it is generally a good idea\n- * to rebalance your rope at some point, before using it for other purposes.\n- */\n-pub fn bal(rope:Rope) -> Rope {\n-    match (rope) {\n-      node::Empty => return rope,\n-      node::Content(x) => match (node::bal(x)) {\n-        None    => rope,\n-        Some(y) => node::Content(y)\n-      }\n-    }\n-}\n-\n-/*\n-Section: Transforming ropes\n- */\n-\n-\n-/**\n- * Extract a subrope from a rope.\n- *\n- * # Performance note\n- *\n- * * on a balanced rope, this operation takes algorithmic time;\n- * * this operation does not involve any copying\n- *\n- * # Safety note\n- *\n- * * this function fails if char_offset/char_len do not represent\n- *   valid positions in rope\n- */\n-pub fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n-    if char_len == 0u { return node::Empty; }\n-    match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(node) => if char_len > node::char_len(node) {\n-        fail!()\n-      } else {\n-        return node::Content(node::sub_chars(node, char_offset, char_len))\n-      }\n-    }\n-}\n-\n-/**\n- * Extract a subrope from a rope.\n- *\n- * # Performance note\n- *\n- * * on a balanced rope, this operation takes algorithmic time;\n- * * this operation does not involve any copying\n- *\n- * # Safety note\n- *\n- * * this function fails if byte_offset/byte_len do not represent\n- *   valid positions in rope\n- */\n-pub fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n-    if byte_len == 0u { return node::Empty; }\n-    match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(node) =>if byte_len > node::byte_len(node) {\n-        fail!()\n-      } else {\n-        return node::Content(node::sub_bytes(node, byte_offset, byte_len))\n-      }\n-    }\n-}\n-\n-/*\n-Section: Comparing ropes\n- */\n-\n-/**\n- * Compare two ropes by Unicode lexicographical order.\n- *\n- * This function compares only the contents of the rope, not their structure.\n- *\n- * # Return value\n- *\n- * A negative value if `left < right`, 0 if eq(left, right) or a positive\n- * value if `left > right`\n- */\n-pub fn cmp(left: Rope, right: Rope) -> int {\n-    match ((left, right)) {\n-      (node::Empty, node::Empty) => return 0,\n-      (node::Empty, _)     => return -1,\n-      (_, node::Empty)     => return  1,\n-      (node::Content(a), node::Content(b)) => {\n-        return node::cmp(a, b);\n-      }\n-    }\n-}\n-\n-/**\n- * Returns `true` if both ropes have the same content (regardless of\n- * their structure), `false` otherwise\n- */\n-pub fn eq(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) == 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left <= right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn le(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) <= 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left < right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn lt(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) < 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- *  `true` if `left >= right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn ge(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) >= 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left > right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn gt(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) > 0;\n-}\n-\n-/*\n-Section: Iterating\n- */\n-\n-/**\n- * Loop through a rope, char by char\n- *\n- * While other mechanisms are available, this is generally the best manner\n- * of looping through the contents of a rope char by char. If you prefer a\n- * loop that iterates through the contents string by string (e.g. to print\n- * the contents of the rope or output it to the system), however,\n- * you should rather use `traverse_components`.\n- *\n- * # Arguments\n- *\n- * * rope - A rope to traverse. It may be empty.\n- * * it - A block to execute with each consecutive character of the rope.\n- *        Return `true` to continue, `false` to stop.\n- *\n- * # Return value\n- *\n- * `true` If execution proceeded correctly, `false` if it was interrupted,\n- * that is if `it` returned `false` at any point.\n- */\n-pub fn loop_chars(rope: Rope, it: &fn(c: char) -> bool) -> bool {\n-   match (rope) {\n-      node::Empty => return true,\n-      node::Content(x) => return node::loop_chars(x, it)\n-   }\n-}\n-\n-/**\n- * Loop through a rope, char by char, until the end.\n- *\n- * # Arguments\n- * * rope - A rope to traverse. It may be empty\n- * * it - A block to execute with each consecutive character of the rope.\n- */\n-pub fn iter_chars(rope: Rope, it: &fn(char)) {\n-    do loop_chars(rope) |x| {\n-        it(x);\n-        true\n-    };\n-}\n-\n-/**\n- * Loop through a rope, string by string\n- *\n- * While other mechanisms are available, this is generally the best manner of\n- * looping through the contents of a rope string by string, which may be\n- * useful e.g. to print strings as you see them (without having to copy their\n- * contents into a new string), to send them to then network, to write them to\n- * a file, etc.. If you prefer a loop that iterates through the contents\n- * char by char (e.g. to search for a char), however, you should rather\n- * use `traverse`.\n- *\n- * # Arguments\n- *\n- * * rope - A rope to traverse. It may be empty\n- * * it - A block to execute with each consecutive string component of the\n- *        rope. Return `true` to continue, `false` to stop\n- *\n- * # Return value\n- *\n- * `true` If execution proceeded correctly, `false` if it was interrupted,\n- * that is if `it` returned `false` at any point.\n- */\n-pub fn loop_leaves(rope: Rope, it: &fn(node::Leaf) -> bool) -> bool{\n-   match (rope) {\n-      node::Empty => return true,\n-      node::Content(x) => return node::loop_leaves(x, it)\n-   }\n-}\n-\n-pub mod iterator {\n-    pub mod leaf {\n-\n-        use rope::{Rope, node};\n-\n-        pub fn start(rope: Rope) -> node::leaf_iterator::T {\n-            match (rope) {\n-              node::Empty      => return node::leaf_iterator::empty(),\n-              node::Content(x) => return node::leaf_iterator::start(x)\n-            }\n-        }\n-        pub fn next(it: &mut node::leaf_iterator::T) -> Option<node::Leaf> {\n-            return node::leaf_iterator::next(it);\n-        }\n-    }\n-    pub mod char {\n-\n-        use rope::{Rope, node};\n-\n-        pub fn start(rope: Rope) -> node::char_iterator::T {\n-            match (rope) {\n-              node::Empty      => return node::char_iterator::empty(),\n-              node::Content(x) => return node::char_iterator::start(x)\n-            }\n-        }\n-        pub fn next(it: &mut node::char_iterator::T) -> Option<char> {\n-            return node::char_iterator::next(it)\n-        }\n-    }\n-}\n-\n-/*\n- Section: Rope properties\n- */\n-\n-/**\n- * Returns the height of the rope.\n- *\n- * The height of the rope is a bound on the number of operations which\n- * must be performed during a character access before finding the leaf in\n- * which a character is contained.\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn height(rope: Rope) -> uint {\n-   match (rope) {\n-      node::Empty      => return 0u,\n-      node::Content(x) => return node::height(x)\n-   }\n-}\n-\n-\n-\n-/**\n- * The number of character in the rope\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn char_len(rope: Rope) -> uint {\n-   match (rope) {\n-     node::Empty            => return 0u,\n-     node::Content(x)       => return node::char_len(x)\n-   }\n-}\n-\n-/**\n- * The number of bytes in the rope\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn byte_len(rope: Rope) -> uint {\n-   match (rope) {\n-     node::Empty            => return 0u,\n-     node::Content(x)       => return node::byte_len(x)\n-   }\n-}\n-\n-/**\n- * The character at position `pos`\n- *\n- * # Arguments\n- *\n- * * pos - A position in the rope\n- *\n- * # Safety notes\n- *\n- * The function will fail if `pos` is not a valid position in the rope.\n- *\n- * # Performance note\n- *\n- * This function executes in a time proportional to the height of the\n- * rope + the (bounded) length of the largest leaf.\n- */\n-pub fn char_at(rope: Rope, pos: uint) -> char {\n-   match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(x) => return node::char_at(x, pos)\n-   }\n-}\n-\n-\n-/*\n- Section: Implementation\n-*/\n-pub mod node {\n-\n-    use rope::node;\n-\n-    use std::cast;\n-    use std::uint;\n-    use std::vec;\n-\n-    /// Implementation of type `rope`\n-    pub enum Root {\n-        /// An empty rope\n-        Empty,\n-        /// A non-empty rope\n-        Content(@Node),\n-    }\n-\n-    /**\n-     * A text component in a rope.\n-     *\n-     * This is actually a slice in a rope, so as to ensure maximal sharing.\n-     *\n-     * # Fields\n-     *\n-     * * byte_offset = The number of bytes skipped in `content`\n-     * * byte_len - The number of bytes of `content` to use\n-     * * char_len - The number of chars in the leaf.\n-     * * content - Contents of the leaf.\n-     *\n-     *     Note that we can have `char_len < content.char_len()`, if\n-     *     this leaf is only a subset of the string. Also note that the\n-     *     string can be shared between several ropes, e.g. for indexing\n-     *     purposes.\n-     */\n-    pub struct Leaf {\n-        byte_offset: uint,\n-        byte_len: uint,\n-        char_len: uint,\n-        content: @~str,\n-    }\n-\n-    /**\n-     * A node obtained from the concatenation of two other nodes\n-     *\n-     * # Fields\n-     *\n-     * * left - The node containing the beginning of the text.\n-     * * right - The node containing the end of the text.\n-     * * char_len - The number of chars contained in all leaves of this node.\n-     * * byte_len - The number of bytes in the subrope.\n-     *\n-     *     Used to pre-allocate the correct amount of storage for\n-     *     serialization.\n-     *\n-     * * height - Height of the subrope.\n-     *\n-     *     Used for rebalancing and to allocate stacks for traversals.\n-     */\n-    pub struct Concat {\n-        //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n-        left: @Node,\n-        right: @Node,\n-        char_len: uint,\n-        byte_len: uint,\n-        height: uint,\n-    }\n-\n-    pub enum Node {\n-        /// A leaf consisting in a `str`\n-        Leaf(Leaf),\n-        /// The concatenation of two ropes\n-        Concat(Concat),\n-    }\n-\n-    /**\n-     * The maximal number of chars that _should_ be permitted in a single node\n-     *\n-     * This is not a strict value\n-     */\n-    pub static hint_max_leaf_char_len: uint = 256u;\n-\n-    /**\n-     * The maximal height that _should_ be permitted in a tree.\n-     *\n-     * This is not a strict value\n-     */\n-    pub static hint_max_node_height:   uint = 16u;\n-\n-    /**\n-     * Adopt a string as a node.\n-     *\n-     * If the string is longer than `max_leaf_char_len`, it is\n-     * logically split between as many leaves as necessary. Regardless,\n-     * the string itself is not copied.\n-     *\n-     * Performance note: The complexity of this function is linear in\n-     * the length of `str`.\n-     */\n-    pub fn of_str(str: @~str) -> @Node {\n-        return of_substr(str, 0u, str.len());\n-    }\n-\n-    /**\n-     * Adopt a slice of a string as a node.\n-     *\n-     * If the slice is longer than `max_leaf_char_len`, it is logically split\n-     * between as many leaves as necessary. Regardless, the string itself\n-     * is not copied\n-     *\n-     * # Arguments\n-     *\n-     * * byte_start - The byte offset where the slice of `str` starts.\n-     * * byte_len   - The number of bytes from `str` to use.\n-     *\n-     * # Safety note\n-     *\n-     * Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     * valid positions in `str`\n-     */\n-    pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n-        return of_substr_unsafer(str, byte_start, byte_len,\n-                                 str.slice(byte_start, byte_start + byte_len).char_len());\n-    }\n-\n-    /**\n-     * Adopt a slice of a string as a node.\n-     *\n-     * If the slice is longer than `max_leaf_char_len`, it is logically split\n-     * between as many leaves as necessary. Regardless, the string itself\n-     * is not copied\n-     *\n-     * # Arguments\n-     *\n-     * * byte_start - The byte offset where the slice of `str` starts.\n-     * * byte_len - The number of bytes from `str` to use.\n-     * * char_len - The number of chars in `str` in the interval\n-     *              [byte_start, byte_start+byte_len)\n-     *\n-     * # Safety notes\n-     *\n-     * * Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     *   valid positions in `str`\n-     * * Behavior is undefined if `char_len` does not accurately represent the\n-     *   number of chars between byte_start and byte_start+byte_len\n-     */\n-    pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n-                             char_len: uint) -> @Node {\n-        assert!((byte_start + byte_len <= str.len()));\n-        let candidate = @Leaf(Leaf {\n-            byte_offset: byte_start,\n-            byte_len: byte_len,\n-            char_len: char_len,\n-            content: str,\n-        });\n-        if char_len <= hint_max_leaf_char_len {\n-            return candidate;\n-        } else {\n-            //Firstly, split `str` in slices of hint_max_leaf_char_len\n-            let mut leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n-            //Number of leaves\n-            let mut nodes  = vec::from_elem(leaves, candidate);\n-\n-            let mut i = 0u;\n-            let mut offset = byte_start;\n-            let first_leaf_char_len =\n-                if char_len%hint_max_leaf_char_len == 0u {\n-                  hint_max_leaf_char_len\n-                } else {\n-                char_len%hint_max_leaf_char_len\n-               };\n-            while i < leaves {\n-                let chunk_char_len: uint =\n-                    if i == 0u  { first_leaf_char_len }\n-                    else { hint_max_leaf_char_len };\n-                let chunk_byte_len =\n-                    str.slice_from(offset).slice_chars(0, chunk_char_len).len();\n-                nodes[i] = @Leaf(Leaf {\n-                    byte_offset: offset,\n-                    byte_len: chunk_byte_len,\n-                    char_len: chunk_char_len,\n-                    content: str,\n-                });\n-\n-                offset += chunk_byte_len;\n-                i      += 1u;\n-            }\n-\n-            //Then, build a tree from these slices by collapsing them\n-            while leaves > 1u {\n-                i = 0u;\n-                while i < leaves - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n-                    nodes[i/2u] = concat2(nodes[i], nodes[i + 1u]);\n-                    i += 2u;\n-                }\n-                if i == leaves - 1u {\n-                    //And don't forget the last node if it is in even position\n-                    nodes[i/2u] = nodes[i];\n-                }\n-                leaves = uint::div_ceil(leaves, 2u);\n-            }\n-            return nodes[0u];\n-        }\n-    }\n-\n-    pub fn byte_len(node: @Node) -> uint {\n-        //FIXME (#2744): Could we do this without the pattern-matching?\n-        match (*node) {\n-          Leaf(y) => y.byte_len,\n-          Concat(ref y) => y.byte_len\n-        }\n-    }\n-\n-    pub fn char_len(node: @Node) -> uint {\n-        match (*node) {\n-          Leaf(y) => y.char_len,\n-          Concat(ref y) => y.char_len\n-        }\n-    }\n-\n-    /**\n-     * Concatenate a forest of nodes into one tree.\n-     *\n-     * # Arguments\n-     *\n-     * * forest - The forest. This vector is progressively rewritten during\n-     *            execution and should be discarded as meaningless afterwards.\n-     */\n-    pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n-        let mut i;\n-        let mut len = forest.len();\n-        while len > 1u {\n-            i = 0u;\n-            while i < len - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n-                let mut left  = forest[i];\n-                let mut right = forest[i+1u];\n-                let left_len = char_len(left);\n-                let right_len= char_len(right);\n-                let mut left_height= height(left);\n-                let mut right_height=height(right);\n-                if left_len + right_len > hint_max_leaf_char_len {\n-                    if left_len <= hint_max_leaf_char_len {\n-                        left = flatten(left);\n-                        left_height = height(left);\n-                    }\n-                    if right_len <= hint_max_leaf_char_len {\n-                        right = flatten(right);\n-                        right_height = height(right);\n-                    }\n-                }\n-                if left_height >= hint_max_node_height {\n-                    left = of_substr_unsafer(@serialize_node(left),\n-                                             0u,byte_len(left),\n-                                             left_len);\n-                }\n-                if right_height >= hint_max_node_height {\n-                    right = of_substr_unsafer(@serialize_node(right),\n-                                             0u,byte_len(right),\n-                                             right_len);\n-                }\n-                forest[i/2u] = concat2(left, right);\n-                i += 2u;\n-            }\n-            if i == len - 1u {\n-                //And don't forget the last node if it is in even position\n-                forest[i/2u] = forest[i];\n-            }\n-            len = uint::div_ceil(len, 2u);\n-        }\n-        return forest[0];\n-    }\n-\n-    pub fn serialize_node(node: @Node) -> ~str {\n-        unsafe {\n-            let mut buf = vec::from_elem(byte_len(node), 0);\n-            let mut offset = 0u;//Current position in the buffer\n-            let mut it = leaf_iterator::start(node);\n-            loop {\n-                match leaf_iterator::next(&mut it) {\n-                  None => break,\n-                  Some(x) => {\n-                    //FIXME (#2744): Replace with memcpy or something similar\n-                    let local_buf: ~[u8] = cast::transmute(copy *x.content);\n-                    let mut i = x.byte_offset;\n-                    while i < x.byte_len {\n-                        buf[offset] = local_buf[i];\n-                        offset += 1u;\n-                        i      += 1u;\n-                    }\n-                    cast::forget(local_buf);\n-                  }\n-                }\n-            }\n-            return cast::transmute(buf);\n-        }\n-    }\n-\n-    /**\n-     * Replace a subtree by a single leaf with the same contents.\n-     *\n-     * * Performance note\n-     *\n-     * This function executes in linear time.\n-     */\n-    pub fn flatten(node: @Node) -> @Node {\n-        match (*node) {\n-            Leaf(_) => node,\n-            Concat(ref x) => {\n-                @Leaf(Leaf {\n-                    byte_offset: 0u,\n-                    byte_len: x.byte_len,\n-                    char_len: x.char_len,\n-                    content: @serialize_node(node),\n-                })\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Balance a node.\n-     *\n-     * # Algorithm\n-     *\n-     * * if the node height is smaller than `hint_max_node_height`, do nothing\n-     * * otherwise, gather all leaves as a forest, rebuild a balanced node,\n-     *   concatenating small leaves along the way\n-     *\n-     * # Return value\n-     *\n-     * * `None` if no transformation happened\n-     * * `Some(x)` otherwise, in which case `x` has the same contents\n-     *    as `node` bot lower height and/or fragmentation.\n-     */\n-    pub fn bal(node: @Node) -> Option<@Node> {\n-        if height(node) < hint_max_node_height { return None; }\n-        //1. Gather all leaves as a forest\n-        let mut forest = ~[];\n-        let mut it = leaf_iterator::start(node);\n-        loop {\n-            match leaf_iterator::next(&mut it) {\n-              None    => break,\n-              Some(x) => forest.push(@Leaf(x))\n-            }\n-        }\n-        //2. Rebuild tree from forest\n-        let root = @*tree_from_forest_destructive(forest);\n-        return Some(root);\n-\n-    }\n-\n-    /**\n-     * Compute the subnode of a node.\n-     *\n-     * # Arguments\n-     *\n-     * * node        - A node\n-     * * byte_offset - A byte offset in `node`\n-     * * byte_len    - The number of bytes to return\n-     *\n-     * # Performance notes\n-     *\n-     * * this function performs no copying;\n-     * * this function executes in a time proportional to the height of `node`\n-     *\n-     * # Safety notes\n-     *\n-     * This function fails if `byte_offset` or `byte_len` do not represent\n-     * valid positions in `node`.\n-     */\n-    pub fn sub_bytes(node: @Node, byte_offset: uint,\n-                     byte_len: uint) -> @Node {\n-        let mut node        = node;\n-        let mut byte_offset = byte_offset;\n-        loop {\n-            if byte_offset == 0u && byte_len == node::byte_len(node) {\n-                return node;\n-            }\n-            match (*node) {\n-              node::Leaf(x) => {\n-                let char_len =\n-                    x.content.slice(byte_offset, byte_offset + byte_len).char_len();\n-                return @Leaf(Leaf {\n-                    byte_offset: byte_offset,\n-                    byte_len: byte_len,\n-                    char_len: char_len,\n-                    content: x.content,\n-                });\n-              }\n-              node::Concat(ref x) => {\n-                let left_len: uint = node::byte_len(x.left);\n-                if byte_offset <= left_len {\n-                    if byte_offset + byte_len <= left_len {\n-                        //Case 1: Everything fits in x.left, tail-call\n-                        node = x.left;\n-                    } else {\n-                        //Case 2: A (non-empty, possibly full) suffix\n-                        //of x.left and a (non-empty, possibly full) prefix\n-                        //of x.right\n-                        let left_result  =\n-                            sub_bytes(x.left, byte_offset, left_len);\n-                        let right_result =\n-                            sub_bytes(x.right, 0u, left_len - byte_offset);\n-                        return concat2(left_result, right_result);\n-                    }\n-                } else {\n-                    //Case 3: Everything fits in x.right\n-                    byte_offset -= left_len;\n-                    node = x.right;\n-                }\n-              }\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Compute the subnode of a node.\n-     *\n-     * # Arguments\n-     *\n-     * * node        - A node\n-     * * char_offset - A char offset in `node`\n-     * * char_len    - The number of chars to return\n-     *\n-     * # Performance notes\n-     *\n-     * * this function performs no copying;\n-     * * this function executes in a time proportional to the height of `node`\n-     *\n-     * # Safety notes\n-     *\n-     * This function fails if `char_offset` or `char_len` do not represent\n-     * valid positions in `node`.\n-     */\n-    pub fn sub_chars(node: @Node, char_offset: uint,\n-                     char_len: uint) -> @Node {\n-        let mut node        = node;\n-        let mut char_offset = char_offset;\n-        loop {\n-            match (*node) {\n-              node::Leaf(x) => {\n-                if char_offset == 0u && char_len == x.char_len {\n-                    return node;\n-                }\n-                let byte_offset =\n-                    x.content.slice_chars(0, char_offset).len();\n-                let byte_len    =\n-                    x.content.slice_from(byte_offset).slice_chars(0, char_len).len();\n-                return @Leaf(Leaf {\n-                    byte_offset: byte_offset,\n-                    byte_len: byte_len,\n-                    char_len: char_len,\n-                    content: x.content,\n-                });\n-              }\n-              node::Concat(ref x) => {\n-                if char_offset == 0u && char_len == x.char_len {return node;}\n-                let left_len : uint = node::char_len(x.left);\n-                if char_offset <= left_len {\n-                    if char_offset + char_len <= left_len {\n-                        //Case 1: Everything fits in x.left, tail call\n-                        node        = x.left;\n-                    } else {\n-                        //Case 2: A (non-empty, possibly full) suffix\n-                        //of x.left and a (non-empty, possibly full) prefix\n-                        //of x.right\n-                        let left_result  =\n-                            sub_chars(x.left, char_offset, left_len);\n-                        let right_result =\n-                            sub_chars(x.right, 0u, left_len - char_offset);\n-                        return concat2(left_result, right_result);\n-                    }\n-                } else {\n-                    //Case 3: Everything fits in x.right, tail call\n-                    node = x.right;\n-                    char_offset -= left_len;\n-                }\n-              }\n-            }\n-        };\n-    }\n-\n-    pub fn concat2(left: @Node, right: @Node) -> @Node {\n-        @Concat(Concat {\n-            left: left,\n-            right: right,\n-            char_len: char_len(left) + char_len(right),\n-            byte_len: byte_len(left) + byte_len(right),\n-            height: uint::max(height(left), height(right)) + 1u,\n-        })\n-    }\n-\n-    pub fn height(node: @Node) -> uint {\n-        match (*node) {\n-          Leaf(_) => 0u,\n-          Concat(ref x) => x.height,\n-        }\n-    }\n-\n-    pub fn cmp(a: @Node, b: @Node) -> int {\n-        let mut ita = char_iterator::start(a);\n-        let mut itb = char_iterator::start(b);\n-        let mut result = 0;\n-        while result == 0 {\n-            match (char_iterator::next(&mut ita), char_iterator::next(&mut itb))\n-            {\n-              (None, None) => break,\n-              (Some(chara), Some(charb)) => {\n-                result = chara.cmp(&charb) as int;\n-              }\n-              (Some(_), _) => {\n-                result = 1;\n-              }\n-              (_, Some(_)) => {\n-                result = -1;\n-              }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n-        return loop_leaves(node,|leaf| {\n-            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(|c| it(c))\n-        });\n-    }\n-\n-    /**\n-     * Loop through a node, leaf by leaf\n-     *\n-     * # Arguments\n-     *\n-     * * rope - A node to traverse.\n-     * * it - A block to execute with each consecutive leaf of the node.\n-     *        Return `true` to continue, `false` to stop\n-     *\n-     * # Arguments\n-     *\n-     * `true` If execution proceeded correctly, `false` if it was interrupted,\n-     * that is if `it` returned `false` at any point.\n-     */\n-    pub fn loop_leaves(node: @Node, it: &fn(Leaf) -> bool) -> bool{\n-        let mut current = node;\n-        loop {\n-            match (*current) {\n-              Leaf(x) => return it(x),\n-              Concat(ref x) => if loop_leaves(x.left, |l| it(l)) { //non tail call\n-                current = x.right;       //tail call\n-              } else {\n-                return false;\n-              }\n-            }\n-        };\n-    }\n-\n-    /**\n-     * # Arguments\n-     *\n-     * * pos - A position in the rope\n-     *\n-     * # Return value\n-     *\n-     * The character at position `pos`\n-     *\n-     * # Safety notes\n-     *\n-     * The function will fail if `pos` is not a valid position in the rope.\n-     *\n-     * Performance note: This function executes in a time\n-     * proportional to the height of the rope + the (bounded)\n-     * length of the largest leaf.\n-     */\n-    pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n-        loop {\n-            match *node {\n-              Leaf(x) => return x.content.char_at(pos),\n-              Concat(Concat {left, right, _}) => {\n-                let left_len = char_len(left);\n-                node = if left_len > pos { left }\n-                       else { pos -= left_len; right };\n-              }\n-            }\n-        };\n-    }\n-\n-    pub mod leaf_iterator {\n-\n-        use rope::node::{Concat, Leaf, Node, height};\n-\n-        use std::vec;\n-\n-        pub struct T {\n-            stack: ~[@Node],\n-            stackpos: int,\n-        }\n-\n-        pub fn empty() -> T {\n-            let stack : ~[@Node] = ~[];\n-            T { stack: stack, stackpos: -1 }\n-        }\n-\n-        pub fn start(node: @Node) -> T {\n-            let stack = vec::from_elem(height(node)+1u, node);\n-            T {\n-                stack: stack,\n-                stackpos:  0,\n-            }\n-        }\n-\n-        pub fn next(it: &mut T) -> Option<Leaf> {\n-            if it.stackpos < 0 { return None; }\n-            loop {\n-                let current = it.stack[it.stackpos];\n-                it.stackpos -= 1;\n-                match (*current) {\n-                  Concat(ref x) => {\n-                    it.stackpos += 1;\n-                    it.stack[it.stackpos] = x.right;\n-                    it.stackpos += 1;\n-                    it.stack[it.stackpos] = x.left;\n-                  }\n-                  Leaf(x) => return Some(x)\n-                }\n-            };\n-        }\n-    }\n-\n-    pub mod char_iterator {\n-\n-        use rope::node::{Leaf, Node};\n-        use rope::node::leaf_iterator;\n-\n-        pub struct T {\n-            leaf_iterator: leaf_iterator::T,\n-            leaf:  Option<Leaf>,\n-            leaf_byte_pos: uint,\n-        }\n-\n-        pub fn start(node: @Node) -> T {\n-            T {\n-                leaf_iterator: leaf_iterator::start(node),\n-                leaf: None,\n-                leaf_byte_pos: 0u,\n-            }\n-        }\n-\n-        pub fn empty() -> T {\n-            T {\n-                leaf_iterator: leaf_iterator::empty(),\n-                leaf: None,\n-                leaf_byte_pos: 0u,\n-            }\n-        }\n-\n-        pub fn next(it: &mut T) -> Option<char> {\n-            loop {\n-                match get_current_or_next_leaf(it) {\n-                  None => return None,\n-                  Some(_) => {\n-                    let next_char = get_next_char_in_leaf(it);\n-                    match next_char {\n-                      None => loop,\n-                      Some(_) => return next_char\n-                    }\n-                  }\n-                }\n-            };\n-        }\n-\n-        pub fn get_current_or_next_leaf(it: &mut T) -> Option<Leaf> {\n-            match it.leaf {\n-              Some(_) => return it.leaf,\n-              None => {\n-                let next = leaf_iterator::next(&mut it.leaf_iterator);\n-                match next {\n-                  None => return None,\n-                  Some(_) => {\n-                    it.leaf          = next;\n-                    it.leaf_byte_pos = 0u;\n-                    return next;\n-                  }\n-                }\n-              }\n-            }\n-        }\n-\n-        pub fn get_next_char_in_leaf(it: &mut T) -> Option<char> {\n-            match copy it.leaf {\n-              None => return None,\n-              Some(aleaf) => {\n-                if it.leaf_byte_pos >= aleaf.byte_len {\n-                    //We are actually past the end of the leaf\n-                    it.leaf = None;\n-                    return None\n-                } else {\n-                    let range =\n-                        aleaf.content.char_range_at((*it).leaf_byte_pos + aleaf.byte_offset);\n-                    let ch = range.ch;\n-                    let next = range.next;\n-                    (*it).leaf_byte_pos = next - aleaf.byte_offset;\n-                    return Some(ch)\n-                }\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use rope::*;\n-\n-    use std::uint;\n-    use std::vec;\n-\n-    //Utility function, used for sanity check\n-    fn rope_to_string(r: Rope) -> ~str {\n-        match (r) {\n-          node::Empty => return ~\"\",\n-          node::Content(x) => {\n-            let mut str = ~\"\";\n-            fn aux(str: &mut ~str, node: @node::Node) {\n-                match (*node) {\n-                    node::Leaf(x) => {\n-                        str.push_str(x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n-                    }\n-                    node::Concat(ref x) => {\n-                        aux(str, x.left);\n-                        aux(str, x.right);\n-                    }\n-                }\n-            }\n-            aux(&mut str, x);\n-            return str\n-          }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn trivial() {\n-        assert_eq!(char_len(empty()), 0u);\n-        assert_eq!(byte_len(empty()), 0u);\n-    }\n-\n-    #[test]\n-    fn of_string1() {\n-        let sample = @~\"0123456789ABCDE\";\n-        let r      = of_str(sample);\n-\n-        assert_eq!(char_len(r), sample.char_len());\n-        assert!(rope_to_string(r) == *sample);\n-    }\n-\n-    #[test]\n-    fn of_string2() {\n-        let buf = @ mut ~\"1234567890\";\n-        let mut i = 0;\n-        while i < 10 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r      = of_str(sample);\n-        assert_eq!(char_len(r), sample.char_len());\n-        assert!(rope_to_string(r) == *sample);\n-\n-        let mut string_iter = 0u;\n-        let string_len = sample.len();\n-        let mut rope_iter = iterator::char::start(r);\n-        let mut equal = true;\n-        while equal {\n-            match (node::char_iterator::next(&mut rope_iter)) {\n-              None => {\n-                if string_iter < string_len {\n-                    equal = false;\n-                } break; }\n-              Some(c) => {\n-                let range = sample.char_range_at(string_iter);\n-                string_iter = range.next;\n-                if range.ch != c { equal = false; break; }\n-              }\n-            }\n-        }\n-\n-        assert!(equal);\n-    }\n-\n-    #[test]\n-    fn iter1() {\n-        let buf = @ mut ~\"1234567890\";\n-        let mut i = 0;\n-        while i < 10 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r      = of_str(sample);\n-\n-        let mut len = 0u;\n-        let mut it  = iterator::char::start(r);\n-        loop {\n-            match (node::char_iterator::next(&mut it)) {\n-              None => break,\n-              Some(_) => len += 1u\n-            }\n-        }\n-\n-        assert_eq!(len, sample.char_len());\n-    }\n-\n-    #[test]\n-    fn bal1() {\n-        let init = @~\"1234567890\";\n-        let buf  = @mut copy *init;\n-        let mut i = 0;\n-        while i < 8 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r1     = of_str(sample);\n-        let mut r2 = of_str(init);\n-        i = 0;\n-        while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n-\n-\n-        assert!(eq(r1, r2));\n-        let r3 = bal(r2);\n-        assert_eq!(char_len(r1), char_len(r3));\n-\n-        assert!(eq(r1, r3));\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn char_at1() {\n-        //Generate a large rope\n-        let mut r = of_str(@~\"123456789\");\n-        for uint::range(0u, 10u) |_i| {\n-            r = append_rope(r, r);\n-        }\n-\n-        //Copy it in the slowest possible way\n-        let mut r2 = empty();\n-        for uint::range(0u, char_len(r)) |i| {\n-            r2 = append_char(r2, char_at(r, i));\n-        }\n-        assert!(eq(r, r2));\n-\n-        let mut r3 = empty();\n-        for uint::range(0u, char_len(r)) |i| {\n-            r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n-        }\n-        assert!(eq(r, r3));\n-\n-        //Additional sanity checks\n-        let balr = bal(r);\n-        let bal2 = bal(r2);\n-        let bal3 = bal(r3);\n-        assert!(eq(r, balr));\n-        assert!(eq(r, bal2));\n-        assert!(eq(r, bal3));\n-        assert!(eq(r2, r3));\n-        assert!(eq(bal2, bal3));\n-    }\n-\n-    #[test]\n-    fn concat1() {\n-        //Generate a reasonable rope\n-        let chunk = of_str(@~\"123456789\");\n-        let mut r = empty();\n-        for uint::range(0u, 10u) |_i| {\n-            r = append_rope(r, chunk);\n-        }\n-\n-        //Same rope, obtained with rope::concat\n-        let r2 = concat(vec::from_elem(10u, chunk));\n-\n-        assert!(eq(r, r2));\n-    }\n-}"}, {"sha": "b1383948bf72b221fc1fe305a4b59eaddff84829", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -682,7 +682,7 @@ impl<\n > Encodable<S> for Deque<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }"}, {"sha": "0271b393f61163fd0aebd287c4a0bb0690752cab", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 830, "deletions": 18, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,32 +8,135 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(missing_doc)];\n-\n-\n-use std::f64;\n+use sort;\n use std::cmp;\n+use std::io;\n use std::num;\n+use std::f64;\n use std::vec;\n-use sort;\n \n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n \n+/// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n pub trait Stats {\n+\n+    /// Sum of the samples.\n     fn sum(self) -> f64;\n+\n+    /// Minimum value of the samples.\n     fn min(self) -> f64;\n+\n+    /// Maximum value of the samples.\n     fn max(self) -> f64;\n+\n+    /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n     fn mean(self) -> f64;\n+\n+    /// Median of the samples: value separating the lower half of the samples from the higher half.\n+    /// Equal to `self.percentile(50.0)`.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Median\n     fn median(self) -> f64;\n+\n+    /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n+    /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n+    /// population variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\n+    /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n+    /// than `n`.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Variance\n     fn var(self) -> f64;\n+\n+    /// Standard deviation: the square root of the sample variance.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev` for unknown distributions.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Standard_deviation\n     fn std_dev(self) -> f64;\n+\n+    /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev_pct` for unknown distributions.\n     fn std_dev_pct(self) -> f64;\n+\n+    /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n+    /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n+    /// `std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\n+    /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n+    /// deviation.\n+    ///\n+    /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n     fn median_abs_dev(self) -> f64;\n+\n+    /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n     fn median_abs_dev_pct(self) -> f64;\n+\n+    /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n+    /// percentile(95.0) will return the value `v` such that that 95% of the samples `s` in `self`\n+    /// satisfy `s <= v`.\n+    ///\n+    /// Calculated by linear interpolation between closest ranks.\n+    ///\n+    /// See: http://en.wikipedia.org/wiki/Percentile\n+    fn percentile(self, pct: f64) -> f64;\n+\n+    /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n+    /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n+    /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n+    /// is otherwise equivalent.\n+    ///\n+    /// See also: https://en.wikipedia.org/wiki/Quartile\n+    fn quartiles(self) -> (f64,f64,f64);\n+\n+    /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n+    /// percentile (3rd quartile). See `quartiles`.\n+    ///\n+    /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n+    fn iqr(self) -> f64;\n+}\n+\n+/// Extracted collection of all the summary statistics of a sample set.\n+struct Summary {\n+    sum: f64,\n+    min: f64,\n+    max: f64,\n+    mean: f64,\n+    median: f64,\n+    var: f64,\n+    std_dev: f64,\n+    std_dev_pct: f64,\n+    median_abs_dev: f64,\n+    median_abs_dev_pct: f64,\n+    quartiles: (f64,f64,f64),\n+    iqr: f64,\n+}\n+\n+impl Summary {\n+    fn new(samples: &[f64]) -> Summary {\n+        Summary {\n+            sum: samples.sum(),\n+            min: samples.min(),\n+            max: samples.max(),\n+            mean: samples.mean(),\n+            median: samples.median(),\n+            var: samples.var(),\n+            std_dev: samples.std_dev(),\n+            std_dev_pct: samples.std_dev_pct(),\n+            median_abs_dev: samples.median_abs_dev(),\n+            median_abs_dev_pct: samples.median_abs_dev_pct(),\n+            quartiles: samples.quartiles(),\n+            iqr: samples.iqr()\n+        }\n+    }\n }\n \n impl<'self> Stats for &'self [f64] {\n+\n     fn sum(self) -> f64 {\n         self.iter().fold(0.0, |p,q| p + *q)\n     }\n@@ -54,19 +157,11 @@ impl<'self> Stats for &'self [f64] {\n     }\n \n     fn median(self) -> f64 {\n-        assert!(self.len() != 0);\n-        let mut tmp = vec::to_owned(self);\n-        sort::tim_sort(tmp);\n-        if tmp.len() & 1 == 0 {\n-            let m = tmp.len() / 2;\n-            (tmp[m] + tmp[m-1]) / 2.0\n-        } else {\n-            tmp[tmp.len() / 2]\n-        }\n+        self.percentile(50.0)\n     }\n \n     fn var(self) -> f64 {\n-        if self.len() == 0 {\n+        if self.len() < 2 {\n             0.0\n         } else {\n             let mean = self.mean();\n@@ -75,7 +170,10 @@ impl<'self> Stats for &'self [f64] {\n                 let x = *s - mean;\n                 v += x*x;\n             }\n-            v/(self.len() as f64)\n+            // NB: this is _supposed to be_ len-1, not len. If you\n+            // change it back to len, you will be calculating a\n+            // population variance, not a sample variance.\n+            v/((self.len()-1) as f64)\n         }\n     }\n \n@@ -89,11 +187,725 @@ impl<'self> Stats for &'self [f64] {\n \n     fn median_abs_dev(self) -> f64 {\n         let med = self.median();\n-        let abs_devs = self.map(|v| num::abs(med - *v));\n-        abs_devs.median()\n+        let abs_devs = self.map(|&v| num::abs(med - v));\n+        // This constant is derived by smarter statistics brains than me, but it is\n+        // consistent with how R and other packages treat the MAD.\n+        abs_devs.median() * 1.4826\n     }\n \n     fn median_abs_dev_pct(self) -> f64 {\n         (self.median_abs_dev() / self.median()) * 100.0\n     }\n+\n+    fn percentile(self, pct: f64) -> f64 {\n+        let mut tmp = vec::to_owned(self);\n+        sort::tim_sort(tmp);\n+        percentile_of_sorted(tmp, pct)\n+    }\n+\n+    fn quartiles(self) -> (f64,f64,f64) {\n+        let mut tmp = vec::to_owned(self);\n+        sort::tim_sort(tmp);\n+        let a = percentile_of_sorted(tmp, 25.0);\n+        let b = percentile_of_sorted(tmp, 50.0);\n+        let c = percentile_of_sorted(tmp, 75.0);\n+        (a,b,c)\n+    }\n+\n+    fn iqr(self) -> f64 {\n+        let (a,_,c) = self.quartiles();\n+        c - a\n+    }\n+}\n+\n+\n+// Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n+// linear interpolation. If samples are not sorted, return nonsensical value.\n+priv fn percentile_of_sorted(sorted_samples: &[f64],\n+                             pct: f64) -> f64 {\n+    assert!(sorted_samples.len() != 0);\n+    if sorted_samples.len() == 1 {\n+        return sorted_samples[0];\n+    }\n+    assert!(0.0 <= pct);\n+    assert!(pct <= 100.0);\n+    if pct == 100.0 {\n+        return sorted_samples[sorted_samples.len() - 1];\n+    }\n+    let rank = (pct / 100.0) * ((sorted_samples.len() - 1) as f64);\n+    let lrank = rank.floor();\n+    let d = rank - lrank;\n+    let n = lrank as uint;\n+    let lo = sorted_samples[n];\n+    let hi = sorted_samples[n+1];\n+    lo + (hi - lo) * d\n+}\n+\n+\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\n+/// percentile with those percentiles themselves. This is a way of minimizing the effect of\n+/// outliers, at the cost of biasing the sample. It differs from trimming in that it does not\n+/// change the number of samples, just changes the values of those that are outliers.\n+///\n+/// See: http://en.wikipedia.org/wiki/Winsorising\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n+    let mut tmp = vec::to_owned(samples);\n+    sort::tim_sort(tmp);\n+    let lo = percentile_of_sorted(tmp, pct);\n+    let hi = percentile_of_sorted(tmp, 100.0-pct);\n+    for samples.mut_iter().advance |samp| {\n+        if *samp > hi {\n+            *samp = hi\n+        } else if *samp < lo {\n+            *samp = lo\n+        }\n+    }\n+}\n+\n+/// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n+pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n+    let (q1,q2,q3) = s.quartiles;\n+    w.write_str(fmt!(\"(min=%f, q1=%f, med=%f, q3=%f, max=%f)\",\n+                     s.min as float,\n+                     q1 as float,\n+                     q2 as float,\n+                     q3 as float,\n+                     s.max as float));\n+}\n+\n+/// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n+/// provided `Summary` (thus includes the mean) and is scaled to display within the range of the\n+/// nearest multiple-of-a-power-of-ten above and below the min and max of possible values, and\n+/// target `width_hint` characters of display (though it will be wider if necessary).\n+///\n+/// As an example, the summary with 5-number-summary `(min=15, q1=17, med=20, q3=24, max=31)` might\n+/// display as:\n+///\n+/// ~~~~\n+///   10 |        [--****#******----------]          | 40\n+/// ~~~~\n+\n+pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n+\n+    let (q1,q2,q3) = s.quartiles;\n+\n+    let lomag = (10.0_f64).pow(&s.min.log10().floor());\n+    let himag = (10.0_f64).pow(&(s.max.log10().floor()));\n+    let lo = (s.min / lomag).floor() * lomag;\n+    let hi = (s.max / himag).ceil() * himag;\n+\n+    let range = hi - lo;\n+\n+    let lostr = lo.to_str();\n+    let histr = hi.to_str();\n+\n+    let overhead_width = lostr.len() + histr.len() + 4;\n+    let range_width = width_hint - overhead_width;;\n+    let char_step = range / (range_width as f64);\n+\n+    w.write_str(lostr);\n+    w.write_char(' ');\n+    w.write_char('|');\n+\n+    let mut c = 0;\n+    let mut v = lo;\n+\n+    while c < range_width && v < s.min {\n+        w.write_char(' ');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char('[');\n+    c += 1;\n+    while c < range_width && v < q1 {\n+        w.write_char('-');\n+        v += char_step;\n+        c += 1;\n+    }\n+    while c < range_width && v < q2 {\n+        w.write_char('*');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char('#');\n+    c += 1;\n+    while c < range_width && v < q3 {\n+        w.write_char('*');\n+        v += char_step;\n+        c += 1;\n+    }\n+    while c < range_width && v < s.max {\n+        w.write_char('-');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char(']');\n+    while c < range_width {\n+        w.write_char(' ');\n+        v += char_step;\n+        c += 1;\n+    }\n+\n+    w.write_char('|');\n+    w.write_char(' ');\n+    w.write_str(histr);\n+}\n+\n+// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use stats::Stats;\n+    use stats::Summary;\n+    use stats::write_5_number_summary;\n+    use stats::write_boxplot;\n+    use std::io;\n+\n+    fn check(samples: &[f64], summ: &Summary) {\n+\n+        let summ2 = Summary::new(samples);\n+\n+        let w = io::stdout();\n+        w.write_char('\\n');\n+        write_5_number_summary(w, &summ2);\n+        w.write_char('\\n');\n+        write_boxplot(w, &summ2, 50);\n+        w.write_char('\\n');\n+\n+        assert_eq!(summ.sum, summ2.sum);\n+        assert_eq!(summ.min, summ2.min);\n+        assert_eq!(summ.max, summ2.max);\n+        assert_eq!(summ.mean, summ2.mean);\n+        assert_eq!(summ.median, summ2.median);\n+\n+        // We needed a few more digits to get exact equality on these\n+        // but they're within float epsilon, which is 1.0e-6.\n+        assert_approx_eq!(summ.var, summ2.var);\n+        assert_approx_eq!(summ.std_dev, summ2.std_dev);\n+        assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n+        assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n+        assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n+\n+        assert_eq!(summ.quartiles, summ2.quartiles);\n+        assert_eq!(summ.iqr, summ2.iqr);\n+    }\n+\n+    #[test]\n+    fn test_norm2() {\n+        let val = &[\n+            958.0000000000,\n+            924.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1882.0000000000,\n+            min: 924.0000000000,\n+            max: 958.0000000000,\n+            mean: 941.0000000000,\n+            median: 941.0000000000,\n+            var: 578.0000000000,\n+            std_dev: 24.0416305603,\n+            std_dev_pct: 2.5549022912,\n+            median_abs_dev: 25.2042000000,\n+            median_abs_dev_pct: 2.6784484591,\n+            quartiles: (932.5000000000,941.0000000000,949.5000000000),\n+            iqr: 17.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10narrow() {\n+        let val = &[\n+            966.0000000000,\n+            985.0000000000,\n+            1110.0000000000,\n+            848.0000000000,\n+            821.0000000000,\n+            975.0000000000,\n+            962.0000000000,\n+            1157.0000000000,\n+            1217.0000000000,\n+            955.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9996.0000000000,\n+            min: 821.0000000000,\n+            max: 1217.0000000000,\n+            mean: 999.6000000000,\n+            median: 970.5000000000,\n+            var: 16050.7111111111,\n+            std_dev: 126.6914010938,\n+            std_dev_pct: 12.6742097933,\n+            median_abs_dev: 102.2994000000,\n+            median_abs_dev_pct: 10.5408964451,\n+            quartiles: (956.7500000000,970.5000000000,1078.7500000000),\n+            iqr: 122.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10medium() {\n+        let val = &[\n+            954.0000000000,\n+            1064.0000000000,\n+            855.0000000000,\n+            1000.0000000000,\n+            743.0000000000,\n+            1084.0000000000,\n+            704.0000000000,\n+            1023.0000000000,\n+            357.0000000000,\n+            869.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 8653.0000000000,\n+            min: 357.0000000000,\n+            max: 1084.0000000000,\n+            mean: 865.3000000000,\n+            median: 911.5000000000,\n+            var: 48628.4555555556,\n+            std_dev: 220.5186059170,\n+            std_dev_pct: 25.4846418487,\n+            median_abs_dev: 195.7032000000,\n+            median_abs_dev_pct: 21.4704552935,\n+            quartiles: (771.0000000000,911.5000000000,1017.2500000000),\n+            iqr: 246.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10wide() {\n+        let val = &[\n+            505.0000000000,\n+            497.0000000000,\n+            1591.0000000000,\n+            887.0000000000,\n+            1026.0000000000,\n+            136.0000000000,\n+            1580.0000000000,\n+            940.0000000000,\n+            754.0000000000,\n+            1433.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9349.0000000000,\n+            min: 136.0000000000,\n+            max: 1591.0000000000,\n+            mean: 934.9000000000,\n+            median: 913.5000000000,\n+            var: 239208.9888888889,\n+            std_dev: 489.0899599142,\n+            std_dev_pct: 52.3146817750,\n+            median_abs_dev: 611.5725000000,\n+            median_abs_dev_pct: 66.9482758621,\n+            quartiles: (567.2500000000,913.5000000000,1331.2500000000),\n+            iqr: 764.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm25verynarrow() {\n+        let val = &[\n+            991.0000000000,\n+            1018.0000000000,\n+            998.0000000000,\n+            1013.0000000000,\n+            974.0000000000,\n+            1007.0000000000,\n+            1014.0000000000,\n+            999.0000000000,\n+            1011.0000000000,\n+            978.0000000000,\n+            985.0000000000,\n+            999.0000000000,\n+            983.0000000000,\n+            982.0000000000,\n+            1015.0000000000,\n+            1002.0000000000,\n+            977.0000000000,\n+            948.0000000000,\n+            1040.0000000000,\n+            974.0000000000,\n+            996.0000000000,\n+            989.0000000000,\n+            1015.0000000000,\n+            994.0000000000,\n+            1024.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 24926.0000000000,\n+            min: 948.0000000000,\n+            max: 1040.0000000000,\n+            mean: 997.0400000000,\n+            median: 998.0000000000,\n+            var: 393.2066666667,\n+            std_dev: 19.8294393937,\n+            std_dev_pct: 1.9888308788,\n+            median_abs_dev: 22.2390000000,\n+            median_abs_dev_pct: 2.2283567134,\n+            quartiles: (983.0000000000,998.0000000000,1013.0000000000),\n+            iqr: 30.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10a() {\n+        let val = &[\n+            23.0000000000,\n+            11.0000000000,\n+            2.0000000000,\n+            57.0000000000,\n+            4.0000000000,\n+            12.0000000000,\n+            5.0000000000,\n+            29.0000000000,\n+            3.0000000000,\n+            21.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 167.0000000000,\n+            min: 2.0000000000,\n+            max: 57.0000000000,\n+            mean: 16.7000000000,\n+            median: 11.5000000000,\n+            var: 287.7888888889,\n+            std_dev: 16.9643416875,\n+            std_dev_pct: 101.5828843560,\n+            median_abs_dev: 13.3434000000,\n+            median_abs_dev_pct: 116.0295652174,\n+            quartiles: (4.2500000000,11.5000000000,22.5000000000),\n+            iqr: 18.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10b() {\n+        let val = &[\n+            24.0000000000,\n+            17.0000000000,\n+            6.0000000000,\n+            38.0000000000,\n+            25.0000000000,\n+            7.0000000000,\n+            51.0000000000,\n+            2.0000000000,\n+            61.0000000000,\n+            32.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 263.0000000000,\n+            min: 2.0000000000,\n+            max: 61.0000000000,\n+            mean: 26.3000000000,\n+            median: 24.5000000000,\n+            var: 383.5666666667,\n+            std_dev: 19.5848580967,\n+            std_dev_pct: 74.4671410520,\n+            median_abs_dev: 22.9803000000,\n+            median_abs_dev_pct: 93.7971428571,\n+            quartiles: (9.5000000000,24.5000000000,36.5000000000),\n+            iqr: 27.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10c() {\n+        let val = &[\n+            71.0000000000,\n+            2.0000000000,\n+            32.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            28.0000000000,\n+            13.0000000000,\n+            37.0000000000,\n+            16.0000000000,\n+            36.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 242.0000000000,\n+            min: 1.0000000000,\n+            max: 71.0000000000,\n+            mean: 24.2000000000,\n+            median: 22.0000000000,\n+            var: 458.1777777778,\n+            std_dev: 21.4050876611,\n+            std_dev_pct: 88.4507754589,\n+            median_abs_dev: 21.4977000000,\n+            median_abs_dev_pct: 97.7168181818,\n+            quartiles: (7.7500000000,22.0000000000,35.0000000000),\n+            iqr: 27.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp25() {\n+        let val = &[\n+            3.0000000000,\n+            24.0000000000,\n+            1.0000000000,\n+            19.0000000000,\n+            7.0000000000,\n+            5.0000000000,\n+            30.0000000000,\n+            39.0000000000,\n+            31.0000000000,\n+            13.0000000000,\n+            25.0000000000,\n+            48.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            42.0000000000,\n+            63.0000000000,\n+            2.0000000000,\n+            12.0000000000,\n+            108.0000000000,\n+            26.0000000000,\n+            1.0000000000,\n+            7.0000000000,\n+            44.0000000000,\n+            25.0000000000,\n+            11.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 593.0000000000,\n+            min: 1.0000000000,\n+            max: 108.0000000000,\n+            mean: 23.7200000000,\n+            median: 19.0000000000,\n+            var: 601.0433333333,\n+            std_dev: 24.5161851301,\n+            std_dev_pct: 103.3565983562,\n+            median_abs_dev: 19.2738000000,\n+            median_abs_dev_pct: 101.4410526316,\n+            quartiles: (6.0000000000,19.0000000000,31.0000000000),\n+            iqr: 25.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_binom25() {\n+        let val = &[\n+            18.0000000000,\n+            17.0000000000,\n+            27.0000000000,\n+            15.0000000000,\n+            21.0000000000,\n+            25.0000000000,\n+            17.0000000000,\n+            24.0000000000,\n+            25.0000000000,\n+            24.0000000000,\n+            26.0000000000,\n+            26.0000000000,\n+            23.0000000000,\n+            15.0000000000,\n+            23.0000000000,\n+            17.0000000000,\n+            18.0000000000,\n+            18.0000000000,\n+            21.0000000000,\n+            16.0000000000,\n+            15.0000000000,\n+            31.0000000000,\n+            20.0000000000,\n+            17.0000000000,\n+            15.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 514.0000000000,\n+            min: 15.0000000000,\n+            max: 31.0000000000,\n+            mean: 20.5600000000,\n+            median: 20.0000000000,\n+            var: 20.8400000000,\n+            std_dev: 4.5650848842,\n+            std_dev_pct: 22.2037202539,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 29.6520000000,\n+            quartiles: (17.0000000000,20.0000000000,24.0000000000),\n+            iqr: 7.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda30() {\n+        let val = &[\n+            27.0000000000,\n+            33.0000000000,\n+            34.0000000000,\n+            34.0000000000,\n+            24.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            27.0000000000,\n+            31.0000000000,\n+            28.0000000000,\n+            38.0000000000,\n+            21.0000000000,\n+            33.0000000000,\n+            36.0000000000,\n+            29.0000000000,\n+            37.0000000000,\n+            32.0000000000,\n+            34.0000000000,\n+            31.0000000000,\n+            39.0000000000,\n+            25.0000000000,\n+            31.0000000000,\n+            32.0000000000,\n+            40.0000000000,\n+            24.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 787.0000000000,\n+            min: 21.0000000000,\n+            max: 40.0000000000,\n+            mean: 31.4800000000,\n+            median: 32.0000000000,\n+            var: 26.5933333333,\n+            std_dev: 5.1568724372,\n+            std_dev_pct: 16.3814245145,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 18.5325000000,\n+            quartiles: (28.0000000000,32.0000000000,34.0000000000),\n+            iqr: 6.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda40() {\n+        let val = &[\n+            42.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            46.0000000000,\n+            34.0000000000,\n+            45.0000000000,\n+            34.0000000000,\n+            49.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            40.0000000000,\n+            35.0000000000,\n+            37.0000000000,\n+            39.0000000000,\n+            46.0000000000,\n+            44.0000000000,\n+            32.0000000000,\n+            45.0000000000,\n+            42.0000000000,\n+            37.0000000000,\n+            48.0000000000,\n+            42.0000000000,\n+            33.0000000000,\n+            42.0000000000,\n+            48.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1019.0000000000,\n+            min: 28.0000000000,\n+            max: 50.0000000000,\n+            mean: 40.7600000000,\n+            median: 42.0000000000,\n+            var: 34.4400000000,\n+            std_dev: 5.8685603004,\n+            std_dev_pct: 14.3978417577,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 14.1200000000,\n+            quartiles: (37.0000000000,42.0000000000,45.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda50() {\n+        let val = &[\n+            45.0000000000,\n+            43.0000000000,\n+            44.0000000000,\n+            61.0000000000,\n+            51.0000000000,\n+            53.0000000000,\n+            59.0000000000,\n+            52.0000000000,\n+            49.0000000000,\n+            51.0000000000,\n+            51.0000000000,\n+            50.0000000000,\n+            49.0000000000,\n+            56.0000000000,\n+            42.0000000000,\n+            52.0000000000,\n+            51.0000000000,\n+            43.0000000000,\n+            48.0000000000,\n+            48.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            43.0000000000,\n+            42.0000000000,\n+            60.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1235.0000000000,\n+            min: 42.0000000000,\n+            max: 61.0000000000,\n+            mean: 49.4000000000,\n+            median: 50.0000000000,\n+            var: 31.6666666667,\n+            std_dev: 5.6273143387,\n+            std_dev_pct: 11.3913245723,\n+            median_abs_dev: 4.4478000000,\n+            median_abs_dev_pct: 8.8956000000,\n+            quartiles: (44.0000000000,50.0000000000,52.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_unif25() {\n+        let val = &[\n+            99.0000000000,\n+            55.0000000000,\n+            92.0000000000,\n+            79.0000000000,\n+            14.0000000000,\n+            2.0000000000,\n+            33.0000000000,\n+            49.0000000000,\n+            3.0000000000,\n+            32.0000000000,\n+            84.0000000000,\n+            59.0000000000,\n+            22.0000000000,\n+            86.0000000000,\n+            76.0000000000,\n+            31.0000000000,\n+            29.0000000000,\n+            11.0000000000,\n+            41.0000000000,\n+            53.0000000000,\n+            45.0000000000,\n+            44.0000000000,\n+            98.0000000000,\n+            98.0000000000,\n+            7.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1242.0000000000,\n+            min: 2.0000000000,\n+            max: 99.0000000000,\n+            mean: 49.6800000000,\n+            median: 45.0000000000,\n+            var: 1015.6433333333,\n+            std_dev: 31.8691595957,\n+            std_dev_pct: 64.1488719719,\n+            median_abs_dev: 45.9606000000,\n+            median_abs_dev_pct: 102.1346666667,\n+            quartiles: (29.0000000000,45.0000000000,79.0000000000),\n+            iqr: 50.0000000000,\n+        };\n+        check(val, summ);\n+    }\n }"}, {"sha": "55626622775763b2126ff0d852b97ae348e339ab", "filename": "src/libextra/term.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -26,23 +26,23 @@ use std::io;\n pub mod color {\n     pub type Color = u16;\n \n-    pub static black:   Color = 0u16;\n-    pub static red:     Color = 1u16;\n-    pub static green:   Color = 2u16;\n-    pub static yellow:  Color = 3u16;\n-    pub static blue:    Color = 4u16;\n-    pub static magenta: Color = 5u16;\n-    pub static cyan:    Color = 6u16;\n-    pub static white:   Color = 7u16;\n-\n-    pub static bright_black:   Color = 8u16;\n-    pub static bright_red:     Color = 9u16;\n-    pub static bright_green:   Color = 10u16;\n-    pub static bright_yellow:  Color = 11u16;\n-    pub static bright_blue:    Color = 12u16;\n-    pub static bright_magenta: Color = 13u16;\n-    pub static bright_cyan:    Color = 14u16;\n-    pub static bright_white:   Color = 15u16;\n+    pub static BLACK:   Color = 0u16;\n+    pub static RED:     Color = 1u16;\n+    pub static GREEN:   Color = 2u16;\n+    pub static YELLOW:  Color = 3u16;\n+    pub static BLUE:    Color = 4u16;\n+    pub static MAGENTA: Color = 5u16;\n+    pub static CYAN:    Color = 6u16;\n+    pub static WHITE:   Color = 7u16;\n+\n+    pub static BRIGHT_BLACK:   Color = 8u16;\n+    pub static BRIGHT_RED:     Color = 9u16;\n+    pub static BRIGHT_GREEN:   Color = 10u16;\n+    pub static BRIGHT_YELLOW:  Color = 11u16;\n+    pub static BRIGHT_BLUE:    Color = 12u16;\n+    pub static BRIGHT_MAGENTA: Color = 13u16;\n+    pub static BRIGHT_CYAN:    Color = 14u16;\n+    pub static BRIGHT_WHITE:   Color = 15u16;\n }\n \n #[cfg(not(target_os = \"win32\"))]"}, {"sha": "e56b3b6bcf4c830e4e3f384e50db2d26eb193f39", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(non_uppercase_statics)];\n+\n /// ncurses-compatible compiled terminfo format parsing (term(5))\n \n \n@@ -292,7 +294,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n             // Find the offset of the NUL we want to go to\n             let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n-                .iter().position_(|&b| b == 0);\n+                .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_owned(),"}, {"sha": "1c6e2a25c01b7298d5c40d65c5747b66c33dd076", "filename": "src/libextra/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -323,19 +323,19 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n \n     fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color::green, use_color);\n+        write_pretty(out, \"ok\", term::color::GREEN, use_color);\n     }\n \n     fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color::red, use_color);\n+        write_pretty(out, \"FAILED\", term::color::RED, use_color);\n     }\n \n     fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color::yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color::YELLOW, use_color);\n     }\n \n     fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"bench\", term::color::cyan, use_color);\n+        write_pretty(out, \"bench\", term::color::CYAN, use_color);\n     }\n \n     fn write_pretty(out: @io::Writer,\n@@ -469,7 +469,7 @@ fn run_tests(opts: &TestOpts,\n     }\n \n     // All benchmarks run at the end, in serial.\n-    do vec::consume(filtered_benchs) |_, b| {\n+    for filtered_benchs.consume_iter().advance |b| {\n         callback(TeWait(copy b.desc));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -479,16 +479,16 @@ fn run_tests(opts: &TestOpts,\n \n // Windows tends to dislike being overloaded with threads.\n #[cfg(windows)]\n-static sched_overcommit : uint = 1;\n+static SCHED_OVERCOMMIT : uint = 1;\n \n #[cfg(unix)]\n-static sched_overcommit : uint = 4u;\n+static SCHED_OVERCOMMIT : uint = 4u;\n \n fn get_concurrency() -> uint {\n     use std::rt;\n     let threads = rt::util::default_sched_threads();\n     if threads == 1 { 1 }\n-    else { threads * sched_overcommit }\n+    else { threads * SCHED_OVERCOMMIT }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -514,7 +514,7 @@ pub fn filter_tests(\n             } else { return option::None; }\n         }\n \n-        vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n+        filtered.consume_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -532,7 +532,7 @@ pub fn filter_tests(\n                 None\n             }\n         };\n-        vec::filter_map(filtered, |x| filter(x))\n+        filtered.consume_iter().filter_map(|x| filter(x)).collect()\n     };\n \n     // Sort the tests alphabetically\n@@ -711,9 +711,9 @@ impl BenchHarness {\n             // Eliminate outliers\n             let med = samples.median();\n             let mad = samples.median_abs_dev();\n-            let samples = do vec::filter(samples) |f| {\n+            let samples = do samples.consume_iter().filter |f| {\n                 num::abs(*f - med) <= 3.0 * mad\n-            };\n+            }.collect::<~[f64]>();\n \n             debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n                    n_samples, med as float, mad as float,"}, {"sha": "a64b23743287e6829570d1977f68050d0c88040b", "filename": "src/libextra/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -868,20 +868,20 @@ mod tests {\n     use std::str;\n \n     fn test_get_time() {\n-        static some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n-        static some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n+        static SOME_RECENT_DATE: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n+        static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n         debug!(\"tv1=%? sec + %? nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n-        assert!(tv1.sec > some_recent_date);\n+        assert!(tv1.sec > SOME_RECENT_DATE);\n         assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n         debug!(\"tv2=%? sec + %? nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n         assert!(tv2.sec >= tv1.sec);\n-        assert!(tv2.sec < some_future_date);\n+        assert!(tv2.sec < SOME_FUTURE_DATE);\n         assert!(tv2.nsec < 1000000000i32);\n         if tv2.sec == tv1.sec {\n             assert!(tv2.nsec >= tv1.nsec);"}, {"sha": "a5f7479d41a0116b8a8ed2b4af8a53bec2f5d374", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -57,23 +57,25 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n }\n \n // Lexicographical comparison\n-fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n \n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n-        let (key_a,_) = x.next().unwrap();\n-        let (key_b,_) = y.next().unwrap();\n+        let (key_a, value_a) = x.next().unwrap();\n+        let (key_b, value_b) = y.next().unwrap();\n         if *key_a < *key_b { return true; }\n         if *key_a > *key_b { return false; }\n-    };\n+        if *value_a < *value_b { return true; }\n+        if *value_a > *value_b { return false; }\n+    }\n \n     a_len < b_len\n }\n \n-impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n+impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n     #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n     #[inline]\n@@ -196,14 +198,15 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root}\n+        TreeMapIterator{stack: ~[], node: &self.root, remaining: self.length}\n     }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'self, K, V> {\n     priv stack: ~[&'self ~TreeNode<K, V>],\n-    priv node: &'self Option<~TreeNode<K, V>>\n+    priv node: &'self Option<~TreeNode<K, V>>,\n+    priv remaining: uint\n }\n \n impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n@@ -220,12 +223,18 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n               None => {\n                 let res = self.stack.pop();\n                 self.node = &res.right;\n+                self.remaining -= 1;\n                 return Some((&res.key, &res.value));\n               }\n             }\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.remaining, Some(self.remaining))\n+    }\n }\n \n impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n@@ -835,7 +844,7 @@ mod test_treemap {\n             for 90.times {\n                 let k = rng.gen();\n                 let v = rng.gen();\n-                if !ctrl.iter().any_(|x| x == &(k, v)) {\n+                if !ctrl.iter().any(|x| x == &(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);\n@@ -935,7 +944,7 @@ mod test_treemap {\n         assert!(b.insert(0, 5));\n         assert!(a < b);\n         assert!(a.insert(0, 7));\n-        assert!(!(a < b) && !(b < a));\n+        assert!(!(a < b) && b < a);\n         assert!(b.insert(-2, 0));\n         assert!(b < a);\n         assert!(a.insert(-5, 2));"}, {"sha": "69ff100784077f93c323b9fb1ec16d3cd7659473", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1046,7 +1046,7 @@ pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         rust_uv_ip4_name(to_unsafe_ptr(src),\n                                  dst_buf, size as libc::size_t);\n         // seems that checking the result of uv_ip4_name\n@@ -1066,7 +1066,7 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         let src_unsafe_ptr = to_unsafe_ptr(src);\n         let result = rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);"}, {"sha": "71504b6498bfb90b0a3ede01a58be3ffe7d65ea3", "filename": "src/librust/rust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -13,7 +13,7 @@\n // FIXME #2238 Make run only accept source that emits an executable\n \n #[link(name = \"rust\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"4a24da33-5cc8-4037-9352-2cbe9bd9d27c\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/rust\")];\n \n@@ -60,7 +60,7 @@ struct Command<'self> {\n     usage_full: UsageSource<'self>,\n }\n \n-static commands: &'static [Command<'static>] = &[\n+static COMMANDS: &'static [Command<'static>] = &[\n     Command{\n         cmd: \"build\",\n         action: CallMain(\"rustc\", rustc::main),\n@@ -122,7 +122,7 @@ fn rustc_help() {\n }\n \n fn find_cmd(command_string: &str) -> Option<Command> {\n-    do commands.iter().find_ |command| {\n+    do COMMANDS.iter().find_ |command| {\n         command.cmd == command_string\n     }.map_consume(|x| copy *x)\n }\n@@ -197,7 +197,7 @@ fn do_command(command: &Command, args: &[~str]) -> ValidUsage {\n }\n \n fn usage() {\n-    static indent: uint = 8;\n+    static INDENT: uint = 8;\n \n     io::print(\n         \"The rust tool is a convenience for managing rust source code.\\n\\\n@@ -209,8 +209,8 @@ fn usage() {\n         \\n\"\n     );\n \n-    for commands.iter().advance |command| {\n-        let padding = \" \".repeat(indent - command.cmd.len());\n+    for COMMANDS.iter().advance |command| {\n+        let padding = \" \".repeat(INDENT - command.cmd.len());\n         io::println(fmt!(\"    %s%s%s\",\n                          command.cmd, padding, command.usage_line));\n     }"}, {"sha": "a7abc619080385849c3bd66e7aef756ca0e7c058", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -893,7 +893,7 @@ pub fn link_args(sess: Session,\n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n-        do vec::consume(link_args) |_, link_arg| {\n+        for link_args.consume_iter().advance |link_arg| {\n             args.push(link_arg);\n         }\n     }"}, {"sha": "3c50754744886c820d55e6fd323f7211c07841d6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -123,10 +123,10 @@ pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n-    do vec::map_consume(cfgspecs) |s| {\n+    do cfgspecs.consume_iter().transform |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n-    }\n+    }.collect()\n }\n \n pub enum input {"}, {"sha": "0d4d96b3b2b3ee64b190c36e3b66aee01dda1f1f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,10 +10,9 @@\n \n \n use std::option;\n-use std::vec;\n use syntax::{ast, fold, attr};\n \n-type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n+type in_cfg_pred = @fn(attrs: &[ast::attribute]) -> bool;\n \n struct Context {\n     in_cfg: in_cfg_pred\n@@ -51,8 +50,7 @@ fn filter_item(cx: @Context, item: @ast::item) ->\n     if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n-fn filter_view_item(cx: @Context, view_item: @ast::view_item\n-                   )-> Option<@ast::view_item> {\n+fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'r ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n         option::Some(view_item)\n     } else {\n@@ -61,13 +59,15 @@ fn filter_view_item(cx: @Context, view_item: @ast::view_item\n }\n \n fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n-    let filtered_items =\n-        m.items.filter_mapped(|a| filter_item(cx, *a));\n-    let filtered_view_items =\n-        m.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = do  m.items.iter().filter_map |a| {\n+        filter_item(cx, *a).chain(|x| fld.fold_item(x))\n+    }.collect();\n+    let filtered_view_items = do m.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+    }.collect();\n     ast::_mod {\n-        view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n+        view_items: filtered_view_items,\n+        items: filtered_items\n     }\n }\n \n@@ -83,27 +83,29 @@ fn fold_foreign_mod(\n     nm: &ast::foreign_mod,\n     fld: @fold::ast_fold\n ) -> ast::foreign_mod {\n-    let filtered_items =\n-        nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n-    let filtered_view_items =\n-        nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n+    let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+    }.collect();\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: filtered_view_items,\n         items: filtered_items\n     }\n }\n \n fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, b, c, ref methods) => {\n-            let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n-            ast::item_impl(/*bad*/ copy *a, b, c, methods)\n+        ast::item_impl(ref a, ref b, ref c, ref methods) => {\n+            let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n+                .transform(|x| *x).collect();\n+            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, /*bad*/ copy *c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n-            let methods = methods.filtered(|m| trait_method_in_cfg(cx, m) );\n+            let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n+                .transform(|x| /* bad */copy *x).collect();\n             ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n         ref item => /*bad*/ copy *item\n@@ -134,19 +136,12 @@ fn fold_block(\n     b: &ast::blk_,\n     fld: @fold::ast_fold\n ) -> ast::blk_ {\n-    let filtered_stmts =\n-        b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n-    let filtered_view_items =\n-        b.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n-    let filtered_view_items =\n-        filtered_view_items.map(|x| fld.fold_view_item(*x));\n-    let mut resulting_stmts = ~[];\n-    for filtered_stmts.iter().advance |stmt| {\n-        match fld.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => resulting_stmts.push(stmt),\n-        }\n-    }\n+    let resulting_stmts = do b.stmts.iter().filter_map |a| {\n+        filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n+    }.collect();\n+    let filtered_view_items = do b.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+    }.collect();\n     ast::blk_ {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n@@ -164,8 +159,8 @@ fn foreign_item_in_cfg(cx: @Context, item: @ast::foreign_item) -> bool {\n     return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n-fn view_item_in_cfg(cx: @Context, item: @ast::view_item) -> bool {\n-    return (cx.in_cfg)(/*bad*/copy item.attrs);\n+fn view_item_in_cfg(cx: @Context, item: &ast::view_item) -> bool {\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn method_in_cfg(cx: @Context, meth: @ast::method) -> bool {\n@@ -193,11 +188,13 @@ pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i));\n+    let cfg_metas = cfg_metas.consume_iter()\n+        .filter_map(|i| attr::get_meta_item_list(i))\n+        .collect::<~[~[@ast::meta_item]]>();\n \n     if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n \n-    cfg_metas.iter().any_(|cfg_meta| {\n+    cfg_metas.iter().any(|cfg_meta| {\n         cfg_meta.iter().all(|cfg_mi| {\n             match cfg_mi.node {\n                 ast::meta_list(s, ref it) if \"not\" == s"}, {"sha": "45169a2f6566bafb36db9b385defe9c4db994f75", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::dummy_sp;\n use syntax::codemap;\n use syntax::fold;\n \n-static STD_VERSION: &'static str = \"0.7\";\n+static STD_VERSION: &'static str = \"0.8-pre\";\n \n pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::crate)\n                                -> @ast::crate {\n@@ -41,7 +41,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n     let precursor = @fold::AstFoldFns {\n         fold_crate: |crate, span, fld| {\n             let n1 = sess.next_node_id();\n-            let vi1 = @ast::view_item {\n+            let vi1 = ast::view_item {\n                 node: ast::view_item_extern_mod(\n                         sess.ident_of(\"std\"), ~[], n1),\n                 attrs: ~[\n@@ -75,7 +75,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n         fold_mod: |module, fld| {\n             let n2 = sess.next_node_id();\n \n-            let prelude_path = @ast::Path {\n+            let prelude_path = ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n                 idents: ~[\n@@ -87,7 +87,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n             };\n \n             let vp = @spanned(ast::view_path_glob(prelude_path, n2));\n-            let vi2 = @ast::view_item { node: ast::view_item_use(~[vp]),\n+            let vi2 = ast::view_item { node: ast::view_item_use(~[vp]),\n                                         attrs: ~[],\n                                         vis: ast::private,\n                                         span: dummy_sp() };"}, {"sha": "7137272acda5a0acef96296db47833bb4bc632a4", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -17,7 +17,7 @@ use front::config;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n+use syntax::codemap::{dummy_sp, span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n@@ -72,13 +72,13 @@ fn generate_test_harness(sess: session::Session,\n     };\n \n     let ext_cx = cx.ext_cx;\n-    ext_cx.bt_push(ExpandedFrom(CallInfo {\n+    ext_cx.bt_push(ExpnInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n             name: @\"test\",\n             span: None\n         }\n-    }));\n+    });\n \n     let precursor = @fold::AstFoldFns {\n         fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n@@ -109,9 +109,11 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n-            @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               \"main\" != attr::get_attr_name(attr)\n-                           }),.. copy *item}\n+            @ast::item{\n+                attrs: do item.attrs.iter().filter_map |attr| {\n+                    if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+                }.collect(),\n+                .. copy *item}\n         } else { item }\n     }\n \n@@ -229,10 +231,10 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     return if !ignoreitems.is_empty() {\n-        let cfg_metas =\n-            vec::concat(\n-                vec::filter_map(ignoreitems,\n-                                |i| attr::get_meta_item_list(i)));\n+        let cfg_metas = ignoreitems.consume_iter()\n+            .filter_map(|i| attr::get_meta_item_list(i))\n+            .collect::<~[~[@ast::meta_item]]>()\n+            .concat_vec();\n         config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false\n@@ -270,8 +272,8 @@ mod __test {\n \n */\n \n-fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n-    let vers = ast::lit_str(@\"0.7\");\n+fn mk_std(cx: &TestCtxt) -> ast::view_item {\n+    let vers = ast::lit_str(@\"0.8-pre\");\n     let vers = nospan(vers);\n     let mi = ast::meta_name_value(@\"vers\", vers);\n     let mi = nospan(mi);\n@@ -285,13 +287,12 @@ fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n         ast::view_item_extern_mod(id_std, ~[@mi],\n                            cx.sess.next_node_id())\n     };\n-    let vi = ast::view_item {\n+    ast::view_item {\n         node: vi,\n         attrs: ~[],\n         vis: ast::public,\n         span: dummy_sp()\n-    };\n-    return @vi;\n+    }\n }\n \n fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n@@ -308,7 +309,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     let mainfn = (quote_item!(\n         pub fn main() {\n             #[main];\n-            extra::test::test_main_static(::std::os::args(), tests);\n+            extra::test::test_main_static(::std::os::args(), TESTS);\n         }\n     )).get();\n \n@@ -341,16 +342,16 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n                  rp: None,\n@@ -365,7 +366,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     let test_descs = mk_test_descs(cx);\n \n     (quote_item!(\n-        pub static tests : &'static [self::extra::test::TestDescAndFn] =\n+        pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n             $test_descs\n         ;\n     )).get()"}, {"sha": "8c62f4dbbe357eb2851d6e43a94735fdeff9f465", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -136,7 +136,7 @@ fn visit_crate(e: &Env, c: &ast::crate) {\n     }\n }\n \n-fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n+fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n     match i.node {\n       ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\","}, {"sha": "bb1834dc5c8fca0653401fc2dddfbdafdbba62fb", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -102,7 +102,7 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n     assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.iter().any_(|x| x == &lib) { return false; }\n+    if cstore.used_libraries.iter().any(|x| x == &lib) { return false; }\n     cstore.used_libraries.push(lib);\n     true\n }"}, {"sha": "1e508d0813184559f93a99f343ae493495e0be7d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1141,7 +1141,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n \n     let r = get_attributes(md);\n     for r.iter().advance |attr| {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n+        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(\"\\n\\n\");"}, {"sha": "a9f3200af1284882f15075416ad13637e849937d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1003,7 +1003,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -1014,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+            ast::ty_path(ref path, ref bounds, _) if path.idents.len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));"}, {"sha": "72b6f8e1c805bd00e1e0ed6b67ca1936aa40b43d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -291,16 +291,16 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n // inlined items.\n fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = do blk.stmts.filtered |stmt| {\n+        let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n-                                             span: _}, _) => true,\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_),\n-                                             span: _}, _) => false,\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_), span: _}, _)\n+                => Some(*stmt),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_), span: _}, _)\n+                => None,\n               ast::stmt_mac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n-        };\n+        }.collect();\n         let blk_sans_items = ast::blk_ {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!"}, {"sha": "2e3813f57e081ad315378a0821a8a3407ada64fc", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -538,12 +538,13 @@ impl BorrowckCtxt {\n \n             move_data::MoveExpr(expr) => {\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                let suggestion = move_suggestion(self.tcx, expr_ty,\n+                        \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved here because it has type `%s`, \\\n-                          which is moved by default (use `copy` to override)\",\n+                    fmt!(\"`%s` moved here because it has type `%s`, which is %s\",\n                          self.loan_path_to_str(moved_lp),\n-                         expr_ty.user_string(self.tcx)));\n+                         expr_ty.user_string(self.tcx), suggestion));\n             }\n \n             move_data::MovePat(pat) => {\n@@ -557,12 +558,28 @@ impl BorrowckCtxt {\n             }\n \n             move_data::Captured(expr) => {\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                let suggestion = move_suggestion(self.tcx, expr_ty,\n+                        \"moved by default (make a copy and \\\n+                         capture that instead to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved into closure environment here \\\n-                          because its type is moved by default \\\n-                          (make a copy and capture that instead to override)\",\n-                         self.loan_path_to_str(moved_lp)));\n+                    fmt!(\"`%s` moved into closure environment here because it \\\n+                          has type `%s`, which is %s\",\n+                         self.loan_path_to_str(moved_lp),\n+                         expr_ty.user_string(self.tcx), suggestion));\n+            }\n+        }\n+\n+        fn move_suggestion(tcx: ty::ctxt, ty: ty::t, default_msg: &'static str)\n+                          -> &'static str {\n+            match ty::get(ty).sty {\n+                ty::ty_closure(ref cty) if cty.sigil == ast::BorrowedSigil =>\n+                    \"a non-copyable stack closure (capture it in a new closure, \\\n+                     e.g. `|x| f(x)`, to override)\",\n+                _ if !ty::type_is_copyable(tcx, ty) =>\n+                    \"non-copyable (perhaps you meant to use clone()?)\",\n+                _ => default_msg,\n             }\n         }\n     }"}, {"sha": "73adade7a5d7162fc90c6fbce270437d93c39c8f", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -506,7 +506,7 @@ impl FlowedMoveData {\n         for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n-            if base_indices.iter().any_(|x| x == &moved_path) {\n+            if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n                 if !f(move, self.move_data.path(moved_path).loan_path) {\n@@ -535,7 +535,7 @@ impl FlowedMoveData {\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n-        self.move_data.assignee_ids.iter().any_(|x| x == &id)\n+        self.move_data.assignee_ids.iter().any(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,"}, {"sha": "26a03b362e3567fe4ff55c25898e1a1c39763cb1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -112,7 +112,7 @@ pub fn check_expr(sess: Session,\n                               \"` in a constant expression\");\n             }\n           }\n-          expr_path(pth) => {\n+          expr_path(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n     (visitor.visit_item)(it, (env, visitor));\n \n     fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n-        if env.idstack.iter().any_(|x| x == &(it.id)) {\n+        if env.idstack.iter().any(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);"}, {"sha": "0baeb8ce57c6cae2b2299252d3254f30ec24003b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -95,7 +95,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n+       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@pat]]>().concat_vec();\n        if arms.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n@@ -265,7 +265,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            &m.filter_mapped(|r| default(cx, *r)),\n+                            &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n               useful_ => useful(left_ty, /*bad*/copy *ctor),\n               ref u => (/*bad*/copy *u)\n@@ -287,7 +287,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = m.filter_mapped(|r| specialize(cx, *r, &ctor, arity, lty));\n+    let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n     let could_be_useful = is_useful(\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n@@ -371,7 +371,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n             for (*variants).iter().advance |v| {\n-                if !found.iter().any_(|x| x == &(variant(v.id))) {\n+                if !found.iter().any(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n             }\n@@ -397,14 +397,14 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = do m.filter_mapped |r| {\n+        let vec_pat_lens = do m.iter().filter_map |r| {\n             match r[0].node {\n                 pat_vec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        };\n+        }.collect::<~[(uint, bool)]>();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n@@ -805,13 +805,13 @@ pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_struct(_, ref fields, _) => {\n-        fields.iter().any_(|f| is_refutable(cx, f.pat))\n+        fields.iter().any(|f| is_refutable(cx, f.pat))\n       }\n       pat_tup(ref elts) => {\n-        elts.iter().any_(|elt| is_refutable(cx, *elt))\n+        elts.iter().any(|elt| is_refutable(cx, *elt))\n       }\n       pat_enum(_, Some(ref args)) => {\n-        args.iter().any_(|a| is_refutable(cx, *a))\n+        args.iter().any(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n       pat_vec(*) => { true }"}, {"sha": "e054b84984d15aee1b1e375712b4febc2a82fe9f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -341,14 +341,14 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n                 let entry_str = bits_to_str(on_entry);\n \n                 let gens = self.gens.slice(start, end);\n-                let gens_str = if gens.iter().any_(|&u| u != 0) {\n+                let gens_str = if gens.iter().any(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n                 let kills = self.kills.slice(start, end);\n-                let kills_str = if kills.iter().any_(|&u| u != 0) {\n+                let kills_str = if kills.iter().any(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n                     ~\"\"\n@@ -643,7 +643,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n \n                 // is this a return from a `for`-loop closure?\n-                match loop_scopes.iter().position_(|s| s.loop_kind == ForLoop) {\n+                match loop_scopes.iter().position(|s| s.loop_kind == ForLoop) {\n                     Some(i) => {\n                         // if so, add the in_out bits to the state\n                         // upon exit. Remember that we cannot count\n@@ -916,7 +916,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             Some(_) => {\n                 match self.tcx().def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        match loop_scopes.iter().position_(|l| l.loop_id == loop_id) {\n+                        match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {\n                                 self.tcx().sess.span_bug("}, {"sha": "a9454d1b23096e64a2942adefd20440bc95a22a3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -117,15 +117,15 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(trait_ref), self_type, _) => {\n+            item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n                     None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n                     Some(&trait_def) => {\n                         let trait_def_id = ast_util::def_id_of_def(trait_def);\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n-                                ty_path(_, bounds, path_node_id) => {\n+                                ty_path(_, ref bounds, path_node_id) => {\n                                     assert!(bounds.is_none());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n@@ -198,8 +198,9 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n-            \"attempted dynamic environment capture\");\n-    }\n+            \"can't capture dynamic environment in a fn item; \\\n+            use the || { ... } closure form instead\");\n+    } // same check is done in resolve.rs, but shouldn't be done\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n@@ -320,7 +321,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_expr(e, (cx, v));\n }\n \n-fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n+fn check_ty(aty: &Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n@@ -535,7 +536,7 @@ pub fn check_cast_for_escaping_regions(\n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.iter().any_(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any(|r| is_re_scope(*r)) {\n         return; /* case (1) */\n     }\n \n@@ -550,7 +551,7 @@ pub fn check_cast_for_escaping_regions(\n         |_r| {\n             // FIXME(#5723) --- turn this check on once &Objects are usable\n             //\n-            // if !target_regions.iter().any_(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n             //         fmt!(\"source contains borrowed pointer with lifetime \\\n@@ -564,7 +565,7 @@ pub fn check_cast_for_escaping_regions(\n         |ty| {\n             match ty::get(ty).sty {\n                 ty::ty_param(source_param) => {\n-                    if target_params.iter().any_(|x| x == &source_param) {\n+                    if target_params.iter().any(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n                         check_durable(cx.tcx, ty, source.span); /* case (3) */"}, {"sha": "d4d1997a56f250d4db38314535a04a379017735f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -63,33 +63,34 @@ pub enum LangItem {\n     FailFnLangItem,                    // 24\n     FailBoundsCheckFnLangItem,         // 25\n     ExchangeMallocFnLangItem,          // 26\n-    ClosureExchangeMallocFnLangItem,   // 27\n-    ExchangeFreeFnLangItem,            // 28\n-    MallocFnLangItem,                  // 29\n-    FreeFnLangItem,                    // 30\n-    BorrowAsImmFnLangItem,             // 31\n-    BorrowAsMutFnLangItem,             // 32\n-    ReturnToMutFnLangItem,             // 33\n-    CheckNotBorrowedFnLangItem,        // 34\n-    StrDupUniqFnLangItem,              // 35\n-    RecordBorrowFnLangItem,            // 36\n-    UnrecordBorrowFnLangItem,          // 37\n-\n-    StartFnLangItem,                   // 38\n-\n-    TyDescStructLangItem,              // 39\n-    TyVisitorTraitLangItem,            // 40\n-    OpaqueStructLangItem,              // 41\n+    VectorExchangeMallocFnLangItem,    // 27\n+    ClosureExchangeMallocFnLangItem,   // 28\n+    ExchangeFreeFnLangItem,            // 29\n+    MallocFnLangItem,                  // 30\n+    FreeFnLangItem,                    // 31\n+    BorrowAsImmFnLangItem,             // 32\n+    BorrowAsMutFnLangItem,             // 33\n+    ReturnToMutFnLangItem,             // 34\n+    CheckNotBorrowedFnLangItem,        // 35\n+    StrDupUniqFnLangItem,              // 36\n+    RecordBorrowFnLangItem,            // 37\n+    UnrecordBorrowFnLangItem,          // 38\n+\n+    StartFnLangItem,                   // 39\n+\n+    TyDescStructLangItem,              // 40\n+    TyVisitorTraitLangItem,            // 41\n+    OpaqueStructLangItem,              // 42\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..42]\n+    items: [Option<def_id>, ..43]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..42 ]\n+            items: [ None, ..43 ]\n         }\n     }\n \n@@ -129,23 +130,24 @@ impl LanguageItems {\n             24 => \"fail_\",\n             25 => \"fail_bounds_check\",\n             26 => \"exchange_malloc\",\n-            27 => \"closure_exchange_malloc\",\n-            28 => \"exchange_free\",\n-            29 => \"malloc\",\n-            30 => \"free\",\n-            31 => \"borrow_as_imm\",\n-            32 => \"borrow_as_mut\",\n-            33 => \"return_to_mut\",\n-            34 => \"check_not_borrowed\",\n-            35 => \"strdup_uniq\",\n-            36 => \"record_borrow\",\n-            37 => \"unrecord_borrow\",\n-\n-            38 => \"start\",\n-\n-            39 => \"ty_desc\",\n-            40 => \"ty_visitor\",\n-            41 => \"opaque\",\n+            27 => \"vector_exchange_malloc\",\n+            28 => \"closure_exchange_malloc\",\n+            29 => \"exchange_free\",\n+            30 => \"malloc\",\n+            31 => \"free\",\n+            32 => \"borrow_as_imm\",\n+            33 => \"borrow_as_mut\",\n+            34 => \"return_to_mut\",\n+            35 => \"check_not_borrowed\",\n+            36 => \"strdup_uniq\",\n+            37 => \"record_borrow\",\n+            38 => \"unrecord_borrow\",\n+\n+            39 => \"start\",\n+\n+            40 => \"ty_desc\",\n+            41 => \"ty_visitor\",\n+            42 => \"opaque\",\n \n             _ => \"???\"\n         }\n@@ -238,6 +240,9 @@ impl LanguageItems {\n     pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n+    pub fn vector_exchange_malloc_fn(&self) -> def_id {\n+        self.items[VectorExchangeMallocFnLangItem as uint].get()\n+    }\n     pub fn closure_exchange_malloc_fn(&self) -> def_id {\n         self.items[ClosureExchangeMallocFnLangItem as uint].get()\n     }\n@@ -331,6 +336,7 @@ impl<'self> LanguageItemCollector<'self> {\n         item_refs.insert(@\"fail_bounds_check\",\n                          FailBoundsCheckFnLangItem as uint);\n         item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"vector_exchange_malloc\", VectorExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"closure_exchange_malloc\", ClosureExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n         item_refs.insert(@\"malloc\", MallocFnLangItem as uint);"}, {"sha": "0fc19ffd78e521ab8694a0c743f5822cc5b725b2", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,7 +14,6 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n-use std::char;\n use std::cmp;\n use std::hashmap::HashMap;\n use std::i16;\n@@ -25,7 +24,6 @@ use std::u16;\n use std::u32;\n use std::u64;\n use std::u8;\n-use std::vec;\n use extra::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -80,6 +78,7 @@ pub enum lint {\n     non_implicitly_copyable_typarams,\n     deprecated_pattern,\n     non_camel_case_types,\n+    non_uppercase_statics,\n     type_limits,\n     default_methods,\n     unused_unsafe,\n@@ -198,6 +197,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: allow\n      }),\n \n+    (\"non_uppercase_statics\",\n+     LintSpec {\n+         lint: non_uppercase_statics,\n+         desc: \"static constants should have uppercase identifiers\",\n+         default: warn\n+     }),\n+\n     (\"managed_heap_memory\",\n      LintSpec {\n         lint: managed_heap_memory,\n@@ -741,9 +747,9 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n         for decl.inputs.iter().advance |in| {\n-            check_ty(cx, in.ty);\n+            check_ty(cx, &in.ty);\n         }\n-        check_ty(cx, decl.output)\n+        check_ty(cx, &decl.output)\n     }\n \n     match it.node {\n@@ -753,7 +759,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                 ast::foreign_item_fn(ref decl, _, _) => {\n                     check_foreign_fn(cx, decl);\n                 }\n-                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n+                ast::foreign_item_static(ref t, _) => { check_ty(cx, t); }\n             }\n         }\n       }\n@@ -854,7 +860,10 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n         let ident = ident.trim_chars(&'_');\n-        char::is_uppercase(ident.char_at(0)) &&\n+\n+        // start with a non-lowercase letter rather than non-uppercase\n+        // ones (some scripts don't have a concept of upper/lowercase)\n+        !ident.char_at(0).is_lowercase() &&\n             !ident.contains_char('_')\n     }\n \n@@ -881,6 +890,23 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     }\n }\n \n+fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n+    match it.node {\n+        // only check static constants\n+        ast::item_static(_, ast::m_imm, _) => {\n+            let s = cx.tcx.sess.str_of(it.ident);\n+            // check for lowercase letters rather than non-uppercase\n+            // ones (some scripts don't have a concept of\n+            // upper/lowercase)\n+            if s.iter().any(|c| c.is_lowercase()) {\n+                cx.span_lint(non_uppercase_statics, it.span,\n+                             \"static constant should have an uppercase identifier\");\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n@@ -940,10 +966,6 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n             visit_fn_decl(cx, &tm.decl);\n             visit::visit_ty_method(tm, (cx, vt));\n         },\n-        visit_struct_method: |sm, (cx, vt)| {\n-            visit_fn_decl(cx, &sm.decl);\n-            visit::visit_struct_method(sm, (cx, vt));\n-        },\n         visit_trait_method: |tm, (cx, vt)| {\n             match *tm {\n                 ast::required(ref tm) => visit_fn_decl(cx, &tm.decl),\n@@ -960,7 +982,7 @@ fn lint_session() -> visit::vt<@mut Context> {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                do vec::consume(l) |_, (lint, span, msg)| {\n+                for l.consume_iter().advance |(lint, span, msg)| {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }\n@@ -1016,21 +1038,13 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n         // If we have doc(hidden), nothing to do\n         if cx.doc_hidden { return }\n         // If we're documented, nothing to do\n-        if attrs.iter().any_(|a| a.node.is_sugared_doc) { return }\n+        if attrs.iter().any(|a| a.node.is_sugared_doc) { return }\n \n         // otherwise, warn!\n         cx.span_lint(missing_doc, sp, msg);\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_struct_method: |m, (cx, vt)| {\n-            if m.vis == ast::public {\n-                check_attrs(cx, m.attrs, m.span,\n-                            \"missing documentation for a method\");\n-            }\n-            visit::visit_struct_method(m, (cx, vt));\n-        },\n-\n         visit_ty_method: |m, (cx, vt)| {\n             // All ty_method objects are linted about because they're part of a\n             // trait (no visibility)\n@@ -1143,6 +1157,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n                     }\n                     check_item_ctypes(cx, it);\n                     check_item_non_camel_case_types(cx, it);\n+                    check_item_non_uppercase_statics(cx, it);\n                     check_item_default_methods(cx, it);\n                     check_item_heap(cx, it);\n "}, {"sha": "f3d4abcdf310f79cf69fdbc1632913eb877c0279", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -390,8 +390,8 @@ impl VisitContext {\n                     // any fields which (1) were not explicitly\n                     // specified and (2) have a type that\n                     // moves-by-default:\n-                    let consume_with = with_fields.iter().any_(|tf| {\n-                        !fields.iter().any_(|f| f.node.ident == tf.ident) &&\n+                    let consume_with = with_fields.iter().any(|tf| {\n+                        !fields.iter().any(|f| f.node.ident == tf.ident) &&\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n "}, {"sha": "7dd7ae6ec9ae0a71f86513d37a35a936f282a059", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -71,10 +71,10 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, node_id, span, @Path)) {\n+                    it: &fn(binding_mode, node_id, span, &Path)) {\n     for walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {\n+          pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}"}, {"sha": "8a2b134191534a9c32bb11a2b2bafec63a8f15be", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -245,13 +245,21 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                  method_id: def_id,\n                                  name: &ident) =\n             |span, method_id, name| {\n+        // If the method is a default method, we need to use the def_id of\n+        // the default implementation.\n+        // Having to do this this is really unfortunate.\n+        let method_id = match tcx.provided_method_sources.find(&method_id) {\n+            None => method_id,\n+            Some(source) => source.method_id\n+        };\n+\n         if method_id.crate == local_crate {\n             let is_private = method_is_private(span, method_id.node);\n             let container_id = local_method_container_id(span,\n                                                          method_id.node);\n             if is_private &&\n                     (container_id.crate != local_crate ||\n-                     !privileged_items.iter().any_(|x| x == &(container_id.node))) {\n+                     !privileged_items.iter().any(|x| x == &(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n@@ -268,7 +276,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     };\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: @Path) =\n+    let check_path: @fn(span: span, def: def, path: &Path) =\n             |span, def, path| {\n         debug!(\"checking path\");\n         match def {\n@@ -279,7 +287,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             def_fn(def_id, _) => {\n                 if def_id.crate == local_crate {\n                     if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.iter().any_(|x| x == &def_id.node) {\n+                            !privileged_items.iter().any(|x| x == &def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n@@ -324,7 +332,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                         provided(method)\n                                              if method.vis == private &&\n                                              !privileged_items.iter()\n-                                             .any_(|x| x == &(trait_id.node)) => {\n+                                             .any(|x| x == &(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n@@ -409,7 +417,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate || !privileged_items.iter()\n-                                .any_(|x| x == &(id.node)) => {\n+                                .any(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n                             check_field(expr.span, id, ident);\n                         }\n@@ -422,7 +430,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n-                           !privileged_items.iter().any_(|x| x == &(id.node)) => {\n+                           !privileged_items.iter().any(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n@@ -441,14 +449,14 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         _ => {}\n                     }\n                 }\n-                expr_path(path) => {\n+                expr_path(ref path) => {\n                     check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for (*fields).iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n@@ -459,7 +467,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).iter().advance |field| {\n@@ -496,7 +504,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 check_variant(expr.span, id);\n                             }\n                         }\n@@ -514,7 +522,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for fields.iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n@@ -525,7 +533,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &enum_id.node) {\n+                                    !privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n                                         for fields.iter().advance |field| {"}, {"sha": "70833813cc0877f7cef8669dcf1367b1cc50759a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -141,7 +141,7 @@ impl ReachableContext {\n                             }\n                         }\n                     }\n-                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                    item_impl(ref generics, ref trait_ref, _, ref methods) => {\n                         // XXX(pcwalton): We conservatively assume any methods\n                         // on a trait implementation are reachable, when this\n                         // is not the case. We could be more precise by only"}, {"sha": "e1c43121ec82be8c7265cf349c09a5b205bbaab8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -78,7 +78,7 @@ impl RegionMaps {\n     pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n             Some(sups) => {\n-                if !sups.iter().any_(|x| x == &sup) {\n+                if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n                 }\n                 return;\n@@ -202,7 +202,7 @@ impl RegionMaps {\n                             return true;\n                         }\n \n-                        if !queue.iter().any_(|x| x == parent) {\n+                        if !queue.iter().any(|x| x == parent) {\n                             queue.push(*parent);\n                         }\n                     }\n@@ -612,7 +612,7 @@ impl DetermineRpCtxt {\n             ambient_variance: self.ambient_variance,\n             id: self.item_id\n         };\n-        if !vec.iter().any_(|x| x == &dep) { vec.push(dep); }\n+        if !vec.iter().any(|x| x == &dep) { vec.push(dep); }\n     }\n \n     // Determines whether a reference to a region that appears in the\n@@ -651,18 +651,18 @@ impl DetermineRpCtxt {\n     // with &self type, &self is also bound.  We detect those last two\n     // cases via flags (anon_implies_rp and self_implies_rp) that are\n     // true when the anon or self region implies RP.\n-    pub fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n+    pub fn region_is_relevant(&self, r: &Option<ast::Lifetime>) -> bool {\n         match r {\n-            None => {\n+            &None => {\n                 self.anon_implies_rp\n             }\n-            Some(ref l) if l.ident == special_idents::statik => {\n+            &Some(ref l) if l.ident == special_idents::statik => {\n                 false\n             }\n-            Some(ref l) if l.ident == special_idents::self_ => {\n+            &Some(ref l) if l.ident == special_idents::self_ => {\n                 true\n             }\n-            Some(_) => {\n+            &Some(_) => {\n                 false\n             }\n         }\n@@ -713,10 +713,10 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.iter().advance |a| {\n-                (visitor.visit_ty)(a.ty, (cx, visitor));\n+                (visitor.visit_ty)(&a.ty, (cx, visitor));\n             }\n         }\n-        (visitor.visit_ty)(decl.output, (cx, visitor));\n+        (visitor.visit_ty)(&decl.output, (cx, visitor));\n         let generics = visit::generics_of_fn(fk);\n         (visitor.visit_generics)(&generics, (cx, visitor));\n         (visitor.visit_block)(body, (cx, visitor));\n@@ -731,7 +731,7 @@ fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n     }\n }\n \n-fn determine_rp_in_ty(ty: @ast::Ty,\n+fn determine_rp_in_ty(ty: &ast::Ty,\n                       (cx, visitor): (@mut DetermineRpCtxt,\n                                       visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n@@ -747,7 +747,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // locations)\n     let sess = cx.sess;\n     match ty.node {\n-        ast::ty_rptr(r, _) => {\n+        ast::ty_rptr(ref r, _) => {\n             debug!(\"referenced rptr type %s\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n@@ -762,7 +762,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n-                    if cx.region_is_relevant(f.region) {\n+                    if cx.region_is_relevant(&f.region) {\n                         let rv = cx.add_variance(rv_contravariant);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -784,13 +784,13 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, _bounds, id) => {\n+      ast::ty_path(ref path, _, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n-                if cx.region_is_relevant(path.rp) {\n+                if cx.region_is_relevant(&path.rp) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -800,7 +800,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(path.rp) {\n+                    if cx.region_is_relevant(&path.rp) {\n                         let rv = cx.add_variance(variance);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -815,16 +815,16 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n \n     match ty.node {\n-      ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n-      ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n+      ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n+      ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _bounds, _) => {\n+      ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {\n-                (visitor.visit_ty)(*tp, (cx, visitor));\n+                (visitor.visit_ty)(tp, (cx, visitor));\n             }\n         }\n       }\n@@ -837,10 +837,10 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.iter().advance |a| {\n-                    (visitor.visit_ty)(a.ty, (cx, visitor));\n+                    (visitor.visit_ty)(&a.ty, (cx, visitor));\n                 }\n             }\n-            (visitor.visit_ty)(decl.output, (cx, visitor));\n+            (visitor.visit_ty)(&decl.output, (cx, visitor));\n         }\n       }\n \n@@ -849,7 +849,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n       }\n     }\n \n-    fn visit_mt(mt: ast::mt,\n+    fn visit_mt(mt: &ast::mt,\n                 (cx, visitor): (@mut DetermineRpCtxt,\n                                 visit::vt<@mut DetermineRpCtxt>)) {\n         // mutability is invariant"}, {"sha": "041d52a690425925d2230ab376a13e76c3f30e79", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 69, "deletions": 68, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -41,7 +41,6 @@ use syntax::opt_vec::OptVec;\n \n use std::str;\n use std::uint;\n-use std::vec;\n use std::hashmap::{HashMap, HashSet};\n use std::util;\n \n@@ -511,6 +510,13 @@ pub struct NameBindings {\n     value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n }\n \n+/// Ways in which a trait can be referenced\n+enum TraitReferenceType {\n+    TraitImplementation,             // impl SomeTrait for T { ... }\n+    TraitDerivation,                 // trait T : SomeTrait { ... }\n+    TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n+}\n+\n impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n     pub fn define_module(@mut self,\n@@ -1227,7 +1233,7 @@ impl Resolver {\n                 visit_item(item, (new_parent, visitor));\n             }\n \n-            item_impl(_, None, ty, ref methods) => {\n+            item_impl(_, None, ref ty, ref methods) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1237,9 +1243,9 @@ impl Resolver {\n                 // the same module that declared the type.\n \n                 // Create the module and add all methods.\n-                match *ty {\n-                    Ty {\n-                        node: ty_path(path, _, _),\n+                match ty {\n+                    &Ty {\n+                        node: ty_path(ref path, _, _),\n                         _\n                     } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n@@ -1307,7 +1313,7 @@ impl Resolver {\n                 visit_item(item, (parent, visitor));\n             }\n \n-            item_impl(_, Some(_), _ty, ref _methods) => {\n+            item_impl(_, Some(_), _, _) => {\n                 visit_item(item, (parent, visitor));\n             }\n \n@@ -1426,7 +1432,7 @@ impl Resolver {\n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n     pub fn build_reduced_graph_for_view_item(@mut self,\n-                                             view_item: @view_item,\n+                                             view_item: &view_item,\n                                              (parent, _):\n                                              (ReducedGraphParent,\n                                               vt<ReducedGraphParent>)) {\n@@ -1440,7 +1446,7 @@ impl Resolver {\n \n                     let mut module_path = ~[];\n                     match view_path.node {\n-                        view_path_simple(_, full_path, _) => {\n+                        view_path_simple(_, ref full_path, _) => {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n@@ -1451,8 +1457,8 @@ impl Resolver {\n                             }\n                         }\n \n-                        view_path_glob(module_ident_path, _) |\n-                        view_path_list(module_ident_path, _, _) => {\n+                        view_path_glob(ref module_ident_path, _) |\n+                        view_path_list(ref module_ident_path, _, _) => {\n                             for module_ident_path.idents.iter().advance |ident| {\n                                 module_path.push(*ident);\n                             }\n@@ -1462,7 +1468,7 @@ impl Resolver {\n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, id) => {\n+                        view_path_simple(binding, ref full_path, id) => {\n                             let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n@@ -3382,7 +3388,8 @@ impl Resolver {\n \n                         self.session.span_err(\n                             span,\n-                            \"attempted dynamic environment-capture\");\n+                            \"can't capture dynamic environment in a fn item; \\\n+                            use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n@@ -3404,7 +3411,8 @@ impl Resolver {\n \n                         self.session.span_err(\n                             span,\n-                            \"attempted dynamic environment-capture\");\n+                            \"can't capture dynamic environment in a fn item; \\\n+                            use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n@@ -3525,8 +3533,8 @@ impl Resolver {\n             }\n \n             item_impl(ref generics,\n-                      implemented_traits,\n-                      self_type,\n+                      ref implemented_traits,\n+                      ref self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n@@ -3553,23 +3561,7 @@ impl Resolver {\n \n                     // Resolve derived traits.\n                     for traits.iter().advance |trt| {\n-                        match self.resolve_path(trt.path, TypeNS, true,\n-                                                visitor) {\n-                            None =>\n-                                self.session.span_err(trt.path.span,\n-                                                      \"attempt to derive a \\\n-                                                      nonexistent trait\"),\n-                            Some(def) => {\n-                                // Write a mapping from the trait ID to the\n-                                // definition of the trait into the definition\n-                                // map.\n-\n-                                debug!(\"(resolving trait) found trait def: \\\n-                                       %?\", def);\n-\n-                                self.record_def(trt.ref_id, def);\n-                            }\n-                        }\n+                        self.resolve_trait_reference(trt, visitor, TraitDerivation);\n                     }\n \n                     for (*methods).iter().advance |method| {\n@@ -3593,10 +3585,10 @@ impl Resolver {\n                                     visitor);\n \n                                 for ty_m.decl.inputs.iter().advance |argument| {\n-                                    self.resolve_type(argument.ty, visitor);\n+                                    self.resolve_type(&argument.ty, visitor);\n                                 }\n \n-                                self.resolve_type(ty_m.decl.output, visitor);\n+                                self.resolve_type(&ty_m.decl.output, visitor);\n                             }\n                           }\n                           provided(m) => {\n@@ -3786,12 +3778,12 @@ impl Resolver {\n                                              None,\n                                              visitor);\n \n-                        self.resolve_type(argument.ty, visitor);\n+                        self.resolve_type(&argument.ty, visitor);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    self.resolve_type(declaration.output, visitor);\n+                    self.resolve_type(&declaration.output, visitor);\n                 }\n             }\n \n@@ -3819,23 +3811,32 @@ impl Resolver {\n                                         type_parameter_bound: &TyParamBound,\n                                         visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n-            TraitTyParamBound(tref) => {\n-                self.resolve_trait_reference(tref, visitor)\n+            TraitTyParamBound(ref tref) => {\n+                self.resolve_trait_reference(tref, visitor, TraitBoundingTypeParameter)\n             }\n             RegionTyParamBound => {}\n         }\n     }\n \n     pub fn resolve_trait_reference(@mut self,\n                                    trait_reference: &trait_ref,\n-                                   visitor: ResolveVisitor) {\n-        match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n+                                   visitor: ResolveVisitor,\n+                                   reference_type: TraitReferenceType) {\n+        match self.resolve_path(&trait_reference.path, TypeNS, true, visitor) {\n             None => {\n-                self.session.span_err(trait_reference.path.span,\n-                                      \"attempt to implement an \\\n-                                       unknown trait\");\n+                let path_str = self.idents_to_str(trait_reference.path.idents);\n+\n+                let usage_str = match reference_type {\n+                    TraitBoundingTypeParameter => \"bound type parameter with\",\n+                    TraitImplementation        => \"implement\",\n+                    TraitDerivation            => \"derive\"\n+                };\n+\n+                let msg = fmt!(\"attempt to %s a nonexistent trait `%s`\", usage_str, path_str);\n+                self.session.span_err(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n+                debug!(\"(resolving trait) found trait def: %?\", def);\n                 self.record_def(trait_reference.ref_id, def);\n             }\n         }\n@@ -3877,7 +3878,7 @@ impl Resolver {\n \n             // Resolve fields.\n             for fields.iter().advance |field| {\n-                self.resolve_type(field.node.ty, visitor);\n+                self.resolve_type(&field.node.ty, visitor);\n             }\n         }\n     }\n@@ -3912,8 +3913,8 @@ impl Resolver {\n     pub fn resolve_implementation(@mut self,\n                                   id: node_id,\n                                   generics: &Generics,\n-                                  opt_trait_reference: Option<@trait_ref>,\n-                                  self_type: @Ty,\n+                                  opt_trait_reference: &Option<trait_ref>,\n+                                  self_type: &Ty,\n                                   methods: &[@method],\n                                   visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n@@ -3928,8 +3929,8 @@ impl Resolver {\n             // Resolve the trait reference, if necessary.\n             let original_trait_refs;\n             match opt_trait_reference {\n-                Some(trait_reference) => {\n-                    self.resolve_trait_reference(trait_reference, visitor);\n+                &Some(ref trait_reference) => {\n+                    self.resolve_trait_reference(trait_reference, visitor, TraitImplementation);\n \n                     // Record the current set of trait references.\n                     let mut new_trait_refs = ~[];\n@@ -3943,7 +3944,7 @@ impl Resolver {\n                         &mut self.current_trait_refs,\n                         Some(new_trait_refs)));\n                 }\n-                None => {\n+                &None => {\n                     original_trait_refs = None;\n                 }\n             }\n@@ -4000,7 +4001,7 @@ impl Resolver {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n-        self.resolve_type(local.node.ty, visitor);\n+        self.resolve_type(&local.node.ty, visitor);\n \n         // Resolve the initializer, if necessary.\n         match local.node.init {\n@@ -4111,12 +4112,12 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n+    pub fn resolve_type(@mut self, ty: &Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(path, bounds, path_id) => {\n+            ty_path(ref path, ref bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4210,7 +4211,7 @@ impl Resolver {\n         let pat_id = pattern.id;\n         for walk_pat(pattern) |pattern| {\n             match pattern.node {\n-                pat_ident(binding_mode, path, _)\n+                pat_ident(binding_mode, ref path, _)\n                         if !path.global && path.idents.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n@@ -4333,11 +4334,11 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n-                pat_ident(binding_mode, path, _) => {\n+                pat_ident(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_variant(*)) |\n@@ -4366,11 +4367,11 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n-                pat_enum(path, _) => {\n+                pat_enum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_fn(*))      |\n@@ -4395,7 +4396,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n@@ -4408,7 +4409,7 @@ impl Resolver {\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n-                pat_struct(path, _, _) => {\n+                pat_struct(ref path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains(&class_id) => {\n@@ -4483,14 +4484,14 @@ impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     pub fn resolve_path(@mut self,\n-                        path: @Path,\n+                        path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n                         visitor: ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n         for path.types.iter().advance |ty| {\n-            self.resolve_type(*ty, visitor);\n+            self.resolve_type(ty, visitor);\n         }\n \n         if path.global {\n@@ -4609,7 +4610,7 @@ impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    pub fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n+    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n         for path.idents.iter().enumerate().advance |(index, ident)| {\n             if index == path.idents.len() - 1 {\n@@ -4623,7 +4624,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_module_relative_path(@mut self,\n-                                        path: @Path,\n+                                        path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n                                         -> Option<def> {\n@@ -4689,7 +4690,7 @@ impl Resolver {\n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     pub fn resolve_crate_relative_path(@mut self,\n-                                       path: @Path,\n+                                       path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n                                        -> Option<def> {\n@@ -4915,7 +4916,7 @@ impl Resolver {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            expr_path(path) => {\n+            expr_path(ref path) => {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n@@ -4984,7 +4985,7 @@ impl Resolver {\n                                       visitor);\n             }\n \n-            expr_struct(path, _, _) => {\n+            expr_struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n@@ -5294,7 +5295,7 @@ impl Resolver {\n         visit_crate(self.crate, ((), vt));\n     }\n \n-    pub fn check_for_item_unused_imports(&mut self, vi: @view_item) {\n+    pub fn check_for_item_unused_imports(&mut self, vi: &view_item) {\n         // Ignore public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n@@ -5360,7 +5361,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(vec::reversed(idents));\n+        return self.idents_to_str(idents.consume_rev_iter().collect::<~[ast::ident]>());\n     }\n \n     pub fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "b7168cbfdec5361b6d684572f481e2af52443d0f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -385,7 +385,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n \n     do m.map |br| {\n         match br.pats[col].node {\n-            ast::pat_ident(_, path, Some(inner)) => {\n+            ast::pat_ident(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n                     br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n@@ -441,7 +441,7 @@ pub fn enter_match<'r>(bcx: block,\n \n                 let this = br.pats[col];\n                 match this.node {\n-                    ast::pat_ident(_, path, None) => {\n+                    ast::pat_ident(_, ref path, None) => {\n                         if pat_is_binding(dm, this) {\n                             let binding_info =\n                                 br.data.bindings_map.get(\n@@ -796,7 +796,7 @@ pub fn enter_region<'r>(bcx: block,\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n-        if set.iter().any_(|l| opt_eq(tcx, l, &val)) {return;}\n+        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -963,7 +963,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.iter().advance |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !idents.iter().any_(|x| *x == field_ident) {\n+            if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }\n@@ -974,7 +974,7 @@ pub fn pats_require_rooting(bcx: block,\n                             m: &[@Match],\n                             col: uint)\n                          -> bool {\n-    do m.iter().any_ |br| {\n+    do m.iter().any |br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n@@ -1003,7 +1003,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        do ($m).iter().any_ |br| {\n+        do ($m).iter().any |br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n@@ -1029,7 +1029,7 @@ pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n-    do m.iter().any_ |br| {\n+    do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n@@ -1095,26 +1095,20 @@ pub fn compare_values(cx: block,\n \n     match ty::get(rhs_t).sty {\n         ty::ty_estr(ty::vstore_uniq) => {\n-            let scratch_result = scratch_datum(cx, ty::mk_bool(), false);\n             let scratch_lhs = alloca(cx, val_ty(lhs));\n             Store(cx, lhs, scratch_lhs);\n             let scratch_rhs = alloca(cx, val_ty(rhs));\n             Store(cx, rhs, scratch_rhs);\n             let did = cx.tcx().lang_items.uniq_str_eq_fn();\n-            let bcx = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs],\n-                                              expr::SaveIn(scratch_result.val));\n-            let result = scratch_result.to_result(bcx);\n+            let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n             Result {\n                 bcx: result.bcx,\n                 val: bool_to_i1(result.bcx, result.val)\n             }\n         }\n         ty::ty_estr(_) => {\n-            let scratch_result = scratch_datum(cx, ty::mk_bool(), false);\n             let did = cx.tcx().lang_items.str_eq_fn();\n-            let bcx = callee::trans_lang_call(cx, did, [lhs, rhs],\n-                                              expr::SaveIn(scratch_result.val));\n-            let result = scratch_result.to_result(bcx);\n+            let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n             Result {\n                 bcx: result.bcx,\n                 val: bool_to_i1(result.bcx, result.val)\n@@ -1395,8 +1389,12 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     if any_uniq_pat(m, col) {\n+        let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n-        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+        let unboxed = match ty::get(pat_ty).sty {\n+            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+            _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+        };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk);\n         return;\n@@ -1868,8 +1866,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n+            let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n-            let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+            let unboxed = match ty::get(pat_ty).sty {\n+                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+                    _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+            };\n             bcx = bind_irrefutable_pat(bcx,\n                                        inner,\n                                        unboxed,"}, {"sha": "dc8f6b1d05b5179f3e06b3b7cb3d44ab716b340d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -131,13 +131,13 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let ftys = do fields.map |field| {\n+            let mut ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n             };\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n-            let ftys =\n-                if dtor { ftys + [ty::mk_bool()] } else { ftys };\n+            if dtor { ftys.push(ty::mk_bool()); }\n+\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -147,7 +147,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                     mk_struct(cx, self.tys, false).size == 0\n                 }\n                 fn find_ptr(&self) -> Option<uint> {\n-                    self.tys.iter().position_(|&ty| mono_data_classify(ty) == MonoNonNull)\n+                    self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n                 }\n             }\n \n@@ -263,7 +263,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)\n-                + [Type::array(&Type::i8(), padding)]\n+                + &[Type::array(&Type::i8(), padding)]\n         }\n     }\n }\n@@ -512,7 +512,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n             let discr_ty = C_int(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n-            C_struct(contents + [padding(max_sz - case.size)])\n+            C_struct(contents + &[padding(max_sz - case.size)])\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr == nndiscr {"}, {"sha": "577f1c68960679567702c17862df3915083013a3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 212, "deletions": 138, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -72,6 +72,7 @@ use std::uint;\n use std::vec;\n use std::local_data;\n use extra::time;\n+use extra::sort;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n use syntax::ast_util::{local_def, path_to_ident};\n@@ -141,6 +142,48 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n+struct StatRecorder<'self> {\n+    ccx: @mut CrateContext,\n+    name: &'self str,\n+    start: u64,\n+    istart: uint,\n+}\n+\n+impl<'self> StatRecorder<'self> {\n+    pub fn new(ccx: @mut CrateContext,\n+               name: &'self str) -> StatRecorder<'self> {\n+        let start = if ccx.sess.trans_stats() {\n+            time::precise_time_ns()\n+        } else {\n+            0\n+        };\n+        let istart = ccx.stats.n_llvm_insns;\n+        StatRecorder {\n+            ccx: ccx,\n+            name: name,\n+            start: start,\n+            istart: istart,\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'self> Drop for StatRecorder<'self> {\n+    pub fn drop(&self) {\n+        if self.ccx.sess.trans_stats() {\n+            let end = time::precise_time_ns();\n+            let elapsed = ((end - self.start) / 1_000_000) as uint;\n+            let iend = self.ccx.stats.n_llvm_insns;\n+            self.ccx.stats.fn_stats.push((self.name.to_owned(),\n+                                          elapsed,\n+                                          iend - self.istart));\n+            self.ccx.stats.n_fns += 1;\n+            // Reset LLVM insn count to avoid compound costs.\n+            self.ccx.stats.n_llvm_insns = self.istart;\n+        }\n+    }\n+}\n+\n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n     let llfn: ValueRef = do name.as_c_str |buf| {\n         unsafe {\n@@ -246,35 +289,48 @@ pub fn malloc_raw_dyn(bcx: block,\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    let (mk_fn, langcall) = match heap {\n-        heap_managed | heap_managed_unique => {\n-            (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n-        }\n-        heap_exchange => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.exchange_malloc_fn())\n-        }\n-        heap_exchange_closure => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n-        }\n-    };\n-\n     if heap == heap_exchange {\n+        let llty_value = type_of::type_of(ccx, t);\n+        let llalign = llalign_of_min(ccx, llty_value);\n+\n+        // Allocate space:\n+        let r = callee::trans_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.exchange_malloc_fn(),\n+            [C_i32(llalign as i32), size],\n+            None);\n+        rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n+    } else if heap == heap_exchange_vector {\n         // Grab the TypeRef type of box_ptr_ty.\n-        let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+        let element_type = match ty::get(t).sty {\n+            ty::ty_unboxed_vec(e) => e,\n+            _ => fail!(\"not a vector body\")\n+        };\n+        let box_ptr_ty = ty::mk_evec(bcx.tcx(), element_type, ty::vstore_uniq);\n         let llty = type_of(ccx, box_ptr_ty);\n \n         let llty_value = type_of::type_of(ccx, t);\n         let llalign = llalign_of_min(ccx, llty_value);\n \n         // Allocate space:\n-        let rval = alloca(bcx, Type::i8p());\n-        let bcx = callee::trans_lang_call(\n+        let r = callee::trans_lang_call(\n             bcx,\n-            langcall,\n+            bcx.tcx().lang_items.vector_exchange_malloc_fn(),\n             [C_i32(llalign as i32), size],\n-            expr::SaveIn(rval));\n-        rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty))\n+            None);\n+        rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     } else {\n+        // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n+        let (mk_fn, langcall) = match heap {\n+            heap_managed | heap_managed_unique => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n+            }\n+            heap_exchange_closure => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n+            }\n+            _ => fail!(\"heap_exchange/heap_exchange_vector already handled\")\n+        };\n+\n         // Grab the TypeRef type of box_ptr_ty.\n         let box_ptr_ty = mk_fn(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n@@ -285,13 +341,12 @@ pub fn malloc_raw_dyn(bcx: block,\n \n         // Allocate space:\n         let tydesc = PointerCast(bcx, static_ti.tydesc, Type::i8p());\n-        let rval = alloca(bcx, Type::i8p());\n-        let bcx = callee::trans_lang_call(\n+        let r = callee::trans_lang_call(\n             bcx,\n             langcall,\n             [tydesc, size],\n-            expr::SaveIn(rval));\n-        let r = rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty));\n+            None);\n+        let r = rslt(r.bcx, PointerCast(r.bcx, r.val, llty));\n         maybe_set_managed_unique_rc(r.bcx, r.val, heap);\n         r\n     }\n@@ -316,16 +371,17 @@ pub struct MallocResult {\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n+    assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n \n     MallocResult { bcx: bcx, box: llbox, body: body }\n }\n \n-pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n-    -> MallocResult {\n-        let ty = type_of(bcx.ccx(), t);\n+pub fn malloc_general(bcx: block, t: ty::t, heap: heap) -> MallocResult {\n+    let ty = type_of(bcx.ccx(), t);\n+    assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n@@ -342,6 +398,7 @@ pub fn heap_for_unique(bcx: block, t: ty::t) -> heap {\n }\n \n pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n+    assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n         // managed heap (thus have refcount 1 from the managed allocator),\n@@ -353,11 +410,6 @@ pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n     }\n }\n \n-pub fn malloc_unique(bcx: block, t: ty::t)\n-    -> MallocResult {\n-    malloc_general(bcx, t, heap_for_unique(bcx, t))\n-}\n-\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {\n@@ -863,10 +915,10 @@ pub fn need_invoke(bcx: block) -> bool {\n \n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n+    let mut cur_scope = cur.scope;\n     loop {\n-        match cur.kind {\n-            block_scope(inf) => {\n-                let inf = &mut *inf; // FIXME(#5074) workaround old borrowck\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n                 for inf.cleanups.iter().advance |cleanup| {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n@@ -876,12 +928,15 @@ pub fn need_invoke(bcx: block) -> bool {\n                         }\n                     }\n                 }\n+                inf.parent\n+            }\n+            None => {\n+                cur = match cur.parent {\n+                    Some(next) => next,\n+                    None => return false\n+                };\n+                cur.scope\n             }\n-            _ => ()\n-        }\n-        cur = match cur.parent {\n-          Some(next) => next,\n-          None => return false\n         }\n     }\n }\n@@ -899,23 +954,21 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n \n pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     let mut bcx = bcx;\n+    let mut cur_scope = bcx.scope;\n     loop {\n-        {\n-            match bcx.kind {\n-                block_scope(inf) => {\n-                    let len = { // FIXME(#5074) workaround old borrowck\n-                        let inf = &mut *inf;\n-                        inf.cleanups.len()\n-                    };\n-                    if len > 0u || bcx.parent.is_none() {\n-                        f(inf);\n-                        return;\n-                    }\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n+                if !inf.empty_cleanups() || (inf.parent.is_none() && bcx.parent.is_none()) {\n+                    f(inf);\n+                    return;\n                 }\n-                _ => ()\n+                inf.parent\n+            }\n+            None => {\n+                bcx = block_parent(bcx);\n+                bcx.scope\n             }\n         }\n-        bcx = block_parent(bcx);\n     }\n }\n \n@@ -972,27 +1025,31 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n     let mut bcx_sid = bcx;\n+    let mut cur_scope = bcx_sid.scope;\n     loop {\n-        bcx_sid = match bcx_sid.node_info {\n-            Some(NodeInfo { id, _ }) if id == scope_id => {\n-                return bcx_sid\n-              }\n-\n-                // FIXME(#6268, #6248) hacky cleanup for nested method calls\n-                Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n-                    return bcx_sid\n-                }\n-\n-                _ => {\n-                    match bcx_sid.parent {\n-                        None => bcx.tcx().sess.bug(\n-                            fmt!(\"no enclosing scope with id %d\", scope_id)),\n-                        Some(bcx_par) => bcx_par\n+        cur_scope = match cur_scope {\n+            Some(inf) => {\n+                match inf.node_info {\n+                    Some(NodeInfo { id, _ }) if id == scope_id => {\n+                        return bcx_sid\n+                    }\n+                    // FIXME(#6268, #6248) hacky cleanup for nested method calls\n+                    Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                        return bcx_sid\n                     }\n+                    _ => inf.parent\n                 }\n             }\n+            None => {\n+                bcx_sid = match bcx_sid.parent {\n+                    None => bcx.tcx().sess.bug(fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                    Some(bcx_par) => bcx_par\n+                };\n+                bcx_sid.scope\n+            }\n         }\n     }\n+}\n \n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n@@ -1014,13 +1071,13 @@ pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n \n pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n-    if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n+    if ty::type_is_immediate(cx.tcx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if ty::type_is_immediate(t) { return Load(cx, v); }\n+    if ty::type_is_immediate(cx.tcx(), t) { return Load(cx, v); }\n     return v;\n }\n \n@@ -1145,7 +1202,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n+pub fn new_block(cx: fn_ctxt, parent: Option<block>, scope: Option<@mut scope_info>,\n                  is_lpad: bool, name: &str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n@@ -1155,10 +1212,10 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n         };\n         let bcx = mk_block(llbb,\n                            parent,\n-                           kind,\n                            is_lpad,\n                            opt_node_info,\n                            cx);\n+        bcx.scope = scope;\n         for parent.iter().advance |cx| {\n             if cx.unreachable {\n                 Unreachable(bcx);\n@@ -1169,27 +1226,30 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n     }\n }\n \n-pub fn simple_block_scope() -> block_kind {\n-    block_scope(@mut scope_info {\n+pub fn simple_block_scope(parent: Option<@mut scope_info>,\n+                          node_info: Option<NodeInfo>) -> @mut scope_info {\n+    @mut scope_info {\n+        parent: parent,\n         loop_break: None,\n         loop_label: None,\n         cleanups: ~[],\n         cleanup_paths: ~[],\n-        landing_pad: None\n-    })\n+        landing_pad: None,\n+        node_info: node_info,\n+    }\n }\n \n // Use this when you're at the top block of a function or the like.\n pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n                     -> block {\n-    return new_block(fcx, None, simple_block_scope(), false,\n+    return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n                   \"function top level\", opt_node_info);\n }\n \n pub fn scope_block(bcx: block,\n                    opt_node_info: Option<NodeInfo>,\n                    n: &str) -> block {\n-    return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n+    return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n@@ -1198,27 +1258,29 @@ pub fn loop_scope_block(bcx: block,\n                         loop_label: Option<ident>,\n                         n: &str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n-    return new_block(bcx.fcx, Some(bcx), block_scope(@mut scope_info {\n+    return new_block(bcx.fcx, Some(bcx), Some(@mut scope_info {\n+        parent: None,\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n         cleanups: ~[],\n         cleanup_paths: ~[],\n-        landing_pad: None\n+        landing_pad: None,\n+        node_info: opt_node_info,\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n // Use this when creating a block for the inside of a landing pad.\n pub fn lpad_block(bcx: block, n: &str) -> block {\n-    new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n+    new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n pub fn sub_block(bcx: block, n: &str) -> block {\n-    new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n+    new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n-    mk_block(llbb, None, block_non_scope, is_lpad, None, fcx)\n+    mk_block(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1277,42 +1339,47 @@ pub fn cleanup_and_leave(bcx: block,\n                 (fmt!(\"cleanup_and_leave(%s)\", cur.to_str())).to_managed());\n         }\n \n-        match cur.kind {\n-            block_scope(inf) if !inf.empty_cleanups() => {\n-                let (sub_cx, dest, inf_cleanups) = {\n-                    let inf = &mut *inf;\n-                    let mut skip = 0;\n-                    let mut dest = None;\n-                    {\n-                        let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n-                        for r.iter().advance |cp| {\n-                            if cp.size == inf.cleanups.len() {\n-                                Br(bcx, cp.dest);\n-                                return;\n+        let mut cur_scope = cur.scope;\n+        loop {\n+            cur_scope = match cur_scope {\n+                Some (inf) if !inf.empty_cleanups() => {\n+                    let (sub_cx, dest, inf_cleanups) = {\n+                        let inf = &mut *inf;\n+                        let mut skip = 0;\n+                        let mut dest = None;\n+                        {\n+                            let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n+                            for r.iter().advance |cp| {\n+                                if cp.size == inf.cleanups.len() {\n+                                    Br(bcx, cp.dest);\n+                                    return;\n+                                }\n+\n+                                skip = cp.size;\n+                                dest = Some(cp.dest);\n                             }\n-\n-                            skip = cp.size;\n-                            dest = Some(cp.dest);\n                         }\n+                        let sub_cx = sub_block(bcx, \"cleanup\");\n+                        Br(bcx, sub_cx.llbb);\n+                        inf.cleanup_paths.push(cleanup_path {\n+                            target: leave,\n+                            size: inf.cleanups.len(),\n+                            dest: sub_cx.llbb\n+                        });\n+                        (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n+                    };\n+                    bcx = trans_block_cleanups_(sub_cx,\n+                                                inf_cleanups,\n+                                                is_lpad);\n+                    for dest.iter().advance |&dest| {\n+                        Br(bcx, dest);\n+                        return;\n                     }\n-                    let sub_cx = sub_block(bcx, \"cleanup\");\n-                    Br(bcx, sub_cx.llbb);\n-                    inf.cleanup_paths.push(cleanup_path {\n-                        target: leave,\n-                        size: inf.cleanups.len(),\n-                        dest: sub_cx.llbb\n-                    });\n-                    (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n-                };\n-                bcx = trans_block_cleanups_(sub_cx,\n-                                            inf_cleanups,\n-                                            is_lpad);\n-                for dest.iter().advance |&dest| {\n-                    Br(bcx, dest);\n-                    return;\n+                    inf.parent\n                 }\n+                Some(inf) => inf.parent,\n+                None => break\n             }\n-            _ => ()\n         }\n \n         match upto {\n@@ -1353,20 +1420,27 @@ pub fn with_scope(bcx: block,\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n-    let scope_cx = scope_block(bcx, opt_node_info, name);\n-    Br(bcx, scope_cx.llbb);\n-    leave_block(f(scope_cx), scope_cx)\n+    let scope = simple_block_scope(bcx.scope, opt_node_info);\n+    bcx.scope = Some(scope);\n+    let ret = f(bcx);\n+    let ret = trans_block_cleanups_(ret, /*bad*/copy scope.cleanups, false);\n+    bcx.scope = scope.parent;\n+    ret\n }\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          name: &str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n-    let scope_cx = scope_block(bcx, opt_node_info, name);\n-    Br(bcx, scope_cx.llbb);\n-    let Result {bcx, val} = f(scope_cx);\n-    rslt(leave_block(bcx, scope_cx), val)\n+\n+    let scope = simple_block_scope(bcx.scope, opt_node_info);\n+    bcx.scope = Some(scope);\n+    let Result { bcx: out_bcx, val } = f(bcx);\n+    let out_bcx = trans_block_cleanups_(out_bcx, /*bad*/copy scope.cleanups, false);\n+    bcx.scope = scope.parent;\n+\n+    rslt(out_bcx, val)\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n@@ -1399,7 +1473,7 @@ pub fn alloc_local(cx: block, local: &ast::local) -> block {\n     let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n-      ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n+      ast::pat_ident(_, ref pth, None) => Some(path_to_ident(pth)),\n       _ => None\n     };\n     let val = alloc_ty(cx, t);\n@@ -1545,7 +1619,7 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n     unsafe {\n-        if !ty::type_is_immediate(output_type) {\n+        if !ty::type_is_immediate(fcx.ccx.tcx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n@@ -1584,7 +1658,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n         }\n     };\n-    let is_immediate = ty::type_is_immediate(substd_output_type);\n+    let is_immediate = ty::type_is_immediate(ccx.tcx, substd_output_type);\n     let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1690,7 +1764,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     match fcx.llself {\n         Some(slf) => {\n             let self_val = if slf.is_copy\n-                    && datum::appropriate_mode(slf.t).is_by_value() {\n+                    && datum::appropriate_mode(bcx.tcx(), slf.t).is_by_value() {\n                 let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n                 let alloc = alloc_ty(bcx, slf.t);\n                 Store(bcx, tmp, alloc);\n@@ -1718,7 +1792,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n         // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(arg_ty).is_by_value() {\n+        let llarg = if datum::appropriate_mode(bcx.tcx(), arg_ty).is_by_value() {\n             let alloc = alloc_ty(bcx, arg_ty);\n             Store(bcx, raw_llarg, alloc);\n             alloc\n@@ -1737,7 +1811,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         fcx.llargs.insert(arg_id, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n         }\n     }\n \n@@ -1866,18 +1940,16 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n                 attrs: &[ast::attribute]) {\n-    let do_time = ccx.sess.trans_stats();\n-    let start = if do_time { time::get_time() }\n-                else { time::Timespec::new(0, 0) };\n+\n+    let the_path_str = path_str(ccx.sess, path);\n+    let _s = StatRecorder::new(ccx, the_path_str);\n     debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n-    ccx.stats.n_fns += 1;\n-    let the_path_str = path_str(ccx.sess, path);\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n     trans_closure(ccx,\n-                  path,\n+                  copy path,\n                   decl,\n                   body,\n                   llfndecl,\n@@ -1893,10 +1965,6 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                       }\n                   },\n                   |_bcx| { });\n-    if do_time {\n-        let end = time::get_time();\n-        ccx.log_fn_time(the_path_str, start, end);\n-    }\n }\n \n pub fn trans_enum_variant(ccx: @mut CrateContext,\n@@ -1911,7 +1979,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n     let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: varg.ty,\n+            ty: copy varg.ty,\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n                 codemap::dummy_sp(),\n@@ -1985,7 +2053,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n     let fn_args = do fields.map |field| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: field.node.ty,\n+            ty: copy field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n                                         codemap::dummy_sp(),\n                                         special_idents::arg),\n@@ -2961,8 +3029,14 @@ pub fn trans_crate(sess: session::Session,\n         io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n         io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n         io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n+        io::println(\"fn stats:\");\n+        do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n+            insns_a > insns_b\n+        }\n+        for ccx.stats.fn_stats.iter().advance |&(name, ms, insns)| {\n+            io::println(fmt!(\"%u insns, %u ms, %s\", insns, ms, name));\n+        }\n     }\n-\n     if ccx.sess.count_llvm_insns() {\n         for ccx.stats.llvm_insns.iter().advance |(&k, &v)| {\n             io::println(fmt!(\"%-7u %s\", v, k));"}, {"sha": "b62b73423e9b1be8b03472378be325658a24f901", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -46,6 +46,9 @@ pub fn B(cx: block) -> BuilderRef {\n }\n \n pub fn count_insn(cx: block, category: &str) {\n+    if cx.ccx().sess.trans_stats() {\n+        cx.ccx().stats.n_llvm_insns += 1;\n+    }\n     do base::with_insn_ctxt |v| {\n         let h = &mut cx.ccx().stats.llvm_insns;\n \n@@ -565,7 +568,7 @@ pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n         let min = llvm::LLVMConstInt(t, lo, signed);\n         let max = llvm::LLVMConstInt(t, hi, signed);\n \n-        do vec::as_imm_buf([min, max]) |ptr, len| {\n+        do [min, max].as_imm_buf |ptr, len| {\n             llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n                                                             ptr, len as c_uint));\n@@ -942,7 +945,7 @@ pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n                cx.val_to_str(Fn),\n                Args.map(|arg| cx.val_to_str(*arg)));\n \n-        do vec::as_imm_buf(Args) |ptr, len| {\n+        do Args.as_imm_buf |ptr, len| {\n             llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n         }\n     }"}, {"sha": "473afda48e65d68158c3c29d48c3cc31553fc7fc", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -446,8 +446,8 @@ pub fn trans_call(in_cx: block,\n                      node_id_type(in_cx, id),\n                      |cx| trans(cx, f),\n                      args,\n-                     dest,\n-                     DontAutorefArg)\n+                     Some(dest),\n+                     DontAutorefArg).bcx\n }\n \n pub fn trans_method_call(in_cx: block,\n@@ -484,15 +484,15 @@ pub fn trans_method_call(in_cx: block,\n             }\n         },\n         args,\n-        dest,\n-        DontAutorefArg)\n+        Some(dest),\n+        DontAutorefArg).bcx\n }\n \n pub fn trans_lang_call(bcx: block,\n                        did: ast::def_id,\n                        args: &[ValueRef],\n-                       dest: expr::Dest)\n-    -> block {\n+                       dest: Option<expr::Dest>)\n+    -> Result {\n     let fty = if did.crate == ast::local_crate {\n         ty::node_id_to_type(bcx.ccx().tcx, did.node)\n     } else {\n@@ -552,7 +552,7 @@ pub fn trans_lang_call_with_type_params(bcx: block,\n             }\n             Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n         },\n-        ArgVals(args), dest, DontAutorefArg);\n+        ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n pub fn body_contains_ret(body: &ast::blk) -> bool {\n@@ -579,10 +579,10 @@ pub fn trans_call_inner(in_cx: block,\n                         ret_ty: ty::t,\n                         get_callee: &fn(block) -> Callee,\n                         args: CallArgs,\n-                        dest: expr::Dest,\n+                        dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n-                        -> block {\n-    do base::with_scope(in_cx, call_info, \"call\") |cx| {\n+                        -> Result {\n+    do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n             args.len() > 0u && match args.last().node {\n@@ -633,7 +633,7 @@ pub fn trans_call_inner(in_cx: block,\n \n         let mut llargs = ~[];\n \n-        if !ty::type_is_immediate(ret_ty) {\n+        if !ty::type_is_immediate(bcx.tcx(), ret_ty) {\n             llargs.push(llretslot);\n         }\n \n@@ -669,18 +669,12 @@ pub fn trans_call_inner(in_cx: block,\n         bcx = new_bcx;\n \n         match dest {\n-            expr::Ignore => {\n+            None => { assert!(ty::type_is_immediate(bcx.tcx(), ret_ty)) }\n+            Some(expr::Ignore) => {\n                 // drop the value if it is not being saved.\n                 unsafe {\n-                    if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-                        if ty::type_is_nil(ret_ty) {\n-                            // When implementing the for-loop sugar syntax, the\n-                            // type of the for-loop is nil, but the function\n-                            // it's invoking returns a bool. This is a special\n-                            // case to ignore instead of invoking the Store\n-                            // below into a scratch pointer of a mismatched\n-                            // type.\n-                        } else if ty::type_is_immediate(ret_ty) {\n+                    if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n+                        if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n                             let llscratchptr = alloc_ty(bcx, ret_ty);\n                             Store(bcx, llresult, llscratchptr);\n                             bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n@@ -690,11 +684,11 @@ pub fn trans_call_inner(in_cx: block,\n                     }\n                 }\n             }\n-            expr::SaveIn(lldest) => {\n+            Some(expr::SaveIn(lldest)) => {\n                 // If this is an immediate, store into the result location.\n                 // (If this was not an immediate, the result will already be\n                 // directly written into the output slot.)\n-                if ty::type_is_immediate(ret_ty) {\n+                if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n                     Store(bcx, llresult, lldest);\n                 }\n             }\n@@ -717,7 +711,7 @@ pub fn trans_call_inner(in_cx: block,\n                 bcx\n             }\n         }\n-        bcx\n+        rslt(bcx, llresult)\n     }\n }\n \n@@ -727,14 +721,14 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n+pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: Option<expr::Dest>)\n                       -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n \n     match dest {\n-        expr::SaveIn(dst) => dst,\n-        expr::Ignore => {\n-            if ty::type_is_nil(retty) {\n+        Some(expr::SaveIn(dst)) => dst,\n+        _ => {\n+            if ty::type_is_immediate(bcx.tcx(), retty) {\n                 unsafe {\n                     llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n                 }\n@@ -898,7 +892,7 @@ pub fn trans_arg_expr(bcx: block,\n                     }\n                     ty::ByCopy => {\n                         if ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n-                                arg_datum.appropriate_mode().is_by_ref() {\n+                                arg_datum.appropriate_mode(bcx.tcx()).is_by_ref() {\n                             debug!(\"by copy arg with type %s, storing to scratch\",\n                                    bcx.ty_to_str(arg_datum.ty));\n                             let scratch = scratch_datum(bcx, arg_datum.ty, false);\n@@ -914,7 +908,7 @@ pub fn trans_arg_expr(bcx: block,\n                             scratch.add_clean(bcx);\n                             temp_cleanups.push(scratch.val);\n \n-                            match scratch.appropriate_mode() {\n+                            match scratch.appropriate_mode(bcx.tcx()) {\n                                 ByValue => val = Load(bcx, scratch.val),\n                                 ByRef(_) => val = scratch.val,\n                             }"}, {"sha": "4c63b8dc844511ad48a80406a79e3534309bbe32", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -531,13 +531,13 @@ pub fn make_opaque_cbox_take_glue(\n \n         // Allocate memory, update original ptr, and copy existing data\n         let opaque_tydesc = PointerCast(bcx, tydesc, Type::i8p());\n-        let rval = alloca(bcx, Type::i8p());\n-        let bcx = callee::trans_lang_call(\n+        let mut bcx = bcx;\n+        let llresult = unpack_result!(bcx, callee::trans_lang_call(\n             bcx,\n             bcx.tcx().lang_items.closure_exchange_malloc_fn(),\n             [opaque_tydesc, sz],\n-            expr::SaveIn(rval));\n-        let cbox_out = PointerCast(bcx, Load(bcx, rval), llopaquecboxty);\n+            None));\n+        let cbox_out = PointerCast(bcx, llresult, llopaquecboxty);\n         call_memcpy(bcx, cbox_out, cbox_in, sz, 1);\n         Store(bcx, cbox_out, cboxptr);\n "}, {"sha": "973a124c48ad2897de82d7fc55f287997481ac9a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -34,9 +34,6 @@ use std::cast::transmute;\n use std::cast;\n use std::hashmap::{HashMap};\n use std::libc::{c_uint, c_longlong, c_ulonglong};\n-use std::to_bytes;\n-use std::str;\n-use std::vec::raw::to_ptr;\n use std::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n@@ -96,8 +93,10 @@ pub struct Stats {\n     n_monos: uint,\n     n_inlines: uint,\n     n_closures: uint,\n+    n_llvm_insns: uint,\n+    llvm_insn_ctxt: ~[~str],\n     llvm_insns: HashMap<~str, uint>,\n-    fn_times: ~[(~str, int)] // (ident, time)\n+    fn_stats: ~[(~str, uint, uint)] // (ident, time-in-ms, llvm-instructions)\n }\n \n pub struct BuilderRef_res {\n@@ -275,6 +274,7 @@ pub enum heap {\n     heap_managed,\n     heap_managed_unique,\n     heap_exchange,\n+    heap_exchange_vector,\n     heap_exchange_closure\n }\n \n@@ -321,7 +321,7 @@ pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, None) |scope_info| {\n         scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n@@ -333,25 +333,36 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) |scope_info| {\n+    do in_scope_cx(cx, None) |scope_info| {\n         scope_info.cleanups.push(\n             clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n                        cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n+\n pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n+    add_clean_temp_mem_in_scope_(bcx, None, val, t);\n+}\n+\n+pub fn add_clean_temp_mem_in_scope(bcx: block, scope_id: ast::node_id, val: ValueRef, t: ty::t) {\n+    add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n+}\n+\n+pub fn add_clean_temp_mem_in_scope_(bcx: block, scope_id: Option<ast::node_id>,\n+                                    val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, scope_id) |scope_info| {\n         scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_return_to_mut(bcx: block,\n+                               scope_id: ast::node_id,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n                                bits_val_ref: ValueRef,\n@@ -369,7 +380,7 @@ pub fn add_clean_return_to_mut(bcx: block,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n-    do in_scope_cx(bcx) |scope_info| {\n+    do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n         scope_info.cleanups.push(\n             clean_temp(\n                 frozen_val_ref,\n@@ -385,12 +396,12 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n         f\n       }\n-      heap_exchange | heap_exchange_closure => {\n+      heap_exchange | heap_exchange_vector | heap_exchange_closure => {\n         let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }\n     };\n-    do in_scope_cx(cx) |scope_info| {\n+    do in_scope_cx(cx, None) |scope_info| {\n         scope_info.cleanups.push(clean_temp(ptr, free_fn,\n                                       normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n@@ -402,8 +413,8 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: block, val: ValueRef) {\n-    do in_scope_cx(cx) |scope_info| {\n-        let cleanup_pos = scope_info.cleanups.iter().position_(\n+    do in_scope_cx(cx, None) |scope_info| {\n+        let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n@@ -419,27 +430,14 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n }\n \n pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n-    match bcx.kind {\n-       block_non_scope  => ~[],\n-       block_scope(inf) => /*bad*/copy inf.cleanups\n+    match bcx.scope {\n+       None  => ~[],\n+       Some(inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n-pub enum block_kind {\n-    // A scope at the end of which temporary values created inside of it are\n-    // cleaned up. May correspond to an actual block in the language, but also\n-    // to an implicit scope, for example, calls introduce an implicit scope in\n-    // which the arguments are evaluated and cleaned up.\n-    block_scope(@mut scope_info),\n-\n-    // A non-scope block is a basic block created as a translation artifact\n-    // from translating code that expresses conditional logic rather than by\n-    // explicit { ... } block structure in the source language.  It's called a\n-    // non-scope block because it doesn't introduce a new variable scope.\n-    block_non_scope,\n-}\n-\n pub struct scope_info {\n+    parent: Option<@mut scope_info>,\n     loop_break: Option<block>,\n     loop_label: Option<ident>,\n     // A list of functions that must be run at when leaving this\n@@ -451,6 +449,8 @@ pub struct scope_info {\n     cleanup_paths: ~[cleanup_path],\n     // Unwinding landing pad. Also cleared when cleanups change.\n     landing_pad: Option<BasicBlockRef>,\n+    // info about the AST node this scope originated from, if any\n+    node_info: Option<NodeInfo>,\n }\n \n impl scope_info {\n@@ -506,8 +506,8 @@ pub struct block_ {\n     terminated: bool,\n     unreachable: bool,\n     parent: Option<block>,\n-    // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    // The current scope within this basic block\n+    scope: Option<@mut scope_info>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n@@ -517,7 +517,7 @@ pub struct block_ {\n     fcx: fn_ctxt\n }\n \n-pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n+pub fn block_(llbb: BasicBlockRef, parent: Option<block>,\n               is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block_ {\n \n@@ -526,7 +526,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n         terminated: false,\n         unreachable: false,\n         parent: parent,\n-        kind: kind,\n+        scope: None,\n         is_lpad: is_lpad,\n         node_info: node_info,\n         fcx: fcx\n@@ -535,10 +535,10 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n \n pub type block = @mut block_;\n \n-pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n+pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n-    @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n+    @mut block_(llbb, parent, is_lpad, node_info, fcx)\n }\n \n pub struct Result {\n@@ -563,19 +563,33 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: block, scope_id: Option<ast::node_id>, f: &fn(si: &mut scope_info)) {\n     let mut cur = cx;\n+    let mut cur_scope = cur.scope;\n     loop {\n-        match cur.kind {\n-            block_scope(inf) => {\n-                debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n-                       cur.to_str(), cx.to_str());\n-                f(inf);\n-                return;\n+        cur_scope = match cur_scope {\n+            Some(inf) => match scope_id {\n+                Some(wanted) => match inf.node_info {\n+                    Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n+                        debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                               cur.to_str(), cx.to_str());\n+                        f(inf);\n+                        return;\n+                    },\n+                    _ => inf.parent,\n+                },\n+                None => {\n+                    debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                           cur.to_str(), cx.to_str());\n+                    f(inf);\n+                    return;\n+                }\n+            },\n+            None => {\n+                cur = block_parent(cur);\n+                cur.scope\n             }\n-            _ => ()\n         }\n-        cur = block_parent(cur);\n     }\n }\n \n@@ -774,23 +788,23 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, True)\n         }\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n         }\n     }\n@@ -826,7 +840,7 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = do vec::as_imm_buf(us) |p, len| {\n+        let r = do us.as_imm_buf |p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n "}, {"sha": "9044ef5700321ed5a5ec972c96913fc31fc5ccf8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -91,7 +91,7 @@ pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n         let vs = es.map(|e| const_expr(cx, *e));\n         // If the vector contains enums, an LLVM array won't work.\n-        let v = if vs.iter().any_(|vi| val_ty(*vi) != llunitty) {\n+        let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n             C_struct(vs)\n         } else {\n             C_array(llunitty, vs)\n@@ -525,7 +525,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::expr_path(pth) => {\n+          ast::expr_path(ref pth) => {\n             assert_eq!(pth.types.len(), 0);\n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {"}, {"sha": "ebaa3179442843e3f20b7331084ef98ec9b3f3b4", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -210,8 +210,10 @@ impl CrateContext {\n                     n_monos: 0u,\n                     n_inlines: 0u,\n                     n_closures: 0u,\n+                    n_llvm_insns: 0u,\n+                    llvm_insn_ctxt: ~[],\n                     llvm_insns: HashMap::new(),\n-                    fn_times: ~[]\n+                    fn_stats: ~[]\n                   },\n                   upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n                   tydesc_type: tydesc_type,\n@@ -226,12 +228,6 @@ impl CrateContext {\n             }\n         }\n     }\n-\n-    pub fn log_fn_time(&mut self, name: ~str, start: time::Timespec, end: time::Timespec) {\n-        let elapsed = 1000 * ((end.sec - start.sec) as int) +\n-            ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-        self.stats.fn_times.push((name, elapsed));\n-    }\n }\n \n #[unsafe_destructor]"}, {"sha": "8ca4253ead8b8b70ba27f9a32b9bf77bb6604331", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -26,7 +26,6 @@ use util::ppaux;\n use middle::trans::type_::Type;\n \n use std::str;\n-use std::vec;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_map::path_mod;\n@@ -190,9 +189,13 @@ pub fn trans_log(log_ex: &ast::expr,\n \n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n-        let modpath = vec::append(\n-            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n-            path.filtered(|e| match *e { path_mod(_) => true, _ => false }));\n+        let mut modpath = ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))];\n+        for path.iter().advance |e| {\n+            match *e {\n+                path_mod(_) => { modpath.push(*e) }\n+                _ => {}\n+            }\n+        }\n         let modname = path_str(ccx.sess, modpath);\n         (modpath, modname)\n     };\n@@ -246,42 +249,48 @@ pub fn trans_break_cont(bcx: block,\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n-    let mut target;\n+    let mut cur_scope = unwind.scope;\n+    let mut target = unwind;\n+    let mut quit = false;\n     loop {\n-        match unwind.kind {\n-          block_scope(@scope_info {\n-            loop_break: Some(brk),\n-            loop_label: l,\n-            _\n-          }) => {\n-              // If we're looking for a labeled loop, check the label...\n-              target = if to_end {\n-                  brk\n-              } else {\n-                  unwind\n-              };\n-              match opt_label {\n-                  Some(desired) => match l {\n-                      Some(actual) if actual == desired => break,\n-                      // If it doesn't match the one we want,\n-                      // don't break\n-                      _ => ()\n-                  },\n-                  None => break\n-              }\n-          }\n-          _ => ()\n+        cur_scope = match cur_scope {\n+            Some(@scope_info {\n+                loop_break: Some(brk),\n+                loop_label: l,\n+                parent,\n+                _\n+            }) => {\n+                // If we're looking for a labeled loop, check the label...\n+                target = if to_end {\n+                    brk\n+                } else {\n+                    unwind\n+                };\n+                match opt_label {\n+                    Some(desired) => match l {\n+                        Some(actual) if actual == desired => break,\n+                        // If it doesn't match the one we want,\n+                        // don't break\n+                        _ => parent,\n+                    },\n+                    None => break,\n+                }\n+            }\n+            Some(inf) => inf.parent,\n+            None => {\n+                unwind = match unwind.parent {\n+                    Some(bcx) => bcx,\n+                        // This is a return from a loop body block\n+                        None => {\n+                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n+                            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                            Unreachable(bcx);\n+                            return bcx;\n+                        }\n+                };\n+                unwind.scope\n+            }\n         }\n-        unwind = match unwind.parent {\n-          Some(bcx) => bcx,\n-          // This is a return from a loop body block\n-          None => {\n-            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n-            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n-            Unreachable(bcx);\n-            return bcx;\n-          }\n-        };\n     }\n     cleanup_and_Br(bcx, unwind, target.llbb);\n     Unreachable(bcx);\n@@ -386,7 +395,7 @@ fn trans_fail_value(bcx: block,\n     let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = callee::trans_lang_call(\n-        bcx, bcx.tcx().lang_items.fail_fn(), args, expr::Ignore);\n+        bcx, bcx.tcx().lang_items.fail_fn(), args, Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }\n@@ -397,7 +406,7 @@ pub fn trans_fail_bounds_check(bcx: block, sp: span,\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];\n     let bcx = callee::trans_lang_call(\n-        bcx, bcx.tcx().lang_items.fail_bounds_check_fn(), args, expr::Ignore);\n+        bcx, bcx.tcx().lang_items.fail_bounds_check_fn(), args, Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "e86709d72b329e296365339be90fa47d20b6337c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -100,6 +100,7 @@ use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::write_guard;\n+use middle::trans::type_::Type;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n@@ -188,7 +189,7 @@ pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n-pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n     /*!\n     *\n     * Indicates the \"appropriate\" mode for this value,\n@@ -197,7 +198,7 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n \n     if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n         ByValue\n-    } else if ty::type_is_immediate(ty) {\n+    } else if ty::type_is_immediate(tcx, ty) {\n         ByValue\n     } else {\n         ByRef(RevokeClean)\n@@ -508,18 +509,18 @@ impl Datum {\n         }\n     }\n \n-    pub fn appropriate_mode(&self) -> DatumMode {\n+    pub fn appropriate_mode(&self, tcx: ty::ctxt) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n-        appropriate_mode(self.ty)\n+        appropriate_mode(tcx, self.ty)\n     }\n \n     pub fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode() {\n+        match self.appropriate_mode(bcx.tcx()) {\n             ByValue => self.to_value_llval(bcx),\n             ByRef(_) => self.to_ref_llval(bcx)\n         }\n@@ -530,7 +531,7 @@ impl Datum {\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode() {\n+        match self.appropriate_mode(bcx.tcx()) {\n             ByValue => self.to_value_datum(bcx),\n             ByRef(_) => self.to_ref_datum(bcx)\n         }\n@@ -567,18 +568,31 @@ impl Datum {\n          * This datum must represent an @T or ~T box.  Returns a new\n          * by-ref datum of type T, pointing at the contents. */\n \n-        let content_ty = match ty::get(self.ty).sty {\n-            ty::ty_box(mt) | ty::ty_uniq(mt) => mt.ty,\n+        let (content_ty, header) = match ty::get(self.ty).sty {\n+            ty::ty_box(mt) => (mt.ty, true),\n+            ty::ty_uniq(mt) => (mt.ty, false),\n+            ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+                let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n+                let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n+                (unboxed_vec_ty, true)\n+            }\n             _ => {\n                 bcx.tcx().sess.bug(fmt!(\n                     \"box_body() invoked on non-box type %s\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n \n-        let ptr = self.to_value_llval(bcx);\n-        let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        if !header && !ty::type_contents(bcx.tcx(), content_ty).contains_managed() {\n+            let ptr = self.to_value_llval(bcx);\n+            let ty = type_of(bcx.ccx(), content_ty);\n+            let body = PointerCast(bcx, ptr, ty.ptr_to());\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        } else { // has a header\n+            let ptr = self.to_value_llval(bcx);\n+            let body = opaque_box_body(bcx, content_ty, ptr);\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        }\n     }\n \n     pub fn to_rptr(&self, bcx: block) -> Datum {\n@@ -657,13 +671,7 @@ impl Datum {\n                     ByValue => {\n                         // Actually, this case cannot happen right\n                         // now, because enums are never immediate.\n-                        // But in principle newtype'd immediate\n-                        // values should be immediate, and in that\n-                        // case the * would be a no-op except for\n-                        // changing the type, so I am putting this\n-                        // code in place here to do the right\n-                        // thing if this change ever goes through.\n-                        assert!(ty::type_is_immediate(ty));\n+                        assert!(ty::type_is_immediate(bcx.tcx(), ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -695,15 +703,15 @@ impl Datum {\n                         )\n                     }\n                     ByValue => {\n-                        // Actually, this case cannot happen right now,\n-                        // because structs are never immediate. But in\n-                        // principle, newtype'd immediate values should be\n-                        // immediate, and in that case the * would be a no-op\n-                        // except for changing the type, so I am putting this\n-                        // code in place here to do the right thing if this\n-                        // change ever goes through.\n-                        assert!(ty::type_is_immediate(ty));\n-                        (Some(Datum {ty: ty, ..*self}), bcx)\n+                        assert!(ty::type_is_immediate(bcx.tcx(), ty));\n+                        (\n+                            Some(Datum {\n+                                val: ExtractValue(bcx, self.val, 0),\n+                                ty: ty,\n+                                mode: ByValue\n+                            }),\n+                            bcx\n+                        )\n                     }\n                 }\n             }"}, {"sha": "fc73d80537987ef04d154edb7f1f07a976f9e5d7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -133,7 +133,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      ast::pat_ident(_, ref pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n       _ => {\n         bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n@@ -182,7 +182,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_arg\");\n     if true {\n         // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n@@ -204,7 +204,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     let context = create_function(fcx);\n \n     match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n+        ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n@@ -259,23 +259,25 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n-      ast_map::node_item(item, _) => {\n+    let fnitem = cx.tcx.items.get_copy(&fcx.id);\n+    let (ident, ret_ty, id) = match fnitem {\n+      ast_map::node_item(ref item, _) => {\n         match item.node {\n-          ast::item_fn(ref decl, _, _, _, _) => {\n-            (item.ident, decl.output, item.id)\n+          ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n+            (item.ident, ty, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n         }\n       }\n-      ast_map::node_method(method, _, _) => {\n-          (method.ident, method.decl.output, method.id)\n+      ast_map::node_method(@ast::method { decl: ast::fn_decl { output: ref ty, _ },\n+                           id: id, ident: ident, _}, _, _) => {\n+          (ident, ty, id)\n       }\n-      ast_map::node_expr(expr) => {\n+      ast_map::node_expr(ref expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n             let name = gensym_name(\"fn\");\n-            (name, decl.output, expr.id)\n+            (name, &decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")"}, {"sha": "0180eeb3d22051db58bcef4ff47fe2fffba9045e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -150,6 +150,7 @@ use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n+use middle::trans::machine::llsize_of;\n \n use middle::trans::type_::Type;\n \n@@ -291,7 +292,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert_eq!(datum.appropriate_mode(), ByValue);\n+        assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);\n@@ -464,7 +465,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                                       expr, contents);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_uniq) => {\n-            let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n+            let heap = tvec::heap_for_unique_vector(bcx, expr_ty(bcx, contents));\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n                                                       expr, contents);\n         }\n@@ -1147,7 +1148,7 @@ fn trans_rec_or_struct(bcx: block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            let opt_pos = field_tys.iter().position_(|field_ty| field_ty.ident == field.node.ident);\n+            let opt_pos = field_tys.iter().position(|field_ty| field_ty.ident == field.node.ident);\n             match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;\n@@ -1171,7 +1172,7 @@ fn trans_rec_or_struct(bcx: block,\n                                      fields: leftovers })\n             }\n             None => {\n-                if need_base.iter().any_(|b| *b) {\n+                if need_base.iter().any(|b| *b) {\n                     tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n                 }\n                 None\n@@ -1329,12 +1330,23 @@ fn trans_unary_datum(bcx: block,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n-        let base::MallocResult { bcx, box: bx, body } =\n-            base::malloc_general(bcx, contents_ty, heap);\n-        add_clean_free(bcx, bx, heap);\n-        let bcx = trans_into(bcx, contents, SaveIn(body));\n-        revoke_clean(bcx, bx);\n-        return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        if heap == heap_exchange {\n+            let llty = type_of(bcx.ccx(), contents_ty);\n+            let size = llsize_of(bcx.ccx(), llty);\n+            let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n+                                                               heap_exchange, size);\n+            add_clean_free(bcx, val, heap_exchange);\n+            let bcx = trans_into(bcx, contents, SaveIn(val));\n+            revoke_clean(bcx, val);\n+            return immediate_rvalue_bcx(bcx, val, box_ty);\n+        } else {\n+            let base::MallocResult { bcx, box: bx, body } =\n+                base::malloc_general(bcx, contents_ty, heap);\n+            add_clean_free(bcx, bx, heap);\n+            let bcx = trans_into(bcx, contents, SaveIn(body));\n+            revoke_clean(bcx, bx);\n+            return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        }\n     }\n }\n \n@@ -1539,8 +1551,8 @@ fn trans_overloaded_op(bcx: block,\n                                                           origin)\n                              },\n                              callee::ArgExprs(args),\n-                             dest,\n-                             DoAutorefArg)\n+                             Some(dest),\n+                             DoAutorefArg).bcx\n }\n \n fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,"}, {"sha": "2c505853d5eb742ab44e044fc862d73cde01fe96", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -103,7 +103,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n         llret_ty: llret_ty,\n-        sret: !ty::type_is_immediate(fn_sig.output),\n+        sret: !ty::type_is_immediate(ccx.tcx, fn_sig.output),\n     }\n }\n \n@@ -113,7 +113,7 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = Type::struct_(llsig.llarg_tys + [llsig.llret_ty.ptr_to()], false);\n+    let bundle_ty = Type::struct_(llsig.llarg_tys + &[llsig.llret_ty.ptr_to()], false);\n     let ret_def = !ty::type_is_bot(fn_sig.output) &&\n                   !ty::type_is_nil(fn_sig.output);\n     let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);\n@@ -192,7 +192,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n-    if needs_c_return && !ty::type_is_immediate(tys.fn_sig.output) {\n+    if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n         fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n                                    lloutputtype));\n@@ -648,7 +648,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(tp_ty);\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n@@ -657,7 +657,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(tp_ty);\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n@@ -731,7 +731,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n \n                 let llsrcval = get_param(decl, first_real_arg);\n-                let llsrcptr = if ty::type_is_immediate(in_type) {\n+                let llsrcptr = if ty::type_is_immediate(ccx.tcx, in_type) {\n                     let llsrcptr = alloca(bcx, llintype);\n                     Store(bcx, llsrcval, llsrcptr);\n                     llsrcptr\n@@ -789,7 +789,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             bcx = trans_call_inner(\n                 bcx, None, fty, ty::mk_nil(),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n-                ArgVals(arg_vals), Ignore, DontAutorefArg);\n+                ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n         }\n         \"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular\n@@ -1221,7 +1221,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n             let mut i = 0u;\n             let n = tys.fn_sig.inputs.len();\n \n-            if !ty::type_is_immediate(tys.fn_sig.output) {\n+            if !ty::type_is_immediate(bcx.tcx(), tys.fn_sig.output) {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n                 llargvals.push(llretptr);\n             }\n@@ -1247,7 +1247,8 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n-            if bcx.fcx.llretptr.is_some() && ty::type_is_immediate(shim_types.fn_sig.output) {\n+            if bcx.fcx.llretptr.is_some() &&\n+                ty::type_is_immediate(bcx.tcx(), shim_types.fn_sig.output) {\n                 // Write the value into the argument bundle.\n                 let arg_count = shim_types.fn_sig.inputs.len();\n                 let llretptr = load_inbounds(bcx,"}, {"sha": "bc493bfa23ec30c9acb9e5250fdbb0f65f306752", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -47,15 +47,15 @@ pub fn trans_free(cx: block, v: ValueRef) -> block {\n     callee::trans_lang_call(cx,\n         cx.tcx().lang_items.free_fn(),\n         [PointerCast(cx, v, Type::i8p())],\n-        expr::Ignore)\n+        Some(expr::Ignore)).bcx\n }\n \n pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         cx.tcx().lang_items.exchange_free_fn(),\n         [PointerCast(cx, v, Type::i8p())],\n-        expr::Ignore)\n+        Some(expr::Ignore)).bcx\n }\n \n pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n@@ -386,7 +386,9 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_uniq(*) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+        tvec::make_uniq_free_glue(bcx, v, t)\n+      }\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         make_free_glue(bcx, v,\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n@@ -738,15 +740,9 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n                          name: &str)\n                       -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    if !ccx.sess.trans_stats() {\n-        return make_generic_glue_inner(ccx, t, llfn, helper);\n-    }\n-\n-    let start = time::get_time();\n-    let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n-    let end = time::get_time();\n-    ccx.log_fn_time(fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)), start, end);\n-    return llval;\n+    let glue_name = fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t));\n+    let _s = StatRecorder::new(ccx, glue_name);\n+    make_generic_glue_inner(ccx, t, llfn, helper)\n }\n \n pub fn emit_tydescs(ccx: &mut CrateContext) {"}, {"sha": "2cd313ff4315447ad062e83515297f2bce70f8d3", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,9 +14,6 @@ use lib::llvm::{ValueRef};\n use lib::llvm::False;\n use lib::llvm::llvm;\n use middle::trans::common::*;\n-use middle::trans::type_of;\n-use middle::ty;\n-use util::ppaux::ty_to_str;\n \n use middle::trans::type_::Type;\n \n@@ -116,42 +113,3 @@ pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n             llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n     }\n }\n-\n-// Computes the size of the data part of an enum.\n-pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key(&t) {\n-        return cx.enum_sizes.get_copy(&t);\n-    }\n-\n-    debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));\n-\n-    match ty::get(t).sty {\n-        ty::ty_enum(tid, ref substs) => {\n-            // Compute max(variant sizes).\n-            let mut max_size = 0;\n-            let variants = ty::enum_variants(cx.tcx, tid);\n-            for variants.iter().advance |variant| {\n-                if variant.args.len() == 0 {\n-                    loop;\n-                }\n-\n-                let lltypes = variant.args.map(|&variant_arg| {\n-                    let substituted = ty::subst(cx.tcx, substs, variant_arg);\n-                    type_of::sizing_type_of(cx, substituted)\n-                });\n-\n-                debug!(\"static_size_of_enum: variant %s type %s\",\n-                       cx.tcx.sess.str_of(variant.name),\n-                       cx.tn.type_to_str(Type::struct_(lltypes, false)));\n-\n-                let this_size = llsize_of_real(cx, Type::struct_(lltypes, false));\n-                if max_size < this_size {\n-                    max_size = this_size;\n-                }\n-            }\n-            cx.enum_sizes.insert(t, max_size);\n-            return max_size;\n-        }\n-        _ => cx.sess.bug(\"static_size_of_enum called on non-enum\")\n-    }\n-}"}, {"sha": "14cc822b5a571687ecc97787076f20e03918404a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -577,6 +577,10 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n         }\n         ast::sty_region(*) => {\n             match store {\n+                ty::UniqTraitStore\n+                    if !ty::type_contents(bcx.tcx(), callee_ty).contains_managed() => {\n+                    llself = llbox;\n+                }\n                 ty::BoxTraitStore |\n                 ty::UniqTraitStore => {\n                     llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n@@ -641,16 +645,18 @@ pub fn vtable_id(ccx: @mut CrateContext,\n               -> mono_id {\n     match origin {\n         &typeck::vtable_static(impl_id, ref substs, sub_vtables) => {\n+            let psubsts = param_substs {\n+                tys: copy *substs,\n+                vtables: Some(sub_vtables),\n+                self_ty: None,\n+                self_vtable: None\n+            };\n+\n             monomorphize::make_mono_id(\n                 ccx,\n                 impl_id,\n-                *substs,\n-                if sub_vtables.is_empty() {\n-                    None\n-                } else {\n-                    Some(sub_vtables)\n-                },\n                 None,\n+                &psubsts,\n                 None)\n         }\n "}, {"sha": "bbcf68c386de7c9fcda00c372fc727b1dd730f95", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -50,11 +50,13 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             fn_id=%s, \\\n             real_substs=%s, \\\n             vtables=%s, \\\n+            self_vtable=%s, \\\n             impl_did_opt=%s, \\\n             ref_id=%?)\",\n            fn_id.repr(ccx.tcx),\n            real_substs.repr(ccx.tcx),\n            vtables.repr(ccx.tcx),\n+           self_vtable.repr(ccx.tcx),\n            impl_did_opt.repr(ccx.tcx),\n            ref_id);\n \n@@ -71,21 +73,28 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n     for substs.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n-    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n+\n+    let psubsts = @param_substs {\n+        tys: substs,\n+        vtables: vtables,\n+        self_ty: real_substs.self_ty,\n+        self_vtable: self_vtable\n+    };\n+\n+    let hash_id = make_mono_id(ccx, fn_id, impl_did_opt,\n+                               &*psubsts,\n                                Some(param_uses));\n-    if hash_id.params.iter().any_(\n+    if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }\n \n     debug!(\"monomorphic_fn(\\\n             fn_id=%s, \\\n-            vtables=%s, \\\n-            substs=%s, \\\n+            psubsts=%s, \\\n             hash_id=%?)\",\n            fn_id.repr(ccx.tcx),\n-           vtables.repr(ccx.tcx),\n-           substs.repr(ccx.tcx),\n+           psubsts.repr(ccx.tcx),\n            hash_id);\n \n     match ccx.monomorphized.find(&hash_id) {\n@@ -142,8 +151,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n-    let mono_ty = ty::subst_tps(ccx.tcx, substs,\n-                                real_substs.self_ty, llitem_ty);\n+    let mono_ty = ty::subst_tps(ccx.tcx, psubsts.tys,\n+                                psubsts.self_ty, llitem_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     ccx.stats.n_monos += 1;\n@@ -172,13 +181,6 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         lldecl\n     };\n \n-    let psubsts = Some(@param_substs {\n-        tys: substs,\n-        vtables: vtables,\n-        self_ty: real_substs.self_ty,\n-        self_vtable: self_vtable\n-    });\n-\n     let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 node: ast::item_fn(ref decl, _, _, _, ref body),\n@@ -192,7 +194,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                  body,\n                  d,\n                  no_self,\n-                 psubsts,\n+                 Some(psubsts),\n                  fn_id.node,\n                  []);\n         d\n@@ -202,7 +204,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n-          foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(), i.attrs,\n+          foreign::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n                                 ref_id);\n           d\n       }\n@@ -214,7 +216,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         match v.node.kind {\n             ast::tuple_variant_kind(ref args) => {\n                 trans_enum_variant(ccx, enum_item.id, v, /*bad*/copy *args,\n-                                   this_tv.disr_val, psubsts, d);\n+                                   this_tv.disr_val, Some(psubsts), d);\n             }\n             ast::struct_variant_kind(_) =>\n                 ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n@@ -225,13 +227,13 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n-        meth::trans_method(ccx, pt, mth, psubsts, d);\n+        meth::trans_method(ccx, pt, mth, Some(psubsts), d);\n         d\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);\n-        meth::trans_method(ccx, /*bad*/copy *pt, mth, psubsts, d);\n+        meth::trans_method(ccx, /*bad*/copy *pt, mth, Some(psubsts), d);\n         d\n       }\n       ast_map::node_struct_ctor(struct_def, _, _) => {\n@@ -241,7 +243,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                                  /*bad*/copy struct_def.fields,\n                                  struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                             didn't have a ctor id\"),\n-                                 psubsts,\n+                                 Some(psubsts),\n                                  d);\n         d\n       }\n@@ -320,26 +322,36 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n \n pub fn make_mono_id(ccx: @mut CrateContext,\n                     item: ast::def_id,\n-                    substs: &[ty::t],\n-                    vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n+                    substs: &param_substs,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get\n     // .collect() to work.\n-    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match vtables {\n+    let substs_iter = substs.self_ty.iter().chain_(substs.tys.iter());\n+    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n-               vts.repr(ccx.tcx), substs.repr(ccx.tcx));\n-        vts.iter().zip(substs.iter()).transform(|(vtable, subst)| {\n+               vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n+        let self_vtables = substs.self_vtable.map(|vtbl| @~[copy *vtbl]);\n+        let vts_iter = self_vtables.iter().chain_(vts.iter());\n+        vts_iter.zip(substs_iter).transform(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         }).collect()\n       }\n-      None => substs.iter().transform(|subst| (*subst, None::<@~[mono_id]>)).collect()\n+      None => substs_iter.transform(|subst| (*subst, None::<@~[mono_id]>)).collect()\n     };\n+\n+\n     let param_ids = match param_uses {\n       Some(ref uses) => {\n-        precise_param_ids.iter().zip(uses.iter()).transform(|(id, uses)| {\n+        // param_uses doesn't include a use for the self type.\n+        // We just say it is fully used.\n+        let self_use =\n+            substs.self_ty.map(|_| type_use::use_repr|type_use::use_tydesc);\n+        let uses_iter = self_use.iter().chain_(uses.iter());\n+\n+        precise_param_ids.iter().zip(uses_iter).transform(|(id, uses)| {\n             if ccx.sess.no_monomorphic_collapse() {\n                 match copy *id {\n                     (a, b) => mono_precise(a, b)\n@@ -356,7 +368,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                             let llty = type_of::type_of(ccx, subst);\n                             let size = machine::llbitsize_of_real(ccx, llty);\n                             let align = machine::llalign_of_min(ccx, llty);\n-                            let mode = datum::appropriate_mode(subst);\n+                            let mode = datum::appropriate_mode(ccx.tcx, subst);\n                             let data_class = mono_data_classify(subst);\n \n                             debug!(\"make_mono_id: type %s -> size %u align %u mode %? class %?\","}, {"sha": "cc4111aa1947dca14b94621763f007689caa69bd", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -17,7 +17,6 @@ use middle::trans::callee::{ArgVals, DontAutorefArg};\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n-use middle::trans::expr::SaveIn;\n use middle::trans::glue;\n use middle::trans::machine;\n use middle::trans::meth;\n@@ -96,14 +95,13 @@ impl Reflector {\n             ty::mk_bare_fn(tcx, copy self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", args.len());\n-        let bcx = self.bcx;\n+        let mut bcx = self.bcx;\n         for args.iter().enumerate().advance |(i, a)| {\n             debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n-        let scratch = scratch_datum(bcx, bool_ty, false);\n         // XXX: Should not be BoxTraitStore!\n-        let bcx = callee::trans_call_inner(\n+        let result = unpack_result!(bcx, callee::trans_call_inner(\n             self.bcx, None, mth_ty, bool_ty,\n             |bcx| meth::trans_trait_callee_from_llval(bcx,\n                                                       mth_ty,\n@@ -113,8 +111,7 @@ impl Reflector {\n                                                       ast::sty_region(\n                                                         None,\n                                                         ast::m_imm)),\n-            ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n-        let result = scratch.to_value_llval(bcx);\n+            ArgVals(args), None, DontAutorefArg));\n         let result = bool_to_i1(bcx, result);\n         let next_bcx = sub_block(bcx, \"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n@@ -194,7 +191,11 @@ impl Reflector {\n           }\n           ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"uniq\", extra)\n+              if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+                  self.visit(\"uniq_managed\", extra)\n+              } else {\n+                  self.visit(\"uniq\", extra)\n+              }\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n@@ -278,7 +279,7 @@ impl Reflector {\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n-                let sub_path = bcx.fcx.path + [path_name(special_idents::anon)];\n+                let sub_path = bcx.fcx.path + &[path_name(special_idents::anon)];\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n                                                                \"get_disr\");"}, {"sha": "41dbe320d2d103d9a05251afde8168125f6b960e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -33,6 +33,23 @@ use std::option::None;\n use syntax::ast;\n use syntax::codemap;\n \n+pub fn make_uniq_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> block {\n+    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n+\n+    let not_null = IsNotNull(bcx, box_datum.val);\n+    do with_cond(bcx, not_null) |bcx| {\n+        let body_datum = box_datum.box_body(bcx);\n+        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n+                                body_datum.ty);\n+        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n+            glue::trans_free(bcx, box_datum.val)\n+        } else {\n+            glue::trans_exchange_free(bcx, box_datum.val)\n+        }\n+    }\n+}\n+\n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n@@ -42,7 +59,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n-        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n+        fail!(\"cannot treat vectors/strings as exchange allocations yet\");\n       }\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n@@ -95,9 +112,17 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     return rslt(bcx, bx);\n }\n \n+pub fn heap_for_unique_vector(bcx: block, t: ty::t) -> heap {\n+    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+        heap_managed_unique\n+    } else {\n+        heap_exchange_vector\n+    }\n+}\n+\n pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n-    alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_for_unique_vector(bcx, unit_ty))\n }\n \n pub fn alloc_vec(bcx: block,\n@@ -298,7 +323,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n \n     // Handle ~\"\".\n     match heap {\n-        heap_exchange => {\n+        heap_exchange_vector => {\n             match content_expr.node {\n                 ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n@@ -312,7 +337,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                         bcx,\n                         bcx.tcx().lang_items.strdup_uniq_fn(),\n                         [ llptrval, llsizeval ],\n-                        expr::SaveIn(lldestval.to_ref_llval(bcx)));\n+                        Some(expr::SaveIn(lldestval.to_ref_llval(bcx)))).bcx;\n                     return DatumBlock {\n                         bcx: bcx,\n                         datum: lldestval\n@@ -321,7 +346,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors are not allocated with closure_exchange_alloc\"),\n+        heap_exchange | heap_exchange_closure => fail!(\"vectors use vector_exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n "}, {"sha": "7878e17f7fc689f5d242ae6b81a468b4b39586b9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -245,7 +245,7 @@ impl Type {\n     }\n \n     pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + [*ty], false)\n+        Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {"}, {"sha": "1d20481617575c5dfc39c0a257be0f3f14ea6eb1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -18,8 +18,8 @@ use middle::trans::type_::Type;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n-    !ty::type_is_immediate(*arg_ty)\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: &ty::t) -> bool {\n+    !ty::type_is_immediate(ccx.tcx, *arg_ty)\n }\n \n pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n@@ -41,7 +41,7 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let output_is_immediate = ty::type_is_immediate(output);\n+    let output_is_immediate = ty::type_is_immediate(cx.tcx, output);\n     let lloutputtype = type_of(cx, output);\n     if !output_is_immediate {\n         atys.push(lloutputtype.ptr_to());\n@@ -72,29 +72,6 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n-    assert!(!ty::type_needs_infer(t));\n-\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n-    if t != t_norm {\n-        type_of_non_gc_box(cx, t_norm)\n-    } else {\n-        match ty::get(t).sty {\n-          ty::ty_box(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::box(cx, &ty).ptr_to()\n-          }\n-          ty::ty_uniq(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::unique(cx, &ty).ptr_to()\n-          }\n-          _ => {\n-            cx.sess.bug(\"non-box in type_of_non_gc_box\");\n-          }\n-        }\n-    }\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -104,8 +81,7 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n //\n // (2) It won't make any recursive calls to determine the structure of the\n //     type behind pointers. This can help prevent infinite loops for\n-//     recursive types. For example, `static_size_of_enum()` relies on this\n-//     behavior.\n+//     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     match cx.llsizingtypes.find_copy(&t) {\n@@ -232,7 +208,11 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::unique(cx, &ty).ptr_to()\n+          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+              Type::unique(cx, &ty).ptr_to()\n+          } else {\n+              ty.ptr_to()\n+          }\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);"}, {"sha": "df9e29cad7f78397fd82b718402d3c0abbb67447", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use back;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -18,6 +17,9 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::datum;\n use middle::trans::glue;\n use middle::ty;\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_of;\n+use middle::trans::type_of::*;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n@@ -45,12 +47,21 @@ pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     let body_datum = src_datum.box_body(bcx);\n \n     // Malloc space in exchange heap and copy src into it\n-    let MallocResult {\n-        bcx: bcx,\n-        box: dst_box,\n-        body: dst_body\n-    } = malloc_unique(bcx, body_datum.ty);\n-    body_datum.copy_to(bcx, datum::INIT, dst_body);\n-\n-    rslt(bcx, dst_box)\n+    if ty::type_contents(bcx.tcx(), src_ty).contains_managed() {\n+        let MallocResult {\n+            bcx: bcx,\n+            box: dst_box,\n+            body: dst_body\n+        } = malloc_general(bcx, body_datum.ty, heap_managed_unique);\n+        body_datum.copy_to(bcx, datum::INIT, dst_body);\n+\n+        rslt(bcx, dst_box)\n+    } else {\n+        let body_datum = body_datum.to_value_datum(bcx);\n+        let llty = type_of(bcx.ccx(), body_datum.ty);\n+        let size = llsize_of(bcx.ccx(), llty);\n+        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, body_datum.ty, heap_exchange, size);\n+        body_datum.copy_to(bcx, datum::INIT, val);\n+        Result { bcx: bcx, val: val }\n+    }\n }"}, {"sha": "bd22e41aff8f07ea3dba11070c313760ca3bdd6a", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -81,7 +81,7 @@ pub fn return_to_mut(mut bcx: block,\n                 filename_val,\n                 line_val\n             ],\n-            expr::Ignore);\n+            Some(expr::Ignore)).bcx;\n     }\n \n     callee::trans_lang_call(\n@@ -93,8 +93,8 @@ pub fn return_to_mut(mut bcx: block,\n             filename_val,\n             line_val\n         ],\n-        expr::Ignore\n-    )\n+        Some(expr::Ignore)\n+    ).bcx\n }\n \n fn root(datum: &Datum,\n@@ -123,7 +123,7 @@ fn root(datum: &Datum,\n     let scratch = scratch_datum(bcx, datum.ty, true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-    add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n+    add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n \n     // Now, consider also freezing it.\n     match root_info.freeze {\n@@ -144,31 +144,31 @@ fn root(datum: &Datum,\n \n             let box_ptr = Load(bcx, PointerCast(bcx, scratch.val, Type::i8p().ptr_to()));\n \n-            bcx = callee::trans_lang_call(\n+            let llresult = unpack_result!(bcx, callee::trans_lang_call(\n                 bcx,\n                 freeze_did,\n                 [\n                     box_ptr,\n                     filename,\n                     line\n                 ],\n-                expr::SaveIn(scratch_bits.val));\n+                Some(expr::SaveIn(scratch_bits.val))));\n \n             if bcx.tcx().sess.debug_borrows() {\n                 bcx = callee::trans_lang_call(\n                     bcx,\n                     bcx.tcx().lang_items.record_borrow_fn(),\n                     [\n                         box_ptr,\n-                        Load(bcx, scratch_bits.val),\n+                        llresult,\n                         filename,\n                         line\n                     ],\n-                    expr::Ignore);\n+                    Some(expr::Ignore)).bcx;\n             }\n \n             add_clean_return_to_mut(\n-                cleanup_bcx, root_key, scratch.val, scratch_bits.val,\n+                cleanup_bcx, root_info.scope, root_key, scratch.val, scratch_bits.val,\n                 filename, line);\n         }\n     }\n@@ -188,5 +188,5 @@ fn perform_write_guard(datum: &Datum,\n         bcx,\n         bcx.tcx().lang_items.check_not_borrowed_fn(),\n         [PointerCast(bcx, llval, Type::i8p()), filename, line],\n-        expr::Ignore)\n+        Some(expr::Ignore)).bcx\n }"}, {"sha": "dce899010c76dd3e03f4af245c7d29924f9b5832", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -29,7 +29,6 @@ use util::enum_set::{EnumSet, CLike};\n use std::cast;\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n-use std::iter;\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n@@ -1486,8 +1485,8 @@ pub fn type_needs_subst(ty: t) -> bool {\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.self_ty.iter().any_(|&t| type_is_error(t)) ||\n-        tref.substs.tps.iter().any_(|&t| type_is_error(t))\n+    tref.substs.self_ty.iter().any(|&t| type_is_error(t)) ||\n+        tref.substs.tps.iter().any(|&t| type_is_error(t))\n }\n \n pub fn type_is_ty_var(ty: t) -> bool {\n@@ -1647,9 +1646,22 @@ pub fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ty: t) -> bool {\n+fn type_is_newtype_immediate(cx: ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_struct(def_id, ref substs) => {\n+            let fields = struct_fields(cx, def_id, substs);\n+            fields.len() == 1 &&\n+                fields[0].ident == token::special_idents::unnamed_field &&\n+                type_is_immediate(cx, fields[0].mt.ty)\n+        }\n+        _ => false\n+    }\n+}\n+\n+pub fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n     return type_is_scalar(ty) || type_is_boxed(ty) ||\n-        type_is_unique(ty) || type_is_region_ptr(ty);\n+        type_is_unique(ty) || type_is_region_ptr(ty) ||\n+        type_is_newtype_immediate(cx, ty);\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n@@ -1752,7 +1764,7 @@ pub struct TypeContents {\n \n impl TypeContents {\n     pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n-        iter::all(|bb| self.meets_bound(cx, bb), |f| bbs.each(f))\n+        bbs.iter().all(|bb| self.meets_bound(cx, bb))\n     }\n \n     pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n@@ -2330,13 +2342,13 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_struct(did, ref substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n-                let r = fields.iter().any_(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n+                let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                 seen.pop();\n                 r\n             }\n \n             ty_tup(ref ts) => {\n-                ts.iter().any_(|t| type_requires(cx, seen, r_ty, *t))\n+                ts.iter().any(|t| type_requires(cx, seen, r_ty, *t))\n             }\n \n             ty_enum(ref did, _) if seen.contains(did) => {\n@@ -2347,7 +2359,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && do vs.iter().all |variant| {\n-                    do variant.args.iter().any_ |aty| {\n+                    do variant.args.iter().any |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n                     }\n@@ -3148,7 +3160,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_cast(*) => {\n             match tcx.node_types.find(&(expr.id as uint)) {\n                 Some(&t) => {\n-                    if ty::type_is_immediate(t) {\n+                    if ty::type_is_immediate(tcx, t) {\n                         RvalueDatumExpr\n                     } else {\n                         RvalueDpsExpr\n@@ -3229,7 +3241,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n }\n \n pub fn method_idx(id: ast::ident, meths: &[@Method]) -> Option<uint> {\n-    meths.iter().position_(|m| m.ident == id)\n+    meths.iter().position(|m| m.ident == id)\n }\n \n /// Returns a vector containing the indices of all type parameters that appear\n@@ -3612,12 +3624,12 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n             debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n             match cx.items.find(&id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n-                                         node: ast::item_impl(_, opt_trait, _, _),\n+                                         node: ast::item_impl(_, ref opt_trait, _, _),\n                                          _},\n                                          _)) => {\n                     match opt_trait {\n-                        Some(t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                        None => None\n+                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                        &None => None\n                     }\n                 }\n                 _ => None\n@@ -3816,41 +3828,62 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                 }, _) => {\n             let mut disr_val = -1;\n             @enum_definition.variants.iter().transform(|variant| {\n+\n+                let ctor_ty = node_id_to_type(cx, variant.node.id);\n+\n                 match variant.node.kind {\n                     ast::tuple_variant_kind(ref args) => {\n-                        let ctor_ty = node_id_to_type(cx, variant.node.id);\n-                        let arg_tys = {\n-                            if args.len() > 0u {\n-                                ty_fn_args(ctor_ty).map(|a| *a)\n-                            } else {\n+                        let arg_tys = if args.len() > 0u {\n+                                ty_fn_args(ctor_ty).map(|a| *a) }\n+                            else {\n                                 ~[]\n-                            }\n-                        };\n+                            };\n+\n                         match variant.node.disr_expr {\n                           Some (ex) => {\n                             disr_val = match const_eval::eval_const_expr(cx,\n                                                                          ex) {\n                               const_eval::const_int(val) => val as int,\n-                              _ => cx.sess.bug(\"tag_variants: bad disr expr\")\n+                              _ => cx.sess.bug(\"enum_variants: bad disr expr\")\n                             }\n                           }\n                           _ => disr_val += 1\n                         }\n-                        @VariantInfo_{args: arg_tys,\n-                          ctor_ty: ctor_ty,\n-                          name: variant.node.name,\n-                          id: ast_util::local_def(variant.node.id),\n-                          disr_val: disr_val,\n-                          vis: variant.node.vis\n+                        @VariantInfo_{\n+                            args: arg_tys,\n+                            ctor_ty: ctor_ty,\n+                            name: variant.node.name,\n+                            id: ast_util::local_def(variant.node.id),\n+                            disr_val: disr_val,\n+                            vis: variant.node.vis\n                          }\n-                    }\n-                    ast::struct_variant_kind(_) => {\n-                        fail!(\"struct variant kinds unimpl in enum_variants\")\n+                    },\n+                    ast::struct_variant_kind(struct_def) => {\n+                        let arg_tys =\n+                            // Is this check needed for structs too, or are they always guaranteed\n+                            // to have a valid constructor function?\n+                            if struct_def.fields.len() > 0 {\n+                                ty_fn_args(ctor_ty).map(|a| *a)\n+                            } else {\n+                                ~[]\n+                            };\n+\n+                        assert!(variant.node.disr_expr.is_none());\n+                        disr_val += 1;\n+\n+                        @VariantInfo_{\n+                            args: arg_tys,\n+                            ctor_ty: ctor_ty,\n+                            name: variant.node.name,\n+                            id: ast_util::local_def(variant.node.id),\n+                            disr_val: disr_val,\n+                            vis: variant.node.vis\n+                        }\n                     }\n                 }\n             }).collect()\n           }\n-          _ => cx.sess.bug(\"tag_variants: id not bound to an enum\")\n+          _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n     };\n     cx.enum_var_cache.insert(id, result);"}, {"sha": "d8185022e416d8e35f2915defd0cee547ff7ed05", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -85,15 +85,15 @@ pub trait AstConv {\n pub fn get_region_reporting_err(\n     tcx: ty::ctxt,\n     span: span,\n-    a_r: Option<@ast::Lifetime>,\n+    a_r: &Option<ast::Lifetime>,\n     res: Result<ty::Region, RegionError>) -> ty::Region\n {\n     match res {\n         result::Ok(r) => r,\n         result::Err(ref e) => {\n             let descr = match a_r {\n-                None => ~\"anonymous lifetime\",\n-                Some(a) => fmt!(\"lifetime %s\",\n+                &None => ~\"anonymous lifetime\",\n+                &Some(ref a) => fmt!(\"lifetime %s\",\n                                 lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n@@ -109,19 +109,19 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     default_span: span,\n-    opt_lifetime: Option<@ast::Lifetime>) -> ty::Region\n+    opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n     let (span, res) = match opt_lifetime {\n-        None => {\n+        &None => {\n             (default_span, rscope.anon_region(default_span))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n             (lifetime.span, Ok(ty::re_static))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n             (lifetime.span, rscope.self_region(lifetime.span))\n         }\n-        Some(ref lifetime) => {\n+        &Some(ref lifetime) => {\n             (lifetime.span, rscope.named_region(lifetime.span,\n                                                 lifetime.ident))\n         }\n@@ -136,7 +136,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> ty::substs\n+    path: &ast::Path) -> ty::substs\n {\n     /*!\n      *\n@@ -164,11 +164,11 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n       }\n       (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n-        let r = get_region_reporting_err(this.tcx(), path.span, None, res);\n+        let r = get_region_reporting_err(this.tcx(), path.span, &None, res);\n         Some(r)\n       }\n       (&Some(_), &Some(_)) => {\n-        Some(ast_region_to_region(this, rscope, path.span, path.rp))\n+        Some(ast_region_to_region(this, rscope, path.span, &path.rp))\n       }\n     };\n \n@@ -179,7 +179,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n                  decl_generics.type_param_defs.len(), path.types.len()));\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, *a_t));\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, a_t));\n \n     substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n@@ -188,7 +188,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::def_id,\n-    path: @ast::Path) -> ty_param_substs_and_ty\n+    path: &ast::Path) -> ty_param_substs_and_ty\n {\n     let tcx = this.tcx();\n     let ty::ty_param_bounds_and_ty {\n@@ -206,7 +206,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> @ty::TraitRef\n+    path: &ast::Path) -> @ty::TraitRef\n {\n     let trait_def =\n         this.get_trait_def(trait_def_id);\n@@ -228,7 +228,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n-        path: @ast::Path)\n+        path: &ast::Path)\n      -> ty_param_substs_and_ty\n {\n     // Look up the polytype of the item and then substitute the provided types\n@@ -276,7 +276,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(path, bounds, id) => {\n+            ast::ty_path(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n@@ -321,7 +321,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n     }\n \n     fn check_path_args(tcx: ty::ctxt,\n-                       path: @ast::Path,\n+                       path: &ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n             if path.types.len() > 0u {\n@@ -371,13 +371,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n       ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n-      ast::ty_rptr(region, ref mt) => {\n+      ast::ty_rptr(ref region, ref mt) => {\n         let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(ref fields) => {\n-        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, *t));\n+        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n@@ -398,14 +398,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       f.purity,\n                                       f.onceness,\n                                       bounds,\n-                                      f.region,\n+                                      &f.region,\n                                       &f.decl,\n                                       None,\n                                       &f.lifetimes,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(path, bounds, id) => {\n+      ast::ty_path(ref path, ref bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n@@ -525,13 +525,13 @@ pub fn ty_of_arg<AC:AstConv,\n                  RS:region_scope + Copy + 'static>(\n                  this: &AC,\n                  rscope: &RS,\n-                 a: ast::arg,\n+                 a: &ast::arg,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n         ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n }\n \n@@ -553,7 +553,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n     let special_idents = [special_idents::statik, special_idents::self_];\n     let mut bound_lifetime_names = opt_vec::Empty;\n     ast_lifetimes.map_to_vec(|ast_lifetime| {\n-        if special_idents.iter().any_(|&i| i == ast_lifetime.ident) {\n+        if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n             this.tcx().sess.span_err(\n                 ast_lifetime.span,\n                 fmt!(\"illegal lifetime parameter name: `%s`\",\n@@ -621,11 +621,11 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n         transform_self_ty(this, &rb, self_info)\n     });\n \n-    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, *a, None));\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n     let output_ty = match decl.output.node {\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     return (opt_transformed_self_ty,\n@@ -647,7 +647,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n             ast::sty_value => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::sty_region(lifetime, mutability) => {\n+            ast::sty_region(ref lifetime, mutability) => {\n                 let region =\n                     ast_region_to_region(this, rscope,\n                                          self_info.explicit_self.span,\n@@ -677,7 +677,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n-    opt_lifetime: Option<@ast::Lifetime>,\n+    opt_lifetime: &Option<ast::Lifetime>,\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n     lifetimes: &OptVec<ast::Lifetime>,\n@@ -695,10 +695,10 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n-        Some(_) => {\n+        &Some(_) => {\n             ast_region_to_region(this, rscope, span, opt_lifetime)\n         }\n-        None => {\n+        &None => {\n             match sigil {\n                 ast::OwnedSigil | ast::ManagedSigil => {\n                     // @fn(), ~fn() default to static as the bound\n@@ -724,14 +724,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n-        ty_of_arg(this, &rb, *a, expected_arg_ty)\n+        ty_of_arg(this, &rb, a, expected_arg_ty)\n     }.collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     ty::ClosureTy {\n@@ -764,7 +764,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n             let mut builtin_bounds = ty::EmptyBuiltinBounds();\n             for bound_vec.iter().advance |ast_bound| {\n                 match *ast_bound {\n-                    ast::TraitTyParamBound(b) => {\n+                    ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                             ast::def_trait(trait_did) => {\n                                 if try_add_builtin_trait(tcx,"}, {"sha": "1f7946576db5c6cd95c010b952403a000e27a5bf", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -105,7 +105,7 @@ pub struct pat_ctxt {\n     map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -271,7 +271,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: span,\n-                               path: @ast::Path,\n+                               path: &ast::Path,\n                                fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n                                class_id: ast::def_id,\n@@ -322,7 +322,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n }\n \n pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n-                        expected: ty::t, path: @ast::Path,\n+                        expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n@@ -356,7 +356,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n-                                          path: @ast::Path,\n+                                          path: &ast::Path,\n                                           fields: &[ast::field_pat],\n                                           etc: bool,\n                                           enum_id: ast::def_id,\n@@ -440,7 +440,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::pat_ident(bm, name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::pat_ident(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -476,13 +476,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::pat_ident(_, path, _) => {\n+      ast::pat_ident(_, ref path, _) => {\n         check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n       }\n-      ast::pat_enum(path, ref subpats) => {\n+      ast::pat_enum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         let mut error_happened = false;"}, {"sha": "04c83f40f6cf88025384eee2f2301f4b5bbd2993", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -253,7 +253,7 @@ impl<'self> LookupContext<'self> {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n                 // See discussion in typeck::check::do_autoderef().\n-                if enum_dids.iter().any_(|x| x == &did) {\n+                if enum_dids.iter().any(|x| x == &did) {\n                     return None;\n                 }\n                 enum_dids.push(did);\n@@ -368,7 +368,7 @@ impl<'self> LookupContext<'self> {\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             let pos = {\n-                match trait_methods.iter().position_(|m| {\n+                match trait_methods.iter().position(|m| {\n                     m.explicit_self != ast::sty_static &&\n                         m.ident == self.m_name })\n                 {\n@@ -412,7 +412,7 @@ impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         let ms = ty::trait_methods(tcx, did);\n-        let index = match ms.iter().position_(|m| m.ident == self.m_name) {\n+        let index = match ms.iter().position(|m| m.ident == self.m_name) {\n             Some(i) => i,\n             None => { return; } // no method with the right name\n         };\n@@ -466,7 +466,7 @@ impl<'self> LookupContext<'self> {\n         // First, try self methods\n         let mut method_info: Option<MethodInfo> = None;\n         let methods = ty::trait_methods(tcx, did);\n-        match methods.iter().position_(|m| m.ident == self.m_name) {\n+        match methods.iter().position(|m| m.ident == self.m_name) {\n             Some(i) => {\n                 method_info = Some(MethodInfo {\n                     method_ty: methods[i],\n@@ -482,7 +482,7 @@ impl<'self> LookupContext<'self> {\n             for ty::trait_supertraits(tcx, did).iter().advance |trait_ref| {\n                 let supertrait_methods =\n                     ty::trait_methods(tcx, trait_ref.def_id);\n-                match supertrait_methods.iter().position_(|m| m.ident == self.m_name) {\n+                match supertrait_methods.iter().position(|m| m.ident == self.m_name) {\n                     Some(i) => {\n                         method_info = Some(MethodInfo {\n                             method_ty: supertrait_methods[i],\n@@ -538,7 +538,7 @@ impl<'self> LookupContext<'self> {\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position_(|m| m.ident == self.m_name) {\n+            match impl_info.methods.iter().position(|m| m.ident == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }"}, {"sha": "5c8ce6b2d8bb03f51ac897fe81190696c1171b18", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -463,7 +463,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             }\n \n             // Check the pattern.\n-            let region = fcx.block_region();\n             let pcx = pat_ctxt {\n                 fcx: fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n@@ -476,7 +475,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 |local, (e, v)| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n-              _ => Some(fcx.to_ty(local.node.ty))\n+              _ => Some(fcx.to_ty(&local.node.ty))\n             };\n             assign(local.node.id, o_ty);\n             debug!(\"Local variable %s is assigned type %s\",\n@@ -489,7 +488,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add pattern bindings.\n         let visit_pat: @fn(@ast::pat, ((), visit::vt<()>)) = |p, (e, v)| {\n             match p.node {\n-              ast::pat_ident(_, path, _)\n+              ast::pat_ident(_, ref path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n@@ -624,7 +623,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_struct(*) => {\n         check_struct(ccx, it.id, it.span);\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n@@ -790,7 +789,7 @@ impl FnCtxt {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n-    pub fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n@@ -1381,7 +1380,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n                          args: &[@ast::expr],\n-                         tps: &[@ast::Ty],\n+                         tps: &[ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n \n@@ -1390,7 +1389,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n \n-        let tps = tps.map(|ast_ty| fcx.to_ty(*ast_ty));\n+        let tps = tps.map(|ast_ty| fcx.to_ty(ast_ty));\n         match method::lookup(fcx,\n                              expr,\n                              rcvr,\n@@ -1738,7 +1737,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            purity,\n                                            expected_onceness,\n                                            expected_bounds,\n-                                           None,\n+                                           &None,\n                                            decl,\n                                            expected_sig,\n                                            &opt_vec::Empty,\n@@ -1779,7 +1778,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    base: @ast::expr,\n                    field: ast::ident,\n-                   tys: &[@ast::Ty]) {\n+                   tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -1809,7 +1808,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps = tys.iter().transform(|ty| fcx.to_ty(*ty)).collect::<~[ty::t]>();\n+        let tps : ~[ty::t] = tys.iter().transform(|ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2437,7 +2436,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_path(pth) => {\n+      ast::expr_path(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n@@ -2622,7 +2621,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_cast(e, t) => {\n+      ast::expr_cast(e, ref t) => {\n         check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n@@ -2775,7 +2774,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::expr_struct(path, ref fields, base_expr) => {\n+      ast::expr_struct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n             Some(&ast::def_struct(type_def_id)) => {\n@@ -2892,7 +2891,6 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         _ => {}\n     }\n \n-    let region = tcx.region_maps.encl_region(local.node.id);\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n@@ -3286,7 +3284,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path(fcx: @mut FnCtxt,\n-                        pth: @ast::Path,\n+                        pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n                         node_id: ast::node_id) {\n@@ -3310,7 +3308,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             None\n           }\n           Some(_) => { // ...and the type is lifetime parameterized, ok.\n-            Some(ast_region_to_region(fcx, fcx, span, pth.rp))\n+            Some(ast_region_to_region(fcx, fcx, span, &pth.rp))\n           }\n         }\n       }\n@@ -3336,7 +3334,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             (span, \"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(*aty))\n+        pth.types.map(|aty| fcx.to_ty(aty))\n     };\n \n     let substs = substs { self_r: self_r, self_ty: None, tps: tps };"}, {"sha": "65b40fbd48c5d3a3491c8809bf65cd050d3769af", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -36,11 +36,9 @@ use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use util::ppaux::{note_and_explain_region, ty_to_str,\n-                  region_to_str};\n+use util::ppaux::{ty_to_str, region_to_str};\n use middle::pat_util;\n \n-use std::result;\n use std::uint;\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n@@ -419,8 +417,6 @@ fn constrain_callee(rcx: @mut Rcx,\n                     call_expr: @ast::expr,\n                     callee_expr: @ast::expr)\n {\n-    let tcx = rcx.fcx.tcx();\n-\n     let call_region = ty::re_scope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n@@ -559,8 +555,6 @@ fn constrain_index(rcx: @mut Rcx,\n      * includes the deref expr.\n      */\n \n-    let tcx = rcx.fcx.tcx();\n-\n     debug!(\"constrain_index(index_expr=?, indexed_ty=%s\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n "}, {"sha": "7cc3286741430b0ea287a4351929f9c94da8c20c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -67,7 +67,7 @@ impl VtableContext {\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n-    type_param_defs.iter().any_(\n+    type_param_defs.iter().any(\n         |type_param_def| !type_param_def.bounds.trait_bounds.is_empty())\n }\n "}, {"sha": "473d5b8e6e8804e3375f12d862635dc143a96006", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -207,9 +207,11 @@ impl CoherenceChecker {\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n-                    item_impl(_, opt_trait, _, _) => {\n-                        self.check_implementation(item,\n-                                                  opt_trait.iter().transform(|&x| x).collect());\n+                    item_impl(_, ref opt_trait, _, _) => {\n+                        let opt_trait : ~[trait_ref] = opt_trait.iter()\n+                                                                .transform(|&x| x)\n+                                                                .collect();\n+                        self.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n                         // Nothing to do.\n@@ -238,7 +240,7 @@ impl CoherenceChecker {\n \n     pub fn check_implementation(&self,\n                                 item: @item,\n-                                associated_traits: ~[@trait_ref]) {\n+                                associated_traits: &[trait_ref]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -636,7 +638,7 @@ impl CoherenceChecker {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, ((), visitor));\n                     }\n-                    item_impl(_, None, ast_ty, _) => {\n+                    item_impl(_, None, ref ast_ty, _) => {\n                         if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n                             // This is an error.\n                             let session = self.crate_context.tcx.sess;\n@@ -646,7 +648,7 @@ impl CoherenceChecker {\n                                               a trait or new type instead\");\n                         }\n                     }\n-                    item_impl(_, Some(trait_ref), _, _) => {\n+                    item_impl(_, Some(ref trait_ref), _, _) => {\n                         // `for_ty` is `Type` in `impl Trait for Type`\n                         let for_ty =\n                             ty::node_id_to_type(self.crate_context.tcx,\n@@ -678,7 +680,7 @@ impl CoherenceChecker {\n         })));\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -723,7 +725,7 @@ impl CoherenceChecker {\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n-    pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n+    pub fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty)\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, _, path_id) => {\n@@ -805,7 +807,7 @@ impl CoherenceChecker {\n                 // Check that we have implementations of every trait method\n                 for trait_refs.iter().advance |trait_ref| {\n                     let trait_did =\n-                        self.trait_ref_to_trait_def_id(*trait_ref);\n+                        self.trait_ref_to_trait_def_id(trait_ref);\n                     self.please_check_that_trait_methods_are_implemented(\n                         &mut methods,\n                         trait_did,\n@@ -817,7 +819,7 @@ impl CoherenceChecker {\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did = self.trait_ref_to_trait_def_id(*trait_ref);\n+                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n                     self.add_provided_methods_to_impl(\n                         &mut methods,\n                         &trait_did,"}, {"sha": "fb544335a723b8a65d9e21ed3048db0c22b83937", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -148,7 +148,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(region_parameterization);\n-                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n+                let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n                 result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n \n@@ -378,20 +378,20 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          ast_trait_refs: &[@ast::trait_ref],\n+                          ast_trait_refs: &[ast::trait_ref],\n                           generics: &ast::Generics)\n {\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    for ast_trait_refs.iter().advance |&ast_trait_ref| {\n+    for ast_trait_refs.iter().advance |ast_trait_ref| {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n         // FIXME(#5527) Could have same trait multiple times\n-        if ty_trait_refs.iter().any_(|other_trait| other_trait.def_id == trait_ref.def_id) {\n+        if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n             tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n@@ -441,7 +441,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         (_, &ast::sty_static) => {\n@@ -450,7 +450,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         _ => {\n@@ -671,7 +671,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n                          tcx.sess.str_of(impl_m.mty.ident),\n-                         path_to_str(a_trait_ty.path, tcx.sess.intr())));\n+                         path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n     }\n@@ -684,7 +684,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n                      generics: &ast::Generics) {\n     let region_parameterization =\n         RegionParameterization::from_variance_and_generics(rp, generics);\n-    let tt = ccx.to_ty(&type_rscope(region_parameterization), v.node.ty);\n+    let tt = ccx.to_ty(&type_rscope(region_parameterization), &v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -813,7 +813,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n+      ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -839,7 +839,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n         for opt_trait_ref.iter().advance |t| {\n-            check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n+            check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n@@ -966,7 +966,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         ast::def_trait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n-                    ccx, &rscope, trait_did, Some(self_ty), ast_trait_ref.path);\n+                    ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n             ccx.tcx.trait_refs.insert(\n                 ast_trait_ref.ref_id, trait_ref);\n             return trait_ref;\n@@ -975,7 +975,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 fmt!(\"%s is not a trait\",\n-                    path_to_str(ast_trait_ref.path,\n+                    path_to_str(&ast_trait_ref.path,\n                                 ccx.tcx.sess.intr())));\n         }\n     }\n@@ -1031,7 +1031,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n-      ast::item_static(t, _, _) => {\n+      ast::item_static(ref t, _, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -1060,7 +1060,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n           Some(&tpt) => return tpt,\n           None => { }\n@@ -1124,7 +1124,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_static(t, _) => {\n+        ast::foreign_item_static(ref t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -1149,7 +1149,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n                     let bounds = @compute_bounds(ccx, rp, generics,\n-                                                 param_ty, param.bounds);\n+                                                 param_ty, &param.bounds);\n                     let def = ty::TypeParameterDef {\n                         def_id: local_def(param.id),\n                         bounds: bounds\n@@ -1167,7 +1167,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         rp: Option<ty::region_variance>,\n         generics: &ast::Generics,\n         param_ty: ty::param_ty,\n-        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::ParamBounds\n+        ast_bounds: &OptVec<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n          *\n@@ -1184,7 +1184,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         };\n         for ast_bounds.iter().advance |ast_bound| {\n             match *ast_bound {\n-                TraitTyParamBound(b) => {\n+                TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n                     if !astconv::try_add_builtin_trait(\n@@ -1215,8 +1215,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n     let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n-    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n+    let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "ee90d9661c37f90ef1f9112b279c984bf93eb31e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -65,15 +65,14 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{InferCtxtMethods};\n use middle::typeck::infer::{InferCtxt, cres, ures};\n-use middle::typeck::infer::{TypeOrigin, TypeTrace};\n+use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n \n use std::result::{iter_vec2, map_vec2};\n use std::vec;\n use syntax::ast::{Onceness, purity};\n use syntax::ast;\n use syntax::opt_vec;\n-use syntax::codemap::span;\n use syntax::abi::AbiSet;\n \n pub trait Combine {"}, {"sha": "928f33803dd8c556408e1686fdb04f2f50d42f96", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -59,23 +59,18 @@ time of error detection.\n \n */\n \n-use std::prelude::*;\n use middle::ty;\n use middle::ty::Region;\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::TypeTrace;\n-use middle::typeck::infer::TypeOrigin;\n use middle::typeck::infer::SubregionOrigin;\n use middle::typeck::infer::RegionVariableOrigin;\n-use middle::typeck::infer::Types;\n-use middle::typeck::infer::TraitRefs;\n use middle::typeck::infer::ValuePairs;\n use middle::typeck::infer::region_inference::RegionResolutionError;\n use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n-use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n use util::ppaux::UserString;\n use util::ppaux::note_and_explain_region;\n@@ -362,7 +357,7 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n+            infer::ReferenceOutlivesReferent(ty, _) => {\n                 self.tcx.sess.span_err(\n                     origin.span(),\n                     fmt!(\"in type `%s`, pointer has a longer lifetime than \\"}, {"sha": "32f3e8fea3a86407f95831cef5e9b4aa66fb334a", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -26,8 +26,7 @@ use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use syntax::abi::AbiSet;\n-use syntax::codemap::span;\n-use util::common::{indent, indenter};\n+use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n use extra::list;"}, {"sha": "90a316c78f965caf13b337e88eee47662470ddca", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -540,7 +540,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any_(|x| x == v),\n+        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n }"}, {"sha": "96d18976358e0b05eb462542f5f6f1e015f22398", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,7 +21,6 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::isr_alist;\n-use util::common::indent;\n use util::ppaux::mt_to_str;\n \n use extra::list;\n@@ -30,7 +29,6 @@ use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n-use syntax::codemap::span;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n@@ -186,7 +184,7 @@ impl Combine for Lub {\n             // with.\n             for list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n-                if tainted.iter().any_(|x| x == &a_r) {\n+                if tainted.iter().any(|x| x == &a_r) {\n                     debug!(\"generalize_region(r0=%?): \\\n                             replacing with %?, tainted=%?\",\n                            r0, a_br, tainted);"}, {"sha": "d0a778139dbd2b81d6a48d7f797954af8e89c0b7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -328,7 +328,7 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n-               a_is_expected: bool,\n+               _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {"}, {"sha": "50290ba752e74b202f1bb360ddf8ebf476257ab6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -19,13 +19,12 @@ use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n use util::common::indenter;\n-use util::ppaux::{note_and_explain_region, Repr, UserString};\n+use util::ppaux::{Repr};\n \n use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n-use syntax::codemap::span;\n use syntax::ast;\n use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n@@ -455,7 +454,7 @@ impl RegionVarBindings {\n         {\n             let mut result_set = result_set;\n             if r == r1 { // Clearly, this is potentially inefficient.\n-                if !result_set.iter().any_(|x| *x == r2) {\n+                if !result_set.iter().any(|x| *x == r2) {\n                     result_set.push(r2);\n                 }\n             }"}, {"sha": "7e418c0061d33c2458655e8a8f23e25e058b8ef8", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,15 +21,14 @@ use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use util::common::{indent, indenter};\n+use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n use extra::list::Nil;\n use extra::list;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::{Onceness, m_const, purity};\n-use syntax::codemap::span;\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n@@ -200,7 +199,7 @@ impl Combine for Sub {\n                 // or new variables:\n                 match *tainted_region {\n                     ty::re_infer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any_(|x| x == vid) { loop; }\n+                        if new_vars.iter().any(|x| x == vid) { loop; }\n                     }\n                     _ => {\n                         if *tainted_region == skol { loop; }"}, {"sha": "60fc485c4db5d96cd015209d8a6ed3f3b768fd5f", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[link(name = \"rustc\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"0ce89b41-2f92-459e-bbc1-8f5fe32f16cf\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/rustc\")];\n \n@@ -19,6 +19,7 @@\n \n #[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n+#[allow(non_uppercase_statics)];\n #[deny(deprecated_pattern)];\n \n extern mod extra;\n@@ -211,7 +212,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let lint_flags = vec::append(getopts::opt_strs(matches, \"W\"),\n                                  getopts::opt_strs(matches, \"warn\"));\n \n-    let show_lint_options = lint_flags.iter().any_(|x| x == &~\"help\") ||\n+    let show_lint_options = lint_flags.iter().any(|x| x == &~\"help\") ||\n         (opt_present(matches, \"W\") && lint_flags.is_empty());\n \n     if show_lint_options {\n@@ -220,7 +221,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     }\n \n     let r = getopts::opt_strs(matches, \"Z\");\n-    if r.iter().any_(|x| x == &~\"help\") {\n+    if r.iter().any(|x| x == &~\"help\") {\n         describe_debug_flags();\n         return;\n     }"}, {"sha": "3ce645e012b791373349a717afd10f00d88bfe96", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::Iterator;\n \n #[deriving(Eq, IterBytes)]\n pub struct EnumSet<E> {\n@@ -73,6 +74,10 @@ impl<E:CLike> EnumSet<E> {\n         }\n         return true;\n     }\n+\n+    pub fn iter(&self) -> EnumSetIterator<E> {\n+        EnumSetIterator::new(self.bits)\n+    }\n }\n \n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n@@ -93,11 +98,43 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     }\n }\n \n+pub struct EnumSetIterator<E> {\n+    priv index: uint,\n+    priv bits: uint,\n+}\n+\n+impl<E:CLike> EnumSetIterator<E> {\n+    fn new(bits: uint) -> EnumSetIterator<E> {\n+        EnumSetIterator { index: 0, bits: bits }\n+    }\n+}\n+\n+impl<E:CLike> Iterator<E> for EnumSetIterator<E> {\n+    fn next(&mut self) -> Option<E> {\n+        if (self.bits == 0) {\n+            return None;\n+        }\n+\n+        while (self.bits & 1) == 0 {\n+            self.index += 1;\n+            self.bits >>= 1;\n+        }\n+        let elem = CLike::from_uint(self.index);\n+        self.index += 1;\n+        self.bits >>= 1;\n+        Some(elem)\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let exact = self.bits.population_count();\n+        (exact, Some(exact))\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n \n     use std::cast;\n-    use std::iter;\n \n     use util::enum_set::*;\n \n@@ -199,25 +236,58 @@ mod test {\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n-    // each\n+    // iter / each\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[], elems)\n+\n+        e1.add(A);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A], elems)\n+\n+        e1.add(C);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,C], elems)\n+\n+        e1.add(C);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,C], elems)\n+\n+        e1.add(B);\n+        let elems: ~[Foo] = e1.iter().collect();\n+        assert_eq!(~[A,B,C], elems)\n+    }\n \n     #[test]\n     fn test_each() {\n         let mut e1: EnumSet<Foo> = EnumSet::empty();\n \n-        assert_eq!(~[], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[], collect(e1))\n \n         e1.add(A);\n-        assert_eq!(~[A], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A], collect(e1))\n \n         e1.add(C);\n-        assert_eq!(~[A,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,C], collect(e1))\n \n         e1.add(C);\n-        assert_eq!(~[A,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,C], collect(e1))\n \n         e1.add(B);\n-        assert_eq!(~[A,B,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e1.each(f)))\n+        assert_eq!(~[A,B,C], collect(e1))\n+    }\n+\n+    fn collect(e: EnumSet<Foo>) -> ~[Foo] {\n+        let mut elems = ~[];\n+        e.each(|elem| {\n+           elems.push(elem);\n+           true\n+        });\n+        elems\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -234,12 +304,15 @@ mod test {\n         e2.add(C);\n \n         let e_union = e1 | e2;\n-        assert_eq!(~[A,B,C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_union.each(f)))\n+        let elems: ~[Foo] = e_union.iter().collect();\n+        assert_eq!(~[A,B,C], elems)\n \n         let e_intersection = e1 & e2;\n-        assert_eq!(~[C], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_intersection.each(f)))\n+        let elems: ~[Foo] = e_intersection.iter().collect();\n+        assert_eq!(~[C], elems)\n \n         let e_subtract = e1 - e2;\n-        assert_eq!(~[A], iter::FromIter::from_iter::<Foo, ~[Foo]>(|f| e_subtract.each(f)))\n+        let elems: ~[Foo] = e_subtract.iter().collect();\n+        assert_eq!(~[A], elems)\n     }\n }"}, {"sha": "e61f8d6d74334b17eb76a91ed5e14057b7e9637d", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -45,9 +45,9 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta).map(|s| s.to_owned())\n-    };\n+    let doc_strs = do doc_metas(attrs).consume_iter().filter_map |meta| {\n+        attr::get_meta_item_value_str(meta).map(|s| s.to_owned())\n+    }.collect::<~[~str]>();\n     if doc_strs.is_empty() {\n         None\n     } else {\n@@ -57,7 +57,7 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n     let r = doc_metas(attrs);\n-    do r.iter().any_ |meta| {\n+    do r.iter().any |meta| {\n         match attr::get_meta_item_list(*meta) {\n             Some(metas) => {\n                 let hiddens = attr::find_meta_items_by_name(metas, \"hidden\");"}, {"sha": "3393133bc186603acdc5042935abc62521cb62ba", "filename": "src/librustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -23,7 +23,7 @@\n \n \n /// The base price of a muffin on a non-holiday\n-static price_of_a_muffin: float = 70f;\n+static PRICE_OF_A_MUFFIN: float = 70f;\n \n struct WaitPerson {\n     hair_color: ~str"}, {"sha": "3fd6ad1699876346deb79da4c8d7530ae1956b71", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -87,11 +87,11 @@ pub fn extract(desc: Option<~str>) -> Option<~str> {\n }\n \n fn parse_desc(desc: ~str) -> Option<~str> {\n-    static max_brief_len: uint = 120u;\n+    static MAX_BRIEF_LEN: uint = 120u;\n \n     match first_sentence(copy desc) {\n       Some(first_sentence) => {\n-        if first_sentence.len() <= max_brief_len {\n+        if first_sentence.len() <= MAX_BRIEF_LEN {\n             Some(first_sentence)\n         } else {\n             None\n@@ -141,7 +141,7 @@ fn first_sentence_(s: &str) -> ~str {\n pub fn paragraphs(s: &str) -> ~[~str] {\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n+    let mut paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -166,11 +166,8 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n         res\n     };\n \n-    if !accum.is_empty() {\n-        paras + [accum]\n-    } else {\n-        paras\n-    }\n+    if !accum.is_empty() { paras.push(accum); }\n+    paras\n }\n \n #[cfg(test)]"}, {"sha": "ffb4642be8107dcd8509a25e0cfb9ba19eb1ded3", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 39, "deletions": 104, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -13,8 +13,6 @@\n \n use doc;\n \n-use std::vec;\n-\n pub type AstId = int;\n \n #[deriving(Eq)]\n@@ -186,87 +184,64 @@ impl Doc {\n     }\n }\n \n+macro_rules! filt_mapper {\n+    ($vec:expr, $pat:pat) => {\n+        do ($vec).iter().filter_map |thing| {\n+            match thing {\n+                &$pat => Some(copy *x),\n+                _ => None\n+            }\n+        }.collect()\n+    }\n+}\n+\n+macro_rules! md {\n+    ($id:ident) => {\n+        filt_mapper!(self.items, $id(ref x))\n+    }\n+}\n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n     pub fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ModTag(ModDoc) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ModTag)\n     }\n \n     pub fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              NmodTag(nModDoc) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(NmodTag)\n     }\n \n     pub fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              FnTag(FnDoc) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        md!(FnTag)\n     }\n \n     pub fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ConstTag(ConstDoc) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ConstTag)\n     }\n \n     pub fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              EnumTag(EnumDoc) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        md!(EnumTag)\n     }\n \n     pub fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TraitTag(TraitDoc) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TraitTag)\n     }\n \n     pub fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ImplTag(ImplDoc) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ImplTag)\n     }\n \n     pub fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TyTag(TyDoc) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TyTag)\n     }\n \n     pub fn structs(&self) -> ~[StructDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-                StructTag(StructDoc) => Some(StructDoc),\n-                _ => None\n-            }\n-        }\n+        md!(StructTag)\n+    }\n+}\n+\n+macro_rules! pu {\n+    ($id:ident) => {\n+        filt_mapper!(*self, ItemPage($id(ref x)))\n     }\n }\n \n@@ -284,75 +259,35 @@ pub trait PageUtils {\n impl PageUtils for ~[Page] {\n \n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ModTag)\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(NmodTag)\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(FnTag)\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ConstTag)\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(EnumTag)\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TraitTag)\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ImplTag)\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TyTag)\n     }\n }\n "}, {"sha": "01b77a985fedb249a28d456f01dfe3a02ff6557f", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -15,7 +15,6 @@ use astsrv;\n use doc::ItemUtils;\n use doc;\n \n-use std::vec;\n use syntax::ast;\n use syntax::parse::token::{ident_interner, ident_to_str};\n use syntax::parse::token;\n@@ -83,7 +82,7 @@ fn moddoc_from_mod(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: itemdoc,\n-        items: do vec::filter_mapped(module_.items) |item| {\n+        items: do module_.items.iter().filter_map |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n             match copy item.node {\n               ast::item_mod(m) => {\n@@ -133,7 +132,7 @@ fn moddoc_from_mod(\n               }\n               _ => None\n             }\n-        },\n+        }.collect(),\n         index: None\n     }\n }"}, {"sha": "f800a8ab946fe35e6e778b08c285f0a148f79740", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -172,7 +172,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = (doc.path() + [doc.name()]).connect(\"::\");\n+    let fullpath = (doc.path() + &[doc.name()]).connect(\"::\");\n     match &doc {\n         &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n             fullpath"}, {"sha": "d757547d8f76f59332c1cf8464c388ec48f01dee", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -163,7 +163,7 @@ pub fn make_filename(\n             }\n           }\n           doc::ItemPage(doc) => {\n-            (doc.path() + [doc.name()]).connect(\"_\")\n+            (doc.path() + &[doc.name()]).connect(\"_\")\n           }\n         }\n     };"}, {"sha": "83a0d44978ec49c96b84dc3596edbcdb61686cae", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -128,13 +128,12 @@ fn fold_mod(\n \n fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n     doc::ModDoc {\n-        items: do doc.items.filtered |item| {\n-            match *item {\n-              doc::ModTag(_) => false,\n-              doc::NmodTag(_) => false,\n+        items: do doc.items.iter().filter |item| {\n+            match **item {\n+              doc::ModTag(_) | doc::NmodTag(_) => false,\n               _ => true\n             }\n-        },\n+        }.transform(|x| copy *x).collect::<~[doc::ItemTag]>(),\n         .. copy doc\n     }\n }"}, {"sha": "96c5df10680cc51ca8f214d68ec6f92f84f64056", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -41,9 +41,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: do doc.items.filtered |ItemTag| {\n-            !is_hidden(fold.ctxt.clone(), ItemTag.item())\n-        },\n+        items: do doc.items.iter().filter |item_tag| {\n+            !is_hidden(fold.ctxt.clone(), item_tag.item())\n+        }.transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "aeb6e02f244f175055f9f9516d4e1006bfcbc853", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -80,7 +80,7 @@ fn strip_priv_methods(\n     methods: &[@ast::method],\n     item_vis: ast::visibility\n ) -> doc::ImplDoc {\n-    let methods = do (&doc.methods).filtered |method| {\n+    let methods = do doc.methods.iter().filter |method| {\n         let ast_method = do methods.iter().find_ |m| {\n             extract::to_str(m.ident) == method.name\n         };\n@@ -91,7 +91,7 @@ fn strip_priv_methods(\n             ast::private => false,\n             ast::inherited => item_vis == ast::public\n         }\n-    };\n+    }.transform(|x| copy *x).collect();\n \n     doc::ImplDoc {\n         methods: methods,\n@@ -106,9 +106,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: doc.items.filtered(|ItemTag| {\n-            match ItemTag {\n-                &doc::ImplTag(ref doc) => {\n+        items: doc.items.iter().filter(|item_tag| {\n+            match item_tag {\n+                & &doc::ImplTag(ref doc) => {\n                     if doc.trait_types.is_empty() {\n                         // This is an associated impl. We have already pruned the\n                         // non-visible methods. If there are any left then\n@@ -123,10 +123,10 @@ fn fold_mod(\n                     }\n                 }\n                 _ => {\n-                    is_visible(fold.ctxt.clone(), ItemTag.item())\n+                    is_visible(fold.ctxt.clone(), item_tag.item())\n                 }\n             }\n-        }),\n+        }).transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "d12f85dcc44f38085d516cfc6ce951ba8525519b", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,7 +11,7 @@\n //! Rustdoc - The Rust documentation generator\n \n #[link(name = \"rustdoc\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"f8abd014-b281-484d-a0c3-26e3de8e2412\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/rustdoc\")];\n \n@@ -64,7 +64,7 @@ pub mod util;\n pub fn main() {\n     let args = os::args();\n \n-    if args.iter().any_(|x| \"-h\" == *x) || args.iter().any_(|x| \"--help\" == *x) {\n+    if args.iter().any(|x| \"-h\" == *x) || args.iter().any(|x| \"--help\" == *x) {\n         config::usage();\n         return;\n     }"}, {"sha": "40c662e3a09e530a4cf727d0a7864e80e06ea830", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -94,7 +94,7 @@ fn fold_const(\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n-                        node: ast::item_static(ty, _, _), _\n+                        node: ast::item_static(ref ty, _, _), _\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }\n@@ -245,12 +245,12 @@ fn fold_impl(\n         do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get_copy(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n-                    node: ast::item_impl(ref generics, opt_trait_type, self_ty, _), _\n+                    node: ast::item_impl(ref generics, ref opt_trait_type, ref self_ty, _), _\n                 }, _) => {\n                     let bounds = pprust::generics_to_str(generics, extract::interner());\n                     let bounds = if bounds.is_empty() { None } else { Some(bounds) };\n                     let trait_types = opt_trait_type.map_default(~[], |p| {\n-                        ~[pprust::path_to_str(p.path, extract::interner())]\n+                        ~[pprust::path_to_str(&p.path, extract::interner())]\n                     });\n                     (bounds,\n                      trait_types,\n@@ -285,15 +285,14 @@ fn fold_type(\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         ident: ident,\n-                        node: ast::item_ty(ty, ref params), _\n+                        node: ast::item_ty(ref ty, ref params), _\n                     }, _) => {\n                         Some(fmt!(\n                             \"type %s%s = %s\",\n                             to_str(ident),\n                             pprust::generics_to_str(params,\n                                                     extract::interner()),\n-                            pprust::ty_to_str(ty,\n-                                              extract::interner())\n+                            pprust::ty_to_str(ty, extract::interner())\n                         ))\n                     }\n                     _ => fail!(\"expected type\")"}, {"sha": "e15cc04fa9b7e8d048351e1ab75f45264e4d838b", "filename": "src/librusti/program.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -196,21 +196,7 @@ impl Program {\n         // up front, disable lots of annoying lints, then include all global\n         // state such as items, view items, and extern mods.\n         let mut code = fmt!(\"\n-            #[allow(ctypes)];\n-            #[allow(heap_memory)];\n-            #[allow(implicit_copies)];\n-            #[allow(managed_heap_memory)];\n-            #[allow(non_camel_case_types)];\n-            #[allow(owned_heap_memory)];\n-            #[allow(path_statement)];\n-            #[allow(unrecognized_lint)];\n-            #[allow(unused_imports)];\n-            #[allow(while_true)];\n-            #[allow(unused_variable)];\n-            #[allow(dead_assignment)];\n-            #[allow(unused_unsafe)];\n-            #[allow(unused_mut)];\n-            #[allow(unreachable_code)];\n+            #[allow(warnings)];\n \n             extern mod extra;\n             %s // extern mods"}, {"sha": "bbc4b9ff719789478a873c570b3e99c6a4bf0a0d", "filename": "src/librusti/rusti.rc", "status": "removed", "additions": 0, "deletions": 667, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b227583dadd1500bba7752c7e5d9f2ac931611bc/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=b227583dadd1500bba7752c7e5d9f2ac931611bc", "patch": "@@ -1,667 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * rusti - A REPL using the JIT backend\n- *\n- * Rusti works by serializing state between lines of input. This means that each\n- * line can be run in a separate task, and the only limiting factor is that all\n- * local bound variables are encodable.\n- *\n- * This is accomplished by feeding in generated input to rustc for execution in\n- * the JIT compiler. Currently input actually gets fed in three times to get\n- * information about the program.\n- *\n- * - Pass #1\n- *   In this pass, the input is simply thrown at the parser and the input comes\n- *   back. This validates the structure of the program, and at this stage the\n- *   global items (fns, structs, impls, traits, etc.) are filtered from the\n- *   input into the \"global namespace\". These declarations shadow all previous\n- *   declarations of an item by the same name.\n- *\n- * - Pass #2\n- *   After items have been stripped, the remaining input is passed to rustc\n- *   along with all local variables declared (initialized to nothing). This pass\n- *   runs up to typechecking. From this, we can learn about the types of each\n- *   bound variable, what variables are bound, and also ensure that all the\n- *   types are encodable (the input can actually be run).\n- *\n- * - Pass #3\n- *   Finally, a program is generated to deserialize the local variable state,\n- *   run the code input, and then reserialize all bindings back into a local\n- *   hash map. Once this code runs, the input has fully been run and the REPL\n- *   waits for new input.\n- *\n- * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n- * ~[u8] maintaining the values of each local binding (by name).\n- */\n-\n-#[link(name = \"rusti\",\n-       vers = \"0.7\",\n-       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n-\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-extern mod extra;\n-extern mod rustc;\n-extern mod syntax;\n-\n-use std::{libc, io, os, task, vec};\n-use std::cell::Cell;\n-use extra::rl;\n-\n-use rustc::driver::{driver, session};\n-use syntax::{ast, diagnostic};\n-use syntax::ast_util::*;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-\n-use program::Program;\n-use utils::*;\n-\n-mod program;\n-pub mod utils;\n-\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-pub struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    lib_search_paths: ~[~str],\n-\n-    program: Program,\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(mut repl: Repl, input: ~str) -> Repl {\n-    // Build some necessary rustc boilerplate for compiling things\n-    let binary = repl.binary.to_managed();\n-    let options = @session::options {\n-        crate_type: session::unknown_crate,\n-        binary: binary,\n-        addl_lib_search_paths: @mut repl.lib_search_paths.map(|p| Path(*p)),\n-        jit: true,\n-        .. copy *session::basic_options()\n-    };\n-    // Because we assume that everything is encodable (and assert so), add some\n-    // extra helpful information if the error crops up. Otherwise people are\n-    // bound to be very confused when they find out code is running that they\n-    // never typed in...\n-    let sess = driver::build_session(options, |cm, msg, lvl| {\n-        diagnostic::emit(cm, msg, lvl);\n-        if msg.contains(\"failed to find an implementation of trait\") &&\n-           msg.contains(\"extra::serialize::Encodable\") {\n-            diagnostic::emit(cm,\n-                             \"Currrently rusti serializes bound locals between \\\n-                              different lines of input. This means that all \\\n-                              values of local variables need to be encodable, \\\n-                              and this type isn't encodable\",\n-                             diagnostic::note);\n-        }\n-    });\n-    let intr = token::get_ident_interner();\n-\n-    //\n-    // Stage 1: parse the input and filter it into the program (as necessary)\n-    //\n-    debug!(\"parsing: %s\", input);\n-    let crate = parse_input(sess, binary, input);\n-    let mut to_run = ~[];       // statements to run (emitted back into code)\n-    let new_locals = @mut ~[];  // new locals being defined\n-    let mut result = None;      // resultant expression (to print via pp)\n-    do find_main(crate, sess) |blk| {\n-        // Fish out all the view items, be sure to record 'extern mod' items\n-        // differently beause they must appear before all 'use' statements\n-        for blk.node.view_items.iter().advance |vi| {\n-            let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, *vi);\n-            };\n-            match vi.node {\n-                ast::view_item_extern_mod(*) => {\n-                    repl.program.record_extern(s);\n-                }\n-                ast::view_item_use(*) => { repl.program.record_view_item(s); }\n-            }\n-        }\n-\n-        // Iterate through all of the block's statements, inserting them into\n-        // the correct portions of the program\n-        for blk.node.stmts.iter().advance |stmt| {\n-            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n-            match stmt.node {\n-                ast::stmt_decl(d, _) => {\n-                    match d.node {\n-                        ast::decl_item(it) => {\n-                            let name = sess.str_of(it.ident);\n-                            match it.node {\n-                                // Structs are treated specially because to make\n-                                // them at all usable they need to be decorated\n-                                // with #[deriving(Encoable, Decodable)]\n-                                ast::item_struct(*) => {\n-                                    repl.program.record_struct(name, s);\n-                                }\n-                                // Item declarations are hoisted out of main()\n-                                _ => { repl.program.record_item(name, s); }\n-                            }\n-                        }\n-\n-                        // Local declarations must be specially dealt with,\n-                        // record all local declarations for use later on\n-                        ast::decl_local(l) => {\n-                            let mutbl = l.node.is_mutbl;\n-                            do each_binding(l) |path, _| {\n-                                let s = do with_pp(intr) |pp, _| {\n-                                    pprust::print_path(pp, path, false);\n-                                };\n-                                new_locals.push((s, mutbl));\n-                            }\n-                            to_run.push(s);\n-                        }\n-                    }\n-                }\n-\n-                // run statements with expressions (they have effects)\n-                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n-                    to_run.push(s);\n-                }\n-            }\n-        }\n-        result = do blk.node.expr.map_consume |e| {\n-            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n-        };\n-    }\n-    // return fast for empty inputs\n-    if to_run.len() == 0 && result.is_none() {\n-        return repl;\n-    }\n-\n-    //\n-    // Stage 2: run everything up to typeck to learn the types of the new\n-    //          variables introduced into the program\n-    //\n-    info!(\"Learning about the new types in the program\");\n-    repl.program.set_cache(); // before register_new_vars (which changes them)\n-    let input = to_run.connect(\"\\n\");\n-    let test = repl.program.test_code(input, &result, *new_locals);\n-    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n-    let dinput = driver::str_input(test.to_managed());\n-    let cfg = driver::build_configuration(sess, binary, &dinput);\n-    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n-    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n-                                            driver::cu_typeck, Some(outputs));\n-    // Once we're typechecked, record the types of all local variables defined\n-    // in this input\n-    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n-        repl.program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n-    }\n-\n-    //\n-    // Stage 3: Actually run the code in the JIT\n-    //\n-    info!(\"actually running code\");\n-    let code = repl.program.code(input, &result);\n-    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n-    let input = driver::str_input(code.to_managed());\n-    let cfg = driver::build_configuration(sess, binary, &input);\n-    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-    let sess = driver::build_session(options, diagnostic::emit);\n-    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                         Some(outputs));\n-\n-    //\n-    // Stage 4: Inform the program that computation is done so it can update all\n-    //          local variable bindings.\n-    //\n-    info!(\"cleaning up after code\");\n-    repl.program.consume_cache();\n-\n-    return repl;\n-\n-    fn parse_input(sess: session::Session, binary: @str,\n-                   input: &str) -> @ast::crate {\n-        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n-        let input = driver::str_input(code.to_managed());\n-        let cfg = driver::build_configuration(sess, binary, &input);\n-        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n-                                              driver::cu_parse, Some(outputs));\n-        crate.expect(\"parsing should return a crate\")\n-    }\n-\n-    fn find_main(crate: @ast::crate, sess: session::Session,\n-                 f: &fn(&ast::blk)) {\n-        for crate.node.module.items.iter().advance |item| {\n-            match item.node {\n-                ast::item_fn(_, _, _, _, ref blk) => {\n-                    if item.ident == sess.ident_of(\"main\") {\n-                        return f(blk);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        fail!(\"main function was expected somewhere...\");\n-    }\n-}\n-\n-// Compiles a crate given by the filename as a library if the compiled\n-// version doesn't exist or is older than the source file. Binary is\n-// the name of the compiling executable. Returns Some(true) if it\n-// successfully compiled, Some(false) if the crate wasn't compiled\n-// because it already exists and is newer than the source file, or\n-// None if there were compile errors.\n-fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n-    match do task::try {\n-        let src_path = Path(src_filename);\n-        let binary = binary.to_managed();\n-        let options = @session::options {\n-            binary: binary,\n-            addl_lib_search_paths: @mut ~[os::getcwd()],\n-            .. copy *session::basic_options()\n-        };\n-        let input = driver::file_input(copy src_path);\n-        let sess = driver::build_session(options, diagnostic::emit);\n-        *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess, binary, &input);\n-        let outputs = driver::build_output_filenames(\n-            &input, &None, &None, [], sess);\n-        // If the library already exists and is newer than the source\n-        // file, skip compilation and return None.\n-        let mut should_compile = true;\n-        let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n-        let maybe_lib_path = do dir.iter().find_ |file| {\n-            // The actual file's name has a hash value and version\n-            // number in it which is unknown at this time, so looking\n-            // for a file that matches out_filename won't work,\n-            // instead we guess which file is the library by matching\n-            // the prefix and suffix of out_filename to files in the\n-            // directory.\n-            let file_str = file.filename().get();\n-            file_str.starts_with(outputs.out_filename.filestem().get())\n-                && file_str.ends_with(outputs.out_filename.filetype().get())\n-        };\n-        match maybe_lib_path {\n-            Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().get();\n-                let (lib_mtime, _) = lib_path.get_mtime().get();\n-                if lib_mtime >= src_mtime {\n-                    should_compile = false;\n-                }\n-            },\n-            None => { },\n-        }\n-        if (should_compile) {\n-            println(fmt!(\"compiling %s...\", src_filename));\n-            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n-                                 Some(outputs));\n-            true\n-        } else { false }\n-    } {\n-        Ok(true) => Some(true),\n-        Ok(false) => Some(false),\n-        Err(_) => None,\n-    }\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n-    if use_rl {\n-        let result = unsafe { rl::read(prompt) };\n-\n-        match result {\n-            None => None,\n-            Some(line) => {\n-                unsafe { rl::add_history(line) };\n-                Some(line)\n-            }\n-        }\n-    } else {\n-        if io::stdin().eof() {\n-            None\n-        } else {\n-            Some(io::stdin().read_line())\n-        }\n-    }\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n-           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.program.clear();\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            println(\n-                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n-                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n-                 :clear - clear the bindings\\n\\\n-                 :exit - exit from the repl\\n\\\n-                 :help - show this message\");\n-        }\n-        ~\"load\" => {\n-            let mut loaded_crates: ~[~str] = ~[];\n-            for args.iter().advance |arg| {\n-                let (crate, filename) =\n-                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n-                } else {\n-                    (copy *arg, *arg + \".rs\")\n-                };\n-                match compile_crate(filename, copy repl.binary) {\n-                    Some(_) => loaded_crates.push(crate),\n-                    None => { }\n-                }\n-            }\n-            for loaded_crates.iter().advance |crate| {\n-                let crate_path = Path(*crate);\n-                let crate_dir = crate_path.dirname();\n-                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n-                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n-                    repl.lib_search_paths.push(crate_dir);\n-                }\n-            }\n-            if loaded_crates.is_empty() {\n-                println(\"no crates loaded\");\n-            } else {\n-                println(fmt!(\"crates loaded: %s\",\n-                                 loaded_crates.connect(\", \")));\n-            }\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(use_rl, \"rusti| \") {\n-                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n-                    Some(line) => {\n-                        if line.trim() == \":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd.push_str(line);\n-                            multiline_cmd.push_char('\\n');\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n-                use_rl: bool)\n-    -> Option<Repl> {\n-    if line.starts_with(\":\") {\n-        // drop the : and the \\n (one byte each)\n-        let full = line.slice(1, line.len());\n-        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = copy split[0];\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    vec::slice(split, 1, len).to_owned()\n-                } else { ~[] };\n-\n-                match run_cmd(repl, in, out, cmd, args, use_rl) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, in, out, multiline_cmd, use_rl);\n-                        }\n-                    }\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    let line = Cell::new(line);\n-    let r = Cell::new(copy *repl);\n-    let result = do task::try {\n-        run(r.take(), line.take())\n-    };\n-\n-    if result.is_ok() {\n-        return Some(result.get());\n-    }\n-    return None;\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    let in = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: copy args[0],\n-        running: true,\n-        lib_search_paths: ~[],\n-\n-        program: Program::new(),\n-    };\n-\n-    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n-\n-    // only print this stuff if the user is actually typing into rusti\n-    if istty {\n-        println(\"WARNING: The Rust REPL is experimental and may be\");\n-        println(\"unstable. If you encounter problems, please use the\");\n-        println(\"compiler instead. Type :help for help.\");\n-\n-        unsafe {\n-            do rl::complete |line, suggest| {\n-                if line.starts_with(\":\") {\n-                    suggest(~\":clear\");\n-                    suggest(~\":exit\");\n-                    suggest(~\":help\");\n-                    suggest(~\":load\");\n-                }\n-            }\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(istty, repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    if istty {\n-                        println(\"()\");\n-                    }\n-                    loop;\n-                }\n-                match run_line(&mut repl, in, out, line, istty) {\n-                    Some(new_repl) => repl = new_repl,\n-                    None => { }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-//#[cfg(test)]\n-#[cfg(ignore)] // FIXME #7541 doesn't work under cross-compile\n-mod tests {\n-    use std::io;\n-    use std::iterator::IteratorUtil;\n-    use program::Program;\n-    use super::*;\n-\n-    fn repl() -> Repl {\n-        Repl {\n-            prompt: ~\"rusti> \",\n-            binary: ~\"rusti\",\n-            running: true,\n-            lib_search_paths: ~[],\n-            program: Program::new(),\n-        }\n-    }\n-\n-    fn run_program(prog: &str) {\n-        let mut r = repl();\n-        for prog.split_iter('\\n').advance |cmd| {\n-            let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                                  cmd.to_owned(), false);\n-            r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n-        }\n-    }\n-\n-    #[test]\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    #[cfg(not(target_word_size=\"32\",\n-              target_os=\"macos\"))]\n-    fn run_all() {\n-        // FIXME(#7071):\n-        // By default, unit tests are run in parallel. Rusti, on the other hand,\n-        // does not enjoy doing this. I suspect that it is because the LLVM\n-        // bindings are not thread-safe (when running parallel tests, some tests\n-        // were triggering assertions in LLVM (or segfaults). Hence, this\n-        // function exists to run everything serially (sadface).\n-        //\n-        // To get some interesting output, run with RUST_LOG=rusti::tests\n-\n-        debug!(\"hopefully this runs\");\n-        run_program(\"\");\n-\n-        debug!(\"regression test for #5937\");\n-        run_program(\"use std::hashmap;\");\n-\n-        debug!(\"regression test for #5784\");\n-        run_program(\"let a = 3;\");\n-\n-        // XXX: can't spawn new tasks because the JIT code is cleaned up\n-        //      after the main function is done.\n-        // debug!(\"regression test for #5803\");\n-        // run_program(\"\n-        //     spawn( || println(\\\"Please don't segfault\\\") );\n-        //     do spawn { println(\\\"Please?\\\"); }\n-        // \");\n-\n-        debug!(\"inferred integers are usable\");\n-        run_program(\"let a = 2;\\n()\\n\");\n-        run_program(\"\n-            let a = 3;\n-            let b = 4u;\n-            assert!((a as uint) + b == 7)\n-        \");\n-\n-        debug!(\"local variables can be shadowed\");\n-        run_program(\"\n-            let a = 3;\n-            let a = 5;\n-            assert!(a == 5)\n-        \");\n-\n-        debug!(\"strings are usable\");\n-        run_program(\"\n-            let a = ~\\\"\\\";\n-            let b = \\\"\\\";\n-            let c = @\\\"\\\";\n-            let d = a + b + c;\n-            assert!(d.len() == 0);\n-        \");\n-\n-        debug!(\"vectors are usable\");\n-        run_program(\"\n-            let a = ~[1, 2, 3];\n-            let b = &[1, 2, 3];\n-            let c = @[1, 2, 3];\n-            let d = a + b + c;\n-            assert!(d.len() == 9);\n-            let e: &[int] = [];\n-        \");\n-\n-        debug!(\"structs are usable\");\n-        run_program(\"\n-            struct A{ a: int }\n-            let b = A{ a: 3 };\n-            assert!(b.a == 3)\n-        \");\n-\n-        debug!(\"mutable variables\");\n-        run_program(\"\n-            let mut a = 3;\n-            a = 5;\n-            let mut b = std::hashmap::HashSet::new::<int>();\n-            b.insert(a);\n-            assert!(b.contains(&5))\n-            assert!(b.len() == 1)\n-        \");\n-\n-        debug!(\"functions are cached\");\n-        run_program(\"\n-            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n-            let a = fib(3);\n-            let a = a + fib(4);\n-            assert!(a == 5)\n-        \");\n-\n-        debug!(\"modules are cached\");\n-        run_program(\"\n-            mod b { pub fn foo() -> uint { 3 } }\n-            assert!(b::foo() == 3)\n-        \");\n-\n-        debug!(\"multiple function definitions are allowed\");\n-        run_program(\"\n-            fn f() {}\n-            fn f() {}\n-            f()\n-        \");\n-\n-        debug!(\"multiple item definitions are allowed\");\n-        run_program(\"\n-            fn f() {}\n-            mod f {}\n-            struct f;\n-            enum f {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[test]\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    #[cfg(not(target_word_size=\"32\",\n-              target_os=\"macos\"))]\n-    fn exit_quits() {\n-        let mut r = repl();\n-        assert!(r.running);\n-        let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                              ~\":exit\", false);\n-        assert!(result.is_none());\n-        assert!(!r.running);\n-    }\n-}"}, {"sha": "2ba881f5a04aeb2ac011de3a8581c07af51725f3", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -44,7 +44,7 @@\n  */\n \n #[link(name = \"rusti\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n \n@@ -132,7 +132,7 @@ fn run(mut repl: Repl, input: ~str) -> Repl {\n         // differently beause they must appear before all 'use' statements\n         for blk.node.view_items.iter().advance |vi| {\n             let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, *vi);\n+                pprust::print_view_item(pp, vi);\n             };\n             match vi.node {\n                 ast::view_item_extern_mod(*) => {\n@@ -381,7 +381,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n-                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n+                if !repl.lib_search_paths.iter().any(|x| x == &crate_dir) {\n                     repl.lib_search_paths.push(crate_dir);\n                 }\n             }\n@@ -511,8 +511,7 @@ pub fn main() {\n     }\n }\n \n-//#[cfg(test)]\n-#[cfg(ignore)] // FIXME #7541 doesn't work under cross-compile\n+#[cfg(test)]\n mod tests {\n     use std::io;\n     use std::iterator::IteratorUtil;\n@@ -530,8 +529,9 @@ mod tests {\n     }\n \n     // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    #[cfg(not(target_word_size=\"32\"))]\n-    #[cfg(not(target_os=\"macos\"))]\n+    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n+    // FIXME: #7115 re-enable once LLVM has been upgraded\n+    #[cfg(thiswillneverbeacfgflag)]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n         for prog.split_iter('\\n').advance |cmd| {\n@@ -540,7 +540,6 @@ mod tests {\n             r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n         }\n     }\n-    #[cfg(target_word_size=\"32\", target_os=\"macos\")]\n     fn run_program(_: &str) {}\n \n     #[test]\n@@ -668,8 +667,10 @@ mod tests {\n             fn f() {}\n             f()\n         \");\n+    }\n \n-        debug!(\"simultaneous definitions + expressions are allowed\");\n+    #[test]\n+    fn simultaneous_definition_and_expression() {\n         run_program(\"\n             let a = 3; a as u8\n         \");"}, {"sha": "3932df1db847abfd4ed9e647ea1462adae41f2e2", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,14 +14,14 @@ use syntax::print::pp;\n use syntax::print::pprust;\n use syntax::parse::token;\n \n-pub fn each_binding(l: @ast::local, f: @fn(@ast::Path, ast::node_id)) {\n+pub fn each_binding(l: @ast::local, f: @fn(&ast::Path, ast::node_id)) {\n     use syntax::visit;\n \n     let vt = visit::mk_simple_visitor(\n         @visit::SimpleVisitor {\n             visit_pat: |pat| {\n                 match pat.node {\n-                    ast::pat_ident(_, path, _) => {\n+                    ast::pat_ident(_, ref path, _) => {\n                         f(path, pat.id);\n                     }\n                     _ => {}"}, {"sha": "5233b87f7e4fa62914ccd0117495096204f84fb7", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,10 +14,8 @@ use package_id::*;\n use package_source::*;\n use version::Version;\n \n-use std::option::*;\n use std::os;\n use std::hashmap::*;\n-use std::path::*;\n \n /// Convenience functions intended for calling from pkg.rs\n "}, {"sha": "96c99a7a0f17edcb4e7e3a8e9c0ee1cf910ef31d", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,18 +10,17 @@\n \n use extra::term;\n use std::io;\n-use std::result::*;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color::green, io::stdout())\n+    pretty_message(msg, \"note: \", term::color::GREEN, io::stdout())\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color::yellow, io::stdout())\n+    pretty_message(msg, \"warning: \", term::color::YELLOW, io::stdout())\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color::red, io::stdout())\n+    pretty_message(msg, \"error: \", term::color::RED, io::stdout())\n }\n \n fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: term::color::Color, out: @io::Writer) {"}, {"sha": "b2f608bd352aefb8d9a41a6a3d7582337092f7d7", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,7 +11,6 @@\n use target::*;\n use package_id::PkgId;\n use std::path::Path;\n-use std::option::*;\n use std::{os, run, str};\n use context::*;\n use crate::Crate;"}, {"sha": "b8f77ceececd756a08f68966b55ca36b66e14188", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -29,9 +29,9 @@ fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n }\n \n #[cfg(windows)]\n-static path_entry_separator: &'static str = \";\";\n+static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n #[cfg(not(windows))]\n-static path_entry_separator: &'static str = \":\";\n+static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. Includes default entries for, if they exist:\n@@ -42,7 +42,7 @@ pub fn rust_path() -> ~[Path] {\n     let mut env_rust_path: ~[Path] = match os::getenv(\"RUST_PATH\") {\n         Some(env_path) => {\n             let env_path_components: ~[&str] =\n-                env_path.split_str_iter(path_entry_separator).collect();\n+                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n             env_path_components.map(|&s| Path(s))\n         }\n         None => ~[]\n@@ -56,12 +56,12 @@ pub fn rust_path() -> ~[Path] {\n     env_rust_path\n }\n \n-pub static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n \n /// Creates a directory that is readable, writeable,\n /// and executable by the user. Returns true iff creation\n /// succeeded.\n-pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n+pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n \n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n@@ -318,7 +318,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n         Lib => \"lib\", Main | Test | Bench => \"bin\"\n     };\n     let result = workspace.push(subdir);\n-    if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n+    if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n         cond.raise((copy result, fmt!(\"target_file_in_workspace couldn't \\\n             create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n             subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n@@ -335,7 +335,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n     result = result.push_rel(&*pkgid.local_path);\n-    if os::path_exists(&result) || os::mkdir_recursive(&result, u_rwx) {\n+    if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }\n     else {"}, {"sha": "4e4570961e752fd0edc642c3a6d93508fea71bff", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,7 +11,7 @@\n // rustpkg - a package manager and build system for Rust\n \n #[link(name = \"rustpkg\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"25de5e6e-279e-4a20-845c-4cabae92daaf\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/librustpkg\")];\n \n@@ -38,7 +38,7 @@ use syntax::{ast, diagnostic};\n use util::*;\n use messages::*;\n use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n-use path_util::{u_rwx, rust_path};\n+use path_util::{U_RWX, rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces};\n@@ -374,7 +374,7 @@ impl CtxMethods for Ctx {\n \n         for maybe_executable.iter().advance |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n-            if !(os::mkdir_recursive(&target_exec.dir_path(), u_rwx) &&\n+            if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n                  os::copy_file(exec, &target_exec)) {\n                 cond.raise((copy *exec, copy target_exec));\n             }\n@@ -383,7 +383,7 @@ impl CtxMethods for Ctx {\n             let target_lib = (copy target_lib).expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n-            if !(os::mkdir_recursive(&target_lib.dir_path(), u_rwx) &&\n+            if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                  os::copy_file(lib, &target_lib)) {\n                 cond.raise((copy *lib, copy target_lib));\n             }"}, {"sha": "251783577df8e8eb746a2452394d1406c5ab1fb4", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,7 +21,7 @@ use package_source::*;\n use version::{ExactRevision, NoVersion, Version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx, u_rwx, library_in_workspace,\n+               make_dir_rwx, U_RWX, library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace,\n                 installed_library_in_workspace, rust_path};\n@@ -78,7 +78,7 @@ fn mk_workspace(workspace: &Path, short_name: &LocalPath, version: &Version) ->\n     // include version number in directory name\n     let package_dir = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n                                                       short_name.to_str(), version.to_str()));\n-    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n@@ -92,7 +92,7 @@ fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n     debug!(\"mk_workspace: creating %s\", package_dir.to_str());\n-    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n@@ -181,7 +181,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     let package_dir = pkgdir.push(\"src\").push(pkgid.to_str());\n \n     // Create main, lib, test, and bench files\n-    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n@@ -585,9 +585,9 @@ fn rust_path_test() {\n fn rust_path_contents() {\n     let dir = mkdtemp(&os::tmpdir(), \"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.push(\"A\").push(\"B\").push(\"C\");\n-    assert!(os::mkdir_recursive(&abc.push(\".rust\"), u_rwx));\n-    assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), u_rwx));\n-    assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), u_rwx));\n+    assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n+    assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n+    assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n     assert!(do os::change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n         let p = rust_path();\n         let cwd = os::getcwd().push(\".rust\");\n@@ -626,14 +626,14 @@ fn install_remove() {\n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(list_output.iter().any_(|x| x == &~\"foo\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n+    assert!(list_output.iter().any(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any(|x| x == &~\"quux\"));\n     command_line_test([~\"remove\", ~\"foo\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(!list_output.iter().any_(|x| x == &~\"foo\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n+    assert!(!list_output.iter().any(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any(|x| x == &~\"quux\"));\n }\n \n #[test]\n@@ -699,7 +699,7 @@ fn test_versions() {\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n-    assert!(!output.iter().any_(|x| x == &~\"foo#0.2\"));\n+    assert!(!output.iter().any(|x| x == &~\"foo#0.2\"));\n }\n \n #[test]"}, {"sha": "900ef4896ca118f117cb32e6025dda26ffcef6f4", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{libc, os, result, str};\n+use std::{os, result};\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n@@ -28,7 +28,7 @@ use search::find_library_in_search_path;\n use path_util::target_library_in_workspace;\n pub use target::{OutputType, Main, Lib, Bench, Test};\n \n-static Commands: &'static [&'static str] =\n+static COMMANDS: &'static [&'static str] =\n     &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n       \"unprefer\"];\n \n@@ -55,7 +55,7 @@ pub fn root() -> Path {\n }\n \n pub fn is_cmd(cmd: &str) -> bool {\n-    Commands.iter().any_(|&c| c == cmd)\n+    COMMANDS.iter().any(|&c| c == cmd)\n }\n \n struct ListenerFn {\n@@ -77,9 +77,9 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n             fold: @fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n-            attrs: do item.attrs.filtered |attr| {\n-                \"main\" != attr::get_attr_name(attr)\n-            },\n+            attrs: do item.attrs.iter().filter_map |attr| {\n+                if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+            }.collect(),\n             .. copy *item\n         }\n     }\n@@ -379,6 +379,7 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    use std::{libc, str};\n     unsafe {\n         do str::as_c_str(src.to_str()) |src_buf| {\n             do str::as_c_str(dest.to_str()) |dest_buf| {\n@@ -417,4 +418,4 @@ mod test {\n \n // tjc: cheesy\n fn debug_flags() -> ~[~str] { ~[] }\n-// static debug_flags: ~[~str] = ~[~\"-Z\", ~\"time-passes\"];\n+// static DEBUG_FLAGS: ~[~str] = ~[~\"-Z\", ~\"time-passes\"];"}, {"sha": "5876dbdc9dea13823124cef251901c6857375a72", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -34,6 +34,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n }\n \n pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n-    rust_path().filtered(|ws|\n-        workspace_contains_package_id(pkgid, ws))\n+    rust_path().consume_iter()\n+        .filter(|ws| workspace_contains_package_id(pkgid, ws))\n+        .collect()\n }"}, {"sha": "dfd39af093d96df0ad4e638203d80942d816d626", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -17,8 +17,7 @@ use kinds::Copy;\n use option::Option;\n use sys;\n use uint;\n-use vec;\n-use vec::ImmutableVector;\n+use vec::{ImmutableVector, OwnedVector};\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n@@ -142,7 +141,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n     let mut av = @[];\n     unsafe {\n         raw::reserve(&mut av, v.len());\n-        do vec::consume(v) |_i, x| {\n+        for v.consume_iter().advance |x| {\n             raw::push(&mut av, x);\n         }\n         transmute(av)\n@@ -160,13 +159,14 @@ pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n #[cfg(not(test))]\n pub mod traits {\n     use at_vec::append;\n+    use vec::Vector;\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<'self,T:Copy> Add<&'self [T],@[T]> for @[T] {\n+    impl<'self,T:Copy, V: Vector<T>> Add<V,@[T]> for @[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self [T]) -> @[T] {\n-            append(*self, (*rhs))\n+        fn add(&self, rhs: &V) -> @[T] {\n+            append(*self, rhs.as_slice())\n         }\n     }\n }\n@@ -335,7 +335,7 @@ mod test {\n \n     #[test]\n     fn append_test() {\n-        assert_eq!(@[1,2,3] + [4,5,6], @[1,2,3,4,5,6]);\n+        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n     }\n \n     #[test]"}, {"sha": "b0b586df4b58edcd6daa4d40d53301a00ea64b77", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -122,6 +122,7 @@ pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n * ~~~ {.rust}\n * rusti> std::bool::implies(true, true)\n * true\n+* ~~~\n *\n * ~~~ {.rust}\n * rusti> std::bool::implies(true, false)"}, {"sha": "47473c2faba65649976f64fff6f2e09144a01f34", "filename": "src/libstd/char.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -82,7 +82,8 @@ pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n ///\n #[inline]\n pub fn is_whitespace(c: char) -> bool {\n-    ('\\x09' <= c && c <= '\\x0d')\n+    c == ' '\n+        || ('\\x09' <= c && c <= '\\x0d')\n         || general_category::Zs(c)\n         || general_category::Zl(c)\n         || general_category::Zp(c)"}, {"sha": "8b9b3102831c6c55da53acb6851b126a1dbe17d3", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -73,7 +73,7 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n-    do vec::consume(eithers) |_i, elt| {\n+    for eithers.consume_iter().advance |elt| {\n         match elt {\n             Left(l) => lefts.push(l),\n             Right(r) => rights.push(r)"}, {"sha": "f92561edcb0863f66c3587b02abb9e8d3254775d", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[doc(hidden)];\n+#[allow(non_uppercase_statics)];\n \n /*! Precise garbage collector\n "}, {"sha": "2d80dc2be152d094fc56b3761bd1d09b613d78c9", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -24,7 +24,7 @@ use rand::RngUtil;\n use rand;\n use uint;\n use vec;\n-use vec::{ImmutableVector, MutableVector};\n+use vec::{ImmutableVector, MutableVector, OwnedVector};\n use kinds::Copy;\n use util::{replace, unreachable};\n \n@@ -175,7 +175,8 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                   vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n-        do vec::consume(old_buckets) |_, bucket| {\n+        // consume_rev_iter is more efficient\n+        for old_buckets.consume_rev_iter().advance |bucket| {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -441,7 +442,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n                               vec::from_fn(INITIAL_CAPACITY, |_| None));\n         self.size = 0;\n \n-        do vec::consume(buckets) |_, bucket| {\n+        for buckets.consume_iter().advance |bucket| {\n             match bucket {\n                 None => {},\n                 Some(Bucket{key, value, _}) => {"}, {"sha": "38826dd411b681f7653c08321123051abd501297", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -917,7 +917,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n-            do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n+            do bytes.as_mut_buf |buf_p, buf_len| {\n                 assert!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -1152,7 +1152,7 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n                                         1,\n                                         len as size_t,\n@@ -1203,7 +1203,7 @@ impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 while count < len {\n                     let vb = ptr::offset(vbuf, count) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);"}, {"sha": "2092ae588d01db64436ea01643c2da91198bba83", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 302, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,316 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n+/*! Times trait\n \n ~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+use iter::Times;\n+let ten = 10 as uint;\n+let mut accum = 0;\n+for ten.times { accum += 1; }\n ~~~\n \n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for it.advance |&x: &uint| {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n */\n \n-use cmp::Ord;\n-use option::{Option, Some, None};\n-use num::{One, Zero};\n-use ops::{Add, Mul};\n-\n #[allow(missing_doc)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool) -> bool;\n }\n \n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    for iter |x| {\n-        if predicate(x) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    for iter |x| {\n-        if predicate(&x) {\n-            return Some(x);\n-        }\n-    }\n-    None\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "4f5f1bd85c73fa42cc2e8a1163d811adfbdfe086", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 202, "deletions": 25, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -26,6 +26,7 @@ use option::{Option, Some, None};\n use ops::{Add, Mul};\n use cmp::Ord;\n use clone::Clone;\n+use uint;\n \n /// Conversion from an `Iterator`\n pub trait FromIterator<A, T: Iterator<A>> {\n@@ -43,7 +44,7 @@ pub trait Iterator<A> {\n     /// Return a lower bound and upper bound on the remaining length of the iterator.\n     ///\n     /// The common use case for the estimate is pre-allocating space to store the results.\n-    fn size_hint(&self) -> (Option<uint>, Option<uint>) { (None, None) }\n+    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -244,6 +245,25 @@ pub trait IteratorUtil<A> {\n     fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n         -> FlatMapIterator<'r, A, B, Self, U>;\n \n+    /// Creates an iterator that calls a function with a reference to each\n+    /// element before yielding it. This is often useful for debugging an\n+    /// iterator pipeline.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n+    ///let sum = xs.iter()\n+    ///            .transform(|&x| x)\n+    ///            .peek_(|&x| debug!(\"filtering %u\", x))\n+    ///            .filter(|&x| x % 2 == 0)\n+    ///            .peek_(|&x| debug!(\"%u made it through\", x))\n+    ///            .sum();\n+    ///println(sum.to_str());\n+    /// ~~~\n+    // FIXME: #5898: should be called `peek`\n+    fn peek_<'r>(self, f: &'r fn(&A)) -> PeekIterator<'r, A, Self>;\n+\n     /// An adaptation of an external iterator to the for-loop protocol of rust.\n     ///\n     /// # Example\n@@ -337,16 +357,16 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.any_(|&x| *x == 3));\n-    /// assert!(!it.any_(|&x| *x == 3));\n+    /// assert!(it.any(|&x| *x == 3));\n+    /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any_(&mut self, f: &fn(A) -> bool) -> bool;\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n \n     /// Return the first element satisfying the specified predicate\n     fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A>;\n \n     /// Return the index of the first element satisfying the specified predicate\n-    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n+    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n \n     /// Count the number of elements satisfying the specified predicate\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint;\n@@ -441,6 +461,12 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         FlatMapIterator{iter: self, f: f, subiter: None }\n     }\n \n+    // FIXME: #5898: should be called `peek`\n+    #[inline]\n+    fn peek_<'r>(self, f: &'r fn(&A)) -> PeekIterator<'r, A, T> {\n+        PeekIterator{iter: self, f: f}\n+    }\n+\n     /// A shim implementing the `for` loop iteration protocol for iterator objects\n     #[inline]\n     fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n@@ -503,7 +529,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline]\n-    fn any_(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if f(x) { return true; } }\n         false\n     }\n@@ -519,7 +545,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n         let mut i = 0;\n         for self.advance |x| {\n             if predicate(x) {\n@@ -684,18 +710,18 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = match (a_lower, b_lower) {\n-            (Some(x), Some(y)) => Some(x + y),\n-            (Some(x), None) => Some(x),\n-            (None, Some(y)) => Some(y),\n-            (None, None) => None\n+        let lower = if uint::max_value - a_lower < b_lower {\n+            uint::max_value\n+        } else {\n+            a_lower + b_lower\n         };\n \n         let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) if uint::max_value - x < y => Some(uint::max_value),\n             (Some(x), Some(y)) => Some(x + y),\n             _ => None\n         };\n@@ -719,6 +745,23 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<A, T\n             _ => None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator which maps the values of `iter` with `f`\n@@ -737,7 +780,7 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         self.iter.size_hint()\n     }\n }\n@@ -762,9 +805,9 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         let (_, upper) = self.iter.size_hint();\n-        (None, upper) // can't know a lower bound, due to the predicate\n+        (0, upper) // can't know a lower bound, due to the predicate\n     }\n }\n \n@@ -787,9 +830,9 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMapIterator<'self, A, B,\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         let (_, upper) = self.iter.size_hint();\n-        (None, upper) // can't know a lower bound, due to the predicate\n+        (0, upper) // can't know a lower bound, due to the predicate\n     }\n }\n \n@@ -812,6 +855,11 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<A, T> {\n             _ => None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n }\n \n /// An iterator which rejects elements while `predicate` is true\n@@ -844,6 +892,12 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhileIterator<'self, A, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n }\n \n /// An iterator which only accepts elements while `predicate` is true\n@@ -872,6 +926,12 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhileIterator<'self, A, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n }\n \n /// An iterator which skips over `n` elements of `iter`.\n@@ -905,6 +965,21 @@ impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<A, T> {\n             next\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = if lower >= self.n { lower - self.n } else { 0 };\n+\n+        let upper = match upper {\n+            Some(x) if x >= self.n => Some(x - self.n),\n+            Some(_) => Some(0),\n+            None => None\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator which only iterates over the first `n` iterations of `iter`.\n@@ -925,6 +1000,20 @@ impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<A, T> {\n             None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator to maintain state while iterating another iterator\n@@ -941,6 +1030,12 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for ScanIterator<'self, A, B,\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().chain(|a| (self.f)(&mut self.state, a))\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n }\n \n /// An iterator that maps each element to an iterator,\n@@ -971,6 +1066,32 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n     }\n }\n \n+/// An iterator that calls a function with a reference to each\n+/// element before yielding it.\n+pub struct PeekIterator<'self, A, T> {\n+    priv iter: T,\n+    priv f: &'self fn(&A)\n+}\n+\n+impl<'self, A, T: Iterator<A>> Iterator<A> for PeekIterator<'self, A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let next = self.iter.next();\n+\n+        match next {\n+            Some(ref a) => (self.f)(a),\n+            None => ()\n+        }\n+\n+        next\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n /// An iterator which just modifies the contained state throughout iteration.\n pub struct UnfoldrIterator<'self, A, St> {\n     priv f: &'self fn(&mut St) -> Option<A>,\n@@ -1022,6 +1143,11 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n         self.state = self.state.add(&self.step); // FIXME: #6050\n         Some(result)\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (uint::max_value, None) // Too bad we can't specify an infinite lower bound\n+    }\n }\n \n #[cfg(test)]\n@@ -1161,6 +1287,20 @@ mod tests {\n         assert_eq!(i, ys.len());\n     }\n \n+    #[test]\n+    fn test_peek() {\n+        let xs = [1u, 2, 3, 4];\n+        let mut n = 0;\n+\n+        let ys = xs.iter()\n+                   .transform(|&x| x)\n+                   .peek_(|_| n += 1)\n+                   .collect::<~[uint]>();\n+\n+        assert_eq!(n, xs.len());\n+        assert_eq!(xs, ys.as_slice());\n+    }\n+\n     #[test]\n     fn test_unfoldr() {\n         fn count(st: &mut uint) -> Option<uint> {\n@@ -1237,6 +1377,43 @@ mod tests {\n         assert_eq!(v.slice(0, 0).iter().transform(|&x| x).min(), None);\n     }\n \n+    #[test]\n+    fn test_iterator_size_hint() {\n+        let c = Counter::new(0, 1);\n+        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let v2 = &[10, 11, 12];\n+        let vi = v.iter();\n+\n+        assert_eq!(c.size_hint(), (uint::max_value, None));\n+        assert_eq!(vi.size_hint(), (10, Some(10)));\n+\n+        assert_eq!(c.take_(5).size_hint(), (5, Some(5)));\n+        assert_eq!(c.skip(5).size_hint().second(), None);\n+        assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.enumerate().size_hint(), (uint::max_value, None));\n+        assert_eq!(c.chain_(vi.transform(|&i| i)).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n+        assert_eq!(c.scan(0, |_,_| Some(0)).size_hint(), (0, None));\n+        assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.transform(|_| 0).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n+\n+        assert_eq!(vi.take_(5).size_hint(), (5, Some(5)));\n+        assert_eq!(vi.take_(12).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n+        assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n+        assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n+        assert_eq!(vi.chain_(v2.iter()).size_hint(), (13, Some(13)));\n+        assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n+        assert_eq!(vi.scan(0, |_,_| Some(0)).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.transform(|i| i+1).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n+    }\n+\n     #[test]\n     fn test_collect() {\n         let a = ~[1, 2, 3, 4, 5];\n@@ -1256,10 +1433,10 @@ mod tests {\n     #[test]\n     fn test_any() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().any_(|&x| x < 10));\n-        assert!(v.iter().any_(|&x| x.is_even()));\n-        assert!(!v.iter().any_(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any_(|_| fail!()));\n+        assert!(v.iter().any(|&x| x < 10));\n+        assert!(v.iter().any(|&x| x.is_even()));\n+        assert!(!v.iter().any(|&x| x > 100));\n+        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }\n \n     #[test]\n@@ -1273,9 +1450,9 @@ mod tests {\n     #[test]\n     fn test_position() {\n         let v = &[1, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(v.iter().position_(|x| *x & 1 == 0).unwrap(), 5);\n-        assert_eq!(v.iter().position_(|x| *x % 3 == 0).unwrap(), 1);\n-        assert!(v.iter().position_(|x| *x % 12 == 0).is_none());\n+        assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n+        assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n+        assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n     }\n \n     #[test]"}, {"sha": "6c16ecc0d4ef8bc5ef84b1774d2727e0c560bafd", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -18,7 +18,7 @@ intrinsic properties of the type. These classifications, often called\n They cannot be implemented by user code, but are instead implemented\n by the compiler automatically for the types to which they apply.\n \n-The 4 kinds are\n+The 3 kinds are\n \n * Copy - types that may be copied without allocation. This includes\n   scalar types and managed pointers, and exludes owned pointers. It"}, {"sha": "14e719bc8dd46ed318976eac9e909f7e556d7f11", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -64,6 +64,7 @@\n */\n \n #[allow(non_camel_case_types)];\n+#[allow(non_uppercase_statics)];\n #[allow(missing_doc)];\n \n // Initial glob-exports mean that all the contents of all the modules"}, {"sha": "c89fc73693cae777be1d28313d5c7958554101d0", "filename": "src/libstd/num/cmath.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n // function names are almost identical to C's libmath, a few have been\n // renamed, grep for \"rename:\""}, {"sha": "a84c27cd91882f67e13bd9d970221af5b8569841", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,6 +10,7 @@\n \n //! Operations and constants for `f32`\n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n use libc::c_int;\n use num::{Zero, One, strconv};"}, {"sha": "216963e04143dfde496efac941d679686735acd0", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f64`\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n use libc::c_int;\n use num::{Zero, One, strconv};"}, {"sha": "d73ff16c6f7bca0ef7431f9881648c702e93075f", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,6 +21,7 @@\n // PORT this must match in width according to architecture\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n use f64;\n use libc::c_int;"}, {"sha": "d39b4b2b911ff6d02c02ed7e5714c08b96810da1", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for `int`\n \n+#[allow(non_uppercase_statics)];\n+\n use num::BitCount;\n \n pub use self::generated::*;"}, {"sha": "c2eebf9a3e41a17410d4cc670a60cdc437cb1f37", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,6 +14,8 @@\n \n macro_rules! int_module (($T:ty, $bits:expr) => (mod generated {\n \n+#[allow(non_uppercase_statics)];\n+\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;"}, {"sha": "337d804ce732d603a7540e925547fc674eb80e5a", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -101,12 +101,12 @@ impl_NumStrConv_Integer!(u64)\n \n \n // Special value strings as [u8] consts.\n-static inf_buf:          [u8, ..3] = ['i' as u8, 'n' as u8, 'f' as u8];\n-static positive_inf_buf: [u8, ..4] = ['+' as u8, 'i' as u8, 'n' as u8,\n+static INF_BUF:          [u8, ..3] = ['i' as u8, 'n' as u8, 'f' as u8];\n+static POS_INF_BUF: [u8, ..4] = ['+' as u8, 'i' as u8, 'n' as u8,\n                                       'f' as u8];\n-static negative_inf_buf: [u8, ..4] = ['-' as u8, 'i' as u8, 'n' as u8,\n+static NEG_INF_BUF: [u8, ..4] = ['-' as u8, 'i' as u8, 'n' as u8,\n                                       'f' as u8];\n-static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n+static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n \n /**\n  * Converts an integral number to its string representation as a byte vector.\n@@ -506,15 +506,15 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n     }\n \n     if special {\n-        if buf == inf_buf || buf == positive_inf_buf {\n+        if buf == INF_BUF || buf == POS_INF_BUF {\n             return NumStrConv::inf();\n-        } else if buf == negative_inf_buf {\n+        } else if buf == NEG_INF_BUF {\n             if negative {\n                 return NumStrConv::neg_inf();\n             } else {\n                 return None;\n             }\n-        } else if buf == nan_buf {\n+        } else if buf == NAN_BUF {\n             return NumStrConv::NaN();\n         }\n     }"}, {"sha": "d185b2a05a8c4e051ada4b337d22bc20941aa7d0", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,6 +14,8 @@\n \n macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (mod generated {\n \n+#[allow(non_uppercase_statics)];\n+\n use num::BitCount;\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};"}, {"sha": "fb9962f8a44ec7a5f6d4bb4a5c23226abae3d408", "filename": "src/libstd/option.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -161,7 +161,7 @@ impl<T> Option<T> {\n \n     /// Filters an optional value using given function.\n     #[inline(always)]\n-    pub fn filtered<'a>(self, f: &fn(t: &'a T) -> bool) -> Option<T> {\n+    pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n         match self {\n             Some(x) => if(f(&x)) {Some(x)} else {None},\n             None => None\n@@ -170,10 +170,16 @@ impl<T> Option<T> {\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline]\n-    pub fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n+    pub fn map<'a, U>(&'a self, f: &fn(&'a T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n+    /// Maps a `some` value from one type to another by a mutable reference\n+    #[inline]\n+    pub fn map_mut<'a, U>(&'a mut self, f: &fn(&'a mut T) -> U) -> Option<U> {\n+        match *self { Some(ref mut x) => Some(f(x)), None => None }\n+    }\n+\n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline]"}, {"sha": "c26020dd06d57c9fc7e5241b34c38a0999c8bd2e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -92,7 +92,7 @@ pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n-    do vec::as_mut_buf(buf) |b, sz| {\n+    do buf.as_mut_buf |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n                 Some(str::raw::from_buf(b as *u8))\n@@ -122,7 +122,7 @@ pub mod win32 {\n             while !done {\n                 let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n@@ -147,7 +147,7 @@ pub mod win32 {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n-        vec::as_imm_buf(t, |buf, _len| f(buf))\n+        t.as_imm_buf(|buf, _len| f(buf))\n     }\n }\n \n@@ -778,9 +778,9 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 strings\n             }\n         }\n-        do get_list(p).filtered |filename| {\n-            *filename != ~\".\" && *filename != ~\"..\"\n-        }\n+        do get_list(p).consume_iter().filter |filename| {\n+            \".\" != *filename && \"..\" != *filename\n+        }.collect()\n     }\n }\n \n@@ -938,7 +938,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let mut done = false;\n             let mut ok = true;\n             while !done {\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                   let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                           bufsize as size_t,\n                                           istream);\n@@ -1694,7 +1694,7 @@ mod tests {\n           let s = ~\"hello\";\n           let mut buf = s.as_bytes_with_null().to_owned();\n           let len = buf.len();\n-          do vec::as_mut_buf(buf) |b, _len| {\n+          do buf.as_mut_buf |b, _len| {\n               assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n                                       (s.len() + 1u) as size_t, ostream),\n                          len as size_t)"}, {"sha": "db534cca971a58dc2a8ad867fff2de13b029f677", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -47,7 +47,7 @@ pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Great\n pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{Times, FromIter};\n+pub use iter::{Times};\n pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};\n@@ -72,7 +72,7 @@ pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};\n pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n-pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n+pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};"}, {"sha": "aee6f1bd204e3a6070d06d5013ffac9b74943f21", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -406,7 +406,7 @@ pub mod ptr_tests {\n             do str::as_c_str(s1) |p1| {\n                 do str::as_c_str(s2) |p2| {\n                     let v = ~[p0, p1, p2, null()];\n-                    do vec::as_imm_buf(v) |vp, len| {\n+                    do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);\n                         assert_eq!(len, 4u);\n                     }"}, {"sha": "5054763d742b05cf3e1f7a66bc005ebd0660d336", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -157,15 +157,15 @@ impl Rand for f32 {\n     }\n }\n \n-static scale : f64 = (u32::max_value as f64) + 1.0f64;\n+static SCALE : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> f64 {\n         let u1 = rng.next() as f64;\n         let u2 = rng.next() as f64;\n         let u3 = rng.next() as f64;\n \n-        ((u1 / scale + u2) / scale + u3) / scale\n+        ((u1 / SCALE + u2) / SCALE + u3) / SCALE\n     }\n }\n \n@@ -724,7 +724,7 @@ impl IsaacRng {\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n \n-        static midpoint: uint = RAND_SIZE as uint / 2;\n+        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n \n         macro_rules! ind (($x:expr) => {\n             self.mem[($x >> 2) & (RAND_SIZE - 1)]\n@@ -748,9 +748,9 @@ impl IsaacRng {\n             }}\n         );\n \n-        let r = [(0, midpoint), (midpoint, 0)];\n+        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for r.iter().advance |&(mr_offset, m2_offset)| {\n-            for uint::range_step(0, midpoint, 4) |base| {\n+            for uint::range_step(0, MIDPOINT, 4) |base| {\n                 rngstep!(0, 13);\n                 rngstep!(1, -6);\n                 rngstep!(2, 2);\n@@ -830,7 +830,7 @@ pub fn seed() -> ~[u8] {\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n         let mut s = vec::from_elem(n, 0_u8);\n-        do vec::as_mut_buf(s) |p, sz| {\n+        do s.as_mut_buf |p, sz| {\n             rustrt::rand_gen_seed(p, sz as size_t)\n         }\n         s\n@@ -1087,7 +1087,7 @@ mod tests {\n         for 10.times {\n             unsafe {\n                 let seed = super::seed();\n-                let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n+                let rt_rng = do seed.as_imm_buf |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n                 let mut rng = IsaacRng::new_seeded(seed);"}, {"sha": "9075133b08617b12f94674096c4b733bf3e1dcc2", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -248,6 +248,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }"}, {"sha": "dd5075f8e66887a2913c5ff6036ddee219e1eb6e", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -300,6 +300,15 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |b| {\n+            self.visit_ptr_inner(*b, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('~');\n         self.write_mut_qualifier(mtbl);\n         do self.get::<&managed::raw::BoxRepr> |b| {"}, {"sha": "c9bf3b28530391c6d4e3baeff474becbcc6ffb00", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -60,12 +60,6 @@ pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n #[cfg(stage0, not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc_(td: *c_char, size: uintptr_t) -> *c_char {\n-    exchange_malloc(td, size)\n-}\n-\n-#[cfg(stage0)]\n-#[inline]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let td = td as *TyDesc;\n     let size = size as uint;\n@@ -86,13 +80,14 @@ pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[cfg(not(stage0), not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc_(align: u32, size: uintptr_t) -> *c_char {\n-    exchange_malloc(align, size)\n+pub unsafe fn exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n+    malloc_raw(size as uint) as *c_char\n }\n \n-#[cfg(not(stage0))]\n+#[cfg(not(test))]\n+#[lang=\"vector_exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n+pub unsafe fn vector_exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n     let total_size = get_box_size(size as uint, align as uint);\n     malloc_raw(total_size as uint) as *c_char\n }"}, {"sha": "0eaf0dd3ab6495e794f417ed4c78d0dfab56a28c", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -40,6 +40,7 @@ use str::raw::from_c_str;\n use to_str::ToStr;\n use ptr::RawPtr;\n use vec;\n+use vec::ImmutableVector;\n use ptr;\n use str;\n use libc::{c_void, c_int, size_t, malloc, free};\n@@ -312,7 +313,7 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n     unsafe {\n         let data = malloc(v.len() as size_t) as *u8;\n         assert!(data.is_not_null());\n-        do vec::as_imm_buf(v) |b, l| {\n+        do v.as_imm_buf |b, l| {\n             let data = data as *mut u8;\n             ptr::copy_memory(data, b, l)\n         }"}, {"sha": "7e051b62171c85db65644bd5740b08506e35a6cb", "filename": "src/libstd/run.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -24,7 +24,7 @@ use prelude::*;\n use ptr;\n use str;\n use task;\n-use vec;\n+use vec::ImmutableVector;\n \n /**\n  * A value representing a child process.\n@@ -587,7 +587,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     return cmd;\n \n     fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any_(|c| c == ' ' || c == '\\t');\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n         }\n@@ -703,7 +703,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n         argptrs.push(str::as_c_str(*t, |b| b));\n     }\n     argptrs.push(ptr::null());\n-    vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n+    argptrs.as_imm_buf(|buf, _len| cb(buf))\n }\n \n #[cfg(unix)]\n@@ -722,7 +722,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         }\n \n         ptrs.push(ptr::null());\n-        vec::as_imm_buf(ptrs, |p, _len|\n+        ptrs.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }\n@@ -743,7 +743,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n             blk.push_all(kv.as_bytes_with_null_consume());\n         }\n         blk.push(0);\n-        vec::as_imm_buf(blk, |p, _len|\n+        blk.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }"}, {"sha": "8f86216d2407069ef8dc055ea511771915a00d98", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -49,7 +49,7 @@ they contained the following prologue:\n \n \n #[link(name = \"std\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"c70c24a7-5551-4f73-8e37-380b11d80be8\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/libstd\")];\n "}, {"sha": "3ecafa46a9c99fc3d284e87d97ccf02e37c52fb4", "filename": "src/libstd/str.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -13,8 +13,7 @@\n  *\n  * Strings are a packed UTF-8 representation of text, stored as null\n  * terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n- * for efficiency, but UTF-8 unsafe operations should be avoided.  For\n- * some heavy-duty uses, try extra::rope.\n+ * for efficiency, but UTF-8 unsafe operations should be avoided.\n  */\n \n use at_vec;\n@@ -279,7 +278,7 @@ impl CharEq for extern \"Rust\" fn(char) -> bool {\n impl<'self, C: CharEq> CharEq for &'self [C] {\n     #[inline]\n     fn matches(&self, c: char) -> bool {\n-        self.iter().any_(|m| m.matches(c))\n+        self.iter().any(|m| m.matches(c))\n     }\n \n     fn only_ascii(&self) -> bool {\n@@ -602,7 +601,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n         if i + chsize > total { return false; }\n         i += 1u;\n         while chsize > 1u {\n-            if v[i] & 192u8 != tag_cont_u8 { return false; }\n+            if v[i] & 192u8 != TAG_CONT_U8 { return false; }\n             i += 1u;\n             chsize -= 1u;\n         }\n@@ -743,18 +742,18 @@ pub struct CharRange {\n }\n \n // UTF-8 tags and ranges\n-static tag_cont_u8: u8 = 128u8;\n-static tag_cont: uint = 128u;\n-static max_one_b: uint = 128u;\n-static tag_two_b: uint = 192u;\n-static max_two_b: uint = 2048u;\n-static tag_three_b: uint = 224u;\n-static max_three_b: uint = 65536u;\n-static tag_four_b: uint = 240u;\n-static max_four_b: uint = 2097152u;\n-static tag_five_b: uint = 248u;\n-static max_five_b: uint = 67108864u;\n-static tag_six_b: uint = 252u;\n+static TAG_CONT_U8: u8 = 128u8;\n+static TAG_CONT: uint = 128u;\n+static MAX_ONE_B: uint = 128u;\n+static TAG_TWO_B: uint = 192u;\n+static MAX_TWO_B: uint = 2048u;\n+static TAG_THREE_B: uint = 224u;\n+static MAX_THREE_B: uint = 65536u;\n+static TAG_FOUR_B: uint = 240u;\n+static MAX_FOUR_B: uint = 2097152u;\n+static TAG_FIVE_B: uint = 248u;\n+static MAX_FIVE_B: uint = 67108864u;\n+static TAG_SIX_B: uint = 252u;\n \n /**\n  * A dummy trait to hold all the utility methods that we implement on strings.\n@@ -826,6 +825,7 @@ pub mod raw {\n     use str::raw;\n     use str::{as_buf, is_utf8};\n     use vec;\n+    use vec::MutableVector;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n@@ -841,7 +841,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n-        vec::as_mut_buf(v, |vbuf, _len| {\n+        v.as_mut_buf(|vbuf, _len| {\n             ptr::copy_memory(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(&mut v, len);\n@@ -863,7 +863,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_bytes(v: &[u8]) -> ~str {\n-        do vec::as_imm_buf(v) |buf, len| {\n+        do v.as_imm_buf |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n@@ -917,7 +917,7 @@ pub mod raw {\n             assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n-            do vec::as_imm_buf(v) |vbuf, _vlen| {\n+            do v.as_imm_buf |vbuf, _vlen| {\n                 let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n                 let src = ptr::offset(sbuf, begin);\n                 ptr::copy_memory(vbuf, src, end - begin);\n@@ -1728,7 +1728,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut i = i + 1u;\n         while i < end {\n             let byte = self[i];\n-            assert_eq!(byte & 192u8, tag_cont_u8);\n+            assert_eq!(byte & 192u8, TAG_CONT_U8);\n             val <<= 6u;\n             val += (byte & 63u8) as uint;\n             i += 1u;\n@@ -1755,7 +1755,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut prev = start;\n \n         // while there is a previous byte == 10......\n-        while prev > 0u && self[prev - 1u] & 192u8 == tag_cont_u8 {\n+        while prev > 0u && self[prev - 1u] & 192u8 == TAG_CONT_U8 {\n             prev -= 1u;\n         }\n \n@@ -2071,11 +2071,11 @@ impl OwnedStr for ~str {\n     fn push_char(&mut self, c: char) {\n         unsafe {\n             let code = c as uint;\n-            let nb = if code < max_one_b { 1u }\n-            else if code < max_two_b { 2u }\n-            else if code < max_three_b { 3u }\n-            else if code < max_four_b { 4u }\n-            else if code < max_five_b { 5u }\n+            let nb = if code < MAX_ONE_B { 1u }\n+            else if code < MAX_TWO_B { 2u }\n+            else if code < MAX_THREE_B { 3u }\n+            else if code < MAX_FOUR_B { 4u }\n+            else if code < MAX_FIVE_B { 5u }\n             else { 6u };\n             let len = self.len();\n             let new_len = len + nb;\n@@ -2088,34 +2088,34 @@ impl OwnedStr for ~str {\n                         *ptr::mut_offset(buf, off) = code as u8;\n                     }\n                     2u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 6u & 31u | tag_two_b) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off) = (code >> 6u & 31u | TAG_TWO_B) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     3u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 12u & 15u | tag_three_b) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off) = (code >> 12u & 15u | TAG_THREE_B) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     4u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 18u & 7u | tag_four_b) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 3u) = (code & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off) = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     5u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 24u & 3u | tag_five_b) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 18u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code >> 12u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 3u) = (code >> 6u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 4u) = (code & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off) = (code >> 24u & 3u | TAG_FIVE_B) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 18u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 12u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 4u) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     6u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 30u & 1u | tag_six_b) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 24u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code >> 18u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 3u) = (code >> 12u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 4u) = (code >> 6u & 63u | tag_cont) as u8;\n-                        *ptr::mut_offset(buf, off + 5u) = (code & 63u | tag_cont) as u8;\n+                        *ptr::mut_offset(buf, off) = (code >> 30u & 1u | TAG_SIX_B) as u8;\n+                        *ptr::mut_offset(buf, off + 1u) = (code >> 24u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2u) = (code >> 18u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 3u) = (code >> 12u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 4u) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 5u) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     _ => {}\n                 }"}, {"sha": "8dd96df45453927da947241d00095e5c7959a71b", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -142,7 +142,7 @@ unsafe fn local_data_lookup<T: 'static>(\n     -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).iter().position_(|entry|\n+    let map_pos = (*map).iter().position(|entry|\n         match *entry {\n             Some((k,_,_)) => k == key_value,\n             None => false\n@@ -215,7 +215,7 @@ pub unsafe fn local_set<T: 'static>(\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).iter().position_(|x| x.is_none()) {\n+            match (*map).iter().position(|x| x.is_none()) {\n                 Some(empty_index) => { map[empty_index] = new_entry; }\n                 None => { map.push(new_entry); }\n             }"}, {"sha": "460c0a847c8bdb300b09f44cc5d2f580842f8fb5", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,6 +11,7 @@\n // The following code was generated by \"src/etc/unicode.py\"\n \n #[allow(missing_doc)];\n+#[allow(non_uppercase_statics)];\n \n pub mod general_category {\n "}, {"sha": "b1df5175c920629ca1e83b11ac8cc22dd1632a80", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -472,6 +472,7 @@ pub mod ct {\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n #[doc(hidden)]\n+#[allow(non_uppercase_statics)]\n pub mod rt {\n     use float;\n     use str;"}, {"sha": "ce5ccf2401dbd00ea6e64ad1e9ca14f6ae8f95ce", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -91,6 +91,7 @@ pub trait TyVisitor {\n \n     fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n \n@@ -417,3 +418,17 @@ pub extern \"rust-intrinsic\" {\n     pub fn bswap32(x: i32) -> i32;\n     pub fn bswap64(x: i64) -> i64;\n }\n+\n+#[cfg(target_endian = \"little\")] pub fn to_le16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"big\")]    pub fn to_le16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] pub fn to_le32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"big\")]    pub fn to_le32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] pub fn to_le64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"big\")]    pub fn to_le64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+\n+#[cfg(target_endian = \"little\")] pub fn to_be16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")]    pub fn to_be16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"little\")] pub fn to_be32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")]    pub fn to_be32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"little\")] pub fn to_be64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")]    pub fn to_be64(x: i64) -> i64 { x }"}, {"sha": "2c1e913511eff65bb18a0fae15bfeba80815556e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 660, "deletions": 914, "changes": 1574, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -16,14 +16,12 @@ use cast::transmute;\n use cast;\n use container::{Container, Mutable};\n use cmp;\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n-use iter::FromIter;\n use kinds::Copy;\n use libc::c_void;\n use num::Zero;\n-use ops::Add;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -34,9 +32,9 @@ use sys::size_of;\n use uint;\n use unstable::intrinsics;\n #[cfg(stage0)]\n-use intrinsic::{get_tydesc};\n+use intrinsic::{get_tydesc, TyDesc};\n #[cfg(not(stage0))]\n-use unstable::intrinsics::{get_tydesc, contains_managed};\n+use unstable::intrinsics::{get_tydesc, contains_managed, TyDesc};\n use vec;\n use util;\n \n@@ -56,7 +54,7 @@ pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i: uint = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n@@ -81,7 +79,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), copy t);\n@@ -158,165 +156,69 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n     build_sized(size.get_or_default(4), builder)\n }\n \n-// Accessors\n-\n-/// Copies\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct VecSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n+}\n \n-/// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n+impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-    let mut start = 0u;\n-    let mut result = ~[];\n-    while start < ln {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                start += i + 1u;\n-            }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n         }\n-    }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n-}\n-\n-/**\n- * Split the vector `v` by applying each element against the predicate `f` up\n- * to `n` times.\n- */\n-pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n \n-    let mut start = 0u;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while start < ln && count > 0u {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                // Make sure to skip the separator.\n-                start += i + 1u;\n-                count -= 1u;\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                self.n -= 1;\n+                ret\n             }\n         }\n     }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n }\n \n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f`.\n- */\n-pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0) { return ~[] }\n-\n-    let mut end = ln;\n-    let mut result = ~[];\n-    while end > 0 {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1, end).to_owned());\n-                end = i;\n-            }\n-        }\n-    }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, from back to front.\n+pub struct VecRSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n }\n \n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f` up to `n times.\n- */\n-pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n+impl<'self, T> Iterator<&'self [T]> for VecRSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-    let mut end = ln;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while end > 0u && count > 0u {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1u, end).to_owned());\n-                // Make sure to skip the separator.\n-                end = i;\n-                count -= 1u;\n-            }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n         }\n-    }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n-}\n \n-/// Consumes all elements, in a vector, moving them out into the / closure\n-/// provided. The vector is traversed from the start to the end.\n-///\n-/// This method does not impose any requirements on the type of the vector being\n-/// consumed, but it prevents any usage of the vector after this function is\n-/// called.\n-///\n-/// # Examples\n-///\n-/// ~~~ {.rust}\n-/// let v = ~[~\"a\", ~\"b\"];\n-/// do vec::consume(v) |i, s| {\n-///   // s has type ~str, not &~str\n-///   io::println(s + fmt!(\" %d\", i));\n-/// }\n-/// ~~~\n-pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n-    unsafe {\n-        do as_mut_buf(v) |p, ln| {\n-            for uint::range(0, ln) |i| {\n-                // NB: This unsafe operation counts on init writing 0s to the\n-                // holes we create in the vector. That ensures that, if the\n-                // iterator fails then we won't try to clean up the consumed\n-                // elements during unwinding\n-                let x = intrinsics::init();\n-                let p = ptr::mut_offset(p, i);\n-                f(i, ptr::replace_ptr(p, x));\n+        match self.v.rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n             }\n-        }\n-\n-        raw::set_len(&mut v, 0);\n-    }\n-}\n-\n-/// Consumes all elements, in a vector, moving them out into the / closure\n-/// provided. The vectors is traversed in reverse order (from end to start).\n-///\n-/// This method does not impose any requirements on the type of the vector being\n-/// consumed, but it prevents any usage of the vector after this function is\n-/// called.\n-pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n-    unsafe {\n-        do as_mut_buf(v) |p, ln| {\n-            let mut i = ln;\n-            while i > 0 {\n-                i -= 1;\n-\n-                // NB: This unsafe operation counts on init writing 0s to the\n-                // holes we create in the vector. That ensures that, if the\n-                // iterator fails then we won't try to clean up the consumed\n-                // elements during unwinding\n-                let x = intrinsics::init();\n-                let p = ptr::mut_offset(p, i);\n-                f(i, ptr::replace_ptr(p, x));\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                self.n -= 1;\n+                ret\n             }\n         }\n-\n-        raw::set_len(&mut v, 0);\n     }\n }\n \n@@ -342,20 +244,6 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n // Functional utilities\n \n-/// Consumes a vector, mapping it into a different vector. This function takes\n-/// ownership of the supplied vector `v`, moving each element into the closure\n-/// provided to generate a new element. The vector of new elements is then\n-/// returned.\n-///\n-/// The original vector `v` cannot be used after this function call (it is moved\n-/// inside), but there are no restrictions on the type of the vector.\n-pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n-    let mut result = ~[];\n-    do consume(v) |_i, x| {\n-        result.push(f(x));\n-    }\n-    result\n-}\n /**\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n@@ -366,79 +254,6 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     result\n }\n \n-pub fn filter_map<T, U>(\n-    v: ~[T],\n-    f: &fn(t: T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Apply a function to each element of a vector and return the results.\n-     * Consumes the input vector.  If function `f` returns `None` then that\n-     * element is excluded from the resulting vector.\n-     */\n-\n-    let mut result = ~[];\n-    do consume(v) |_, elem| {\n-        match f(elem) {\n-            None => {}\n-            Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-pub fn filter_mapped<T, U: Copy>(\n-    v: &[T],\n-    f: &fn(t: &T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Like `filter_map()`, but operates on a borrowed slice\n-     * and does not consume the input.\n-     */\n-\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        match f(elem) {\n-          None => {/* no-op */ }\n-          Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    // FIXME (#4355 maybe): using v.consume here crashes\n-    // do v.consume |_, elem| {\n-    do consume(v) |_, elem| {\n-        if f(&elem) { result.push(elem); }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        if f(elem) { result.push(copy *elem); }\n-    }\n-    result\n-}\n-\n /// Flattens a vector of vectors of T into a single vector of T.\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n \n@@ -524,7 +339,7 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    do consume(v) |_i, p| {\n+    for v.consume_iter().advance |p| {\n         let (t, u) = p;\n         ts.push(t);\n         us.push(u);\n@@ -566,16 +381,6 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     w\n }\n \n-/// Returns a vector with the order of elements reversed\n-pub fn reversed<T:Copy>(v: &[T]) -> ~[T] {\n-    let mut rs: ~[T] = ~[];\n-    let mut i = v.len();\n-    if i == 0 { return (rs); } else { i -= 1; }\n-    while i != 0 { rs.push(copy v[i]); i -= 1; }\n-    rs.push(copy v[0]);\n-    rs\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -630,265 +435,236 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n     }\n }\n \n-/**\n- * Iterate over all contiguous windows of length `n` of the vector `v`.\n- *\n- * # Example\n- *\n- * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`, `[3,4]`)\n- *\n- * ~~~ {.rust}\n- * for windowed(2, &[1,2,3,4]) |v| {\n- *     io::println(fmt!(\"%?\", v));\n- * }\n- * ~~~\n- *\n- */\n-pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n-    assert!(1u <= n);\n-    if n > v.len() { return true; }\n-    for uint::range(0, v.len() - n + 1) |i| {\n-        if !it(v.slice(i, i + n)) { return false; }\n-    }\n-    return true;\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+pub struct VecWindowIter<'self, T> {\n+    priv v: &'self [T],\n+    priv size: uint\n }\n \n-/**\n- * Work with the buffer of a vector.\n- *\n- * Allows for unsafe manipulation of vector contents, which is useful for\n- * foreign interop.\n- */\n-#[inline]\n-pub fn as_imm_buf<T,U>(s: &[T],\n-                       /* NB---this CANNOT be const, see below */\n-                       f: &fn(*T, uint) -> U) -> U {\n-\n-    // NB---Do not change the type of s to `&const [T]`.  This is\n-    // unsound.  The reason is that we are going to create immutable pointers\n-    // into `s` and pass them to `f()`, but in fact they are potentially\n-    // pointing at *mutable memory*.  Use `as_const_buf` or `as_mut_buf`\n-    // instead!\n-\n-    unsafe {\n-        let v : *(*T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n+impl<'self, T> Iterator<&'self [T]> for VecWindowIter<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n     }\n }\n \n-/// Similar to `as_imm_buf` but passing a `*mut T`\n-#[inline]\n-pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*mut T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+pub struct VecChunkIter<'self, T> {\n+    priv v: &'self [T],\n+    priv size: uint\n+}\n+\n+impl<'self, T> Iterator<&'self [T]> for VecChunkIter<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.size == 0 {\n+            None\n+        } else if self.size >= self.v.len() {\n+            // finished\n+            self.size = 0;\n+            Some(self.v)\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(self.size, self.v.len());\n+            ret\n+        }\n     }\n }\n \n // Equality\n \n-/// Tests whether two slices are equal to one another. This is only true if both\n-/// slices are of the same length, and each of the corresponding elements return\n-/// true when queried via the `eq` function.\n-fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n+#[cfg(not(test))]\n+pub mod traits {\n+    use super::Vector;\n+    use kinds::Copy;\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n+    use ops::Add;\n \n-    let mut i = 0;\n-    while i < a_len {\n-        if a[i] != b[i] { return false; }\n-        i += 1;\n+    impl<'self,T:Eq> Eq for &'self [T] {\n+        fn eq(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| *s == *o)\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n \n-/// Similar to the `vec::eq` function, but this is defined for types which\n-/// implement `TotalEq` as opposed to types which implement `Eq`. Equality\n-/// comparisons are done via the `equals` function instead of `eq`.\n-fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    if a_len != b_len { return false; }\n-\n-    let mut i = 0;\n-    while i < a_len {\n-        if !a[i].equals(&b[i]) { return false; }\n-        i += 1;\n+    impl<T:Eq> Eq for ~[T] {\n+        #[inline]\n+        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n-    true\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:Eq> Eq for &'self [T] {\n-    #[inline]\n-    fn eq(&self, other: & &'self [T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Eq> Eq for ~[T] {\n-    #[inline]\n-    fn eq(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<T:Eq> Eq for @[T] {\n-    #[inline]\n-    fn eq(&self, other: &@[T]) -> bool { eq(*self, *other) }\n-    #[inline]\n-    fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n-}\n+    impl<T:Eq> Eq for @[T] {\n+        #[inline]\n+        fn eq(&self, other: &@[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-    #[inline]\n-    fn equals(&self, other: & &'self [T]) -> bool { equals(*self, *other) }\n-}\n+    impl<'self,T:TotalEq> TotalEq for &'self [T] {\n+        fn equals(&self, other: & &'self [T]) -> bool {\n+            self.len() == other.len() &&\n+                self.iter().zip(other.iter()).all(|(s,o)| s.equals(o))\n+        }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for ~[T] {\n-    #[inline]\n-    fn equals(&self, other: &~[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for ~[T] {\n+        #[inline]\n+        fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T:TotalEq> TotalEq for @[T] {\n-    #[inline]\n-    fn equals(&self, other: &@[T]) -> bool { equals(*self, *other) }\n-}\n+    impl<T:TotalEq> TotalEq for @[T] {\n+        #[inline]\n+        fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<'self,T:Eq> Equiv<~[T]> for &'self [T] {\n-    #[inline]\n-    fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n-}\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for &'self [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-// Lexicographical comparison\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n-    let low = uint::min(a.len(), b.len());\n+    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n \n-    for uint::range(0, low) |idx| {\n-        match a[idx].cmp(&b[idx]) {\n-          Greater => return Greater,\n-          Less => return Less,\n-          Equal => ()\n+    impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n+        fn cmp(&self, other: & &'self [T]) -> Ordering {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                match s.cmp(o) {\n+                    Equal => {},\n+                    non_eq => { return non_eq; }\n+                }\n+            }\n+            self.len().cmp(&other.len())\n         }\n     }\n \n-    a.len().cmp(&b.len())\n-}\n-\n-#[cfg(not(test))]\n-impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-    #[inline]\n-    fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for ~[T] {\n+        #[inline]\n+        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for ~[T] {\n-    #[inline]\n-    fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<T: TotalOrd> TotalOrd for @[T] {\n+        #[inline]\n+        fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for @[T] {\n-    #[inline]\n-    fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n-}\n+    impl<'self,T:Ord> Ord for &'self [T] {\n+        fn lt(&self, other: & &'self [T]) -> bool {\n+            for self.iter().zip(other.iter()).advance |(s,o)| {\n+                if *s < *o { return true; }\n+                if *s > *o { return false; }\n+            }\n+            self.len() < other.len()\n+        }\n+        #[inline]\n+        fn le(&self, other: & &'self [T]) -> bool { !(*other < *self) }\n+        #[inline]\n+        fn ge(&self, other: & &'self [T]) -> bool { !(*self < *other) }\n+        #[inline]\n+        fn gt(&self, other: & &'self [T]) -> bool { *other < *self }\n+    }\n \n-fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let end = uint::min(a_len, b_len);\n+    impl<T:Ord> Ord for ~[T] {\n+        #[inline]\n+        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n+    }\n \n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (&a[i], &b[i]);\n-        if *c_a < *c_b { return true; }\n-        if *c_a > *c_b { return false; }\n-        i += 1;\n+    impl<T:Ord> Ord for @[T] {\n+        #[inline]\n+        fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &@[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &@[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    a_len < b_len\n+    impl<'self,T:Copy, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n+    impl<T:Copy, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+        #[inline]\n+        fn add(&self, rhs: &V) -> ~[T] {\n+            let mut res = self.to_owned();\n+            res.push_all(rhs.as_slice());\n+            res\n+        }\n+    }\n }\n \n-fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+#[cfg(test)]\n+pub mod traits {}\n \n-#[cfg(not(test))]\n-impl<'self,T:Ord> Ord for &'self [T] {\n-    #[inline]\n-    fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for ~[T] {\n-    #[inline]\n-    fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n+impl<'self,T> Vector<T> for &'self [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for @[T] {\n-    #[inline]\n-    fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n-    #[inline]\n-    fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n-    #[inline]\n-    fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n-    #[inline]\n-    fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n+impl<T> Vector<T> for ~[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n-\n-#[cfg(not(test))]\n-impl<'self,T:Copy> Add<&'self [T], ~[T]> for ~[T] {\n-    #[inline]\n-    fn add(&self, rhs: & &'self [T]) -> ~[T] {\n-        append(copy *self, (*rhs))\n-    }\n+impl<T> Vector<T> for @[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n impl<'self, T> Container for &'self [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n@@ -915,6 +691,14 @@ pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n     fn rev_iter(self) -> VecRevIterator<'self, T>;\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+\n+    fn window_iter(self, size: uint) -> VecWindowIter<'self, T>;\n+    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T>;\n+\n     fn head(&self) -> &'self T;\n     fn head_opt(&self) -> Option<&'self T>;\n     fn tail(&self) -> &'self [T];\n@@ -925,12 +709,13 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n     fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n \n     fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n+\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U;\n }\n \n /// Extension methods for vectors\n@@ -940,7 +725,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n     assert!(start <= end);\n     assert!(end <= self.len());\n-        do as_imm_buf(*self) |p, _len| {\n+        do self.as_imm_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -966,6 +751,101 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         }\n     }\n \n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.\n+    #[inline]\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        self.splitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.\n+    #[inline]\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        VecSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`. This starts at the\n+    /// end of the vector and works backwards.\n+    #[inline]\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        self.rsplitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.\n+    #[inline]\n+    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        VecRSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ~~~ {.rust}\n+     * let v = &[1,2,3,4];\n+     * for v.window_iter().advance |win| {\n+     *     io::println(fmt!(\"%?\", win));\n+     * }\n+     * ~~~\n+     *\n+     */\n+    fn window_iter(self, size: uint) -> VecWindowIter<'self, T> {\n+        assert!(size != 0);\n+        VecWindowIter { v: self, size: size }\n+    }\n+\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ~~~ {.rust}\n+     * let v = &[1,2,3,4,5];\n+     * for v.chunk_iter().advance |win| {\n+     *     io::println(fmt!(\"%?\", win));\n+     * }\n+     * ~~~\n+     *\n+     */\n+    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T> {\n+        assert!(size != 0);\n+        VecChunkIter { v: self, size: size }\n+    }\n+\n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n     fn head(&self) -> &'self T {\n@@ -1035,17 +915,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n-    /**\n-     * Apply a function to each element of a vector and return the results\n-     *\n-     * If function `f` returns `none` then that element is excluded from\n-     * the resulting vector.\n-     */\n-    #[inline]\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_mapped(*self, f)\n-    }\n-\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[inline]\n@@ -1089,20 +958,42 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n         self.iter().transform(f).collect()\n     }\n-}\n-\n-#[allow(missing_doc)]\n-pub trait ImmutableEqVector<T:Eq> {\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-    fn contains(&self, x: &T) -> bool;\n-}\n+\n+    /**\n+     * Work with the buffer of a vector.\n+     *\n+     * Allows for unsafe manipulation of vector contents, which is useful for\n+     * foreign interop.\n+     */\n+    #[inline]\n+    fn as_imm_buf<U>(&self,\n+                     /* NB---this CANNOT be const, see below */\n+                     f: &fn(*T, uint) -> U) -> U {\n+        // NB---Do not change the type of s to `&const [T]`.  This is\n+        // unsound.  The reason is that we are going to create immutable pointers\n+        // into `s` and pass them to `f()`, but in fact they are potentially\n+        // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n+\n+        unsafe {\n+            let v : *(*T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n+}\n+\n+#[allow(missing_doc)]\n+pub trait ImmutableEqVector<T:Eq> {\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn contains(&self, x: &T) -> bool;\n+}\n \n impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the first index containing a matching value\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n-        self.iter().position_(|y| *x == *y)\n+        self.iter().position(|y| *x == *y)\n     }\n \n     /// Find the last index containing a matching value\n@@ -1136,25 +1027,12 @@ impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n-    fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n \n /// Extension methods for vectors\n impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n-    /**\n-     * Construct a new vector from the elements of a vector for which some\n-     * predicate holds.\n-     *\n-     * Apply function `f` to each element of `v` and return a vector\n-     * containing only those elements for which `f` returned true.\n-     */\n-    #[inline]\n-    fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n-        filtered(*self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1184,6 +1062,9 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n+    fn consume_iter(self) -> VecConsumeIterator<T>;\n+    fn consume_rev_iter(self) -> VecConsumeRevIterator<T>;\n+\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n@@ -1193,21 +1074,46 @@ pub trait OwnedVector<T> {\n \n     fn push_all_move(&mut self, rhs: ~[T]);\n     fn pop(&mut self) -> T;\n+    fn pop_opt(&mut self) -> Option<T>;\n     fn shift(&mut self) -> T;\n+    fn shift_opt(&mut self) -> Option<T>;\n     fn unshift(&mut self, x: T);\n     fn insert(&mut self, i: uint, x:T);\n     fn remove(&mut self, i: uint) -> T;\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n     fn retain(&mut self, f: &fn(t: &T) -> bool);\n-    fn consume(self, f: &fn(uint, v: T));\n-    fn consume_reverse(self, f: &fn(uint, v: T));\n-    fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// Note that this performs O(n) swaps, and so `consume_rev_iter`\n+    /// (which just calls `pop` repeatedly) is more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v = ~[~\"a\", ~\"b\"];\n+    /// for v.consume_iter().advance |s| {\n+    ///   // s has type ~str, not &~str\n+    ///   println(s);\n+    /// }\n+    /// ~~~\n+    fn consume_iter(self) -> VecConsumeIterator<T> {\n+        VecConsumeIterator { v: self, idx: 0 }\n+    }\n+    /// Creates a consuming iterator that moves out of the vector in\n+    /// reverse order. Also see `consume_iter`, however note that this\n+    /// is more efficient.\n+    fn consume_rev_iter(self) -> VecConsumeRevIterator<T> {\n+        VecConsumeRevIterator { v: self }\n+    }\n+\n     /**\n      * Reserves capacity for exactly `n` elements in the given vector.\n      *\n@@ -1351,7 +1257,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n         unsafe {\n-            do as_mut_buf(rhs) |p, len| {\n+            do rhs.as_mut_buf |p, len| {\n                 for uint::range(0, len) |i| {\n                     let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n                                              intrinsics::uninit());\n@@ -1362,35 +1268,49 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    /// Remove the last element from a vector and return it\n-    fn pop(&mut self) -> T {\n-        let ln = self.len();\n-        if ln == 0 {\n-            fail!(\"sorry, cannot pop an empty vector\")\n-        }\n-        let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n-        unsafe {\n-            let val = ptr::replace_ptr(valptr, intrinsics::init());\n-            raw::set_len(self, ln - 1u);\n-            val\n+    /// Remove the last element from a vector and return it, or `None` if it is empty\n+    fn pop_opt(&mut self) -> Option<T> {\n+        match self.len() {\n+            0  => None,\n+            ln => {\n+                let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n+                unsafe {\n+                    let val = ptr::replace_ptr(valptr, intrinsics::init());\n+                    raw::set_len(self, ln - 1u);\n+                    Some(val)\n+                }\n+            }\n         }\n     }\n \n+\n+    /// Remove the last element from a vector and return it, failing if it is empty\n+    #[inline]\n+    fn pop(&mut self) -> T {\n+        self.pop_opt().expect(\"pop: empty vector\")\n+    }\n+\n     /// Removes the first element from a vector and return it\n+    #[inline]\n     fn shift(&mut self) -> T {\n-        unsafe {\n-            assert!(!self.is_empty());\n-\n-            if self.len() == 1 { return self.pop() }\n+        self.shift_opt().expect(\"shift: empty vector\")\n+    }\n \n-            if self.len() == 2 {\n-                let last = self.pop();\n-                let first = self.pop();\n-                self.push(last);\n-                return first;\n-            }\n+    /// Removes the first element from a vector and return it, or `None` if it is empty\n+    fn shift_opt(&mut self) -> Option<T> {\n+        unsafe {\n+            let ln = match self.len() {\n+                0 => return None,\n+                1 => return self.pop_opt(),\n+                2 =>  {\n+                    let last = self.pop();\n+                    let first = self.pop_opt();\n+                    self.push(last);\n+                    return first;\n+                }\n+                x => x\n+            };\n \n-            let ln = self.len();\n             let next_ln = self.len() - 1;\n \n             // Save the last element. We're going to overwrite its position\n@@ -1426,7 +1346,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let vp = raw::to_mut_ptr(*self);\n             let vp = ptr::mut_offset(vp, next_ln - 1);\n \n-            ptr::replace_ptr(vp, work_elt)\n+            Some(ptr::replace_ptr(vp, work_elt))\n         }\n     }\n \n@@ -1483,7 +1403,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Shorten a vector, dropping excess elements.\n     fn truncate(&mut self, newlen: uint) {\n-        do as_mut_buf(*self) |p, oldlen| {\n+        do self.as_mut_buf |p, oldlen| {\n             assert!(newlen <= oldlen);\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n@@ -1516,21 +1436,6 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    #[inline]\n-    fn consume(self, f: &fn(uint, v: T)) {\n-        consume(self, f)\n-    }\n-\n-    #[inline]\n-    fn consume_reverse(self, f: &fn(uint, v: T)) {\n-        consume_reverse(self, f)\n-    }\n-\n-    #[inline]\n-    fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n-        filter(self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1540,7 +1445,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        do self.consume |_, elt| {\n+        for self.consume_iter().advance |elt| {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -1656,7 +1561,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             if self.len() == 0 { return; }\n             let mut last_written = 0;\n             let mut next_to_read = 1;\n-            do as_mut_buf(*self) |p, ln| {\n+            do self.as_mut_buf |p, ln| {\n                 // last_written < next_to_read <= ln\n                 while next_to_read < ln {\n                     // last_written < next_to_read < ln\n@@ -1710,6 +1615,8 @@ pub trait MutableVector<'self, T> {\n \n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n+\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -1718,7 +1625,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        do as_mut_buf(self) |p, _len| {\n+        do self.as_mut_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::mut_offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -1791,6 +1698,17 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     unsafe fn unsafe_set(&self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n+\n+    /// Similar to `as_imm_buf` but passing a `*mut T`\n+    #[inline]\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U {\n+        unsafe {\n+            let v : *(*mut T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n+\n }\n \n /// Trait for ~[T] where T is Cloneable\n@@ -1840,7 +1758,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_imm_buf, as_mut_buf, with_capacity};\n+    use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -1928,7 +1846,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n-        as_imm_buf(v, |p, _len| copy *ptr::offset(p, i))\n+        v.as_imm_buf(|p, _len| copy *ptr::offset(p, i))\n     }\n \n     /**\n@@ -1939,7 +1857,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let box2 = util::replace(&mut box, None);\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                       box2.unwrap());\n@@ -1959,7 +1877,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n-        as_mut_buf(dst, |p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n+        dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n         dst\n     }\n \n@@ -1975,8 +1893,8 @@ pub mod raw {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n-        do as_mut_buf(dst) |p_dst, _len_dst| {\n-            do as_imm_buf(src) |p_src, _len_src| {\n+        do dst.as_mut_buf |p_dst, _len_dst| {\n+            do src.as_imm_buf |p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n@@ -2000,7 +1918,7 @@ pub mod bytes {\n     impl<'self> MutableByteVector for &'self mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            do vec::as_mut_buf(self) |p, len| {\n+            do self.as_mut_buf |p, len| {\n                 unsafe { ptr::set_memory(p, value, len) };\n             }\n         }\n@@ -2107,16 +2025,21 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n-                let exact = Some(((self.end as uint) - (self.ptr as uint)) / size_of::<$elem>());\n-                (exact, exact)\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                let diff = if $step > 0 {\n+                    (self.end as uint) - (self.ptr as uint)\n+                } else {\n+                    (self.ptr as uint) - (self.end as uint)\n+                };\n+                let exact = diff / size_of::<$elem>();\n+                (exact, Some(exact))\n             }\n         }\n     }\n }\n \n //iterator!{struct VecIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector\n+/// An iterator for iterating over a vector.\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n@@ -2125,7 +2048,7 @@ pub struct VecIterator<'self, T> {\n iterator!{impl VecIterator -> &'self T, 1}\n \n //iterator!{struct VecRevIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector in reverse\n+/// An iterator for iterating over a vector in reverse.\n pub struct VecRevIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n@@ -2134,7 +2057,7 @@ pub struct VecRevIterator<'self, T> {\n iterator!{impl VecRevIterator -> &'self T, -1}\n \n //iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector\n+/// An iterator for mutating the elements of a vector.\n pub struct VecMutIterator<'self, T> {\n     priv ptr: *mut T,\n     priv end: *mut T,\n@@ -2143,20 +2066,48 @@ pub struct VecMutIterator<'self, T> {\n iterator!{impl VecMutIterator -> &'self mut T, 1}\n \n //iterator!{struct VecMutRevIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector in reverse\n+/// An iterator for mutating the elements of a vector in reverse.\n pub struct VecMutRevIterator<'self, T> {\n     priv ptr: *mut T,\n     priv end: *mut T,\n     priv lifetime: &'self mut T // FIXME: #5922\n }\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        for iter |x| { v.push(x) }\n-        v\n+/// An iterator that moves out of a vector.\n+pub struct VecConsumeIterator<T> {\n+    priv v: ~[T],\n+    priv idx: uint,\n+}\n+\n+impl<T> Iterator<T> for VecConsumeIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        // this is peculiar, but is required for safety with respect\n+        // to dtors. It traverses the first half of the vec, and\n+        // removes them by swapping them with the last element (and\n+        // popping), which results in the second half in reverse\n+        // order, and so these can just be pop'd off. That is,\n+        //\n+        // [1,2,3,4,5] => 1, [5,2,3,4] => 2, [5,4,3] => 3, [5,4] => 4,\n+        // [5] -> 5, []\n+        let l = self.v.len();\n+        if self.idx < l {\n+            self.v.swap(self.idx, l - 1);\n+            self.idx += 1;\n+        }\n+\n+        self.v.pop_opt()\n+    }\n+}\n+\n+/// An iterator that moves out of a vector in reverse order.\n+pub struct VecConsumeRevIterator<T> {\n+    priv v: ~[T]\n+}\n+\n+impl<T> Iterator<T> for VecConsumeRevIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        self.v.pop_opt()\n     }\n }\n \n@@ -2176,7 +2127,7 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n-        let mut xs = with_capacity(lower.get_or_zero());\n+        let mut xs = with_capacity(lower);\n         for iterator.advance |x| {\n             xs.push(x);\n         }\n@@ -2459,6 +2410,17 @@ mod tests {\n     }\n \n     #[test]\n+    fn test_pop_opt() {\n+        let mut v = ~[5];\n+        let e = v.pop_opt();\n+        assert_eq!(v.len(), 0);\n+        assert_eq!(e, Some(5));\n+        let f = v.pop_opt();\n+        assert_eq!(f, None);\n+        let g = v.pop_opt();\n+        assert_eq!(g, None);\n+    }\n+\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n@@ -2626,87 +2588,6 @@ mod tests {\n         assert_eq!(w[4], 25u);\n     }\n \n-    #[test]\n-    fn test_filter_mapped() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: &int) -> Option<int> {\n-            if *i % 2 == 0 {\n-                Some::<int>(*i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_mapped(all_even, halve) ==\n-                     all_even.map(halve_for_sure));\n-        assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n-        assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n-        assert_eq!(filter_mapped(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter_map() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: int) -> Option<int> {\n-            if i % 2 == 0 {\n-                Some::<int>(i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_even0: ~[int] = copy all_even;\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_map(all_even, halve) ==\n-                     all_even0.map(halve_for_sure));\n-        assert_eq!(filter_map(all_odd1, halve), ~[]);\n-        assert_eq!(filter_map(all_odd2, halve), ~[]);\n-        assert_eq!(filter_map(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter() {\n-        assert_eq!(filter(~[1u, 2u, 3u], is_odd), ~[1u, 3u]);\n-        assert_eq!(filter(~[1u, 2u, 4u, 8u, 16u], is_three), ~[]);\n-    }\n-\n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n@@ -2821,75 +2702,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn reverse_and_reversed() {\n+    fn test_reverse() {\n         let mut v: ~[int] = ~[10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n-        let v2 = reversed::<int>([10, 20]);\n-        assert_eq!(v2[0], 20);\n-        assert_eq!(v2[1], 10);\n-        v[0] = 30;\n-        assert_eq!(v2[0], 20);\n-        // Make sure they work with 0-length vectors too.\n-\n-        let v4 = reversed::<int>([]);\n-        assert_eq!(v4, ~[]);\n+\n         let mut v3: ~[int] = ~[];\n         v3.reverse();\n-    }\n-\n-    #[test]\n-    fn reversed_mut() {\n-        let v2 = reversed::<int>([10, 20]);\n-        assert_eq!(v2[0], 20);\n-        assert_eq!(v2[1], 10);\n-    }\n-\n-    #[test]\n-    fn test_split() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(split([], f), ~[]);\n-        assert_eq!(split([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(split([3, 1, 2], f), ~[~[], ~[1, 2]]);\n-        assert_eq!(split([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert_eq!(split([1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_splitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(splitn([], 1u, f), ~[]);\n-        assert_eq!(splitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(splitn([3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n-        assert_eq!(splitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert!(splitn([1, 2, 3, 4, 3, 5], 1u, f) ==\n-                      ~[~[1, 2], ~[4, 3, 5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplit() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplit([], f), ~[]);\n-        assert_eq!(rsplit([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(rsplit([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert!(rsplit([1, 2, 3, 4, 3, 5], f) ==\n-            ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplitn([], 1u, f), ~[]);\n-        assert_eq!(rsplitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(rsplitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert_eq!(rsplitn([1, 2, 3, 4, 3, 5], 1u, f), ~[~[1, 2, 3, 4], ~[5]]);\n+        assert!(v3.is_empty());\n     }\n \n     #[test]\n@@ -2933,28 +2756,24 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_windowed () {\n-        fn t(n: uint, expected: &[&[int]]) {\n-            let mut i = 0;\n-            for windowed(n, [1,2,3,4,5,6]) |v| {\n-                assert_eq!(v, expected[i]);\n-                i += 1;\n-            }\n-\n-            // check that we actually iterated the right number of times\n-            assert_eq!(i, expected.len());\n-        }\n-        t(3, &[&[1,2,3],&[2,3,4],&[3,4,5],&[4,5,6]]);\n-        t(4, &[&[1,2,3,4],&[2,3,4,5],&[3,4,5,6]]);\n-        t(7, &[]);\n-        t(8, &[]);\n+    fn test_shift() {\n+        let mut x = ~[1, 2, 3];\n+        assert_eq!(x.shift(), 1);\n+        assert_eq!(&x, &~[2, 3]);\n+        assert_eq!(x.shift(), 2);\n+        assert_eq!(x.shift(), 3);\n+        assert_eq!(x.len(), 0);\n     }\n \n     #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_windowed_() {\n-        for windowed (0u, [1u,2u,3u,4u,5u,6u]) |_v| {}\n+    fn test_shift_opt() {\n+        let mut x = ~[1, 2, 3];\n+        assert_eq!(x.shift_opt(), Some(1));\n+        assert_eq!(&x, &~[2, 3]);\n+        assert_eq!(x.shift_opt(), Some(2));\n+        assert_eq!(x.shift_opt(), Some(3));\n+        assert_eq!(x.shift_opt(), None);\n+        assert_eq!(x.len(), 0);\n     }\n \n     #[test]\n@@ -3057,156 +2876,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do splitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_consume_fail() {\n-        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do consume(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3236,21 +2905,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_map_consume_fail() {\n-        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do map_consume(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3266,38 +2920,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_mapped_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do filter_mapped(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            Some((~0, @0))\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do v.filtered |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3333,7 +2955,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_imm_buf(v) |_buf, _i| {\n+        do v.as_imm_buf |_buf, _i| {\n             fail!()\n         }\n     }\n@@ -3343,7 +2965,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_mut_buf(v) |_buf, _i| {\n+        do v.as_mut_buf |_buf, _i| {\n             fail!()\n         }\n     }\n@@ -3373,20 +2995,30 @@ mod tests {\n         use iterator::*;\n         let xs = [1, 2, 5, 10, 11];\n         let mut it = xs.iter();\n-        assert_eq!(it.size_hint(), (Some(5), Some(5)));\n+        assert_eq!(it.size_hint(), (5, Some(5)));\n         assert_eq!(it.next().unwrap(), &1);\n-        assert_eq!(it.size_hint(), (Some(4), Some(4)));\n+        assert_eq!(it.size_hint(), (4, Some(4)));\n         assert_eq!(it.next().unwrap(), &2);\n-        assert_eq!(it.size_hint(), (Some(3), Some(3)));\n+        assert_eq!(it.size_hint(), (3, Some(3)));\n         assert_eq!(it.next().unwrap(), &5);\n-        assert_eq!(it.size_hint(), (Some(2), Some(2)));\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n         assert_eq!(it.next().unwrap(), &10);\n-        assert_eq!(it.size_hint(), (Some(1), Some(1)));\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &11);\n-        assert_eq!(it.size_hint(), (Some(0), Some(0)));\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_iter_size_hints() {\n+        use iterator::*;\n+        let mut xs = [1, 2, 5, 10, 11];\n+        assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n+        assert_eq!(xs.rev_iter().size_hint(), (5, Some(5)));\n+        assert_eq!(xs.mut_iter().size_hint(), (5, Some(5)));\n+        assert_eq!(xs.mut_rev_iter().size_hint(), (5, Some(5)));\n+    }\n+\n     #[test]\n     fn test_mut_iterator() {\n         use iterator::*;\n@@ -3421,6 +3053,120 @@ mod tests {\n         assert_eq!(xs, [5, 5, 5, 5, 5])\n     }\n \n+    #[test]\n+    fn test_consume_iterator() {\n+        use iterator::*;\n+        let xs = ~[1u,2,3,4,5];\n+        assert_eq!(xs.consume_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+    }\n+\n+    #[test]\n+    fn test_consume_rev_iterator() {\n+        use iterator::*;\n+        let xs = ~[1u,2,3,4,5];\n+        assert_eq!(xs.consume_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+    }\n+\n+    #[test]\n+    fn test_split_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.split_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3], &[5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[], &[2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4], &[]]);\n+        assert_eq!(xs.split_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[], &[], &[]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_splitn_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.splitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.splitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3,4,5]]);\n+        assert_eq!(xs.splitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.splitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplit_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.rsplit_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[3], &[1]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[2,3,4,5], &[]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[], &[1,2,3,4]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplitn_iterator() {\n+        let xs = &[1,2,3,4,5];\n+\n+        assert_eq!(xs.rsplitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[1,2,3]]);\n+        assert_eq!(xs.rsplitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[1,2]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_window_iterator() {\n+        let v = &[1i,2,3,4];\n+\n+        assert_eq!(v.window_iter(2).collect::<~[&[int]]>(), ~[&[1,2], &[2,3], &[3,4]]);\n+        assert_eq!(v.window_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[2,3,4]]);\n+        assert!(v.window_iter(6).next().is_none());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_window_iterator_0() {\n+        let v = &[1i,2,3,4];\n+        let _it = v.window_iter(0);\n+    }\n+\n+    #[test]\n+    fn test_chunk_iterator() {\n+        let v = &[1i,2,3,4,5];\n+\n+        assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n+        assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n+        assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_chunk_iterator_0() {\n+        let v = &[1i,2,3,4];\n+        let _it = v.chunk_iter(0);\n+    }\n+\n     #[test]\n     fn test_move_from() {\n         let mut a = [1,2,3,4,5];"}, {"sha": "8c37c1510cf20974d6543ce87a9335c961ca4c3d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -109,8 +109,8 @@ pub struct Path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n-    rp: Option<@Lifetime>,\n-    types: ~[@Ty],\n+    rp: Option<Lifetime>,\n+    types: ~[Ty],\n }\n \n pub type crate_num = int;\n@@ -132,15 +132,15 @@ pub static crate_node_id: node_id = 0;\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Send, and Freeze.\n pub enum TyParamBound {\n-    TraitTyParamBound(@trait_ref),\n+    TraitTyParamBound(trait_ref),\n     RegionTyParamBound\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n-    bounds: @OptVec<TyParamBound>\n+    bounds: OptVec<TyParamBound>\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -219,7 +219,7 @@ pub type blk = spanned<blk_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct blk_ {\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     stmts: ~[@stmt],\n     expr: Option<@expr>,\n     id: node_id,\n@@ -255,10 +255,10 @@ pub enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, @Path, Option<@pat>),\n-    pat_enum(@Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+    pat_ident(binding_mode, Path, Option<@pat>),\n+    pat_enum(Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_struct(@Path, ~[field_pat], bool),\n+    pat_struct(Path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),\n     pat_uniq(@pat),\n@@ -296,7 +296,7 @@ pub enum vstore {\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n     vstore_uniq,                    // ~[1,2,3,4]\n     vstore_box,                     // @[1,2,3,4]\n-    vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n+    vstore_slice(Option<Lifetime>) // &'foo? [1,2,3,4]\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -361,7 +361,7 @@ pub enum stmt_ {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct local_ {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     init: Option<@expr>,\n     id: node_id,\n@@ -429,12 +429,12 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(node_id, @expr, ident, ~[@Ty], ~[@expr], CallSugar),\n+    expr_method_call(node_id, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(node_id, binop, @expr, @expr),\n     expr_unary(node_id, unop, @expr),\n     expr_lit(@lit),\n-    expr_cast(@expr, @Ty),\n+    expr_cast(@expr, Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, or ret)\n@@ -454,9 +454,9 @@ pub enum expr_ {\n     expr_copy(@expr),\n     expr_assign(@expr, @expr),\n     expr_assign_op(node_id, binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[@Ty]),\n+    expr_field(@expr, ident, ~[Ty]),\n     expr_index(node_id, @expr, @expr),\n-    expr_path(@Path),\n+    expr_path(Path),\n \n     /// The special identifier `self`.\n     expr_self,\n@@ -471,7 +471,7 @@ pub enum expr_ {\n     expr_mac(mac),\n \n     // A struct literal expression.\n-    expr_struct(@Path, ~[field], Option<@expr>),\n+    expr_struct(Path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n     expr_repeat(@expr /* element */, @expr /* count */, mutability),\n@@ -583,7 +583,7 @@ pub type mac = spanned<mac_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mac_ {\n-    mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n+    mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n@@ -604,7 +604,7 @@ pub enum lit_ {\n // type structure in middle/ty.rs as well.\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct mt {\n-    ty: @Ty,\n+    ty: ~Ty,\n     mutbl: mutability,\n }\n \n@@ -701,7 +701,7 @@ impl ToStr for Onceness {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyClosure {\n     sigil: Sigil,\n-    region: Option<@Lifetime>,\n+    region: Option<Lifetime>,\n     lifetimes: OptVec<Lifetime>,\n     purity: purity,\n     onceness: Onceness,\n@@ -730,11 +730,11 @@ pub enum ty_ {\n     ty_vec(mt),\n     ty_fixed_length_vec(mt, @expr),\n     ty_ptr(mt),\n-    ty_rptr(Option<@Lifetime>, mt),\n+    ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n-    ty_tup(~[@Ty]),\n-    ty_path(@Path, @Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n+    ty_tup(~[Ty]),\n+    ty_path(Path, Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -762,15 +762,15 @@ pub struct inline_asm {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n-    output: @Ty,\n+    output: Ty,\n     cf: ret_style,\n }\n \n@@ -803,7 +803,7 @@ pub enum ret_style {\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n-    sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n+    sty_region(Option<Lifetime>, mutability), // `&'lt self`\n     sty_box(mutability),                       // `@self`\n     sty_uniq                                   // `~self`\n }\n@@ -827,7 +827,7 @@ pub struct method {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct _mod {\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@item],\n }\n \n@@ -839,13 +839,13 @@ pub enum foreign_mod_sort { named, anonymous }\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@foreign_item],\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_arg {\n-    ty: @Ty,\n+    ty: Ty,\n     id: node_id,\n }\n \n@@ -890,13 +890,13 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, @Path, node_id),\n+    view_path_simple(ident, Path, node_id),\n \n     // foo::bar::*\n-    view_path_glob(@Path, node_id),\n+    view_path_glob(Path, node_id),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(@Path, ~[path_list_ident], node_id)\n+    view_path_list(Path, ~[path_list_ident], node_id)\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -939,7 +939,7 @@ pub struct attribute_ {\n  */\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n-    path: @Path,\n+    path: Path,\n     ref_id: node_id,\n }\n \n@@ -959,7 +959,7 @@ impl visibility {\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n-    ty: @Ty,\n+    ty: Ty,\n     attrs: ~[attribute],\n }\n \n@@ -995,17 +995,17 @@ pub struct item {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum item_ {\n-    item_static(@Ty, mutability, @expr),\n+    item_static(Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@Ty, Generics),\n+    item_ty(Ty, Generics),\n     item_enum(enum_def, Generics),\n     item_struct(@struct_def, Generics),\n-    item_trait(Generics, ~[@trait_ref], ~[trait_method]),\n+    item_trait(Generics, ~[trait_ref], ~[trait_method]),\n     item_impl(Generics,\n-              Option<@trait_ref>, // (optional) trait this impl implements\n-              @Ty, // self\n+              Option<trait_ref>, // (optional) trait this impl implements\n+              Ty, // self\n               ~[@method]),\n     // a macro invocation (which includes macro definition)\n     item_mac(mac),\n@@ -1024,7 +1024,7 @@ pub struct foreign_item {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n-    foreign_item_static(@Ty, /* is_mutbl */ bool),\n+    foreign_item_static(Ty, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "59020e9d18377a463b69eb97ac30f650f6cdbc8e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -196,7 +196,7 @@ pub fn map_block(b: &blk, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n \n pub fn map_pat(pat: @pat, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match pat.node {\n-        pat_ident(_, path, _) => {\n+        pat_ident(_, ref path, _) => {\n             // Note: this is at least *potentially* a pattern...\n             cx.map.insert(pat.id, node_local(ast_util::path_to_ident(path)));\n         }"}, {"sha": "565f181ab8598431549f5b66b704ebc9cb050c62", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -27,7 +27,7 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: &Path) -> ident { copy *p.idents.last() }\n \n pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n@@ -212,8 +212,8 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, i: ident) -> @Path {\n-    @ast::Path { span: s,\n+pub fn ident_to_path(s: span, i: ident) -> Path {\n+    ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,\n@@ -238,12 +238,12 @@ pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    do ms.filtered |m| {\n+    do ms.consume_iter().filter |m| {\n         match m.vis {\n             public => true,\n             _   => false\n         }\n-    }\n+    }.collect()\n }\n \n // extract a ty_method from a trait_method. if the trait_method is\n@@ -580,7 +580,7 @@ pub fn view_path_id(p: &view_path) -> node_id {\n \n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n+pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n "}, {"sha": "e4532c476d75f626f446ece0bfeb7176df7b0e0a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -143,13 +143,13 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n /// Search a list of attributes and return only those with a specific name\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n-    do vec::filter_mapped(attrs) |a| {\n+    do attrs.iter().filter_map |a| {\n         if name == get_attr_name(a) {\n             Some(*a)\n         } else {\n             None\n         }\n-    }\n+    }.collect()\n }\n \n /// Search a list of meta items and return only those with a specific name\n@@ -192,7 +192,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n             ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n                 for misa.iter().advance |mi| {\n-                    if !misb.iter().any_(|x| x == mi) { return false; }\n+                    if !misb.iter().any(|x| x == mi) { return false; }\n                 }\n                 true\n             }\n@@ -277,14 +277,7 @@ pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n-\n-    return vec::filter_mapped(items, |item| {\n-        if name != get_meta_item_name(*item) {\n-            Some(*item)\n-        } else {\n-            None\n-        }\n-    });\n+    items.consume_iter().filter(|item| name != get_meta_item_name(*item)).collect()\n }\n \n /**"}, {"sha": "7e89d0407816031ea3e191822df7460a798e7d00", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -174,18 +174,13 @@ pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n #[deriving(IterBytes)]\n pub struct NameAndSpan {name: @str, span: Option<span>}\n \n+/// Extra information for tracking macro expansion of spans\n #[deriving(IterBytes)]\n-pub struct CallInfo {\n+pub struct ExpnInfo {\n     call_site: span,\n     callee: NameAndSpan\n }\n \n-/// Extra information for tracking macro expansion of spans\n-#[deriving(IterBytes)]\n-pub enum ExpnInfo {\n-    ExpandedFrom(CallInfo)\n-}\n-\n pub type FileName = @str;\n \n pub struct FileLines"}, {"sha": "204028212d62177e0da20ef2eed2c4c356fa0071", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -179,10 +179,10 @@ fn diagnosticstr(lvl: level) -> ~str {\n \n fn diagnosticcolor(lvl: level) -> term::color::Color {\n     match lvl {\n-        fatal => term::color::bright_red,\n-        error => term::color::bright_red,\n-        warning => term::color::bright_yellow,\n-        note => term::color::bright_green\n+        fatal => term::color::BRIGHT_RED,\n+        error => term::color::BRIGHT_RED,\n+        warning => term::color::BRIGHT_YELLOW,\n+        note => term::color::BRIGHT_GREEN\n     }\n }\n "}, {"sha": "5686887491615feb1ec1c2c263a3ad110d3d8dc8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -11,8 +11,7 @@\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n-use codemap::CallInfo;\n+use codemap::{CodeMap, span, ExpnInfo};\n use diagnostic::span_handler;\n use ext;\n use parse;\n@@ -243,7 +242,7 @@ impl ExtCtxt {\n     pub fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n     pub fn call_site(&self) -> span {\n         match *self.backtrace {\n-            Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n+            Some(@ExpnInfo {call_site: cs, _}) => cs,\n             None => self.bug(\"missing top span\")\n         }\n     }\n@@ -254,21 +253,19 @@ impl ExtCtxt {\n     pub fn mod_path(&self) -> ~[ast::ident] { copy *self.mod_path }\n     pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n         match ei {\n-            ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n+            ExpnInfo {call_site: cs, callee: ref callee} => {\n                 *self.backtrace =\n-                    Some(@ExpandedFrom(CallInfo {\n+                    Some(@ExpnInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n-                        callee: copy *callee}));\n+                        callee: copy *callee});\n             }\n         }\n     }\n     pub fn bt_pop(&self) {\n         match *self.backtrace {\n-            Some(@ExpandedFrom(\n-                CallInfo {\n-                    call_site: span {expn_info: prev, _}, _\n-                })) => {\n+            Some(@ExpnInfo {\n+                call_site: span {expn_info: prev, _}, _}) => {\n                 *self.backtrace = prev\n             }\n             _ => self.bug(\"tried to pop without a push\")\n@@ -329,7 +326,7 @@ pub fn expr_to_ident(cx: @ExtCtxt,\n                      expr: @ast::expr,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n-      ast::expr_path(p) => {\n+      ast::expr_path(ref p) => {\n         if p.types.len() > 0u || p.idents.len() != 1u {\n             cx.span_fatal(expr.span, err_msg);\n         }"}, {"sha": "73220ec28817030f71afc81e00e857ffce2ca78e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -32,44 +32,43 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n-                types: ~[@ast::Ty])\n-        -> @ast::Path;\n+                rp: Option<ast::Lifetime>,\n+                types: ~[ast::Ty])\n+        -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path, @Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n-    fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty;\n+    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n+    fn ty_ident(&self, span: span, idents: ast::ident) -> ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n-               ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n-               mutbl: ast::mutability)\n-        -> @ast::Ty;\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_box(&self, span: span, ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n-\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self, sp: span) -> @ast::Ty;\n-    fn ty_nil(&self) -> @ast::Ty;\n-\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+               ty: ast::Ty,\n+               lifetime: Option<ast::Lifetime>,\n+               mutbl: ast::mutability) -> ast::Ty;\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty;\n+    fn ty_box(&self, span: span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n+\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n+    fn ty_infer(&self, sp: span) -> ast::Ty;\n+    fn ty_nil(&self) -> ast::Ty;\n+\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n-    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n+    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref;\n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound;\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n \n     // statements\n@@ -80,13 +79,13 @@ pub trait AstBuilder {\n     fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::blk;\n     fn blk_expr(&self, expr: @ast::expr) -> ast::blk;\n     fn blk_all(&self, span: span,\n-               view_items: ~[@ast::view_item],\n+               view_items: ~[ast::view_item],\n                stmts: ~[@ast::stmt],\n                expr: Option<@ast::expr>) -> ast::blk;\n \n     // expressions\n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr;\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr;\n     fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n \n     fn expr_self(&self, span: span) -> @ast::expr;\n@@ -110,7 +109,7 @@ pub trait AstBuilder {\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n \n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field;\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr;\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr;\n     fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::field]) -> @ast::expr;\n \n     fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n@@ -138,9 +137,9 @@ pub trait AstBuilder {\n                               span: span,\n                               ident: ast::ident,\n                               bm: ast::binding_mode) -> @ast::pat;\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n \n     fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n     fn arm_unreachable(&self, span: span) -> ast::arm;\n@@ -167,25 +166,25 @@ pub trait AstBuilder {\n     fn item(&self, span: span,\n             name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: span, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn arg(&self, span: span, name: ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk) -> @ast::item;\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n                       span: span,\n                       name: ident,\n@@ -202,14 +201,14 @@ pub trait AstBuilder {\n \n     fn item_mod(&self, span: span,\n                 name: ident, attrs: ~[ast::attribute],\n-                vi: ~[@ast::view_item], items: ~[@ast::item]) -> @ast::item;\n+                vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n                     span: span,\n                     name: ident,\n-                    ty: @ast::Ty,\n+                    ty: ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item;\n \n     fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n \n@@ -218,30 +217,30 @@ pub trait AstBuilder {\n     fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item;\n \n     fn view_use(&self, sp: span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item;\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n     fn view_use_list(&self, sp: span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item;\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item;\n     fn view_use_glob(&self, sp: span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item;\n+                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item;\n }\n \n impl AstBuilder for @ExtCtxt {\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, false, strs, None, ~[])\n     }\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path {\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n-                types: ~[@ast::Ty])\n-        -> @ast::Path {\n-        @ast::Path {\n+                rp: Option<ast::Lifetime>,\n+                types: ~[ast::Ty])\n+        -> ast::Path {\n+        ast::Path {\n             span: sp,\n             global: global,\n             idents: idents,\n@@ -250,52 +249,52 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt {\n         ast::mt {\n-            ty: ty,\n+            ty: ~ty,\n             mutbl: mutbl\n         }\n     }\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             span: span,\n             node: ty\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path, bounds: @Option<OptVec<ast::TyParamBound>>)\n-              -> @ast::Ty {\n+    fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n+              -> ast::Ty {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, self.next_id()))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n-        -> @ast::Ty {\n-        self.ty_path(self.path_ident(span, ident), @None)\n+        -> ast::Ty {\n+        self.ty_path(self.path_ident(span, ident), None)\n     }\n \n     fn ty_rptr(&self,\n                span: span,\n-               ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n+               ty: ast::Ty,\n+               lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n-        -> @ast::Ty {\n+        -> ast::Ty {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty {\n         self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n     }\n     fn ty_box(&self, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+                 ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty {\n         self.ty_path(\n             self.path_all(dummy_sp(),\n                           true,\n@@ -305,67 +304,65 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"Option\")\n                           ],\n                           None,\n-                          ~[ ty ]),\n-            @None)\n+                          ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field {\n         respan(span,\n                ast::ty_field_ {\n                    ident: name,\n-                   mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+                   mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n                })\n     }\n \n-    fn ty_infer(&self, span: span) -> @ast::Ty {\n+    fn ty_infer(&self, span: span) -> ast::Ty {\n         self.ty(span, ast::ty_infer)\n     }\n \n-    fn ty_nil(&self) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty_nil(&self) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam {\n+    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n         ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n \n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]), @None)))\n+                self.path_global(dummy_sp(), ~[p.ident]), None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let no_bounds = @opt_vec::Empty;\n         let new_params = do generics.ty_params.map |ty_param| {\n-            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+            ast::TyParam { bounds: opt_vec::Empty, ..copy *ty_param }\n         };\n         Generics {\n             ty_params: new_params,\n             .. copy *generics\n         }\n     }\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref {\n-        @ast::trait_ref {\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref {\n+        ast::trait_ref {\n             path: path,\n             ref_id: self.next_id()\n         }\n     }\n \n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound {\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n@@ -400,7 +397,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n     fn blk_all(&self,\n                span: span,\n-               view_items: ~[@ast::view_item],\n+               view_items: ~[ast::view_item],\n                stmts: ~[@ast::stmt],\n                expr: Option<@ast::expr>) -> ast::blk {\n         respan(span,\n@@ -421,7 +418,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr {\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr {\n         self.expr(path.span, ast::expr_path(path))\n     }\n \n@@ -487,7 +484,7 @@ impl AstBuilder for @ExtCtxt {\n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field {\n         respan(span, ast::field_ { ident: name, expr: e })\n     }\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr {\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr {\n         self.expr(span, ast::expr_struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: span,\n@@ -570,12 +567,12 @@ impl AstBuilder for @ExtCtxt {\n         let pat = ast::pat_ident(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n         let pat = ast::pat_enum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n         let pat = ast::pat_struct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n@@ -644,7 +641,7 @@ impl AstBuilder for @ExtCtxt {\n         self.lambda1(span, self.blk(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: span, ident: ast::ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, span: span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n@@ -655,7 +652,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n             output: output,\n@@ -679,7 +676,7 @@ impl AstBuilder for @ExtCtxt {\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item {\n         self.item(span,\n@@ -696,7 +693,7 @@ impl AstBuilder for @ExtCtxt {\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk\n               ) -> @ast::item {\n         self.item_fn_poly(\n@@ -708,10 +705,10 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = do tys.map |ty| {\n-            ast::variant_arg { ty: *ty, id: self.next_id() }\n-        };\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n+        let args = tys.consume_iter().transform(|ty| {\n+            ast::variant_arg { ty: ty, id: self.next_id() }\n+        }).collect();\n \n         respan(span,\n                ast::variant_ {\n@@ -762,7 +759,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn item_mod(&self, span: span, name: ident,\n                 attrs: ~[ast::attribute],\n-                vi: ~[@ast::view_item],\n+                vi: ~[ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n         self.item(\n             span,\n@@ -775,12 +772,12 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: span, name: ident, ty: @ast::Ty,\n+    fn item_ty_poly(&self, span: span, name: ident, ty: ast::Ty,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n@@ -804,8 +801,8 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use(&self, sp: span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item {\n-        @ast::view_item {\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item {\n+        ast::view_item {\n             node: ast::view_item_use(vp),\n             attrs: ~[],\n             vis: vis,\n@@ -814,7 +811,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_list(&self, sp: span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item {\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item {\n         let imports = do imports.map |id| {\n             respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n         };\n@@ -827,7 +824,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_glob(&self, sp: span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item {\n+                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n                                 ast::view_path_glob(self.path(sp, path), self.next_id()))])"}, {"sha": "900668df117e3cb3ab963dac4817bb843574a61d", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -36,7 +36,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let e = @ast::expr {\n         id: cx.next_id(),\n         node: ast::expr_path(\n-            @ast::Path {\n+            ast::Path {\n                  span: sp,\n                  global: false,\n                  idents: ~[res],"}, {"sha": "01769482d08297eb211d460ca62887e56d043d24", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -335,9 +335,9 @@ impl<'self> TraitDef<'self> {\n                     cx.typarambound(p.to_path(cx, span, type_ident, generics))\n                 });\n             // require the current trait\n-            bounds.push(cx.typarambound(trait_path));\n+            bounds.push(cx.typarambound(copy trait_path));\n \n-            trait_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n+            trait_generics.ty_params.push(cx.typaram(ty_param.ident, bounds));\n         }\n \n         // Create the reference to the trait.\n@@ -351,13 +351,12 @@ impl<'self> TraitDef<'self> {\n         let self_lifetime = if generics.lifetimes.is_empty() {\n             None\n         } else {\n-            Some(@*generics.lifetimes.get(0))\n+            Some(*generics.lifetimes.get(0))\n         };\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n-                                               opt_vec::take_vec(self_ty_params)),\n-                                   @None);\n+                                               opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n             span,\n@@ -457,7 +456,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n-                     generics: &Generics, type_ident: ident) -> @ast::Ty {\n+                     generics: &Generics, type_ident: ident) -> ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n \n@@ -467,7 +466,7 @@ impl<'self> MethodDef<'self> {\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n                              type_ident: ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -515,7 +514,7 @@ impl<'self> MethodDef<'self> {\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n-                     arg_types: ~[(ident, @ast::Ty)],\n+                     arg_types: ~[(ident, ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n@@ -890,7 +889,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: span,\n-                          field_paths: ~[@ast::Path],\n+                          field_paths: ~[ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n@@ -941,7 +940,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         };\n         let path = cx.path_ident(span,\n                                  cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(path);\n+        paths.push(copy path);\n         ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n@@ -987,7 +986,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n-                paths.push(path);\n+                paths.push(copy path);\n                 ident_expr.push((None, cx.expr_path(path)));\n             }\n "}, {"sha": "255bc6c98775be9679da3c9a6444cedaad9894d4", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -61,16 +61,15 @@ impl<'self> Path<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n-        cx.ty_path(self.to_path(cx, span,\n-                                self_ty, self_generics), @None)\n+                 -> ast::Ty {\n+        cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n@@ -110,9 +109,9 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@cx.lifetime(span, cx.ident_of(*s))),\n+        Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -123,7 +122,7 @@ impl<'self> Ty<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n+                 -> ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n@@ -142,8 +141,7 @@ impl<'self> Ty<'self> {\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics),\n-                           @None)\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n@@ -162,7 +160,7 @@ impl<'self> Ty<'self> {\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n@@ -171,7 +169,7 @@ impl<'self> Ty<'self> {\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n-                    Some(@*self_generics.lifetimes.get(0))\n+                    Some(*self_generics.lifetimes.get(0))\n                 };\n \n                 cx.path_all(span, false, ~[self_ty], lifetime,\n@@ -194,7 +192,7 @@ fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n         });\n-    cx.typaram(cx.ident_of(name), @bounds)\n+    cx.typaram(cx.ident_of(name), bounds)\n }\n \n fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n@@ -251,8 +249,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n                     Send => ast::sty_uniq,\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @cx.lifetime(span,\n-                                                         cx.ident_of(*s)));\n+                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });"}, {"sha": "71e0d49493b81b8ce2d8c8ac6474a15beb27f347", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -16,7 +16,7 @@ use ast;\n use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use codemap;\n-use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n+use codemap::{span, ExpnInfo, NameAndSpan, spanned};\n use ext::base::*;\n use fold::*;\n use parse;\n@@ -40,7 +40,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         expr_mac(ref mac) => {\n             match (*mac).node {\n                 // Token-tree macros:\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     if (pth.idents.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n@@ -60,13 +60,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             expander: exp,\n                             span: exp_sp\n                         }))) => {\n-                            cx.bt_push(ExpandedFrom(CallInfo {\n+                            cx.bt_push(ExpnInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n                                     span: exp_sp,\n                                 },\n-                            }));\n+                            });\n \n                             let expanded = match exp(cx, mac.span, *tts) {\n                                 MRExpr(e) => e,\n@@ -131,13 +131,13 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n \n             match (*extsbox).find(&intern(mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n-                  cx.bt_push(ExpandedFrom(CallInfo {\n+                  cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n                           name: mname,\n                           span: None\n                       }\n-                  }));\n+                  });\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();\n                   r\n@@ -198,7 +198,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n \n // does this attribute list contain \"macro_escape\" ?\n pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n-    attrs.iter().any_(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n+    attrs.iter().any(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n }\n \n // Support for item-position macro invocations, exactly the same\n@@ -208,7 +208,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n-        item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+        item_mac(codemap::spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n             (pth, copy *tts)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -227,13 +227,13 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                                     given '%s'\", extnamestr,\n                                    ident_to_str(&it.ident)));\n             }\n-            cx.bt_push(ExpandedFrom(CallInfo {\n+            cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n                     span: expand.span\n                 }\n-            }));\n+            });\n             ((*expand).expander)(cx, it.span, tts)\n         }\n         Some(@SE(IdentTT(ref expand))) => {\n@@ -242,13 +242,13 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    extnamestr));\n             }\n-            cx.bt_push(ExpandedFrom(CallInfo {\n+            cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n                     span: expand.span\n                 }\n-            }));\n+            });\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n         }\n         _ => cx.span_fatal(\n@@ -298,7 +298,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     (copy *mac, pth, copy *tts, semi)\n                 }\n             }\n@@ -319,10 +319,10 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n         Some(@SE(NormalTT(\n             SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n-            cx.bt_push(ExpandedFrom(CallInfo {\n+            cx.bt_push(ExpnInfo {\n                 call_site: sp,\n                 callee: NameAndSpan { name: extnamestr, span: exp_sp }\n-            }));\n+            });\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n                     @codemap::spanned { node: stmt_expr(e, cx.next_id()),\n@@ -372,10 +372,10 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                      (ident_accum, v): (@mut ~[ast::ident], visit::vt<@mut ~[ast::ident]>)| {\n             match *p {\n                 // we found a pat_ident!\n-                ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n+                ast::pat{id:_, node: ast::pat_ident(_,ref path,ref inner), span:_} => {\n                     match path {\n                         // a path of length one:\n-                        @ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n+                        &ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n                         ident_accum.push(id),\n                         // I believe these must be enums...\n                         _ => ()\n@@ -580,6 +580,7 @@ pub fn core_macros() -> @str {\n             pub mod $c {\n                 fn key(_x: @::std::condition::Handler<$in,$out>) { }\n \n+                #[allow(non_uppercase_statics)]\n                 pub static cond :\n                     ::std::condition::Condition<'static,$in,$out> =\n                     ::std::condition::Condition {\n@@ -595,6 +596,7 @@ pub fn core_macros() -> @str {\n             pub mod $c {\n                 fn key(_x: @::std::condition::Handler<$in,$out>) { }\n \n+                #[allow(non_uppercase_statics)]\n                 pub static cond :\n                     ::std::condition::Condition<'static,$in,$out> =\n                     ::std::condition::Condition {"}, {"sha": "333570b6c9d7e5156cb7518d996c6b7b01054e3f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -22,7 +22,6 @@ use ext::build::AstBuilder;\n \n use std::option;\n use std::unstable::extfmt::ct::*;\n-use std::vec;\n use parse::token::{str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n@@ -268,7 +267,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n        corresponding function in std::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n     let npieces = pieces.len();\n-    do vec::consume(pieces) |i, pc| {\n+    for pieces.consume_iter().enumerate().advance |(i, pc)| {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {"}, {"sha": "9e6776363a82db7e1a91bebfc82d6c445eec3689", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -26,7 +26,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n-            ast::tt_delim(vec::to_owned(tt)),\n+            &ast::tt_delim(vec::to_owned(tt)),\n             get_ident_interner()));\n \n     //trivial expression"}, {"sha": "a4873e6e34b45feb0e86f5f98b5658150459e388", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -25,39 +25,39 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path_global(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n pub trait append_types {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path;\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path;\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path;\n }\n \n-impl append_types for @ast::Path {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path {\n-        @ast::Path {\n+impl append_types for ast::Path {\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path {\n+        ast::Path {\n             types: vec::append_one(copy self.types, ty),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n \n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path {\n-        @ast::Path {\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path {\n+        ast::Path {\n             types: vec::append(copy self.types, tys),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n }"}, {"sha": "adf10215cb56636ef995845e1e8bc70fdcb5ace8", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -49,7 +49,7 @@ impl proto::visitor<(), (), ()> for @ExtCtxt {\n         }\n     }\n \n-    fn visit_message(&self, name: @str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, _span: span, _tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(ref next_state) => {"}, {"sha": "98fc9aa61784d05b3d634ce01d8b23e1b03e06ef", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -25,7 +25,7 @@ use std::vec;\n \n pub trait gen_send {\n     fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty;\n }\n \n pub trait to_type_decls {\n@@ -37,7 +37,7 @@ pub trait to_type_decls {\n pub trait gen_init {\n     fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n     fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty;\n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n     fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n@@ -56,11 +56,11 @@ impl gen_send for message {\n                 next.generics.ty_params.len());\n             let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n             let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                .transform(|(n, t)| cx.arg(span, *n, *t)).collect();\n+                .transform(|(n, t)| cx.arg(span, copy *n, copy *t)).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)), @None);\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)), None);\n             let args_ast = vec::append(\n                 ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n@@ -117,7 +117,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys), @None);\n+                                     .add_tys(copy next_state.tys), None);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -137,15 +137,15 @@ impl gen_send for message {\n                 let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n                 let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), *t)).collect();\n+                    .transform(|(&n, t)| cx.arg(span, cx.ident_of(n), copy *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,\n                              cx.ident_of(\"pipe\"),\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params)), @None))],\n+                                     &this.generics.ty_params)), None))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -189,9 +189,9 @@ impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @None)\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), None)\n     }\n }\n \n@@ -225,7 +225,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys), @None))\n+                                    .add_tys(copy next_state.tys), None))\n               }\n               None => tys\n             };\n@@ -278,8 +278,7 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params)), @None)),\n-                        @None),\n+                                &self.generics.ty_params)), None)), None),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n@@ -298,8 +297,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params)), @None),\n-                                   self.proto.buffer_ty_path(cx)]), @None),\n+                                &self.generics.ty_params)), None),\n+                                   self.proto.buffer_ty_path(cx)]), None),\n                     cx.strip_bounds(&self.generics)));\n         };\n         items\n@@ -370,12 +369,12 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        for (copy self.states).iter().advance |s| {\n+        for self.states.iter().advance |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(*tp),\n+                  None => params.push(copy *tp),\n                   _ => ()\n                 }\n             }\n@@ -384,16 +383,16 @@ impl gen_init for protocol {\n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n                         copy self.span)\n-                   .add_tys(cx.ty_vars_global(&params)), @None)\n+                   .add_tys(cx.ty_vars_global(&params)), None)\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        let fields = do (copy self.states).iter().transform |s| {\n+        let fields = do self.states.iter().transform |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(*tp),\n+                  None => params.push(copy *tp),\n                   _ => ()\n                 }\n             }"}, {"sha": "2fe8456c2749c7becbce1a5a79ebb3995b8b5630", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -37,11 +37,11 @@ impl direction {\n \n pub struct next_state {\n     state: @str,\n-    tys: ~[@ast::Ty],\n+    tys: ~[ast::Ty],\n }\n \n // name, span, data, current state, next state\n-pub struct message(@str, span, ~[@ast::Ty], state, Option<next_state>);\n+pub struct message(@str, span, ~[ast::Ty], state, Option<next_state>);\n \n impl message {\n     pub fn name(&mut self) -> @str {\n@@ -81,7 +81,7 @@ impl state_ {\n     pub fn add_message(@self,\n                        name: @str,\n                        span: span,\n-                       data: ~[@ast::Ty],\n+                       data: ~[ast::Ty],\n                        next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n@@ -96,10 +96,10 @@ impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    pub fn to_ty(&self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)), @None)\n+                cx.ty_vars(&self.generics.ty_params)), None)\n     }\n \n     /// Iterate over the states that can be reached in one message\n@@ -206,7 +206,7 @@ impl protocol_ {\n pub trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(&self, name: @str, spane: span, tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, spane: span, tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}, {"sha": "c550e3382a233ca272d068b2286008e7eda95f53", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -88,13 +88,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Ty {\n+    impl ToSource for ast::Ty {\n         fn to_source(&self) -> @str {\n-            pprust::ty_to_str(*self, get_ident_interner()).to_managed()\n+            pprust::ty_to_str(self, get_ident_interner()).to_managed()\n         }\n     }\n \n-    impl<'self> ToSource for &'self [@ast::Ty] {\n+    impl<'self> ToSource for &'self [ast::Ty] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\", \").to_managed()\n         }\n@@ -216,13 +216,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for @ast::Ty {\n+    impl ToTokens for ast::Ty {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }\n     }\n \n-    impl<'self> ToTokens for &'self [@ast::Ty] {\n+    impl<'self> ToTokens for &'self [ast::Ty] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }"}, {"sha": "b43536389e2cd06829e716447f98c01143e3da23", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,8 +10,8 @@\n \n use ast;\n use codemap;\n-use codemap::{Pos, ExpandedFrom, span};\n-use codemap::{CallInfo, NameAndSpan};\n+use codemap::{Pos, span};\n+use codemap::{ExpnInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -117,14 +117,14 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n // recur along an ExpnInfo chain to find the original expression\n fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n     match *expn_info {\n-        ExpandedFrom(CallInfo { call_site: ref call_site, _ }) => {\n+        ExpnInfo { call_site: ref call_site, _ } => {\n             match call_site.expn_info {\n                 Some(next_expn_info) => {\n                     match *next_expn_info {\n-                        ExpandedFrom(CallInfo {\n+                        ExpnInfo {\n                             callee: NameAndSpan { name: ref name, _ },\n                             _\n-                        }) => {\n+                        } => {\n                             // Don't recurse into file using \"include!\"\n                             if \"include\" == *name  {\n                                 expn_info"}, {"sha": "6de504c66fd88937313b3a364f3dd2bf164a6a85", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -82,7 +82,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(vec::to_owned(arg)),\n+                                 &ast::tt_delim(vec::to_owned(arg)),\n                                  get_ident_interner())));\n         }\n "}, {"sha": "c36b717ea0055f58f181bd60f8ad3792e4ecd61b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,11 +14,9 @@ use codemap::{span, spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n-use std::vec;\n-\n pub trait ast_fold {\n     fn fold_crate(@self, &crate) -> crate;\n-    fn fold_view_item(@self, @view_item) -> @view_item;\n+    fn fold_view_item(@self, &view_item) -> view_item;\n     fn fold_foreign_item(@self, @foreign_item) -> @foreign_item;\n     fn fold_item(@self, @item) -> Option<@item>;\n     fn fold_struct_field(@self, @struct_field) -> @struct_field;\n@@ -30,12 +28,12 @@ pub trait ast_fold {\n     fn fold_pat(@self, @pat) -> @pat;\n     fn fold_decl(@self, @decl) -> Option<@decl>;\n     fn fold_expr(@self, @expr) -> @expr;\n-    fn fold_ty(@self, @Ty) -> @Ty;\n+    fn fold_ty(@self, &Ty) -> Ty;\n     fn fold_mod(@self, &_mod) -> _mod;\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n     fn fold_ident(@self, ident) -> ident;\n-    fn fold_path(@self, @Path) -> @Path;\n+    fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @local) -> @local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, node_id) -> node_id;\n@@ -64,7 +62,7 @@ pub struct AstFoldFns {\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n     fold_ident: @fn(ident, @ast_fold) -> ident,\n-    fold_path: @fn(@Path, @ast_fold) -> Path,\n+    fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(&local_, span, @ast_fold) -> (local_, span),\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(node_id) -> node_id,\n@@ -109,7 +107,7 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n         is_mutbl: a.is_mutbl,\n-        ty: fld.fold_ty(a.ty),\n+        ty: fld.fold_ty(&a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),\n     }\n@@ -119,7 +117,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n         node: match m.node {\n-            mac_invoc_tt(p,ref tts) =>\n+            mac_invoc_tt(ref p,ref tts) =>\n             mac_invoc_tt(fld.fold_path(p),\n                          fold_tts(*tts,fld))\n         },\n@@ -156,15 +154,15 @@ fn maybe_fold_ident(t : &token::Token, fld: @ast_fold) -> token::Token {\n \n pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n-        output: fld.fold_ty(decl.output),\n+        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ copy *x, fld)),\n+        output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n \n fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n@@ -173,12 +171,13 @@ pub fn fold_ty_param(tp: TyParam,\n                      fld: @ast_fold) -> TyParam {\n     TyParam {ident: tp.ident,\n              id: fld.new_id(tp.id),\n-             bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n+             bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n }\n \n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n                       fld: @ast_fold) -> OptVec<TyParam> {\n-    tps.map(|tp| fold_ty_param(*tp, fld))\n+    let tps = /*bad*/ copy *tps;\n+    tps.map_consume(|tp| fold_ty_param(tp, fld))\n }\n \n pub fn fold_lifetime(l: &Lifetime,\n@@ -227,14 +226,14 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n                 foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fold_arg(*a)),\n-                            output: fld.fold_ty(fdec.output),\n+                            inputs: fdec.inputs.map(|a| fold_arg(/*bad*/copy *a)),\n+                            output: fld.fold_ty(&fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n                         fold_generics(generics, fld))\n                 }\n-                foreign_item_static(t, m) => {\n+                foreign_item_static(ref t, m) => {\n                     foreign_item_static(fld.fold_ty(t), m)\n                 }\n             },\n@@ -261,14 +260,14 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n \n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n-                                          ty: fld.fold_ty(sf.node.ty),\n+                                          ty: fld.fold_ty(&sf.node.ty),\n                                           attrs: sf.node.attrs.map(|e| fold_attribute(*e)) },\n                span: sf.span }\n }\n \n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n-        item_static(t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n+        item_static(ref t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n@@ -282,7 +281,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(fld.fold_foreign_mod(nm))\n         }\n-        item_ty(t, ref generics) => {\n+        item_ty(ref t, ref generics) => {\n             item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n@@ -298,10 +297,10 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             let struct_def = fold_struct_def(*struct_def, fld);\n             item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n         }\n-        item_impl(ref generics, ifce, ty, ref methods) => {\n+        item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(\n                 fold_generics(generics, fld),\n-                ifce.map(|p| fold_trait_ref(*p, fld)),\n+                ifce.map(|p| fold_trait_ref(p, fld)),\n                 fld.fold_ty(ty),\n                 methods.map(|x| fld.fold_method(*x))\n             )\n@@ -315,7 +314,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             };\n             item_trait(\n                 fold_generics(generics, fld),\n-                traits.map(|p| fold_trait_ref(*p, fld)),\n+                traits.map(|p| fold_trait_ref(p, fld)),\n                 methods\n             )\n         }\n@@ -337,9 +336,9 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n     }\n }\n \n-fn fold_trait_ref(p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n-    @ast::trait_ref {\n-        path: fld.fold_path(p.path),\n+fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n+    ast::trait_ref {\n+        path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n@@ -349,7 +348,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n         node: ast::struct_field_ {\n             kind: copy f.node.kind,\n             id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(f.node.ty),\n+            ty: fld.fold_ty(&f.node.ty),\n             attrs: /* FIXME (#2543) */ copy f.node.attrs,\n         },\n         span: fld.new_span(f.span),\n@@ -374,7 +373,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n \n \n pub fn noop_fold_block(b: &blk_, fld: @ast_fold) -> blk_ {\n-    let view_items = b.view_items.map(|x| fld.fold_view_item(*x));\n+    let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let mut stmts = ~[];\n     for b.stmts.iter().advance |stmt| {\n         match fld.fold_stmt(*stmt) {\n@@ -421,21 +420,21 @@ fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n     match *p {\n         pat_wild => pat_wild,\n-        pat_ident(binding_mode, pth, ref sub) => {\n+        pat_ident(binding_mode, ref pth, ref sub) => {\n             pat_ident(\n                 binding_mode,\n                 fld.fold_path(pth),\n                 sub.map(|x| fld.fold_pat(*x))\n             )\n         }\n         pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-        pat_enum(pth, ref pats) => {\n+        pat_enum(ref pth, ref pats) => {\n             pat_enum(\n                 fld.fold_path(pth),\n                 pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n             )\n         }\n-        pat_struct(pth, ref fields, etc) => {\n+        pat_struct(ref pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n@@ -519,7 +518,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.new_id(callee_id),\n                 fld.fold_expr(f),\n                 fld.fold_ident(i),\n-                tps.map(|x| fld.fold_ty(*x)),\n+                tps.map(|x| fld.fold_ty(x)),\n                 fld.map_exprs(|x| fld.fold_expr(x), *args),\n                 blk\n             )\n@@ -542,7 +541,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n         expr_lit(_) => copy *e,\n-        expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+        expr_cast(expr, ref ty) => expr_cast(fld.fold_expr(expr), copy *ty),\n         expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n         expr_if(cond, ref tr, fl) => {\n             expr_if(\n@@ -588,7 +587,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_field(el, id, ref tys) => {\n             expr_field(\n                 fld.fold_expr(el), fld.fold_ident(id),\n-                tys.map(|x| fld.fold_ty(*x))\n+                tys.map(|x| fld.fold_ty(x))\n             )\n         }\n         expr_index(callee_id, el, er) => {\n@@ -598,7 +597,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(er)\n             )\n         }\n-        expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_path(ref pth) => expr_path(fld.fold_path(pth)),\n         expr_self => expr_self,\n         expr_break(ref opt_ident) => {\n             expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n@@ -623,7 +622,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             })\n         }\n         expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n-        expr_struct(path, ref fields, maybe_expr) => {\n+        expr_struct(ref path, ref fields, maybe_expr) => {\n             expr_struct(\n                 fld.fold_path(path),\n                 fields.map(|x| fold_field(*x)),\n@@ -638,7 +637,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n         mt {\n-            ty: fld.fold_ty(mt.ty),\n+            ty: ~fld.fold_ty(mt.ty),\n             mutbl: mt.mutbl,\n         }\n     }\n@@ -683,9 +682,9 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 decl: fold_fn_decl(&f.decl, fld)\n             })\n         }\n-        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n-        ty_path(path, bounds, id) =>\n-            ty_path(fld.fold_path(path), @fold_opt_bounds(bounds, fld), fld.new_id(id)),\n+        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(ty))),\n+        ty_path(ref path, ref bounds, id) =>\n+            ty_path(fld.fold_path(path), fold_opt_bounds(bounds, fld), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n                 fold_mt(mt, fld),\n@@ -699,31 +698,31 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n // ...nor do modules\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n-        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n-        items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n+        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n+        items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n     }\n }\n \n fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n         items: nm.items.iter().transform(|x| fld.fold_foreign_item(*x)).collect(),\n     }\n }\n \n fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n-        ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n+        ast::variant_arg { ty: fld.fold_ty(&va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n     let kind;\n     match v.kind {\n         tuple_variant_kind(ref variant_args) => {\n             kind = tuple_variant_kind(do variant_args.map |x| {\n-                fold_variant_arg(*x)\n+                fold_variant_arg(/*bad*/ copy *x)\n             })\n         }\n         struct_variant_kind(struct_def) => {\n@@ -756,20 +755,20 @@ fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n     /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(p: @Path, fld: @ast_fold) -> Path {\n+fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n     ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n         idents: p.idents.map(|x| fld.fold_ident(*x)),\n         rp: p.rp,\n-        types: p.types.map(|x| fld.fold_ty(*x)),\n+        types: p.types.map(|x| fld.fold_ty(x)),\n     }\n }\n \n fn noop_fold_local(l: &local_, fld: @ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n-        ty: fld.fold_ty(l.ty),\n+        ty: fld.fold_ty(&l.ty),\n         pat: fld.fold_pat(l.pat),\n         init: l.init.map(|e| fld.fold_expr(*e)),\n         id: fld.new_id(l.id),\n@@ -820,9 +819,8 @@ impl ast_fold for AstFoldFns {\n         let (n, s) = (self.fold_crate)(&c.node, c.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_view_item(@self, x: @view_item) ->\n-       @view_item {\n-        @ast::view_item {\n+    fn fold_view_item(@self, x: &view_item) -> view_item {\n+        ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n             attrs: x.attrs.iter().transform(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n             vis: x.vis,\n@@ -840,7 +838,7 @@ impl ast_fold for AstFoldFns {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n                 id: sf.node.id,\n-                ty: (self as @ast_fold).fold_ty(sf.node.ty),\n+                ty: self.fold_ty(&sf.node.ty),\n                 attrs: copy sf.node.attrs,\n             },\n             span: (self.new_span)(sf.span),\n@@ -889,9 +887,9 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(@self, x: @Ty) -> @Ty {\n+    fn fold_ty(@self, x: &Ty) -> Ty {\n         let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n-        @Ty {\n+        Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n@@ -910,8 +908,8 @@ impl ast_fold for AstFoldFns {\n     fn fold_ident(@self, x: ident) -> ident {\n         (self.fold_ident)(x, self as @ast_fold)\n     }\n-    fn fold_path(@self, x: @Path) -> @Path {\n-        @(self.fold_path)(x, self as @ast_fold)\n+    fn fold_path(@self, x: &Path) -> Path {\n+        (self.fold_path)(x, self as @ast_fold)\n     }\n     fn fold_local(@self, x: @local) -> @local {\n         let (n, s) = (self.fold_local)(&x.node, x.span, self as @ast_fold);\n@@ -966,7 +964,7 @@ mod test {\n     }\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: @pprust::ps, crate: ast::crate) {\n+    fn fake_print_crate(s: @pprust::ps, crate: &ast::crate) {\n         pprust::print_mod(s, &crate.node.module, crate.node.attrs);\n     }\n \n@@ -997,7 +995,7 @@ mod test {\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n@@ -1009,7 +1007,7 @@ mod test {\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }"}, {"sha": "ba3b72ec19443fe3f4d1b9e7ce324ba2bb5af7d4", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -16,7 +16,7 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n-use std::vec::VecIterator;\n+use std::vec::{VecIterator};\n \n #[deriving(Encodable, Decodable,IterBytes)]\n pub enum OptVec<T> {\n@@ -58,6 +58,13 @@ impl<T> OptVec<T> {\n         }\n     }\n \n+    fn map_consume<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+        match self {\n+            Empty => Empty,\n+            Vec(v) => Vec(v.consume_iter().transform(op).collect())\n+        }\n+    }\n+\n     fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(\"Invalid index %u\", i),\n@@ -146,4 +153,12 @@ impl<'self, T> Iterator<&'self T> for OptVecIterator<'self, T> {\n             None => None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match self.iter {\n+            Some(ref x) => x.size_hint(),\n+            None => (0, Some(0))\n+        }\n+    }\n }"}, {"sha": "75d1f35bf38a5f1701b80556722b0f86505fe0ed", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -44,6 +44,8 @@ pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     next_id: node_id,\n     span_diagnostic: @span_handler, // better be the same as the one in the reader!\n+    /// Used to determine and report recursive mod inclusions\n+    included_mod_stack: ~[Path],\n }\n \n pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n@@ -52,6 +54,7 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n+        included_mod_stack: ~[],\n     }\n }\n \n@@ -62,6 +65,7 @@ pub fn new_parse_sess_special_handler(sh: @span_handler,\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: sh,\n+        included_mod_stack: ~[],\n     }\n }\n \n@@ -366,7 +370,7 @@ mod test {\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@\"a\"),\n                    @ast::expr{id:1,\n-                              node:ast::expr_path(@ast::Path {span:sp(0,1),\n+                              node:ast::expr_path(ast::Path {span:sp(0,1),\n                                                               global:false,\n                                                               idents:~[str_to_ident(\"a\")],\n                                                               rp:None,\n@@ -378,7 +382,7 @@ mod test {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n                    @ast::expr{id:1,\n                                node:ast::expr_path(\n-                                   @ast::Path {span:sp(0,6),\n+                                    ast::Path {span:sp(0,6),\n                                                global:true,\n                                                idents:strs_to_idents(~[\"a\",\"b\"]),\n                                                rp:None,\n@@ -428,7 +432,7 @@ mod test {\n                               node:ast::expr_ret(\n                                   Some(@ast::expr{id:1,\n                                                   node:ast::expr_path(\n-                                                      @ast::Path{span:sp(7,8),\n+                                                       ast::Path{span:sp(7,8),\n                                                                  global:false,\n                                                                  idents:~[str_to_ident(\"d\")],\n                                                                  rp:None,\n@@ -444,7 +448,7 @@ mod test {\n                        node: ast::stmt_expr(@ast::expr{\n                            id: 1,\n                            node: ast::expr_path(\n-                               @ast::Path{\n+                                ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n                                    idents:~[str_to_ident(\"b\")],\n@@ -465,7 +469,7 @@ mod test {\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n                              node: ast::pat_ident(ast::bind_infer,\n-                                                  @ast::Path{\n+                                                   ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n                                                       idents:~[str_to_ident(\"b\")],\n@@ -482,19 +486,19 @@ mod test {\n         assert_eq!(parser.parse_arg_general(true),\n                    ast::arg{\n                        is_mutbl: false,\n-                       ty: @ast::Ty{id:3, // fixme\n-                                    node: ast::ty_path(@ast::Path{\n+                       ty: ast::Ty{id:3, // fixme\n+                                    node: ast::ty_path(ast::Path{\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @None, 2),\n+                                                       None, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n-                                                           @ast::Path{\n+                                                            ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n                                                                idents:~[str_to_ident(\"b\")],\n@@ -519,19 +523,19 @@ mod test {\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n                                     is_mutbl: false,\n-                                    ty: @ast::Ty{id:3, // fixme\n-                                                node: ast::ty_path(@ast::Path{\n+                                    ty: ast::Ty{id:3, // fixme\n+                                                node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @None, 2),\n+                                                       None, 2),\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n                                                        ast::bind_infer,\n-                                                       @ast::Path{\n+                                                       ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n                                                            idents:~[str_to_ident(\"b\")],\n@@ -542,7 +546,7 @@ mod test {\n                                                   span: sp(6,7)},\n                                     id: 4 // fixme\n                                 }],\n-                                output: @ast::Ty{id:5, // fixme\n+                                output: ast::Ty{id:5, // fixme\n                                                  node: ast::ty_nil,\n                                                  span:sp(15,15)}, // not sure\n                                 cf: ast::return_val\n@@ -561,7 +565,7 @@ mod test {\n                                                 node: ast::stmt_semi(@ast::expr{\n                                                     id: 6,\n                                                     node: ast::expr_path(\n-                                                        @ast::Path{\n+                                                          ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n                                                             idents:~[str_to_ident(\"b\")],"}, {"sha": "c43b350abdbf7b797aa13d8aaec56b3d06393ab7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 101, "deletions": 77, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -115,7 +115,7 @@ pub enum item_or_view_item {\n     iovi_none,\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n-    iovi_view_item(@view_item)\n+    iovi_view_item(view_item)\n }\n \n #[deriving(Eq)]\n@@ -130,20 +130,28 @@ The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n-        match *($p).token {\n-            INTERPOLATED(token::nt_expr(e)) => {\n-                $p.bump();\n-                return e;\n-            }\n-            INTERPOLATED(token::nt_path(pt)) => {\n-                $p.bump();\n-                return $p.mk_expr(\n-                    ($p).span.lo,\n-                    ($p).span.hi,\n-                    expr_path(pt)\n-                );\n+        {\n+            // This horrible convolution is brought to you by\n+            // @mut, have a terrible day\n+            let ret = match *($p).token {\n+                INTERPOLATED(token::nt_expr(e)) => {\n+                    Some(e)\n+                }\n+                INTERPOLATED(token::nt_path(ref pt)) => {\n+                    Some($p.mk_expr(\n+                        ($p).span.lo,\n+                        ($p).span.hi,\n+                        expr_path(/* bad */ copy *pt)))\n+                }\n+                _ => None\n+            };\n+            match ret {\n+                Some(e) => {\n+                    $p.bump();\n+                    return e;\n+                }\n+                None => ()\n             }\n-            _ => ()\n         }\n     )\n )\n@@ -208,7 +216,7 @@ fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n struct ParsedItemsAndViewItems {\n     attrs_remaining: ~[attribute],\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@item],\n     foreign_items: ~[@foreign_item]\n }\n@@ -264,7 +272,6 @@ pub struct Parser {\n     obsolete_set: @mut HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n     mod_path_stack: @mut ~[@str],\n-\n }\n \n #[unsafe_destructor]\n@@ -638,7 +645,7 @@ impl Parser {\n     // parse a ty_closure type\n     pub fn parse_ty_closure(&self,\n                             sigil: ast::Sigil,\n-                            region: Option<@ast::Lifetime>)\n+                            region: Option<ast::Lifetime>)\n                             -> ty_ {\n         /*\n \n@@ -816,7 +823,7 @@ impl Parser {\n     // parse a possibly mutable type\n     pub fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(false);\n+        let t = ~self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n@@ -827,7 +834,7 @@ impl Parser {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = ~self.parse_ty(false);\n         spanned(\n             lo,\n             ty.span.hi,\n@@ -839,13 +846,13 @@ impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n+    pub fn parse_ret_ty(&self) -> (ret_style, Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n                 (\n                     noreturn,\n-                    @Ty {\n+                    Ty {\n                         id: self.get_id(),\n                         node: ty_bot,\n                         span: mk_sp(lo, self.last_span.hi)\n@@ -858,7 +865,7 @@ impl Parser {\n             let pos = self.span.lo;\n             (\n                 return_val,\n-                @Ty {\n+                Ty {\n                     id: self.get_id(),\n                     node: ty_nil,\n                     span: mk_sp(pos, pos),\n@@ -870,7 +877,7 @@ impl Parser {\n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    pub fn parse_ty(&self, _: bool) -> @Ty {\n+    pub fn parse_ty(&self, _: bool) -> Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -960,14 +967,14 @@ impl Parser {\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n             let (path, bounds) = self.parse_type_path();\n-            ty_path(path, @bounds, self.get_id())\n+            ty_path(path, bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n                             *self.token));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        @Ty {id: self.get_id(), node: t, span: sp}\n+        Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n     // parse the type following a @ or a ~\n@@ -977,7 +984,7 @@ impl Parser {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n-                let lifetime = @self.parse_lifetime();\n+                let lifetime = self.parse_lifetime();\n                 self.bump();\n                 return self.parse_ty_closure(sigil, Some(lifetime));\n             }\n@@ -986,7 +993,7 @@ impl Parser {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n                     self.token_is_closure_keyword(&self.look_ahead(2u))\n                 {\n-                    let lifetime = @self.parse_lifetime();\n+                    let lifetime = self.parse_lifetime();\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                     return self.parse_ty_closure(sigil, Some(lifetime));\n                 } else if self.token_is_closure_keyword(&copy *self.token) {\n@@ -1108,7 +1115,7 @@ impl Parser {\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n-            @Ty {\n+            Ty {\n                 id: self.get_id(),\n                 node: ty_infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n@@ -1218,18 +1225,18 @@ impl Parser {\n     }\n \n     // parse a path that doesn't have type parameters attached\n-    pub fn parse_path_without_tps(&self) -> @ast::Path {\n+    pub fn parse_path_without_tps(&self) -> ast::Path {\n         maybe_whole!(self, nt_path);\n         let (ids,is_global,sp) = self.parse_path();\n-        @ast::Path { span: sp,\n+        ast::Path { span: sp,\n                      global: is_global,\n                      idents: ids,\n                      rp: None,\n                      types: ~[] }\n     }\n \n     pub fn parse_bounded_path_with_tps(&self, colons: bool,\n-                                        before_tps: Option<&fn()>) -> @ast::Path {\n+                                        before_tps: Option<&fn()>) -> ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -1255,7 +1262,7 @@ impl Parser {\n                     token::IDENT(sid, _) => {\n                         let span = copy self.span;\n                         self.bump();\n-                        Some(@ast::Lifetime {\n+                        Some(ast::Lifetime {\n                             id: self.get_id(),\n                             span: *span,\n                             ident: sid\n@@ -1280,30 +1287,30 @@ impl Parser {\n                 if v.len() == 0 {\n                     None\n                 } else if v.len() == 1 {\n-                    Some(@*v.get(0))\n+                    Some(*v.get(0))\n                 } else {\n                     self.fatal(fmt!(\"Expected at most one \\\n                                      lifetime name (for now)\"));\n                 }\n             }\n         };\n \n-        @ast::Path { span: mk_sp(lo, hi),\n+        ast::Path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n-                     .. copy *path }\n+                     .. path }\n     }\n \n     // parse a path optionally with type parameters. If 'colons'\n     // is true, then type parameters must be preceded by colons,\n     // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_path_with_tps(&self, colons: bool) -> ast::Path {\n         self.parse_bounded_path_with_tps(colons, None)\n     }\n \n     // Like the above, but can also parse kind bounds in the case of a\n     // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (@ast::Path, Option<OptVec<TyParamBound>>) {\n+    pub fn parse_type_path(&self) -> (ast::Path, Option<OptVec<TyParamBound>>) {\n         let mut bounds = None;\n         let path = self.parse_bounded_path_with_tps(false, Some(|| {\n             // Note: this closure might not even get called in the case of a\n@@ -1314,17 +1321,17 @@ impl Parser {\n     }\n \n     /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n+    pub fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n         match *self.token {\n             token::LIFETIME(*) => {\n-                Some(@self.parse_lifetime())\n+                Some(self.parse_lifetime())\n             }\n \n             // Also accept the (obsolete) syntax `foo/`\n             token::IDENT(*) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                    Some(@self.parse_lifetime())\n+                    Some(self.parse_lifetime())\n                 } else {\n                     None\n                 }\n@@ -1455,7 +1462,7 @@ impl Parser {\n     pub fn mk_method_call(&self,\n                       rcvr: @expr,\n                       ident: ident,\n-                      tps: ~[@Ty],\n+                      tps: ~[Ty],\n                       args: ~[@expr],\n                       sugar: CallSugar) -> ast::expr_ {\n         expr_method_call(self.get_id(), rcvr, ident, tps, args, sugar)\n@@ -1465,7 +1472,7 @@ impl Parser {\n         expr_index(self.get_id(), expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[@Ty]) -> ast::expr_ {\n+    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[Ty]) -> ast::expr_ {\n         expr_field(expr, ident, tys)\n     }\n \n@@ -1549,10 +1556,10 @@ impl Parser {\n         } else if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(keywords::For) {\n-            return self.parse_sugary_call_expr(~\"for\", ForSugar,\n+            return self.parse_sugary_call_expr(lo, ~\"for\", ForSugar,\n                                                expr_loop_body);\n         } else if self.eat_keyword(keywords::Do) {\n-            return self.parse_sugary_call_expr(~\"do\", DoSugar,\n+            return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n                                                expr_do_body);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n@@ -2207,7 +2214,7 @@ impl Parser {\n                     // No argument list - `do foo {`\n                       ast::fn_decl {\n                           inputs: ~[],\n-                          output: @Ty {\n+                          output: Ty {\n                               id: self.get_id(),\n                               node: ty_infer,\n                               span: *self.span\n@@ -2264,12 +2271,11 @@ impl Parser {\n     // parse a 'for' or 'do'.\n     // the 'for' and 'do' expressions parse as calls, but look like\n     // function calls followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&self,\n+    pub fn parse_sugary_call_expr(&self, lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n                                   ctor: &fn(v: @expr) -> expr_)\n                                   -> @expr {\n-        let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n         //    for foo.bar || {\n@@ -2286,21 +2292,21 @@ impl Parser {\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(copy *args, [last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n+                self.mk_expr(lo, block.span.hi, expr_call(f, args, sugar))\n             }\n             expr_method_call(_, f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(copy *args, [last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi,\n+                self.mk_expr(lo, block.span.hi,\n                              self.mk_method_call(f, i, copy *tps, args, sugar))\n             }\n             expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                self.mk_expr(lo.lo, block.span.hi,\n+                self.mk_expr(lo, block.span.hi,\n                              self.mk_method_call(f, i, copy *tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n@@ -2309,7 +2315,7 @@ impl Parser {\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(\n-                    lo.lo,\n+                    lo,\n                     last_arg.span.hi,\n                     self.mk_call(e, ~[last_arg], sugar))\n             }\n@@ -2319,7 +2325,7 @@ impl Parser {\n                 // but they aren't represented by tests\n                 debug!(\"sugary call on %?\", e.node);\n                 self.span_fatal(\n-                    *lo,\n+                    e.span,\n                     fmt!(\"`%s` must be followed by a block call\", keyword));\n             }\n         }\n@@ -2819,7 +2825,7 @@ impl Parser {\n             self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n         }\n \n-        let mut ty = @Ty {\n+        let mut ty = Ty {\n             id: self.get_id(),\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n@@ -3206,7 +3212,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = @opt_bounds.get_or_default(opt_vec::Empty);\n+        let bounds = opt_bounds.get_or_default(opt_vec::Empty);\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n@@ -3228,7 +3234,7 @@ impl Parser {\n \n     // parse a generic use site\n     fn parse_generic_values(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         if !self.eat(&token::LT) {\n             (opt_vec::Empty, ~[])\n@@ -3238,7 +3244,7 @@ impl Parser {\n     }\n \n     fn parse_generic_values_after_lt(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n@@ -3336,14 +3342,14 @@ impl Parser {\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        this.token_is_mutability(&this.look_ahead(2)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(3))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), mutability)\n@@ -3448,7 +3454,7 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            @Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n+            Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n         };\n \n         ast::fn_decl {\n@@ -3558,9 +3564,9 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, @None, node_id) => {\n-                    Some(@trait_ref {\n-                        path: path,\n+                ty_path(ref path, None, node_id) => {\n+                    Some(trait_ref {\n+                        path: /* bad */ copy *path,\n                         ref_id: node_id\n                     })\n                 }\n@@ -3601,15 +3607,15 @@ impl Parser {\n     }\n \n     // parse a::B<~str,int>\n-    fn parse_trait_ref(&self) -> @trait_ref {\n-        @ast::trait_ref {\n+    fn parse_trait_ref(&self) -> trait_ref {\n+        ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -3834,7 +3840,7 @@ impl Parser {\n         (id, item_static(ty, m, e), None)\n     }\n \n-    // parse a mod { ...}  item\n+    // parse a `mod <foo> { ... }` or `mod <foo>;` item\n     fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n@@ -3907,13 +3913,31 @@ impl Parser {\n             prefix.push_many(path.components)\n         };\n         let full_path = full_path.normalize();\n+\n+        let maybe_i = do self.sess.included_mod_stack.iter().position |&p| { p == full_path };\n+        match maybe_i {\n+            Some(i) => {\n+                let stack = &self.sess.included_mod_stack;\n+                let mut err = ~\"circular modules: \";\n+                for stack.slice(i, stack.len()).iter().advance |p| {\n+                    err.push_str(p.to_str());\n+                    err.push_str(\" -> \");\n+                }\n+                err.push_str(full_path.to_str());\n+                self.span_fatal(id_sp, err);\n+            }\n+            None => ()\n+        }\n+        self.sess.included_mod_stack.push(full_path.clone());\n+\n         let p0 =\n             new_sub_parser_from_file(self.sess, copy self.cfg,\n                                      &full_path, id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        self.sess.included_mod_stack.pop();\n         return (ast::item_mod(m0), mod_attrs);\n \n         fn cdir_path_opt(default: @str, attrs: ~[ast::attribute]) -> @str {\n@@ -4075,7 +4099,7 @@ impl Parser {\n         // extern mod foo;\n         let metadata = self.parse_optional_meta();\n         self.expect(&token::SEMI);\n-        iovi_view_item(@ast::view_item {\n+        iovi_view_item(ast::view_item {\n             node: view_item_extern_mod(ident, metadata, self.get_id()),\n             attrs: copy attrs,\n             vis: visibility,\n@@ -4148,9 +4172,9 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for arg_tys.iter().advance |ty| {\n+                for arg_tys.consume_iter().advance |ty| {\n                     args.push(ast::variant_arg {\n-                        ty: *ty,\n+                        ty: ty,\n                         id: self.get_id(),\n                     });\n                 }\n@@ -4309,7 +4333,7 @@ impl Parser {\n             // USE ITEM (iovi_view_item)\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n-            return iovi_view_item(@ast::view_item {\n+            return iovi_view_item(ast::view_item {\n                 node: view_item,\n                 attrs: attrs,\n                 vis: visibility,\n@@ -4559,7 +4583,7 @@ impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+            let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                     global: false,\n                                     idents: path,\n                                     rp: None,\n@@ -4589,7 +4613,7 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4601,7 +4625,7 @@ impl Parser {\n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4617,7 +4641,7 @@ impl Parser {\n           _ => ()\n         }\n         let last = path[path.len() - 1u];\n-        let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+        let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                 global: false,\n                                 idents: path,\n                                 rp: None,\n@@ -4657,7 +4681,7 @@ impl Parser {\n         &self,\n         attrs: ~[attribute],\n         vis: visibility\n-    ) -> @view_item {\n+    ) -> view_item {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(keywords::Use) {\n             self.parse_use()\n@@ -4670,7 +4694,7 @@ impl Parser {\n             self.bug(\"expected view item\");\n         };\n         self.expect(&token::SEMI);\n-        @ast::view_item { node: node,\n+        ast::view_item { node: node,\n                           attrs: attrs,\n                           vis: vis,\n                           span: mk_sp(lo, self.last_span.hi) }\n@@ -4688,7 +4712,7 @@ impl Parser {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n-        let mut view_items = ~[];\n+        let mut view_items : ~[ast::view_item] = ~[];\n         let mut items = ~[];\n         let mut done = false;\n         // I think this code would probably read better as a single"}, {"sha": "09d6ecb40fc0b86048fb54a8d3d9926812b93df2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -104,9 +104,9 @@ pub enum nonterminal {\n     nt_stmt(@ast::stmt),\n     nt_pat( @ast::pat),\n     nt_expr(@ast::expr),\n-    nt_ty(  @ast::Ty),\n+    nt_ty(   ast::Ty),\n     nt_ident(ast::ident, bool),\n-    nt_path(@ast::Path),\n+    nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n }"}, {"sha": "b545c56778e90d7be141cef85f0affd2fb82b581", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 120, "deletions": 121, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -34,9 +34,9 @@ use std::uint;\n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n     node_block(@ps, &'self ast::blk),\n-    node_item(@ps, @ast::item),\n-    node_expr(@ps, @ast::expr),\n-    node_pat(@ps, @ast::pat),\n+    node_item(@ps, &'self ast::item),\n+    node_expr(@ps, &'self ast::expr),\n+    node_pat(@ps, &'self ast::pat),\n }\n pub struct pp_ann {\n     pre: @fn(ann_node),\n@@ -106,7 +106,7 @@ pub static default_columns: uint = 78u;\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n                    span_diagnostic: @diagnostic::span_handler,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    filename: @str,\n                    in: @io::Reader,\n                    out: @io::Writer,\n@@ -136,41 +136,41 @@ pub fn print_crate(cm: @CodeMap,\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: @ps, crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, crate: &ast::crate) {\n     print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n \n-pub fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n+pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n     to_str(ty, print_type, intr)\n }\n \n-pub fn pat_to_str(pat: @ast::pat, intr: @ident_interner) -> ~str {\n+pub fn pat_to_str(pat: &ast::pat, intr: @ident_interner) -> ~str {\n     to_str(pat, print_irrefutable_pat, intr)\n }\n \n-pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n+pub fn expr_to_str(e: &ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n     to_str(e, print_lifetime, intr)\n }\n \n-pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n-    to_str(&tt, print_tt, intr)\n+pub fn tt_to_str(tt: &ast::token_tree, intr: @ident_interner) -> ~str {\n+    to_str(tt, print_tt, intr)\n }\n \n pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n-    to_str(tts, print_tts, intr)\n+    to_str(&tts, print_tts, intr)\n }\n \n pub fn stmt_to_str(s: &ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n-pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n+pub fn item_to_str(i: &ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n@@ -179,7 +179,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -208,11 +208,11 @@ pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn meta_item_to_str(mi: @ast::meta_item, intr: @ident_interner) -> ~str {\n+pub fn meta_item_to_str(mi: &ast::meta_item, intr: @ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n-pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n+pub fn attribute_to_str(attr: &ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n@@ -314,45 +314,44 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, \"*/\");\n }\n \n-pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.iter().advance |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        op(s, copy *elt);\n+        op(s, elt);\n     }\n     end(s);\n }\n \n \n-pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n-                               get_span: &fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n+                               get_span: &fn(&T) -> codemap::span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n     for elts.iter().advance |elt| {\n-        maybe_print_comment(s, get_span(copy *elt).hi);\n-        op(s, copy *elt);\n+        maybe_print_comment(s, get_span(elt).hi);\n+        op(s, elt);\n         i += 1u;\n         if i < len {\n             word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(copy *elt),\n-                                         Some(get_span(copy elts[i]).hi));\n+            maybe_print_trailing_comment(s, get_span(elt),\n+                                         Some(get_span(&elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n     end(s);\n }\n \n pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(expr: @ast::expr) -> codemap::span { return expr.span; }\n-    commasep_cmnt(s, b, exprs, print_expr, expr_span);\n+    commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.iter().advance |vitem| {\n-        print_view_item(s, *vitem);\n+        print_view_item(s, vitem);\n     }\n     for _mod.items.iter().advance |item| { print_item(s, *item); }\n }\n@@ -361,19 +360,19 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.iter().advance |vitem| {\n-        print_view_item(s, *vitem);\n+        print_view_item(s, vitem);\n     }\n     for nmod.items.iter().advance |item| { print_foreign_item(s, *item); }\n }\n \n-pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n+pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n     for lifetime.iter().advance |l| {\n-        print_lifetime(s, *l);\n+        print_lifetime(s, l);\n         nbsp(s);\n     }\n }\n \n-pub fn print_type(s: @ps, ty: @ast::Ty) {\n+pub fn print_type(s: @ps, ty: &ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -392,7 +391,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n         word(s.s, \"]\");\n       }\n       ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(lifetime, ref mt) => {\n+      ast::ty_rptr(ref lifetime, ref mt) => {\n           word(s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n@@ -408,18 +407,18 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n       ast::ty_bare_fn(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, Some(f.abis), None, None,\n+          print_ty_fn(s, Some(f.abis), None, &None,\n                       f.purity, ast::Many, &f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, None, Some(f.sigil), f.region,\n+          print_ty_fn(s, None, Some(f.sigil), &f.region,\n                       f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n-      ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n+      ast::ty_path(ref path, ref bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, \"[\");\n         match mt.mutbl {\n@@ -443,7 +442,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n     end(s);\n }\n \n-pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n+pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -455,7 +454,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n-      ast::foreign_item_static(t, m) => {\n+      ast::foreign_item_static(ref t, m) => {\n         head(s, \"static\");\n         if m {\n             word_space(s, \"mut\");\n@@ -470,14 +469,14 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: @ps, item: @ast::item) {\n+pub fn print_item(s: @ps, item: &ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n     match item.node {\n-      ast::item_static(ty, m, expr) => {\n+      ast::item_static(ref ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n         if m == ast::m_mutbl {\n             word_space(s, \"mut\");\n@@ -531,7 +530,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, ref params) => {\n+      ast::item_ty(ref ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, \"type\"));\n@@ -560,20 +559,20 @@ pub fn print_item(s: @ps, item: @ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      ast::item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n             space(s.s);\n         }\n \n         match opt_trait {\n-            Some(t) => {\n+            &Some(ref t) => {\n                 print_trait_ref(s, t);\n                 space(s.s);\n                 word_space(s, \"for\");\n             }\n-            None => ()\n+            &None => ()\n         };\n \n         print_type(s, ty);\n@@ -600,7 +599,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n                 if i != 0 {\n                     word_space(s, \"+\");\n                 }\n-                print_path(s, trait_.path, false);\n+                print_path(s, &trait_.path, false);\n             }\n         }\n         word(s.s, \" \");\n@@ -610,15 +609,15 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n         word(s.s, \"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &(tts.as_slice()));\n         pclose(s);\n         end(s);\n       }\n@@ -627,7 +626,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n }\n \n fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n-    print_path(s, t.path, false);\n+    print_path(s, &t.path, false);\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n@@ -681,7 +680,7 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n }\n \n pub fn print_struct(s: @ps,\n-                    struct_def: @ast::struct_def,\n+                    struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::ident,\n                     span: codemap::span) {\n@@ -695,7 +694,7 @@ pub fn print_struct(s: @ps,\n                     ast::named_field(*) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n-                        print_type(s, field.node.ty);\n+                        print_type(s, &field.node.ty);\n                     }\n                 }\n             }\n@@ -719,7 +718,7 @@ pub fn print_struct(s: @ps,\n                     print_visibility(s, visibility);\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n-                    print_type(s, field.node.ty);\n+                    print_type(s, &field.node.ty);\n                     word(s.s, \",\");\n                 }\n             }\n@@ -738,7 +737,7 @@ pub fn print_struct(s: @ps,\n /// expression arguments as expressions). It can be done! I think.\n pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     match *tt {\n-      ast::tt_delim(ref tts) => print_tts(s, *tts),\n+      ast::tt_delim(ref tts) => print_tts(s, &(tts.as_slice())),\n       ast::tt_tok(_, ref tk) => {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n@@ -759,7 +758,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.iter().enumerate().advance |(i, tt)| {\n         if i != 0 {\n@@ -777,8 +776,8 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n-                    print_type(s, arg.ty);\n+                fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n+                    print_type(s, &arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n@@ -804,7 +803,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, None, m.purity, ast::Many,\n+    print_ty_fn(s, None, None, &None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), &None, Some(&m.generics),\n                 Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, \";\");\n@@ -817,7 +816,7 @@ pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n     }\n }\n \n-pub fn print_method(s: @ps, meth: @ast::method) {\n+pub fn print_method(s: @ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n@@ -832,7 +831,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n-          ast::attr_outer => { print_attribute(s, *attr); count += 1; }\n+          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n     }\n@@ -844,7 +843,7 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n           ast::attr_inner => {\n-            print_attribute(s, *attr);\n+            print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, \";\");\n             }\n@@ -856,11 +855,11 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: ast::attribute) {\n+pub fn print_attribute(s: @ps, attr: &ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let meta = attr::attr_meta(attr);\n+        let meta = attr::attr_meta(*attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n         word(s.s, comment);\n     } else {\n@@ -947,7 +946,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.node.view_items.iter().advance |vi| { print_view_item(s, *vi); }\n+    for blk.node.view_items.iter().advance |vi| { print_view_item(s, vi); }\n     for blk.node.stmts.iter().advance |st| {\n         print_stmt(s, *st);\n     }\n@@ -963,7 +962,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n+pub fn print_if(s: @ps, test: &ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n@@ -1005,11 +1004,11 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n \n pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n-      ast::mac_invoc_tt(pth, ref tts) => {\n+      ast::mac_invoc_tt(ref pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, \"!\");\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &tts.as_slice());\n         pclose(s);\n       }\n     }\n@@ -1021,7 +1020,7 @@ pub fn print_vstore(s: @ps, t: ast::vstore) {\n         ast::vstore_fixed(None) => word(s.s, \"_\"),\n         ast::vstore_uniq => word(s.s, \"~\"),\n         ast::vstore_box => word(s.s, \"@\"),\n-        ast::vstore_slice(r) => {\n+        ast::vstore_slice(ref r) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n@@ -1088,15 +1087,15 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, expr: @ast::expr) {\n-    fn print_field(s: @ps, field: ast::field) {\n+pub fn print_expr(s: @ps, expr: &ast::expr) {\n+    fn print_field(s: @ps, field: &ast::field) {\n         ibox(s, indent_unit);\n         print_ident(s, field.node.ident);\n         word_space(s, \":\");\n         print_expr(s, field.node.expr);\n         end(s);\n     }\n-    fn get_span(field: ast::field) -> codemap::span { return field.span; }\n+    fn get_span(field: &ast::field) -> codemap::span { return field.span; }\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1134,7 +1133,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         end(s);\n       }\n \n-      ast::expr_struct(path, ref fields, wth) => {\n+      ast::expr_struct(ref path, ref fields, wth) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n@@ -1199,7 +1198,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, expr);\n       }\n       ast::expr_lit(lit) => print_literal(s, lit),\n-      ast::expr_cast(expr, ty) => {\n+      ast::expr_cast(expr, ref ty) => {\n         print_expr(s, expr);\n         space(s.s);\n         word_space(s, \"as\");\n@@ -1359,7 +1358,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, index);\n         word(s.s, \"]\");\n       }\n-      ast::expr_path(path) => print_path(s, path, true),\n+      ast::expr_path(ref path) => print_path(s, path, true),\n       ast::expr_self => word(s.s, \"self\"),\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n@@ -1434,15 +1433,15 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n     end(s);\n }\n \n-pub fn print_local_decl(s: @ps, loc: @ast::local) {\n+pub fn print_local_decl(s: @ps, loc: &ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n-      _ => { word_space(s, \":\"); print_type(s, loc.node.ty); }\n+      _ => { word_space(s, \":\"); print_type(s, &loc.node.ty); }\n     }\n }\n \n-pub fn print_decl(s: @ps, decl: @ast::decl) {\n+pub fn print_decl(s: @ps, decl: &ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::decl_local(ref loc) => {\n@@ -1454,7 +1453,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             word_nbsp(s, \"mut\");\n         }\n \n-        fn print_local(s: @ps, loc: @ast::local) {\n+        fn print_local(s: @ps, loc: &ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1479,14 +1478,14 @@ pub fn print_ident(s: @ps, ident: ast::ident) {\n     word(s.s, ident_to_str(&ident));\n }\n \n-pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n+pub fn print_for_decl(s: @ps, loc: &ast::local, coll: &ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n+fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n@@ -1505,7 +1504,7 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n             word(s.s, \"<\");\n \n             for path.rp.iter().advance |r| {\n-                print_lifetime(s, *r);\n+                print_lifetime(s, r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n                 }\n@@ -1518,32 +1517,32 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n     }\n }\n \n-pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: @ast::Path,\n+pub fn print_bounded_path(s: @ps, path: &ast::Path,\n                           bounds: &Option<OptVec<ast::TyParamBound>>) {\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n       ast::pat_wild => word(s.s, \"_\"),\n-      ast::pat_ident(binding_mode, path, sub) => {\n+      ast::pat_ident(binding_mode, ref path, sub) => {\n           if refutable {\n               match binding_mode {\n                   ast::bind_by_ref(mutbl) => {\n@@ -1562,31 +1561,31 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n               None => ()\n           }\n       }\n-      ast::pat_enum(path, ref args_) => {\n+      ast::pat_enum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n           None => word(s.s, \"(*)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n               commasep(s, inconsistent, *args,\n-                       |s, p| print_pat(s, p, refutable));\n+                       |s, &p| print_pat(s, p, refutable));\n               pclose(s);\n             } else { }\n           }\n         }\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n-        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: &ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n             print_pat(s, f.pat, refutable);\n             end(s);\n         }\n-        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n+        fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n@@ -1598,7 +1597,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -1625,7 +1624,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n-        do commasep(s, inconsistent, *before) |s, p| {\n+        do commasep(s, inconsistent, *before) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.iter().advance |&p| {\n@@ -1634,7 +1633,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             print_pat(s, p, refutable);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n-        do commasep(s, inconsistent, *after) |s, p| {\n+        do commasep(s, inconsistent, *after) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         word(s.s, \"]\");\n@@ -1643,8 +1642,8 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_interner) -> ~str {\n-    to_str(explicit_self, |a, b| { print_explicit_self(a, b); () }, intr)\n+pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n+    to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n@@ -1653,7 +1652,7 @@ pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, \"self\"); }\n         ast::sty_uniq => { word(s.s, \"~self\"); }\n-        ast::sty_region(lt, m) => {\n+        ast::sty_region(ref lt, m) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n@@ -1694,7 +1693,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n \n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n \n     end(s);\n@@ -1712,7 +1711,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n }\n@@ -1727,7 +1726,7 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n \n@@ -1748,7 +1747,7 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n             }\n \n             match *bound {\n-                TraitTyParamBound(tref) => print_trait_ref(s, tref),\n+                TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(s.s, \"'static\"),\n             }\n         }\n@@ -1774,7 +1773,7 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n                 print_ident(s, param.ident);\n-                print_bounds(s, param.bounds, false);\n+                print_bounds(s, &param.bounds, false);\n             }\n         }\n \n@@ -1784,12 +1783,12 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n         }\n \n         commasep(s, inconsistent, ints,\n-                 |s, i| print_item(s, generics, i));\n+                 |s, &i| print_item(s, generics, i));\n         word(s.s, \">\");\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: &ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, name),\n@@ -1804,18 +1803,18 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n         commasep(\n             s,\n             consistent,\n-            /* FIXME (#2543) */ copy *items,\n-            print_meta_item\n+            items.as_slice(),\n+            |p, &i| print_meta_item(p, i)\n         );\n         pclose(s);\n       }\n     }\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n-      ast::view_path_simple(ident, path, _) => {\n+      ast::view_path_simple(ident, ref path, _) => {\n         if path.idents[path.idents.len()-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);\n@@ -1824,12 +1823,12 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n         print_path(s, path, false);\n       }\n \n-      ast::view_path_glob(path, _) => {\n+      ast::view_path_glob(ref path, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::*\");\n       }\n \n-      ast::view_path_list(path, ref idents, _) => {\n+      ast::view_path_list(ref path, ref idents, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n         do commasep(s, inconsistent, (*idents)) |s, w| {\n@@ -1841,10 +1840,10 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n }\n \n pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n-    commasep(s, inconsistent, vps, print_view_path);\n+    commasep(s, inconsistent, vps, |p, &vp| print_view_path(p, vp));\n }\n \n-pub fn print_view_item(s: @ps, item: @ast::view_item) {\n+pub fn print_view_item(s: @ps, item: &ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1855,7 +1854,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n-                commasep(s, consistent, *mta, print_meta_item);\n+                commasep(s, consistent, *mta, |p, &i| print_meta_item(p, i));\n                 pclose(s);\n             }\n         }\n@@ -1883,7 +1882,7 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: @ps, input: ast::arg) {\n+pub fn print_arg(s: @ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n     if input.is_mutbl {\n         word_space(s, \"mut\");\n@@ -1892,7 +1891,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n       ast::ty_infer => print_irrefutable_pat(s, input.pat),\n       _ => {\n         match input.pat.node {\n-            ast::pat_ident(_, path, _) if\n+            ast::pat_ident(_, ref path, _) if\n                 path.idents.len() == 1 &&\n                 path.idents[0] == parse::token::special_idents::invalid => {\n                 // Do nothing.\n@@ -1903,7 +1902,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n                 space(s.s);\n             }\n         }\n-        print_type(s, input.ty);\n+        print_type(s, &input.ty);\n       }\n     }\n     end(s);\n@@ -1912,7 +1911,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n pub fn print_ty_fn(s: @ps,\n                    opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n-                   opt_region: Option<@ast::Lifetime>,\n+                   opt_region: &Option<ast::Lifetime>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl,\n@@ -1945,7 +1944,7 @@ pub fn print_ty_fn(s: @ps,\n     }\n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n     end(s);\n     pclose(s);\n@@ -1959,7 +1958,7 @@ pub fn print_ty_fn(s: @ps,\n             ibox(s, indent_unit);\n             word_space(s, \"->\");\n             if decl.cf == ast::noreturn { word_nbsp(s, \"!\"); }\n-            else { print_type(s, decl.output); }\n+            else { print_type(s, &decl.output); }\n             end(s);\n         }\n     }\n@@ -2003,7 +2002,7 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, lit: @ast::lit) {\n+pub fn print_literal(s: @ps, lit: &ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2056,7 +2055,7 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n     }\n }\n \n-pub fn lit_to_str(l: @ast::lit) -> ~str {\n+pub fn lit_to_str(l: &ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n@@ -2139,10 +2138,10 @@ pub fn print_string(s: @ps, st: &str) {\n     word(s.s, \"\\\"\");\n }\n \n-pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        f(s, copy t);\n+        f(s, t);\n         eof(s.s);\n     }\n }\n@@ -2273,7 +2272,7 @@ mod test {\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n-            output: @ast::Ty {id: 0,\n+            output: ast::Ty {id: 0,\n                               node: ast::ty_nil,\n                               span: codemap::dummy_sp()},\n             cf: ast::return_val"}, {"sha": "7cb211a402b49a27b419f342f0508fc79ace8206", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -14,13 +14,14 @@\n  */\n \n #[link(name = \"syntax\",\n-       vers = \"0.7\",\n+       vers = \"0.8-pre\",\n        uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];\n \n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n #[allow(non_camel_case_types)];\n+#[allow(non_uppercase_statics)];\n #[deny(deprecated_pattern)];\n \n extern mod extra;"}, {"sha": "b2d9d49f0ee77eed8610ac37a28c494b9ca35f04", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -72,7 +72,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n \n pub struct Visitor<E> {\n     visit_mod: @fn(&_mod, span, node_id, (E, vt<E>)),\n-    visit_view_item: @fn(@view_item, (E, vt<E>)),\n+    visit_view_item: @fn(&view_item, (E, vt<E>)),\n     visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n     visit_item: @fn(@item, (E, vt<E>)),\n     visit_local: @fn(@local, (E, vt<E>)),\n@@ -83,14 +83,13 @@ pub struct Visitor<E> {\n     visit_decl: @fn(@decl, (E, vt<E>)),\n     visit_expr: @fn(@expr, (E, vt<E>)),\n     visit_expr_post: @fn(@expr, (E, vt<E>)),\n-    visit_ty: @fn(@Ty, (E, vt<E>)),\n+    visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id, (E, vt<E>)),\n     visit_ty_method: @fn(&ty_method, (E, vt<E>)),\n     visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n     visit_struct_def: @fn(@struct_def, ident, &Generics, node_id, (E, vt<E>)),\n     visit_struct_field: @fn(@struct_field, (E, vt<E>)),\n-    visit_struct_method: @fn(@method, (E, vt<E>))\n }\n \n pub type visitor<E> = @Visitor<E>;\n@@ -116,7 +115,6 @@ pub fn default_visitor<E: Copy>() -> visitor<E> {\n         visit_trait_method: |a,b|visit_trait_method::<E>(a, b),\n         visit_struct_def: |a,b,c,d,e|visit_struct_def::<E>(a, b, c, d, e),\n         visit_struct_field: |a,b|visit_struct_field::<E>(a, b),\n-        visit_struct_method: |a,b|visit_struct_method::<E>(a, b)\n     };\n }\n \n@@ -125,28 +123,28 @@ pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+    for m.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n     for m.items.iter().advance |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n \n pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n     (v.visit_pat)(loc.node.pat, (copy e, v));\n-    (v.visit_ty)(loc.node.ty, (copy e, v));\n+    (v.visit_ty)(&loc.node.ty, (copy e, v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n     }\n }\n \n fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n-    visit_path(tref.path, (e, v));\n+    visit_path(&tref.path, (e, v));\n }\n \n pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n     match i.node {\n-        item_static(t, _, ex) => {\n+        item_static(ref t, _, ex) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n         }\n@@ -168,10 +166,10 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n             for nm.items.iter().advance |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n-        item_ty(t, ref tps) => {\n+        item_ty(ref t, ref tps) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_generics)(tps, (e, v));\n         }\n@@ -183,9 +181,9 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n                 (e, v)\n             );\n         }\n-        item_impl(ref tps, ref traits, ty, ref methods) => {\n+        item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (copy e, v));\n-            for traits.iter().advance |&p| {\n+            for traits.iter().advance |p| {\n                 visit_trait_ref(p, (copy e, v));\n             }\n             (v.visit_ty)(ty, (copy e, v));\n@@ -199,7 +197,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (copy e, v));\n-            for traits.iter().advance |p| { visit_path(p.path, (copy e, v)); }\n+            for traits.iter().advance |p| { visit_path(&p.path, (copy e, v)); }\n             for methods.iter().advance |m| {\n                 (v.visit_trait_method)(m, (copy e, v));\n             }\n@@ -215,7 +213,7 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n                 for variant_args.iter().advance |va| {\n-                    (v.visit_ty)(va.ty, (copy e, v));\n+                    (v.visit_ty)(&va.ty, (copy e, v));\n                 }\n             }\n             struct_variant_kind(struct_def) => {\n@@ -234,27 +232,27 @@ pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n \n pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n-        ty_box(mt) | ty_uniq(mt) |\n-        ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n+        ty_box(ref mt) | ty_uniq(ref mt) |\n+        ty_vec(ref mt) | ty_ptr(ref mt) | ty_rptr(_, ref mt) => {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n             for ts.iter().advance |tt| {\n-                (v.visit_ty)(*tt, (copy e, v));\n+                (v.visit_ty)(tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (copy e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (copy e, v));\n             do f.bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (e, v));\n         },\n-        ty_path(p, bounds, _) => {\n+        ty_path(ref p, ref bounds, _) => {\n             visit_path(p, (copy e, v));\n             do bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n@@ -269,20 +267,20 @@ pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n+    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n-        pat_enum(path, ref children) => {\n+        pat_enum(ref path, ref children) => {\n             visit_path(path, (copy e, v));\n             for children.iter().advance |children| {\n                 for children.iter().advance |child| {\n                     (v.visit_pat)(*child, (copy e, v));\n                 }\n             }\n         }\n-        pat_struct(path, ref fields, _) => {\n+        pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (copy e, v));\n             for fields.iter().advance |f| {\n                 (v.visit_pat)(f.pat, (copy e, v));\n@@ -296,7 +294,7 @@ pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n-        pat_ident(_, path, ref inner) => {\n+        pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (copy e, v));\n             for inner.iter().advance |subpat| {\n                 (v.visit_pat)(*subpat, (copy e, v))\n@@ -328,7 +326,7 @@ pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n             visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n-        foreign_item_static(t, _) => {\n+        foreign_item_static(ref t, _) => {\n             (v.visit_ty)(t, (e, v));\n         }\n     }\n@@ -338,24 +336,24 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.iter().advance |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n+            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.iter().advance |tp| {\n-        visit_ty_param_bounds(tp.bounds, (copy e, v));\n+        visit_ty_param_bounds(&tp.bounds, (copy e, v));\n     }\n }\n \n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.iter().advance |a| {\n         (v.visit_pat)(a.pat, (copy e, v));\n-        (v.visit_ty)(a.ty, (copy e, v));\n+        (v.visit_ty)(&a.ty, (copy e, v));\n     }\n-    (v.visit_ty)(fd.output, (e, v));\n+    (v.visit_ty)(&fd.output, (e, v));\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -386,9 +384,9 @@ pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n     (v.visit_generics)(&m.generics, (copy e, v));\n-    (v.visit_ty)(m.decl.output, (e, v));\n+    (v.visit_ty)(&m.decl.output, (e, v));\n }\n \n pub fn visit_trait_method<E: Copy>(m: &trait_method, (e, v): (E, vt<E>)) {\n@@ -411,16 +409,12 @@ pub fn visit_struct_def<E: Copy>(\n }\n \n pub fn visit_struct_field<E: Copy>(sf: &struct_field, (e, v): (E, vt<E>)) {\n-    (v.visit_ty)(sf.node.ty, (e, v));\n-}\n-\n-pub fn visit_struct_method<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n-    visit_method_helper(m, (e, v));\n+    (v.visit_ty)(&sf.node.ty, (e, v));\n }\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.node.view_items.iter().advance |vi| {\n-        (v.visit_view_item)(*vi, (copy e, v));\n+        (v.visit_view_item)(vi, (copy e, v));\n     }\n     for b.node.stmts.iter().advance |s| {\n         (v.visit_stmt)(*s, (copy e, v));\n@@ -464,7 +458,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(element, (copy e, v));\n             (v.visit_expr)(count, (copy e, v));\n         }\n-        expr_struct(p, ref flds, base) => {\n+        expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (copy e, v));\n             for flds.iter().advance |f| {\n                 (v.visit_expr)(f.node.expr, (copy e, v));\n@@ -481,7 +475,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n             (v.visit_expr)(callee, (copy e, v));\n         }\n@@ -492,7 +486,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n         expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_lit(_) => (),\n-        expr_cast(x, t) => {\n+        expr_cast(x, ref t) => {\n             (v.visit_expr)(x, (copy e, v));\n             (v.visit_ty)(t, (copy e, v));\n         }\n@@ -533,14 +527,14 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n         }\n         expr_index(_, a, b) => {\n             (v.visit_expr)(a, (copy e, v));\n             (v.visit_expr)(b, (copy e, v));\n         }\n-        expr_path(p) => visit_path(p, (copy e, v)),\n+        expr_path(ref p) => visit_path(p, (copy e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n@@ -574,7 +568,7 @@ pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n \n pub struct SimpleVisitor {\n     visit_mod: @fn(&_mod, span, node_id),\n-    visit_view_item: @fn(@view_item),\n+    visit_view_item: @fn(&view_item),\n     visit_foreign_item: @fn(@foreign_item),\n     visit_item: @fn(@item),\n     visit_local: @fn(@local),\n@@ -585,7 +579,7 @@ pub struct SimpleVisitor {\n     visit_decl: @fn(@decl),\n     visit_expr: @fn(@expr),\n     visit_expr_post: @fn(@expr),\n-    visit_ty: @fn(@Ty),\n+    visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id),\n     visit_ty_method: @fn(&ty_method),\n@@ -597,7 +591,7 @@ pub struct SimpleVisitor {\n \n pub type simple_visitor = @SimpleVisitor;\n \n-pub fn simple_ignore_ty(_t: @Ty) {}\n+pub fn simple_ignore_ty(_t: &Ty) {}\n \n pub fn default_simple_visitor() -> @SimpleVisitor {\n     @SimpleVisitor {\n@@ -635,7 +629,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m, sp, id);\n         visit_mod(m, sp, id, (e, v));\n     }\n-    fn v_view_item(f: @fn(@view_item), vi: @view_item, (e, v): ((), vt<()>)) {\n+    fn v_view_item(f: @fn(&view_item), vi: &view_item, (e, v): ((), vt<()>)) {\n         f(vi);\n         visit_view_item(vi, (e, v));\n     }\n@@ -678,7 +672,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_expr_post(f: @fn(@expr), ex: @expr, (_e, _v): ((), vt<()>)) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, (e, v): ((), vt<()>)) {\n+    fn v_ty(f: @fn(&Ty), ty: &Ty, (e, v): ((), vt<()>)) {\n         f(ty);\n         visit_ty(ty, (e, v));\n     }\n@@ -723,16 +717,12 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, (e, v));\n     }\n-    let visit_ty: @fn(@Ty, ((), vt<()>)) =\n+    let visit_ty: @fn(&Ty, ((), vt<()>)) =\n         |a,b| v_ty(v.visit_ty, a, b);\n     fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, (e, v): ((), vt<()>)) {\n         f(sf);\n         visit_struct_field(sf, (e, v));\n     }\n-    fn v_struct_method(f: @fn(@method), m: @method, (e, v): ((), vt<()>)) {\n-        f(m);\n-        visit_struct_method(m, (e, v));\n-    }\n     return mk_vt(@Visitor {\n         visit_mod: |a,b,c,d|v_mod(v.visit_mod, a, b, c, d),\n         visit_view_item: |a,b| v_view_item(v.visit_view_item, a, b),\n@@ -760,7 +750,5 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n             v_struct_def(v.visit_struct_def, a, b, c, d, e),\n         visit_struct_field: |a,b|\n             v_struct_field(v.visit_struct_field, a, b),\n-        visit_struct_method: |a,b|\n-            v_struct_method(v.visit_struct_method, a, b)\n     });\n }"}, {"sha": "95e38a9903c4bd39913921a00949a9fd9491d3dc", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -13,10 +13,11 @@\n #include <malloc.h>\n #endif\n \n+#include \"uv.h\"\n+\n #include \"rust_globals.h\"\n #include \"rust_task.h\"\n #include \"rust_log.h\"\n-#include \"uv.h\"\n \n // extern fn pointers\n typedef void (*extern_async_op_cb)(uv_loop_t* loop, void* data,"}, {"sha": "9b8f0e3a46214d9585abfc862cd478df702129e2", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-6-29-2013\n+2013-07-03"}, {"sha": "7ae648f113a38d0f5808da755b09e5ec260bc50a", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1,5 +1,7 @@\n #[allow(default_methods)];\n \n+pub struct Something { x: int }\n+\n pub trait A {\n     fn f(&self) -> int;\n     fn g(&self) -> int { 10 }\n@@ -11,6 +13,10 @@ impl A for int {\n     fn f(&self) -> int { 10 }\n }\n \n+impl A for Something {\n+    fn f(&self) -> int { 10 }\n+}\n+\n trait B<T> {\n     fn thing<U>(&self, x: T, y: U) -> (T, U) { (x, y) }\n }"}, {"sha": "867be38545cdfe9256559a3c8c3b0f20b3ad7ce9", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -44,7 +44,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     if os::getenv(~\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.iter().any_(|x| x == &~\"all\") || argv.iter().any_(|x| x == &name)\n+        run_test = argv.iter().any(|x| x == &~\"all\") || argv.iter().any(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "47de9334be15c039a794bbfc73126706f1edfa64", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -95,13 +95,13 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         }\n     }\n \n-    do vec::map_consume(graph) |mut v| {\n+    do graph.consume_iter().transform |mut v| {\n         let mut vec = ~[];\n         do v.consume |i| {\n             vec.push(i);\n         }\n         vec\n-    }\n+    }.collect()\n }\n \n fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n@@ -111,7 +111,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && graph[k].iter().any_(|i| {\n+        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n             *i != k as node_id\n         }) {\n             keys.insert(k as node_id);\n@@ -187,7 +187,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     let mut i = 0;\n-    while colors.iter().any_(is_gray) {\n+    while colors.iter().any(is_gray) {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n@@ -402,7 +402,7 @@ fn validate(edges: ~[(node_id, node_id)],\n             if *v == -1i64 || u == root {\n                 true\n             } else {\n-                edges.iter().any_(|x| x == &(u, *v)) || edges.iter().any_(|x| x == &(*v, u))\n+                edges.iter().any(|x| x == &(u, *v)) || edges.iter().any(|x| x == &(*v, u))\n             }\n         };\n         result"}, {"sha": "abc44dfbc9bb71d9830338cf4b157bdda46ec34c", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -96,7 +96,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 fn_box: || @Cons((), fn_box()),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + [@Cons((), *st.vec.last())],\n+                vec: st.vec + &[@Cons((), *st.vec.last())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}, {"sha": "1cd90962c5b796b851b721f4b88fddb04f8a2530", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -28,20 +28,21 @@ fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n         wait_port\n     };\n \n-    let child_start_chans: ~[Chan<Chan<int>>] = vec::map_consume(wait_ports, |port| port.recv());\n+    let child_start_chans: ~[Chan<Chan<int>>] =\n+        wait_ports.consume_iter().transform(|port| port.recv()).collect();\n \n     let (start_port, start_chan) = stream::<Chan<int>>();\n     parent_wait_chan.send(start_chan);\n     let parent_result_chan: Chan<int> = start_port.recv();\n \n-    let child_sum_ports: ~[Port<int>] = do vec::map_consume(child_start_chans) |child_start_chan| {\n-        let (child_sum_port, child_sum_chan) = stream::<int>();\n-        child_start_chan.send(child_sum_chan);\n-        child_sum_port\n-    };\n+    let child_sum_ports: ~[Port<int>] =\n+        do child_start_chans.consume_iter().transform |child_start_chan| {\n+            let (child_sum_port, child_sum_chan) = stream::<int>();\n+            child_start_chan.send(child_sum_chan);\n+            child_sum_port\n+    }.collect();\n \n-    let mut sum = 0;\n-    vec::consume(child_sum_ports, |_, sum_port| sum += sum_port.recv() );\n+    let sum = child_sum_ports.consume_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n \n     parent_result_chan.send(sum + 1);\n }"}, {"sha": "ac5a4c220a4a6ef742c2fa57d12a4bb7d2f5d093", "filename": "src/test/compile-fail/bad-env-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: attempted dynamic environment-capture\n+// error-pattern: can't capture dynamic environment in a fn item;\n fn foo() {\n     let x: int;\n     fn bar() { log(debug, x); }"}, {"sha": "c97069acd9aeeaffc21d18555febacff795ae3c3", "filename": "src/test/compile-fail/bad-env-capture2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: attempted dynamic environment-capture\n+// error-pattern: can't capture dynamic environment in a fn item;\n fn foo(x: int) {\n     fn bar() { log(debug, x); }\n }"}, {"sha": "e3a6ac2cdfc4feef83b87e1adc9f88d4dee8f81b", "filename": "src/test/compile-fail/bad-env-capture3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: attempted dynamic environment-capture\n+// error-pattern: can't capture dynamic environment in a fn item;\n fn foo(x: int) {\n     fn mth() {\n         fn bar() { log(debug, x); }"}, {"sha": "706edd0a112b8794af92dc2ada90649a0c6de36b", "filename": "src/test/compile-fail/capture1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture1.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -10,7 +10,7 @@\n // except according to those terms.\n \n \n-// error-pattern: attempted dynamic environment-capture\n+// error-pattern: can't capture dynamic environment in a fn item;\n \n fn main() {\n     let bar: int = 5;"}, {"sha": "261fa489f610160ad0fac82864d368bd5ac8628c", "filename": "src/test/compile-fail/circular_modules_hello.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcircular_modules_hello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcircular_modules_hello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_hello.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test: this is an auxiliary file for circular-modules-main.rs\n+\n+mod circular_modules_main;\n+\n+pub fn say_hello() {\n+  println(circular_modules_main::hi_str());\n+}"}, {"sha": "06b5854f42c824f18c439cb6147188a13a72aa5a", "filename": "src/test/compile-fail/circular_modules_main.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcircular_modules_main.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+mod circular_modules_hello; //~ERROR: circular modules\n+\n+pub fn hi_str() -> ~str {\n+  ~\"Hi!\"\n+}\n+\n+fn main() {\n+    circular_modules_hello::say_hello();\n+}"}, {"sha": "bfb1e910495dedfa24e90c14fec9589b71131a56", "filename": "src/test/compile-fail/closure-bounds-cant-mutably-borrow-with-copy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-mutably-borrow-with-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-mutably-borrow-with-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-mutably-borrow-with-copy.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "previous_filename": "src/test/compile-fail/the-case-of-the-recurring-closure-2.rs"}, {"sha": "641403fb85a148eb913883981857c78c2c8baa60", "filename": "src/test/compile-fail/issue-3021-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -18,7 +18,7 @@ fn siphash(k0 : u64) {\n \n     impl siphash {\n         pub fn reset(&mut self) {\n-           self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR attempted dynamic environment-capture\n+           self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n            //~^ ERROR unresolved name `k0`.\n         }\n     }"}, {"sha": "c5ee9e8bb90e1b9330a4b524f44e47941839acee", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -30,9 +30,9 @@ fn siphash(k0 : u64, k1 : u64) -> siphash {\n \n    impl siphash for SipState {\n         fn reset(&self) {\n-            self.v0 = k0 ^ 0x736f6d6570736575;  //~ ERROR attempted dynamic environment-capture\n+            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n             //~^ ERROR unresolved name `k0`.\n-            self.v1 = k1 ^ 0x646f72616e646f6d;   //~ ERROR attempted dynamic environment-capture\n+            self.v1 = k1 ^ 0x646f72616e646f6d; //~ ERROR can't capture dynamic environment\n             //~^ ERROR unresolved name `k1`.\n         }\n         fn result(&self) -> u64 { return mk_result(self); }"}, {"sha": "56ade814db0207bf60ff70c2a245ec00064e4365", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -21,7 +21,7 @@ fn siphash(k0 : u64) -> SipHash {\n \n     impl SipHash for SipState {\n         fn reset(&self) {\n-           self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR attempted dynamic environment-capture\n+           self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n            //~^ ERROR unresolved name `k0`.\n         }\n     }"}, {"sha": "310de3657b385e06bc2b7177cd20c85aa7d3d8a2", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do needlesArr.iter().fold() |x, y| {\n     }\n-    //~^ ERROR 1 parameter was supplied (including the closure passed by the `do` keyword)\n+    //~^^ ERROR 1 parameter was supplied (including the closure passed by the `do` keyword)\n     //\n     // the first error is, um, non-ideal.\n }"}, {"sha": "4da4d3ada384eb20b2dfb1927a88eb451513d831", "filename": "src/test/compile-fail/lint-non-uppercase-statics.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[forbid(non_uppercase_statics)];\n+\n+static foo: int = 1; //~ ERROR static constant should have an uppercase identifier\n+\n+fn main() { }"}, {"sha": "e7e01a40487214b4257a13326ca8f50fb7267888", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -30,7 +30,7 @@ use std::io::WriterUtil;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{filter, from_elem};   //~ ERROR unused import\n+use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n \n mod foo {\n     pub struct Point{x: int, y: int}"}, {"sha": "f05c30c3355e0830b57d1425204ad4fd22a1e4fd", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "previous_filename": "src/test/compile-fail/the-case-of-the-recurring-closure.rs"}, {"sha": "6d5bb638be69bd3bd885627cfc030b1cecc60de6", "filename": "src/test/compile-fail/moves-based-on-type-tuple.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-tuple.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "previous_filename": "src/test/compile-fail/move-based-on-type-tuple.rs"}, {"sha": "699a30ad4ebdd72d330e36173a32bfcc09f0e7b1", "filename": "src/test/compile-fail/resolve-unknown-trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+trait NewTrait : SomeNonExistentTrait {}\n+//~^ ERROR attempt to derive a nonexistent trait `SomeNonExistentTrait`\n+\n+impl SomeNonExistentTrait for int {}\n+//~^ ERROR attempt to implement a nonexistent trait `SomeNonExistentTrait`\n+\n+fn f<T:SomeNonExistentTrait>() {}\n+//~^ ERROR attempt to bound type parameter with a nonexistent trait `SomeNonExistentTrait`\n+"}, {"sha": "019a4b88aedfd0b2983aa6a3643afd49cab610e0", "filename": "src/test/compile-fail/static-assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1,5 +1,5 @@\n #[static_assert]\n-static a: bool = false; //~ ERROR static assertion failed\n+static A: bool = false; //~ ERROR static assertion failed\n \n fn main() {\n }"}, {"sha": "42e475dac8b6718e35a650ad1a35432517ed2ee1", "filename": "src/test/compile-fail/static-assert2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -1,4 +1,4 @@\n #[static_assert]\n-static e: bool = 1 == 2; //~ ERROR static assertion failed\n+static E: bool = 1 == 2; //~ ERROR static assertion failed\n \n fn main() {}"}, {"sha": "c666950034a01072075b9b54b02612d2fd4ad4cb", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -108,7 +108,6 @@\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-     // <= bugs in pretty-printer?\n     for chars.iter().advance |c| {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\" , c , ws));"}, {"sha": "f0d46f39cdf9cba980bed076165c9fcf9df21fb9", "filename": "src/test/pretty/block-comment-wchar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs?ref=fae33367692c634356d861dc4badb967dc72a573", "patch": "@@ -104,6 +104,6 @@ fn main() {\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n     for chars.iter().advance |c| {\n         let ws = c.is_whitespace();\n-        println(fmt!(\"%? %?\", c , ws)); // <= bugs in pretty-printer?\n+        println(fmt!(\"%? %?\", c , ws));\n     }\n }"}, {"sha": "15631337d2a44f8490bf712a16cb9da827081156", "filename": "src/test/pretty/for-comment.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Ffor-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Fpretty%2Ffor-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffor-comment.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "0fdaf31c59361a13adb460e4a98878331cca8d0c", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "466f2def290bf60bf2afadb9435281c75c38fedd", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "532b2312a987101e8da24c65f948ee45224564cd", "filename": "src/test/run-pass/bug-7183-generics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-7183-generics.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "8bb57ebaaf58d3cf6d6ef3372846309c4a419f0c", "filename": "src/test/run-pass/closure-bounds-recursive-stack-closure.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fclosure-bounds-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fclosure-bounds-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-recursive-stack-closure.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "d09ef3bc25c3a45d3ecf1a4579f1a63dafafeff9", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "8c1dc366f23284db89b46f7b742a5a1f562310b6", "filename": "src/test/run-pass/lint-non-camel-case-types-non-uppercase-statics-unicode.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "3a3648fbf6d8342809122865b04803058e7d667b", "filename": "src/test/run-pass/lint-non-uppercase-statics-lowercase-mut-statics.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "d2407f3d6059bbe0c4ab8be4f6cc4f206677a3df", "filename": "src/test/run-pass/newtype-temporary.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "53b39d5ed3038876612bf21144ae9d9277e02d40", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "4ce229526ffbaf865b9178ca64526129eafdaf80", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "6e6670e4c38e9c8fc41843615474def34810d885", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "4eac1a1e7308fa775686289fc9d613898349f8a2", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}, {"sha": "e23fccb28f15117b09ce0c8c433112a51ff2d522", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae33367692c634356d861dc4badb967dc72a573/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=fae33367692c634356d861dc4badb967dc72a573"}]}