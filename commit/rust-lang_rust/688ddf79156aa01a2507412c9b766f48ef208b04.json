{"sha": "688ddf79156aa01a2507412c9b766f48ef208b04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OGRkZjc5MTU2YWEwMWEyNTA3NDEyYzliNzY2ZjQ4ZWYyMDhiMDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-12T15:47:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-15T19:28:12Z"}, "message": "typeck/kind -- stop using old trait framework.\n\n- Unify the \"well-formedness\" checking that typeck was already doing with what\n  was taking place in kind.\n- Move requirements that things be sized into typeck.\n- I left the checking on upvars in kind, though I think it should eventually be\n  refactored into regionck (which would perhaps be renamed).\n\nThis reflects a general plan to convert typeck so that it registers\nobligations or other pending things for conditions it cannot check\neventually. This makes it easier to identify all the conditions that\napply to an AST expression, but can also influence inference in somec\ncases (e.g., `Send` implies `'static`, so I already had to promote a lot\nof the checking that `kind.rs` was doing into typeck, this branch just\ncontinues the process).", "tree": {"sha": "4d8fc6a10ba98534517a66e4ae6d1fa1df2e3d06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d8fc6a10ba98534517a66e4ae6d1fa1df2e3d06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688ddf79156aa01a2507412c9b766f48ef208b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688ddf79156aa01a2507412c9b766f48ef208b04", "html_url": "https://github.com/rust-lang/rust/commit/688ddf79156aa01a2507412c9b766f48ef208b04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688ddf79156aa01a2507412c9b766f48ef208b04/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088c94ae96aa139db6b6f0c5640c720ff107ee0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/088c94ae96aa139db6b6f0c5640c720ff107ee0f", "html_url": "https://github.com/rust-lang/rust/commit/088c94ae96aa139db6b6f0c5640c720ff107ee0f"}], "stats": {"total": 3071, "additions": 1271, "deletions": 1800}, "files": [{"sha": "aeb0c155a3f4851ea100ff3904c671b4d6945892", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 46, "deletions": 437, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -10,50 +10,30 @@\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n+use middle::mem_categorization::Typer;\n use middle::subst;\n-use middle::ty::ParameterEnvironment;\n use middle::ty;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold;\n-use middle::typeck::check::vtable;\n-use middle::typeck::{MethodCall, NoAdjustment};\n-use middle::typeck;\n-use util::ppaux::{Repr, ty_to_string};\n+use util::ppaux::{ty_to_string};\n use util::ppaux::UserString;\n \n-use std::collections::HashSet;\n use syntax::ast::*;\n-use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::print::pprust::{expr_to_string, ident_to_string};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-// Kind analysis pass.\n-//\n-// There are several kinds defined by various operations. The most restrictive\n-// kind is noncopyable. The noncopyable kind can be extended with any number\n-// of the following attributes.\n-//\n-//  Send: Things that can be sent on channels or included in spawned closures. It\n-//  includes scalar types as well as classes and unique types containing only\n-//  sendable types.\n-//  'static: Things that do not contain references.\n-//\n-// This pass ensures that type parameters are only instantiated with types\n-// whose kinds are equal or less general than the way the type parameter was\n-// annotated (with the `Send` bound).\n-//\n-// It also verifies that noncopyable kinds are not copied. Sendability is not\n-// applied, since none of our language primitives send. Instead, the sending\n-// primitives in the stdlib are explicitly annotated to only take sendable\n-// types.\n+// Kind analysis pass. This pass does some ad-hoc checks that are more\n+// convenient to do after type checking is complete and all checks are\n+// known. These are generally related to the builtin bounds `Copy` and\n+// `Sized`. Note that many of the builtin bound properties that used\n+// to be checked here are actually checked by trait checking these\n+// days.\n \n-pub struct Context<'a, 'tcx: 'a> {\n+pub struct Context<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    struct_and_enum_bounds_checked: HashSet<ty::t>,\n-    parameter_environments: Vec<ParameterEnvironment>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n@@ -77,17 +57,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_pat(&mut self, p: &Pat) {\n         check_pat(self, p);\n     }\n-\n-    fn visit_local(&mut self, l: &Local) {\n-        check_local(self, l);\n-    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut ctx = Context {\n         tcx: tcx,\n-        struct_and_enum_bounds_checked: HashSet::new(),\n-        parameter_environments: Vec::new(),\n     };\n     visit::walk_crate(&mut ctx, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n@@ -135,27 +109,11 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_trait_def.def_id();\n-    let trait_def = cx.tcx.trait_defs.borrow()\n-                          .find_copy(&trait_def_id)\n-                          .expect(\"trait def not in trait-defs map!\");\n-\n-    // If this trait has builtin-kind supertraits, meet them.\n-    let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug!(\"checking impl with self type {}\", ty::get(self_ty).sty);\n-    check_builtin_bounds(\n-        cx, self_ty, trait_def.bounds.builtin_bounds,\n-        |missing| {\n-            span_err!(cx.tcx.sess, self_type.span, E0142,\n-                      \"the type `{}', which does not fulfill `{}`, \\\n-                       cannot implement this trait\",\n-                      ty_to_string(cx.tcx, self_ty), missing.user_string(cx.tcx));\n-            span_note!(cx.tcx.sess, self_type.span,\n-                       \"types implementing this trait must fulfill `{}`\",\n-                       trait_def.bounds.user_string(cx.tcx));\n-        });\n \n     // If this is a destructor, check kinds.\n-    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n+    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) &&\n+        !attr::contains_name(it.attrs.as_slice(), \"unsafe_destructor\")\n+    {\n         match self_type.node {\n             TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n@@ -172,133 +130,50 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n }\n \n fn check_item(cx: &mut Context, item: &Item) {\n-    if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n-        match item.node {\n-            ItemImpl(_, ref trait_ref, ref self_type, _) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                // Check bounds on the `self` type.\n-                check_bounds_on_structs_or_enums_in_type_if_possible(\n-                    cx,\n-                    item.span,\n-                    ty::node_id_to_type(cx.tcx, item.id));\n-\n-                match trait_ref {\n-                    &Some(ref trait_ref) => {\n-                        check_impl_of_trait(cx, item, trait_ref, &**self_type);\n-\n-                        // Check bounds on the trait ref.\n-                        match ty::impl_trait_ref(cx.tcx,\n-                                                 ast_util::local_def(item.id)) {\n-                            None => {}\n-                            Some(trait_ref) => {\n-                                check_bounds_on_structs_or_enums_in_trait_ref(\n-                                    cx,\n-                                    item.span,\n-                                    &*trait_ref);\n-\n-                                let trait_def = ty::lookup_trait_def(cx.tcx, trait_ref.def_id);\n-                                for (ty, type_param_def) in trait_ref.substs.types\n-                                                                  .iter()\n-                                                                  .zip(trait_def.generics\n-                                                                                .types\n-                                                                                .iter()) {\n-                                    check_typaram_bounds(cx, item.span, *ty, type_param_def);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    &None => {}\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            ItemEnum(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                let def_id = ast_util::local_def(item.id);\n-                for variant in ty::enum_variants(cx.tcx, def_id).iter() {\n-                    for arg in variant.args.iter() {\n-                        check_bounds_on_structs_or_enums_in_type_if_possible(\n-                            cx,\n-                            item.span,\n-                            *arg)\n-                    }\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            ItemStruct(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                let def_id = ast_util::local_def(item.id);\n-                for field in ty::lookup_struct_fields(cx.tcx, def_id).iter() {\n-                    check_bounds_on_structs_or_enums_in_type_if_possible(\n-                        cx,\n-                        item.span,\n-                        ty::node_id_to_type(cx.tcx, field.id.node))\n-                }\n-\n-                drop(cx.parameter_environments.pop());\n-\n-            }\n-            ItemStatic(..) => {\n-                let parameter_environment =\n-                    ParameterEnvironment::for_item(cx.tcx, item.id);\n-                cx.parameter_environments.push(parameter_environment);\n-\n-                check_bounds_on_structs_or_enums_in_type_if_possible(\n-                    cx,\n-                    item.span,\n-                    ty::node_id_to_type(cx.tcx, item.id));\n-\n-                drop(cx.parameter_environments.pop());\n-            }\n-            _ => {}\n+    match item.node {\n+        ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n+            check_impl_of_trait(cx, item, trait_ref, &**self_type);\n         }\n+        _ => {}\n     }\n \n     visit::walk_item(cx, item)\n }\n \n-fn check_local(cx: &mut Context, local: &Local) {\n-    check_bounds_on_structs_or_enums_in_type_if_possible(\n-        cx,\n-        local.span,\n-        ty::node_id_to_type(cx.tcx, local.id));\n-\n-    visit::walk_local(cx, local)\n-}\n-\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n fn with_appropriate_checker(cx: &Context,\n                             id: NodeId,\n+                            fn_span: Span,\n                             b: |checker: |&Context, &freevar_entry||) {\n-    fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_uniq(cx: &Context,\n+                      fn_span: Span,\n+                      fv: &freevar_entry,\n+                      bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n-        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n+        check_freevar_bounds(cx, fn_span, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(cx: &Context, fv: &freevar_entry,\n-                       bounds: ty::BuiltinBounds, region: ty::Region) {\n+    fn check_for_block(cx: &Context,\n+                       fn_span: Span,\n+                       fn_id: NodeId,\n+                       fv: &freevar_entry,\n+                       bounds: ty::BuiltinBounds) {\n         let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        // FIXME(#3569): Figure out whether the implicit borrow is actually\n-        // mutable. Currently we assume all upvars are referenced mutably.\n-        let implicit_borrowed_type = ty::mk_mut_rptr(cx.tcx, region, var_t);\n-        check_freevar_bounds(cx, fv.span, implicit_borrowed_type,\n+        let upvar_id = ty::UpvarId { var_id: id, closure_expr_id: fn_id };\n+        let upvar_borrow = cx.tcx.upvar_borrow(upvar_id);\n+        let implicit_borrowed_type =\n+            ty::mk_rptr(cx.tcx,\n+                        upvar_borrow.region,\n+                        ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n+                                 ty: var_t });\n+        check_freevar_bounds(cx, fn_span, fv.span, implicit_borrowed_type,\n                              bounds, Some(var_t));\n     }\n \n@@ -315,12 +190,16 @@ fn with_appropriate_checker(cx: &Context,\n             bounds: bounds,\n             ..\n         }) => {\n-            b(|cx, fv| check_for_uniq(cx, fv, bounds.builtin_bounds))\n+            b(|cx, fv| check_for_uniq(cx, fn_span, fv,\n+                                      bounds.builtin_bounds))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n-            store: ty::RegionTraitStore(region, _), bounds, ..\n-        }) => b(|cx, fv| check_for_block(cx, fv, bounds.builtin_bounds, region)),\n+            store: ty::RegionTraitStore(..), bounds, ..\n+        }) => {\n+            b(|cx, fv| check_for_block(cx, fn_span, id, fv,\n+                                       bounds.builtin_bounds))\n+        }\n \n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -346,8 +225,8 @@ fn check_fn(\n     sp: Span,\n     fn_id: NodeId) {\n \n-    // Check kinds on free variables:\n-    with_appropriate_checker(cx, fn_id, |chk| {\n+    // <Check kinds on free variables:\n+    with_appropriate_checker(cx, fn_id, sp, |chk| {\n         freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n             for fv in freevars.iter() {\n                 chk(cx, fv);\n@@ -357,52 +236,18 @@ fn check_fn(\n \n     match fk {\n         visit::FkFnBlock(..) => {\n-            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n-            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n-\n             visit::walk_fn(cx, fk, decl, body, sp)\n         }\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            let parameter_environment = ParameterEnvironment::for_item(cx.tcx,\n-                                                                       fn_id);\n-            cx.parameter_environments.push(parameter_environment);\n-\n-            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n-            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n-\n             visit::walk_fn(cx, fk, decl, body, sp);\n-            drop(cx.parameter_environments.pop());\n         }\n     }\n }\n \n pub fn check_expr(cx: &mut Context, e: &Expr) {\n     debug!(\"kind::check_expr({})\", expr_to_string(e));\n \n-    // Handle any kind bounds on type parameters\n-    check_bounds_on_type_parameters(cx, e);\n-\n-    // Check bounds on structures or enumerations in the type of the\n-    // expression.\n-    let expression_type = ty::expr_ty(cx.tcx, e);\n-    check_bounds_on_structs_or_enums_in_type_if_possible(cx,\n-                                                         e.span,\n-                                                         expression_type);\n-\n     match e.node {\n-        ExprCast(ref source, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, &**source);\n-            let target_ty = ty::expr_ty(cx.tcx, e);\n-            let method_call = MethodCall {\n-                expr_id: e.id,\n-                adjustment: NoAdjustment,\n-            };\n-            check_trait_cast(cx,\n-                             source_ty,\n-                             target_ty,\n-                             source.span,\n-                             method_call);\n-        }\n         ExprRepeat(ref element, ref count_expr) => {\n             let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n             if count > 1 {\n@@ -427,174 +272,8 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n         _ => {}\n     }\n \n-    // Search for auto-adjustments to find trait coercions.\n-    match cx.tcx.adjustments.borrow().find(&e.id) {\n-        Some(adjustment) => {\n-            match adjustment {\n-                adj if ty::adjust_is_object(adj) => {\n-                    let source_ty = ty::expr_ty(cx.tcx, e);\n-                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n-                    let method_call = MethodCall {\n-                        expr_id: e.id,\n-                        adjustment: typeck::AutoObject,\n-                    };\n-                    check_trait_cast(cx,\n-                                     source_ty,\n-                                     target_ty,\n-                                     e.span,\n-                                     method_call);\n-                }\n-                _ => {}\n-            }\n-        }\n-        None => {}\n-    }\n-\n     visit::walk_expr(cx, e);\n }\n-\n-fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n-    let method_map = cx.tcx.method_map.borrow();\n-    let method_call = typeck::MethodCall::expr(e.id);\n-    let method = method_map.find(&method_call);\n-\n-    // Find the values that were provided (if any)\n-    let item_substs = cx.tcx.item_substs.borrow();\n-    let (types, is_object_call) = match method {\n-        Some(method) => {\n-            let is_object_call = match method.origin {\n-                typeck::MethodObject(..) => true,\n-                typeck::MethodStatic(..) |\n-                typeck::MethodStaticUnboxedClosure(..) |\n-                typeck::MethodParam(..) => false\n-            };\n-            (&method.substs.types, is_object_call)\n-        }\n-        None => {\n-            match item_substs.find(&e.id) {\n-                None => { return; }\n-                Some(s) => { (&s.substs.types, false) }\n-            }\n-        }\n-    };\n-\n-    // Find the relevant type parameter definitions\n-    let def_map = cx.tcx.def_map.borrow();\n-    let type_param_defs = match e.node {\n-        ExprPath(_) => {\n-            let did = def_map.get_copy(&e.id).def_id();\n-            ty::lookup_item_type(cx.tcx, did).generics.types.clone()\n-        }\n-        _ => {\n-            // Type substitutions should only occur on paths and\n-            // method calls, so this needs to be a method call.\n-\n-            // Even though the callee_id may have been the id with\n-            // node_type_substs, e.id is correct here.\n-            match method {\n-                Some(method) => {\n-                    ty::method_call_type_param_defs(cx.tcx, method.origin)\n-                }\n-                None => {\n-                    cx.tcx.sess.span_bug(e.span,\n-                                         \"non path/method call expr has type substs??\");\n-                }\n-            }\n-        }\n-    };\n-\n-    // Check that the value provided for each definition meets the\n-    // kind requirements\n-    for type_param_def in type_param_defs.iter() {\n-        let ty = *types.get(type_param_def.space, type_param_def.index);\n-\n-        // If this is a call to an object method (`foo.bar()` where\n-        // `foo` has a type like `Trait`), then the self type is\n-        // unknown (after all, this is a virtual call). In that case,\n-        // we will have put a ty_err in the substitutions, and we can\n-        // just skip over validating the bounds (because the bounds\n-        // would have been enforced when the object instance was\n-        // created).\n-        if is_object_call && type_param_def.space == subst::SelfSpace {\n-            assert_eq!(type_param_def.index, 0);\n-            assert!(ty::type_is_error(ty));\n-            continue;\n-        }\n-\n-        debug!(\"type_param_def space={} index={} ty={}\",\n-               type_param_def.space, type_param_def.index, ty.repr(cx.tcx));\n-        check_typaram_bounds(cx, e.span, ty, type_param_def)\n-    }\n-\n-    // Check the vtable.\n-    let vtable_map = cx.tcx.vtable_map.borrow();\n-    let vtable_res = match vtable_map.find(&method_call) {\n-        None => return,\n-        Some(vtable_res) => vtable_res,\n-    };\n-    check_type_parameter_bounds_in_vtable_result(cx, e.span, vtable_res);\n-}\n-\n-fn check_type_parameter_bounds_in_vtable_result(\n-        cx: &mut Context,\n-        span: Span,\n-        vtable_res: &typeck::vtable_res) {\n-    for origins in vtable_res.iter() {\n-        for origin in origins.iter() {\n-            let (type_param_defs, substs) = match *origin {\n-                typeck::vtable_static(def_id, ref tys, _) => {\n-                    let type_param_defs =\n-                        ty::lookup_item_type(cx.tcx, def_id).generics\n-                                                            .types\n-                                                            .clone();\n-                    (type_param_defs, (*tys).clone())\n-                }\n-                _ => {\n-                    // Nothing to do here.\n-                    continue\n-                }\n-            };\n-            for type_param_def in type_param_defs.iter() {\n-                let typ = substs.types.get(type_param_def.space,\n-                                           type_param_def.index);\n-                check_typaram_bounds(cx, span, *typ, type_param_def)\n-            }\n-        }\n-    }\n-}\n-\n-fn check_trait_cast(cx: &mut Context,\n-                    source_ty: ty::t,\n-                    target_ty: ty::t,\n-                    span: Span,\n-                    method_call: MethodCall) {\n-    match ty::get(target_ty).sty {\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => {\n-            match ty::get(ty).sty {\n-                ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n-                     match cx.tcx.vtable_map.borrow().find(&method_call) {\n-                        None => {\n-                            cx.tcx.sess.span_bug(span,\n-                                                 \"trait cast not in vtable \\\n-                                                  map?!\")\n-                        }\n-                        Some(vtable_res) => {\n-                            check_type_parameter_bounds_in_vtable_result(\n-                                cx,\n-                                span,\n-                                vtable_res)\n-                        }\n-                    };\n-                    check_trait_cast_bounds(cx, span, source_ty,\n-                                            bounds.builtin_bounds);\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {\n@@ -651,77 +330,7 @@ pub fn check_typaram_bounds(cx: &Context,\n     });\n }\n \n-fn check_bounds_on_structs_or_enums_in_type_if_possible(cx: &mut Context,\n-                                                        span: Span,\n-                                                        ty: ty::t) {\n-    // If we aren't in a function, structure, or enumeration context, we don't\n-    // have enough information to ensure that bounds on structures or\n-    // enumerations are satisfied. So we don't perform the check.\n-    if cx.parameter_environments.len() == 0 {\n-        return\n-    }\n-\n-    // If we've already checked for this type, don't do it again. This\n-    // massively speeds up kind checking.\n-    if cx.struct_and_enum_bounds_checked.contains(&ty) {\n-        return\n-    }\n-    cx.struct_and_enum_bounds_checked.insert(ty);\n-\n-    ty::walk_ty(ty, |ty| {\n-        match ty::get(ty).sty {\n-            ty::ty_struct(type_id, ref substs) |\n-            ty::ty_enum(type_id, ref substs) => {\n-                let polytype = ty::lookup_item_type(cx.tcx, type_id);\n-\n-                // Check builtin bounds.\n-                for (ty, type_param_def) in substs.types\n-                                                  .iter()\n-                                                  .zip(polytype.generics\n-                                                               .types\n-                                                               .iter()) {\n-                    check_typaram_bounds(cx, span, *ty, type_param_def);\n-                }\n-\n-                // Check trait bounds.\n-                let parameter_environment =\n-                    cx.parameter_environments.get(cx.parameter_environments\n-                                                    .len() - 1);\n-                debug!(\n-                    \"check_bounds_on_structs_or_enums_in_type_if_possible(): \\\n-                     checking {}\",\n-                    ty.repr(cx.tcx));\n-                vtable::check_param_bounds(cx.tcx,\n-                                           span,\n-                                           parameter_environment,\n-                                           &polytype.generics.types,\n-                                           substs,\n-                                           |missing| {\n-                    cx.tcx\n-                      .sess\n-                      .span_err(span,\n-                                format!(\"instantiating a type parameter with \\\n-                                         an incompatible type `{}`, which \\\n-                                         does not fulfill `{}`\",\n-                                        ty_to_string(cx.tcx, ty),\n-                                        missing.user_string(\n-                                            cx.tcx)).as_slice());\n-                })\n-            }\n-            _ => {}\n-        }\n-    });\n-}\n-\n-fn check_bounds_on_structs_or_enums_in_trait_ref(cx: &mut Context,\n-                                                 span: Span,\n-                                                 trait_ref: &ty::TraitRef) {\n-    for ty in trait_ref.substs.types.iter() {\n-        check_bounds_on_structs_or_enums_in_type_if_possible(cx, span, *ty)\n-    }\n-}\n-\n-pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n+pub fn check_freevar_bounds(cx: &Context, fn_span: Span, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     check_builtin_bounds(cx, ty, bounds, |missing| {\n@@ -741,7 +350,7 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                     ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx));\n             }\n         }\n-        span_note!(cx.tcx.sess, sp,\n+        span_note!(cx.tcx.sess, fn_span,\n             \"this closure's environment must satisfy `{}`\",\n             bounds.user_string(cx.tcx));\n     });"}, {"sha": "d0b94cb3abb8b12f8500b247dbdd3639e20a6bc9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -5423,7 +5423,7 @@ impl BorrowKind {\n          * Returns a mutability `m` such that an `&m T` pointer could\n          * be used to obtain this borrow kind. Because borrow kinds\n          * are richer than mutabilities, we sometimes have to pick a\n-         * mutability that is stornger than necessary so that it at\n+         * mutability that is stronger than necessary so that it at\n          * least *would permit* the borrow in question.\n          */\n "}, {"sha": "46aba94a5f12a0ab773f463d7be43bd46ebae106", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -555,11 +555,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n                     Some(def) => {\n-                        let item_type = ty::lookup_item_type(tcx, def.def_id());\n-                        let substitutions = fcx.infcx().fresh_substs_for_type(\n-                            pat.span, &item_type.generics);\n+                        let struct_ty = fcx.instantiate_item_type(pat.span, def.def_id());\n                         check_struct_pat(pcx, pat.span, fields.as_slice(),\n-                                         etc, def.def_id(), &substitutions);\n+                                         etc, def.def_id(), &struct_ty.substs);\n                     }\n                     None => {\n                         tcx.sess.span_bug(pat.span,"}, {"sha": "074074c13ae907995231cc57a0abc81ac6f20911", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -82,6 +82,7 @@ obtained the type `Foo`, we would never match this method.\n \n use middle::subst;\n use middle::subst::Subst;\n+use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n@@ -91,7 +92,6 @@ use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n-use middle::typeck::{param_index};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::TypeAndSubsts;\n use util::common::indenter;\n@@ -538,14 +538,12 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             return\n         }\n \n-        let vcx = self.fcx.vtable_context();\n-\n         // Get the tupled type of the arguments.\n         let arguments_type = *closure_function_type.sig.inputs.get(0);\n         let return_type = closure_function_type.sig.output;\n \n         let closure_region =\n-            vcx.infcx.next_region_var(infer::MiscVariable(self.span));\n+            self.fcx.infcx().next_region_var(infer::MiscVariable(self.span));\n         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n                                                           closure_did,\n                                                           closure_region);\n@@ -555,7 +553,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_substs: subst::Substs::new_trait(\n                 vec![arguments_type, return_type],\n                 vec![],\n-                *vcx.infcx.next_ty_vars(1).get(0)),\n+                *self.fcx.infcx().next_ty_vars(1).get(0)),\n             method_ty: method,\n             origin: MethodStaticUnboxedClosure(closure_did),\n         });\n@@ -618,7 +616,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         self.push_inherent_candidates_from_bounds_inner(\n             &[trait_ref.clone()],\n-            |_this, new_trait_ref, m, method_num, _bound_num| {\n+            |_this, new_trait_ref, m, method_num| {\n                 let vtable_index =\n                     get_method_index(tcx, &*new_trait_ref,\n                                      trait_ref.clone(), method_num);\n@@ -633,7 +631,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_substs: new_trait_ref.substs.clone(),\n                     method_ty: Rc::new(m),\n                     origin: MethodObject(MethodObject {\n-                        trait_id: new_trait_ref.def_id,\n+                        trait_ref: new_trait_ref,\n                         object_trait_id: did,\n                         method_num: method_num,\n                         real_index: vtable_index\n@@ -652,22 +650,20 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_ty,\n             param_ty.space,\n             param_ty.idx,\n-            restrict_to,\n-            param_index { space: param_ty.space, index: param_ty.idx });\n+            restrict_to);\n     }\n \n \n     fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n                                             space: subst::ParamSpace,\n                                             index: uint,\n-                                            restrict_to: Option<DefId>,\n-                                            param: param_index) {\n+                                            restrict_to: Option<DefId>) {\n         let bounds =\n             self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n             .as_slice();\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n-            |this, trait_ref, m, method_num, bound_num| {\n+            |this, trait_ref, m, method_num| {\n                 match restrict_to {\n                     Some(trait_did) => {\n                         if trait_did != trait_ref.def_id {\n@@ -701,10 +697,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n                     origin: MethodParam(MethodParam {\n-                        trait_id: trait_ref.def_id,\n+                        trait_ref: trait_ref,\n                         method_num: method_num,\n-                        param_num: param,\n-                        bound_num: bound_num,\n                     })\n                 })\n         })\n@@ -718,15 +712,16 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         mk_cand: |this: &mut LookupContext,\n                   tr: Rc<TraitRef>,\n                   m: Rc<ty::Method>,\n-                  method_num: uint,\n-                  bound_num: uint|\n-                  -> Option<Candidate>) {\n+                  method_num: uint|\n+                  -> Option<Candidate>)\n+    {\n         let tcx = self.tcx();\n-        let mut next_bound_idx = 0; // count only trait bounds\n-\n-        ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n-            let this_bound_idx = next_bound_idx;\n-            next_bound_idx += 1;\n+        let mut cache = HashSet::new();\n+        for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+            // Already visited this trait, skip it.\n+            if !cache.insert(bound_trait_ref.def_id) {\n+                continue;\n+            }\n \n             let trait_items = ty::trait_items(tcx, bound_trait_ref.def_id);\n             match trait_items.iter().position(|ti| {\n@@ -745,8 +740,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     match mk_cand(self,\n                                   bound_trait_ref,\n                                   method,\n-                                  pos,\n-                                  this_bound_idx) {\n+                                  pos) {\n                         Some(cand) => {\n                             debug!(\"pushing inherent candidate for param: {}\",\n                                    cand.repr(self.tcx()));\n@@ -761,8 +755,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     // check next trait or bound\n                 }\n             }\n-            true\n-        });\n+        }\n     }\n \n \n@@ -773,7 +766,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n-            for impl_did in impl_infos.borrow().iter() {\n+            for impl_did in impl_infos.iter() {\n                 let items = impl_items.get(impl_did);\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n@@ -825,11 +818,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n-        let vcx = self.fcx.vtable_context();\n         let TypeAndSubsts {\n             substs: impl_substs,\n             ty: impl_ty\n-        } = impl_self_ty(&vcx, span, impl_did);\n+        } = impl_self_ty(self.fcx, span, impl_did);\n \n         let condition = match method.explicit_self {\n             ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n@@ -877,7 +869,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n-                        self.fcx.write_adjustment(self_expr_id, adj);\n+                        self.fcx.write_adjustment(self_expr_id, self.span, adj);\n                     }\n                     None => {}\n                 }\n@@ -1109,7 +1101,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             ty_err => None,\n \n-            ty_infer(TyVar(_)) => {\n+            ty_infer(TyVar(_)) |\n+            ty_infer(SkolemizedTy(_)) |\n+            ty_infer(SkolemizedIntTy(_)) => {\n                 self.bug(format!(\"unexpected type: {}\",\n                                  self.ty_to_string(self_ty)).as_slice());\n             }\n@@ -1150,6 +1144,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                         Some(self_expr_id) => {\n                             self.fcx.write_adjustment(\n                                 self_expr_id,\n+                                self.span,\n                                 ty::AutoDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(kind(region, *mutbl))\n@@ -1209,7 +1204,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             // return something so we don't get errors for every mutability\n             return Some(MethodCallee {\n-                origin: relevant_candidates.get(0).origin,\n+                origin: relevant_candidates.get(0).origin.clone(),\n                 ty: ty::mk_err(),\n                 substs: subst::Substs::empty()\n             });\n@@ -1237,12 +1232,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        candidate_b.repr(self.tcx()));\n                 match (&candidate_a.origin, &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n-                        let same_trait = p1.trait_id == p2.trait_id;\n-                        let same_method = p1.method_num == p2.method_num;\n-                        let same_param = p1.param_num == p2.param_num;\n-                        // The bound number may be different because\n-                        // multiple bounds may lead to the same trait\n-                        // impl\n+                        let same_trait =\n+                            p1.trait_ref.def_id == p2.trait_ref.def_id;\n+                        let same_method =\n+                            p1.method_num == p2.method_num;\n+                        // it's ok to compare self-ty with `==` here because\n+                        // they are always a TyParam\n+                        let same_param =\n+                            p1.trait_ref.self_ty() == p2.trait_ref.self_ty();\n                         same_trait && same_method && same_param\n                     }\n                     _ => false\n@@ -1369,13 +1366,13 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        self.fcx.add_region_obligations_for_parameters(\n-            self.span,\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(self.span),\n             &all_substs,\n             &candidate.method_ty.generics);\n \n         MethodCallee {\n-            origin: candidate.origin,\n+            origin: candidate.origin.clone(),\n             ty: fty,\n             substs: all_substs\n         }\n@@ -1452,10 +1449,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => bad = false,\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n-            MethodParam(MethodParam { trait_id: trait_id, .. }) |\n-            MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 bad = self.tcx().destructor_for_type.borrow()\n-                          .contains_key(&trait_id);\n+                          .contains_key(&trait_ref.def_id);\n             }\n         }\n \n@@ -1602,10 +1599,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 self.report_static_candidate(idx, did)\n             }\n             MethodParam(ref mp) => {\n-                self.report_param_candidate(idx, (*mp).trait_id)\n+                self.report_param_candidate(idx, mp.trait_ref.def_id)\n             }\n             MethodObject(ref mo) => {\n-                self.report_trait_candidate(idx, mo.trait_id)\n+                self.report_trait_candidate(idx, mo.trait_ref.def_id)\n             }\n         }\n     }"}, {"sha": "20fe8186adf40fe50100022eb2ae24fae60d0cf8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 323, "deletions": 196, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -87,6 +87,7 @@ use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::traits;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n@@ -102,15 +103,14 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n-use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n-use middle::typeck::{require_same_types, vtable_map};\n-use middle::typeck::{MethodCall, MethodMap};\n+use middle::typeck::{require_same_types};\n+use middle::typeck::{MethodCall, MethodMap, ObjectCastMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::typeck;\n use middle::lang_items::TypeIdLangItem;\n@@ -143,12 +143,13 @@ use syntax::visit::Visitor;\n use syntax;\n \n pub mod _match;\n-pub mod vtable;\n+pub mod vtable2; // New trait code\n pub mod writeback;\n pub mod regionmanip;\n pub mod regionck;\n pub mod demand;\n pub mod method;\n+pub mod wf;\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -170,9 +171,9 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n     method_map: MethodMap,\n-    vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n     unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n+    object_cast_map: ObjectCastMap,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n@@ -190,7 +191,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // then in some expression `let x = Foo { ... }` it will\n     // instantiate the type parameter `T` with a fresh type `$0`. At\n     // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck.  (We\n+    // `$0:'static`. This will get checked later by regionck. (We\n     // can't generally check these things right away because we have\n     // to wait until types are resolved.)\n     //\n@@ -204,6 +205,9 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: RefCell<NodeMap<Vec<RegionObligation>>>,\n+\n+    // Tracks trait obligations incurred during this function body.\n+    fulfillment_cx: RefCell<traits::FulfillmentContext>,\n }\n \n struct RegionObligation {\n@@ -335,11 +339,12 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             item_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n             method_map: RefCell::new(FnvHashMap::new()),\n-            vtable_map: RefCell::new(FnvHashMap::new()),\n+            object_cast_map: RefCell::new(NodeMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n             fn_sig_map: RefCell::new(NodeMap::new()),\n             region_obligations: RefCell::new(NodeMap::new()),\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n }\n@@ -369,20 +374,12 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n         free_substs: subst::Substs::empty(),\n         bounds: subst::VecPerParamSpace::empty(),\n         implicit_region_bound: ty::ReStatic,\n+        caller_obligations: subst::VecPerParamSpace::empty(),\n     };\n     Inherited::new(ccx.tcx, param_env)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_type_well_formed(self.ccx, i);\n-        visit::walk_item(self, i);\n-    }\n-}\n-\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n@@ -404,8 +401,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n-\n-    let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n+    let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n     // If types are not well-formed, it leads to all manner of errors\n@@ -437,9 +433,10 @@ fn check_bare_fn(ccx: &CrateCtxt,\n             let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n \n-            vtable::resolve_in_block(&fcx, body);\n+            vtable2::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n+            vtable2::check_builtin_bound_obligations(&fcx); // must happen after writeback\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -451,19 +448,21 @@ struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n-            match ty_opt {\n-                None => {\n-                    // infer the variable's type\n-                    let var_id = self.fcx.infcx().next_ty_var_id();\n-                    let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n-                    self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n-                }\n-                Some(typ) => {\n-                    // take type that the user specified\n-                    self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n-                }\n+    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<ty::t>) -> ty::t {\n+        match ty_opt {\n+            None => {\n+                // infer the variable's type\n+                let var_id = self.fcx.infcx().next_ty_var_id();\n+                let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n+                self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n+                var_ty\n             }\n+            Some(typ) => {\n+                // take type that the user specified\n+                self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n+                typ\n+            }\n+        }\n     }\n }\n \n@@ -474,7 +473,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n             ast::TyInfer => None,\n             _ => Some(self.fcx.to_ty(&*local.ty))\n         };\n-        self.assign(local.id, o_ty);\n+        self.assign(local.span, local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n@@ -484,19 +483,23 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-            match p.node {\n-              ast::PatIdent(_, ref path1, _)\n-                  if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n-                self.assign(p.id, None);\n-                debug!(\"Pattern binding {} is assigned to {}\",\n-                       token::get_ident(path1.node),\n-                       self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow().get_copy(&p.id)));\n-              }\n-              _ => {}\n-            }\n-            visit::walk_pat(self, p);\n-\n+        match p.node {\n+            ast::PatIdent(_, ref path1, _)\n+                if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n+                    let var_ty = self.assign(p.span, p.id, None);\n+\n+                    self.fcx.require_type_is_sized(var_ty, p.span,\n+                                                   traits::VariableType(p.id));\n+\n+                    debug!(\"Pattern binding {} is assigned to {} with type {}\",\n+                           token::get_ident(path1.node),\n+                           self.fcx.infcx().ty_to_string(\n+                               self.fcx.inh.locals.borrow().get_copy(&p.id)),\n+                           var_ty.repr(self.fcx.tcx()));\n+                }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, p);\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n@@ -592,11 +595,14 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            pat_util::pat_bindings(&tcx.def_map,\n-                                   &*input.pat,\n-                                   |_bm, pat_id, _sp, _path| {\n-                                       visit.assign(pat_id, None);\n-                                   });\n+            pat_util::pat_bindings(\n+                &tcx.def_map,\n+                &*input.pat,\n+                |_bm, pat_id, sp, _path| {\n+                    let var_ty = visit.assign(sp, pat_id, None);\n+                    fcx.require_type_is_sized(var_ty, sp,\n+                                              traits::VariableType(pat_id));\n+                });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n@@ -713,71 +719,6 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-fn check_type_well_formed(ccx: &CrateCtxt, item: &ast::Item) {\n-    /*!\n-     * Checks that the field types (in a struct def'n) or\n-     * argument types (in an enum def'n) are well-formed,\n-     * meaning that they do not require any constraints not\n-     * declared in the struct definition itself.\n-     * For example, this definition would be illegal:\n-     *\n-     *     struct Ref<'a, T> { x: &'a T }\n-     *\n-     * because the type did not declare that `T:'a`.\n-     *\n-     * We do this check as a pre-pass before checking fn bodies\n-     * because if these constraints are not included it frequently\n-     * leads to confusing errors in fn bodies. So it's better to check\n-     * the types first.\n-     */\n-\n-    debug!(\"check_type_well_formed(it.id={}, it.ident={})\",\n-           item.id,\n-           ty::item_path_str(ccx.tcx, local_def(item.id)));\n-\n-    match item.node {\n-        ast::ItemStruct(..) => {\n-            check_type_defn(ccx, item, |fcx| {\n-                ty::struct_fields(ccx.tcx, local_def(item.id),\n-                                  &fcx.inh.param_env.free_substs)\n-                    .iter()\n-                    .map(|f| f.mt.ty)\n-                    .collect()\n-            });\n-        }\n-        ast::ItemEnum(..) => {\n-            check_type_defn(ccx, item, |fcx| {\n-                ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n-                                         &fcx.inh.param_env.free_substs)\n-                    .iter()\n-                    .flat_map(|variant| {\n-                        variant.args\n-                            .iter()\n-                            .map(|&arg_ty| arg_ty)\n-                    })\n-                    .collect()\n-            });\n-        }\n-        _ => {}\n-    }\n-\n-    fn check_type_defn(ccx: &CrateCtxt,\n-                       item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n-    {\n-        let item_def_id = local_def(item.id);\n-        let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        let param_env =\n-            ty::construct_parameter_environment(ccx.tcx,\n-                                                &polytype.generics,\n-                                                item.id);\n-        let inh = Inherited::new(ccx.tcx, param_env);\n-        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n-        let field_tys = lookup_fields(&fcx);\n-        regionck::regionck_type_defn(&fcx, item.span, field_tys.as_slice());\n-    }\n-}\n-\n pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -836,7 +777,6 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                ast_trait_ref,\n                                                &*impl_trait_ref,\n                                                impl_items.as_slice());\n-                vtable::resolve_impl(ccx.tcx, it, &impl_pty.generics, &*impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -1409,10 +1349,12 @@ fn compare_impl_method(tcx: &ty::ctxt,\n }\n \n fn check_cast(fcx: &FnCtxt,\n+              cast_expr: &ast::Expr,\n               e: &ast::Expr,\n-              t: &ast::Ty,\n-              id: ast::NodeId,\n-              span: Span) {\n+              t: &ast::Ty) {\n+    let id = cast_expr.id;\n+    let span = cast_expr.span;\n+\n     // Find the type of `e`. Supply hints based on the type we are casting to,\n     // if appropriate.\n     let t_1 = fcx.to_ty(t);\n@@ -1443,6 +1385,7 @@ fn check_cast(fcx: &FnCtxt,\n \n     if ty::type_is_trait(t_1) {\n         // This will be looked up later on.\n+        vtable2::check_object_cast(fcx, cast_expr, e, t_1);\n         fcx.write_ty(id, t_1);\n         return\n     }\n@@ -1582,14 +1525,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-\n-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {\n-        VtableContext {\n-            infcx: self.infcx(),\n-            param_env: &self.inh.param_env,\n-            unboxed_closures: &self.inh.unboxed_closures,\n-        }\n-    }\n }\n \n impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n@@ -1629,6 +1564,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n+    pub fn write_object_cast(&self,\n+                             key: ast::NodeId,\n+                             trait_ref: Rc<ty::TraitRef>) {\n+        debug!(\"write_object_cast key={} trait_ref={}\",\n+               key, trait_ref.repr(self.tcx()));\n+        self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n+    }\n+\n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n@@ -1651,10 +1594,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n+                                      span: Span,\n                                       derefs: uint) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n+            span,\n             ty::AutoDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None })\n@@ -1663,11 +1608,109 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n+                            span: Span,\n                             adj: ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n+\n+        // Careful: adjustments can imply trait obligations if we are\n+        // casting from a concrete type to an object type. I think\n+        // it'd probably be nicer to move the logic that creates the\n+        // obligation into the code that creates the adjustment, but\n+        // that's a bit awkward, so instead we go digging and pull the\n+        // obligation out here.\n+        self.register_adjustment_obligations(span, &adj);\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n+    fn register_adjustment_obligations(&self,\n+                                       span: Span,\n+                                       adj: &ty::AutoAdjustment) {\n+        match *adj {\n+            ty::AutoAddEnv(..) => { }\n+            ty::AutoDerefRef(ref d_r) => {\n+                match d_r.autoref {\n+                    Some(ref a_r) => {\n+                        self.register_autoref_obligations(span, a_r);\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn register_autoref_obligations(&self,\n+                                    span: Span,\n+                                    autoref: &ty::AutoRef) {\n+        match *autoref {\n+            ty::AutoUnsize(ref unsize) => {\n+                self.register_unsize_obligations(span, unsize);\n+            }\n+            ty::AutoPtr(_, _, None) |\n+            ty::AutoUnsafe(_, None) => {\n+            }\n+            ty::AutoPtr(_, _, Some(ref a_r)) |\n+            ty::AutoUnsafe(_, Some(ref a_r)) => {\n+                self.register_autoref_obligations(span, &**a_r)\n+            }\n+            ty::AutoUnsizeUniq(ref unsize) => {\n+                self.register_unsize_obligations(span, unsize);\n+            }\n+        }\n+    }\n+\n+    fn register_unsize_obligations(&self,\n+                                   span: Span,\n+                                   unsize: &ty::UnsizeKind) {\n+        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n+\n+        match *unsize {\n+            ty::UnsizeLength(..) => {}\n+            ty::UnsizeStruct(ref u, _) => {\n+                self.register_unsize_obligations(span, &**u)\n+            }\n+            ty::UnsizeVtable(ref ty_trait, self_ty) => {\n+                vtable2::register_object_cast_obligations(self,\n+                                                          span,\n+                                                          ty_trait,\n+                                                          self_ty);\n+            }\n+        }\n+    }\n+\n+    pub fn instantiate_item_type(&self,\n+                                 span: Span,\n+                                 def_id: ast::DefId)\n+                                 -> TypeAndSubsts\n+    {\n+        /*!\n+         * Returns the type of `def_id` with all generics replaced by\n+         * by fresh type/region variables. Also returns the\n+         * substitution from the type parameters on `def_id` to the\n+         * fresh variables.  Registers any trait obligations specified\n+         * on `def_id` at the same time.\n+         */\n+\n+        let polytype =\n+            ty::lookup_item_type(self.tcx(), def_id);\n+        let substs =\n+            self.infcx().fresh_substs_for_generics(\n+                span,\n+                &polytype.generics);\n+        self.add_obligations_for_parameters(\n+            traits::ObligationCause::new(\n+                span,\n+                traits::ItemObligation(def_id)),\n+            &substs,\n+            &polytype.generics);\n+        let monotype =\n+            polytype.ty.subst(self.tcx(), &substs);\n+\n+        TypeAndSubsts {\n+            ty: monotype,\n+            substs: substs\n+        }\n+    }\n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil());\n     }\n@@ -1678,8 +1721,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n+    pub fn require_type_meets(&self,\n+                              ty: ty::t,\n+                              span: Span,\n+                              code: traits::ObligationCauseCode,\n+                              bound: ty::BuiltinBound)\n+    {\n+        self.register_obligation(\n+            traits::obligation_for_builtin_bound(\n+                self.tcx(),\n+                traits::ObligationCause::new(span, code),\n+                ty,\n+                bound));\n+    }\n+\n+    pub fn require_type_is_sized(&self,\n+                                 ty: ty::t,\n+                                 span: Span,\n+                                 code: traits::ObligationCauseCode)\n+    {\n+        self.require_type_meets(ty, span, code, ty::BoundSized);\n+    }\n+\n+    pub fn require_expr_have_sized_type(&self,\n+                                        expr: &ast::Expr,\n+                                        code: traits::ObligationCauseCode)\n+    {\n+        self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n+    }\n+\n+    pub fn register_obligation(&self,\n+                               obligation: traits::Obligation)\n+    {\n+        debug!(\"register_obligation({})\",\n+               obligation.repr(self.tcx()));\n+\n+        self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .register_obligation(self.tcx(), obligation);\n+    }\n+\n     pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n-        ast_ty_to_ty(self, self.infcx(), ast_t)\n+        let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n+\n+        let mut bounds_checker = wf::BoundsChecker::new(self,\n+                                                        ast_t.span,\n+                                                        self.body_id,\n+                                                        None);\n+        bounds_checker.check_ty(t);\n+\n+        t\n     }\n \n     pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n@@ -1761,7 +1852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(None) => Ok(()),\n             Err(ref e) => Err((*e)),\n             Ok(Some(adjustment)) => {\n-                self.write_adjustment(expr.id, adjustment);\n+                self.write_adjustment(expr.id, expr.span, adjustment);\n                 Ok(())\n             }\n         }\n@@ -1829,10 +1920,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   origin: origin });\n     }\n \n-    pub fn add_region_obligations_for_parameters(&self,\n-                                                 span: Span,\n-                                                 substs: &Substs,\n-                                                 generics: &ty::Generics)\n+    pub fn add_obligations_for_parameters(&self,\n+                                          cause: traits::ObligationCause,\n+                                          substs: &Substs,\n+                                          generics: &ty::Generics)\n     {\n         /*!\n          * Given a set of generic parameter definitions (`generics`)\n@@ -1853,10 +1944,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          * locally.\n          */\n \n-        debug!(\"add_region_obligations_for_parameters(substs={}, generics={})\",\n+        debug!(\"add_obligations_for_parameters(substs={}, generics={})\",\n                substs.repr(self.tcx()),\n                generics.repr(self.tcx()));\n \n+        self.add_trait_obligations_for_generics(cause, substs, generics);\n+        self.add_region_obligations_for_generics(cause, substs, generics);\n+    }\n+\n+    fn add_trait_obligations_for_generics(&self,\n+                                          cause: traits::ObligationCause,\n+                                          substs: &Substs,\n+                                          generics: &ty::Generics) {\n+        let obligations =\n+            traits::obligations_for_generics(self.tcx(),\n+                                             cause,\n+                                             generics,\n+                                             substs);\n+        obligations.map_move(|o| self.register_obligation(o));\n+    }\n+\n+    fn add_region_obligations_for_generics(&self,\n+                                           cause: traits::ObligationCause,\n+                                           substs: &Substs,\n+                                           generics: &ty::Generics)\n+    {\n         assert_eq!(generics.types.iter().len(),\n                    substs.types.iter().len());\n         for (type_def, &type_param) in\n@@ -1867,8 +1979,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                          idx: type_def.index,\n                                          def_id: type_def.def_id };\n             let bounds = type_def.bounds.subst(self.tcx(), substs);\n-            add_region_obligations_for_type_parameter(\n-                self, span, param_ty, &bounds, type_param);\n+            self.add_region_obligations_for_type_parameter(\n+                cause.span, param_ty, &bounds, type_param);\n         }\n \n         assert_eq!(generics.regions.iter().len(),\n@@ -1878,42 +1990,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 substs.regions().iter())\n         {\n             let bounds = region_def.bounds.subst(self.tcx(), substs);\n-            add_region_obligations_for_region_parameter(\n-                self, span, bounds.as_slice(), region_param);\n-        }\n-\n-        fn add_region_obligations_for_type_parameter(\n-            fcx: &FnCtxt,\n-            span: Span,\n-            param_ty: ty::ParamTy,\n-            param_bound: &ty::ParamBounds,\n-            ty: ty::t)\n-        {\n-            // For each declared region bound `T:r`, `T` must outlive `r`.\n-            let region_bounds =\n-                ty::required_region_bounds(\n-                    fcx.tcx(),\n-                    param_bound.opt_region_bound.as_slice(),\n-                    param_bound.builtin_bounds,\n-                    param_bound.trait_bounds.as_slice());\n-            for &r in region_bounds.iter() {\n-                let origin = infer::RelateParamBound(span, param_ty, ty);\n-                fcx.register_region_obligation(origin, ty, r);\n-            }\n+            self.add_region_obligations_for_region_parameter(\n+                cause.span, bounds.as_slice(), region_param);\n         }\n+    }\n \n-        fn add_region_obligations_for_region_parameter(\n-            fcx: &FnCtxt,\n-            span: Span,\n-            region_bounds: &[ty::Region],\n-            region_param: ty::Region)\n-        {\n-            for &b in region_bounds.iter() {\n-                // For each bound `region:b`, `b <= region` must hold\n-                // (i.e., `region` must outlive `b`).\n-                let origin = infer::RelateRegionParamBound(span);\n-                fcx.mk_subr(origin, b, region_param);\n-            }\n+    fn add_region_obligations_for_type_parameter(&self,\n+                                                 span: Span,\n+                                                 param_ty: ty::ParamTy,\n+                                                 param_bound: &ty::ParamBounds,\n+                                                 ty: ty::t)\n+    {\n+        // For each declared region bound `T:r`, `T` must outlive `r`.\n+        let region_bounds =\n+            ty::required_region_bounds(\n+                self.tcx(),\n+                param_bound.opt_region_bound.as_slice(),\n+                param_bound.builtin_bounds,\n+                param_bound.trait_bounds.as_slice());\n+        for &r in region_bounds.iter() {\n+            let origin = infer::RelateParamBound(span, param_ty, ty);\n+            self.register_region_obligation(origin, ty, r);\n+        }\n+    }\n+\n+    fn add_region_obligations_for_region_parameter(&self,\n+                                                   span: Span,\n+                                                   region_bounds: &[ty::Region],\n+                                                   region_param: ty::Region)\n+    {\n+        for &b in region_bounds.iter() {\n+            // For each bound `region:b`, `b <= region` must hold\n+            // (i.e., `region` must outlive `b`).\n+            let origin = infer::RelateRegionParamBound(span);\n+            self.mk_subr(origin, b, region_param);\n         }\n     }\n }\n@@ -2272,7 +2382,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n-                        callee_expr: &ast::Expr,\n+                        _callee_expr: &ast::Expr,\n                         args: &[P<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n@@ -2369,7 +2479,7 @@ fn check_argument_types(fcx: &FnCtxt,\n         // an \"opportunistic\" vtable resolution of any trait\n         // bounds on the call.\n         if check_blocks {\n-            vtable::early_resolve_expr(callee_expr, fcx, true);\n+            vtable2::select_fcx_obligations_where_possible(fcx);\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -2568,25 +2678,24 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n     check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n }\n \n-\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn impl_self_ty(vcx: &VtableContext,\n+pub fn impl_self_ty(fcx: &FnCtxt,\n                     span: Span, // (potential) receiver for this impl\n                     did: ast::DefId)\n                     -> TypeAndSubsts {\n-    let tcx = vcx.tcx();\n+    let tcx = fcx.tcx();\n \n     let ity = ty::lookup_item_type(tcx, did);\n     let (n_tps, rps, raw_ty) =\n         (ity.generics.types.len(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n          ity.ty);\n \n-    let rps = vcx.infcx.region_vars_for_defs(span, rps);\n-    let tps = vcx.infcx.next_ty_vars(n_tps);\n+    let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n+    let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n     let substs = subst::Substs::new_type(tps, rps);\n     let substd_ty = raw_ty.subst(tcx, &substs);\n \n@@ -3260,7 +3369,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -3344,7 +3453,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);\n-                fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                 return;\n             }\n             None => {}\n@@ -3467,15 +3576,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 base_expr: Option<&ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n-        // Look up the number of type parameters and the raw type, and\n-        // determine whether the class is region-parameterized.\n-        let item_type = ty::lookup_item_type(tcx, class_id);\n-        let raw_type = item_type.ty;\n-\n         // Generate the struct type.\n-        let substitutions = fcx.infcx().fresh_substs_for_type(\n-            span, &item_type.generics);\n-        let mut struct_type = raw_type.subst(tcx, &substitutions);\n+        let TypeAndSubsts {\n+            ty: mut struct_type,\n+            substs: struct_substs\n+        } = fcx.instantiate_item_type(span, class_id);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n@@ -3484,7 +3589,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                        span,\n                                        class_id,\n                                        id,\n-                                       substitutions,\n+                                       struct_substs,\n                                        class_fields.as_slice(),\n                                        fields,\n                                        base_expr.is_none());\n@@ -3517,9 +3622,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n-        let item_type = ty::lookup_item_type(tcx, enum_id);\n-        let substitutions = fcx.infcx().fresh_substs_for_type(span, &item_type.generics);\n-        let enum_type = item_type.ty.subst(tcx, &substitutions);\n+        let TypeAndSubsts {\n+            ty: enum_type,\n+            substs: substitutions\n+        } = fcx.instantiate_item_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -3619,6 +3725,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             span_err!(tcx.sess, lhs.span, E0067, \"illegal left-hand side expression\");\n         }\n \n+        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+\n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n         // and so forth. - Niko\n@@ -3833,6 +3941,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_expr_has_type(fcx, &**rhs, lhs_ty);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n \n+        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+\n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n         } else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n@@ -3863,7 +3973,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::early_resolve_expr(expr, fcx, true);\n+        vtable2::select_fcx_obligations_where_possible(fcx);\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -3958,7 +4068,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n             _ => {}\n         }\n-        check_cast(fcx, &**e, &**t, id, expr.span);\n+        check_cast(fcx, expr, &**e, &**t);\n       }\n       ast::ExprVec(ref args) => {\n         let uty = match expected {\n@@ -4015,6 +4125,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n         };\n \n+        if count > 1 {\n+            // For [foo, ..n] where n > 1, `foo` must have\n+            // Copy type:\n+            fcx.require_type_meets(\n+                t,\n+                expr.span,\n+                traits::RepeatVec,\n+                ty::BoundCopy);\n+        }\n+\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n         } else if ty::type_is_bot(element_ty) {\n@@ -4143,6 +4263,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 }\n             }\n         }\n+\n+        fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       ast::ExprField(ref base, ref field, ref tys) => {\n         check_field(fcx, expr, lvalue_pref, &**base, field, tys.as_slice());\n@@ -4167,7 +4289,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   Some(ty) => {\n                       check_expr_has_type(fcx, &**idx, ty::mk_uint());\n                       fcx.write_ty(id, ty);\n-                      fcx.write_autoderef_adjustment(base.id, autoderefs);\n+                      fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n                   }\n                   None => {\n                       // This is an overloaded method.\n@@ -4520,8 +4642,10 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n+    vtable2::select_all_fcx_obligations_or_error(fcx);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n+    vtable2::check_builtin_bound_obligations(fcx);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -5009,8 +5133,11 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n-    fcx.add_region_obligations_for_parameters(\n-        span, &substs, &polytype.generics);\n+    fcx.add_obligations_for_parameters(\n+        traits::ObligationCause::new(span,\n+                                     traits::ItemObligation(def.def_id())),\n+        &substs,\n+        &polytype.generics);\n \n     fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n         substs: substs,"}, {"sha": "45ffddf3fe80e57d881a9526dc3727149a7dfce7", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -155,18 +155,9 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_type_defn(fcx: &FnCtxt,\n-                          span: Span,\n-                          component_tys: &[ty::t]) {\n-    let mut rcx = Rcx::new(fcx, 0);\n-    for &component_ty in component_tys.iter() {\n-        // Check that each type outlives the empty region. Since the\n-        // empty region is a subregion of all others, this can't fail\n-        // unless the type does not meet the well-formedness\n-        // requirements.\n-        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n-                          component_ty, ty::ReEmpty);\n-    }\n+pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n+    let mut rcx = Rcx::new(fcx, item.id);\n+    rcx.visit_region_obligations(item.id);\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n@@ -179,6 +170,26 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n+pub fn regionck_ensure_component_tys_wf(fcx: &FnCtxt,\n+                                        span: Span,\n+                                        component_tys: &[ty::t]) {\n+    /*!\n+     * Checks that the types in `component_tys` are well-formed.\n+     * This will add constraints into the region graph.\n+     * Does *not* run `resolve_regions_and_report_errors` and so forth.\n+     */\n+\n+    let mut rcx = Rcx::new(fcx, 0);\n+    for &component_ty in component_tys.iter() {\n+        // Check that each type outlives the empty region. Since the\n+        // empty region is a subregion of all others, this can't fail\n+        // unless the type does not meet the well-formedness\n+        // requirements.\n+        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n+                          component_ty, ty::ReEmpty);\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n "}, {"sha": "9a70cf574fc4d942ecae922180f0eb7a0fa79aef", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "removed", "additions": 0, "deletions": 1077, "changes": 1077, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -1,1077 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use middle::ty;\n-use middle::ty::{AutoDerefRef, ParamTy};\n-use middle::ty_fold::TypeFolder;\n-use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, impl_self_ty};\n-use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::regionmanip;\n-use middle::typeck::check::writeback;\n-use middle::typeck::infer::fixup_err_to_string;\n-use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n-use middle::typeck::infer;\n-use middle::typeck::{MethodCall, TypeAndSubsts};\n-use middle::typeck::{param_index, vtable_error, vtable_origin, vtable_param};\n-use middle::typeck::{vtable_param_res, vtable_res, vtable_static};\n-use middle::typeck::{vtable_unboxed_closure};\n-use middle::subst;\n-use middle::subst::{Subst, VecPerParamSpace};\n-use util::common::indenter;\n-use util::nodemap::DefIdMap;\n-use util::ppaux;\n-use util::ppaux::Repr;\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-use std::collections::HashSet;\n-use syntax::ast;\n-use syntax::ast_util;\n-use syntax::codemap::Span;\n-use syntax::print::pprust::expr_to_string;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-\n-// vtable resolution looks for places where trait bounds are\n-// substituted in and figures out which vtable is used. There is some\n-// extra complication thrown in to support early \"opportunistic\"\n-// vtable resolution. This is a hacky mechanism that is invoked while\n-// typechecking function calls (after typechecking non-closure\n-// arguments and before typechecking closure arguments) in the hope of\n-// solving for the trait parameters from the impl. (For example,\n-// determining that if a parameter bounded by BaseIter<A> is\n-// instantiated with Option<int>, that A = int.)\n-//\n-// In early resolution mode, no vtables are recorded, and a number of\n-// errors are ignored. Early resolution only works if a type is\n-// *fully* resolved. (We could be less restrictive than that, but it\n-// would require much more care, and this seems to work decently in\n-// practice.)\n-//\n-// While resolution on a single type requires the type to be fully\n-// resolved, when resolving a substitution against a list of bounds,\n-// we do not require all of the types to be resolved in advance.\n-// Furthermore, we process substitutions in reverse order, which\n-// allows resolution on later parameters to give information on\n-// earlier params referenced by the typeclass bounds.\n-// It may be better to do something more clever, like processing fully\n-// resolved types first.\n-\n-/// A vtable context includes an inference context, a parameter environment,\n-/// and a list of unboxed closure types.\n-pub struct VtableContext<'a, 'tcx: 'a> {\n-    pub infcx: &'a infer::InferCtxt<'a, 'tcx>,\n-    pub param_env: &'a ty::ParameterEnvironment,\n-    pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,\n-}\n-\n-impl<'a, 'tcx> VtableContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }\n-}\n-\n-fn lookup_vtables(vcx: &VtableContext,\n-                  span: Span,\n-                  type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n-                  substs: &subst::Substs,\n-                  is_early: bool)\n-                  -> VecPerParamSpace<vtable_param_res> {\n-    debug!(\"lookup_vtables(\\\n-           type_param_defs={}, \\\n-           substs={}\",\n-           type_param_defs.repr(vcx.tcx()),\n-           substs.repr(vcx.tcx()));\n-\n-    // We do this backwards for reasons discussed above.\n-    let result = type_param_defs.map_rev(|def| {\n-        let ty = *substs.types.get(def.space, def.index);\n-        lookup_vtables_for_param(vcx, span, Some(substs),\n-                                 &def.bounds, ty, is_early)\n-    });\n-\n-    debug!(\"lookup_vtables result(\\\n-            type_param_defs={}, \\\n-            substs={}, \\\n-            result={})\",\n-           type_param_defs.repr(vcx.tcx()),\n-           substs.repr(vcx.tcx()),\n-           result.repr(vcx.tcx()));\n-\n-    result\n-}\n-\n-fn lookup_vtables_for_param(vcx: &VtableContext,\n-                            span: Span,\n-                            // None for substs means the identity\n-                            substs: Option<&subst::Substs>,\n-                            type_param_bounds: &ty::ParamBounds,\n-                            ty: ty::t,\n-                            is_early: bool)\n-                            -> vtable_param_res {\n-    let tcx = vcx.tcx();\n-\n-    debug!(\"lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})\",\n-           ty.repr(vcx.tcx()),\n-           type_param_bounds.repr(vcx.tcx()),\n-           is_early);\n-\n-    // ty is the value supplied for the type parameter A...\n-    let mut param_result = Vec::new();\n-\n-    ty::each_bound_trait_and_supertraits(tcx,\n-                                         type_param_bounds.trait_bounds\n-                                                          .as_slice(),\n-                                         |trait_ref| {\n-        // ...and here trait_ref is each bound that was declared on A,\n-        // expressed in terms of the type parameters.\n-\n-        debug!(\"matching ty={} trait_ref={}\",\n-               ty.repr(vcx.tcx()),\n-               trait_ref.repr(vcx.tcx()));\n-\n-        ty::populate_implementations_for_trait_if_necessary(tcx,\n-                                                            trait_ref.def_id);\n-\n-        // Substitute the values of the type parameters that may\n-        // appear in the bound.\n-        let trait_ref = substs.as_ref().map_or(trait_ref.clone(), |substs| {\n-            debug!(\"about to subst: {}, {}\",\n-                   trait_ref.repr(tcx), substs.repr(tcx));\n-            trait_ref.subst(tcx, *substs)\n-        });\n-\n-        debug!(\"after subst: {}\", trait_ref.repr(tcx));\n-\n-        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {\n-            Some(vtable) => param_result.push(vtable),\n-            None => {\n-                vcx.tcx().sess.span_err(span,\n-                    format!(\"failed to find an implementation of \\\n-                          trait {} for {}\",\n-                         vcx.infcx.trait_ref_to_string(&*trait_ref),\n-                         vcx.infcx.ty_to_string(ty)).as_slice());\n-                param_result.push(vtable_error)\n-            }\n-        }\n-        true\n-    });\n-\n-    debug!(\"lookup_vtables_for_param result(\\\n-            type_param_bounds={}, \\\n-            ty={}, \\\n-            result={})\",\n-           type_param_bounds.repr(vcx.tcx()),\n-           ty.repr(vcx.tcx()),\n-           param_result.repr(vcx.tcx()));\n-\n-    param_result\n-}\n-\n-fn relate_trait_refs(vcx: &VtableContext,\n-                     span: Span,\n-                     act_trait_ref: Rc<ty::TraitRef>,\n-                     exp_trait_ref: Rc<ty::TraitRef>) {\n-    /*!\n-     *\n-     * Checks that an implementation of `act_trait_ref` is suitable\n-     * for use where `exp_trait_ref` is required and reports an\n-     * error otherwise.\n-     */\n-\n-    match infer::mk_sub_trait_refs(vcx.infcx,\n-                                   false,\n-                                   infer::RelateTraitRefs(span),\n-                                   act_trait_ref.clone(),\n-                                   exp_trait_ref.clone()) {\n-        Ok(()) => {} // Ok.\n-        Err(ref err) => {\n-            // There is an error, but we need to do some work to make\n-            // the message good.\n-            // Resolve any type vars in the trait refs\n-            let r_act_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);\n-            let r_exp_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);\n-            // Only print the message if there aren't any previous type errors\n-            // inside the types.\n-            if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n-                !ty::trait_ref_contains_error(&r_exp_trait_ref)\n-            {\n-                let tcx = vcx.tcx();\n-                span_err!(tcx.sess, span, E0095, \"expected {}, found {} ({})\",\n-                          ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),\n-                          ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),\n-                          ty::type_err_to_str(tcx, err));\n-            }\n-        }\n-    }\n-}\n-\n-// Look up the vtable implementing the trait `trait_ref` at type `t`\n-fn lookup_vtable(vcx: &VtableContext,\n-                 span: Span,\n-                 ty: ty::t,\n-                 trait_ref: Rc<ty::TraitRef>,\n-                 is_early: bool)\n-                 -> Option<vtable_origin>\n-{\n-    debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n-           ty.repr(vcx.tcx()),\n-           trait_ref.repr(vcx.tcx()));\n-    let _i = indenter();\n-\n-    let ty = match fixup_ty(vcx, span, ty, is_early) {\n-        Some(ty) => ty,\n-        None => {\n-            // fixup_ty can only fail if this is early resolution\n-            assert!(is_early);\n-            // The type has unconstrained type variables in it, so we can't\n-            // do early resolution on it. Return some completely bogus vtable\n-            // information: we aren't storing it anyways.\n-            return Some(vtable_error);\n-        }\n-    };\n-\n-    if ty::type_is_error(ty) {\n-        return Some(vtable_error);\n-    }\n-\n-    // If the type is self or a param, we look at the trait/supertrait\n-    // bounds to see if they include the trait we are looking for.\n-    let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(ParamTy {space, idx: n, ..}) => {\n-            let env_bounds = &vcx.param_env.bounds;\n-            let type_param_bounds = &env_bounds.get(space, n).trait_bounds;\n-            lookup_vtable_from_bounds(vcx,\n-                                      span,\n-                                      type_param_bounds.as_slice(),\n-                                      param_index {\n-                                          space: space,\n-                                          index: n,\n-                                      },\n-                                      trait_ref.clone())\n-        }\n-\n-        // Default case just falls through\n-        _ => None\n-    };\n-\n-    if vtable_opt.is_some() { return vtable_opt; }\n-\n-    // If we aren't a self type or param, or it was, but we didn't find it,\n-    // do a search.\n-    search_for_vtable(vcx, span, ty, trait_ref, is_early)\n-}\n-\n-// Given a list of bounds on a type, search those bounds to see if any\n-// of them are the vtable we are looking for.\n-fn lookup_vtable_from_bounds(vcx: &VtableContext,\n-                             span: Span,\n-                             bounds: &[Rc<ty::TraitRef>],\n-                             param: param_index,\n-                             trait_ref: Rc<ty::TraitRef>)\n-                             -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-\n-    let mut n_bound = 0;\n-    let mut ret = None;\n-    ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n-        debug!(\"checking bounds trait {}\",\n-               bound_trait_ref.repr(vcx.tcx()));\n-\n-        if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());\n-            let vtable = vtable_param(param, n_bound);\n-            debug!(\"found param vtable: {:?}\",\n-                   vtable);\n-            ret = Some(vtable);\n-            false\n-        } else {\n-            n_bound += 1;\n-            true\n-        }\n-    });\n-    ret\n-}\n-\n-fn search_for_unboxed_closure_vtable(vcx: &VtableContext,\n-                                     span: Span,\n-                                     ty: ty::t,\n-                                     trait_ref: Rc<ty::TraitRef>)\n-                                     -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-    let closure_def_id = match ty::get(ty).sty {\n-        ty::ty_unboxed_closure(closure_def_id, _) => closure_def_id,\n-        _ => return None,\n-    };\n-\n-    let fn_traits = [\n-        (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n-        (ty::FnMutUnboxedClosureKind, tcx.lang_items.fn_mut_trait()),\n-        (ty::FnOnceUnboxedClosureKind, tcx.lang_items.fn_once_trait()),\n-    ];\n-    for tuple in fn_traits.iter() {\n-        let kind = match tuple {\n-            &(kind, Some(ref fn_trait)) if *fn_trait == trait_ref.def_id => {\n-                kind\n-            }\n-            _ => continue,\n-        };\n-\n-        // Check to see whether the argument and return types match.\n-        let unboxed_closures = tcx.unboxed_closures.borrow();\n-        let closure_type = match unboxed_closures.find(&closure_def_id) {\n-            Some(closure) => {\n-                if closure.kind != kind {\n-                    continue\n-                }\n-                closure.closure_type.clone()\n-            }\n-            None => {\n-                // Try the inherited unboxed closure type map.\n-                let unboxed_closures = vcx.unboxed_closures.borrow();\n-                match unboxed_closures.find(&closure_def_id) {\n-                    Some(closure) => {\n-                        if closure.kind != kind {\n-                            continue\n-                        }\n-                        closure.closure_type.clone()\n-                    }\n-                    None => {\n-                        tcx.sess.span_bug(span,\n-                                          \"didn't find unboxed closure type \\\n-                                           in tcx map or inh map\")\n-                    }\n-                }\n-            }\n-        };\n-\n-        // FIXME(pcwalton): This is a bogus thing to do, but\n-        // it'll do for now until we get the new trait-bound\n-        // region skolemization working.\n-        let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions_in_fn_sig(\n-                tcx,\n-                &closure_type.sig,\n-                |br| {\n-                    vcx.infcx.next_region_var(infer::LateBoundRegion(span,\n-                                                                     br))\n-                });\n-\n-        let arguments_tuple = *new_signature.inputs.get(0);\n-        let corresponding_trait_ref = Rc::new(ty::TraitRef {\n-            def_id: trait_ref.def_id,\n-            substs: subst::Substs::new_trait(\n-                vec![arguments_tuple, new_signature.output],\n-                Vec::new(),\n-                ty)\n-        });\n-\n-        relate_trait_refs(vcx, span, corresponding_trait_ref, trait_ref);\n-        return Some(vtable_unboxed_closure(closure_def_id))\n-    }\n-\n-    None\n-}\n-\n-fn search_for_vtable(vcx: &VtableContext,\n-                     span: Span,\n-                     ty: ty::t,\n-                     trait_ref: Rc<ty::TraitRef>,\n-                     is_early: bool)\n-                     -> Option<vtable_origin> {\n-    let tcx = vcx.tcx();\n-\n-    // First, check to see whether this is a call to the `call` method of an\n-    // unboxed closure. If so, and the arguments match, we're done.\n-    match search_for_unboxed_closure_vtable(vcx,\n-                                            span,\n-                                            ty,\n-                                            trait_ref.clone()) {\n-        Some(vtable_origin) => return Some(vtable_origin),\n-        None => {}\n-    }\n-\n-    // Nope. Continue.\n-\n-    let mut found = Vec::new();\n-    let mut impls_seen = HashSet::new();\n-\n-    // Load the implementations from external metadata if necessary.\n-    ty::populate_implementations_for_trait_if_necessary(tcx,\n-                                                        trait_ref.def_id);\n-\n-    let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {\n-        Some(impls) => impls,\n-        None => {\n-            return None;\n-        }\n-    };\n-    // impls is the list of all impls in scope for trait_ref.\n-    for &impl_did in impls.borrow().iter() {\n-        // im is one specific impl of trait_ref.\n-\n-        // First, ensure we haven't processed this impl yet.\n-        if impls_seen.contains(&impl_did) {\n-            continue;\n-        }\n-        impls_seen.insert(impl_did);\n-\n-        // ty::impl_traits gives us the trait im implements.\n-        //\n-        // If foo implements a trait t, and if t is the same trait as\n-        // trait_ref, we need to unify it with trait_ref in order to\n-        // get all the ty vars sorted out.\n-        let r = ty::impl_trait_ref(tcx, impl_did);\n-        let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n-        if of_trait_ref.def_id != trait_ref.def_id { continue; }\n-\n-        // At this point, we know that of_trait_ref is the same trait\n-        // as trait_ref, but possibly applied to different substs.\n-        //\n-        // Next, we check whether the \"for\" ty in the impl is\n-        // compatible with the type that we're casting to a\n-        // trait. That is, if im is:\n-        //\n-        // impl<T> some_trait<T> for self_ty<T> { ... }\n-        //\n-        // we check whether self_ty<T> is the type of the thing that\n-        // we're trying to cast to some_trait.  If not, then we try\n-        // the next impl.\n-        //\n-        // FIXME: document a bit more what this means\n-        let TypeAndSubsts {\n-            substs: substs,\n-            ty: for_ty\n-        } = impl_self_ty(vcx, span, impl_did);\n-        match infer::mk_eqty(vcx.infcx,\n-                             false,\n-                             infer::RelateSelfType(span),\n-                             ty,\n-                             for_ty) {\n-            Err(_) => continue,\n-            Ok(()) => ()\n-        }\n-\n-        // Now, in the previous example, for_ty is bound to\n-        // the type self_ty, and substs is bound to [T].\n-        debug!(\"The self ty is {} and its substs are {}\",\n-               for_ty.repr(tcx),\n-               substs.types.repr(tcx));\n-\n-        // Next, we unify trait_ref -- the type that we want to cast\n-        // to -- with of_trait_ref -- the trait that im implements. At\n-        // this point, we require that they be unifiable with each\n-        // other -- that's what relate_trait_refs does.\n-        //\n-        // For example, in the above example, of_trait_ref would be\n-        // some_trait<T>, so we would be unifying trait_ref<U> (for\n-        // some value of U) with some_trait<T>. This would fail if T\n-        // and U weren't compatible.\n-\n-        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-\n-        debug!(\"(checking vtable) num 2 relating trait \\\n-                ty {} to of_trait_ref {}\",\n-               vcx.infcx.trait_ref_to_string(&*trait_ref),\n-               vcx.infcx.trait_ref_to_string(&*of_trait_ref));\n-\n-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n-\n-\n-        // Recall that trait_ref -- the trait type we're casting to --\n-        // is the trait with id trait_ref.def_id applied to the substs\n-        // trait_ref.substs.\n-\n-        // Resolve any sub bounds. Note that there still may be free\n-        // type variables in substs. This might still be OK: the\n-        // process of looking up bounds might constrain some of them.\n-        //\n-        // This does not check built-in traits because those are handled\n-        // later in the kind checking pass.\n-        let im_generics =\n-            ty::lookup_item_type(tcx, impl_did).generics;\n-        let subres = lookup_vtables(vcx,\n-                                    span,\n-                                    &im_generics.types,\n-                                    &substs,\n-                                    is_early);\n-\n-        // substs might contain type variables, so we call\n-        // fixup_substs to resolve them.\n-        let substs_f = match fixup_substs(vcx, span,\n-                                          trait_ref.def_id,\n-                                          substs,\n-                                          is_early) {\n-            Some(ref substs) => (*substs).clone(),\n-            None => {\n-                assert!(is_early);\n-                // Bail out with a bogus answer\n-                return Some(vtable_error);\n-            }\n-        };\n-\n-        debug!(\"The fixed-up substs are {} - \\\n-                they will be unified with the bounds for \\\n-                the target ty, {}\",\n-               substs_f.types.repr(tcx),\n-               trait_ref.repr(tcx));\n-\n-        // Next, we unify the fixed-up substitutions for the impl self\n-        // ty with the substitutions from the trait type that we're\n-        // trying to cast to. connect_trait_tps requires these lists\n-        // of types to unify pairwise.\n-        // I am a little confused about this, since it seems to be\n-        // very similar to the relate_trait_refs we already do,\n-        // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);\n-\n-        // Finally, we register that we found a matching impl, and\n-        // record the def ID of the impl as well as the resolved list\n-        // of type substitutions for the target trait.\n-        found.push(vtable_static(impl_did, substs_f, subres));\n-    }\n-\n-    match found.len() {\n-        0 => { return None }\n-        1 => return Some(found.get(0).clone()),\n-        _ => {\n-            if !is_early {\n-                span_err!(vcx.tcx().sess, span, E0096,\n-                          \"multiple applicable methods in scope\");\n-            }\n-            return Some(found.get(0).clone());\n-        }\n-    }\n-}\n-\n-\n-fn fixup_substs(vcx: &VtableContext,\n-                span: Span,\n-                id: ast::DefId,\n-                substs: subst::Substs,\n-                is_early: bool)\n-                -> Option<subst::Substs> {\n-    let tcx = vcx.tcx();\n-    // use a dummy type just to package up the substs that need fixing up\n-    let t = ty::mk_trait(tcx,\n-                         id, substs,\n-                         ty::region_existential_bound(ty::ReStatic));\n-    fixup_ty(vcx, span, t, is_early).map(|t_f| {\n-        match ty::get(t_f).sty {\n-          ty::ty_trait(ref inner) => inner.substs.clone(),\n-          _ => fail!(\"t_f should be a trait\")\n-        }\n-    })\n-}\n-\n-fn fixup_ty(vcx: &VtableContext,\n-            span: Span,\n-            ty: ty::t,\n-            is_early: bool)\n-            -> Option<ty::t> {\n-    let tcx = vcx.tcx();\n-    match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {\n-        Ok(new_type) => Some(new_type),\n-        Err(e) if !is_early => {\n-            tcx.sess.span_err(span,\n-                format!(\"cannot determine a type for this bounded type \\\n-                         parameter: {}\",\n-                        fixup_err_to_string(e)).as_slice());\n-            Some(ty::mk_err())\n-        }\n-        Err(_) => {\n-            None\n-        }\n-    }\n-}\n-\n-fn connect_trait_tps(vcx: &VtableContext,\n-                     span: Span,\n-                     impl_substs: &subst::Substs,\n-                     trait_ref: Rc<ty::TraitRef>,\n-                     impl_did: ast::DefId) {\n-    let tcx = vcx.tcx();\n-\n-    let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n-        Some(t) => t,\n-        None => vcx.tcx().sess.span_bug(span,\n-                                  \"connect_trait_tps invoked on a type impl\")\n-    };\n-\n-    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);\n-}\n-\n-fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {\n-    debug!(\"insert_vtables(vtable_key={}, vtables={})\",\n-           vtable_key, vtables.repr(fcx.tcx()));\n-    fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);\n-}\n-\n-pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n-    fn mutability_allowed(a_mutbl: ast::Mutability,\n-                          b_mutbl: ast::Mutability) -> bool {\n-        a_mutbl == b_mutbl ||\n-        (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-    }\n-\n-    debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n-           ex.id, is_early, expr_to_string(ex));\n-    let _indent = indenter();\n-\n-    let cx = fcx.ccx;\n-    let check_object_cast = |src_ty: ty::t, target_ty: ty::t| {\n-      debug!(\"check_object_cast {} to {}\",\n-             fcx.infcx().ty_to_string(src_ty),\n-             fcx.infcx().ty_to_string(target_ty));\n-      // Check that a cast is of correct types.\n-      match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n-          (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n-          | (&ty::ty_ptr(ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n-            if !mutability_allowed(mt.mutbl, mutbl) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.tcx().sess, ex.span, E0097, \"types differ in mutability\");\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          (&ty::ty_uniq(..), &ty::ty_uniq(..) )\n-          | (&ty::ty_ptr(..), &ty::ty_ptr(..) )\n-          | (&ty::ty_ptr(..), &ty::ty_rptr(..)) => {}\n-          (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n-              infer::mk_subr(fcx.infcx(),\n-                             infer::RelateObjectBound(ex.span),\n-                             r_t,\n-                             r_s);\n-          }\n-          (&ty::ty_uniq(ty), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0098,\n-                                \"can only cast an boxed pointer to a boxed object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-\n-          }\n-          (&ty::ty_rptr(_, ty::mt{ty, ..}), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0099,\n-                                \"can only cast an &-pointer to an &-object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          (&ty::ty_ptr(ty::mt{ty, ..}), _) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(..) => {\n-                      span_err!(fcx.ccx.tcx.sess, ex.span, E0160,\n-                                \"can only cast an *-pointer or &-pointer to an *-object, not a {}\",\n-                                ty::ty_sort_string(fcx.tcx(), src_ty));\n-                  }\n-                  _ => {}\n-              }\n-          }\n-          _ => {}\n-      }\n-    };\n-    let resolve_object_cast = |src_ty: ty::t, target_ty: ty::t, key: MethodCall| {\n-      // Look up vtables for the type we're casting to,\n-      // passing in the source and target type.  The source\n-      // must be a pointer type suitable to the object sigil,\n-      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-      // Bounds of type's contents are not checked here, but in kind.rs.\n-      match ty::get(target_ty).sty {\n-          ty::ty_trait(box ty::TyTrait {\n-              def_id: target_def_id, substs: ref target_substs, ..\n-          }) => {\n-              let vcx = fcx.vtable_context();\n-\n-              // Take the type parameters from the object\n-              // type, but set the Self type (which is\n-              // unknown, for the object type) to be the type\n-              // we are casting from.\n-              let mut target_types = target_substs.types.clone();\n-              assert!(target_types.get_self().is_none());\n-              target_types.push(subst::SelfSpace, src_ty);\n-\n-              let target_trait_ref = Rc::new(ty::TraitRef {\n-                  def_id: target_def_id,\n-                  substs: subst::Substs {\n-                      regions: target_substs.regions.clone(),\n-                      types: target_types\n-                  }\n-              });\n-\n-              let param_bounds = ty::ParamBounds {\n-                  opt_region_bound: None,\n-                  builtin_bounds: ty::empty_builtin_bounds(),\n-                  trait_bounds: vec!(target_trait_ref)\n-              };\n-\n-              let vtables =\n-                    lookup_vtables_for_param(&vcx,\n-                                             ex.span,\n-                                             None,\n-                                             &param_bounds,\n-                                             src_ty,\n-                                             is_early);\n-\n-              if !is_early {\n-                  let mut r = VecPerParamSpace::empty();\n-                  r.push(subst::SelfSpace, vtables);\n-                  insert_vtables(fcx, key, r);\n-              }\n-          }\n-          _ => {}\n-      }\n-    };\n-    match ex.node {\n-      ast::ExprPath(..) => {\n-        fcx.opt_node_ty_substs(ex.id, |item_substs| {\n-            debug!(\"vtable resolution on parameter bounds for expr {}\",\n-                   ex.repr(fcx.tcx()));\n-            let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n-            let did = def.def_id();\n-            let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n-                   fcx.infcx().ty_to_string(item_ty.ty));\n-            debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n-                   item_ty.generics.types.repr(fcx.tcx()));\n-            let vcx = fcx.vtable_context();\n-            let vtbls = lookup_vtables(&vcx, ex.span,\n-                                       &item_ty.generics.types,\n-                                       &item_substs.substs, is_early);\n-            if !is_early {\n-                insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-            }\n-        });\n-      }\n-\n-      // Must resolve bounds on methods with bounded params\n-      ast::ExprBinary(_, _, _) |\n-      ast::ExprUnary(_, _) |\n-      ast::ExprAssignOp(_, _, _) |\n-      ast::ExprIndex(_, _) |\n-      ast::ExprMethodCall(_, _, _) |\n-      ast::ExprForLoop(..) |\n-      ast::ExprCall(..) => {\n-        match fcx.inh.method_map.borrow().find(&MethodCall::expr(ex.id)) {\n-          Some(method) => {\n-              debug!(\"vtable resolution on parameter bounds for method call {}\",\n-                     ex.repr(fcx.tcx()));\n-              let type_param_defs =\n-                  ty::method_call_type_param_defs(fcx, method.origin);\n-              let substs = fcx.method_ty_substs(ex.id);\n-              let vcx = fcx.vtable_context();\n-              let vtbls = lookup_vtables(&vcx, ex.span,\n-                                         &type_param_defs,\n-                                         &substs, is_early);\n-              if !is_early {\n-                  insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-              }\n-          }\n-          None => {}\n-        }\n-      }\n-      ast::ExprCast(ref src, _) => {\n-          debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n-          let target_ty = fcx.expr_ty(ex);\n-          let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                                  fcx.expr_ty(&**src));\n-          check_object_cast(src_ty, target_ty);\n-          match (ty::deref(src_ty, false), ty::deref(target_ty, false)) {\n-              (Some(s), Some(t)) => {\n-                  let key = MethodCall::expr(ex.id);\n-                  resolve_object_cast(s.ty, t.ty, key)\n-              }\n-              _ => {}\n-          }\n-      }\n-      _ => ()\n-    }\n-\n-    // Search for auto-adjustments to find trait coercions\n-    match fcx.inh.adjustments.borrow().find(&ex.id) {\n-        Some(adjustment) => {\n-            match *adjustment {\n-                _ if ty::adjust_is_object(adjustment) => {\n-                    let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                                            fcx.expr_ty(ex));\n-                    match ty::type_of_adjust(fcx.tcx(), adjustment) {\n-                        Some(target_ty) => {\n-                            check_object_cast(src_ty, target_ty)\n-                        }\n-                        None => {}\n-                    }\n-\n-                    match trait_cast_types(fcx, adjustment, src_ty, ex.span) {\n-                        Some((s, t)) => {\n-                            let key = MethodCall::autoobject(ex.id);\n-                            resolve_object_cast(s, t, key)\n-                        }\n-                        None => fail!(\"Couldn't extract types from adjustment\")\n-                    }\n-                }\n-                AutoDerefRef(ref adj) => {\n-                    for autoderef in range(0, adj.autoderefs) {\n-                        let method_call = MethodCall::autoderef(ex.id, autoderef);\n-                        match fcx.inh.method_map.borrow().find(&method_call) {\n-                            Some(method) => {\n-                                debug!(\"vtable resolution on parameter bounds for autoderef {}\",\n-                                       ex.repr(fcx.tcx()));\n-                                let type_param_defs =\n-                                    ty::method_call_type_param_defs(cx.tcx, method.origin);\n-                                let vcx = fcx.vtable_context();\n-                                let vtbls = lookup_vtables(&vcx, ex.span,\n-                                                           &type_param_defs,\n-                                                           &method.substs, is_early);\n-                                if !is_early {\n-                                    insert_vtables(fcx, method_call, vtbls);\n-                                }\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        None => {}\n-    }\n-}\n-\n-// When we coerce (possibly implicitly) from a concrete type to a trait type, this\n-// function returns the concrete type and trait. This might happen arbitrarily\n-// deep in the adjustment. This function will fail if the adjustment does not\n-// match the source type.\n-// This function will always return types if ty::adjust_is_object is true for the\n-// adjustment\n-fn trait_cast_types(fcx: &FnCtxt,\n-                    adj: &ty::AutoAdjustment,\n-                    src_ty: ty::t,\n-                    sp: Span)\n-                    -> Option<(ty::t, ty::t)> {\n-    fn trait_cast_types_autoref(fcx: &FnCtxt,\n-                                autoref: &ty::AutoRef,\n-                                src_ty: ty::t,\n-                                sp: Span)\n-                                -> Option<(ty::t, ty::t)> {\n-        fn trait_cast_types_unsize(fcx: &FnCtxt,\n-                                   k: &ty::UnsizeKind,\n-                                   src_ty: ty::t,\n-                                   sp: Span)\n-                                   -> Option<(ty::t, ty::t)> {\n-            match k {\n-                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n-                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n-                }\n-                &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(src_ty).sty {\n-                    ty::ty_struct(_, ref substs) => {\n-                        let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                        let field_ty = structurally_resolved_type(fcx, sp, ty_substs[tp_index]);\n-                        trait_cast_types_unsize(fcx, k, field_ty, sp)\n-                    }\n-                    _ => fail!(\"Failed to find a ty_struct to correspond with \\\n-                                UnsizeStruct whilst walking adjustment. Found {}\",\n-                                ppaux::ty_to_string(fcx.tcx(), src_ty))\n-                },\n-                _ => None\n-            }\n-        }\n-\n-        match autoref {\n-            &ty::AutoUnsize(ref k) |\n-            &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n-            &ty::AutoPtr(_, _, Some(box ref autoref)) |\n-            &ty::AutoUnsafe(_, Some(box ref autoref)) => {\n-                trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    match adj {\n-        &ty::AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), autoderefs}) => {\n-            let mut derefed_type = src_ty;\n-            for _ in range(0, autoderefs) {\n-                derefed_type = ty::deref(derefed_type, true).unwrap().ty;\n-                derefed_type = structurally_resolved_type(fcx, sp, derefed_type)\n-            }\n-            trait_cast_types_autoref(fcx, autoref, derefed_type, sp)\n-        }\n-        _ => None\n-    }\n-}\n-\n-pub fn resolve_impl(tcx: &ty::ctxt,\n-                    impl_item: &ast::Item,\n-                    impl_generics: &ty::Generics,\n-                    impl_trait_ref: &ty::TraitRef) {\n-    /*!\n-     * The situation is as follows. We have some trait like:\n-     *\n-     *    trait Foo<A:Clone> : Bar {\n-     *        fn method() { ... }\n-     *    }\n-     *\n-     * and an impl like:\n-     *\n-     *    impl<B:Clone> Foo<B> for int { ... }\n-     *\n-     * We want to validate that the various requirements of the trait\n-     * are met:\n-     *\n-     *    A:Clone, Self:Bar\n-     *\n-     * But of course after substituting the types from the impl:\n-     *\n-     *    B:Clone, int:Bar\n-     *\n-     * We store these results away as the \"impl_res\" for use by the\n-     * default methods.\n-     */\n-\n-    debug!(\"resolve_impl(impl_item.id={})\",\n-           impl_item.id);\n-\n-    let param_env = ty::construct_parameter_environment(tcx,\n-                                                        impl_generics,\n-                                                        impl_item.id);\n-\n-    // The impl_trait_ref in our example above would be\n-    //     `Foo<B> for int`\n-    let impl_trait_ref = impl_trait_ref.subst(tcx, &param_env.free_substs);\n-    debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(tcx));\n-\n-    let infcx = &infer::new_infer_ctxt(tcx);\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: infcx,\n-        param_env: &param_env,\n-        unboxed_closures: &unboxed_closures,\n-    };\n-\n-    // Resolve the vtables for the trait reference on the impl.  This\n-    // serves many purposes, best explained by example. Imagine we have:\n-    //\n-    //    trait A<T:B> : C { fn x(&self) { ... } }\n-    //\n-    // and\n-    //\n-    //    impl A<int> for uint { ... }\n-    //\n-    // In that case, the trait ref will be `A<int> for uint`. Resolving\n-    // this will first check that the various types meet their requirements:\n-    //\n-    // 1. Because of T:B, int must implement the trait B\n-    // 2. Because of the supertrait C, uint must implement the trait C.\n-    //\n-    // Simultaneously, the result of this resolution (`vtbls`), is precisely\n-    // the set of vtable information needed to compile the default method\n-    // `x()` adapted to the impl. (After all, a default method is basically\n-    // the same as:\n-    //\n-    //     fn default_x<T:B, Self:A>(...) { .. .})\n-\n-    let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n-    let vtbls = lookup_vtables(&vcx,\n-                                   impl_item.span,\n-                                   &trait_def.generics.types,\n-                                   &impl_trait_ref.substs,\n-                                   false);\n-\n-    infcx.resolve_regions_and_report_errors();\n-\n-    let vtbls = writeback::resolve_impl_res(infcx, impl_item.span, &vtbls);\n-    let impl_def_id = ast_util::local_def(impl_item.id);\n-\n-    debug!(\"impl_vtables for {} are {}\",\n-           impl_def_id.repr(tcx),\n-           vtbls.repr(tcx));\n-\n-    tcx.impl_vtables.borrow_mut().insert(impl_def_id, vtbls);\n-}\n-\n-/// Resolve vtables for a method call after typeck has finished.\n-/// Used by trans to monomorphize artificial method callees (e.g. drop).\n-pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n-                            substs: &subst::Substs) -> vtable_res {\n-    let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),\n-        unboxed_closures: &unboxed_closures,\n-    };\n-\n-    lookup_vtables(&vcx,\n-                   tcx.map.span(id),\n-                   &generics.types,\n-                   substs,\n-                   false)\n-}\n-\n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for &'a FnCtxt<'b, 'tcx> {\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n-        early_resolve_expr(ex, *self, false);\n-        visit::walk_expr(self, ex);\n-    }\n-    fn visit_item(&mut self, _: &ast::Item) {\n-        // no-op\n-    }\n-}\n-\n-// Detect points where a trait-bounded type parameter is\n-// instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(mut fcx: &FnCtxt, bl: &ast::Block) {\n-    visit::walk_block(&mut fcx, bl);\n-}\n-\n-/// Used in the kind checker after typechecking has finished. Calls\n-/// `any_missing` if any bounds were missing.\n-pub fn check_param_bounds(tcx: &ty::ctxt,\n-                          span: Span,\n-                          parameter_environment: &ty::ParameterEnvironment,\n-                          type_param_defs:\n-                            &VecPerParamSpace<ty::TypeParameterDef>,\n-                          substs: &subst::Substs,\n-                          any_missing: |&ty::TraitRef|) {\n-    let unboxed_closures = RefCell::new(DefIdMap::new());\n-    let vcx = VtableContext {\n-        infcx: &infer::new_infer_ctxt(tcx),\n-        param_env: parameter_environment,\n-        unboxed_closures: &unboxed_closures,\n-    };\n-    let vtable_param_results =\n-        lookup_vtables(&vcx, span, type_param_defs, substs, false);\n-    for (vtable_param_result, type_param_def) in\n-            vtable_param_results.iter().zip(type_param_defs.iter()) {\n-        for (vtable_result, trait_ref) in\n-                vtable_param_result.iter()\n-                                   .zip(type_param_def.bounds\n-                                                      .trait_bounds\n-                                                      .iter()) {\n-            match *vtable_result {\n-                vtable_error => any_missing(&**trait_ref),\n-                vtable_static(..) |\n-                vtable_param(..) |\n-                vtable_unboxed_closure(..) => {}\n-            }\n-        }\n-    }\n-}\n-"}, {"sha": "f75d2622fdb895520d4cb05ff24fa99d5c68d285", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -0,0 +1,407 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{SelfSpace};\n+use middle::traits;\n+use middle::traits::{SelectionError, Overflow,\n+                     OutputTypeParameterMismatch, Unimplemented};\n+use middle::traits::{Obligation, obligation_for_builtin_bound};\n+use middle::traits::{FulfillmentError, Ambiguity};\n+use middle::traits::{ObligationCause};\n+use middle::ty;\n+use middle::typeck::check::{FnCtxt,\n+                            structurally_resolved_type};\n+use middle::typeck::infer;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::ppaux::UserString;\n+use util::ppaux::Repr;\n+\n+/// When reporting an error about a failed trait obligation, it's nice\n+/// to include some context indicating why we were checking that\n+/// obligation in the first place. The span is often enough but\n+/// sometimes it's not. Currently this enum is a bit of a hack and I\n+/// suspect it should be carried in the obligation or more deeply\n+/// integrated somehow.\n+pub enum ErrorReportingContext {\n+    GenericContext,\n+    ImplSupertraitCheck,\n+}\n+\n+pub fn check_object_cast(fcx: &FnCtxt,\n+                         cast_expr: &ast::Expr,\n+                         source_expr: &ast::Expr,\n+                         target_object_ty: ty::t)\n+{\n+    debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n+           cast_expr.repr(fcx.tcx()),\n+           target_object_ty.repr(fcx.tcx()));\n+\n+    // Look up vtables for the type we're casting to,\n+    // passing in the source and target type.  The source\n+    // must be a pointer type suitable to the object sigil,\n+    // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n+    let source_ty = fcx.expr_ty(source_expr);\n+    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n+    debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n+    match (&ty::get(source_ty).sty, &ty::get(target_object_ty).sty) {\n+        (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n+            let object_trait = object_trait(&object_trait_ty);\n+\n+            // Ensure that if ~T is cast to ~Trait, then T : Trait\n+            push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+        }\n+\n+        (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n+                                                mutbl: referent_mutbl }),\n+         &ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n+                                              mutbl: target_mutbl })) =>\n+        {\n+            let object_trait = object_trait(&object_trait_ty);\n+            if !mutability_allowed(referent_mutbl, target_mutbl) {\n+                fcx.tcx().sess.span_err(source_expr.span,\n+                                        \"types differ in mutability\");\n+            } else {\n+                // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n+                push_cast_obligation(fcx, cast_expr,\n+                                     object_trait,\n+                                     referent_ty);\n+\n+                // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n+                infer::mk_subr(fcx.infcx(),\n+                               infer::RelateObjectBound(source_expr.span),\n+                               target_region,\n+                               referent_region);\n+            }\n+        }\n+\n+        (_, &ty::ty_uniq(..)) => {\n+            fcx.ccx.tcx.sess.span_err(\n+                source_expr.span,\n+                format!(\"can only cast an boxed pointer \\\n+                         to a boxed object, not a {}\",\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+        }\n+\n+        (_, &ty::ty_rptr(..)) => {\n+            fcx.ccx.tcx.sess.span_err(\n+                source_expr.span,\n+                format!(\"can only cast a &-pointer \\\n+                         to an &-object, not a {}\",\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).as_slice());\n+        }\n+\n+        _ => {\n+            fcx.tcx().sess.span_bug(\n+                source_expr.span,\n+                \"expected object type\");\n+        }\n+    }\n+\n+    // Because we currently give unsound lifetimes to the \"ty_box\", I\n+    // could have written &'static ty::TyTrait here, but it seems\n+    // gratuitously unsafe.\n+    fn object_trait<'a>(t: &'a ty::t) -> &'a ty::TyTrait {\n+        match ty::get(*t).sty {\n+            ty::ty_trait(ref ty_trait) => &**ty_trait,\n+            _ => fail!(\"expected ty_trait\")\n+        }\n+    }\n+\n+    fn mutability_allowed(a_mutbl: ast::Mutability,\n+                          b_mutbl: ast::Mutability)\n+                          -> bool {\n+        a_mutbl == b_mutbl ||\n+            (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n+    }\n+\n+    fn push_cast_obligation(fcx: &FnCtxt,\n+                            cast_expr: &ast::Expr,\n+                            object_trait: &ty::TyTrait,\n+                            referent_ty: ty::t) {\n+        let object_trait_ref =\n+            register_object_cast_obligations(fcx,\n+                                             cast_expr.span,\n+                                             object_trait,\n+                                             referent_ty);\n+\n+        // Finally record the object_trait_ref for use during trans\n+        // (it would prob be better not to do this, but it's just kind\n+        // of a pain to have to reconstruct it).\n+        fcx.write_object_cast(cast_expr.id, object_trait_ref);\n+    }\n+}\n+\n+pub fn register_object_cast_obligations(fcx: &FnCtxt,\n+                                        span: Span,\n+                                        object_trait: &ty::TyTrait,\n+                                        referent_ty: ty::t)\n+                                        -> Rc<ty::TraitRef>\n+{\n+    // This is just for better error reporting. Kinda goofy. The object type stuff\n+    // needs some refactoring so there is a more convenient type to pass around.\n+    let object_trait_ty =\n+        ty::mk_trait(fcx.tcx(),\n+                     object_trait.def_id,\n+                     object_trait.substs.clone(),\n+                     object_trait.bounds);\n+\n+    debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n+           referent_ty.repr(fcx.tcx()),\n+           object_trait_ty.repr(fcx.tcx()));\n+\n+    // Take the type parameters from the object type, but set\n+    // the Self type (which is unknown, for the object type)\n+    // to be the type we are casting from.\n+    let mut object_substs = object_trait.substs.clone();\n+    assert!(object_substs.self_ty().is_none());\n+    object_substs.types.push(SelfSpace, referent_ty);\n+\n+    // Create the obligation for casting from T to Trait.\n+    let object_trait_ref =\n+        Rc::new(ty::TraitRef { def_id: object_trait.def_id,\n+                               substs: object_substs });\n+    let object_obligation =\n+        Obligation::new(\n+            ObligationCause::new(span,\n+                                 traits::ObjectCastObligation(object_trait_ty)),\n+            object_trait_ref.clone());\n+    fcx.register_obligation(object_obligation);\n+\n+    // Create additional obligations for all the various builtin\n+    // bounds attached to the object cast. (In other words, if the\n+    // object type is Foo+Send, this would create an obligation\n+    // for the Send check.)\n+    for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n+        fcx.register_obligation(\n+            obligation_for_builtin_bound(\n+                fcx.tcx(),\n+                ObligationCause::new(span,\n+                                     traits::ObjectCastObligation(object_trait_ty)),\n+                referent_ty,\n+                builtin_bound));\n+    }\n+\n+    object_trait_ref\n+}\n+\n+pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n+    debug!(\"select_all_fcx_obligations_or_error\");\n+\n+    let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n+    let r =\n+        fulfillment_cx.select_all_or_error(\n+            fcx.infcx(),\n+            &fcx.inh.param_env,\n+            &*fcx.inh.unboxed_closures.borrow());\n+    match r {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+pub fn check_builtin_bound_obligations(fcx: &FnCtxt) {\n+    /*!\n+     * Hacky second pass to check builtin-bounds obligations *after*\n+     * writeback occurs.\n+     */\n+\n+    match\n+        fcx.inh.fulfillment_cx.borrow()\n+                              .check_builtin_bound_obligations(fcx.infcx())\n+    {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n+                     -> (ty::TraitRef, ty::t)\n+{\n+    let trait_ref =\n+        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+            &*obligation.trait_ref);\n+    let self_ty =\n+        trait_ref.substs.self_ty().unwrap();\n+    (trait_ref, self_ty)\n+}\n+\n+pub fn report_fulfillment_errors(fcx: &FnCtxt,\n+                                 errors: &Vec<FulfillmentError>) {\n+    for error in errors.iter() {\n+        report_fulfillment_error(fcx, error);\n+    }\n+}\n+\n+pub fn report_fulfillment_error(fcx: &FnCtxt,\n+                                error: &FulfillmentError) {\n+    match error.code {\n+        SelectionError(ref e) => {\n+            report_selection_error(fcx, &error.obligation, e);\n+        }\n+        Ambiguity => {\n+            maybe_report_ambiguity(fcx, &error.obligation);\n+        }\n+    }\n+}\n+\n+pub fn report_selection_error(fcx: &FnCtxt,\n+                              obligation: &Obligation,\n+                              error: &SelectionError) {\n+    match *error {\n+        Unimplemented => {\n+            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+            if !ty::type_is_error(self_ty) {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"the trait `{}` is not implemented for the type `{}`\",\n+                        trait_ref.user_string(fcx.tcx()),\n+                        self_ty.user_string(fcx.tcx())).as_slice());\n+                note_obligation_cause(fcx, obligation);\n+            }\n+        }\n+        Overflow => {\n+            report_overflow(fcx, obligation);\n+        }\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref e) => {\n+            let expected_trait_ref =\n+                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                    &**expected_trait_ref);\n+            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+            if !ty::type_is_error(self_ty) {\n+                fcx.tcx().sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                         but the trait `{}` is required ({})\",\n+                        self_ty.user_string(fcx.tcx()),\n+                        expected_trait_ref.user_string(fcx.tcx()),\n+                        trait_ref.user_string(fcx.tcx()),\n+                        ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n+                note_obligation_cause(fcx, obligation);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn report_overflow(fcx: &FnCtxt, obligation: &Obligation) {\n+    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+    if ty::type_is_error(self_ty) {\n+        fcx.tcx().sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"could not locate an impl of the trait `{}` for \\\n+                 the type `{}` due to overflow; possible cyclic \\\n+                 dependency between impls\",\n+                trait_ref.user_string(fcx.tcx()),\n+                self_ty.user_string(fcx.tcx())).as_slice());\n+        note_obligation_cause(fcx, obligation);\n+    }\n+}\n+\n+pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n+    // Unable to successfully determine, probably means\n+    // insufficient type information, but could mean\n+    // ambiguous impls. The latter *ought* to be a\n+    // coherence violation, so we don't report it here.\n+    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n+           trait_ref.repr(fcx.tcx()),\n+           self_ty.repr(fcx.tcx()),\n+           obligation.repr(fcx.tcx()));\n+    if ty::type_is_error(self_ty) {\n+    } else if ty::type_needs_infer(self_ty) {\n+        fcx.tcx().sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"unable to infer enough type information to \\\n+             locate the impl of the trait `{}` for \\\n+             the type `{}`; type annotations required\",\n+            trait_ref.user_string(fcx.tcx()),\n+            self_ty.user_string(fcx.tcx())).as_slice());\n+        note_obligation_cause(fcx, obligation);\n+    } else if fcx.tcx().sess.err_count() == 0 {\n+         // Ambiguity. Coherence should have reported an error.\n+        fcx.tcx().sess.span_bug(\n+            obligation.cause.span,\n+            format!(\n+                \"coherence failed to report ambiguity: \\\n+                 cannot locate the impl of the trait `{}` for \\\n+                 the type `{}`\",\n+                trait_ref.user_string(fcx.tcx()),\n+                self_ty.user_string(fcx.tcx())).as_slice());\n+    }\n+}\n+\n+pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n+    /*! Select as many obligations as we can at present. */\n+\n+    match\n+        fcx.inh.fulfillment_cx\n+        .borrow_mut()\n+        .select_where_possible(fcx.infcx(),\n+                               &fcx.inh.param_env,\n+                               &*fcx.inh.unboxed_closures.borrow())\n+    {\n+        Ok(()) => { }\n+        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+    }\n+}\n+\n+fn note_obligation_cause(fcx: &FnCtxt,\n+                         obligation: &Obligation) {\n+    let tcx = fcx.tcx();\n+    let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n+    match obligation.cause.code {\n+        traits::MiscObligation => { }\n+        traits::ItemObligation(item_def_id) => {\n+            let item_name = ty::item_path_str(tcx, item_def_id);\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the trait `{}` must be implemented because it is required by `{}`\",\n+                    trait_name,\n+                    item_name).as_slice());\n+        }\n+        traits::ObjectCastObligation(object_ty) => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the trait `{}` must be implemented for the cast \\\n+                     to the object type `{}`\",\n+                    trait_name,\n+                    fcx.infcx().ty_to_string(object_ty)).as_slice());\n+        }\n+        traits::RepeatVec => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"the `Copy` trait is required because the \\\n+                     repeated element will be copied\").as_slice());\n+        }\n+        traits::VariableType(_) => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"all local variables must have a statically known size\");\n+        }\n+        traits::AssignmentLhsSized => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"the left-hand-side of an assignment must have a statically known size\");\n+        }\n+        traits::StructInitializerSized => {\n+            tcx.sess.span_note(\n+                obligation.cause.span,\n+                \"structs must have a statically known size to be initialized\");\n+        }\n+    }\n+}"}, {"sha": "73c0a4e10fc2a8fcdd047b6c04813448ad261cdf", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -0,0 +1,365 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{Subst};\n+use middle::traits;\n+use middle::ty;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::typeck::astconv::AstConv;\n+use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable2, regionck};\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::CrateCtxt;\n+use util::ppaux::Repr;\n+\n+use std::collections::HashSet;\n+use syntax::ast;\n+use syntax::ast_util::{local_def};\n+use syntax::codemap::Span;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n+    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+    cache: HashSet<ty::t>\n+}\n+\n+impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>) -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+        CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n+    }\n+\n+    fn check_item_well_formed(&mut self, ccx: &CrateCtxt, item: &ast::Item) {\n+        /*!\n+         * Checks that the field types (in a struct def'n) or\n+         * argument types (in an enum def'n) are well-formed,\n+         * meaning that they do not require any constraints not\n+         * declared in the struct definition itself.\n+         * For example, this definition would be illegal:\n+         *\n+         *     struct Ref<'a, T> { x: &'a T }\n+         *\n+         * because the type did not declare that `T:'a`.\n+         *\n+         * We do this check as a pre-pass before checking fn bodies\n+         * because if these constraints are not included it frequently\n+         * leads to confusing errors in fn bodies. So it's better to check\n+         * the types first.\n+         */\n+\n+        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+               item.id,\n+               ty::item_path_str(ccx.tcx, local_def(item.id)));\n+\n+        let ccx = self.ccx;\n+        match item.node {\n+            ast::ItemImpl(..) => {\n+                self.check_impl(item);\n+            }\n+            ast::ItemFn(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStatic(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStruct(..) => {\n+                self.check_type_defn(item, |fcx| {\n+                    ty::struct_fields(ccx.tcx, local_def(item.id),\n+                                      &fcx.inh.param_env.free_substs)\n+                        .iter()\n+                        .map(|f| f.mt.ty)\n+                        .collect()\n+                });\n+            }\n+            ast::ItemEnum(..) => {\n+                self.check_type_defn(item, |fcx| {\n+                    ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n+                                             &fcx.inh.param_env.free_substs)\n+                        .iter()\n+                        .flat_map(|variant| {\n+                            variant.args\n+                                .iter()\n+                                .map(|&arg_ty| arg_ty)\n+                        })\n+                        .collect()\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn with_fcx(&mut self,\n+                ccx: &CrateCtxt,\n+                item: &ast::Item,\n+                f: |&mut CheckTypeWellFormedVisitor, &FnCtxt|) {\n+        let item_def_id = local_def(item.id);\n+        let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n+        let param_env =\n+            ty::construct_parameter_environment(ccx.tcx,\n+                                                item.span,\n+                                                &polytype.generics,\n+                                                item.id);\n+        let inh = Inherited::new(ccx.tcx, param_env);\n+        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n+        f(self, &fcx);\n+        vtable2::select_all_fcx_obligations_or_error(&fcx);\n+        regionck::regionck_item(&fcx, item);\n+        vtable2::check_builtin_bound_obligations(&fcx);\n+    }\n+\n+    fn check_type_defn(&mut self,\n+                       item: &ast::Item,\n+                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n+    {\n+        /*!\n+         * In a type definition, we check that to ensure that the types of the fields are\n+         * well-formed.\n+         */\n+\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let field_tys = lookup_fields(fcx);\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+            for &ty in field_tys.iter() {\n+                // Regions are checked below.\n+                bounds_checker.check_traits_in_ty(ty);\n+            }\n+\n+            regionck::regionck_ensure_component_tys_wf(\n+                fcx, item.span, field_tys.as_slice());\n+        });\n+    }\n+\n+    fn check_item_type(&mut self,\n+                       item: &ast::Item)\n+    {\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+            let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let item_ty = polytype.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            bounds_checker.check_traits_in_ty(item_ty);\n+        });\n+    }\n+\n+    fn check_impl(&mut self,\n+                  item: &ast::Item)\n+    {\n+        self.with_fcx(self.ccx, item, |this, fcx| {\n+            let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n+                                                        item.id, Some(&mut this.cache));\n+\n+            let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n+            let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+\n+            bounds_checker.check_traits_in_ty(self_ty);\n+\n+            let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n+                None => { return; }\n+                Some(t) => { t }\n+            };\n+            let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+\n+            // We are stricter on the trait-ref in an impl than the\n+            // self-type.  In particular, we enforce region\n+            // relationships. The reason for this is that (at least\n+            // presently) \"appyling\" an impl does not require that the\n+            // application site check the well-formedness constraints on the\n+            // trait reference. Instead, this is done at the impl site.\n+            // Arguably this is wrong and we should treat the trait-reference\n+            // the same way as we treat the self-type.\n+            bounds_checker.check_trait_ref(&trait_ref);\n+\n+            let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_ref.def_id);\n+\n+            let cause =\n+                traits::ObligationCause::new(\n+                    item.span,\n+                    traits::ItemObligation(trait_ref.def_id));\n+\n+            // Find the supertrait bounds. This will add `int:Bar`.\n+            //\n+            // FIXME -- This is a bit ill-factored. There is very similar\n+            // code in traits::util::obligations_for_generics.\n+            fcx.add_region_obligations_for_type_parameter(item.span,\n+                                                          ty::ParamTy::for_self(trait_ref.def_id),\n+                                                          &trait_def.bounds,\n+                                                          trait_ref.self_ty());\n+            for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n+                fcx.register_obligation(\n+                    traits::obligation_for_builtin_bound(fcx.tcx(),\n+                                                         cause,\n+                                                         trait_ref.self_ty(),\n+                                                         builtin_bound));\n+            }\n+            for trait_bound in trait_def.bounds.trait_bounds.iter() {\n+                let trait_bound = trait_bound.subst(fcx.tcx(), &trait_ref.substs);\n+                fcx.register_obligation(\n+                    traits::Obligation::new(cause, trait_bound));\n+            }\n+        });\n+    }\n+}\n+\n+impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    fn visit_item(&mut self, i: &'v ast::Item) {\n+        self.check_item_well_formed(self.ccx, i);\n+        visit::walk_item(self, i);\n+    }\n+}\n+\n+pub struct BoundsChecker<'cx,'tcx:'cx> {\n+    fcx: &'cx FnCtxt<'cx,'tcx>,\n+    span: Span,\n+    scope_id: ast::NodeId,\n+    binding_count: uint,\n+    cache: Option<&'cx mut HashSet<ty::t>>,\n+}\n+\n+impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n+    pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n+               span: Span,\n+               scope_id: ast::NodeId,\n+               cache: Option<&'cx mut HashSet<ty::t>>)\n+               -> BoundsChecker<'cx,'tcx> {\n+        BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n+                        cache: cache, binding_count: 0 }\n+    }\n+\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef) {\n+        /*!\n+         * Given a trait ref like `A : Trait<B>`, where `Trait` is\n+         * defined as (say):\n+         *\n+         *     trait Trait<B:OtherTrait> : Copy { ... }\n+         *\n+         * This routine will check that `B : OtherTrait` and `A :\n+         * Trait<B>`. It will also recursively check that the types\n+         * `A` and `B` are well-formed.\n+         *\n+         * Note that it does not (currently, at least)\n+         * check that `A : Copy` (that check is delegated to the point\n+         * where impl `A : Trait<B>` is implemented).\n+         */\n+\n+        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n+\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::new(\n+                self.span,\n+                traits::ItemObligation(trait_ref.def_id)),\n+            &trait_ref.substs,\n+            &trait_def.generics);\n+\n+        for &ty in trait_ref.substs.types.iter() {\n+            self.check_traits_in_ty(ty);\n+        }\n+    }\n+\n+    pub fn check_ty(&mut self, ty: ty::t) {\n+        ty.fold_with(self);\n+    }\n+\n+    fn check_traits_in_ty(&mut self, ty: ty::t) {\n+        // When checking types outside of a type def'n, we ignore\n+        // region obligations. See discussion below in fold_ty().\n+        self.binding_count += 1;\n+        ty.fold_with(self);\n+        self.binding_count -= 1;\n+    }\n+}\n+\n+impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        debug!(\"BoundsChecker t={}\",\n+               t.repr(self.tcx()));\n+\n+        match self.cache {\n+            Some(ref mut cache) => {\n+                if !cache.insert(t) {\n+                    // Already checked this type! Don't check again.\n+                    debug!(\"cached\");\n+                    return t;\n+                }\n+            }\n+            None => { }\n+        }\n+\n+        match ty::get(t).sty{\n+            ty::ty_struct(type_id, ref substs) |\n+            ty::ty_enum(type_id, ref substs) => {\n+                let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n+\n+                if self.binding_count == 0 {\n+                    self.fcx.add_obligations_for_parameters(\n+                        traits::ObligationCause::new(self.span,\n+                                                     traits::ItemObligation(type_id)),\n+                        substs,\n+                        &polytype.generics);\n+                } else {\n+                    // There are two circumstances in which we ignore\n+                    // region obligations.\n+                    //\n+                    // The first is when we are inside of a closure\n+                    // type. This is because in that case the region\n+                    // obligations for the parameter types are things\n+                    // that the closure body gets to assume and the\n+                    // caller must prove at the time of call. In other\n+                    // words, if there is a type like `<'a, 'b> | &'a\n+                    // &'b int |`, it is well-formed, and caller will\n+                    // have to show that `'b : 'a` at the time of\n+                    // call.\n+                    //\n+                    // The second is when we are checking for\n+                    // well-formedness outside of a type def'n or fn\n+                    // body. This is for a similar reason: in general,\n+                    // we only do WF checking for regions in the\n+                    // result of expressions and type definitions, so\n+                    // to as allow for implicit where clauses.\n+                    //\n+                    // (I believe we should do the same for traits, but\n+                    // that will require an RFC. -nmatsakis)\n+                    self.fcx.add_trait_obligations_for_generics(\n+                        traits::ObligationCause::new(self.span,\n+                                                     traits::ItemObligation(type_id)),\n+                        substs,\n+                        &polytype.generics);\n+                }\n+\n+                self.fold_substs(substs);\n+            }\n+            ty::ty_bare_fn(ty::BareFnTy{sig: ref fn_sig, ..}) |\n+            ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n+                self.binding_count += 1;\n+\n+                let (_, fn_sig) =\n+                    replace_late_bound_regions_in_fn_sig(\n+                        self.fcx.tcx(), fn_sig,\n+                        |br| ty::ReFree(ty::FreeRegion{scope_id: self.scope_id,\n+                                                       bound_region: br}));\n+\n+                debug!(\"late-bound regions replaced: {}\",\n+                       fn_sig.repr(self.tcx()));\n+\n+                self.fold_sig(&fn_sig);\n+\n+                self.binding_count -= 1;\n+            }\n+            ref sty => {\n+                self.fold_sty(sty);\n+            }\n+        }\n+\n+        t // we're not folding to produce a new type, so just return `t` here\n+    }\n+}"}, {"sha": "ffe019b314a87c32289482e5fc30073b84f26506", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -44,6 +44,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_unboxed_closures();\n+    wbcx.visit_object_cast_map();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -63,6 +64,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     }\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_unboxed_closures();\n+    wbcx.visit_object_cast_map();\n }\n \n pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n@@ -128,8 +130,6 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n-        self.visit_vtable_map_entry(ResolvingExpr(e.span),\n-                                    MethodCall::expr(e.id));\n \n         match e.node {\n             ast::ExprFnBlock(_, ref decl, _) |\n@@ -235,6 +235,27 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_object_cast_map(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        for (&node_id, trait_ref) in self.fcx\n+                                            .inh\n+                                            .object_cast_map\n+                                            .borrow()\n+                                            .iter()\n+        {\n+            let span = ty::expr_span(self.tcx(), node_id);\n+            let reason = ResolvingExpr(span);\n+            let closure_ty = self.resolve(trait_ref, reason);\n+            self.tcx()\n+                .object_cast_map\n+                .borrow_mut()\n+                .insert(node_id, closure_ty);\n+        }\n+    }\n+\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n@@ -284,13 +305,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         for autoderef in range(0, adj.autoderefs) {\n                             let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n-                            self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n                         if adj_object {\n                             let method_call = MethodCall::autoobject(id);\n                             self.visit_method_map_entry(reason, method_call);\n-                            self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n                         ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -329,22 +348,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_vtable_map_entry(&self,\n-                              reason: ResolveReason,\n-                              vtable_key: MethodCall) {\n-        // Resolve any vtable map entry\n-        match self.fcx.inh.vtable_map.borrow_mut().pop(&vtable_key) {\n-            Some(origins) => {\n-                let r_origins = self.resolve(&origins, reason);\n-                debug!(\"writeback::resolve_vtable_map_entry(\\\n-                        vtable_key={}, vtables={:?})\",\n-                       vtable_key, r_origins.repr(self.tcx()));\n-                self.tcx().vtable_map.borrow_mut().insert(vtable_key, r_origins);\n-            }\n-            None => {}\n-        }\n-    }\n-\n     fn resolve<T:ResolveIn>(&self, t: &T, reason: ResolveReason) -> T {\n         t.resolve_in(&mut Resolver::new(self.fcx, reason))\n     }\n@@ -504,3 +507,11 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// During type check, we store promises with the result of trait\n+// lookup rather than the actual results (because the results are not\n+// necessarily available immediately). These routines unwind the\n+// promises. It is expected that we will have already reported any\n+// errors that may be encountered, so if the promises store an error,\n+// a dummy result is returned."}, {"sha": "e0a35dc72a39f4220546a736b335e96d9fb2a812", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688ddf79156aa01a2507412c9b766f48ef208b04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=688ddf79156aa01a2507412c9b766f48ef208b04", "patch": "@@ -327,10 +327,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sty_b = &ty::get(b).sty;\n         match (sty_a, sty_b) {\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_rptr(_, mt_b)) => {\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n                         Some((ty, kind)) => {\n+                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                                return Err(ty::terr_mutability);\n+                            }\n+\n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n@@ -349,10 +353,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n                 })\n             }\n-            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b)) => {\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n                         Some((ty, kind)) => {\n+                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                                return Err(ty::terr_mutability);\n+                            }\n+\n                             let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n@@ -510,19 +518,23 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                      a: ty::t,\n                      sty_a: &ty::sty,\n                      b: ty::t,\n+                     b_mutbl: ast::Mutability,\n                      mk_ty: |ty::t| -> ty::t,\n                      mk_adjust: || -> ty::AutoRef) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n         match *sty_a {\n-            ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n                         ref substs,\n                         bounds,\n                         ..\n-                    }) => {\n+                    }) =>\n+                {\n+                    debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n+\n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -624,3 +636,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })))\n     }\n }\n+\n+fn can_coerce_mutbls(from_mutbl: ast::Mutability,\n+                     to_mutbl: ast::Mutability)\n+                     -> bool {\n+    match (from_mutbl, to_mutbl) {\n+        (ast::MutMutable, ast::MutMutable) => true,\n+        (ast::MutImmutable, ast::MutImmutable) => true,\n+        (ast::MutMutable, ast::MutImmutable) => true,\n+        (ast::MutImmutable, ast::MutMutable) => false,\n+    }\n+}"}]}