{"sha": "8956c1ed1d95915ac17612cd93df38243b875790", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NTZjMWVkMWQ5NTkxNWFjMTc2MTJjZDkzZGYzODI0M2I4NzU3OTA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-10-27T17:07:05Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:23:04Z"}, "message": "Factor out witness reconstruction", "tree": {"sha": "f5908af573c941ea21c43d7286804dab20277092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5908af573c941ea21c43d7286804dab20277092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8956c1ed1d95915ac17612cd93df38243b875790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8956c1ed1d95915ac17612cd93df38243b875790", "html_url": "https://github.com/rust-lang/rust/commit/8956c1ed1d95915ac17612cd93df38243b875790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8956c1ed1d95915ac17612cd93df38243b875790/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7fa9f12ca62fc4f95306fa0c233de948edf303c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fa9f12ca62fc4f95306fa0c233de948edf303c", "html_url": "https://github.com/rust-lang/rust/commit/b7fa9f12ca62fc4f95306fa0c233de948edf303c"}], "stats": {"total": 220, "additions": 131, "deletions": 89}, "files": [{"sha": "fbe265666d17c2eb307e35bb13200841cde954e8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 131, "deletions": 89, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8956c1ed1d95915ac17612cd93df38243b875790/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8956c1ed1d95915ac17612cd93df38243b875790/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=8956c1ed1d95915ac17612cd93df38243b875790", "patch": "@@ -792,12 +792,82 @@ pub enum Usefulness<'tcx> {\n }\n \n impl<'tcx> Usefulness<'tcx> {\n+    fn new_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n+            LeaveOutWitness => Useful,\n+        }\n+    }\n+\n     fn is_useful(&self) -> bool {\n         match *self {\n             NotUseful => false,\n             _ => true,\n         }\n     }\n+\n+    fn apply_constructor(\n+        self,\n+        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => UsefulWithWitness(\n+                witnesses\n+                    .into_iter()\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, ty))\n+                    .collect(),\n+            ),\n+            x => x,\n+        }\n+    }\n+\n+    fn apply_wildcard(self, ty: Ty<'tcx>) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => {\n+                let wild = Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+                UsefulWithWitness(\n+                    witnesses\n+                        .into_iter()\n+                        .map(|mut witness| {\n+                            witness.0.push(wild.clone());\n+                            witness\n+                        })\n+                        .collect(),\n+                )\n+            }\n+            x => x,\n+        }\n+    }\n+\n+    fn apply_missing_ctors(\n+        self,\n+        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        ty: Ty<'tcx>,\n+        missing_ctors: &MissingConstructors<'tcx>,\n+    ) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => {\n+                let new_patterns: Vec<_> =\n+                    missing_ctors.iter().map(|ctor| ctor.apply_wildcards(cx, ty)).collect();\n+                // Add the new patterns to each witness\n+                UsefulWithWitness(\n+                    witnesses\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect(),\n+                )\n+            }\n+            x => x,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -1399,10 +1469,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     // the type of the tuple we're checking is inhabited or not.\n     if v.is_empty() {\n         return if rows.is_empty() {\n-            match witness_preference {\n-                ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-                LeaveOutWitness => Useful,\n-            }\n+            Usefulness::new_useful(witness_preference)\n         } else {\n             NotUseful\n         };\n@@ -1527,79 +1594,62 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n-            match is_useful(cx, &matrix, &v, witness_preference, hir_id) {\n-                UsefulWithWitness(witnesses) => {\n-                    let cx = &*cx;\n-                    // In this case, there's at least one \"free\"\n-                    // constructor that is only matched against by\n-                    // wildcard patterns.\n-                    //\n-                    // There are 2 ways we can report a witness here.\n-                    // Commonly, we can report all the \"free\"\n-                    // constructors as witnesses, e.g., if we have:\n-                    //\n-                    // ```\n-                    //     enum Direction { N, S, E, W }\n-                    //     let Direction::N = ...;\n-                    // ```\n-                    //\n-                    // we can report 3 witnesses: `S`, `E`, and `W`.\n-                    //\n-                    // However, there are 2 cases where we don't want\n-                    // to do this and instead report a single `_` witness:\n-                    //\n-                    // 1) If the user is matching against a non-exhaustive\n-                    // enum, there is no point in enumerating all possible\n-                    // variants, because the user can't actually match\n-                    // against them themselves, e.g., in an example like:\n-                    // ```\n-                    //     let err: io::ErrorKind = ...;\n-                    //     match err {\n-                    //         io::ErrorKind::NotFound => {},\n-                    //     }\n-                    // ```\n-                    // we don't want to show every possible IO error,\n-                    // but instead have `_` as the witness (this is\n-                    // actually *required* if the user specified *all*\n-                    // IO errors, but is probably what we want in every\n-                    // case).\n-                    //\n-                    // 2) If the user didn't actually specify a constructor\n-                    // in this arm, e.g., in\n-                    // ```\n-                    //     let x: (Direction, Direction, bool) = ...;\n-                    //     let (_, _, false) = x;\n-                    // ```\n-                    // we don't want to show all 16 possible witnesses\n-                    // `(<direction-1>, <direction-2>, true)` - we are\n-                    // satisfied with `(_, _, true)`. In this case,\n-                    // `used_ctors` is empty.\n-                    let new_patterns = if is_non_exhaustive || missing_ctors.all_ctors_are_missing()\n-                    {\n-                        // All constructors are unused. Add a wild pattern\n-                        // rather than each individual constructor.\n-                        vec![Pat { ty: pcx.ty, span: DUMMY_SP, kind: box PatKind::Wild }]\n-                    } else {\n-                        // Construct for each missing constructor a \"wild\" version of this\n-                        // constructor, that matches everything that can be built with\n-                        // it. For example, if `ctor` is a `Constructor::Variant` for\n-                        // `Option::Some`, we get the pattern `Some(_)`.\n-                        missing_ctors.iter().map(|ctor| ctor.apply_wildcards(cx, pcx.ty)).collect()\n-                    };\n-                    // Add the new patterns to each witness\n-                    let new_witnesses = witnesses\n-                        .into_iter()\n-                        .flat_map(|witness| {\n-                            new_patterns.iter().map(move |pat| {\n-                                let mut witness = witness.clone();\n-                                witness.0.push(pat.clone());\n-                                witness\n-                            })\n-                        })\n-                        .collect();\n-                    UsefulWithWitness(new_witnesses)\n-                }\n-                result => result,\n+            let usefulness = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+\n+            // In this case, there's at least one \"free\"\n+            // constructor that is only matched against by\n+            // wildcard patterns.\n+            //\n+            // There are 2 ways we can report a witness here.\n+            // Commonly, we can report all the \"free\"\n+            // constructors as witnesses, e.g., if we have:\n+            //\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            //\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, there are 2 cases where we don't want\n+            // to do this and instead report a single `_` witness:\n+            //\n+            // 1) If the user is matching against a non-exhaustive\n+            // enum, there is no point in enumerating all possible\n+            // variants, because the user can't actually match\n+            // against them themselves, e.g., in an example like:\n+            // ```\n+            //     let err: io::ErrorKind = ...;\n+            //     match err {\n+            //         io::ErrorKind::NotFound => {},\n+            //     }\n+            // ```\n+            // we don't want to show every possible IO error,\n+            // but instead have `_` as the witness (this is\n+            // actually *required* if the user specified *all*\n+            // IO errors, but is probably what we want in every\n+            // case).\n+            //\n+            // 2) If the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses\n+            // `(<direction-1>, <direction-2>, true)` - we are\n+            // satisfied with `(_, _, true)`. In this case,\n+            // `used_ctors` is empty.\n+            if is_non_exhaustive || missing_ctors.all_ctors_are_missing() {\n+                // All constructors are unused. Add a wild pattern\n+                // rather than each individual constructor.\n+                usefulness.apply_wildcard(pcx.ty)\n+            } else {\n+                // Construct for each missing constructor a \"wild\" version of this\n+                // constructor, that matches everything that can be built with\n+                // it. For example, if `ctor` is a `Constructor::Variant` for\n+                // `Option::Some`, we get the pattern `Some(_)`.\n+                usefulness.apply_missing_ctors(cx, pcx.ty, &missing_ctors)\n             }\n         }\n     }\n@@ -1621,18 +1671,10 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n     let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    match v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v, witness_preference, hir_id) {\n-            UsefulWithWitness(witnesses) => UsefulWithWitness(\n-                witnesses\n-                    .into_iter()\n-                    .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n-                    .collect(),\n-            ),\n-            result => result,\n-        },\n-        None => NotUseful,\n-    }\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n+        .map(|u| u.apply_constructor(cx, &ctor, lty))\n+        .unwrap_or(NotUseful)\n }\n \n /// Determines the constructors that the given pattern can be specialized to."}]}