{"sha": "505ef7e710ff890c0027fadad54997041b7ee93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNWVmN2U3MTBmZjg5MGMwMDI3ZmFkYWQ1NDk5NzA0MWI3ZWU5M2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-14T06:31:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-16T02:00:44Z"}, "message": "std::rt: Tasks contain a JoinLatch", "tree": {"sha": "80721bd6eb072d90ed6b3881c89a8f9a3fff75c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80721bd6eb072d90ed6b3881c89a8f9a3fff75c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/505ef7e710ff890c0027fadad54997041b7ee93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/505ef7e710ff890c0027fadad54997041b7ee93b", "html_url": "https://github.com/rust-lang/rust/commit/505ef7e710ff890c0027fadad54997041b7ee93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/505ef7e710ff890c0027fadad54997041b7ee93b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90fbe38f0064836fd5e169c520d3fd19953e5604", "url": "https://api.github.com/repos/rust-lang/rust/commits/90fbe38f0064836fd5e169c520d3fd19953e5604", "html_url": "https://github.com/rust-lang/rust/commit/90fbe38f0064836fd5e169c520d3fd19953e5604"}], "stats": {"total": 88, "additions": 56, "deletions": 32}, "files": [{"sha": "75ca4c941c50b16f7a5422024baa27f682994c17", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/505ef7e710ff890c0027fadad54997041b7ee93b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505ef7e710ff890c0027fadad54997041b7ee93b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=505ef7e710ff890c0027fadad54997041b7ee93b", "patch": "@@ -16,16 +16,20 @@\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n+use option::{Option, Some, None};\n use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n+use rt::join_latch::JoinLatch;\n \n pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: StdErrLogger,\n     unwinder: Unwinder,\n+    join_latch: Option<~JoinLatch>,\n+    on_exit: Option<~fn(bool)>,\n     destroyed: bool\n }\n \n@@ -44,6 +48,8 @@ impl Task {\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n+            join_latch: Some(JoinLatch::new_root()),\n+            on_exit: None,\n             destroyed: false\n         }\n     }\n@@ -55,6 +61,8 @@ impl Task {\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n+            join_latch: Some(self.join_latch.get_mut_ref().new_child()),\n+            on_exit: None,\n             destroyed: false\n         }\n     }\n@@ -68,9 +76,22 @@ impl Task {\n \n         self.unwinder.try(f);\n         self.destroy();\n+\n+        // Wait for children. Possibly report the exit status.\n+        let local_success = !self.unwinder.unwinding;\n+        let join_latch = self.join_latch.swap_unwrap();\n+        match self.on_exit {\n+            Some(ref on_exit) => {\n+                let success = join_latch.wait(local_success);\n+                (*on_exit)(success);\n+            }\n+            None => {\n+                join_latch.release(local_success);\n+            }\n+        }\n     }\n \n-    /// Must be called manually before finalization to clean up\n+    /// must be called manually before finalization to clean up\n     /// thread-local resources. Some of the routines here expect\n     /// Task to be available recursively so this must be\n     /// called unsafely, without removing Task from\n@@ -216,5 +237,15 @@ mod test {\n             assert!(port.recv() == 10);\n         }\n     }\n+\n+    #[test]\n+    fn linked_failure() {\n+        do run_in_newsched_task() {\n+            let res = do spawntask_try {\n+                spawntask_random(|| fail!());\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n }\n "}, {"sha": "36e394e5c5bbac42ecc29f1ae0bb3115117a52e7", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/505ef7e710ff890c0027fadad54997041b7ee93b/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505ef7e710ff890c0027fadad54997041b7ee93b/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=505ef7e710ff890c0027fadad54997041b7ee93b", "patch": "@@ -18,6 +18,7 @@ use vec::OwnedVector;\n use result::{Result, Ok, Err};\n use unstable::run_in_bare_thread;\n use super::io::net::ip::{IpAddr, Ipv4};\n+use rt::comm::oneshot;\n use rt::task::Task;\n use rt::thread::Thread;\n use rt::local::Local;\n@@ -47,8 +48,11 @@ pub fn run_in_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let mut sched = ~new_test_uv_sched();\n+        let mut new_task = ~Task::new_root();\n+        let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n+        new_task.on_exit = Some(on_exit);\n         let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                         ~Task::new_root(),\n+                                         new_task,\n                                          f.take());\n         sched.enqueue_task(task);\n         sched.run();\n@@ -94,16 +98,20 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n         let f_cell = Cell(f_cell.take());\n         let handles = Cell(handles);\n-        let main_task = ~do Coroutine::new_root(&mut scheds[0].stack_pool) {\n-            f_cell.take()();\n+        let mut new_task = ~Task::new_root();\n+        let on_exit: ~fn(bool) = |exit_status| {\n \n             let mut handles = handles.take();\n             // Tell schedulers to exit\n             for handles.each_mut |handle| {\n                 handle.send(Shutdown);\n             }\n-        };\n \n+            rtassert!(exit_status);\n+        };\n+        new_task.on_exit = Some(on_exit);\n+        let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n+                                              new_task, f_cell.take());\n         scheds[0].enqueue_task(main_task);\n \n         let mut threads = ~[];\n@@ -213,36 +221,21 @@ pub fn spawntask_random(f: ~fn()) {\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;\n     use super::sched::*;\n-    use task;\n-    use unstable::finally::Finally;\n-\n-    // Our status variables will be filled in from the scheduler context\n-    let mut failed = false;\n-    let failed_ptr: *mut bool = &mut failed;\n-\n-    // Switch to the scheduler\n-    let f = Cell(Cell(f));\n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then() |sched, old_task| {\n-        let old_task = Cell(old_task);\n-        let f = f.take();\n-        let new_task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n-            do (|| {\n-                (f.take())()\n-            }).finally {\n-                // Check for failure then resume the parent task\n-                unsafe { *failed_ptr = task::failing(); }\n-                let sched = Local::take::<Scheduler>();\n-                do sched.switch_running_tasks_and_then(old_task.take()) |sched, new_task| {\n-                    sched.enqueue_task(new_task);\n-                }\n-            }\n-        };\n \n-        sched.enqueue_task(new_task);\n+    let (port, chan) = oneshot();\n+    let chan = Cell(chan);\n+    let mut new_task = ~Task::new_root();\n+    let on_exit: ~fn(bool) = |exit_status| chan.take().send(exit_status);\n+    new_task.on_exit = Some(on_exit);\n+    let mut sched = Local::take::<Scheduler>();\n+    let new_task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         new_task, f);\n+    do sched.switch_running_tasks_and_then(new_task) |sched, old_task| {\n+        sched.enqueue_task(old_task);\n     }\n \n-    if !failed { Ok(()) } else { Err(()) }\n+    let exit_status = port.recv();\n+    if exit_status { Ok(()) } else { Err(()) }\n }\n \n // Spawn a new task in a new scheduler and return a thread handle."}]}