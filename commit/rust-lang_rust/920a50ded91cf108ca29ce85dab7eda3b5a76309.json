{"sha": "920a50ded91cf108ca29ce85dab7eda3b5a76309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMGE1MGRlZDkxY2YxMDhjYTI5Y2U4NWRhYjdlZGEzYjVhNzYzMDk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T21:03:31Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T21:07:54Z"}, "message": "Refactoring: return a summary from `format_project`\n\nRather than modifying `self.summary`.\n\nAlso move some Timer methods.", "tree": {"sha": "694849d5cc27d5fc55b066b99320ba7a1c592d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/694849d5cc27d5fc55b066b99320ba7a1c592d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/920a50ded91cf108ca29ce85dab7eda3b5a76309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/920a50ded91cf108ca29ce85dab7eda3b5a76309", "html_url": "https://github.com/rust-lang/rust/commit/920a50ded91cf108ca29ce85dab7eda3b5a76309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/920a50ded91cf108ca29ce85dab7eda3b5a76309/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "069c4fc50871acfcf41f8726107daa26a29b488c", "url": "https://api.github.com/repos/rust-lang/rust/commits/069c4fc50871acfcf41f8726107daa26a29b488c", "html_url": "https://github.com/rust-lang/rust/commit/069c4fc50871acfcf41f8726107daa26a29b488c"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "6c545632aeb9f9b51ae8c92ae0c34621d6c73249", "filename": "src/formatting.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/920a50ded91cf108ca29ce85dab7eda3b5a76309/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/920a50ded91cf108ca29ce85dab7eda3b5a76309/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=920a50ded91cf108ca29ce85dab7eda3b5a76309", "patch": "@@ -315,11 +315,9 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n \n         let input_is_stdin = input.is_text();\n         let mut filemap = FileMap::new();\n-        // TODO split Session? out vs config - but what about summary?\n-        //  - look at error handling\n-        let format_result = self.format_ast(input, |this, path, mut result| {\n+        // TODO split Session? out vs config?\n+        let format_result = self.format_project(input, |this, path, mut result| {\n             if let Some(ref mut out) = this.out {\n-                // TODO pull out the has_diff return value\n                 match filemap::write_file(&mut result, &path, out, &this.config) {\n                     Ok(b) if b => this.summary.add_diff(),\n                     Err(e) => {\n@@ -342,24 +340,27 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n \n             println!(\n                 \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-                duration_to_f32(self.get_parse_time().unwrap()),\n-                duration_to_f32(self.get_format_time().unwrap()),\n+                duration_to_f32(self.timer.get_parse_time().unwrap()),\n+                duration_to_f32(self.timer.get_format_time().unwrap()),\n             )\n         });\n \n-        format_result.map(|r| (filemap, r))\n+        format_result.map(|(result, summary)| {\n+            self.summary.add(summary);\n+            (filemap, result)\n+        })\n     }\n \n-    // TODO name, only uses config and summary\n-    // Formatting which depends on the AST.\n-    fn format_ast<F>(\n+    // TODO only uses config and timer\n+    fn format_project<F>(\n         &mut self,\n         input: Input,\n         mut formatted_file: F,\n-    ) -> Result<FormatReport, ErrorKind>\n+    ) -> Result<(FormatReport, Summary), ErrorKind>\n     where\n         F: FnMut(&mut Session<T>, FileName, String) -> Result<(), ErrorKind>,\n     {\n+        let mut summary = Summary::default();\n         let main_file = match input {\n             Input::File(ref file) => FileName::Real(file.clone()),\n             Input::Text(..) => FileName::Stdin,\n@@ -383,7 +384,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n                     }\n                     ParseError::Recovered => {}\n                 }\n-                self.summary.add_parsing_error();\n+                summary.add_parsing_error();\n                 return Err(ErrorKind::ParseError);\n             }\n         };\n@@ -453,27 +454,27 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             self.replace_with_system_newlines(&mut visitor.buffer);\n \n             if visitor.macro_rewrite_failure {\n-                self.summary.add_macro_foramt_failure();\n+                summary.add_macro_format_failure();\n             }\n \n             formatted_file(self, path, visitor.buffer)?;\n         }\n         self.timer = self.timer.done_formatting();\n \n         if report.has_warnings() {\n-            self.summary.add_formatting_error();\n+            summary.add_formatting_error();\n         }\n         {\n             let report_errs = &report.internal.borrow().1;\n             if report_errs.has_check_errors {\n-                self.summary.add_check_error();\n+                summary.add_check_error();\n             }\n             if report_errs.has_operational_errors {\n-                self.summary.add_operational_error();\n+                summary.add_operational_error();\n             }\n         }\n \n-        Ok(report)\n+        Ok((report, summary))\n     }\n \n     fn make_parse_sess(&self, codemap: Rc<CodeMap>) -> ParseSess {\n@@ -525,28 +526,6 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             NewlineStyle::Native => unreachable!(),\n         }\n     }\n-\n-    /// Returns the time it took to parse the source files in nanoseconds.\n-    fn get_parse_time(&self) -> Option<Duration> {\n-        match self.timer {\n-            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n-                // This should never underflow since `Instant::now()` guarantees monotonicity.\n-                Some(parse_time.duration_since(init))\n-            }\n-            Timer::Initialized(..) => None,\n-        }\n-    }\n-\n-    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n-    /// not included.\n-    fn get_format_time(&self) -> Option<Duration> {\n-        match self.timer {\n-            Timer::DoneFormatting(_init, parse_time, format_time) => {\n-                Some(format_time.duration_since(parse_time))\n-            }\n-            Timer::DoneParsing(..) | Timer::Initialized(..) => None,\n-        }\n-    }\n }\n \n /// A single span of changed lines, with 0 or more removed lines\n@@ -591,6 +570,28 @@ impl Timer {\n             _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n         }\n     }\n+\n+    /// Returns the time it took to parse the source files in nanoseconds.\n+    fn get_parse_time(&self) -> Option<Duration> {\n+        match *self {\n+            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n+                // This should never underflow since `Instant::now()` guarantees monotonicity.\n+                Some(parse_time.duration_since(init))\n+            }\n+            Timer::Initialized(..) => None,\n+        }\n+    }\n+\n+    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n+    /// not included.\n+    fn get_format_time(&self) -> Option<Duration> {\n+        match *self {\n+            Timer::DoneFormatting(_init, parse_time, format_time) => {\n+                Some(format_time.duration_since(parse_time))\n+            }\n+            Timer::DoneParsing(..) | Timer::Initialized(..) => None,\n+        }\n+    }\n }\n \n /// A summary of a Rustfmt run.\n@@ -656,7 +657,7 @@ impl Summary {\n         self.has_diff = true;\n     }\n \n-    pub(crate) fn add_macro_foramt_failure(&mut self) {\n+    pub(crate) fn add_macro_format_failure(&mut self) {\n         self.has_macro_format_failure = true;\n     }\n \n@@ -671,6 +672,7 @@ impl Summary {\n     pub fn add(&mut self, other: Summary) {\n         self.has_operational_errors |= other.has_operational_errors;\n         self.has_formatting_errors |= other.has_formatting_errors;\n+        self.has_macro_format_failure |= other.has_macro_format_failure;\n         self.has_parsing_errors |= other.has_parsing_errors;\n         self.has_check_errors |= other.has_check_errors;\n         self.has_diff |= other.has_diff;"}]}