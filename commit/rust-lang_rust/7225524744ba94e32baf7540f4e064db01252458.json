{"sha": "7225524744ba94e32baf7540f4e064db01252458", "node_id": "C_kwDOAAsO6NoAKDcyMjU1MjQ3NDRiYTk0ZTMyYmFmNzU0MGY0ZTA2NGRiMDEyNTI0NTg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-20T17:07:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-20T17:15:24Z"}, "message": "add a weak form of protection that justifies Box noalias", "tree": {"sha": "f8b75de838540c60d5fe48c4726258fb83e68e91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8b75de838540c60d5fe48c4726258fb83e68e91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7225524744ba94e32baf7540f4e064db01252458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7225524744ba94e32baf7540f4e064db01252458", "html_url": "https://github.com/rust-lang/rust/commit/7225524744ba94e32baf7540f4e064db01252458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7225524744ba94e32baf7540f4e064db01252458/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5", "html_url": "https://github.com/rust-lang/rust/commit/c043a0e7d6f347f9b2c7f08c5b3a179470e0f0c5"}], "stats": {"total": 211, "additions": 146, "deletions": 65}, "files": [{"sha": "323ec3d75f9f8999f5fbd4d49e5b61c3987e13f7", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -6,7 +6,7 @@ use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n use crate::helpers::CurrentSpan;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n use crate::*;\n \n use rustc_middle::mir::interpret::InterpError;\n@@ -288,7 +288,11 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n             }\n             Operation::Access(AccessOp { kind, range, .. }) =>\n                 (*range, InvalidationCause::Access(*kind)),\n-            _ => unreachable!(\"Tags can only be invalidated during a retag or access\"),\n+            _ => {\n+                // This can be reached, but never be relevant later since the entire allocation is\n+                // gone now.\n+                return;\n+            }\n         };\n         self.history.invalidations.push(Invalidation { tag, range, span, cause });\n     }\n@@ -369,7 +373,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n         };\n@@ -389,7 +393,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Access(op) = &self.operation  else {\n             unreachable!(\"access_error should only be called during an access\")\n         };\n@@ -408,7 +412,11 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn protector_error(&self, item: &Item) -> InterpError<'tcx> {\n+    pub(super) fn protector_error(&self, item: &Item, kind: ProtectorKind) -> InterpError<'tcx> {\n+        let protected = match kind {\n+            ProtectorKind::WeakProtector => \"weakly protected\",\n+            ProtectorKind::StrongProtector => \"strongly protected\",\n+        };\n         let call_id = self\n             .threads\n             .all_stacks()\n@@ -422,19 +430,15 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         match self.operation {\n             Operation::Dealloc(_) =>\n                 err_sb_ub(\n-                    format!(\n-                        \"deallocating while item {:?} is protected by call {:?}\",\n-                        item, call_id\n-                    ),\n+                    format!(\"deallocating while item {item:?} is {protected} by call {call_id:?}\",),\n                     None,\n                     None,\n                 ),\n             Operation::Retag(RetagOp { orig_tag: tag, .. })\n             | Operation::Access(AccessOp { tag, .. }) =>\n                 err_sb_ub(\n                     format!(\n-                        \"not granting access to tag {:?} because that would remove {:?} which is protected because it is an argument of call {:?}\",\n-                        tag, item, call_id\n+                        \"not granting access to tag {tag:?} because that would remove {item:?} which is {protected} because it is an argument of call {call_id:?}\",\n                     ),\n                     None,\n                     tag.and_then(|tag| self.get_logs_relevant_to(tag, Some(item.tag()))),"}, {"sha": "648797211a77a3908578a8bf4fa5b74e9d96e53f", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -91,6 +91,26 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug)]\n+enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n /// Extra global state, available to the memory access hooks.\n #[derive(Debug)]\n pub struct GlobalStateInner {\n@@ -102,12 +122,12 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// All currently protected tags.\n+    /// All currently protected tags, and the status of their protection.\n     /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n     /// We add tags to this when they are created with a protector in `reborrow`, and\n     /// we remove tags from this when the call which is protecting them returns, in\n     /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n-    protected_tags: FxHashSet<SbTag>,\n+    protected_tags: FxHashMap<SbTag, ProtectorKind>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: FxHashSet<SbTag>,\n     /// The call ids to trace\n@@ -189,7 +209,7 @@ impl GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            protected_tags: FxHashSet::default(),\n+            protected_tags: FxHashMap::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n             retag_fields,\n@@ -314,6 +334,7 @@ impl<'tcx> Stack {\n         item: &Item,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        deallocation: bool,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n             dcx.check_tracked_tag_popped(item, global);\n@@ -336,8 +357,11 @@ impl<'tcx> Stack {\n         // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n         //    which ends up about linear in the number of protected tags in the program into a\n         //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n-        if global.protected_tags.contains(&item.tag()) {\n-            return Err(dcx.protector_error(item).into());\n+        if let Some(&protector_kind) = global.protected_tags.get(&item.tag()) {\n+            let allowed = deallocation && matches!(protector_kind, ProtectorKind::WeakProtector);\n+            if !allowed {\n+                return Err(dcx.protector_error(item, protector_kind).into());\n+            }\n         }\n         Ok(())\n     }\n@@ -350,7 +374,7 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        global: &mut GlobalStateInner,\n+        global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n@@ -377,7 +401,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.pop_items_after(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_popped(&item, global, dcx, /* deallocation */ false)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -398,7 +422,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.disable_uniques_starting_at(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_popped(&item, global, dcx, /* deallocation */ false)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -440,14 +464,15 @@ impl<'tcx> Stack {\n         dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n-        // Step 1: Make sure there is a granting item.\n-        self.find_granting(AccessKind::Write, tag, exposed_tags)\n+        // Step 1: Make a write access.\n+        // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n+        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)\n             .map_err(|_| dcx.dealloc_error())?;\n \n-        // Step 2: Consider all items removed. This checks for protectors.\n+        // Step 2: Pretend we remove the remaining items, checking if any are strongly protected.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, global, dcx)?;\n+            Stack::item_popped(&item, global, dcx, /* deallocation */ true)?;\n         }\n \n         Ok(())\n@@ -698,7 +723,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n         new_tag: SbTag,\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -761,7 +786,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect {\n+                    if protect.is_some() {\n                         dcx.log_protector();\n                     }\n                 }\n@@ -821,10 +846,16 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             size.bytes()\n         );\n \n-        if protect {\n+        if let Some(protect) = protect {\n             // See comment in `Stack::item_popped` for why we store the tag twice.\n             this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n-            this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n+            this.machine\n+                .stacked_borrows\n+                .as_mut()\n+                .unwrap()\n+                .get_mut()\n+                .protected_tags\n+                .insert(new_tag, protect);\n         }\n \n         // Update the stacks.\n@@ -866,7 +897,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         Permission::SharedReadWrite\n                     };\n                     let protected = if frozen {\n-                        protect\n+                        protect.is_some()\n                     } else {\n                         // We do not protect inside UnsafeCell.\n                         // This fixes https://github.com/rust-lang/rust/issues/55005.\n@@ -899,7 +930,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             .as_mut()\n             .expect(\"we should have Stacked Borrows data\")\n             .borrow_mut();\n-        let item = Item::new(new_tag, perm, protect);\n+        let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         // FIXME: can't share this with the current_span inside log_creation\n@@ -926,7 +957,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -996,7 +1027,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 place: &PlaceTy<'tcx, Provenance>,\n                 ref_kind: RefKind,\n                 retag_cause: RetagCause,\n-                protector: bool,\n+                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n                 let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n@@ -1015,13 +1046,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n-                // Boxes do not get a protector: protectors reflect that references outlive the call\n-                // they were passed in to; that's just not the case for boxes.\n+                // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n                     RefKind::Unique { two_phase: false },\n                     self.retag_cause,\n-                    /*protector*/ false,\n+                    /*protector*/\n+                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n                 )\n             }\n \n@@ -1046,7 +1077,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             place,\n                             ref_kind,\n                             self.retag_cause,\n-                            /*protector*/ self.kind == RetagKind::FnEntry,\n+                            /*protector*/\n+                            (self.kind == RetagKind::FnEntry)\n+                                .then_some(ProtectorKind::StrongProtector),\n                         )?;\n                     }\n                     ty::RawPtr(tym) => {\n@@ -1059,7 +1092,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                                 place,\n                                 RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n                                 self.retag_cause,\n-                                /*protector*/ false,\n+                                /*protector*/ None,\n                             )?;\n                         }\n                     }\n@@ -1110,12 +1143,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // (The pointer type does not matter, so we use a raw pointer.)\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n-        // Reborrow it.\n+        // Reborrow it. With protection! That is part of the point.\n         let val = this.retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n             RetagCause::FnReturn,\n-            /*protector*/ true,\n+            /*protector*/ Some(ProtectorKind::StrongProtector),\n         )?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;"}, {"sha": "268d253ad5b06c65b49b5d9ac60914c231ff0608", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "77a542f45a2566a5f61af86f328921e92d07c668", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "e592b154a7326326da9226cf42c2876ba35f4699", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2067149b6c87cac19c52bebd30a18abb6dfff1ab", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -0,0 +1,14 @@\n+unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+    // We will call this in a way that x and y alias.\n+    *x = 5;\n+    std::mem::forget(x);\n+    *y //~ERROR: weakly protected\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut v = 42;\n+        let ptr = &mut v as *mut i32;\n+        test(Box::from_raw(ptr), ptr);\n+    }\n+}"}, {"sha": "3c84cbcfd5182a0b543111003d38052a8e498bb4", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |     *y\n+   |     ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         let ptr = &mut v as *mut i32;\n+   |                   ^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL | unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+   |                ^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `test` at $DIR/box_noalias_violation.rs:LL:CC\n+note: inside `main` at $DIR/box_noalias_violation.rs:LL:CC\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         test(Box::from_raw(ptr), ptr);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "4036dce5bebab1a5995da3daead21bd32c365950", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[Unique for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[Unique for .*\\] is strongly protected/\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "bb3eaec1e85c0da033b0f68073849a304ae21b71", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [Unique for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "25bab1aa564a65a0145bb1506cda9ded5c95e453", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "7983b30ea18229ee93498d640354629d5d008175", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -7,6 +7,6 @@ fn main() {\n fn foo(a: &mut u32, y: *mut u32) -> u32 {\n     *a = 1;\n     let _b = &*a;\n-    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is protected/\n+    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is strongly protected/\n     return *a;\n }"}, {"sha": "1a627b8a883009f07818308cbe6f48f916bb21ac", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "1ef36b7ac10fc4c5005ded98d127b7968315d580", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "941b936e5d7249443852d9692444911c5cd8c898", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "176a859ee8af7692d4b1673d1ce96b03eff79019", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector3.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "c19bcb99cc1cee4bd5ca83381607ae019577f1b7", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32, i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "70186dd3a53f3305d9b8622fadf83448f1aae9ad", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2bbe7122ec7478873190fc73686b02dbfe11a932", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "69fa27c9c096fef7f6e6c1a3e6a6dfe9287165d5", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7225524744ba94e32baf7540f4e064db01252458/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=7225524744ba94e32baf7540f4e064db01252458", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}]}