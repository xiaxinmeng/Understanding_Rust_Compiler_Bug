{"sha": "52acc05f6398d70e8cc506e19bb9fefbed7368ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYWNjMDVmNjM5OGQ3MGU4Y2M1MDZlMTliYjlmZWZiZWQ3MzY4YWM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-16T16:53:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-17T22:24:20Z"}, "message": "Rework stability annotation pass", "tree": {"sha": "22bb720f7974f186449499cc6426cc22298b7a19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22bb720f7974f186449499cc6426cc22298b7a19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52acc05f6398d70e8cc506e19bb9fefbed7368ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52acc05f6398d70e8cc506e19bb9fefbed7368ac", "html_url": "https://github.com/rust-lang/rust/commit/52acc05f6398d70e8cc506e19bb9fefbed7368ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52acc05f6398d70e8cc506e19bb9fefbed7368ac/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2f539375a24511f8dff5e67e549e0f08e5b961d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f539375a24511f8dff5e67e549e0f08e5b961d", "html_url": "https://github.com/rust-lang/rust/commit/b2f539375a24511f8dff5e67e549e0f08e5b961d"}], "stats": {"total": 300, "additions": 163, "deletions": 137}, "files": [{"sha": "a1691281083f3a58402e6591e56f2565a5f11f02", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 147, "deletions": 130, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=52acc05f6398d70e8cc506e19bb9fefbed7368ac", "patch": "@@ -12,6 +12,7 @@\n //! propagating default levels lexically from parent to children ast nodes.\n \n pub use self::StabilityLevel::*;\n+use self::AnnotationKind::*;\n \n use session::Session;\n use lint;\n@@ -30,8 +31,8 @@ use syntax::attr::{self, Stability, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n-use rustc_front::hir::{FnDecl, Block, Crate, Item, Generics, StructField, Variant};\n-use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::hir::{Block, Crate, Item, Generics, StructField, Variant};\n+use rustc_front::visit::{self, Visitor};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -48,6 +49,16 @@ impl StabilityLevel {\n     }\n }\n \n+#[derive(PartialEq)]\n+enum AnnotationKind {\n+    // Annotation is required if not inherited from unstable parents\n+    AnnRequired,\n+    // Annotation is useless, reject it\n+    AnnProhibited,\n+    // Annotation itself is useless, but it can be propagated to children\n+    AnnContainer,\n+}\n+\n /// A stability index, giving the stability level for items and methods.\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n@@ -64,174 +75,180 @@ struct Annotator<'a, 'tcx: 'a> {\n     index: &'a mut Index<'tcx>,\n     parent: Option<&'tcx Stability>,\n     export_map: &'a PublicItems,\n+    in_trait_impl: bool,\n+    in_enum: bool,\n }\n \n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n-                   attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n-        F: FnOnce(&mut Annotator),\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>,\n+                   item_sp: Span, kind: AnnotationKind, visit_children: F)\n+        where F: FnOnce(&mut Annotator)\n     {\n         if self.index.staged_api[&LOCAL_CRATE] {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n-            match attr::find_stability(self.tcx.sess.diagnostic(), attrs, item_sp) {\n-                Some(mut stab) => {\n-                    debug!(\"annotate: found {:?}\", stab);\n-                    // if parent is deprecated and we're not, inherit this by merging\n-                    // deprecated_since and its reason.\n-                    if let Some(parent_stab) = self.parent {\n-                        if parent_stab.depr.is_some()\n-                        && stab.depr.is_none() {\n-                            stab.depr = parent_stab.depr.clone()\n-                        }\n+            if let Some(mut stab) = attr::find_stability(self.tcx.sess.diagnostic(),\n+                                                         attrs, item_sp) {\n+                // Error if prohibited, or can't inherit anything from a container\n+                if kind == AnnProhibited ||\n+                   kind == AnnContainer && stab.level.is_stable() && stab.depr.is_none() {\n+                    self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n+                }\n+\n+                debug!(\"annotate: found {:?}\", stab);\n+                // If parent is deprecated and we're not, inherit this by merging\n+                // deprecated_since and its reason.\n+                if let Some(parent_stab) = self.parent {\n+                    if parent_stab.depr.is_some() && stab.depr.is_none() {\n+                        stab.depr = parent_stab.depr.clone()\n                     }\n+                }\n \n-                    let stab = self.tcx.intern_stability(stab);\n-\n-                    // Check if deprecated_since < stable_since. If it is,\n-                    // this is *almost surely* an accident.\n-                    let deprecated_predates_stable = match (&stab.depr, &stab.level) {\n-                        (&Some(attr::Deprecation {since: ref dep_since, ..}),\n-                               &attr::Stable {since: ref stab_since}) => {\n-                            // explicit version of iter::order::lt to handle parse errors properly\n-                            let mut is_less = false;\n-                            for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n-                                match (dep_v.parse::<u64>(), stab_v.parse::<u64>()) {\n-                                    (Ok(dep_v), Ok(stab_v)) => match dep_v.cmp(&stab_v) {\n-                                        Ordering::Less => {\n-                                            is_less = true;\n-                                            break;\n-                                        }\n-                                        Ordering::Equal => { continue; }\n-                                        Ordering::Greater => { break; }\n-                                    },\n-                                    _ => {\n-                                        self.tcx.sess.span_err(item_sp,\n-                                            \"Invalid stability or deprecation version found\");\n-                                        // act like it isn't less because the question is now\n-                                        // nonsensical, and this makes us not do anything else\n-                                        // interesting.\n-                                        break;\n-                                    }\n+                let stab = self.tcx.intern_stability(stab);\n+\n+                // Check if deprecated_since < stable_since. If it is,\n+                // this is *almost surely* an accident.\n+                if let (&Some(attr::Deprecation {since: ref dep_since, ..}),\n+                        &attr::Stable {since: ref stab_since}) = (&stab.depr, &stab.level) {\n+                    // Explicit version of iter::order::lt to handle parse errors properly\n+                    for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n+                        if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n+                            match dep_v.cmp(&stab_v) {\n+                                Ordering::Less => {\n+                                    self.tcx.sess.span_err(item_sp, \"An API can't be stabilized \\\n+                                                                     after it is deprecated\");\n+                                    break\n                                 }\n+                                Ordering::Equal => continue,\n+                                Ordering::Greater => break,\n                             }\n-                            is_less\n-                        },\n-                        _ => false,\n-                    };\n-\n-                    if deprecated_predates_stable {\n-                        self.tcx.sess.span_err(item_sp,\n-                            \"An API can't be stabilized after it is deprecated\");\n+                        } else {\n+                            // Act like it isn't less because the question is now nonsensical,\n+                            // and this makes us not do anything else interesting.\n+                            self.tcx.sess.span_err(item_sp, \"Invalid stability or deprecation \\\n+                                                             version found\");\n+                            break\n+                        }\n                     }\n+                }\n \n-                    let def_id = self.tcx.map.local_def_id(id);\n-                    self.index.map.insert(def_id, Some(stab));\n-\n-                    // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                    if !stab.level.is_stable() {\n-                        let parent = replace(&mut self.parent, Some(stab));\n-                        f(self);\n-                        self.parent = parent;\n-                    } else {\n-                        f(self);\n+                let def_id = self.tcx.map.local_def_id(id);\n+                self.index.map.insert(def_id, Some(stab));\n+\n+                let parent = replace(&mut self.parent, Some(stab));\n+                visit_children(self);\n+                self.parent = parent;\n+            } else {\n+                debug!(\"annotate: not found, parent = {:?}\", self.parent);\n+                let mut is_error = kind == AnnRequired &&\n+                                   self.export_map.contains(&id) &&\n+                                   !self.tcx.sess.opts.test;\n+                if let Some(stab) = self.parent {\n+                    if stab.level.is_unstable() {\n+                        let def_id = self.tcx.map.local_def_id(id);\n+                        self.index.map.insert(def_id, Some(stab));\n+                        is_error = false;\n                     }\n                 }\n-                None => {\n-                    debug!(\"annotate: not found, use_parent = {:?}, parent = {:?}\",\n-                           use_parent, self.parent);\n-                    if use_parent {\n-                        if let Some(stab) = self.parent {\n-                            let def_id = self.tcx.map.local_def_id(id);\n-                            self.index.map.insert(def_id, Some(stab));\n-                        } else if self.index.staged_api[&LOCAL_CRATE] && required\n-                            && self.export_map.contains(&id)\n-                            && !self.tcx.sess.opts.test {\n-                                self.tcx.sess.span_err(item_sp,\n-                                                       \"This node does not \\\n-                                                        have a stability attribute\");\n-                            }\n-                    }\n-                    f(self);\n+                if is_error {\n+                    self.tcx.sess.span_err(item_sp, \"This node does not have \\\n+                                                     a stability attribute\");\n                 }\n+                visit_children(self);\n             }\n         } else {\n-            // Emit warnings for non-staged-api crates. These should be errors.\n+            // Emit errors for non-staged-api crates.\n             for attr in attrs {\n                 let tag = attr.name();\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"deprecated\" {\n                     attr::mark_used(attr);\n-                    self.tcx.sess.span_err(attr.span(),\n-                                       \"stability attributes may not be used outside \\\n-                                        of the standard library\");\n+                    self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n+                                                         outside of the standard library\");\n                 }\n             }\n-            f(self);\n+            visit_children(self);\n         }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item) {\n-        // FIXME (#18969): the following is a hack around the fact\n-        // that we cannot currently annotate the stability of\n-        // `deriving`.  Basically, we do *not* allow stability\n-        // inheritance on trait implementations, so that derived\n-        // implementations appear to be unannotated. This then allows\n-        // derived implementations to be automatically tagged with the\n-        // stability of the trait. This is WRONG, but expedient to get\n-        // libstd stabilized for the 1.0 release.\n-        let use_parent = match i.node {\n-            hir::ItemImpl(_, _, _, Some(_), _, _) => false,\n-            _ => true,\n-        };\n-\n-        // In case of a `pub use <mod>;`, we should not error since the stability\n-        // is inherited from the module itself\n-        let required = match i.node {\n-            hir::ItemUse(_) => i.vis != hir::Public,\n-            _ => true\n-        };\n-\n-        self.annotate(i.id, use_parent, &i.attrs, i.span,\n-                      |v| visit::walk_item(v, i), required);\n-\n-        if let hir::ItemStruct(ref sd, _) = i.node {\n-            if !sd.is_struct() {\n-                self.annotate(sd.id(), true, &i.attrs, i.span, |_| {}, true)\n+        let orig_in_trait_impl = self.in_trait_impl;\n+        let orig_in_enum = self.in_enum;\n+        let mut kind = AnnRequired;\n+        match i.node {\n+            // Inherent impls and foreign modules serve only as containers for other items,\n+            // they don't have their own stability. They still can be annotated as unstable\n+            // and propagate this unstability to children, but this annotation is completely\n+            // optional. They inherit stability from their parents when unannotated.\n+            hir::ItemImpl(_, _, _, None, _, _) | hir::ItemForeignMod(..) => {\n+                self.in_trait_impl = false;\n+                kind = AnnContainer;\n+            }\n+            hir::ItemImpl(_, _, _, Some(_), _, _) => {\n+                self.in_trait_impl = true;\n+            }\n+            hir::ItemStruct(ref sd, _) => {\n+                self.in_enum = false;\n+                if !sd.is_struct() {\n+                    self.annotate(sd.id(), &i.attrs, i.span, AnnRequired, |_| {})\n+                }\n+            }\n+            hir::ItemEnum(..) => {\n+                self.in_enum = true;\n             }\n+            _ => {}\n         }\n-    }\n \n-    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v FnDecl,\n-                _: &'v Block, _: Span, _: NodeId) {\n-        // Items defined in a function body have no reason to have\n-        // a stability attribute, so we don't recurse.\n+        self.annotate(i.id, &i.attrs, i.span, kind, |v| {\n+            visit::walk_item(v, i)\n+        });\n+        self.in_trait_impl = orig_in_trait_impl;\n+        self.in_enum = orig_in_enum;\n     }\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        self.annotate(ti.id, true, &ti.attrs, ti.span,\n-                      |v| visit::walk_trait_item(v, ti), true);\n+        self.annotate(ti.id, &ti.attrs, ti.span, AnnRequired, |v| {\n+            visit::walk_trait_item(v, ti);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        self.annotate(ii.id, true, &ii.attrs, ii.span,\n-                      |v| visit::walk_impl_item(v, ii), false);\n+        let kind = if self.in_trait_impl { AnnProhibited } else { AnnRequired };\n+        self.annotate(ii.id, &ii.attrs, ii.span, kind, |v| {\n+            visit::walk_impl_item(v, ii);\n+        });\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n-        self.annotate(var.node.data.id(), true, &var.node.attrs, var.span,\n-                      |v| visit::walk_variant(v, var, g, item_id), true)\n+        self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnRequired, |v| {\n+            visit::walk_variant(v, var, g, item_id);\n+        })\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n-        self.annotate(s.node.id, true, &s.node.attrs, s.span,\n-                      |v| visit::walk_struct_field(v, s), !s.node.kind.is_unnamed());\n+        // FIXME: This is temporary, can't use attributes with tuple variant fields until snapshot\n+        let kind = if self.in_enum && s.node.kind.is_unnamed() {\n+            AnnProhibited\n+        } else {\n+            AnnRequired\n+        };\n+        self.annotate(s.node.id, &s.node.attrs, s.span, kind, |v| {\n+            visit::walk_struct_field(v, s);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n-        self.annotate(i.id, true, &i.attrs, i.span, |_| {}, true);\n+        self.annotate(i.id, &i.attrs, i.span, AnnRequired, |v| {\n+            visit::walk_foreign_item(v, i);\n+        });\n+    }\n+\n+    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+        if md.imported_from.is_none() {\n+            self.annotate(md.id, &md.attrs, md.span, AnnRequired, |_| {});\n+        }\n     }\n }\n \n@@ -243,21 +260,21 @@ impl<'tcx> Index<'tcx> {\n             index: self,\n             parent: None,\n             export_map: export_map,\n+            in_trait_impl: false,\n+            in_enum: false,\n         };\n-        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs, krate.span,\n-                           |v| visit::walk_crate(v, krate), true);\n+        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnRequired,\n+                           |v| visit::walk_crate(v, krate));\n     }\n \n     pub fn new(krate: &Crate) -> Index {\n         let mut is_staged_api = false;\n         for attr in &krate.attrs {\n-            if &attr.name()[..] == \"staged_api\" {\n-                match attr.node.value.node {\n-                    ast::MetaWord(_) => {\n-                        attr::mark_used(attr);\n-                        is_staged_api = true;\n-                    }\n-                    _ => (/*pass*/)\n+            if attr.name() == \"staged_api\" {\n+                if let ast::MetaWord(_) = attr.node.value.node {\n+                    attr::mark_used(attr);\n+                    is_staged_api = true;\n+                    break\n                 }\n             }\n         }"}, {"sha": "eb542adef003c0bec483a3f6ffbc1ae24c18903e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=52acc05f6398d70e8cc506e19bb9fefbed7368ac", "patch": "@@ -739,7 +739,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-\n                                    // passes are timed inside typeck\n                                    typeck::check_crate(tcx, trait_map);\n \n@@ -756,7 +755,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    // Do not move this check past lint\n                                    time(time_passes, \"stability index\", || {\n-                                       tcx.stability.borrow_mut().build(tcx, krate, &public_items)\n+                                       tcx.stability.borrow_mut().build(tcx, krate, &exported_items)\n                                    });\n \n                                    time(time_passes,"}, {"sha": "09503bec0c360e8580bf1075b1be668e6cba5239", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52acc05f6398d70e8cc506e19bb9fefbed7368ac/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=52acc05f6398d70e8cc506e19bb9fefbed7368ac", "patch": "@@ -221,9 +221,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         let orig_all_exported = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway. They are also not\n+            // cannot have visibility qualifiers on them anyway. Impls are also not\n             // added to public/exported sets based on inherited publicity.\n-            hir::ItemImpl(..) | hir::ItemDefaultImpl(..) | hir::ItemForeignMod(..) => {}\n+            hir::ItemImpl(..) | hir::ItemDefaultImpl(..) => {}\n+            hir::ItemForeignMod(..) => {\n+                self.maybe_insert_id(item.id);\n+            }\n \n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n@@ -249,12 +252,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            // Public items in inherent impls for public/exported types are public/exported\n-            // Inherent impls themselves are not public/exported, they are nothing more than\n-            // containers for other items\n+            // Inherent impls for public/exported types and their public items are public/exported\n             hir::ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n                 let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n \n+                if public_ty {\n+                    self.public_items.insert(item.id);\n+                }\n+                if exported_ty {\n+                    self.exported_items.insert(item.id);\n+                }\n+\n                 for impl_item in impl_items {\n                     if impl_item.vis == hir::Public {\n                         if public_ty {\n@@ -1512,6 +1520,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n         prev_exported: true,\n         prev_public: true,\n     };\n+    visitor.exported_items.insert(ast::CRATE_NODE_ID);\n+    visitor.public_items.insert(ast::CRATE_NODE_ID);\n     loop {\n         let before = (visitor.exported_items.len(), visitor.public_items.len());\n         visit::walk_crate(&mut visitor, krate);"}]}