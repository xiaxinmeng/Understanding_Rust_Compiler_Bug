{"sha": "c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMTljZGZhMTFiMGJiMjNmMWRhYmJlZjk0MTVmZmI5NGYxMDM4NmE=", "commit": {"author": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2017-04-10T09:40:24Z"}, "committer": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2017-04-20T21:37:10Z"}, "message": "Removed sizing parameter from struct_llfields.", "tree": {"sha": "4dda7af89d58f8a7e8fe3e937f2c1a2083b383d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dda7af89d58f8a7e8fe3e937f2c1a2083b383d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "html_url": "https://github.com/rust-lang/rust/commit/c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c219cdfa11b0bb23f1dabbef9415ffb94f10386a/comments", "author": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7971a47eff4b178ffe7c38c67b1926dacea4c0dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7971a47eff4b178ffe7c38c67b1926dacea4c0dd", "html_url": "https://github.com/rust-lang/rust/commit/7971a47eff4b178ffe7c38c67b1926dacea4c0dd"}], "stats": {"total": 28, "additions": 10, "deletions": 18}, "files": [{"sha": "5326e9344c89a848d73698c84ed91a3c566fb48b", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c219cdfa11b0bb23f1dabbef9415ffb94f10386a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c219cdfa11b0bb23f1dabbef9415ffb94f10386a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "patch": "@@ -90,12 +90,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None, false)\n+    generic_type_of(cx, t, None)\n }\n \n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name), false)\n+    generic_type_of(cx, t, Some(name))\n }\n \n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -114,7 +114,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 _ => unreachable!()\n             };\n             let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false),\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -123,10 +123,9 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              t: Ty<'tcx>,\n-                             name: Option<&str>,\n-                             sizing: bool) -> Type {\n+                             name: Option<&str>) -> Type {\n     let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {}\", t, name, sizing);\n+    debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n         layout::RawNullablePointer { nndiscr, .. } => {\n@@ -146,11 +145,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -161,13 +159,12 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, &variant, sizing);\n+                    let fields = struct_llfields(cx, &fields, &variant);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n                     // drop flag. (... needs validation.)\n-                    assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -256,19 +253,14 @@ pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n \n \n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n-                             variant: &layout::Struct,\n-                             sizing: bool) -> Vec<Type> {\n-    if sizing {\n-        bug!();\n-    }\n+                             variant: &layout::Struct) -> Vec<Type> {\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut first_field = true;\n     let mut min_offset = 0;\n     let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n     let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n         (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n-    for (index, ty, target_offset) in field_iter.filter(\n-        |&(_, ty, _)| !sizing || cx.shared().type_is_sized(ty)) {\n+    for (index, ty, target_offset) in field_iter {\n         if first_field {\n             debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n                 index, ty, min_offset, target_offset);"}, {"sha": "88e46b5c99a44186a4a033e4ff630544049555c1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c219cdfa11b0bb23f1dabbef9415ffb94f10386a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c219cdfa11b0bb23f1dabbef9415ffb94f10386a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=c219cdfa11b0bb23f1dabbef9415ffb94f10386a", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let alignment = self.alignment | Alignment::from_packed(st.packed);\n \n-        let llfields = adt::struct_llfields(ccx, fields, st, false);\n+        let llfields = adt::struct_llfields(ccx, fields, st);\n         let ptr_val = if needs_cast {\n             let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n             bcx.pointercast(self.llval, real_ty.ptr_to())"}]}