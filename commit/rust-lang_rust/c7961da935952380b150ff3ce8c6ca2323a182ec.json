{"sha": "c7961da935952380b150ff3ce8c6ca2323a182ec", "node_id": "C_kwDOAAsO6NoAKGM3OTYxZGE5MzU5NTIzODBiMTUwZmYzY2U4YzZjYTIzMjNhMTgyZWM", "commit": {"author": {"name": "zhaixiaojuan", "email": "zhaixiaojuan@loongson.cn", "date": "2022-09-17T10:00:34Z"}, "committer": {"name": "zhaixiaojuan", "email": "zhaixiaojuan@loongson.cn", "date": "2022-09-17T10:00:34Z"}, "message": "Add loongarch64 abi support", "tree": {"sha": "f6e40a3a6e0b8f488491c8b86cea56943ac5cc0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6e40a3a6e0b8f488491c8b86cea56943ac5cc0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7961da935952380b150ff3ce8c6ca2323a182ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7961da935952380b150ff3ce8c6ca2323a182ec", "html_url": "https://github.com/rust-lang/rust/commit/c7961da935952380b150ff3ce8c6ca2323a182ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7961da935952380b150ff3ce8c6ca2323a182ec/comments", "author": {"login": "zhaixiaojuan", "id": 67671683, "node_id": "MDQ6VXNlcjY3NjcxNjgz", "avatar_url": "https://avatars.githubusercontent.com/u/67671683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhaixiaojuan", "html_url": "https://github.com/zhaixiaojuan", "followers_url": "https://api.github.com/users/zhaixiaojuan/followers", "following_url": "https://api.github.com/users/zhaixiaojuan/following{/other_user}", "gists_url": "https://api.github.com/users/zhaixiaojuan/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhaixiaojuan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhaixiaojuan/subscriptions", "organizations_url": "https://api.github.com/users/zhaixiaojuan/orgs", "repos_url": "https://api.github.com/users/zhaixiaojuan/repos", "events_url": "https://api.github.com/users/zhaixiaojuan/events{/privacy}", "received_events_url": "https://api.github.com/users/zhaixiaojuan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zhaixiaojuan", "id": 67671683, "node_id": "MDQ6VXNlcjY3NjcxNjgz", "avatar_url": "https://avatars.githubusercontent.com/u/67671683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhaixiaojuan", "html_url": "https://github.com/zhaixiaojuan", "followers_url": "https://api.github.com/users/zhaixiaojuan/followers", "following_url": "https://api.github.com/users/zhaixiaojuan/following{/other_user}", "gists_url": "https://api.github.com/users/zhaixiaojuan/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhaixiaojuan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhaixiaojuan/subscriptions", "organizations_url": "https://api.github.com/users/zhaixiaojuan/orgs", "repos_url": "https://api.github.com/users/zhaixiaojuan/repos", "events_url": "https://api.github.com/users/zhaixiaojuan/events{/privacy}", "received_events_url": "https://api.github.com/users/zhaixiaojuan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a12d10bcc4536108efad1613b57f725302c207e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12d10bcc4536108efad1613b57f725302c207e", "html_url": "https://github.com/rust-lang/rust/commit/4a12d10bcc4536108efad1613b57f725302c207e"}], "stats": {"total": 344, "additions": 344, "deletions": 0}, "files": [{"sha": "d29b479de5da6e4497ae96030eb83bb0e0013829", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/c7961da935952380b150ff3ce8c6ca2323a182ec/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7961da935952380b150ff3ce8c6ca2323a182ec/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=c7961da935952380b150ff3ce8c6ca2323a182ec", "patch": "@@ -0,0 +1,342 @@\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::{self, Abi, FieldsShape, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n+use crate::spec::HasTargetSpec;\n+\n+#[derive(Copy, Clone)]\n+enum RegPassKind {\n+    Float(Reg),\n+    Integer(Reg),\n+    Unknown,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FloatConv {\n+    FloatPair(Reg, Reg),\n+    Float(Reg),\n+    MixedPair(Reg, Reg),\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CannotUseFpConv;\n+\n+fn is_loongarch_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+    match arg.layout.abi {\n+        Abi::Vector { .. } => true,\n+        _ => arg.layout.is_aggregate(),\n+    }\n+}\n+\n+fn should_use_fp_conv_helper<'a, Ty, C>(\n+    cx: &C,\n+    arg_layout: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    field1_kind: &mut RegPassKind,\n+    field2_kind: &mut RegPassKind,\n+) -> Result<(), CannotUseFpConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    match arg_layout.abi {\n+        Abi::Scalar(scalar) => match scalar.primitive() {\n+            abi::Int(..) | abi::Pointer => {\n+                if arg_layout.size.bits() > xlen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {\n+                        *field2_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+            abi::F32 | abi::F64 => {\n+                if arg_layout.size.bits() > flen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    (_, RegPassKind::Unknown) => {\n+                        *field2_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+        },\n+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"aggregates can't have `FieldsShape::Primitive`\")\n+            }\n+            FieldsShape::Union(_) => {\n+                if !arg_layout.is_zst() {\n+                    return Err(CannotUseFpConv);\n+                }\n+            }\n+            FieldsShape::Array { count, .. } => {\n+                for _ in 0..count {\n+                    let elem_layout = arg_layout.field(cx, 0);\n+                    should_use_fp_conv_helper(\n+                        cx,\n+                        &elem_layout,\n+                        xlen,\n+                        flen,\n+                        field1_kind,\n+                        field2_kind,\n+                    )?;\n+                }\n+            }\n+            FieldsShape::Arbitrary { .. } => {\n+                match arg_layout.variants {\n+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n+                    abi::Variants::Single { .. } => (),\n+                }\n+                for i in arg_layout.fields.index_by_increasing_offset() {\n+                    let field = arg_layout.field(cx, i);\n+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;\n+                }\n+            }\n+        },\n+    }\n+    Ok(())\n+}\n+\n+fn should_use_fp_conv<'a, Ty, C>(\n+    cx: &C,\n+    arg: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+) -> Option<FloatConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    let mut field1_kind = RegPassKind::Unknown;\n+    let mut field2_kind = RegPassKind::Unknown;\n+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {\n+        return None;\n+    }\n+    match (field1_kind, field2_kind) {\n+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),\n+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),\n+        _ => None,\n+    }\n+}\n+\n+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+        match conv {\n+            FloatConv::Float(f) => {\n+                arg.cast_to(f);\n+            }\n+            FloatConv::FloatPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+            FloatConv::MixedPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    let total = arg.layout.size;\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        return true;\n+    }\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+    if is_loongarch_aggregate(arg) {\n+        if total.bits() <= xlen {\n+            arg.cast_to(xlen_reg);\n+        } else {\n+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });\n+        }\n+        return false;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    extend_integer_width(arg, xlen);\n+    false\n+}\n+\n+fn classify_arg<'a, Ty, C>(\n+    cx: &C,\n+    arg: &mut ArgAbi<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    is_vararg: bool,\n+    avail_gprs: &mut u64,\n+    avail_fprs: &mut u64,\n+) where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if !is_vararg {\n+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {\n+                *avail_fprs -= 1;\n+                arg.cast_to(f);\n+                return;\n+            }\n+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {\n+                *avail_fprs -= 2;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {\n+                *avail_gprs -= 1;\n+                *avail_fprs -= 1;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    let total = arg.layout.size;\n+    let align = arg.layout.align.abi.bits();\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    let double_xlen_reg = match xlen {\n+        32 => Reg::i64(),\n+        64 => Reg::i128(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    if total.bits() > xlen {\n+        let align_regs = align > xlen;\n+        if is_loongarch_aggregate(arg) {\n+            arg.cast_to(Uniform {\n+                unit: if align_regs { double_xlen_reg } else { xlen_reg },\n+                total: Size::from_bits(xlen * 2),\n+            });\n+        }\n+        if align_regs && is_vararg {\n+            *avail_gprs -= *avail_gprs % 2;\n+        }\n+        if *avail_gprs >= 2 {\n+            *avail_gprs -= 2;\n+        } else {\n+            *avail_gprs = 0;\n+        }\n+        return;\n+    } else if is_loongarch_aggregate(arg) {\n+        arg.cast_to(xlen_reg);\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    if *avail_gprs >= 1 {\n+        extend_integer_width(arg, xlen);\n+        *avail_gprs -= 1;\n+    }\n+}\n+\n+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+    if let Abi::Scalar(scalar) = arg.layout.abi {\n+        if let abi::Int(i, _) = scalar.primitive() {\n+            // 32-bit integers are always sign-extended\n+            if i.size().bits() == 32 && xlen > 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.ext(ArgExtension::Sext);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(xlen);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n+{\n+    let xlen = cx.data_layout().pointer_size.bits();\n+    let flen = match &cx.target_spec().llvm_abiname[..] {\n+        \"ilp32f\" | \"lp64f\" => 32,\n+        \"ilp32d\" | \"lp64d\" => 64,\n+        _ => 0,\n+    };\n+\n+    let mut avail_gprs = 8;\n+    let mut avail_fprs = 8;\n+\n+    if !fn_abi.ret.is_ignore() && classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+        avail_gprs -= 1;\n+    }\n+\n+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg(\n+            cx,\n+            arg,\n+            xlen,\n+            flen,\n+            i >= fn_abi.fixed_count as usize,\n+            &mut avail_gprs,\n+            &mut avail_fprs,\n+        );\n+    }\n+}"}, {"sha": "bd3cb7951edb0517d7c0ae63e7735585161593b5", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7961da935952380b150ff3ce8c6ca2323a182ec/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7961da935952380b150ff3ce8c6ca2323a182ec/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=c7961da935952380b150ff3ce8c6ca2323a182ec", "patch": "@@ -10,6 +10,7 @@ mod arm;\n mod avr;\n mod bpf;\n mod hexagon;\n+mod loongarch;\n mod m68k;\n mod mips;\n mod mips64;\n@@ -696,6 +697,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"amdgpu\" => amdgpu::compute_abi_info(cx, self),\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"avr\" => avr::compute_abi_info(self),\n+            \"loongarch64\" => loongarch::compute_abi_info(cx, self),\n             \"m68k\" => m68k::compute_abi_info(self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),"}]}