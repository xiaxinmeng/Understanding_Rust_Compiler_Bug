{"sha": "6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYmJhN2M1NGU0ZTFlMDJkNGZmM2ZmYWNmNDZkMTVkMGYzYTAzOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T06:51:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T06:51:40Z"}, "message": "auto merge of #12414 : DaGenix/rust/failing-iterator-wrappers, r=alexcrichton\n\n \r\nMost IO related functions return an IoResult so that the caller can handle failure in whatever way is appropriate. However, the `lines`, `bytes`, and `chars` iterators all supress errors. This means that code that needs to handle errors can't use any of these iterators. All three of these iterators were updated to produce IoResults.\r\n    \r\nFixes #12368", "tree": {"sha": "eb357b706573d3bb19a23fc7c12969cb7140373c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb357b706573d3bb19a23fc7c12969cb7140373c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "html_url": "https://github.com/rust-lang/rust/commit/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "792da8424f4f422c2750607dcc243315fdff9fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/792da8424f4f422c2750607dcc243315fdff9fc3", "html_url": "https://github.com/rust-lang/rust/commit/792da8424f4f422c2750607dcc243315fdff9fc3"}, {"sha": "9ba6bb5a71adeb861f8bf21c2b1f2fde3132480d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba6bb5a71adeb861f8bf21c2b1f2fde3132480d", "html_url": "https://github.com/rust-lang/rust/commit/9ba6bb5a71adeb861f8bf21c2b1f2fde3132480d"}], "stats": {"total": 106, "additions": 57, "deletions": 49}, "files": [{"sha": "4fee64e630481e679dd9fdb6bc102f91a8850bb9", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -19,7 +19,7 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     for ln in rdr.lines() {\n-        error_patterns.push_all_move(parse_expected(line_num, ln));\n+        error_patterns.push_all_move(parse_expected(line_num, ln.unwrap()));\n         line_num += 1u;\n     }\n     return error_patterns;"}, {"sha": "81b76f6b09a835d6ea98eff16e42effdb66999ac", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -140,6 +140,7 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n+        let ln = ln.unwrap();\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return true;\n         } else { if !(it(ln.trim())) { return false; } }"}, {"sha": "3ae44e4a1b5ce8872195fef24f9000717803258f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -537,9 +537,9 @@ mod test {\n         let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(~\"a\\n\"));\n-        assert_eq!(it.next(), Some(~\"b\\n\"));\n-        assert_eq!(it.next(), Some(~\"c\"));\n+        assert_eq!(it.next(), Some(Ok(~\"a\\n\")));\n+        assert_eq!(it.next(), Some(Ok(~\"b\\n\")));\n+        assert_eq!(it.next(), Some(Ok(~\"c\")));\n         assert_eq!(it.next(), None);\n     }\n \n@@ -569,8 +569,8 @@ mod test {\n         let buf = [195u8, 159u8, 'a' as u8];\n         let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n         let mut it = reader.chars();\n-        assert_eq!(it.next(), Some('\u00df'));\n-        assert_eq!(it.next(), Some('a'));\n+        assert_eq!(it.next(), Some(Ok('\u00df')));\n+        assert_eq!(it.next(), Some(Ok('a')));\n         assert_eq!(it.next(), None);\n     }\n "}, {"sha": "f7cab755714f20785e09fec7aa6a775e7ebab6ba", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -17,25 +17,26 @@\n \n use container::Container;\n use iter::Iterator;\n-use option::Option;\n-use io::Reader;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use io;\n+use io::{IoError, IoResult, Reader};\n use vec::{OwnedVector, ImmutableVector};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n-/// until `.read_byte()` returns `None`.\n+/// until `.read_byte()` returns `EndOfFile`.\n ///\n /// # Notes about the Iteration Protocol\n ///\n /// The `Bytes` may yield `None` and thus terminate\n /// an iteration, but continue to yield elements if iteration\n /// is attempted again.\n ///\n-/// # Failure\n+/// # Error\n ///\n-/// Raises the same conditions as the `read` method, for\n-/// each call to its `.next()` method.\n-/// Yields `None` if the condition is handled.\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n pub struct Bytes<'r, T> {\n     priv reader: &'r mut T,\n }\n@@ -46,10 +47,14 @@ impl<'r, R: Reader> Bytes<'r, R> {\n     }\n }\n \n-impl<'r, R: Reader> Iterator<u8> for Bytes<'r, R> {\n+impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n     #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.reader.read_byte().ok()\n+    fn next(&mut self) -> Option<IoResult<u8>> {\n+        match self.reader.read_byte() {\n+            Ok(x) => Some(Ok(x)),\n+            Err(IoError { kind: io::EndOfFile, .. }) => None,\n+            Err(e) => Some(Err(e))\n+        }\n     }\n }\n \n@@ -257,7 +262,7 @@ mod test {\n             count: 0,\n         };\n         let byte = reader.bytes().next();\n-        assert!(byte == Some(10));\n+        assert!(byte == Some(Ok(10)));\n     }\n \n     #[test]\n@@ -272,7 +277,7 @@ mod test {\n         let mut reader = ErroringReader;\n         let mut it = reader.bytes();\n         let byte = it.next();\n-        assert!(byte.is_none());\n+        assert!(byte.unwrap().is_err());\n     }\n \n     #[test]"}, {"sha": "3aaee59288f73c038644b12cb20b1bcc82dbc0fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -31,7 +31,7 @@ Some examples of obvious things you might want to do\n     use std::io;\n \n     for line in io::stdin().lines() {\n-        print!(\"{}\", line);\n+        print!(\"{}\", line.unwrap());\n     }\n     ```\n \n@@ -57,26 +57,26 @@ Some examples of obvious things you might want to do\n \n * Iterate over the lines of a file\n \n-    ```rust\n+    ```rust,no_run\n     use std::io::BufferedReader;\n     use std::io::File;\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     for line in file.lines() {\n-        print!(\"{}\", line);\n+        print!(\"{}\", line.unwrap());\n     }\n     ```\n \n * Pull the lines of a file into a vector of strings\n \n-    ```rust\n+    ```rust,no_run\n     use std::io::BufferedReader;\n     use std::io::File;\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n-    let lines: ~[~str] = file.lines().collect();\n+    let lines: ~[~str] = file.lines().map(|x| x.unwrap()).collect();\n     ```\n \n * Make a simple TCP client connection and request\n@@ -466,10 +466,8 @@ pub trait Reader {\n     ///\n     /// # Error\n     ///\n-    /// The iterator protocol causes all specifics about errors encountered to\n-    /// be swallowed. All errors will be signified by returning `None` from the\n-    /// iterator. If this is undesirable, it is recommended to use the\n-    /// `read_byte` method.\n+    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n+    /// is returned by the iterator and should be handled by the caller.\n     fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n         extensions::Bytes::new(self)\n     }\n@@ -986,7 +984,7 @@ pub trait Stream: Reader + Writer { }\n impl<T: Reader + Writer> Stream for T {}\n \n /// An iterator that reads a line on each iteration,\n-/// until `.read_line()` returns `None`.\n+/// until `.read_line()` encounters `EndOfFile`.\n ///\n /// # Notes about the Iteration Protocol\n ///\n@@ -996,21 +994,24 @@ impl<T: Reader + Writer> Stream for T {}\n ///\n /// # Error\n ///\n-/// This iterator will swallow all I/O errors, transforming `Err` values to\n-/// `None`. If errors need to be handled, it is recommended to use the\n-/// `read_line` method directly.\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n pub struct Lines<'r, T> {\n     priv buffer: &'r mut T,\n }\n \n-impl<'r, T: Buffer> Iterator<~str> for Lines<'r, T> {\n-    fn next(&mut self) -> Option<~str> {\n-        self.buffer.read_line().ok()\n+impl<'r, T: Buffer> Iterator<IoResult<~str>> for Lines<'r, T> {\n+    fn next(&mut self) -> Option<IoResult<~str>> {\n+        match self.buffer.read_line() {\n+            Ok(x) => Some(Ok(x)),\n+            Err(IoError { kind: EndOfFile, ..}) => None,\n+            Err(y) => Some(Err(y))\n+        }\n     }\n }\n \n /// An iterator that reads a utf8-encoded character on each iteration,\n-/// until `.read_char()` returns `None`.\n+/// until `.read_char()` encounters `EndOfFile`.\n ///\n /// # Notes about the Iteration Protocol\n ///\n@@ -1020,16 +1021,19 @@ impl<'r, T: Buffer> Iterator<~str> for Lines<'r, T> {\n ///\n /// # Error\n ///\n-/// This iterator will swallow all I/O errors, transforming `Err` values to\n-/// `None`. If errors need to be handled, it is recommended to use the\n-/// `read_char` method directly.\n+/// Any error other than `EndOfFile` that is produced by the underlying Reader\n+/// is returned by the iterator and should be handled by the caller.\n pub struct Chars<'r, T> {\n     priv buffer: &'r mut T\n }\n \n-impl<'r, T: Buffer> Iterator<char> for Chars<'r, T> {\n-    fn next(&mut self) -> Option<char> {\n-        self.buffer.read_char().ok()\n+impl<'r, T: Buffer> Iterator<IoResult<char>> for Chars<'r, T> {\n+    fn next(&mut self) -> Option<IoResult<char>> {\n+        match self.buffer.read_char() {\n+            Ok(x) => Some(Ok(x)),\n+            Err(IoError { kind: EndOfFile, ..}) => None,\n+            Err(y) => Some(Err(y))\n+        }\n     }\n }\n \n@@ -1095,9 +1099,8 @@ pub trait Buffer: Reader {\n     ///\n     /// # Error\n     ///\n-    /// This iterator will transform all error values to `None`, discarding the\n-    /// cause of the error. If this is undesirable, it is recommended to call\n-    /// `read_line` directly.\n+    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n+    /// is returned by the iterator and should be handled by the caller.\n     fn lines<'r>(&'r mut self) -> Lines<'r, Self> {\n         Lines { buffer: self }\n     }\n@@ -1183,9 +1186,8 @@ pub trait Buffer: Reader {\n     ///\n     /// # Error\n     ///\n-    /// This iterator will transform all error values to `None`, discarding the\n-    /// cause of the error. If this is undesirable, it is recommended to call\n-    /// `read_char` directly.\n+    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n+    /// is returned by the iterator and should be handled by the caller.\n     fn chars<'r>(&'r mut self) -> Chars<'r, Self> {\n         Chars { buffer: self }\n     }"}, {"sha": "d8bd0e6250f512cc3dbf73f8fddded946b20240f", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -182,7 +182,7 @@ fn main() {\n    let mut proc_mode = false;\n \n    for line in rdr.lines() {\n-       let line = line.trim().to_owned();\n+       let line = line.unwrap().trim().to_owned();\n \n        if line.len() == 0u { continue; }\n "}, {"sha": "d2ce61ee7556e166058c765344033109e814cef1", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "patch": "@@ -72,7 +72,7 @@ impl Sudoku {\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         for line in reader.lines() {\n-            let comps: ~[&str] = line.trim().split(',').collect();\n+            let comps: ~[&str] = line.unwrap().trim().split(',').collect();\n \n             if comps.len() == 3u {\n                 let row     = from_str::<uint>(comps[0]).unwrap() as u8;"}]}