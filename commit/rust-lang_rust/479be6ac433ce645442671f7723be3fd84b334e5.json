{"sha": "479be6ac433ce645442671f7723be3fd84b334e5", "node_id": "C_kwDOAAsO6NoAKDQ3OWJlNmFjNDMzY2U2NDU0NDI2NzFmNzcyM2JlM2ZkODRiMzM0ZTU", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-06-08T14:55:49Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-06-14T07:28:56Z"}, "message": "update hashbrown and replace Hash{Set,Map}::DrainFilter with ExtractIf", "tree": {"sha": "66a5bdec162b4a79d48e04c74f8f5f7fc9539d7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66a5bdec162b4a79d48e04c74f8f5f7fc9539d7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/479be6ac433ce645442671f7723be3fd84b334e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/479be6ac433ce645442671f7723be3fd84b334e5", "html_url": "https://github.com/rust-lang/rust/commit/479be6ac433ce645442671f7723be3fd84b334e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/479be6ac433ce645442671f7723be3fd84b334e5/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18c9a12d13fd70b8950a4985f7968ab70ec9b37b", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c9a12d13fd70b8950a4985f7968ab70ec9b37b", "html_url": "https://github.com/rust-lang/rust/commit/18c9a12d13fd70b8950a4985f7968ab70ec9b37b"}], "stats": {"total": 169, "additions": 94, "deletions": 75}, "files": [{"sha": "4eafda94037c384b8931fe4b9c24405313ecc592", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -65,6 +65,12 @@ dependencies = [\n  \"rand_xorshift\",\n ]\n \n+[[package]]\n+name = \"allocator-api2\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c4f263788a35611fba42eb41ff811c5d0360c58b97402570312a350736e2542e\"\n+\n [[package]]\n name = \"ammonia\"\n version = \"3.2.0\"\n@@ -1522,6 +1528,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"33ff8ae62cd3a9102e5637afc8452c55acf3844001bd5374e0b0bd7b6616c038\"\n dependencies = [\n  \"ahash 0.8.2\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a\"\n+dependencies = [\n+ \"allocator-api2\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -4633,7 +4648,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.13.1\",\n+ \"hashbrown 0.14.0\",\n  \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\","}, {"sha": "e6b051838861adcf4eb089eb3df732493787b249", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -21,7 +21,7 @@ libc = { version = \"0.2.146\", default-features = false, features = ['rustc-dep-o\n compiler_builtins = { version = \"0.1.92\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.13\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.14\", default-features = false, features = ['rustc-dep-of-std'] }\n std_detect = { path = \"../stdarch/crates/std_detect\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate"}, {"sha": "f3316d97c5faf0d20722eb9dc3024eb2a4113b11", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -623,28 +623,27 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// If the closure returns false, or panics, the element remains in the map and will not be\n     /// yielded.\n     ///\n-    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// Note that `extract_if` lets you mutate every value in the filter closure, regardless of\n     /// whether you choose to keep or remove it.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n-    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more elements will be subjected to the closure\n-    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n-    /// or if the `DrainFilter` value is leaked.\n+    /// [`retain`]: HashMap::retain\n     ///\n     /// # Examples\n     ///\n     /// Splitting a map into even and odd keys, reusing the original map:\n     ///\n     /// ```\n-    /// #![feature(hash_drain_filter)]\n+    /// #![feature(hash_extract_if)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n-    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let extracted: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n     ///\n-    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n+    /// let mut evens = extracted.keys().copied().collect::<Vec<_>>();\n     /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n     /// evens.sort();\n     /// odds.sort();\n@@ -654,12 +653,12 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[inline]\n     #[rustc_lint_query_instability]\n-    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    #[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+    pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, K, V, F>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        DrainFilter { base: self.base.drain_filter(pred) }\n+        ExtractIf { base: self.base.extract_if(pred) }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1578,28 +1577,29 @@ impl<'a, K, V> Drain<'a, K, V> {\n \n /// A draining, filtering iterator over the entries of a `HashMap`.\n ///\n-/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n+/// This `struct` is created by the [`extract_if`] method on [`HashMap`].\n ///\n-/// [`drain_filter`]: HashMap::drain_filter\n+/// [`extract_if`]: HashMap::extract_if\n ///\n /// # Example\n ///\n /// ```\n-/// #![feature(hash_drain_filter)]\n+/// #![feature(hash_extract_if)]\n ///\n /// use std::collections::HashMap;\n ///\n /// let mut map = HashMap::from([\n ///     (\"a\", 1),\n /// ]);\n-/// let iter = map.drain_filter(|_k, v| *v % 2 == 0);\n+/// let iter = map.extract_if(|_k, v| *v % 2 == 0);\n /// ```\n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-pub struct DrainFilter<'a, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<'a, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n-    base: base::DrainFilter<'a, K, V, F>,\n+    base: base::ExtractIf<'a, K, V, F>,\n }\n \n /// A mutable iterator over the values of a `HashMap`.\n@@ -2479,8 +2479,8 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, V, F> Iterator for ExtractIf<'_, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -2496,16 +2496,16 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, V, F> FusedIterator for ExtractIf<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<'a, K, V, F> fmt::Debug for ExtractIf<'a, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n+        f.debug_struct(\"ExtractIf\").finish_non_exhaustive()\n     }\n }\n "}, {"sha": "91a3776e7be84a20d20701cf20fe3192662bdad1", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -944,7 +944,7 @@ fn test_raw_entry() {\n     }\n }\n \n-mod test_drain_filter {\n+mod test_extract_if {\n     use super::*;\n \n     use crate::panic::{catch_unwind, AssertUnwindSafe};\n@@ -968,23 +968,23 @@ mod test_drain_filter {\n     #[test]\n     fn empty() {\n         let mut map: HashMap<i32, i32> = HashMap::new();\n-        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        map.extract_if(|_, _| unreachable!(\"there's nothing to decide on\")).for_each(drop);\n         assert!(map.is_empty());\n     }\n \n     #[test]\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n-        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n+        assert!(map.extract_if(|_, _| false).eq_sorted(crate::iter::empty()));\n         assert_eq!(map.len(), 3);\n     }\n \n     #[test]\n     fn consuming_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.clone().collect();\n-        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n+        assert!(map.extract_if(|_, _| true).eq_sorted(pairs));\n         assert!(map.is_empty());\n     }\n \n@@ -993,7 +993,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 false\n             })\n@@ -1008,7 +1008,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 true\n             })\n@@ -1034,14 +1034,15 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         catch_unwind(move || {\n-            drop(map.drain_filter(|_, _| {\n+            map.extract_if(|_, _| {\n                 PREDS.fetch_add(1, Ordering::SeqCst);\n                 true\n-            }))\n+            })\n+            .for_each(drop)\n         })\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n     }\n \n@@ -1060,10 +1061,11 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         catch_unwind(AssertUnwindSafe(|| {\n-            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            map.extract_if(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                 0 => true,\n                 _ => panic!(),\n-            }))\n+            })\n+            .for_each(drop)\n         }))\n         .unwrap_err();\n \n@@ -1088,7 +1090,7 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         {\n-            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            let mut it = map.extract_if(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                 0 => true,\n                 _ => panic!(),\n             });"}, {"sha": "5bf542629f003dc8177bbfa22f7e3e280ad58b2e", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -262,25 +262,24 @@ impl<T, S> HashSet<T, S> {\n     /// If the closure returns false, the value will remain in the list and will not be yielded\n     /// by the iterator.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n-    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more values will be subjected to the closure\n-    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n-    /// `DrainFilter` itself is leaked.\n+    /// [`retain`]: HashSet::retain\n     ///\n     /// # Examples\n     ///\n     /// Splitting a set into even and odd values, reusing the original set:\n     ///\n     /// ```\n-    /// #![feature(hash_drain_filter)]\n+    /// #![feature(hash_extract_if)]\n     /// use std::collections::HashSet;\n     ///\n     /// let mut set: HashSet<i32> = (0..8).collect();\n-    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let extracted: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n     ///\n-    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n+    /// let mut evens = extracted.into_iter().collect::<Vec<_>>();\n     /// let mut odds = set.into_iter().collect::<Vec<_>>();\n     /// evens.sort();\n     /// odds.sort();\n@@ -290,12 +289,12 @@ impl<T, S> HashSet<T, S> {\n     /// ```\n     #[inline]\n     #[rustc_lint_query_instability]\n-    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n+    #[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+    pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, T, F>\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        DrainFilter { base: self.base.drain_filter(pred) }\n+        ExtractIf { base: self.base.extract_if(pred) }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1310,27 +1309,27 @@ pub struct Drain<'a, K: 'a> {\n \n /// A draining, filtering iterator over the items of a `HashSet`.\n ///\n-/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n+/// This `struct` is created by the [`extract_if`] method on [`HashSet`].\n ///\n-/// [`drain_filter`]: HashSet::drain_filter\n+/// [`extract_if`]: HashSet::extract_if\n ///\n /// # Examples\n ///\n /// ```\n-/// #![feature(hash_drain_filter)]\n+/// #![feature(hash_extract_if)]\n ///\n /// use std::collections::HashSet;\n ///\n /// let mut a = HashSet::from([1, 2, 3]);\n ///\n-/// let mut drain_filtered = a.drain_filter(|v| v % 2 == 0);\n+/// let mut extract_ifed = a.extract_if(|v| v % 2 == 0);\n /// ```\n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-pub struct DrainFilter<'a, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+pub struct ExtractIf<'a, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n-    base: base::DrainFilter<'a, K, F>,\n+    base: base::ExtractIf<'a, K, F>,\n }\n \n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n@@ -1576,8 +1575,8 @@ impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, F> Iterator for DrainFilter<'_, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, F> Iterator for ExtractIf<'_, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n@@ -1593,16 +1592,16 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, F> FusedIterator for ExtractIf<'_, K, F> where F: FnMut(&K) -> bool {}\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<'a, K, F> fmt::Debug for ExtractIf<'a, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n+        f.debug_struct(\"ExtractIf\").finish_non_exhaustive()\n     }\n }\n "}, {"sha": "7ac9eae67a090b42897ae7de9a72e49c8a20be80", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -418,18 +418,18 @@ fn test_retain() {\n }\n \n #[test]\n-fn test_drain_filter() {\n+fn test_extract_if() {\n     let mut x: HashSet<_> = [1].iter().copied().collect();\n     let mut y: HashSet<_> = [1].iter().copied().collect();\n \n-    x.drain_filter(|_| true);\n-    y.drain_filter(|_| false);\n+    x.extract_if(|_| true).for_each(drop);\n+    y.extract_if(|_| false).for_each(drop);\n     assert_eq!(x.len(), 0);\n     assert_eq!(y.len(), 1);\n }\n \n #[test]\n-fn test_drain_filter_drop_panic_leak() {\n+fn test_extract_if_drop_panic_leak() {\n     static PREDS: AtomicU32 = AtomicU32::new(0);\n     static DROPS: AtomicU32 = AtomicU32::new(0);\n \n@@ -446,19 +446,20 @@ fn test_drain_filter_drop_panic_leak() {\n     let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n \n     catch_unwind(move || {\n-        drop(set.drain_filter(|_| {\n+        set.extract_if(|_| {\n             PREDS.fetch_add(1, Ordering::SeqCst);\n             true\n-        }))\n+        })\n+        .for_each(drop)\n     })\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n     assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n }\n \n #[test]\n-fn test_drain_filter_pred_panic_leak() {\n+fn test_extract_if_pred_panic_leak() {\n     static PREDS: AtomicU32 = AtomicU32::new(0);\n     static DROPS: AtomicU32 = AtomicU32::new(0);\n \n@@ -473,10 +474,11 @@ fn test_drain_filter_pred_panic_leak() {\n     let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n \n     catch_unwind(AssertUnwindSafe(|| {\n-        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+        set.extract_if(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n             0 => true,\n             _ => panic!(),\n-        }))\n+        })\n+        .for_each(drop)\n     }))\n     .ok();\n "}, {"sha": "ac2056bcc855ac4877aa69ecb2ace49cb73ab077", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/479be6ac433ce645442671f7723be3fd84b334e5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479be6ac433ce645442671f7723be3fd84b334e5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=479be6ac433ce645442671f7723be3fd84b334e5", "patch": "@@ -108,6 +108,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"adler\",\n     \"ahash\",\n     \"aho-corasick\",\n+    \"allocator-api2\", // FIXME: only appears in Cargo.lock due to https://github.com/rust-lang/cargo/issues/10801\n     \"annotate-snippets\",\n     \"ansi_term\",\n     \"ar_archive_writer\","}]}