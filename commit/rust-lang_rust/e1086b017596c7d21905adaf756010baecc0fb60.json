{"sha": "e1086b017596c7d21905adaf756010baecc0fb60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMDg2YjAxNzU5NmM3ZDIxOTA1YWRhZjc1NjAxMGJhZWNjMGZiNjA=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T03:15:30Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T03:23:18Z"}, "message": "Implement sync::rwlock::write_cond (and task::rekillable)", "tree": {"sha": "c364760801ad243f1567842112ab37d9d2619143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c364760801ad243f1567842112ab37d9d2619143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1086b017596c7d21905adaf756010baecc0fb60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1086b017596c7d21905adaf756010baecc0fb60", "html_url": "https://github.com/rust-lang/rust/commit/e1086b017596c7d21905adaf756010baecc0fb60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1086b017596c7d21905adaf756010baecc0fb60/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c9f16837249a7eeec129fa5f18c61a270262f1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9f16837249a7eeec129fa5f18c61a270262f1d", "html_url": "https://github.com/rust-lang/rust/commit/4c9f16837249a7eeec129fa5f18c61a270262f1d"}], "stats": {"total": 93, "additions": 74, "deletions": 19}, "files": [{"sha": "fba9569c304ac96e38761777fb09f4aa4be3067a", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e1086b017596c7d21905adaf756010baecc0fb60/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1086b017596c7d21905adaf756010baecc0fb60/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=e1086b017596c7d21905adaf756010baecc0fb60", "patch": "@@ -162,7 +162,6 @@ impl condvar {\n                 // Release lock, 'atomically' enqueuing ourselves in so doing.\n                 do (**self.sem).with |state| {\n                     // Drop the lock.\n-                    // FIXME(#3145) investigate why factoring doesn't compile.\n                     state.count += 1;\n                     if state.count <= 0 {\n                         signal_waitqueue(&state.waiters);\n@@ -343,34 +342,41 @@ impl &rwlock {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n-                (&self.access_lock).acquire();\n-                (&self.order_lock).release();\n+                do (&self.access_lock).access {\n+                    (&self.order_lock).release();\n+                    task::rekillable(blk)\n+                }\n             }\n         }\n-        let _z = rwlock_release_write(self);\n-        blk()\n     }\n \n     /**\n      * As write(), but also with a handle to a condvar. Waiting on this\n      * condvar will allow readers and writers alike to take the rwlock before\n-     * the waiting task is signalled.\n+     * the waiting task is signalled. (Note: a writer that waited and then\n+     * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(_blk: fn(condvar) -> U) -> U {\n-        fail ~\"Need implement lock order lock before access lock\";\n+    fn write_cond<U>(blk: fn(condvar) -> U) -> U {\n+        // NB: You might think I should thread the order_lock into the cond\n+        // wait call, so that it gets waited on before access_lock gets\n+        // reacquired upon being woken up. However, (a) this would be not\n+        // pleasant to implement (and would mandate a new 'rw_cond' type) and\n+        // (b) I think violating no-starvation in that case is appropriate.\n+        unsafe {\n+            do task::unkillable {\n+                (&self.order_lock).acquire();\n+                do (&self.access_lock).access_cond |cond| {\n+                    (&self.order_lock).release();\n+                    do task::rekillable { blk(cond) }\n+                }\n+            }\n+        }\n     }\n \n     // to-do implement downgrade\n }\n \n-// FIXME(#3136) should go inside of write() and read() respectively\n-struct rwlock_release_write {\n-    lock: &rwlock;\n-    new(lock: &rwlock) { self.lock = lock; }\n-    drop unsafe {\n-        do task::unkillable { (&self.lock.access_lock).release(); }\n-    }\n-}\n+// FIXME(#3136) should go inside of read()\n struct rwlock_release_read {\n     lock: &rwlock;\n     new(lock: &rwlock) { self.lock = lock; }\n@@ -708,6 +714,41 @@ mod tests {\n             let _ = p1.recv();\n         }\n     }\n+    #[test]\n+    fn test_rwlock_cond_wait() {\n+        // As test_mutex_cond_wait above.\n+        let x = ~rwlock();\n+\n+        // Child wakes up parent\n+        do x.write_cond |cond| {\n+            let x2 = ~x.clone();\n+            do task::spawn {\n+                do x2.write_cond |cond| {\n+                    let woken = cond.signal();\n+                    assert woken;\n+                }\n+            }\n+            cond.wait();\n+        }\n+        // Parent wakes up child\n+        let (chan,port) = pipes::stream();\n+        let x3 = ~x.clone();\n+        do task::spawn {\n+            do x3.write_cond |cond| {\n+                chan.send(());\n+                cond.wait();\n+                chan.send(());\n+            }\n+        }\n+        let _ = port.recv(); // Wait until child gets in the rwlock\n+        do x.read { } // Must be able to get in as a reader in the meantime\n+        do x.write_cond |cond| { // Or as another writer\n+            let woken = cond.signal();\n+            assert woken;\n+        }\n+        let _ = port.recv(); // Wait until child wakes up\n+        do x.read { } // Just for good measure\n+    }\n     #[cfg(test)] #[ignore(cfg(windows))]\n     fn rwlock_kill_helper(reader1: bool, reader2: bool) {\n         // Mutex must get automatically unlocked if failed/killed within."}, {"sha": "67e6dd6125c1cc27bc8e5a59662c71d5688d075b", "filename": "src/libcore/task.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1086b017596c7d21905adaf756010baecc0fb60/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1086b017596c7d21905adaf756010baecc0fb60/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e1086b017596c7d21905adaf756010baecc0fb60", "patch": "@@ -56,7 +56,7 @@ export try;\n export yield;\n export failing;\n export get_task;\n-export unkillable;\n+export unkillable, rekillable;\n export atomically;\n \n export local_data_key;\n@@ -572,7 +572,7 @@ fn get_task() -> task {\n  * }\n  * ~~~\n  */\n-unsafe fn unkillable(f: fn()) {\n+unsafe fn unkillable<U>(f: fn() -> U) -> U {\n     class allow_failure {\n         let t: *rust_task;\n         new(t: *rust_task) { self.t = t; }\n@@ -582,7 +582,21 @@ unsafe fn unkillable(f: fn()) {\n     let t = rustrt::rust_get_task();\n     let _allow_failure = allow_failure(t);\n     rustrt::rust_task_inhibit_kill(t);\n-    f();\n+    f()\n+}\n+\n+/// The inverse of unkillable. Only ever to be used nested in unkillable().\n+unsafe fn rekillable<U>(f: fn() -> U) -> U {\n+    class disallow_failure {\n+        let t: *rust_task;\n+        new(t: *rust_task) { self.t = t; }\n+        drop { rustrt::rust_task_inhibit_kill(self.t); }\n+    }\n+\n+    let t = rustrt::rust_get_task();\n+    let _allow_failure = disallow_failure(t);\n+    rustrt::rust_task_allow_kill(t);\n+    f()\n }\n \n /**"}]}