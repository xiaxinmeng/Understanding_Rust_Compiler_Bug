{"sha": "ee6e705d91a7b19aa2d029b21396c70e2129f741", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNmU3MDVkOTFhN2IxOWFhMmQwMjliMjEzOTZjNzBlMjEyOWY3NDE=", "commit": {"author": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2020-05-24T12:11:12Z"}, "committer": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2020-05-25T10:47:48Z"}, "message": "Fix UB in Arc\n\nUse raw pointers to avoid making any assertions about the data field.", "tree": {"sha": "0d40016537d23bd3b16667f6ac0a270c9f85d375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d40016537d23bd3b16667f6ac0a270c9f85d375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee6e705d91a7b19aa2d029b21396c70e2129f741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee6e705d91a7b19aa2d029b21396c70e2129f741", "html_url": "https://github.com/rust-lang/rust/commit/ee6e705d91a7b19aa2d029b21396c70e2129f741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee6e705d91a7b19aa2d029b21396c70e2129f741/comments", "author": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed084b0b8341c974769a0328f61851b0e1fc17fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa", "html_url": "https://github.com/rust-lang/rust/commit/ed084b0b8341c974769a0328f61851b0e1fc17fa"}], "stats": {"total": 35, "additions": 26, "deletions": 9}, "files": [{"sha": "385506dc7a13dc8ace6f22c9cb15ccd54dfb3ad1", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ee6e705d91a7b19aa2d029b21396c70e2129f741/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6e705d91a7b19aa2d029b21396c70e2129f741/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=ee6e705d91a7b19aa2d029b21396c70e2129f741", "patch": "@@ -866,12 +866,10 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n+        ptr::drop_in_place(Self::get_mut_unchecked(self));\n \n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            acquire!(self.inner().weak);\n-            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n-        }\n+        // Drop the weak ref collectively held by all strong references\n+        drop(Weak { ptr: self.ptr });\n     }\n \n     #[inline]\n@@ -1201,7 +1199,7 @@ impl<T: Clone> Arc<T> {\n \n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        unsafe { &mut this.ptr.as_mut().data }\n+        unsafe { Self::get_mut_unchecked(this) }\n     }\n }\n \n@@ -1277,7 +1275,9 @@ impl<T: ?Sized> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        &mut this.ptr.as_mut().data\n+        // We are careful to *not* create a reference covering the \"count\" fields, as\n+        // this would alias with concurrent access to the reference counts (e.g. by `Weak`).\n+        &mut (*this.ptr.as_ptr()).data\n     }\n \n     /// Determine whether this is the unique reference (including weak refs) to\n@@ -1568,6 +1568,13 @@ impl<T> Weak<T> {\n     }\n }\n \n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a atomic::AtomicUsize,\n+    strong: &'a atomic::AtomicUsize,\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n     /// dropping of the inner value if successful.\n@@ -1673,8 +1680,18 @@ impl<T: ?Sized> Weak<T> {\n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n-    fn inner(&self) -> Option<&ArcInner<T>> {\n-        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n+    fn inner(&self) -> Option<WeakInner<'_>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            // We are careful to *not* create a reference covering the \"data\" field, as\n+            // the field may be mutated concurrently (for example, if the last `Arc`\n+            // is dropped, the data field will be dropped in-place).\n+            Some(unsafe {\n+                let ptr = self.ptr.as_ptr();\n+                WeakInner { strong: &(*ptr).strong, weak: &(*ptr).weak }\n+            })\n+        }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to"}]}