{"sha": "c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjQwYWEyYWFhZDg1N2JiYzlmOWExMDAyZjhlMWFhZjUyMDc1MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T14:56:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T14:56:20Z"}, "message": "Auto merge of #31583 - petrochenkov:indi_ast, r=Manishearth\n\ncc #31487\nplugin-[breaking-change]\n\nThe AST part of https://github.com/rust-lang/rust/pull/30087\n\nr? @Manishearth", "tree": {"sha": "057b1cbdee3abfa8a925cf655376f7abeaba6b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/057b1cbdee3abfa8a925cf655376f7abeaba6b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "html_url": "https://github.com/rust-lang/rust/commit/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9257e8956edf003ee73b4d5ba4dc46c4d07a7e72", "url": "https://api.github.com/repos/rust-lang/rust/commits/9257e8956edf003ee73b4d5ba4dc46c4d07a7e72", "html_url": "https://github.com/rust-lang/rust/commit/9257e8956edf003ee73b4d5ba4dc46c4d07a7e72"}, {"sha": "77cc5764b9d8b53e01788886d3b3882dffc0001e", "url": "https://api.github.com/repos/rust-lang/rust/commits/77cc5764b9d8b53e01788886d3b3882dffc0001e", "html_url": "https://github.com/rust-lang/rust/commit/77cc5764b9d8b53e01788886d3b3882dffc0001e"}], "stats": {"total": 525, "additions": 271, "deletions": 254}, "files": [{"sha": "170ae65f919064a55455799677b8a0a16b568032", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -614,7 +614,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n         }\n     }\n \n-    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         match i.node {\n             ast::TraitItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n@@ -626,7 +626,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n         }\n     }\n \n-    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n         match i.node {\n             ast::ImplItemKind::Const(..) => {\n                 self.within_static_or_const = true;"}, {"sha": "72b65f2e45fb008736e3c1ab0784fd5874a21666", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -561,7 +561,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n-                    impl_items: &[P<ast::ImplItem>]) {\n+                    impl_items: &[ast::ImplItem]) {\n         let mut has_self_ref = false;\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(impl_data, ImplData, self, item.span);\n@@ -602,7 +602,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      item: &ast::Item,\n                      generics: &ast::Generics,\n                      trait_refs: &ast::TyParamBounds,\n-                     methods: &[P<ast::TraitItem>]) {\n+                     methods: &[ast::TraitItem]) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);"}, {"sha": "d220508a741f1841904d7738b1ee04a2e4485473", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -287,7 +287,7 @@ impl PathParameters {\n         }\n     }\n \n-    pub fn bindings(&self) -> Vec<&P<TypeBinding>> {\n+    pub fn bindings(&self) -> Vec<&TypeBinding> {\n         match *self {\n             PathParameters::AngleBracketed(ref data) => {\n                 data.bindings.iter().collect()\n@@ -308,7 +308,7 @@ pub struct AngleBracketedParameterData {\n     pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// e.g., `Foo<A=Bar>`.\n-    pub bindings: P<[P<TypeBinding>]>,\n+    pub bindings: P<[TypeBinding]>,\n }\n \n impl AngleBracketedParameterData {\n@@ -508,7 +508,7 @@ impl PartialEq for MetaItemKind {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n-    pub stmts: Vec<P<Stmt>>,\n+    pub stmts: Vec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n@@ -1716,12 +1716,12 @@ pub struct Mod {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub items: Vec<P<ForeignItem>>,\n+    pub items: Vec<ForeignItem>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<P<Variant>>,\n+    pub variants: Vec<Variant>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1988,7 +1988,7 @@ pub enum ItemKind {\n     Trait(Unsafety,\n               Generics,\n               TyParamBounds,\n-              Vec<P<TraitItem>>),\n+              Vec<TraitItem>),\n \n     // Default trait implementations\n     ///\n@@ -2000,7 +2000,7 @@ pub enum ItemKind {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<P<ImplItem>>),\n+             Vec<ImplItem>),\n     /// A macro invocation (which includes macro definition)\n     Mac(Mac),\n }"}, {"sha": "9acb1805cdde879e302092efe5ac4989ff45fb2e", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -72,7 +72,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         fold_opt_expr(self, expr)\n     }\n-    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         fold_stmt(self, stmt)\n     }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n@@ -95,8 +95,8 @@ pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n }\n \n fn filter_foreign_item<F>(cx: &mut Context<F>,\n-                          item: P<ast::ForeignItem>)\n-                          -> Option<P<ast::ForeignItem>> where\n+                          item: ast::ForeignItem)\n+                          -> Option<ast::ForeignItem> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     if foreign_item_in_cfg(cx, &item) {\n@@ -153,18 +153,15 @@ fn fold_item_kind<F>(cx: &mut Context<F>, item: ast::ItemKind) -> ast::ItemKind\n                 if !(cx.in_cfg)(&v.node.attrs) {\n                     None\n                 } else {\n-                    Some(v.map(|Spanned {node: ast::Variant_ {name, attrs, data,\n-                                                              disr_expr}, span}| {\n-                        Spanned {\n-                            node: ast::Variant_ {\n-                                name: name,\n-                                attrs: attrs,\n-                                data: fold_struct(cx, data),\n-                                disr_expr: disr_expr,\n-                            },\n-                            span: span\n-                        }\n-                    }))\n+                    Some(Spanned {\n+                        node: ast::Variant_ {\n+                            name: v.node.name,\n+                            attrs: v.node.attrs,\n+                            data: fold_struct(cx, v.node.data),\n+                            disr_expr: v.node.disr_expr,\n+                        },\n+                        span: v.span\n+                    })\n                 }\n             });\n             ast::ItemKind::Enum(ast::EnumDef {\n@@ -225,11 +222,11 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n     })\n }\n \n-fn fold_stmt<F>(cx: &mut Context<F>, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>>\n+fn fold_stmt<F>(cx: &mut Context<F>, stmt: ast::Stmt) -> SmallVector<ast::Stmt>\n     where F: FnMut(&[ast::Attribute]) -> bool\n {\n     if stmt_in_cfg(cx, &stmt) {\n-        stmt.and_then(|s| fold::noop_fold_stmt(s, cx))\n+        fold::noop_fold_stmt(stmt, cx)\n     } else {\n         SmallVector::zero()\n     }"}, {"sha": "b4e86e4cfd36f717e1b86054e4849ad3cc5350bb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -82,16 +82,16 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn expect_trait_item(self) -> P<ast::TraitItem> {\n+    pub fn expect_trait_item(self) -> ast::TraitItem {\n         match self {\n-            Annotatable::TraitItem(i) => i,\n+            Annotatable::TraitItem(i) => i.unwrap(),\n             _ => panic!(\"expected Item\")\n         }\n     }\n \n-    pub fn expect_impl_item(self) -> P<ast::ImplItem> {\n+    pub fn expect_impl_item(self) -> ast::ImplItem {\n         match self {\n-            Annotatable::ImplItem(i) => i,\n+            Annotatable::ImplItem(i) => i.unwrap(),\n             _ => panic!(\"expected Item\")\n         }\n     }\n@@ -204,8 +204,8 @@ impl<F> IdentMacroExpander for F\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n         $me.make_expr().map(|e| {\n-            SmallVector::one(P(codemap::respan(\n-                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID))))\n+            SmallVector::one(codemap::respan(\n+                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID)))\n         })\n     }\n }\n@@ -223,7 +223,7 @@ pub trait MacResult {\n     }\n \n     /// Create zero or more impl items.\n-    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n         None\n     }\n \n@@ -236,7 +236,7 @@ pub trait MacResult {\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmts(self: Box<Self>) -> Option<SmallVector<P<ast::Stmt>>> {\n+    fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n         make_stmts_default!(self)\n     }\n \n@@ -273,8 +273,8 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n-    impl_items: SmallVector<P<ast::ImplItem>>,\n-    stmts: SmallVector<P<ast::Stmt>>,\n+    impl_items: SmallVector<ast::ImplItem>,\n+    stmts: SmallVector<ast::Stmt>,\n     ty: P<ast::Ty>,\n }\n \n@@ -287,11 +287,11 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n         self.impl_items\n     }\n \n-    fn make_stmts(self: Box<Self>) -> Option<SmallVector<P<ast::Stmt>>> {\n+    fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n         match self.stmts.as_ref().map_or(0, |s| s.len()) {\n             0 => make_stmts_default!(self),\n             _ => self.stmts,\n@@ -391,19 +391,19 @@ impl MacResult for DummyResult {\n         }\n     }\n \n-    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::ImplItem>>> {\n+    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<ast::ImplItem>> {\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n \n-    fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Stmt>>> {\n-        Some(SmallVector::one(P(\n+    fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n+        Some(SmallVector::one(\n             codemap::respan(self.span,\n                             ast::StmtKind::Expr(DummyResult::raw_expr(self.span),\n-                                                ast::DUMMY_NODE_ID)))))\n+                                                ast::DUMMY_NODE_ID))))\n     }\n }\n "}, {"sha": "38af8353aea843ca68c743f56baf741293b1a4ca", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -34,7 +34,7 @@ pub trait AstBuilder {\n                 idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n-                bindings: Vec<P<ast::TypeBinding>> )\n+                bindings: Vec<ast::TypeBinding> )\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n@@ -46,7 +46,7 @@ pub trait AstBuilder {\n                 ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n-                bindings: Vec<P<ast::TypeBinding>>)\n+                bindings: Vec<ast::TypeBinding>)\n                 -> (ast::QSelf, ast::Path);\n \n     // types\n@@ -88,23 +88,23 @@ pub trait AstBuilder {\n                     -> ast::LifetimeDef;\n \n     // statements\n-    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt>;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> P<ast::Stmt>;\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n                       ex: P<ast::Expr>)\n                       -> P<ast::Stmt>;\n-    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt>;\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n              expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 stmts: Vec<P<ast::Stmt>>,\n+                 stmts: Vec<ast::Stmt>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n@@ -206,9 +206,9 @@ pub trait AstBuilder {\n     fn lambda_expr_1(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n \n     fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n-                    blk: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr>;\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+                    blk: Vec<ast::Stmt>) -> P<ast::Expr>;\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr>;\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr>;\n \n     // items\n@@ -315,7 +315,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 mut idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n-                bindings: Vec<P<ast::TypeBinding>> )\n+                bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n@@ -360,7 +360,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  ident: ast::Ident,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n-                 bindings: Vec<P<ast::TypeBinding>>)\n+                 bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n         path.segments.push(ast::PathSegment {\n@@ -505,12 +505,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt> {\n-        P(respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID)))\n+    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n+        respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n-                ex: P<ast::Expr>) -> P<ast::Stmt> {\n+                ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n             let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n@@ -526,7 +526,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs: None,\n         });\n         let decl = respan(sp, ast::DeclKind::Local(local));\n-        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n+        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let_typed(&self,\n@@ -554,22 +554,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n              expr: Option<P<Expr>>) -> P<ast::Block> {\n         self.block_all(span, stmts, expr)\n     }\n \n-    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n+    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         let decl = respan(sp, ast::DeclKind::Item(item));\n-        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n+        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 stmts: Vec<P<ast::Stmt>>,\n+                 stmts: Vec<ast::Stmt>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                stmts: stmts,\n@@ -923,14 +923,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n-                    stmts: Vec<P<ast::Stmt>>)\n+                    stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<P<ast::Stmt>>) -> P<ast::Expr> {\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }"}, {"sha": "1ee108217c6b6a19481aede343e59c099d7e9f07", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -503,8 +503,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n }\n \n /// Expand a stmt\n-fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n-    let stmt = stmt.and_then(|stmt| stmt);\n+fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     let (mac, style, attrs) = match stmt.node {\n         StmtKind::Mac(mac, style, attrs) => (mac, style, attrs),\n         _ => return expand_non_macro_stmt(stmt, fld)\n@@ -514,7 +513,7 @@ fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     drop(attrs);\n \n     let maybe_new_items =\n-        expand_mac_invoc(mac.and_then(|m| m), stmt.span,\n+        expand_mac_invoc(mac.unwrap(), stmt.span,\n                          |r| r.make_stmts(),\n                          |stmts, mark| stmts.move_map(|m| mark_stmt(m, mark)),\n                          fld);\n@@ -535,15 +534,13 @@ fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            let new_stmt = stmt.map(|Spanned {node, span}| {\n-                Spanned {\n-                    node: match node {\n-                        StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n-                        _ => node /* might already have a semi */\n-                    },\n-                    span: span\n-                }\n-            });\n+            let new_stmt = Spanned {\n+                node: match stmt.node {\n+                    StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n+                    _ => stmt.node /* might already have a semi */\n+                },\n+                span: stmt.span\n+            };\n             fully_expanded.push(new_stmt);\n         }\n     }\n@@ -554,7 +551,7 @@ fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<P<Stmt>> {\n+                         -> SmallVector<Stmt> {\n     // is it a let?\n     match node {\n         StmtKind::Decl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n@@ -594,14 +591,14 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         attrs: fold::fold_thin_attrs(attrs, fld),\n                     }\n                 });\n-                SmallVector::one(P(Spanned {\n+                SmallVector::one(Spanned {\n                     node: StmtKind::Decl(P(Spanned {\n                             node: DeclKind::Local(rewritten_local),\n                             span: span\n                         }),\n                         node_id),\n                     span: stmt_span\n-                }))\n+                })\n             }\n             _ => {\n                 noop_fold_stmt(Spanned {\n@@ -919,24 +916,28 @@ fn expand_annotatable(a: Annotatable,\n         },\n \n         Annotatable::TraitItem(it) => match it.node {\n-            ast::TraitItemKind::Method(_, Some(_)) => SmallVector::one(it.map(|ti| ast::TraitItem {\n-                id: ti.id,\n-                ident: ti.ident,\n-                attrs: ti.attrs,\n-                node: match ti.node  {\n-                    ast::TraitItemKind::Method(sig, Some(body)) => {\n-                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                        ast::TraitItemKind::Method(sig, Some(body))\n-                    }\n-                    _ => unreachable!()\n-                },\n-                span: fld.new_span(ti.span)\n-            })),\n-            _ => fold::noop_fold_trait_item(it, fld)\n-        }.into_iter().map(Annotatable::TraitItem).collect(),\n+            ast::TraitItemKind::Method(_, Some(_)) => {\n+                let ti = it.unwrap();\n+                SmallVector::one(ast::TraitItem {\n+                    id: ti.id,\n+                    ident: ti.ident,\n+                    attrs: ti.attrs,\n+                    node: match ti.node  {\n+                        ast::TraitItemKind::Method(sig, Some(body)) => {\n+                            let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                            ast::TraitItemKind::Method(sig, Some(body))\n+                        }\n+                        _ => unreachable!()\n+                    },\n+                    span: fld.new_span(ti.span)\n+                })\n+            }\n+            _ => fold::noop_fold_trait_item(it.unwrap(), fld)\n+        }.into_iter().map(|ti| Annotatable::TraitItem(P(ti))).collect(),\n \n         Annotatable::ImplItem(ii) => {\n-            expand_impl_item(ii, fld).into_iter().map(Annotatable::ImplItem).collect()\n+            expand_impl_item(ii.unwrap(), fld).into_iter().\n+                map(|ii| Annotatable::ImplItem(P(ii))).collect()\n         }\n     };\n \n@@ -1052,10 +1053,10 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n-fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n-                 -> SmallVector<P<ast::ImplItem>> {\n+fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n+                 -> SmallVector<ast::ImplItem> {\n     match ii.node {\n-        ast::ImplItemKind::Method(..) => SmallVector::one(ii.map(|ii| ast::ImplItem {\n+        ast::ImplItemKind::Method(..) => SmallVector::one(ast::ImplItem {\n             id: ii.id,\n             ident: ii.ident,\n             attrs: ii.attrs,\n@@ -1068,12 +1069,12 @@ fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n                 _ => unreachable!()\n             },\n             span: fld.new_span(ii.span)\n-        })),\n+        }),\n         ast::ImplItemKind::Macro(_) => {\n-            let (span, mac) = ii.and_then(|ii| match ii.node {\n+            let (span, mac) = match ii.node {\n                 ast::ImplItemKind::Macro(mac) => (ii.span, mac),\n                 _ => unreachable!()\n-            });\n+            };\n             let maybe_new_items =\n                 expand_mac_invoc(mac, span,\n                                  |r| r.make_impl_items(),\n@@ -1198,7 +1199,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_item_kind(item, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n \n@@ -1210,13 +1211,13 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n-        expand_annotatable(Annotatable::TraitItem(i), self)\n+    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        expand_annotatable(Annotatable::TraitItem(P(i)), self)\n             .into_iter().map(|i| i.expect_trait_item()).collect()\n     }\n \n-    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n-        expand_annotatable(Annotatable::ImplItem(i), self)\n+    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        expand_annotatable(Annotatable::ImplItem(P(i)), self)\n             .into_iter().map(|i| i.expect_impl_item()).collect()\n     }\n \n@@ -1359,7 +1360,7 @@ fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(stmt: P<ast::Stmt>, m: Mrk) -> P<ast::Stmt> {\n+fn mark_stmt(stmt: ast::Stmt, m: Mrk) -> ast::Stmt {\n     Marker{mark:m}.fold_stmt(stmt)\n         .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n@@ -1371,7 +1372,7 @@ fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_impl_item(ii: P<ast::ImplItem>, m: Mrk) -> P<ast::ImplItem> {\n+fn mark_impl_item(ii: ast::ImplItem, m: Mrk) -> ast::ImplItem {\n     Marker{mark:m}.fold_impl_item(ii)\n         .expect_one(\"marking an impl item didn't return exactly one impl item\")\n }"}, {"sha": "d0eaa89e4ae5dc4f143c54e8d89406f9b12cf38e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -114,22 +114,24 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for P<ast::ImplItem> {\n+    impl ToTokens for ast::ImplItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtImplItem(self.clone())))]\n+            vec![TokenTree::Token(self.span,\n+                                  token::Interpolated(token::NtImplItem(P(self.clone()))))]\n         }\n     }\n \n-    impl ToTokens for P<ast::TraitItem> {\n+    impl ToTokens for ast::TraitItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, token::Interpolated(token::NtTraitItem(self.clone())))]\n+            vec![TokenTree::Token(self.span,\n+                                  token::Interpolated(token::NtTraitItem(P(self.clone()))))]\n         }\n     }\n \n-    impl ToTokens for P<ast::Stmt> {\n+    impl ToTokens for ast::Stmt {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             let mut tts = vec![\n-                TokenTree::Token(self.span, token::Interpolated(token::NtStmt(self.clone())))\n+                TokenTree::Token(self.span, token::Interpolated(token::NtStmt(P(self.clone()))))\n             ];\n \n             // Some statements require a trailing semicolon.\n@@ -312,7 +314,7 @@ pub mod rt {\n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: String) -> P<ast::Item>;\n         fn parse_expr(&self, s: String) -> P<ast::Expr>;\n-        fn parse_stmt(&self, s: String) -> P<ast::Stmt>;\n+        fn parse_stmt(&self, s: String) -> ast::Stmt;\n         fn parse_tts(&self, s: String) -> Vec<TokenTree>;\n     }\n \n@@ -326,7 +328,7 @@ pub mod rt {\n                 self.parse_sess()).expect(\"parse error\")\n         }\n \n-        fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n+        fn parse_stmt(&self, s: String) -> ast::Stmt {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n@@ -371,7 +373,7 @@ pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> {\n     panictry!(parser.parse_ty())\n }\n \n-pub fn parse_stmt_panic(parser: &mut Parser) -> Option<P<Stmt>> {\n+pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> {\n     panictry!(parser.parse_stmt())\n }\n \n@@ -710,7 +712,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     mk_token_path(cx, sp, name)\n }\n \n-fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<P<ast::Stmt>> {\n+fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stmt> {\n     match *tt {\n         TokenTree::Token(sp, SubstNt(ident, _)) => {\n             // tt.extend($ident.to_tokens(ext_cx))\n@@ -831,7 +833,7 @@ fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[TokenTree])\n     (cx_expr, tts)\n }\n \n-fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<P<ast::Stmt>> {\n+fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> {\n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n     // This causes every span in a token-tree quote to be attributed to the\n@@ -872,7 +874,7 @@ fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<P<ast::Stmt>> {\n     vec!(stmt_let_sp, stmt_let_tt)\n }\n \n-fn statements_mk_tts(cx: &ExtCtxt, tts: &[TokenTree], matcher: bool) -> Vec<P<ast::Stmt>> {\n+fn statements_mk_tts(cx: &ExtCtxt, tts: &[TokenTree], matcher: bool) -> Vec<ast::Stmt> {\n     let mut ss = Vec::new();\n     for tt in tts {\n         ss.extend(statements_mk_tt(cx, tt, matcher));"}, {"sha": "c4e1f32a52c235bb43bbb0953ddc6d495a812e1b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -523,7 +523,7 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n         \"stmt\" => match panictry!(p.parse_stmt()) {\n-            Some(s) => token::NtStmt(s),\n+            Some(s) => token::NtStmt(P(s)),\n             None => {\n                 p.fatal(\"expected a statement\").emit();\n                 panic!(FatalError);"}, {"sha": "c641c478a6bba6482398a3656346ae5b2f463aa0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -87,7 +87,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n     }\n \n     fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<P<ast::ImplItem>>> {\n+                       -> Option<SmallVector<ast::ImplItem>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -101,7 +101,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n     }\n \n     fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n-                 -> Option<SmallVector<P<ast::Stmt>>> {\n+                 -> Option<SmallVector<ast::Stmt>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();"}, {"sha": "d347899ca2e7a5f043bf44d7412eec6d801a1e92", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -55,7 +55,7 @@ pub trait Folder : Sized {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n+    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n         noop_fold_foreign_item(ni, self)\n     }\n \n@@ -75,11 +75,11 @@ pub trait Folder : Sized {\n         noop_fold_item_kind(i, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n+    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVector<TraitItem> {\n         noop_fold_trait_item(i, self)\n     }\n \n-    fn fold_impl_item(&mut self, i: P<ImplItem>) -> SmallVector<P<ImplItem>> {\n+    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVector<ImplItem> {\n         noop_fold_impl_item(i, self)\n     }\n \n@@ -91,8 +91,8 @@ pub trait Folder : Sized {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: P<Stmt>) -> SmallVector<P<Stmt>> {\n-        s.and_then(|s| noop_fold_stmt(s, self))\n+    fn fold_stmt(&mut self, s: Stmt) -> SmallVector<Stmt> {\n+        noop_fold_stmt(s, self)\n     }\n \n     fn fold_arm(&mut self, a: Arm) -> Arm {\n@@ -123,7 +123,7 @@ pub trait Folder : Sized {\n         noop_fold_ty(t, self)\n     }\n \n-    fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n+    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n         noop_fold_ty_binding(t, self)\n     }\n \n@@ -135,7 +135,7 @@ pub trait Folder : Sized {\n         noop_fold_foreign_mod(nm, self)\n     }\n \n-    fn fold_variant(&mut self, v: P<Variant>) -> P<Variant> {\n+    fn fold_variant(&mut self, v: Variant) -> Variant {\n         noop_fold_variant(v, self)\n     }\n \n@@ -367,13 +367,13 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>\n     })\n }\n \n-pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n-    b.map(|TypeBinding { id, ident, ty, span }| TypeBinding {\n-        id: fld.new_id(id),\n-        ident: ident,\n-        ty: fld.fold_ty(ty),\n-        span: fld.new_span(span),\n-    })\n+pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n+    TypeBinding {\n+        id: fld.new_id(b.id),\n+        ident: b.ident,\n+        ty: fld.fold_ty(b.ty),\n+        span: fld.new_span(b.span),\n+    }\n }\n \n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n@@ -434,16 +434,16 @@ pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n     }\n }\n \n-pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n-    v.map(|Spanned {node: Variant_ {name, attrs, data, disr_expr}, span}| Spanned {\n+pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n+    Spanned {\n         node: Variant_ {\n-            name: name,\n-            attrs: fold_attrs(attrs, fld),\n-            data: fld.fold_variant_data(data),\n-            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+            name: v.node.name,\n+            attrs: fold_attrs(v.node.attrs, fld),\n+            data: fld.fold_variant_data(v.node.data),\n+            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n         },\n-        span: fld.new_span(span),\n-    })\n+        span: fld.new_span(v.span),\n+    }\n }\n \n pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n@@ -653,11 +653,11 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n-            token::NtStmt(fld.fold_stmt(stmt)\n+            token::NtStmt(stmt.map(|stmt| fld.fold_stmt(stmt)\n                           // this is probably okay, because the only folds likely\n                           // to peek inside interpolated nodes will be renamings/markings,\n                           // which map single items to single items\n-                          .expect_one(\"expected fold to produce exactly one statement\")),\n+                          .expect_one(\"expected fold to produce exactly one statement\"))),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n@@ -669,11 +669,11 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n         token::NtImplItem(arm) =>\n-            token::NtImplItem(fld.fold_impl_item(arm)\n-                              .expect_one(\"expected fold to produce exactly one item\")),\n+            token::NtImplItem(arm.map(|arm| fld.fold_impl_item(arm)\n+                              .expect_one(\"expected fold to produce exactly one item\"))),\n         token::NtTraitItem(arm) =>\n-            token::NtTraitItem(fld.fold_trait_item(arm)\n-                               .expect_one(\"expected fold to produce exactly one item\")),\n+            token::NtTraitItem(arm.map(|arm| fld.fold_trait_item(arm)\n+                               .expect_one(\"expected fold to produce exactly one item\"))),\n         token::NtGenerics(generics) => token::NtGenerics(fld.fold_generics(generics)),\n         token::NtWhereClause(where_clause) =>\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n@@ -962,13 +962,13 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n     }\n }\n \n-pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n-                                       -> SmallVector<P<TraitItem>> {\n-    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n-        id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n+pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n+                                       -> SmallVector<TraitItem> {\n+    SmallVector::one(TraitItem {\n+        id: folder.new_id(i.id),\n+        ident: folder.fold_ident(i.ident),\n+        attrs: fold_attrs(i.attrs, folder),\n+        node: match i.node {\n             TraitItemKind::Const(ty, default) => {\n                 TraitItemKind::Const(folder.fold_ty(ty),\n                                default.map(|x| folder.fold_expr(x)))\n@@ -982,18 +982,18 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n                               default.map(|x| folder.fold_ty(x)))\n             }\n         },\n-        span: folder.new_span(span)\n-    }))\n+        span: folder.new_span(i.span)\n+    })\n }\n \n-pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n-                                      -> SmallVector<P<ImplItem>> {\n-    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n-        id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n-        attrs: fold_attrs(attrs, folder),\n-        vis: vis,\n-        node: match node  {\n+pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n+                                      -> SmallVector<ImplItem> {\n+    SmallVector::one(ImplItem {\n+        id: folder.new_id(i.id),\n+        ident: folder.fold_ident(i.ident),\n+        attrs: fold_attrs(i.attrs, folder),\n+        vis: i.vis,\n+        node: match i.node  {\n             ast::ImplItemKind::Const(ty, expr) => {\n                 ast::ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n             }\n@@ -1004,8 +1004,8 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n             ast::ImplItemKind::Type(ty) => ast::ImplItemKind::Type(folder.fold_ty(ty)),\n             ast::ImplItemKind::Macro(mac) => ast::ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n-        span: folder.new_span(span)\n-    }))\n+        span: folder.new_span(i.span)\n+    })\n }\n \n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n@@ -1086,22 +1086,22 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n     }\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n-    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n-        id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n+pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n+    ForeignItem {\n+        id: folder.new_id(ni.id),\n+        ident: folder.fold_ident(ni.ident),\n+        attrs: fold_attrs(ni.attrs, folder),\n+        node: match ni.node {\n             ForeignItemKind::Fn(fdec, generics) => {\n                 ForeignItemKind::Fn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n             }\n             ForeignItemKind::Static(t, m) => {\n                 ForeignItemKind::Static(folder.fold_ty(t), m)\n             }\n         },\n-        vis: vis,\n-        span: folder.new_span(span)\n-    })\n+        vis: ni.vis,\n+        span: folder.new_span(ni.span)\n+    }\n }\n \n pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n@@ -1344,44 +1344,44 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n }\n \n pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n-                                 -> SmallVector<P<Stmt>> {\n+                                 -> SmallVector<Stmt> {\n     let span = folder.new_span(span);\n     match node {\n         StmtKind::Decl(d, id) => {\n             let id = folder.new_id(id);\n-            folder.fold_decl(d).into_iter().map(|d| P(Spanned {\n+            folder.fold_decl(d).into_iter().map(|d| Spanned {\n                 node: StmtKind::Decl(d, id),\n                 span: span\n-            })).collect()\n+            }).collect()\n         }\n         StmtKind::Expr(e, id) => {\n             let id = folder.new_id(id);\n             if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(P(Spanned {\n+                SmallVector::one(Spanned {\n                     node: StmtKind::Expr(e, id),\n                     span: span\n-                }))\n+                })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n         StmtKind::Semi(e, id) => {\n             let id = folder.new_id(id);\n             if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(P(Spanned {\n+                SmallVector::one(Spanned {\n                     node: StmtKind::Semi(e, id),\n                     span: span\n-                }))\n+                })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n+        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(Spanned {\n             node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n                                 semi,\n                                 attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n             span: span\n-        }))\n+        })\n     }\n }\n "}, {"sha": "02844c35408df0ad804cf9a7fb5a6e6975f1bbdd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -144,7 +144,7 @@ pub fn parse_stmt_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Option<P<ast::Stmt>> {\n+                                  -> Option<ast::Stmt> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -866,7 +866,7 @@ mod tests {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   Some(P(Spanned{\n+                   Some(Spanned{\n                        node: ast::StmtKind::Expr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n@@ -882,7 +882,7 @@ mod tests {\n                            span: sp(0,1),\n                            attrs: None}),\n                                            ast::DUMMY_NODE_ID),\n-                       span: sp(0,1)})))\n+                       span: sp(0,1)}))\n \n     }\n \n@@ -957,7 +957,7 @@ mod tests {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        stmts: vec!(P(Spanned{\n+                                        stmts: vec!(Spanned{\n                                             node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprKind::Path(None,\n@@ -977,7 +977,7 @@ mod tests {\n                                                 span: sp(17,18),\n                                                 attrs: None,}),\n                                                 ast::DUMMY_NODE_ID),\n-                                            span: sp(17,19)})),\n+                                            span: sp(17,19)}),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::BlockCheckMode::Default, // no idea"}, {"sha": "0d5bdfbbc3bb89ac4be733de5c0eb35256476e27", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -179,6 +179,19 @@ macro_rules! maybe_whole {\n             }\n         }\n     );\n+    (no_clone_from_p $p:expr, $constructor:ident) => (\n+        {\n+            let found = match ($p).token {\n+                token::Interpolated(token::$constructor(_)) => {\n+                    Some(($p).bump_and_get())\n+                }\n+                _ => None\n+            };\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return Ok(x.unwrap());\n+            }\n+        }\n+    );\n     (deref $p:expr, $constructor:ident) => (\n         {\n             let found = match ($p).token {\n@@ -1174,13 +1187,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<P<TraitItem>>> {\n+    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(token::Brace),\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n-            |p| -> PResult<'a, P<TraitItem>> {\n-            maybe_whole!(no_clone p, NtTraitItem);\n+            |p| -> PResult<'a, TraitItem> {\n+            maybe_whole!(no_clone_from_p p, NtTraitItem);\n             let mut attrs = try!(p.parse_outer_attributes());\n             let lo = p.span.lo;\n \n@@ -1249,13 +1262,13 @@ impl<'a> Parser<'a> {\n                 (ident, ast::TraitItemKind::Method(sig, body))\n             };\n \n-            Ok(P(TraitItem {\n+            Ok(TraitItem {\n                 id: ast::DUMMY_NODE_ID,\n                 ident: name,\n                 attrs: attrs,\n                 node: node,\n                 span: mk_sp(lo, p.last_span.hi),\n-            }))\n+            })\n         })\n     }\n \n@@ -3661,8 +3674,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement. may include decl.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<P<Stmt>>> {\n-        Ok(try!(self.parse_stmt_()).map(P))\n+    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+        Ok(try!(self.parse_stmt_()))\n     }\n \n     fn parse_stmt_(&mut self) -> PResult<'a, Option<Stmt>> {\n@@ -3846,10 +3859,10 @@ impl<'a> Parser<'a> {\n                     // expr depending on whether a semicolon follows\n                     match self.token {\n                         token::Semi => {\n-                            stmts.push(P(Spanned {\n+                            stmts.push(Spanned {\n                                 node: StmtKind::Mac(mac, MacStmtStyle::Semicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n-                            }));\n+                            });\n                             self.bump();\n                         }\n                         _ => {\n@@ -3871,10 +3884,10 @@ impl<'a> Parser<'a> {\n                     // statement macro; might be an expr\n                     match self.token {\n                         token::Semi => {\n-                            stmts.push(P(Spanned {\n+                            stmts.push(Spanned {\n                                 node: StmtKind::Mac(m, MacStmtStyle::Semicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n-                            }));\n+                            });\n                             self.bump();\n                         }\n                         token::CloseDelim(token::Brace) => {\n@@ -3885,10 +3898,10 @@ impl<'a> Parser<'a> {\n                                                          attrs));\n                         }\n                         _ => {\n-                            stmts.push(P(Spanned {\n+                            stmts.push(Spanned {\n                                 node: StmtKind::Mac(m, style, attrs),\n                                 span: span\n-                            }));\n+                            });\n                         }\n                     }\n                 }\n@@ -3899,10 +3912,10 @@ impl<'a> Parser<'a> {\n                         hi = self.last_span.hi;\n                     }\n \n-                    stmts.push(P(Spanned {\n+                    stmts.push(Spanned {\n                         node: node,\n                         span: mk_sp(span.lo, hi)\n-                    }));\n+                    });\n                 }\n             }\n         }\n@@ -3920,7 +3933,7 @@ impl<'a> Parser<'a> {\n             &mut self,\n             e: P<Expr>,\n             span: Span,\n-            stmts: &mut Vec<P<Stmt>>,\n+            stmts: &mut Vec<Stmt>,\n             last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&*e) {\n@@ -3937,17 +3950,17 @@ impl<'a> Parser<'a> {\n                     hi: self.last_span.hi,\n                     expn_id: span.expn_id,\n                 };\n-                stmts.push(P(Spanned {\n+                stmts.push(Spanned {\n                     node: StmtKind::Semi(e, ast::DUMMY_NODE_ID),\n                     span: span_with_semi,\n-                }));\n+                });\n             }\n             token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n-                stmts.push(P(Spanned {\n+                stmts.push(Spanned {\n                     node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n                     span: span\n-                }));\n+                });\n             }\n         }\n         Ok(())\n@@ -4080,7 +4093,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_generic_values_after_lt(&mut self) -> PResult<'a, (Vec<ast::Lifetime>,\n                                                             Vec<P<Ty>>,\n-                                                            Vec<P<TypeBinding>>)> {\n+                                                            Vec<TypeBinding>)> {\n         let span_lo = self.span.lo;\n         let lifetimes = try!(self.parse_lifetimes(token::Comma));\n \n@@ -4146,11 +4159,11 @@ impl<'a> Parser<'a> {\n                 let ty = try!(p.parse_ty());\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);\n-                return Ok(P(TypeBinding{id: ast::DUMMY_NODE_ID,\n+                return Ok(TypeBinding{id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     ty: ty,\n                     span: span,\n-                }));\n+                });\n             }\n         ));\n         Ok((lifetimes, types.into_vec(), bindings.into_vec()))\n@@ -4647,8 +4660,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an impl item.\n-    pub fn parse_impl_item(&mut self) -> PResult<'a, P<ImplItem>> {\n-        maybe_whole!(no_clone self, NtImplItem);\n+    pub fn parse_impl_item(&mut self) -> PResult<'a, ImplItem> {\n+        maybe_whole!(no_clone_from_p self, NtImplItem);\n \n         let mut attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n@@ -4674,14 +4687,14 @@ impl<'a> Parser<'a> {\n             (name, node)\n         };\n \n-        Ok(P(ImplItem {\n+        Ok(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, self.last_span.hi),\n             ident: name,\n             vis: vis,\n             attrs: attrs,\n             node: node\n-        }))\n+        })\n     }\n \n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n@@ -5243,27 +5256,27 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: BytePos,\n-                             attrs: Vec<Attribute>) -> PResult<'a, P<ForeignItem>> {\n+                             attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n         try!(self.expect_keyword(keywords::Fn));\n \n         let (ident, mut generics) = try!(self.parse_fn_header());\n         let decl = try!(self.parse_fn_decl(true));\n         generics.where_clause = try!(self.parse_where_clause());\n         let hi = self.span.hi;\n         try!(self.expect(&token::Semi));\n-        Ok(P(ast::ForeignItem {\n+        Ok(ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Fn(decl, generics),\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             vis: vis\n-        }))\n+        })\n     }\n \n     /// Parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: BytePos,\n-                                 attrs: Vec<Attribute>) -> PResult<'a, P<ForeignItem>> {\n+                                 attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n         try!(self.expect_keyword(keywords::Static));\n         let mutbl = self.eat_keyword(keywords::Mut);\n \n@@ -5272,14 +5285,14 @@ impl<'a> Parser<'a> {\n         let ty = try!(self.parse_ty_sum());\n         let hi = self.span.hi;\n         try!(self.expect(&token::Semi));\n-        Ok(P(ForeignItem {\n+        Ok(ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Static(ty, mutbl),\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             vis: vis\n-        }))\n+        })\n     }\n \n     /// Parse extern crate links\n@@ -5405,7 +5418,7 @@ impl<'a> Parser<'a> {\n                 data: struct_def,\n                 disr_expr: disr_expr,\n             };\n-            variants.push(P(spanned(vlo, self.last_span.hi, vr)));\n+            variants.push(spanned(vlo, self.last_span.hi, vr));\n \n             if !self.eat(&token::Comma) { break; }\n         }\n@@ -5729,7 +5742,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a foreign item.\n-    fn parse_foreign_item(&mut self) -> PResult<'a, Option<P<ForeignItem>>> {\n+    fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n         let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let visibility = try!(self.parse_visibility());"}, {"sha": "7e58fd9c3a1bff349c365675c851049981fd4d79", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -939,7 +939,7 @@ impl<'a> State<'a> {\n                              attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &nmod.items {\n-            try!(self.print_foreign_item(&**item));\n+            try!(self.print_foreign_item(item));\n         }\n         Ok(())\n     }\n@@ -1370,15 +1370,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_variants(&mut self,\n-                          variants: &[P<ast::Variant>],\n+                          variants: &[ast::Variant],\n                           span: codemap::Span) -> io::Result<()> {\n         try!(self.bopen());\n         for v in variants {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(&v.node.attrs));\n             try!(self.ibox(INDENT_UNIT));\n-            try!(self.print_variant(&**v));\n+            try!(self.print_variant(v));\n             try!(word(&mut self.s, \",\"));\n             try!(self.end());\n             try!(self.maybe_print_trailing_comment(v.span, None));\n@@ -1686,7 +1686,7 @@ impl<'a> State<'a> {\n         try!(self.print_inner_attributes(attrs));\n \n         for st in &blk.stmts {\n-            try!(self.print_stmt(&**st));\n+            try!(self.print_stmt(st));\n         }\n         match blk.expr {\n             Some(ref expr) => {"}, {"sha": "27f5700cad58a168b4cd783283cc5a98028f4a8a", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -65,6 +65,10 @@ impl<T: 'static> P<T> {\n     {\n         f(*self.ptr)\n     }\n+    /// Equivalent to and_then(|x| x)\n+    pub fn unwrap(self) -> T {\n+        *self.ptr\n+    }\n \n     /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n     pub fn map<F>(mut self, f: F) -> P<T> where"}, {"sha": "b0f4c2dcba508bdaded40d320aeb835a9338531e", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -64,7 +64,7 @@ pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n }\n \n /// Parse a string, return a stmt\n-pub fn string_to_stmt(source_str : String) -> Option<P<ast::Stmt>> {\n+pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n     let ps = ParseSess::new();\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_stmt()"}, {"sha": "6439e9aa498698c580c962c1769aadc7fcc6bc18", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -141,7 +141,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n fn stmt_let_undescore(cx: &mut ExtCtxt,\n                       sp: Span,\n-                      expr: P<ast::Expr>) -> P<ast::Stmt> {\n+                      expr: P<ast::Expr>) -> ast::Stmt {\n     let local = P(ast::Local {\n         pat: cx.pat_wild(sp),\n         ty: None,\n@@ -151,5 +151,5 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         attrs: None,\n     });\n     let decl = respan(sp, ast::DeclKind::Local(local));\n-    P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n+    respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n }"}, {"sha": "160d230f86be85ace33a77eecd26e71beec0d14f", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -312,7 +312,7 @@ pub enum SubstructureFields<'a> {\n     /// variants for the enum itself, and the third component is a list of\n     /// `Ident`s bound to the variant index values for each of the actual\n     /// input `Self` arguments.\n-    EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [ast::Variant], &'a [Ident]),\n \n     /// A static method where `Self` is a struct.\n     StaticStruct(&'a ast::VariantData, StaticFields),\n@@ -466,12 +466,12 @@ impl<'a> TraitDef<'a> {\n                            type_ident: Ident,\n                            generics: &Generics,\n                            field_tys: Vec<P<ast::Ty>>,\n-                           methods: Vec<P<ast::ImplItem>>) -> P<ast::Item> {\n+                           methods: Vec<ast::ImplItem>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         // Transform associated types from `deriving::ty::Ty` into `ast::ImplItem`\n         let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n-            P(ast::ImplItem {\n+            ast::ImplItem {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident: ident,\n@@ -482,7 +482,7 @@ impl<'a> TraitDef<'a> {\n                     type_ident,\n                     generics\n                 )),\n-            })\n+            }\n         });\n \n         let Generics { mut lifetimes, ty_params, mut where_clause } =\n@@ -857,7 +857,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: P<Expr>) -> P<ast::ImplItem> {\n+                     body: P<Expr>) -> ast::ImplItem {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -888,7 +888,7 @@ impl<'a> MethodDef<'a> {\n         };\n \n         // Create the method.\n-        P(ast::ImplItem {\n+        ast::ImplItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n             span: trait_.span,\n@@ -902,7 +902,7 @@ impl<'a> MethodDef<'a> {\n                 constness: ast::Constness::NotConst,\n                 decl: fn_decl\n             }, body_block)\n-        })\n+        }\n     }\n \n     /// ```ignore\n@@ -1139,7 +1139,7 @@ impl<'a> MethodDef<'a> {\n                 let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(\n                         cx, type_ident,\n-                        &**variant,\n+                        variant,\n                         self_arg_name,\n                         ast::Mutability::Immutable);\n                     (cx.pat(sp, ast::PatRegion(p, ast::Mutability::Immutable)), idents)\n@@ -1209,7 +1209,7 @@ impl<'a> MethodDef<'a> {\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n                 let substructure = EnumMatching(index,\n-                                                &**variant,\n+                                                variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n                     cx, trait_, type_ident, &self_args[..], nonself_args,\n@@ -1250,7 +1250,7 @@ impl<'a> MethodDef<'a> {\n             // let __self2_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&__arg2) } as i32;\n             // ```\n-            let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n+            let mut index_let_stmts: Vec<ast::Stmt> = Vec::new();\n \n             //We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ..."}, {"sha": "fd68ba7342798bc9e16613f4877591aa5f8cbfdc", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Wrap the declaration in a block so that it forms a single expression.\n         ecx.expr_block(ecx.block(sp,\n-            vec![P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))],\n+            vec![respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))],\n             Some(ecx.expr_ident(sp, name))))\n     }\n "}, {"sha": "3516f566e8a1ffda8f157786da1479d6def7eb47", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -74,7 +74,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Impl(_, _, _, _, _, mut items) => {\n-                        Annotatable::ImplItem(items.pop().expect(\"impl method not found\"))\n+                        Annotatable::ImplItem(P(items.pop().expect(\"impl method not found\")))\n                     }\n                     _ => unreachable!(\"impl parsed to something other than impl\")\n                 }\n@@ -84,7 +84,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n                     ItemKind::Trait(_, _, _, mut items) => {\n-                        Annotatable::TraitItem(items.pop().expect(\"trait method not found\"))\n+                        Annotatable::TraitItem(P(items.pop().expect(\"trait method not found\")))\n                     }\n                     _ => unreachable!(\"trait parsed to something other than trait\")\n                 }"}, {"sha": "ed971faf8c6a19a7bd3c75475c735a6a5e5fee83", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -59,7 +59,7 @@ fn expr<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, P<ast::Expr>> {\n     })\n }\n \n-fn stmt<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, P<ast::Stmt>> {\n+fn stmt<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, ast::Stmt> {\n     with_error_checking_parse(s.to_string(), ps, |p| {\n         p.parse_stmt().map(|s| s.unwrap())\n     })"}, {"sha": "0bb3e610020a118b925154bc2340b7131fb6743d", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -52,7 +52,7 @@ fn main() {\n \n     let twenty: u16 = 20;\n     let stmt = quote_stmt!(cx, let x = $twenty;).unwrap();\n-    check!(stmt_to_string, stmt, *quote_stmt!(cx, $stmt).unwrap(); \"let x = 20u16;\");\n+    check!(stmt_to_string, stmt, quote_stmt!(cx, $stmt).unwrap(); \"let x = 20u16;\");\n \n     let pat = quote_pat!(cx, Some(_));\n     check!(pat_to_string, pat, *quote_pat!(cx, $pat); \"Some(_)\");"}, {"sha": "4397da35d7a34f8794048c3f26568f7527984b7c", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7640aa2aaad857bbc9f9a1002f8e1aaf520752e/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=c7640aa2aaad857bbc9f9a1002f8e1aaf520752e", "patch": "@@ -26,7 +26,7 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let a: P<syntax::ast::Expr> = quote_expr!(cx, 1 + 2);\n     let _b: Option<P<syntax::ast::Item>> = quote_item!(cx, static foo : isize = $e_toks; );\n     let _c: P<syntax::ast::Pat> = quote_pat!(cx, (x, 1 .. 4, *) );\n-    let _d: Option<P<syntax::ast::Stmt>> = quote_stmt!(cx, let x = $a; );\n+    let _d: Option<syntax::ast::Stmt> = quote_stmt!(cx, let x = $a; );\n     let _d: syntax::ast::Arm = quote_arm!(cx, (ref x, ref y) = (x, y) );\n     let _e: P<syntax::ast::Expr> = quote_expr!(cx, match foo { $p_toks => 10 } );\n "}]}