{"sha": "c29085761b0bf5b9add4bd008268651feae495bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTA4NTc2MWIwYmY1YjlhZGQ0YmQwMDgyNjg2NTFmZWFlNDk1YmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-13T19:50:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-13T19:50:13Z"}, "message": "Auto merge of #48735 - 1011X:master, r=alexcrichton\n\nMove ascii::escape_default to libcore\n\nAs requested in #46409, the `ascii::escape_default` method has been added to the core library. All I did was copy over the `std::ascii` module file, remove the (redundant) `AsciiExt` trait, and change some of the documentation to match. None of the tests were changed.\n\nI wasn't sure how to handle the annotations. For `EscapeDefault` and `escape_default()`, I changed them to `#[unstable(feature = \"core_ascii\", issue = \"46409\")]`. Is that alright? Or should I leave them as they were?", "tree": {"sha": "8ec81769ef8db276645bebb7c7788d9e3527f740", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ec81769ef8db276645bebb7c7788d9e3527f740"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c29085761b0bf5b9add4bd008268651feae495bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c29085761b0bf5b9add4bd008268651feae495bd", "html_url": "https://github.com/rust-lang/rust/commit/c29085761b0bf5b9add4bd008268651feae495bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c29085761b0bf5b9add4bd008268651feae495bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "html_url": "https://github.com/rust-lang/rust/commit/8c4ff22a2d745097197c659ef9e3b04b8ceeb070"}, {"sha": "1a16271d1cc64e89f6c0acc7803b9d6fa25bf131", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a16271d1cc64e89f6c0acc7803b9d6fa25bf131", "html_url": "https://github.com/rust-lang/rust/commit/1a16271d1cc64e89f6c0acc7803b9d6fa25bf131"}], "stats": {"total": 989, "additions": 512, "deletions": 477}, "files": [{"sha": "2c4bccebceb95247d45a42ffbba8130acc351df1", "filename": "src/libcore/ascii.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=c29085761b0bf5b9add4bd008268651feae495bd", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on ASCII strings and characters.\n+//!\n+//! Most string operations in Rust act on UTF-8 strings. However, at times it\n+//! makes more sense to only consider the ASCII character set for a specific\n+//! operation.\n+//!\n+//! The [`escape_default`] function provides an iterator over the bytes of an\n+//! escaped version of the character given.\n+//!\n+//! [`escape_default`]: fn.escape_default.html\n+\n+#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+\n+use fmt;\n+use ops::Range;\n+use iter::FusedIterator;\n+\n+/// An iterator over the escaped version of a byte.\n+///\n+/// This `struct` is created by the [`escape_default`] function. See its\n+/// documentation for more.\n+///\n+/// [`escape_default`]: fn.escape_default.html\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n+}\n+\n+/// Returns an iterator that produces an escaped version of a `u8`.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// * Tab is escaped as `\\t`.\n+/// * Carriage return is escaped as `\\r`.\n+/// * Line feed is escaped as `\\n`.\n+/// * Single quote is escaped as `\\'`.\n+/// * Double quote is escaped as `\\\"`.\n+/// * Backslash is escaped as `\\\\`.\n+/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n+///   inclusive is not escaped.\n+/// * Any other chars are given hex escapes of the form '\\xNN'.\n+/// * Unicode escapes are never generated by this function.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ascii;\n+///\n+/// let escaped = ascii::escape_default(b'0').next().unwrap();\n+/// assert_eq!(b'0', escaped);\n+///\n+/// let mut escaped = ascii::escape_default(b'\\t');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b't', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\r');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'r', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\n');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'n', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\'');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\'', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\"');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\"', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\\\');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\x9d');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'x', escaped.next().unwrap());\n+/// assert_eq!(b'9', escaped.next().unwrap());\n+/// assert_eq!(b'd', escaped.next().unwrap());\n+/// ```\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub fn escape_default(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: 0..len, data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeDefault {}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EscapeDefault { .. }\")\n+    }\n+}"}, {"sha": "cefcc5ff03f0fea030c742af1378dfff4f4a239a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c29085761b0bf5b9add4bd008268651feae495bd", "patch": "@@ -167,6 +167,7 @@ pub mod borrow;\n \n pub mod any;\n pub mod array;\n+pub mod ascii;\n pub mod sync;\n pub mod cell;\n pub mod char;"}, {"sha": "4d43067ad2cf3e7b4467581b0d2e190af19d0a59", "filename": "src/libcore/tests/ascii.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=c29085761b0bf5b9add4bd008268651feae495bd", "patch": "@@ -0,0 +1,360 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::char::from_u32;\n+use std::ascii::AsciiExt;\n+\n+#[test]\n+fn test_is_ascii() {\n+    assert!(b\"\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n+\n+    assert!(\"\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n+}\n+\n+#[test]\n+fn test_to_ascii_uppercase() {\n+    assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+    assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+                   (from_u32(upper).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_to_ascii_lowercase() {\n+    assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+                   (from_u32(lower).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_make_ascii_lower_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_lowercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'A', b'a');\n+    test!(b'a', b'a');\n+    test!(b'!', b'!');\n+    test!('A', 'a');\n+    test!('\u00c0', '\u00c0');\n+    test!('a', 'a');\n+    test!('!', '!');\n+    test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+    test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+}\n+\n+\n+#[test]\n+fn test_make_ascii_upper_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_uppercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'a', b'A');\n+    test!(b'A', b'A');\n+    test!(b'!', b'!');\n+    test!('a', 'A');\n+    test!('\u00e0', '\u00e0');\n+    test!('A', 'A');\n+    test!('!', '!');\n+    test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+    test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+    let mut x = \"Hello\".to_string();\n+    x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+    assert_eq!(x, \"HELlo\")\n+}\n+\n+#[test]\n+fn test_eq_ignore_ascii_case() {\n+    assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+    assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+    assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+    assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+    assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n+                &from_u32(lower).unwrap().to_string()));\n+    }\n+}\n+\n+#[test]\n+fn inference_works() {\n+    let x = \"a\".to_string();\n+    x.eq_ignore_ascii_case(\"A\");\n+}\n+\n+// Shorthands used by the is_ascii_* tests.\n+macro_rules! assert_all {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if !b.$what() {\n+                    panic!(\"expected {}({}) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if !b.$what() {\n+                    panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            assert!($str.$what());\n+            assert!($str.as_bytes().$what());\n+        )+\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+}\n+macro_rules! assert_none {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}({}) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+        )*\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+}\n+\n+#[test]\n+fn test_is_ascii_alphabetic() {\n+    assert_all!(is_ascii_alphabetic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_alphabetic,\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_uppercase() {\n+    assert_all!(is_ascii_uppercase,\n+        \"\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_uppercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_lowercase() {\n+    assert_all!(is_ascii_lowercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+    );\n+    assert_none!(is_ascii_lowercase,\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_alphanumeric() {\n+    assert_all!(is_ascii_alphanumeric,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_alphanumeric,\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_digit() {\n+    assert_all!(is_ascii_digit,\n+        \"\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_digit,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_hexdigit() {\n+    assert_all!(is_ascii_hexdigit,\n+        \"\",\n+        \"0123456789\",\n+        \"abcdefABCDEF\",\n+    );\n+    assert_none!(is_ascii_hexdigit,\n+        \"ghijklmnopqrstuvwxyz\",\n+        \"GHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_punctuation() {\n+    assert_all!(is_ascii_punctuation,\n+        \"\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_punctuation,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_graphic() {\n+    assert_all!(is_ascii_graphic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_graphic,\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_whitespace() {\n+    assert_all!(is_ascii_whitespace,\n+        \"\",\n+        \" \\t\\n\\x0c\\r\",\n+    );\n+    assert_none!(is_ascii_whitespace,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x0b\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_control() {\n+    assert_all!(is_ascii_control,\n+        \"\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+    assert_none!(is_ascii_control,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \",\n+    );\n+}"}, {"sha": "5bd5bca19c4e561a38b7b72b720816862d78e2ac", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=c29085761b0bf5b9add4bd008268651feae495bd", "patch": "@@ -10,6 +10,7 @@\n \n #![deny(warnings)]\n \n+#![feature(ascii_ctype)]\n #![feature(box_syntax)]\n #![feature(core_float)]\n #![feature(core_private_bignum)]\n@@ -54,6 +55,7 @@ extern crate rand;\n \n mod any;\n mod array;\n+mod ascii;\n mod atomic;\n mod cell;\n mod char;"}, {"sha": "0837ff91c142d658aa5b68c967c3bdb20a9e9dce", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 477, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c29085761b0bf5b9add4bd008268651feae495bd/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=c29085761b0bf5b9add4bd008268651feae495bd", "patch": "@@ -26,9 +26,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n-use ops::Range;\n-use iter::FusedIterator;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::ascii::{EscapeDefault, escape_default};\n \n /// Extension methods for ASCII-subset only operations.\n ///\n@@ -483,477 +482,3 @@ impl AsciiExt for str {\n         self.bytes().all(|b| b.is_ascii_control())\n     }\n }\n-\n-/// An iterator over the escaped version of a byte.\n-///\n-/// This `struct` is created by the [`escape_default`] function. See its\n-/// documentation for more.\n-///\n-/// [`escape_default`]: fn.escape_default.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeDefault {\n-    range: Range<usize>,\n-    data: [u8; 4],\n-}\n-\n-/// Returns an iterator that produces an escaped version of a `u8`.\n-///\n-/// The default is chosen with a bias toward producing literals that are\n-/// legal in a variety of languages, including C++11 and similar C-family\n-/// languages. The exact rules are:\n-///\n-/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n-/// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex escapes of the form '\\xNN'.\n-/// - Unicode escapes are never generated by this function.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ascii;\n-///\n-/// let escaped = ascii::escape_default(b'0').next().unwrap();\n-/// assert_eq!(b'0', escaped);\n-///\n-/// let mut escaped = ascii::escape_default(b'\\t');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b't', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\r');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'r', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\n');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'n', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\'');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\\'', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\"');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\"', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\\\');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\x9d');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'x', escaped.next().unwrap());\n-/// assert_eq!(b'9', escaped.next().unwrap());\n-/// assert_eq!(b'd', escaped.next().unwrap());\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn escape_default(c: u8) -> EscapeDefault {\n-    let (data, len) = match c {\n-        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n-        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n-        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n-        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n-        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n-        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n-        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n-    };\n-\n-    return EscapeDefault { range: (0.. len), data: data };\n-\n-    fn hexify(b: u8) -> u8 {\n-        match b {\n-            0 ... 9 => b'0' + b,\n-            _ => b'a' + b - 10,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for EscapeDefault {\n-    type Item = u8;\n-    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl DoubleEndedIterator for EscapeDefault {\n-    fn next_back(&mut self) -> Option<u8> {\n-        self.range.next_back().map(|i| self.data[i])\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExactSizeIterator for EscapeDefault {}\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EscapeDefault {}\n-\n-#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n-impl fmt::Debug for EscapeDefault {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EscapeDefault { .. }\")\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    //! Note that most of these tests are not testing `AsciiExt` methods, but\n-    //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n-    //! just using those methods, though.\n-    use super::AsciiExt;\n-    use char::from_u32;\n-\n-    #[test]\n-    fn test_is_ascii() {\n-        assert!(b\"\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n-\n-        assert!(\"\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_uppercase() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n-                       (from_u32(upper).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_lowercase() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n-                       (from_u32(lower).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_make_ascii_lower_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_lowercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'A', b'a');\n-        test!(b'a', b'a');\n-        test!(b'!', b'!');\n-        test!('A', 'a');\n-        test!('\u00c0', '\u00c0');\n-        test!('a', 'a');\n-        test!('!', '!');\n-        test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n-        test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n-    }\n-\n-\n-    #[test]\n-    fn test_make_ascii_upper_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_uppercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'a', b'A');\n-        test!(b'A', b'A');\n-        test!(b'!', b'!');\n-        test!('a', 'A');\n-        test!('\u00e0', '\u00e0');\n-        test!('A', 'A');\n-        test!('!', '!');\n-        test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n-        test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n-\n-        let mut x = \"Hello\".to_string();\n-        x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n-        assert_eq!(x, \"HELlo\")\n-    }\n-\n-    #[test]\n-    fn test_eq_ignore_ascii_case() {\n-        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n-        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n-        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n-        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n-        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n-                    &from_u32(lower).unwrap().to_string()));\n-        }\n-    }\n-\n-    #[test]\n-    fn inference_works() {\n-        let x = \"a\".to_string();\n-        x.eq_ignore_ascii_case(\"A\");\n-    }\n-\n-    // Shorthands used by the is_ascii_* tests.\n-    macro_rules! assert_all {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}({}) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                assert!($str.$what());\n-                assert!($str.as_bytes().$what());\n-            )+\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n-    }\n-    macro_rules! assert_none {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}({}) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-            )*\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphabetic() {\n-        assert_all!(is_ascii_alphabetic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_alphabetic,\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_uppercase() {\n-        assert_all!(is_ascii_uppercase,\n-            \"\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_uppercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_lowercase() {\n-        assert_all!(is_ascii_lowercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-        );\n-        assert_none!(is_ascii_lowercase,\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphanumeric() {\n-        assert_all!(is_ascii_alphanumeric,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_alphanumeric,\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_digit() {\n-        assert_all!(is_ascii_digit,\n-            \"\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_digit,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_hexdigit() {\n-        assert_all!(is_ascii_hexdigit,\n-            \"\",\n-            \"0123456789\",\n-            \"abcdefABCDEF\",\n-        );\n-        assert_none!(is_ascii_hexdigit,\n-            \"ghijklmnopqrstuvwxyz\",\n-            \"GHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_punctuation() {\n-        assert_all!(is_ascii_punctuation,\n-            \"\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_punctuation,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_graphic() {\n-        assert_all!(is_ascii_graphic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_graphic,\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_whitespace() {\n-        assert_all!(is_ascii_whitespace,\n-            \"\",\n-            \" \\t\\n\\x0c\\r\",\n-        );\n-        assert_none!(is_ascii_whitespace,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x0b\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_control() {\n-        assert_all!(is_ascii_control,\n-            \"\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-        assert_none!(is_ascii_control,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \",\n-        );\n-    }\n-}"}]}