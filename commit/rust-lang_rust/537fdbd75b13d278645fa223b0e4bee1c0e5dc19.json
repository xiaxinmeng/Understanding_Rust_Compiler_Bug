{"sha": "537fdbd75b13d278645fa223b0e4bee1c0e5dc19", "node_id": "C_kwDOAAsO6NoAKDUzN2ZkYmQ3NWIxM2QyNzg2NDVmYTIyM2IwZTRiZWUxYzBlNWRjMTk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-24T14:06:03Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-24T14:06:03Z"}, "message": "Strenghten disambiguation in `ambiguity_error` and improve documentation", "tree": {"sha": "f6a8b04027baa64378b364544522066727b1f402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a8b04027baa64378b364544522066727b1f402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/537fdbd75b13d278645fa223b0e4bee1c0e5dc19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/537fdbd75b13d278645fa223b0e4bee1c0e5dc19", "html_url": "https://github.com/rust-lang/rust/commit/537fdbd75b13d278645fa223b0e4bee1c0e5dc19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/537fdbd75b13d278645fa223b0e4bee1c0e5dc19/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec43cb3e9c208939e09b4208850aaa34bee0423c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec43cb3e9c208939e09b4208850aaa34bee0423c", "html_url": "https://github.com/rust-lang/rust/commit/ec43cb3e9c208939e09b4208850aaa34bee0423c"}], "stats": {"total": 16, "additions": 11, "deletions": 5}, "files": [{"sha": "80895893ae86b794065ab867c6c1d926e1252092", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/537fdbd75b13d278645fa223b0e4bee1c0e5dc19/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537fdbd75b13d278645fa223b0e4bee1c0e5dc19/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=537fdbd75b13d278645fa223b0e4bee1c0e5dc19", "patch": "@@ -1015,8 +1015,8 @@ impl LinkCollector<'_, '_> {\n                     res = prim;\n                 } else {\n                     // `[char]` when a `char` module is in scope\n-                    let candidates = vec![(res, res.def_id(self.cx.tcx)), (prim, None)];\n-                    ambiguity_error(self.cx, &diag_info, path_str, &candidates);\n+                    let candidates = &[(res, res.def_id(self.cx.tcx)), (prim, None)];\n+                    ambiguity_error(self.cx, &diag_info, path_str, candidates);\n                     return None;\n                 }\n             }\n@@ -1206,6 +1206,10 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n+        // If there are multiple items with the same \"kind\" (for example, both \"associated types\")\n+        // and after removing duplicated kinds, only one remains, the `ambiguity_error` function\n+        // won't emit an error. So at this point, we can just take the first candidate as it was\n+        // the first retrieved and use it to generate the link.\n         if candidates.len() > 1 && !ambiguity_error(self.cx, &diag, &key.path_str, &candidates) {\n             candidates = vec![candidates[0]];\n         }\n@@ -1901,29 +1905,31 @@ fn report_malformed_generics(\n /// Report an ambiguity error, where there were multiple possible resolutions.\n ///\n /// If all `candidates` have the same kind, it's not possible to disambiguate so in this case,\n-/// the function returns `false`. Otherwise, it'll emit the error and return `true`.\n+/// the function won't emit an error and will return `false`. Otherwise, it'll emit the error and\n+/// return `true`.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n     diag_info: &DiagnosticInfo<'_>,\n     path_str: &str,\n     candidates: &[(Res, Option<DefId>)],\n ) -> bool {\n-    let mut msg = format!(\"`{}` is \", path_str);\n+    let mut descrs = FxHashSet::default();\n     let kinds = candidates\n         .iter()\n         .map(\n             |(res, def_id)| {\n                 if let Some(def_id) = def_id { Res::from_def_id(cx.tcx, *def_id) } else { *res }\n             },\n         )\n+        .filter(|res| descrs.insert(res.descr()))\n         .collect::<Vec<_>>();\n-    let descrs = kinds.iter().map(|res| res.descr()).collect::<FxHashSet<&'static str>>();\n     if descrs.len() == 1 {\n         // There is no way for users to disambiguate at this point, so better return the first\n         // candidate and not show a warning.\n         return false;\n     }\n \n+    let mut msg = format!(\"`{}` is \", path_str);\n     match kinds.as_slice() {\n         [res1, res2] => {\n             msg += &format!("}]}