{"sha": "39ceca8893773e71e34e9eebc6952c71bec5bc5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2VjYTg4OTM3NzNlNzFlMzRlOWVlYmM2OTUyYzcxYmVjNWJjNWI=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-26T16:46:42Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-26T17:57:27Z"}, "message": "rename TriState -> Finiteness, docs", "tree": {"sha": "d62d3af3838785a6295443d4c68daad4162ab896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d62d3af3838785a6295443d4c68daad4162ab896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ceca8893773e71e34e9eebc6952c71bec5bc5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ceca8893773e71e34e9eebc6952c71bec5bc5b", "html_url": "https://github.com/rust-lang/rust/commit/39ceca8893773e71e34e9eebc6952c71bec5bc5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ceca8893773e71e34e9eebc6952c71bec5bc5b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e7bc6ad9aab232fecfe6a247a1afd66c830de0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7bc6ad9aab232fecfe6a247a1afd66c830de0a", "html_url": "https://github.com/rust-lang/rust/commit/6e7bc6ad9aab232fecfe6a247a1afd66c830de0a"}], "stats": {"total": 110, "additions": 62, "deletions": 48}, "files": [{"sha": "72ff75dd9948e9bd1de6bf2e42bfe37d0c6981cc", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/39ceca8893773e71e34e9eebc6952c71bec5bc5b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ceca8893773e71e34e9eebc6952c71bec5bc5b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=39ceca8893773e71e34e9eebc6952c71bec5bc5b", "patch": "@@ -49,88 +49,98 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let (lint, msg) = match complete_infinite_iter(cx, expr) {\n-            True => (INFINITE_ITER, \"infinite iteration detected\"),\n-            Unknown => (MAYBE_INFINITE_ITER,\n+            Infinite => (INFINITE_ITER, \"infinite iteration detected\"),\n+            MaybeInfinite => (MAYBE_INFINITE_ITER,\n                         \"possible infinite iteration detected\"),\n-            False => { return; }\n+            Finite => { return; }\n         };\n         span_lint(cx, lint, expr.span, msg)\n     }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum TriState {\n-    True,\n-    Unknown,\n-    False\n+enum Finiteness {\n+    Infinite,\n+    MaybeInfinite,\n+    Finite\n }\n \n-use self::TriState::{True, Unknown, False};\n+use self::Finiteness::{Infinite, MaybeInfinite, Finite};\n \n-impl TriState {\n+impl Finiteness {\n     fn and(self, b: Self) -> Self {\n         match (self, b) {\n-            (False, _) | (_, False) => False,\n-            (Unknown, _) | (_, Unknown) => Unknown,\n-            _ => True\n+            (Finite, _) | (_, Finite) => Finite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Infinite\n         }\n     }\n \n     fn or(self, b: Self) -> Self {\n         match (self, b) {\n-            (True, _) | (_, True) => True,\n-            (Unknown, _) | (_, Unknown) => Unknown,\n-            _ => False\n+            (Infinite, _) | (_, Infinite) => Infinite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Finite\n         }\n     }\n }\n \n-impl From<bool> for TriState {\n+impl From<bool> for Finiteness {\n     fn from(b: bool) -> Self {\n-        if b { True } else { False }\n+        if b { Infinite } else { Finite }\n     }\n }\n \n+/// This tells us what to look for to know if the iterator returned by\n+/// this method is infinite\n #[derive(Copy, Clone)]\n enum Heuristic {\n+    /// infinite no matter what\n     Always,\n+    /// infinite if the first argument is\n     First,\n+    /// infinite if any of the supplied arguments is\n     Any,\n+    /// infinite if all of the supplied arguments are\n     All\n }\n \n use self::Heuristic::{Always, First, Any, All};\n \n-// here we use the `TriState` as (Finite, Possible Infinite, Infinite)\n-static HEURISTICS : &[(&str, usize, Heuristic, TriState)] = &[\n-    (\"zip\", 2, All, True),\n-    (\"chain\", 2, Any, True),\n-    (\"cycle\", 1, Always, True),\n-    (\"map\", 2, First, True),\n-    (\"by_ref\", 1, First, True),\n-    (\"cloned\", 1, First, True),\n-    (\"rev\", 1, First, True),\n-    (\"inspect\", 1, First, True),\n-    (\"enumerate\", 1, First, True),\n-    (\"peekable\", 2, First, True),\n-    (\"fuse\", 1, First, True),\n-    (\"skip\", 2, First, True),\n-    (\"skip_while\", 1, First, True),\n-    (\"filter\", 2, First, True),\n-    (\"filter_map\", 2, First, True),\n-    (\"flat_map\", 2, First, True),\n-    (\"unzip\", 1, First, True),\n-    (\"take_while\", 2, First, Unknown),\n-    (\"scan\", 3, First, Unknown)\n+/// a slice of (method name, number of args, heuristic, bounds) tuples\n+/// that will be used to determine whether the method in question\n+/// returns an infinite or possibly infinite iterator. The finiteness\n+/// is an upper bound, e.g. some methods can return a possibly\n+/// infinite iterator at worst, e.g. `take_while`.\n+static HEURISTICS : &[(&str, usize, Heuristic, Finiteness)] = &[\n+    (\"zip\", 2, All, Infinite),\n+    (\"chain\", 2, Any, Infinite),\n+    (\"cycle\", 1, Always, Infinite),\n+    (\"map\", 2, First, Infinite),\n+    (\"by_ref\", 1, First, Infinite),\n+    (\"cloned\", 1, First, Infinite),\n+    (\"rev\", 1, First, Infinite),\n+    (\"inspect\", 1, First, Infinite),\n+    (\"enumerate\", 1, First, Infinite),\n+    (\"peekable\", 2, First, Infinite),\n+    (\"fuse\", 1, First, Infinite),\n+    (\"skip\", 2, First, Infinite),\n+    (\"skip_while\", 1, First, Infinite),\n+    (\"filter\", 2, First, Infinite),\n+    (\"filter_map\", 2, First, Infinite),\n+    (\"flat_map\", 2, First, Infinite),\n+    (\"unzip\", 1, First, Infinite),\n+    (\"take_while\", 2, First, MaybeInfinite),\n+    (\"scan\", 3, First, MaybeInfinite)\n ];\n \n-fn is_infinite(cx: &LateContext, expr: &Expr) -> TriState {\n+fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprMethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.name == name && args.len() == len {\n                     return (match heuristic {\n-                        Always => True,\n+                        Always => Infinite,\n                         First => is_infinite(cx, &args[0]),\n                         Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n                         All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n@@ -143,23 +153,25 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> TriState {\n                     return is_infinite(cx, &body.value);\n                 }\n             }\n-            False\n+            Finite\n         },\n         ExprBlock(ref block) =>\n-            block.expr.as_ref().map_or(False, |e| is_infinite(cx, e)),\n+            block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n         ExprCall(ref path, _) => {\n             if let ExprPath(ref qpath) = path.node {\n                 match_qpath(qpath, &paths::REPEAT).into()\n-            } else { False }\n+            } else { Finite }\n         },\n         ExprStruct(..) => {\n             higher::range(expr).map_or(false, |r| r.end.is_none()).into()\n         },\n-        _ => False\n+        _ => Finite\n     }\n }\n \n+/// the names and argument lengths of methods that *may* exhaust their\n+/// iterators\n static POSSIBLY_COMPLETING_METHODS : &[(&str, usize)] = &[\n     (\"find\", 2),\n     (\"rfind\", 2),\n@@ -169,6 +181,8 @@ static POSSIBLY_COMPLETING_METHODS : &[(&str, usize)] = &[\n     (\"all\", 2)\n ];\n \n+/// the names and argument lengths of methods that *always* exhaust\n+/// their iterators\n static COMPLETING_METHODS : &[(&str, usize)] = &[\n     (\"count\", 1),\n     (\"collect\", 1),\n@@ -185,7 +199,7 @@ static COMPLETING_METHODS : &[(&str, usize)] = &[\n     (\"product\", 1)\n ];\n \n-fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> TriState {\n+fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprMethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n@@ -195,7 +209,7 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> TriState {\n             }\n             for &(name, len) in POSSIBLY_COMPLETING_METHODS.iter() {\n                 if method.name == name && args.len() == len {\n-                    return Unknown.and(is_infinite(cx, &args[0]));\n+                    return MaybeInfinite.and(is_infinite(cx, &args[0]));\n                 }\n             }\n             if method.name == \"last\" && args.len() == 1 &&\n@@ -209,10 +223,10 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> TriState {\n         },\n         ExprBinary(op, ref l, ref r) => {\n             if op.node.is_comparison() {\n-                return is_infinite(cx, l).and(is_infinite(cx, r)).and(Unknown)\n+                return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite)\n             }\n         }, //TODO: ExprLoop + Match\n         _ => ()\n     }\n-    False\n+    Finite\n }"}]}