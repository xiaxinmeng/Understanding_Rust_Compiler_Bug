{"sha": "1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjM4YzBkZmM2NmM1NGNhYmNlMTZlNTZmYTE2YThlYjM4MzY2YWE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-22T19:24:17Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-22T19:24:17Z"}, "message": "Re-introduce FnBox", "tree": {"sha": "6da98e4ab304aff8e1ae4b01fb882af15cfee3b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6da98e4ab304aff8e1ae4b01fb882af15cfee3b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "html_url": "https://github.com/rust-lang/rust/commit/1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db38c0dfc66c54cabce16e56fa16a8eb38366aa/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ce626865d589e817b6753467dc5d8593454e6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ce626865d589e817b6753467dc5d8593454e6c", "html_url": "https://github.com/rust-lang/rust/commit/85ce626865d589e817b6753467dc5d8593454e6c"}], "stats": {"total": 220, "additions": 178, "deletions": 42}, "files": [{"sha": "9c60ac55a9f3147ea6dd52fd41f4a4a3811b4242", "filename": "patches/0015-Remove-usage-of-unsized-locals.patch", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1db38c0dfc66c54cabce16e56fa16a8eb38366aa/patches%2F0015-Remove-usage-of-unsized-locals.patch", "raw_url": "https://github.com/rust-lang/rust/raw/1db38c0dfc66c54cabce16e56fa16a8eb38366aa/patches%2F0015-Remove-usage-of-unsized-locals.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0015-Remove-usage-of-unsized-locals.patch?ref=1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "patch": "@@ -44,53 +44,16 @@ index f6dee7c..0c6a8c0 100644\n  #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n  impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n  \n-diff --git a/src/libstd/sys_common/at_exit_imp.rs b/src/libstd/sys_common/at_exit_imp.rs\n-index 1181b86..20f9251 100644\n---- a/src/libstd/sys_common/at_exit_imp.rs\n-+++ b/src/libstd/sys_common/at_exit_imp.rs\n-@@ -38,6 +38,7 @@ unsafe fn init() -> bool {\n-     true\n- }\n- \n-+/*\n- pub fn cleanup() {\n-     for i in 1..=ITERS {\n-         unsafe {\n-@@ -60,6 +61,7 @@ pub fn cleanup() {\n-         }\n-     }\n- }\n-+*/\n- \n- pub fn push(f: Box<dyn FnOnce()>) -> bool {\n-     unsafe {\n-diff --git a/src/libstd/sys_common/mod.rs b/src/libstd/sys_common/mod.rs\n-index 6260c3b..611ed7e 100644\n---- a/src/libstd/sys_common/mod.rs\n-+++ b/src/libstd/sys_common/mod.rs\n-@@ -127,7 +127,6 @@ pub fn cleanup() {\n-     CLEANUP.call_once(|| unsafe {\n-         sys::args::cleanup();\n-         sys::stack_overflow::cleanup();\n--        at_exit_imp::cleanup();\n-     });\n- }\n- \n diff --git a/src/libstd/sys_common/thread.rs b/src/libstd/sys_common/thread.rs\n index b2142e7..718bb1c 100644\n --- a/src/libstd/sys_common/thread.rs\n +++ b/src/libstd/sys_common/thread.rs\n-@@ -6,12 +6,7 @@ use crate::sys::thread as imp;\n+@@ -6,7 +6,7 @@ pub unsafe fn start_thread(main: *mut u8) {\n+     let _handler = stack_overflow::Handler::new();\n  \n- #[allow(dead_code)]\n- pub unsafe fn start_thread(main: *mut u8) {\n--    // Next, set up our stack overflow handler which may get triggered if we run\n--    // out of stack.\n--    let _handler = stack_overflow::Handler::new();\n--\n--    // Finally, let's run some code.\n+     // Finally, let's run some code.\n -    Box::from_raw(main as *mut Box<dyn FnOnce()>)()\n-+    panic!(\"Threads are not yet supported, because cranelift doesn't support atomics.\");\n++    Box::from_raw(main as *mut Box<dyn FnBox()>)()\n  }\n  \n  pub fn min_stack() -> usize {\n@@ -101,7 +64,7 @@ index f4a1783..362b537 100644\n @@ -40,5 +40,7 @@ impl Thread {\n      // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n      pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-+        panic!(\"Threads are not yet supported, because cranelift doesn't support atomics.\");\n++        panic!(\"Warning: Threads are not yet fully supported, because cranelift doesn't support atomics.\");\n +\n          let p = box p;\n          let mut native: libc::pthread_t = mem::zeroed();"}, {"sha": "e5616aa5a8b1df5865b7c5fa98e9bcc99da80c8e", "filename": "patches/0018-Add-FnBox-back.patch", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1db38c0dfc66c54cabce16e56fa16a8eb38366aa/patches%2F0018-Add-FnBox-back.patch", "raw_url": "https://github.com/rust-lang/rust/raw/1db38c0dfc66c54cabce16e56fa16a8eb38366aa/patches%2F0018-Add-FnBox-back.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0018-Add-FnBox-back.patch?ref=1db38c0dfc66c54cabce16e56fa16a8eb38366aa", "patch": "@@ -0,0 +1,173 @@\n+From 8617310c3c9e192080df6a0c7b4835d3f02e27b9 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Fri, 1 Nov 2019 20:58:30 +0100\n+Subject: [PATCH] Add FnBox back\n+\n+---\n+ src/liballoc/boxed.rs                | 13 +++++++++++++\n+ src/libstd/prelude/v1.rs             |  2 +-\n+ src/libstd/sys/cloudabi/thread.rs    |  2 +-\n+ src/libstd/sys/hermit/thread.rs      |  4 ++--\n+ src/libstd/sys/unix/thread.rs        |  4 ++--\n+ src/libstd/sys_common/at_exit_imp.rs |  6 +++---\n+ src/libstd/sys_common/mod.rs         |  2 +-\n+ src/libstd/sys_common/thread.rs      |  2 +-\n+ src/libstd/thread/mod.rs             |  2 +-\n+ 9 files changed, 25 insertions(+), 12 deletions(-)\n+\n+diff --git a/src/liballoc/boxed.rs b/src/liballoc/boxed.rs\n+index ef9b648..e32b870 100644\n+--- a/src/liballoc/boxed.rs\n++++ b/src/liballoc/boxed.rs\n+@@ -1079,3 +1079,16 @@ impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n+         F::poll(Pin::new(&mut *self), cx)\n+     }\n+ }\n++\n++#[stable(feature = \"rust1\", since = \"1.0.0\")]\n++pub trait FnBox<A>: FnOnce<A> {\n++    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n++    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output;\n++}\n++\n++#[stable(feature = \"rust1\", since = \"1.0.0\")]\n++impl<A, F: FnOnce<A>> FnBox<A> for F {\n++    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output {\n++        <F as FnOnce<A>>::call_once(*self, args)\n++    }\n++}\n+diff --git a/src/libstd/prelude/v1.rs b/src/libstd/prelude/v1.rs\n+index 3e4cf91..1f50eb3 100644\n+--- a/src/libstd/prelude/v1.rs\n++++ b/src/libstd/prelude/v1.rs\n+@@ -94,6 +94,6 @@ pub use core::prelude::v1::{\n+ #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+ #[doc(no_inline)]\n+-pub use crate::boxed::Box;\n++pub use crate::boxed::{Box, FnBox};\n+ #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+ #[doc(no_inline)]\n+ pub use crate::string::{String, ToString};\n+diff --git a/src/libstd/sys/cloudabi/thread.rs b/src/libstd/sys/cloudabi/thread.rs\n+index 240b6ea..6f71c6b 100644\n+--- a/src/libstd/sys/cloudabi/thread.rs\n++++ b/src/libstd/sys/cloudabi/thread.rs\n+@@ -21,7 +21,7 @@ unsafe impl Sync for Thread {}\n+ \n+ impl Thread {\n+     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n++    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n+         let p = box p;\n+         let mut native: libc::pthread_t = mem::zeroed();\n+         let mut attr: libc::pthread_attr_t = mem::zeroed();\n+diff --git a/src/libstd/sys/hermit/thread.rs b/src/libstd/sys/hermit/thread.rs\n+index 99a9c83..b8bc392 100644\n+--- a/src/libstd/sys/hermit/thread.rs\n++++ b/src/libstd/sys/hermit/thread.rs\n+@@ -44,9 +44,9 @@ unsafe impl Sync for Thread {}\n+ pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n+ \n+ impl Thread {\n+     pub unsafe fn new_with_coreid(\n+         _stack: usize,\n+-        p: Box<dyn FnOnce()>,\n++        p: Box<dyn FnBox()>,\n+         core_id: isize,\n+     ) -> io::Result<Thread> {\n+         let p = box p;\n+@@ -67,7 +67,7 @@ impl Thread {\n+         }\n+     }\n+ \n+-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n++    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n+         Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n+     }\n+ \n+diff --git a/src/libstd/sys/unix/thread.rs b/src/libstd/sys/unix/thread.rs\n+index 143cf2f..a6e8faf 100644\n+--- a/src/libstd/sys/unix/thread.rs\n++++ b/src/libstd/sys/unix/thread.rs\n+@@ -38,8 +38,8 @@ unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n+ \n+ impl Thread {\n+     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n++    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n+         panic!(\"Warning: Threads are not yet fully supported, because cranelift doesn't support atomics.\");\n+ \n+         let p = box p;\n+         let mut native: libc::pthread_t = mem::zeroed();\n+diff --git a/src/libstd/sys_common/at_exit_imp.rs b/src/libstd/sys_common/at_exit_imp.rs\n+index cdb72ee..e523333 100644\n+--- a/src/libstd/sys_common/at_exit_imp.rs\n++++ b/src/libstd/sys_common/at_exit_imp.rs\n+@@ -6,7 +6,7 @@ use crate::mem;\n+ use crate::ptr;\n+ use crate::sys_common::mutex::Mutex;\n+ \n+-type Queue = Vec<Box<dyn FnOnce()>>;\n++type Queue = Vec<Box<dyn FnBox()>>;\n+ \n+ // NB these are specifically not types from `std::sync` as they currently rely\n+ // on poisoning and this module needs to operate at a lower level than requiring\n+@@ -53,14 +53,14 @@ pub fn cleanup() {\n+                 let queue: Box<Queue> = Box::from_raw(queue);\n+                 for to_run in *queue {\n+                     // We are not holding any lock, so reentrancy is fine.\n+-                    to_run();\n++                    to_run.call_box(());\n+                 }\n+             }\n+         }\n+     }\n+ }\n+ \n+-pub fn push(f: Box<dyn FnOnce()>) -> bool {\n++pub fn push(f: Box<dyn FnBox()>) -> bool {\n+     unsafe {\n+         let _guard = LOCK.lock();\n+         if init() {\n+diff --git a/src/libstd/sys_common/mod.rs b/src/libstd/sys_common/mod.rs\n+index 7a0bcd0..668bef2 100644\n+--- a/src/libstd/sys_common/mod.rs\n++++ b/src/libstd/sys_common/mod.rs\n+@@ -113,7 +113,7 @@ pub trait FromInner<Inner> {\n+ /// closure will be run once the main thread exits. Returns `Err` to indicate\n+ /// that the closure could not be registered, meaning that it is not scheduled\n+ /// to be run.\n+-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n++pub fn at_exit<F: FnBox() + Send + 'static>(f: F) -> Result<(), ()> {\n+     if at_exit_imp::push(Box::new(f)) { Ok(()) } else { Err(()) }\n+ }\n+ \n+diff --git a/src/libstd/sys_common/thread.rs b/src/libstd/sys_common/thread.rs\n+index c638be9..5c18a18 100644\n+--- a/src/libstd/sys_common/thread.rs\n++++ b/src/libstd/sys_common/thread.rs\n+@@ -10,7 +10,7 @@ pub unsafe fn start_thread(main: *mut u8) {\n+     let _handler = stack_overflow::Handler::new();\n+ \n+     // Finally, let's run some code.\n+-    Box::from_raw(main as *mut Box<dyn FnBox()>)()\n++    Box::from_raw(main as *mut Box<dyn FnBox()>).call_box(())\n+ }\n+ \n+ pub fn min_stack() -> usize {\n+diff --git a/src/libstd/thread/mod.rs b/src/libstd/thread/mod.rs\n+index 0ffa6ac..4a3e3d6 100644\n+--- a/src/libstd/thread/mod.rs\n++++ b/src/libstd/thread/mod.rs\n+@@ -485,7 +485,7 @@ impl Builder {\n+             // returning.\n+             native: Some(imp::Thread::new(\n+                 stack_size,\n+-                mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(Box::new(\n++                mem::transmute::<Box<dyn FnBox() + 'a>, Box<dyn FnBox() + 'static>>(Box::new(\n+                     main,\n+                 )),\n+             )?),\n+-- \n+2.20.1\n+"}]}