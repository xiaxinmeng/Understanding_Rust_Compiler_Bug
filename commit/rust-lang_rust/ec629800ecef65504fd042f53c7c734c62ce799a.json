{"sha": "ec629800ecef65504fd042f53c7c734c62ce799a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNjI5ODAwZWNlZjY1NTA0ZmQwNDJmNTNjN2M3MzRjNjJjZTc5OWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-22T00:14:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-22T00:14:45Z"}, "message": "Rollup merge of #75725 - LeSeulArtichaut:alloc-intra-doc, r=jyn514\n\nUse intra-doc-links in `alloc`\n\nI didn't have time to test this, so I will let the CI do it for me.\n\nr? @jyn514 cc #75080", "tree": {"sha": "c81b3fe9fb92e8465bee75280fddd4608a396525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c81b3fe9fb92e8465bee75280fddd4608a396525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec629800ecef65504fd042f53c7c734c62ce799a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQGN2CRBK7hj4Ov3rIwAAdHIIADHLyNMomCiRzMqGUhGQQjFP\nfYO8KGk1pRZAXYTUV4quJhbBWi4W2TWDomoa78B5RqfI4zC9Ovh5VB8Z8vuQ7qTv\ncaQaA1We69LVF4BkNJEZeYT0z0jhbTxsYlFODNJMfXP1T9K/KOk7H0DEpY2AZqoO\n6a/cu5jrdHSg0/R9RAcDRDoF/Ju/ZFqwJCBRRl2Cu9PJ84CthiRZoWnCe5rY/ZuO\nq7tIrvIX8pI2Pwrp5U4zN7sfbriQQXTr9d4xRk5p4bjgfCicScZy+qlol+At0krL\nRj81FC7k/1bILgiJURFp9B9bibyx4Y0SIFdMl2+oNMe9NHC8sx6HbOnumrjiSV4=\n=lvlW\n-----END PGP SIGNATURE-----\n", "payload": "tree c81b3fe9fb92e8465bee75280fddd4608a396525\nparent 441c835278107b13a95d1e7010c63b65073e29f7\nparent 97072c6b9054bbab09fa731948d504a26a1f8377\nauthor Dylan DPC <dylan.dpc@gmail.com> 1598055285 +0200\ncommitter GitHub <noreply@github.com> 1598055285 +0200\n\nRollup merge of #75725 - LeSeulArtichaut:alloc-intra-doc, r=jyn514\n\nUse intra-doc-links in `alloc`\n\nI didn't have time to test this, so I will let the CI do it for me.\n\nr? @jyn514 cc #75080\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec629800ecef65504fd042f53c7c734c62ce799a", "html_url": "https://github.com/rust-lang/rust/commit/ec629800ecef65504fd042f53c7c734c62ce799a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec629800ecef65504fd042f53c7c734c62ce799a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441c835278107b13a95d1e7010c63b65073e29f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/441c835278107b13a95d1e7010c63b65073e29f7", "html_url": "https://github.com/rust-lang/rust/commit/441c835278107b13a95d1e7010c63b65073e29f7"}, {"sha": "97072c6b9054bbab09fa731948d504a26a1f8377", "url": "https://api.github.com/repos/rust-lang/rust/commits/97072c6b9054bbab09fa731948d504a26a1f8377", "html_url": "https://github.com/rust-lang/rust/commit/97072c6b9054bbab09fa731948d504a26a1f8377"}], "stats": {"total": 339, "additions": 116, "deletions": 223}, "files": [{"sha": "87b86e590a4c82b23e5d4d5a030eef7c53057728", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -36,8 +36,6 @@ extern \"Rust\" {\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n-///\n-/// [`AllocRef`]: trait.AllocRef.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -55,10 +53,6 @@ pub struct Global;\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n-///\n /// # Examples\n ///\n /// ```\n@@ -92,10 +86,6 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n-///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n@@ -114,10 +104,6 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n-///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n@@ -137,10 +123,6 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n-///\n /// # Examples\n ///\n /// ```"}, {"sha": "93d0df448ea1447f3bfbb7d8c832bbda8b737152", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -118,14 +118,13 @@\n //! described in [rust-lang/unsafe-code-guidelines#198][ucg#198].\n //!\n //! [ucg#198]: https://github.com/rust-lang/unsafe-code-guidelines/issues/198\n-//! [dereferencing]: ../../std/ops/trait.Deref.html\n-//! [`Box`]: struct.Box.html\n-//! [`Box<T>`]: struct.Box.html\n-//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n-//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n-//! [`Global`]: ../alloc/struct.Global.html\n-//! [`Layout`]: ../alloc/struct.Layout.html\n-//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n+//! [dereferencing]: core::ops::Deref\n+//! [`Box<T>`]: Box\n+//! [`Box::<T>::from_raw(value)`]: Box::from_raw\n+//! [`Box::<T>::into_raw`]: Box::into_raw\n+//! [`Global`]: crate::alloc::Global\n+//! [`Layout`]: crate::alloc::Layout\n+//! [`Layout::for_value(&*value)`]: crate::alloc::Layout::for_value\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -240,7 +239,6 @@ impl<T> Box<T> {\n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n-    ///\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n     pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n         // *mut T and *mut [T; 1] have the same size and alignment\n@@ -386,9 +384,8 @@ impl<T: ?Sized> Box<T> {\n     /// }\n     /// ```\n     ///\n-    /// [memory layout]: index.html#memory-layout\n-    /// [`Layout`]: ../alloc/struct.Layout.html\n-    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n+    /// [memory layout]: self#memory-layout\n+    /// [`Layout`]: crate::Layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -433,8 +430,7 @@ impl<T: ?Sized> Box<T> {\n     /// }\n     /// ```\n     ///\n-    /// [memory layout]: index.html#memory-layout\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    /// [memory layout]: self#memory-layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n@@ -478,8 +474,6 @@ impl<T: ?Sized> Box<T> {\n     /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n     /// # Examples\n     ///\n     /// Simple usage:"}, {"sha": "5390b57a1d98dddcd84ef1e2dfc0e7896c1ddd20", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -7,8 +7,8 @@\n //! array-based containers are generally faster,\n //! more memory efficient, and make better use of CPU cache.\n //!\n-//! [`Vec`]: ../../vec/struct.Vec.html\n-//! [`VecDeque`]: ../vec_deque/struct.VecDeque.html\n+//! [`Vec`]: crate::vec::Vec\n+//! [`VecDeque`]: super::vec_deque::VecDeque\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -50,11 +50,8 @@ struct Node<T> {\n \n /// An iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`iter`] method on [`LinkedList`]. See its\n+/// This `struct` is created by [`LinkedList::iter()`]. See its\n /// documentation for more.\n-///\n-/// [`iter`]: struct.LinkedList.html#method.iter\n-/// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -80,11 +77,8 @@ impl<T> Clone for Iter<'_, T> {\n \n /// A mutable iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`iter_mut`] method on [`LinkedList`]. See its\n+/// This `struct` is created by [`LinkedList::iter_mut()`]. See its\n /// documentation for more.\n-///\n-/// [`iter_mut`]: struct.LinkedList.html#method.iter_mut\n-/// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     // We do *not* exclusively own the entire list here, references to node's `element`\n@@ -109,7 +103,6 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.LinkedList.html#method.into_iter\n-/// [`LinkedList`]: struct.LinkedList.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {"}, {"sha": "a886e17f5a9c3022a07467ccdded6bdec6e9c7b0", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -501,31 +501,23 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! [`usize`]: ../../std/primitive.usize.html\n-//! [`isize`]: ../../std/primitive.isize.html\n-//! [`i8`]: ../../std/primitive.i8.html\n-//! [`Display`]: trait.Display.html\n-//! [`Binary`]: trait.Binary.html\n-//! [`fmt::Result`]: type.Result.html\n-//! [`Result`]: ../../std/result/enum.Result.html\n-//! [`std::fmt::Error`]: struct.Error.html\n-//! [`Formatter`]: struct.Formatter.html\n-//! [`write!`]: ../../std/macro.write.html\n-//! [`Debug`]: trait.Debug.html\n-//! [`format!`]: ../../std/macro.format.html\n-//! [`to_string`]: ../../std/string/trait.ToString.html\n-//! [`writeln!`]: ../../std/macro.writeln.html\n+//! [`fmt::Result`]: Result\n+//! [`Result`]: core::result::Result\n+//! [`std::fmt::Error`]: Error\n+//! [`write!`]: core::write\n+//! [`write`]: core::write\n+//! [`format!`]: crate::format\n+//! [`to_string`]: crate::string::ToString\n+//! [`writeln!`]: core::writeln\n //! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n //! [`std::io::Write`]: ../../std/io/trait.Write.html\n //! [`print!`]: ../../std/macro.print.html\n //! [`println!`]: ../../std/macro.println.html\n //! [`eprint!`]: ../../std/macro.eprint.html\n //! [`eprintln!`]: ../../std/macro.eprintln.html\n-//! [`write!`]: ../../std/macro.write.html\n-//! [`format_args!`]: ../../std/macro.format_args.html\n-//! [`fmt::Arguments`]: struct.Arguments.html\n-//! [`write`]: fn.write.html\n-//! [`format`]: fn.format.html\n+//! [`format_args!`]: core::format_args\n+//! [`fmt::Arguments`]: Arguments\n+//! [`format`]: crate::format\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -576,9 +568,8 @@ use crate::string;\n /// assert_eq!(s, \"Hello, world!\");\n /// ```\n ///\n-/// [`Arguments`]: struct.Arguments.html\n-/// [`format_args!`]: ../../std/macro.format_args.html\n-/// [`format!`]: ../../std/macro.format.html\n+/// [`format_args!`]: core::format_args\n+/// [`format!`]: crate::format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "892f794fc42326909cc4301605228af25067fc6c", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -50,11 +50,11 @@\n //! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n //!\n-//! [`Arc`]: sync/index.html\n-//! [`Box`]: boxed/index.html\n-//! [`Cell`]: ../core/cell/index.html\n-//! [`Rc`]: rc/index.html\n-//! [`RefCell`]: ../core/cell/index.html\n+//! [`Arc`]: sync\n+//! [`Box`]: boxed\n+//! [`Cell`]: core::cell\n+//! [`Rc`]: rc\n+//! [`RefCell`]: core::cell\n \n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]"}, {"sha": "2f744618d6936937224ee92fe41c1ac9f9b545ac", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -29,8 +29,7 @@\n /// to the same boxed integer value, not five references pointing to independently\n /// boxed integers.\n ///\n-/// [`Vec`]: ../std/vec/struct.Vec.html\n-/// [`Clone`]: ../std/clone/trait.Clone.html\n+/// [`Vec`]: crate::vec::Vec\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -81,11 +80,11 @@ macro_rules! vec {\n /// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n-/// [fmt]: ../std/fmt/index.html\n+/// [fmt]: core::fmt\n /// [`print!`]: ../std/macro.print.html\n-/// [`write!`]: ../std/macro.write.html\n-/// [`to_string`]: ../std/string/trait.ToString.html\n-/// [`Display`]: ../std/fmt/trait.Display.html\n+/// [`write!`]: core::write\n+/// [`to_string`]: crate::string::ToString\n+/// [`Display`]: core::fmt::Display\n ///\n /// # Panics\n ///"}, {"sha": "f8b1c21e9771c3324823a27a20d1087d9d9d7663", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 33, "deletions": 62, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -214,18 +214,15 @@\n //! }\n //! ```\n //!\n-//! [`Rc`]: struct.Rc.html\n-//! [`Weak`]: struct.Weak.html\n-//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-//! [`Cell`]: ../../std/cell/struct.Cell.html\n-//! [`RefCell`]: ../../std/cell/struct.RefCell.html\n-//! [send]: ../../std/marker/trait.Send.html\n+//! [clone]: Clone::clone\n+//! [`Cell`]: core::cell::Cell\n+//! [`RefCell`]: core::cell::RefCell\n+//! [send]: core::marker::Send\n //! [arc]: ../../std/sync/struct.Arc.html\n-//! [`Deref`]: ../../std/ops/trait.Deref.html\n-//! [downgrade]: struct.Rc.html#method.downgrade\n-//! [upgrade]: struct.Weak.html#method.upgrade\n-//! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n+//! [`Deref`]: core::ops::Deref\n+//! [downgrade]: Rc::downgrade\n+//! [upgrade]: Weak::upgrade\n+//! [mutability]: core::cell#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -396,13 +393,11 @@ impl<T> Rc<T> {\n \n     /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n+    /// Otherwise, an [`Err`] is returned with the same `Rc` that was\n     /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// [result]: ../../std/result/enum.Result.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -553,7 +548,7 @@ impl<T: ?Sized> Rc<T> {\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n     /// [`Rc::from_raw`][from_raw].\n     ///\n-    /// [from_raw]: struct.Rc.html#method.from_raw\n+    /// [from_raw]: Rc::from_raw\n     ///\n     /// # Examples\n     ///\n@@ -613,8 +608,8 @@ impl<T: ?Sized> Rc<T> {\n     /// This function is unsafe because improper use may lead to memory unsafety,\n     /// even if the returned `Rc<T>` is never accessed.\n     ///\n-    /// [into_raw]: struct.Rc.html#method.into_raw\n-    /// [transmute]: ../../std/mem/fn.transmute.html\n+    /// [into_raw]: Rc::into_raw\n+    /// [transmute]: core::mem::transmute\n     ///\n     /// # Examples\n     ///\n@@ -645,9 +640,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Creates a new [`Weak`] pointer to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -666,9 +659,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Gets the number of [`Weak`] pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -704,28 +695,24 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`] pointers to\n     /// this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n     /// Returns a mutable reference into the given `Rc`, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n+    /// no other `Rc` or [`Weak`] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when there are other pointers.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [make_mut]: struct.Rc.html#method.make_mut\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [make_mut]: Rc::make_mut\n+    /// [clone]: Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -750,7 +737,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n     ///\n-    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    /// [`get_mut`]: Rc::get_mut\n     ///\n     /// # Safety\n     ///\n@@ -796,7 +783,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -814,9 +801,8 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    /// [`clone`]: Clone::clone\n+    /// [`get_mut`]: Rc::get_mut\n     ///\n     /// # Examples\n     ///\n@@ -1117,8 +1103,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    ///\n-    /// [`Weak`]: ../../std/rc/struct.Weak.html\n     fn drop(&mut self) {\n         unsafe {\n             self.dec_strong();\n@@ -1600,11 +1584,7 @@ impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n ///\n /// The typical way to obtain a `Weak` pointer is to call [`Rc::downgrade`].\n ///\n-/// [`Rc`]: struct.Rc.html\n-/// [`Rc::downgrade`]: struct.Rc.html#method.downgrade\n-/// [`upgrade`]: struct.Weak.html#method.upgrade\n-/// [`Option`]: ../../std/option/enum.Option.html\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`upgrade`]: Weak::upgrade\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n@@ -1631,8 +1611,7 @@ impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`upgrade`]: #method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///\n@@ -1671,7 +1650,7 @@ impl<T> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`null`]: core::ptr::null\n     #[stable(feature = \"rc_as_ptr\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n@@ -1713,8 +1692,8 @@ impl<T> Weak<T> {\n     /// assert_eq!(0, Rc::weak_count(&strong));\n     /// ```\n     ///\n-    /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n+    /// [`from_raw`]: Weak::from_raw\n+    /// [`as_ptr`]: Weak::as_ptr\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n@@ -1761,12 +1740,9 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`into_raw`]: struct.Weak.html#method.into_raw\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`Rc`]: struct.Rc.html\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`new`]: struct.Weak.html#method.new\n-    /// [`forget`]: ../../std/mem/fn.forget.html\n+    /// [`into_raw`]: Weak::into_raw\n+    /// [`upgrade`]: Weak::upgrade\n+    /// [`new`]: Weak::new\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n@@ -1794,9 +1770,6 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// Returns [`None`] if the inner value has since been dropped.\n     ///\n-    /// [`Rc`]: struct.Rc.html\n-    /// [`None`]: ../../std/option/enum.Option.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1829,8 +1802,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong() } else { 0 }\n@@ -1899,7 +1870,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1981,8 +1952,8 @@ impl<T> Default for Weak<T> {\n     /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n     /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html\n-    /// [`upgrade`]: ../../std/rc/struct.Weak.html#method.upgrade\n+    /// [`None`]: Option\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///"}, {"sha": "8ea2c6dc859b274c4afa9764e777a7f488f68a77", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -70,11 +70,7 @@\n //! * Further methods that return iterators are [`.split`], [`.splitn`],\n //!   [`.chunks`], [`.windows`] and more.\n //!\n-//! [`Clone`]: ../../std/clone/trait.Clone.html\n-//! [`Eq`]: ../../std/cmp/trait.Eq.html\n-//! [`Ord`]: ../../std/cmp/trait.Ord.html\n-//! [`Iter`]: struct.Iter.html\n-//! [`Hash`]: ../../std/hash/trait.Hash.html\n+//! [`Hash`]: core::hash::Hash\n //! [`.iter`]: ../../std/primitive.slice.html#method.iter\n //! [`.iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n //! [`.split`]: ../../std/primitive.slice.html#method.split\n@@ -560,7 +556,7 @@ impl [u8] {\n     ///\n     /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n     ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`make_ascii_uppercase`]: u8::make_ascii_uppercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n@@ -577,7 +573,7 @@ impl [u8] {\n     ///\n     /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n     ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`make_ascii_lowercase`]: u8::make_ascii_lowercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> Vec<u8> {"}, {"sha": "4444a7a313298f25e047183b3376d58f68198170", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 43, "deletions": 76, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec629800ecef65504fd042f53c7c734c62ce799a/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=ec629800ecef65504fd042f53c7c734c62ce799a", "patch": "@@ -2,9 +2,7 @@\n \n //! Thread-safe reference-counting pointers.\n //!\n-//! See the [`Arc<T>`][arc] documentation for more details.\n-//!\n-//! [arc]: struct.Arc.html\n+//! See the [`Arc<T>`][Arc] documentation for more details.\n \n use core::any::Any;\n use core::borrow;\n@@ -100,21 +98,21 @@ macro_rules! acquire {\n /// ## Breaking cycles with `Weak`\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n-/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n+/// [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n /// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n /// already been dropped. In other words, `Weak` pointers do not keep the value\n /// inside the allocation alive; however, they *do* keep the allocation\n /// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n-/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n-/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n+/// [`Weak`] is used to break cycles. For example, a tree could have\n+/// strong `Arc` pointers from parent nodes to children, and [`Weak`]\n /// pointers from children back to their parents.\n ///\n /// # Cloning references\n ///\n /// Creating a new reference from an existing reference counted pointer is done using the\n-/// `Clone` trait implemented for [`Arc<T>`][arc] and [`Weak<T>`][weak].\n+/// `Clone` trait implemented for [`Arc<T>`][Arc] and [`Weak<T>`][Weak].\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -139,23 +137,20 @@ macro_rules! acquire {\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// [`Weak<T>`][Weak] does not auto-dereference to `T`, because the inner value may have\n /// already been dropped.\n ///\n-/// [arc]: struct.Arc.html\n-/// [weak]: struct.Weak.html\n-/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+/// [`Rc<T>`]: crate::rc::Rc\n+/// [clone]: Clone::clone\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n-/// [atomic]: ../../std/sync/atomic/index.html\n-/// [`Send`]: ../../std/marker/trait.Send.html\n-/// [`Sync`]: ../../std/marker/trait.Sync.html\n-/// [deref]: ../../std/ops/trait.Deref.html\n-/// [downgrade]: struct.Arc.html#method.downgrade\n-/// [upgrade]: struct.Weak.html#method.upgrade\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+/// [atomic]: core::sync::atomic\n+/// [`Send`]: core::marker::Send\n+/// [`Sync`]: core::marker::Sync\n+/// [deref]: core::ops::Deref\n+/// [downgrade]: Arc::downgrade\n+/// [upgrade]: Weak::upgrade\n+/// [`RefCell<T>`]: core::cell::RefCell\n /// [`std::sync`]: ../../std/sync/index.html\n /// [`Arc::clone(&from)`]: #method.clone\n ///\n@@ -184,7 +179,7 @@ macro_rules! acquire {\n ///\n /// Sharing a mutable [`AtomicUsize`]:\n ///\n-/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n+/// [`AtomicUsize`]: core::sync::atomic::AtomicUsize\n ///\n /// ```no_run\n /// use std::sync::Arc;\n@@ -254,11 +249,7 @@ impl<T: ?Sized> Arc<T> {\n ///\n /// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n ///\n-/// [`Arc`]: struct.Arc.html\n-/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n-/// [`upgrade`]: struct.Weak.html#method.upgrade\n-/// [`Option`]: ../../std/option/enum.Option.html\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`upgrade`]: Weak::upgrade\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n@@ -396,13 +387,11 @@ impl<T> Arc<T> {\n \n     /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n+    /// Otherwise, an [`Err`] is returned with the same `Arc` that was\n     /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// [result]: ../../std/result/enum.Result.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -550,9 +539,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n-    /// [`Arc::from_raw`][from_raw].\n-    ///\n-    /// [from_raw]: struct.Arc.html#method.from_raw\n+    /// [`Arc::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -612,8 +599,8 @@ impl<T: ?Sized> Arc<T> {\n     /// This function is unsafe because improper use may lead to memory unsafety,\n     /// even if the returned `Arc<T>` is never accessed.\n     ///\n-    /// [into_raw]: struct.Arc.html#method.into_raw\n-    /// [transmute]: ../../std/mem/fn.transmute.html\n+    /// [into_raw]: Arc::into_raw\n+    /// [transmute]: core::mem::transmute\n     ///\n     /// # Examples\n     ///\n@@ -646,9 +633,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Creates a new [`Weak`] pointer to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -690,9 +675,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Gets the number of [`Weak`] pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -861,7 +844,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1098,7 +1081,7 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// If there are other `Arc` or [`Weak`] pointers to the same allocation,\n     /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n     /// to ensure unique ownership. This is also referred to as clone-on-write.\n     ///\n@@ -1107,10 +1090,9 @@ impl<T: Clone> Arc<T> {\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Arc.html#method.get_mut\n-    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n+    /// [clone]: Clone::clone\n+    /// [get_mut]: Arc::get_mut\n+    /// [`Rc::make_mut`]: super::rc::Rc::make_mut\n     ///\n     /// # Examples\n     ///\n@@ -1184,18 +1166,16 @@ impl<T: Clone> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Returns a mutable reference into the given `Arc`, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n+    /// no other `Arc` or [`Weak`] pointers to the same allocation.\n     ///\n-    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when there are other pointers.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [option]: ../../std/option/enum.Option.html\n-    /// [make_mut]: struct.Arc.html#method.make_mut\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [make_mut]: Arc::make_mut\n+    /// [clone]: Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -1229,7 +1209,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n     ///\n-    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    /// [`get_mut`]: Arc::get_mut\n     ///\n     /// # Safety\n     ///\n@@ -1315,8 +1295,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    ///\n-    /// [`Weak`]: ../../std/sync/struct.Weak.html\n     #[inline]\n     fn drop(&mut self) {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n@@ -1401,8 +1379,7 @@ impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///\n@@ -1441,7 +1418,7 @@ impl<T> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`null`]: core::ptr::null\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n@@ -1483,8 +1460,8 @@ impl<T> Weak<T> {\n     /// assert_eq!(0, Arc::weak_count(&strong));\n     /// ```\n     ///\n-    /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n+    /// [`from_raw`]: Weak::from_raw\n+    /// [`as_ptr`]: Weak::as_ptr\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n@@ -1530,12 +1507,10 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`new`]: struct.Weak.html#method.new\n-    /// [`into_raw`]: struct.Weak.html#method.into_raw\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`Arc`]: struct.Arc.html\n-    /// [`forget`]: ../../std/mem/fn.forget.html\n+    /// [`new`]: Weak::new\n+    /// [`into_raw`]: Weak::into_raw\n+    /// [`upgrade`]: Weak::upgrade\n+    /// [`forget`]: std::mem::forget\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n@@ -1565,9 +1540,6 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// Returns [`None`] if the inner value has since been dropped.\n     ///\n-    /// [`Arc`]: struct.Arc.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1619,8 +1591,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong.load(SeqCst) } else { 0 }\n@@ -1637,8 +1607,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n     /// `Weak`s pointing to the same allocation.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -1716,7 +1684,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1765,8 +1733,7 @@ impl<T> Default for Weak<T> {\n     /// Calling [`upgrade`] on the return value always\n     /// gives [`None`].\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`upgrade`]: ../../std/sync/struct.Weak.html#method.upgrade\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///"}]}