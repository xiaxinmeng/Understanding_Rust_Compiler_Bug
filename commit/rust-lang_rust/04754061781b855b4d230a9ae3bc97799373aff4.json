{"sha": "04754061781b855b4d230a9ae3bc97799373aff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzU0MDYxNzgxYjg1NWI0ZDIzMGE5YWUzYmM5Nzc5OTM3M2FmZjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-10T21:11:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-12T03:24:11Z"}, "message": "infer: better names, docs", "tree": {"sha": "fec7c4d88e8cb72de9e2ac48afd5f712ed082b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec7c4d88e8cb72de9e2ac48afd5f712ed082b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04754061781b855b4d230a9ae3bc97799373aff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04754061781b855b4d230a9ae3bc97799373aff4", "html_url": "https://github.com/rust-lang/rust/commit/04754061781b855b4d230a9ae3bc97799373aff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04754061781b855b4d230a9ae3bc97799373aff4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9979c0ae45eee5e6446b389b7f5cc12bfaf5519", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9979c0ae45eee5e6446b389b7f5cc12bfaf5519", "html_url": "https://github.com/rust-lang/rust/commit/a9979c0ae45eee5e6446b389b7f5cc12bfaf5519"}], "stats": {"total": 162, "additions": 122, "deletions": 40}, "files": [{"sha": "c47bd4a9f5436f6d5757c63badaa82261504a52e", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 122, "deletions": 40, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/04754061781b855b4d230a9ae3bc97799373aff4/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04754061781b855b4d230a9ae3bc97799373aff4/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=04754061781b855b4d230a9ae3bc97799373aff4", "patch": "@@ -62,22 +62,79 @@ to pump constraints along and reach a fixed point, but it does impose\n some heuristics in the case where the user is relating two type\n variables A <: B.\n \n-The key point when relating type variables is that we do not know what\n-type the variable represents, but we must make some change that will\n-ensure that, whatever types A and B are resolved to, they are resolved\n-to types which have a subtype relation.\n-\n-There are basically two options here:\n-\n-- we can merge A and B.  Basically we make them the same variable.\n-  The lower bound of this new variable is LUB(LB(A), LB(B)) and\n-  the upper bound is GLB(UB(A), UB(B)).\n-\n-- we can adjust the bounds of A and B.  Because we do not allow\n-  type variables to appear in each other's bounds, this only works if A\n-  and B have appropriate bounds.  But if we can ensure that UB(A) <: LB(B),\n-  then we know that whatever happens A and B will be resolved to types with\n-  the appropriate relation.\n+Combining two variables such that variable A will forever be a subtype\n+of variable B is the trickiest part of the algorithm because there is\n+often no right choice---that is, the right choice will depend on\n+future constraints which we do not yet know. The problem comes about\n+because both A and B have bounds that can be adjusted in the future.\n+Let's look at some of the cases that can come up.\n+\n+Imagine, to start, the best case, where both A and B have an upper and\n+lower bound (that is, the bounds are not top nor bot respectively). In\n+that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n+A and B should become, they will forever have the desired subtyping\n+relation.  We can just leave things as they are.\n+\n+### Option 1: Unify\n+\n+However, suppose that A.ub is *not* a subtype of B.lb.  In\n+that case, we must make a decision.  One option is to unify A\n+and B so that they are one variable whose bounds are:\n+\n+    UB = GLB(A.ub, B.ub)\n+    LB = LUB(A.lb, B.lb)\n+\n+(Note that we will have to verify that LB <: UB; if it does not, the\n+types are not intersecting and there is an error) In that case, A <: B\n+holds trivially because A==B.  However, we have now lost some\n+flexibility, because perhaps the user intended for A and B to end up\n+as different types and not the same type.\n+\n+Pictorally, what this does is to take two distinct variables with\n+(hopefully not completely) distinct type ranges and produce one with\n+the intersection.\n+\n+                      B.ub                  B.ub\n+                       /\\                    /\n+               A.ub   /  \\           A.ub   /\n+               /   \\ /    \\              \\ /\n+              /     X      \\              UB\n+             /     / \\      \\            / \\\n+            /     /   /      \\          /   /\n+            \\     \\  /       /          \\  /\n+             \\      X       /             LB\n+              \\    / \\     /             / \\\n+               \\  /   \\   /             /   \\\n+               A.lb    B.lb          A.lb    B.lb\n+\n+\n+### Option 2: Relate UB/LB\n+\n+Another option is to keep A and B as distinct variables but set their\n+bounds in such a way that, whatever happens, we know that A <: B will hold.\n+This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n+are two ways to do that, depicted pictorally here:\n+\n+        Before                Option #1            Option #2\n+\n+                 B.ub                B.ub                B.ub\n+                  /\\                 /  \\                /  \\\n+          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n+          /   \\ /    \\           \\ /     /           \\ /     /\n+         /     X      \\         __UB____/             UB    /\n+        /     / \\      \\       /  |                   |    /\n+       /     /   /      \\     /   |                   |   /\n+       \\     \\  /       /    /(A')|                   |  /\n+        \\      X       /    /     LB            ______LB/\n+         \\    / \\     /    /     / \\           / (A')/ \\\n+          \\  /   \\   /     \\    /   \\          \\    /   \\\n+          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+\n+In these diagrams, UB and LB are defined as before.  As you can see,\n+the new ranges `A'` and `B'` are quite different from the range that\n+would be produced by unifying the variables.\n+\n+### What we do now\n \n Our current technique is to *try* (transactionally) to relate the\n existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n@@ -105,6 +162,17 @@ because the type variable `T` is merged with the type variable for\n `X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n flexibility for `T` to later adjust to accommodate `@int`.\n \n+### What to do when not all bounds are present\n+\n+In the prior discussion we assumed that A.ub was not top and B.lb was\n+not bot.  Unfortunately this is rarely the case.  Often type variables\n+have \"lopsided\" bounds.  For example, if a variable in the program has\n+been initialized but has not been used, then its corresponding type\n+variable will have a lower bound but no upper bound.  When that\n+variable is then used, we would like to know its upper bound---but we\n+don't have one!  In this case we'll do different things depending on\n+how the variable is being used.\n+\n ## Transactional support\n \n Whenever we adjust merge variables or adjust their bounds, we always\n@@ -156,6 +224,17 @@ We have a notion of assignability which differs somewhat from\n subtyping; in particular it may cause region borrowing to occur.  See\n the big comment later in this file on Type Assignment for specifics.\n \n+### In conclusion\n+\n+I showed you three ways to relate `A` and `B`.  There are also more,\n+of course, though I'm not sure if there are any more sensible options.\n+The main point is that there are various options, each of which\n+produce a distinct range of types for `A` and `B`.  Depending on what\n+the correct values for A and B are, one of these options will be the\n+right choice: but of course we don't know the right values for A and B\n+yet, that's what we're trying to find!  In our code, we opt to unify\n+(Option #1).\n+\n # Implementation details\n \n We make use of a trait-like impementation strategy to consolidate\n@@ -842,7 +921,10 @@ impl infer_ctxt {\n         }}}}}\n     }\n \n-    fn vars<V:copy vid, T:copy to_str st>(\n+    /// Ensure that variable A is a subtype of variable B.  This is a\n+    /// subtle and tricky process, as described in detail at the top\n+    /// of this file.\n+    fn var_sub_var<V:copy vid, T:copy to_str st>(\n         vb: &vals_and_bindings<V, bounds<T>>,\n         a_id: V, b_id: V) -> ures {\n \n@@ -955,23 +1037,23 @@ impl infer_ctxt {\n     }\n \n     /// make variable a subtype of T\n-    fn vart<V: copy vid, T: copy to_str st>(\n+    fn var_sub_t<V: copy vid, T: copy to_str st>(\n         vb: &vals_and_bindings<V, bounds<T>>,\n         a_id: V, b: T) -> ures {\n \n         let nde_a = self.get(vb, a_id);\n         let a_id = nde_a.root;\n         let a_bounds = nde_a.possible_types;\n \n-        debug!{\"vart(%s=%s <: %s)\",\n+        debug!{\"var_sub_t(%s=%s <: %s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n                b.to_str(self)};\n         let b_bounds = {lb: none, ub: some(b)};\n         self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds,\n                                       nde_a.rank)\n     }\n \n-    fn vart_integral<V: copy vid>(\n+    fn var_sub_t_integral<V: copy vid>(\n         vb: &vals_and_bindings<V, int_ty_set>,\n         a_id: V, b: ty::t) -> ures {\n \n@@ -992,7 +1074,7 @@ impl infer_ctxt {\n     }\n \n     /// make T a subtype of variable\n-    fn tvar<V: copy vid, T: copy to_str st>(\n+    fn t_sub_var<V: copy vid, T: copy to_str st>(\n         vb: &vals_and_bindings<V, bounds<T>>,\n         a: T, b_id: V) -> ures {\n \n@@ -1001,14 +1083,14 @@ impl infer_ctxt {\n         let b_id = nde_b.root;\n         let b_bounds = nde_b.possible_types;\n \n-        debug!{\"tvar(%s <: %s=%s)\",\n+        debug!{\"t_sub_var(%s <: %s=%s)\",\n                a.to_str(self),\n                b_id.to_str(), b_bounds.to_str(self)};\n         self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds,\n                                       nde_b.rank)\n     }\n \n-    fn tvar_integral<V: copy vid>(\n+    fn t_sub_var_integral<V: copy vid>(\n         vb: &vals_and_bindings<V, int_ty_set>,\n         a: ty::t, b_id: V) -> ures {\n \n@@ -1771,8 +1853,8 @@ fn super_tys<C:combine>(\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().tvar_integral(&self.infcx().ty_var_integral_bindings,\n-                                   a, b_id)\n+        self.infcx().t_sub_var_integral(&self.infcx().ty_var_integral_bindings,\n+                                        a, b_id)\n             .then(|| ok(a) )\n       }\n \n@@ -1914,20 +1996,20 @@ impl sub: combine {\n         do indent {\n             match (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) => {\n-                do self.infcx().vars(&self.region_var_bindings,\n-                                     a_id, b_id).then {\n+                do self.infcx().var_sub_var(&self.region_var_bindings,\n+                                            a_id, b_id).then {\n                     ok(a)\n                 }\n               }\n               (ty::re_var(a_id), _) => {\n-                do self.infcx().vart(&self.region_var_bindings,\n-                                     a_id, b).then {\n+                do self.infcx().var_sub_t(&self.region_var_bindings,\n+                                          a_id, b).then {\n                       ok(a)\n                   }\n               }\n               (_, ty::re_var(b_id)) => {\n-                  do self.infcx().tvar(&self.region_var_bindings,\n-                                       a, b_id).then {\n+                  do self.infcx().t_sub_var(&self.region_var_bindings,\n+                                            a, b_id).then {\n                       ok(a)\n                   }\n               }\n@@ -1988,16 +2070,16 @@ impl sub: combine {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-                self.infcx().vars(&self.ty_var_bindings,\n-                                  a_id, b_id).then(|| ok(a) )\n+                self.infcx().var_sub_var(&self.ty_var_bindings,\n+                                         a_id, b_id).then(|| ok(a) )\n               }\n               (ty::ty_var(a_id), _) => {\n-                self.infcx().vart(&self.ty_var_bindings,\n-                                  a_id, b).then(|| ok(a) )\n+                self.infcx().var_sub_t(&self.ty_var_bindings,\n+                                       a_id, b).then(|| ok(a) )\n               }\n               (_, ty::ty_var(b_id)) => {\n-                self.infcx().tvar(&self.ty_var_bindings,\n-                                  a, b_id).then(|| ok(a) )\n+                self.infcx().t_sub_var(&self.ty_var_bindings,\n+                                       a, b_id).then(|| ok(a) )\n               }\n               (_, ty::ty_bot) => {\n                 err(ty::terr_sorts(b, a))\n@@ -2591,10 +2673,10 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    self.infcx().vars(vb, a_vid, b_vid).then(|| ok(a_t) )\n+    self.infcx().var_sub_var(vb, a_vid, b_vid).then(|| ok(a_t) )\n }\n \n-fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n+fn lattice_var_and_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     self: &L, vb: &vals_and_bindings<V, bounds<T>>,\n     +a_id: V, +b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n@@ -2606,7 +2688,7 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    debug!{\"%s.lattice_vart(%s=%s <: %s)\",\n+    debug!{\"%s.lattice_var_and_t(%s=%s <: %s)\",\n            self.tag(),\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n            b.to_str(self.infcx())};"}]}