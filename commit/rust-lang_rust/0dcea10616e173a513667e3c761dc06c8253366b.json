{"sha": "0dcea10616e173a513667e3c761dc06c8253366b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkY2VhMTA2MTZlMTczYTUxMzY2N2UzYzc2MWRjMDZjODI1MzM2NmI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-21T15:14:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-21T15:14:34Z"}, "message": "Merge #312\n\n312: Completion refactoring r=matklad a=matklad\n\nJust a usual refactoring, turning a rather ad-hoc completion infra into something extensible\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4652bd1f393540f2f5abdaaab367cfb0b46a10d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4652bd1f393540f2f5abdaaab367cfb0b46a10d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dcea10616e173a513667e3c761dc06c8253366b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcea10616e173a513667e3c761dc06c8253366b", "html_url": "https://github.com/rust-lang/rust/commit/0dcea10616e173a513667e3c761dc06c8253366b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dcea10616e173a513667e3c761dc06c8253366b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "463e5af3f2ff54b74e4aeb73e75047c00b6339be", "url": "https://api.github.com/repos/rust-lang/rust/commits/463e5af3f2ff54b74e4aeb73e75047c00b6339be", "html_url": "https://github.com/rust-lang/rust/commit/463e5af3f2ff54b74e4aeb73e75047c00b6339be"}, {"sha": "45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "html_url": "https://github.com/rust-lang/rust/commit/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a"}], "stats": {"total": 1179, "additions": 678, "deletions": 501}, "files": [{"sha": "bf2297e696ccd8097b3e27164460d5c5668df48f", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -734,7 +734,7 @@ dependencies = [\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smol_str 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smol_str 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -959,7 +959,7 @@ version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smol_str 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smol_str 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1092,7 +1092,7 @@ dependencies = [\n \n [[package]]\n name = \"smol_str\"\n-version = \"0.1.7\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1565,7 +1565,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum sha-1 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded\"\n \"checksum slug 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3bc762e6a4b6c6fcaade73e77f9ebc6991b676f88bb2358bddb56560f073373\"\n \"checksum smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b73ea3738b47563803ef814925e69be00799a8c07420be8b996f8e98fb2336db\"\n-\"checksum smol_str 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3ed6f19b800d76574926e458d5f8e2dbea86c2b58c08d33a982448f09ac8d0c\"\n+\"checksum smol_str 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"486a74e9b9fc53373808f7a17e10fc728adcb1fbe272292271d8bea61175e181\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum superslice 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b50b13d42370e0f5fc62eafdd5c2d20065eaf5458dab215ff3e20e63eea96b30\""}, {"sha": "a11e98ac0be8ebdb07c42b91ebabce54ca2f8e1f", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 49, "deletions": 323, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -1,3 +1,4 @@\n+mod completion_item;\n mod reference_completion;\n \n use ra_editor::find_node_at_offset;\n@@ -14,23 +15,16 @@ use hir::source_binder;\n \n use crate::{\n     db,\n-    Cancelable, FilePosition\n+    Cancelable, FilePosition,\n+    completion::completion_item::{Completions, CompletionKind},\n };\n \n-#[derive(Debug)]\n-pub struct CompletionItem {\n-    /// What user sees in pop-up\n-    pub label: String,\n-    /// What string is used for filtering, defaults to label\n-    pub lookup: Option<String>,\n-    /// What is inserted, defaults to label\n-    pub snippet: Option<String>,\n-}\n+pub use crate::completion::completion_item::{CompletionItem, InsertText};\n \n pub(crate) fn completions(\n     db: &db::RootDatabase,\n     position: FilePosition,\n-) -> Cancelable<Option<Vec<CompletionItem>>> {\n+) -> Cancelable<Option<Completions>> {\n     let original_file = db.source_file(position.file_id);\n     // Insert a fake ident to get a valid parse tree\n     let file = {\n@@ -40,30 +34,36 @@ pub(crate) fn completions(\n \n     let module = ctry!(source_binder::module_from_position(db, position)?);\n \n-    let mut res = Vec::new();\n+    let mut acc = Completions::default();\n     let mut has_completions = false;\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        reference_completion::completions(&mut res, db, &module, &file, name_ref)?;\n+        reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(name_ref.syntax(), &mut res);\n+            param_completions(&mut acc, name_ref.syntax());\n         }\n     }\n \n     // Otherwise, if this is a declaration, use heuristics to suggest a name.\n     if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if is_node::<ast::Param>(name.syntax()) {\n             has_completions = true;\n-            param_completions(name.syntax(), &mut res);\n+            param_completions(&mut acc, name.syntax());\n         }\n     }\n-    let res = if has_completions { Some(res) } else { None };\n-    Ok(res)\n+    if !has_completions {\n+        return Ok(None);\n+    }\n+    Ok(Some(acc))\n }\n \n-fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n+/// Complete repeated parametes, both name and type. For example, if all\n+/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n+/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n+/// suggested.\n+fn param_completions(acc: &mut Completions, ctx: SyntaxNodeRef) {\n     let mut params = FxHashMap::default();\n     for node in ctx.ancestors() {\n         let _ = visitor_ctx(&mut params)\n@@ -82,11 +82,10 @@ fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n             }\n         })\n         .for_each(|(label, lookup)| {\n-            acc.push(CompletionItem {\n-                label,\n-                lookup: Some(lookup),\n-                snippet: None,\n-            })\n+            CompletionItem::new(label)\n+                .lookup_by(lookup)\n+                .kind(CompletionKind::Magic)\n+                .add_to(acc)\n         });\n \n     fn process<'a, N: ast::FnDefOwner<'a>>(\n@@ -111,334 +110,61 @@ fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use test_utils::assert_eq_dbg;\n-\n-    use crate::mock_analysis::single_file_with_position;\n+fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind) {\n+    use crate::mock_analysis::{single_file_with_position, analysis_and_position};\n+    let (analysis, position) = if code.contains(\"//-\") {\n+        analysis_and_position(code)\n+    } else {\n+        single_file_with_position(code)\n+    };\n+    let completions = completions(&analysis.imp.db, position).unwrap().unwrap();\n+    completions.assert_match(expected_completions, kind);\n+}\n \n+#[cfg(test)]\n+mod tests {\n     use super::*;\n \n-    fn check_scope_completion(code: &str, expected_completions: &str) {\n-        let (analysis, position) = single_file_with_position(code);\n-        let completions = completions(&analysis.imp.db, position)\n-            .unwrap()\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_none())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        let (analysis, position) = single_file_with_position(code);\n-        let completions = completions(&analysis.imp.db, position)\n-            .unwrap()\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_some())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Baz\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_scope_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            r#\"[]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_self_path() {\n-        check_scope_completion(\n-            r\"\n-            use self::m::<|>;\n-\n-            mod m {\n-                struct Bar;\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-        \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_scope_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-        \",\n-            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n-               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_scope_completion(\n-            r\"\n-            impl S { fn foo(&self) { <|> } }\n-        \",\n-            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_completion_kewords() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n-                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n-                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    fn check_magic_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Magic);\n     }\n \n     #[test]\n     fn test_param_completion_last_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             fn foo(file_id: FileId) {}\n             fn bar(file_id: FileId) {}\n             fn baz(file<|>) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n     }\n \n     #[test]\n     fn test_param_completion_nth_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             fn foo(file_id: FileId) {}\n             fn bar(file_id: FileId) {}\n             fn baz(file<|>, x: i32) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n     }\n \n     #[test]\n     fn test_param_completion_trait_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             pub(crate) trait SourceRoot {\n                 pub fn contains(&self, file_id: FileId) -> bool;\n                 pub fn module_map(&self) -> &ModuleMap;\n                 pub fn lines(&self, file_id: FileId) -> &LineIndex;\n                 pub fn syntax(&self, file<|>)\n             }\n-        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n-               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n-               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_item_snippets() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n-        // );\n-        check_snippet_completion(r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n             \",\n-            r##\"[CompletionItem { label: \"Test function\", lookup: Some(\"tfn\"), snippet: Some(\"#[test]\\nfn ${1:feature}() {\\n$0\\n}\") },\n-                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n+            r#\"file_id \"file_id: FileId\"\"#,\n         );\n     }\n }"}, {"sha": "d5d751759858d4d6b72c07ba88af40ddc50ab7b0", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -0,0 +1,178 @@\n+/// `CompletionItem` describes a single completion variant in the editor pop-up.\n+/// It is basically a POD with various properties. To construct a\n+/// `CompletionItem`, use `new` method and the `Builder` struct.\n+#[derive(Debug)]\n+pub struct CompletionItem {\n+    label: String,\n+    lookup: Option<String>,\n+    snippet: Option<String>,\n+    /// Used only internally in test, to check only specific kind of completion.\n+    kind: CompletionKind,\n+}\n+\n+pub enum InsertText {\n+    PlainText { text: String },\n+    Snippet { text: String },\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum CompletionKind {\n+    /// Parser-based keyword completion.\n+    Keyword,\n+    /// Your usual \"complete all valid identifiers\".\n+    Reference,\n+    /// \"Secret sauce\" completions.\n+    Magic,\n+    Snippet,\n+    Unspecified,\n+}\n+\n+impl CompletionItem {\n+    pub(crate) fn new(label: impl Into<String>) -> Builder {\n+        let label = label.into();\n+        Builder {\n+            label,\n+            lookup: None,\n+            snippet: None,\n+            kind: CompletionKind::Unspecified,\n+        }\n+    }\n+    /// What user sees in pop-up in the UI.\n+    pub fn label(&self) -> &str {\n+        &self.label\n+    }\n+    /// What string is used for filtering.\n+    pub fn lookup(&self) -> &str {\n+        self.lookup\n+            .as_ref()\n+            .map(|it| it.as_str())\n+            .unwrap_or(self.label())\n+    }\n+    /// What is inserted.\n+    pub fn insert_text(&self) -> InsertText {\n+        match &self.snippet {\n+            None => InsertText::PlainText {\n+                text: self.label.clone(),\n+            },\n+            Some(it) => InsertText::Snippet { text: it.clone() },\n+        }\n+    }\n+}\n+\n+/// A helper to make `CompletionItem`s.\n+#[must_use]\n+pub(crate) struct Builder {\n+    label: String,\n+    lookup: Option<String>,\n+    snippet: Option<String>,\n+    kind: CompletionKind,\n+}\n+\n+impl Builder {\n+    pub(crate) fn add_to(self, acc: &mut Completions) {\n+        acc.add(self.build())\n+    }\n+\n+    pub(crate) fn build(self) -> CompletionItem {\n+        CompletionItem {\n+            label: self.label,\n+            lookup: self.lookup,\n+            snippet: self.snippet,\n+            kind: self.kind,\n+        }\n+    }\n+    pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n+        self.lookup = Some(lookup.into());\n+        self\n+    }\n+    pub(crate) fn snippet(mut self, snippet: impl Into<String>) -> Builder {\n+        self.snippet = Some(snippet.into());\n+        self\n+    }\n+    pub(crate) fn kind(mut self, kind: CompletionKind) -> Builder {\n+        self.kind = kind;\n+        self\n+    }\n+}\n+\n+impl Into<CompletionItem> for Builder {\n+    fn into(self) -> CompletionItem {\n+        self.build()\n+    }\n+}\n+\n+/// Represents an in-progress set of completions being built.\n+#[derive(Debug, Default)]\n+pub(crate) struct Completions {\n+    buf: Vec<CompletionItem>,\n+}\n+\n+impl Completions {\n+    pub(crate) fn add(&mut self, item: impl Into<CompletionItem>) {\n+        self.buf.push(item.into())\n+    }\n+    pub(crate) fn add_all<I>(&mut self, items: I)\n+    where\n+        I: IntoIterator,\n+        I::Item: Into<CompletionItem>,\n+    {\n+        items.into_iter().for_each(|item| self.add(item.into()))\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn assert_match(&self, expected: &str, kind: CompletionKind) {\n+        let expected = normalize(expected);\n+        let actual = self.debug_render(kind);\n+        test_utils::assert_eq_text!(expected.as_str(), actual.as_str(),);\n+\n+        /// Normalize the textual representation of `Completions`:\n+        /// replace `;` with newlines, normalize whitespace\n+        fn normalize(expected: &str) -> String {\n+            use ra_syntax::{tokenize, TextUnit, TextRange, SyntaxKind::SEMI};\n+            let mut res = String::new();\n+            for line in expected.trim().lines() {\n+                let line = line.trim();\n+                let mut start_offset: TextUnit = 0.into();\n+                // Yep, we use rust tokenize in completion tests :-)\n+                for token in tokenize(line) {\n+                    let range = TextRange::offset_len(start_offset, token.len);\n+                    start_offset += token.len;\n+                    if token.kind == SEMI {\n+                        res.push('\\n');\n+                    } else {\n+                        res.push_str(&line[range]);\n+                    }\n+                }\n+\n+                res.push('\\n');\n+            }\n+            res\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    fn debug_render(&self, kind: CompletionKind) -> String {\n+        let mut res = String::new();\n+        for c in self.buf.iter() {\n+            if c.kind == kind {\n+                if let Some(lookup) = &c.lookup {\n+                    res.push_str(lookup);\n+                    res.push_str(&format!(\" {:?}\", c.label));\n+                } else {\n+                    res.push_str(&c.label);\n+                }\n+                if let Some(snippet) = &c.snippet {\n+                    res.push_str(&format!(\" {:?}\", snippet));\n+                }\n+                res.push('\\n');\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+impl Into<Vec<CompletionItem>> for Completions {\n+    fn into(self) -> Vec<CompletionItem> {\n+        self.buf\n+    }\n+}"}, {"sha": "c2a650b6d38daa032618edc030b3de962bdb2c82", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 420, "deletions": 92, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -6,21 +6,19 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner},\n     SyntaxKind::*,\n };\n-use     hir::{\n-        self,\n-        FnScopes,\n-        Def,\n-        Path,\n+use hir::{\n+    self,\n+    FnScopes, Def, Path\n };\n \n use crate::{\n     db::RootDatabase,\n-    completion::CompletionItem,\n+    completion::{CompletionItem, Completions, CompletionKind::*},\n     Cancelable\n };\n \n pub(super) fn completions(\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n     db: &RootDatabase,\n     module: &hir::Module,\n     file: &SourceFileNode,\n@@ -41,25 +39,23 @@ pub(super) fn completions(\n             }\n \n             let module_scope = module.scope(db)?;\n-            acc.extend(\n-                module_scope\n-                    .entries()\n-                    .filter(|(_name, res)| {\n-                        // Don't expose this item\n-                        match res.import {\n-                            None => true,\n-                            Some(import) => {\n-                                let range = import.range(db, module.source().file_id());\n-                                !range.is_subrange(&name_ref.syntax().range())\n-                            }\n+            module_scope\n+                .entries()\n+                .filter(|(_name, res)| {\n+                    // Don't expose this item\n+                    match res.import {\n+                        None => true,\n+                        Some(import) => {\n+                            let range = import.range(db, module.source().file_id());\n+                            !range.is_subrange(&name_ref.syntax().range())\n                         }\n-                    })\n-                    .map(|(name, _res)| CompletionItem {\n-                        label: name.to_string(),\n-                        lookup: None,\n-                        snippet: None,\n-                    }),\n-            );\n+                    }\n+                })\n+                .for_each(|(name, _res)| {\n+                    CompletionItem::new(name.to_string())\n+                        .kind(Reference)\n+                        .add_to(acc)\n+                });\n         }\n         NameRefKind::Path(path) => complete_path(acc, db, module, path)?,\n         NameRefKind::BareIdentInMod => {\n@@ -125,30 +121,24 @@ fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n     None\n }\n \n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n+fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions) {\n     let mut shadowed = FxHashSet::default();\n-    acc.extend(\n-        scopes\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n+    scopes\n+        .scope_chain(name_ref.syntax())\n+        .flat_map(|scope| scopes.entries(scope).iter())\n+        .filter(|entry| shadowed.insert(entry.name()))\n+        .for_each(|entry| {\n+            CompletionItem::new(entry.name().to_string())\n+                .kind(Reference)\n+                .add_to(acc)\n+        });\n     if scopes.self_param.is_some() {\n-        acc.push(CompletionItem {\n-            label: \"self\".to_string(),\n-            lookup: None,\n-            snippet: None,\n-        })\n+        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n     }\n }\n \n fn complete_path(\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n     db: &RootDatabase,\n     module: &hir::Module,\n     mut path: Path,\n@@ -166,58 +156,56 @@ fn complete_path(\n         _ => return Ok(()),\n     };\n     let module_scope = target_module.scope(db)?;\n-    let completions = module_scope.entries().map(|(name, _res)| CompletionItem {\n-        label: name.to_string(),\n-        lookup: None,\n-        snippet: None,\n+    module_scope.entries().for_each(|(name, _res)| {\n+        CompletionItem::new(name.to_string())\n+            .kind(Reference)\n+            .add_to(acc)\n     });\n-    acc.extend(completions);\n     Ok(())\n }\n \n-fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"Test function\".to_string(),\n-        lookup: Some(\"tfn\".to_string()),\n-        snippet: Some(\n-            \"#[test]\\n\\\n-             fn ${1:feature}() {\\n\\\n-             $0\\n\\\n-             }\"\n-            .to_string(),\n-        ),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"pub(crate)\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"pub(crate) $0\".to_string()),\n-    })\n+fn complete_mod_item_snippets(acc: &mut Completions) {\n+    CompletionItem::new(\"Test function\")\n+        .lookup_by(\"tfn\")\n+        .snippet(\n+            \"\\\n+#[test]\n+fn ${1:feature}() {\n+    $0\n+}\",\n+        )\n+        .kind(Snippet)\n+        .add_to(acc);\n+    CompletionItem::new(\"pub(crate)\")\n+        .snippet(\"pub(crate) $0\")\n+        .kind(Snippet)\n+        .add_to(acc);\n }\n \n fn complete_expr_keywords(\n     file: &SourceFileNode,\n     fn_def: ast::FnDef,\n     name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n ) {\n-    acc.push(keyword(\"if\", \"if $0 {}\"));\n-    acc.push(keyword(\"match\", \"match $0 {}\"));\n-    acc.push(keyword(\"while\", \"while $0 {}\"));\n-    acc.push(keyword(\"loop\", \"loop {$0}\"));\n+    acc.add(keyword(\"if\", \"if $0 {}\"));\n+    acc.add(keyword(\"match\", \"match $0 {}\"));\n+    acc.add(keyword(\"while\", \"while $0 {}\"));\n+    acc.add(keyword(\"loop\", \"loop {$0}\"));\n \n     if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n         if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n             if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.push(keyword(\"else\", \"else {$0}\"));\n-                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n+                acc.add(keyword(\"else\", \"else {$0}\"));\n+                acc.add(keyword(\"else if\", \"else if $0 {}\"));\n             }\n         }\n     }\n     if is_in_loop_body(name_ref) {\n-        acc.push(keyword(\"continue\", \"continue\"));\n-        acc.push(keyword(\"break\", \"break\"));\n+        acc.add(keyword(\"continue\", \"continue\"));\n+        acc.add(keyword(\"break\", \"break\"));\n     }\n-    acc.extend(complete_return(fn_def, name_ref));\n+    acc.add_all(complete_return(fn_def, name_ref));\n }\n \n fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n@@ -272,23 +260,363 @@ fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<Complet\n     Some(keyword(\"return\", snip))\n }\n \n-fn keyword(kw: &str, snip: &str) -> CompletionItem {\n-    CompletionItem {\n-        label: kw.to_string(),\n-        lookup: None,\n-        snippet: Some(snip.to_string()),\n-    }\n+fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n+    CompletionItem::new(kw)\n+        .kind(Keyword)\n+        .snippet(snippet)\n+        .build()\n }\n \n-fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"pd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"ppd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n-    });\n+fn complete_expr_snippets(acc: &mut Completions) {\n+    CompletionItem::new(\"pd\")\n+        .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n+        .kind(Snippet)\n+        .add_to(acc);\n+    CompletionItem::new(\"ppd\")\n+        .snippet(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\")\n+        .kind(Snippet)\n+        .add_to(acc);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    fn check_keyword_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Keyword);\n+    }\n+\n+    fn check_snippet_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Snippet);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            \"y;x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            \"b;a;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            \"quux;Foo;Baz\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_no_self_use() {\n+        check_reference_completion(\n+            r\"\n+            use foo<|>;\n+            \",\n+            \"\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_self_path() {\n+        check_reference_completion(\n+            r\"\n+            use self::m::<|>;\n+\n+            mod m {\n+                struct Bar;\n+            }\n+            \",\n+            \"Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_nested() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            \"quux;Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_type() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+            \",\n+            \"Foo;x\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_shadowing() {\n+        check_reference_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"bar;foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_self() {\n+        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::Sp<|>\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path_with_braces() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::{Sp<|>};\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path_in_nested_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Spam;\n+                }\n+            }\n+            //- /foo.rs\n+            use crate::{bar::{baz::Sp<|>}};\n+            \",\n+            \"Spam\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            else \"else {$0}\"\n+            else if \"else if $0 {}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0;\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return;\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            continue \"continue\"\n+            break \"break\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_item_snippets() {\n+        // check_snippet_completion(r\"\n+        //     <|>\n+        //     \",\n+        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n+        // );\n+        check_snippet_completion(\n+            r\"\n+            #[cfg(test)]\n+            mod tests {\n+                <|>\n+            }\n+            \",\n+            r##\"\n+            tfn \"Test function\" \"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\"\n+            pub(crate) \"pub(crate) $0\"\n+        \"##,\n+        );\n+    }\n+\n }"}, {"sha": "340f7c78c9c3f07313ae9bdf8dcc1c94449438d5", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -219,7 +219,8 @@ impl AnalysisImpl {\n         self.db.crate_graph().crate_root(crate_id)\n     }\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        completions(&self.db, position)\n+        let completions = completions(&self.db, position)?;\n+        Ok(completions.map(|it| it.into()))\n     }\n     pub fn approximately_resolve_symbol(\n         &self,"}, {"sha": "1c8aa308b6b6de76213e2a6248decb61830c9fe7", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -30,7 +30,7 @@ use crate::{\n };\n \n pub use crate::{\n-    completion::CompletionItem,\n+    completion::{CompletionItem, InsertText},\n };\n pub use ra_editor::{\n     FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable, RunnableKind, StructureNode,"}, {"sha": "938ca797a2d5980cdd530d46c043b2cf8b552deb", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -452,63 +452,3 @@ fn test_find_all_refs_for_fn_param() {\n     let refs = get_all_refs(code);\n     assert_eq!(refs.len(), 2);\n }\n-\n-#[test]\n-fn test_complete_crate_path() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct Spam;\n-        //- /foo.rs\n-        use crate::Sp<|>\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n-            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}\n-\n-#[test]\n-fn test_complete_crate_path_with_braces() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct Spam;\n-        //- /foo.rs\n-        use crate::{Sp<|>};\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n-            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}\n-\n-#[test]\n-fn test_complete_crate_path_in_nested_tree() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        pub mod bar {\n-            pub mod baz {\n-                pub struct Spam;\n-            }\n-        }\n-        //- /foo.rs\n-        use crate::{bar::{baz::Sp<|>}};\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}"}, {"sha": "2dfeb061a1486099cf7bb003d3d32a0436d7ef38", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -8,7 +8,7 @@ use languageserver_types::{\n     PrepareRenameResponse, RenameParams, SymbolInformation, TextDocumentIdentifier, TextEdit,\n     WorkspaceEdit, ParameterInformation, ParameterLabel, SignatureInformation, Hover, HoverContents,\n };\n-use ra_analysis::{FileId, FoldKind, Query, RunnableKind, FilePosition};\n+use ra_analysis::{FileId, FoldKind, Query, RunnableKind, FilePosition, InsertText};\n use ra_syntax::{TextUnit, text_utils::intersect};\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n use rustc_hash::FxHashMap;\n@@ -423,15 +423,21 @@ pub fn handle_completion(\n         .into_iter()\n         .map(|item| {\n             let mut res = CompletionItem {\n-                label: item.label,\n-                filter_text: item.lookup,\n+                label: item.label().to_string(),\n+                filter_text: Some(item.lookup().to_string()),\n                 ..Default::default()\n             };\n-            if let Some(snip) = item.snippet {\n-                res.insert_text = Some(snip);\n-                res.insert_text_format = Some(InsertTextFormat::Snippet);\n-                res.kind = Some(CompletionItemKind::Keyword);\n-            };\n+            match item.insert_text() {\n+                InsertText::PlainText { text } => {\n+                    res.insert_text = Some(text);\n+                    res.insert_text_format = Some(InsertTextFormat::PlainText);\n+                }\n+                InsertText::Snippet { text } => {\n+                    res.insert_text = Some(text);\n+                    res.insert_text_format = Some(InsertTextFormat::Snippet);\n+                    res.kind = Some(CompletionItemKind::Keyword);\n+                }\n+            }\n             res\n         })\n         .collect();"}, {"sha": "beb936c616d3a5d7cf0cb9517a514caf5bade9e5", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcea10616e173a513667e3c761dc06c8253366b/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=0dcea10616e173a513667e3c761dc06c8253366b", "patch": "@@ -10,22 +10,20 @@ pub const CURSOR_MARKER: &str = \"<|>\";\n \n #[macro_export]\n macro_rules! assert_eq_text {\n-    ($expected:expr, $actual:expr) => {{\n-        let expected = $expected;\n-        let actual = $actual;\n-        if expected != actual {\n-            let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n-            println!(\"Expected:\\n{}\\n\\nActual:\\n{}\\nDiff:{}\\n\", expected, actual, changeset);\n-            panic!(\"text differs\");\n-        }\n-    }};\n+    ($expected:expr, $actual:expr) => {\n+        assert_eq_text!($expected, $actual,)\n+    };\n     ($expected:expr, $actual:expr, $($tt:tt)*) => {{\n         let expected = $expected;\n         let actual = $actual;\n         if expected != actual {\n-            let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n-            println!(\"Expected:\\n{}\\n\\nActual:\\n{}\\n\\nDiff:\\n{}\\n\", expected, actual, changeset);\n-            println!($($tt)*);\n+            if expected.trim() == actual.trim() {\n+                eprintln!(\"Expected:\\n{:?}\\n\\nActual:\\n{:?}\\n\\nWhitespace difference\\n\", expected, actual);\n+            } else {\n+                let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n+                eprintln!(\"Expected:\\n{}\\n\\nActual:\\n{}\\n\\nDiff:\\n{}\\n\", expected, actual, changeset);\n+            }\n+            eprintln!($($tt)*);\n             panic!(\"text differs\");\n         }\n     }};"}]}