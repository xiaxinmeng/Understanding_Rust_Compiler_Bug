{"sha": "8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkY2ExYjhmNjE4ZmRlYzNmMWIzNTRkOWJhZmEwMWIzMmVjYzhhYjY=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-18T22:40:33Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection: Collecting Applicability assign values", "tree": {"sha": "c50dfd2af941bb9c3ec8ff8aa3f620ec0029b780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50dfd2af941bb9c3ec8ff8aa3f620ec0029b780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "html_url": "https://github.com/rust-lang/rust/commit/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d702f88ded863b9cde999f1850b32c6531fe11", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d702f88ded863b9cde999f1850b32c6531fe11", "html_url": "https://github.com/rust-lang/rust/commit/68d702f88ded863b9cde999f1850b32c6531fe11"}], "stats": {"total": 302, "additions": 248, "deletions": 54}, "files": [{"sha": "e22aa285f175649ce2b76cf62569761377039e38", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 195, "deletions": 54, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "patch": "@@ -24,7 +24,7 @@ use if_chain::if_chain;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::{self as hir, ExprKind, Item, ItemKind, Mutability};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n-use rustc_middle::ty::BorrowKind;\n+use rustc_middle::ty::{BorrowKind, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n use rustc_trait_selection::infer::TyCtxtInferExt;\n@@ -37,7 +37,8 @@ use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n use crate::utils::{\n-    last_path_segment, match_function_call, match_type, path_to_local_id, paths, span_lint, walk_ptrs_ty_depth,\n+    get_enclosing_body, get_parent_expr_for_hir, last_path_segment, match_function_call, match_qpath, match_type,\n+    path_to_local_id, paths, span_lint, walk_ptrs_ty_depth,\n };\n \n /// This is the output file of the lint collector.\n@@ -147,6 +148,12 @@ struct SerializableSpan {\n     line: usize,\n }\n \n+impl std::fmt::Display for SerializableSpan {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}:{}\", self.path.rsplit('/').next().unwrap_or_default(), self.line)\n+    }\n+}\n+\n impl SerializableSpan {\n     fn from_item(cx: &LateContext<'_>, item: &Item<'_>) -> Self {\n         Self::from_span(cx, item.ident.span)\n@@ -285,52 +292,54 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n     /// );\n     /// ```\n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx hir::Local<'tcx>) {\n-        if let Some(tc) = cx.maybe_typeck_results() {\n-            // TODO xFrednet 2021-02-14: support nested applicability (only in tuples)\n-            let local_ty = if let Some(ty) = local.ty {\n-                hir_ty_to_ty(cx.tcx, ty)\n-            } else if let Some(init) = local.init {\n-                tc.expr_ty(init)\n-            } else {\n-                return;\n-            };\n-\n-            if_chain! {\n-                if match_type(cx, local_ty, &paths::APPLICABILITY);\n-                if let Some(body) = get_parent_body(cx, local.hir_id);\n-                then {\n-                    let span = SerializableSpan::from_span(cx, local.span);\n-                    let local_str = crate::utils::snippet(cx, local.span, \"_\");\n-                    let value_life = format!(\"{} -- {}:{}\\n\", local_str, span.path.rsplit('/').next().unwrap_or_default(), span.line);\n-                    let value_hir_id = local.pat.hir_id;\n-                    let mut tracker = ValueTracker {cx, value_hir_id, value_life};\n-\n-                    cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let body_owner_id = cx.tcx.hir().body_owner_def_id(body.id());\n-                        ExprUseVisitor::new(\n-                            &mut tracker,\n-                            &infcx,\n-                            body_owner_id,\n-                            cx.param_env,\n-                            cx.typeck_results()\n-                        )\n-                        .consume_body(body);\n-                    });\n-\n-                    log_to_file(&tracker.value_life);\n-                    lint_collection_error_span(cx, local.span, \"Applicability value found\");\n+        if_chain! {\n+            if let Some(local_ty) = get_local_type(cx, local);\n+            if match_type(cx, local_ty, &paths::APPLICABILITY);\n+            if let Some(body) = get_enclosing_body(cx, local.hir_id);\n+            then {\n+                // TODO xFrednet: 2021-02-19: Remove debug code\n+                let span = SerializableSpan::from_span(cx, local.span);\n+                let local_str = crate::utils::snippet(cx, local.span, \"_\");\n+                log_to_file(&format!(\"{} -- {}\\n\", local_str, span));\n+                \n+                let value_hir_id = local.pat.hir_id;\n+                let mut tracker = ValueTracker::new(cx, value_hir_id);\n+                if let Some(init_expr) = local.init {\n+                    tracker.process_assign_expr(init_expr)\n                 }\n+\n+                // TODO xFrednet 2021-02-18: Support nested bodies\n+                // Note: The `ExprUseVisitor` only searches though one body, this means that values\n+                // references in nested bodies like closures are not found by this simple visitor.\n+                cx.tcx.infer_ctxt().enter(|infcx| {\n+                    let body_owner_id = cx.tcx.hir().body_owner_def_id(body.id());\n+                    ExprUseVisitor::new(\n+                        &mut tracker,\n+                        &infcx,\n+                        body_owner_id,\n+                        cx.param_env,\n+                        cx.typeck_results()\n+                    )\n+                    .consume_body(body);\n+                });\n+\n+                log_to_file(&format!(\"{:?}\\n\", tracker.value_mutations));\n             }\n         }\n     }\n }\n \n-fn get_parent_body<'a, 'tcx>(cx: &'a LateContext<'tcx>, id: hir::HirId) -> Option<&'tcx hir::Body<'tcx>> {\n-    let map = cx.tcx.hir();\n+fn get_local_type<'a>(cx: &'a LateContext<'_>, local: &'a hir::Local<'_>) -> Option<Ty<'a>> {\n+    // TODO xFrednet 2021-02-14: support nested applicability (only in tuples)\n+    if let Some(tc) = cx.maybe_typeck_results() {\n+        if let Some(ty) = local.ty {\n+            return Some(hir_ty_to_ty(cx.tcx, ty));\n+        } else if let Some(init) = local.init {\n+            return Some(tc.expr_ty(init));\n+        }\n+    }\n \n-    map.parent_iter(id)\n-        .find_map(|(parent, _)| map.maybe_body_owned_by(parent))\n-        .map(|body| map.body(body))\n+    None\n }\n \n fn sym_to_string(sym: Symbol) -> String {\n@@ -429,42 +438,174 @@ fn extract_emission_info<'tcx>(cx: &LateContext<'tcx>, args: &[hir::Expr<'_>]) -\n     })\n }\n \n-struct ValueTracker<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n+#[allow(dead_code)]\n+struct ValueTracker<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n     value_hir_id: hir::HirId,\n-    value_life: String,\n+    value_mutations: Vec<ApplicabilityModifier<'hir>>,\n }\n \n-impl<'a, 'tcx> ValueTracker<'a, 'tcx> {\n+impl<'a, 'hir> ValueTracker<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>, value_hir_id: hir::HirId) -> Self {\n+        Self {\n+            cx,\n+            value_hir_id,\n+            value_mutations: Vec::new(),\n+        }\n+    }\n+\n     fn is_value_expr(&self, expr_id: hir::HirId) -> bool {\n         match self.cx.tcx.hir().find(expr_id) {\n             Some(hir::Node::Expr(expr)) => path_to_local_id(expr, self.value_hir_id),\n             _ => false,\n         }\n     }\n+\n+    /// This function extracts possible `ApplicabilityModifier` from an assign statement like this:\n+    ///\n+    /// ```rust, ignore\n+    /// //          vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv The expression to process\n+    /// let value = Applicability::MachineApplicable;\n+    /// ```\n+    fn process_assign_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        // This is a bit more complicated. I'll therefor settle on the simple solution of\n+        // simplifying the cases we support.\n+        match &expr.kind {\n+            hir::ExprKind::Call(func_expr, ..) => {\n+                // We only deal with resolved paths as this is the usual case. Other expression kinds like closures\n+                // etc. are hard to track but might be a worthy improvement in the future\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func_expr.kind {\n+                    self.value_mutations.push(ApplicabilityModifier::Producer(path));\n+                } else {\n+                    let msg = format!(\n+                        \"Unsupported Call expression at: {}\",\n+                        SerializableSpan::from_span(self.cx, func_expr.span)\n+                    );\n+                    self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n+                }\n+            },\n+            hir::ExprKind::MethodCall(..) => {\n+                let msg = format!(\n+                    \"Unsupported MethodCall expression at: {}\",\n+                    SerializableSpan::from_span(self.cx, expr.span)\n+                );\n+                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n+            },\n+            // We can ignore ifs without an else block because those can't be used as an assignment\n+            hir::ExprKind::If(_con, if_block, Some(else_block)) => {\n+                self.process_assign_expr(if_block);\n+                self.process_assign_expr(else_block);\n+            },\n+            hir::ExprKind::Match(_expr, arms, _) => {\n+                for arm in *arms {\n+                    self.process_assign_expr(arm.body);\n+                }\n+            },\n+            hir::ExprKind::Loop(block, ..) | hir::ExprKind::Block(block, ..) => {\n+                if let Some(block_expr) = block.expr {\n+                    self.process_assign_expr(block_expr);\n+                }\n+            },\n+            hir::ExprKind::Path(path) => {\n+                for enum_value in &paths::APPLICABILITY_VALUES {\n+                    if match_qpath(path, enum_value) {\n+                        self.value_mutations\n+                            .push(ApplicabilityModifier::ConstValue(enum_value[2].to_string()));\n+                    }\n+                }\n+            },\n+            // hir::ExprKind::Field(expr, ident) => not supported\n+            // hir::ExprKind::Index(expr, expr) => not supported\n+            _ => {\n+                let msg = format!(\n+                    \"Unexpected expression at: {}\",\n+                    SerializableSpan::from_span(self.cx, expr.span)\n+                );\n+                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n+            },\n+        }\n+    }\n }\n \n-impl<'a, 'tcx> Delegate<'tcx> for ValueTracker<'a, 'tcx> {\n-    fn consume(&mut self, _place_with_id: &PlaceWithHirId<'tcx>, expr_id: hir::HirId, _: ConsumeMode) {\n+impl<'a, 'hir> Delegate<'hir> for ValueTracker<'a, 'hir> {\n+    fn consume(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, _: ConsumeMode) {\n         if self.is_value_expr(expr_id) {\n             // TODO xFrednet 2021-02-17: Check if lint emission and extract lint ID\n-            todo!();\n+            if let Some(hir::Node::Expr(expr)) = self.cx.tcx.hir().find(expr_id) {\n+                let span = SerializableSpan::from_span(self.cx, expr.span);\n+                log_to_file(&format!(\"- consume {}\\n\", span));\n+            }\n         }\n     }\n \n-    fn borrow(&mut self, _place_with_id: &PlaceWithHirId<'tcx>, expr_id: hir::HirId, bk: BorrowKind) {\n+    fn borrow(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, bk: BorrowKind) {\n         if self.is_value_expr(expr_id) {\n             if let BorrowKind::MutBorrow = bk {\n                 // TODO xFrednet 2021-02-17: Save the function\n-                todo!();\n+                if let Some(hir::Node::Expr(expr)) = self.cx.tcx.hir().find(expr_id) {\n+                    let span = SerializableSpan::from_span(self.cx, expr.span);\n+                    log_to_file(&format!(\"- &mut     {}\\n\", span));\n+                }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, _assignee_place: &PlaceWithHirId<'tcx>, expr_id: hir::HirId) {\n-        if self.is_value_expr(expr_id) {\n-            // TODO xFrednet 2021-02-17: Save the new value as a mutation\n-            todo!();\n+    fn mutate(&mut self, _assignee_place: &PlaceWithHirId<'hir>, expr_id: hir::HirId) {\n+        if_chain! {\n+            if self.is_value_expr(expr_id);\n+            if let Some(expr) = get_parent_expr_for_hir(self.cx, expr_id);\n+            if let hir::ExprKind::Assign(_value_expr, assign_expr, ..) = expr.kind;\n+            then {\n+                self.process_assign_expr(assign_expr);\n+            }\n         }\n     }\n }\n+\n+/// The life of a value in Rust is a true adventure. These are the corner stones of such a\n+/// fairy tale. Let me introduce you to the possible stepping stones a value might have in\n+/// in our crazy word:\n+#[derive(Debug)]\n+#[allow(dead_code)]\n+enum ApplicabilityModifier<'hir> {\n+    Unknown(String),\n+    /// A simple constant value.\n+    ///\n+    /// This is the actual character of a value. It's baseline. This only defines where the value\n+    /// started. As in real life it can still change and fully decide who it wants to be.\n+    ConstValue(String),\n+    /// A producer is a function that returns an applicability value.\n+    ///\n+    /// This is the heritage of this value. This value comes from a long family tree and is not\n+    /// just a black piece of paper. The evaluation of this stepping stone needs additional\n+    /// context. We therefore only add a reference. This reference will later be used to ask\n+    /// the librarian about the possible initial character that this value might have.\n+    Producer(&'hir hir::Path<'hir>),\n+    /// A modifier that takes the given applicability and might modify it\n+    ///\n+    /// What would an RPG be without it's NPCs. The special thing about modifiers is that they can\n+    /// be actively interested in the story of the value and might make decisions based on the\n+    /// character of this hero. This means that a modifier doesn't just force its way into the life\n+    /// of our hero but it actually asks him how he's been. The possible modification is a result\n+    /// of the situation.\n+    ///\n+    /// Take this part of our heroes life very seriously!\n+    Modifier(&'hir hir::Path<'hir>),\n+    /// The actual emission of a lint\n+    ///\n+    /// All good things must come to an end. Even the life of your awesome applicability hero. He\n+    /// was the bravest soul that has ever wondered this earth. Songs will be written about his\n+    /// heroic deeds. Castles will be named after him and the world how we know it will never be\n+    /// the same!\n+    ///\n+    /// Is this a happy ending? Did he archive what he wanted in his life? Yes, YES, he has lived a\n+    /// life and he will continue to live in all the lint suggestions that can be applied or just\n+    /// displayed by Clippy. He might be no more, but his legacy will serve generations to come.\n+    LintEmit(LintEmission),\n+}\n+\n+#[derive(Debug)]\n+struct LintEmission {\n+    lint: String,\n+    is_multi_line_sugg: bool,\n+}"}, {"sha": "46f58b788e6eb64d4bbecdc8062464b1464a57ea", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "patch": "@@ -7,6 +7,13 @@\n pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n #[cfg(feature = \"metadata-collector-lint\")]\n pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n+    [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n+];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];"}, {"sha": "75fae623e61098086a34c29273c9d5c528aebd1c", "filename": "tests/ui-internal/metadata-collector/track_applicability_value.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmetadata-collector%2Ftrack_applicability_value.rs?ref=8dca1b8f618fdec3f1b354d9bafa01b32ecc8ab6", "patch": "@@ -0,0 +1,46 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_ast;\n+extern crate rustc_errors;\n+extern crate rustc_lint;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+\n+use rustc_ast::ast::Expr;\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+fn producer_fn() -> Applicability {\n+    Applicability::MachineApplicable\n+}\n+\n+fn modifier_fn(applicability: &mut Applicability) {\n+    if let Applicability::MaybeIncorrect = applicability {\n+        *applicability = Applicability::HasPlaceholders;\n+    }\n+}\n+\n+struct Muh;\n+\n+impl Muh {\n+    fn producer_method() -> Applicability {\n+        Applicability::MachineApplicable\n+    }\n+}\n+\n+fn main() {\n+    let mut applicability = producer_fn();\n+    applicability = Applicability::MachineApplicable;\n+    applicability = Muh::producer_method();\n+\n+    applicability = if true {\n+        Applicability::HasPlaceholders\n+    } else {\n+        Applicability::MaybeIncorrect\n+    };\n+\n+    modifier_fn(&mut applicability);\n+}"}]}