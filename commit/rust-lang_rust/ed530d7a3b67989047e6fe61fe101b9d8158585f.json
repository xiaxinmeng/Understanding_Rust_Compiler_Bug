{"sha": "ed530d7a3b67989047e6fe61fe101b9d8158585f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNTMwZDdhM2I2Nzk4OTA0N2U2ZmU2MWZlMTAxYjlkODE1ODU4NWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T22:41:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T22:41:16Z"}, "message": "auto merge of #21008 : huonw/rust/trait-suggestions, r=nikomatsakis\n\nFor a call like `foo.bar()` where the method `bar` can't be resolved,\r\nthe compiler will search for traits that have methods with name `bar` to\r\ngive a more informative error, providing a list of possibilities.\r\n\r\nCloses #7643.", "tree": {"sha": "a6e4e69958ee65cfc746147a3f6d9d01f860c418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6e4e69958ee65cfc746147a3f6d9d01f860c418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed530d7a3b67989047e6fe61fe101b9d8158585f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed530d7a3b67989047e6fe61fe101b9d8158585f", "html_url": "https://github.com/rust-lang/rust/commit/ed530d7a3b67989047e6fe61fe101b9d8158585f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed530d7a3b67989047e6fe61fe101b9d8158585f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653e6880c96f858ff1d9a42b525bf3a903ae94c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/653e6880c96f858ff1d9a42b525bf3a903ae94c8", "html_url": "https://github.com/rust-lang/rust/commit/653e6880c96f858ff1d9a42b525bf3a903ae94c8"}, {"sha": "0a55aacc077f26f5703035f7c5395d083db3d355", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a55aacc077f26f5703035f7c5395d083db3d355", "html_url": "https://github.com/rust-lang/rust/commit/0a55aacc077f26f5703035f7c5395d083db3d355"}], "stats": {"total": 601, "additions": 495, "deletions": 106}, "files": [{"sha": "8a7c7b38287ecf4e2fb09b0b18bed0131daf4089", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -174,6 +174,9 @@ impl Session {\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().fileline_note(sp, msg)\n     }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.diagnostic().fileline_help(sp, msg)\n+    }\n     pub fn note(&self, msg: &str) {\n         self.diagnostic().handler().note(msg)\n     }"}, {"sha": "345bc5fd2aa60772cb367f8fce554789034013ab", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 104, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -12,15 +12,14 @@\n \n use astconv::AstConv;\n use check::{FnCtxt};\n-use check::{impl_self_ty};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n use middle::subst;\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::infer;\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n use std::rc::Rc;\n use syntax::ast::{DefId};\n@@ -30,14 +29,18 @@ use syntax::codemap::Span;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n+pub use self::suggest::{report_error, AllTraitsVec};\n+\n mod confirm;\n mod doc;\n mod probe;\n+mod suggest;\n \n pub enum MethodError {\n     // Did not find an applicable method, but we did find various\n-    // static methods that may apply.\n-    NoMatch(Vec<CandidateSource>),\n+    // static methods that may apply, as well as a list of\n+    // not-in-scope traits which may work.\n+    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>),\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n@@ -63,7 +66,7 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n         Ok(_) => true,\n-        Err(NoMatch(_)) => false,\n+        Err(NoMatch(_, _)) => false,\n         Err(Ambiguity(_)) => true,\n     }\n }\n@@ -294,105 +297,6 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n-pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                              span: Span,\n-                              rcvr_ty: Ty<'tcx>,\n-                              method_name: ast::Name,\n-                              error: MethodError)\n-{\n-    match error {\n-        NoMatch(static_sources) => {\n-            let cx = fcx.tcx();\n-            let method_ustring = method_name.user_string(cx);\n-\n-            // True if the type is a struct and contains a field with\n-            // the same name as the not-found method\n-            let is_field = match rcvr_ty.sty {\n-                ty_struct(did, _) =>\n-                    ty::lookup_struct_fields(cx, did)\n-                        .iter()\n-                        .any(|f| f.name.user_string(cx) == method_ustring),\n-                _ => false\n-            };\n-\n-            fcx.type_error_message(\n-                span,\n-                |actual| {\n-                    format!(\"type `{}` does not implement any \\\n-                             method in scope named `{}`\",\n-                            actual,\n-                            method_ustring)\n-                },\n-                rcvr_ty,\n-                None);\n-\n-            // If the method has the name of a field, give a help note\n-            if is_field {\n-                cx.sess.span_note(span,\n-                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring)[]);\n-            }\n-\n-            if static_sources.len() > 0 {\n-                fcx.tcx().sess.fileline_note(\n-                    span,\n-                    \"found defined static methods, maybe a `self` is missing?\");\n-\n-                report_candidates(fcx, span, method_name, static_sources);\n-            }\n-        }\n-\n-        Ambiguity(sources) => {\n-            span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable methods in scope\");\n-\n-            report_candidates(fcx, span, method_name, sources);\n-        }\n-    }\n-\n-    fn report_candidates(fcx: &FnCtxt,\n-                         span: Span,\n-                         method_name: ast::Name,\n-                         mut sources: Vec<CandidateSource>) {\n-        sources.sort();\n-        sources.dedup();\n-\n-        for (idx, source) in sources.iter().enumerate() {\n-            match *source {\n-                ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the method, if local to crate, else\n-                    // the impl, if local to crate (method may be defaulted), else the call site.\n-                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n-                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n-\n-                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n-\n-                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n-                        None => format!(\"\"),\n-                        Some(trait_ref) => format!(\" of the trait `{}`\",\n-                                                   ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n-                    };\n-\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                               idx + 1u,\n-                               insertion,\n-                               impl_ty.user_string(fcx.tcx()));\n-                }\n-                TraitSource(trait_did) => {\n-                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1u,\n-                               ty::item_path_str(fcx.tcx(), trait_did));\n-                }\n-            }\n-        }\n-    }\n-}\n \n /// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n /// index (or `None`, if no such method)."}, {"sha": "9df8875152e3b94e0f9bc40434f9005597a0bb49", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -11,6 +11,7 @@\n use super::{MethodError,Ambiguity,NoMatch};\n use super::MethodIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n+use super::suggest;\n \n use check;\n use check::{FnCtxt, NoPreference};\n@@ -25,6 +26,7 @@ use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use std::collections::HashSet;\n+use std::mem;\n use std::rc::Rc;\n use util::ppaux::Repr;\n \n@@ -42,6 +44,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n     static_candidates: Vec<CandidateSource>,\n+    all_traits_search: bool,\n }\n \n struct CandidateStep<'tcx> {\n@@ -127,7 +130,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // take place in the `fcx.infcx().probe` below.\n     let steps = match create_steps(fcx, span, self_ty) {\n         Some(steps) => steps,\n-        None => return Err(NoMatch(Vec::new())),\n+        None => return Err(NoMatch(Vec::new(), Vec::new())),\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -208,9 +211,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n+            all_traits_search: false,\n         }\n     }\n \n+    fn reset(&mut self) {\n+        self.inherent_candidates.clear();\n+        self.extension_candidates.clear();\n+        self.impl_dups.clear();\n+        self.static_candidates.clear();\n+    }\n+\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n@@ -446,6 +457,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_extension_candidates_for_all_traits(&mut self) {\n+        let mut duplicates = HashSet::new();\n+        for trait_info in suggest::all_traits(self.fcx.ccx) {\n+            if duplicates.insert(trait_info.def_id) {\n+                self.assemble_extension_candidates_for_trait(trait_info.def_id)\n+            }\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: ast::DefId) {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n@@ -715,7 +735,47 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n         }\n \n-        Err(NoMatch(self.static_candidates))\n+        let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+\n+        let out_of_scope_traits = if !self.all_traits_search {\n+            // things failed, and we haven't yet looked through all\n+            // traits, so lets do that now:\n+            self.reset();\n+            self.all_traits_search = true;\n+\n+            let span = self.span;\n+            let tcx = self.tcx();\n+\n+            self.assemble_extension_candidates_for_all_traits();\n+\n+            match self.pick() {\n+                Ok(p) => vec![p.method_ty.container.id()],\n+                Err(Ambiguity(v)) => v.into_iter().map(|source| {\n+                    match source {\n+                        TraitSource(id) => id,\n+                        ImplSource(impl_id) => {\n+                            match ty::trait_id_of_impl(tcx, impl_id) {\n+                                Some(id) => id,\n+                                None => tcx.sess.span_bug(span,\n+                                                          \"found inherent method when looking \\\n+                                                           at traits\")\n+                            }\n+                        }\n+                    }\n+                }).collect(),\n+                // it'd be really weird for this assertion to trigger,\n+                // given the `vec![]` in the else branch below\n+                Err(NoMatch(_, others)) => {\n+                    assert!(others.is_empty());\n+                    vec![]\n+                }\n+            }\n+        } else {\n+            // we've just looked through all traits and didn't find\n+            // anything at all.\n+            vec![]\n+        };\n+        Err(NoMatch(static_candidates, out_of_scope_traits))\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {"}, {"sha": "013c6e2f953a07f4d931106b3fbd87aa0e54afcd", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Give useful errors and suggestions to users when a method can't be\n+//! found or is otherwise invalid.\n+\n+use CrateCtxt;\n+\n+use astconv::AstConv;\n+use check::{self, FnCtxt};\n+use middle::ty::{self, Ty};\n+use middle::def;\n+use metadata::{csearch, cstore, decoder};\n+use util::ppaux::UserString;\n+\n+use syntax::{ast, ast_util};\n+use syntax::codemap::Span;\n+\n+use std::cell;\n+use std::cmp::Ordering;\n+\n+use super::{MethodError, CandidateSource, impl_method, trait_method};\n+\n+pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              rcvr_ty: Ty<'tcx>,\n+                              method_name: ast::Name,\n+                              error: MethodError)\n+{\n+    match error {\n+        MethodError::NoMatch(static_sources, out_of_scope_traits) => {\n+            let cx = fcx.tcx();\n+            let method_ustring = method_name.user_string(cx);\n+\n+            // True if the type is a struct and contains a field with\n+            // the same name as the not-found method\n+            let is_field = match rcvr_ty.sty {\n+                ty::ty_struct(did, _) =>\n+                    ty::lookup_struct_fields(cx, did)\n+                        .iter()\n+                        .any(|f| f.name.user_string(cx) == method_ustring),\n+                _ => false\n+            };\n+\n+            fcx.type_error_message(\n+                span,\n+                |actual| {\n+                    format!(\"type `{}` does not implement any \\\n+                             method in scope named `{}`\",\n+                            actual,\n+                            method_ustring)\n+                },\n+                rcvr_ty,\n+                None);\n+\n+            // If the method has the name of a field, give a help note\n+            if is_field {\n+                cx.sess.span_note(span,\n+                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring)[]);\n+            }\n+\n+            if static_sources.len() > 0 {\n+                fcx.tcx().sess.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n+\n+                report_candidates(fcx, span, method_name, static_sources);\n+            }\n+\n+            suggest_traits_to_import(fcx, span, rcvr_ty, method_name, out_of_scope_traits)\n+        }\n+\n+        MethodError::Ambiguity(sources) => {\n+            span_err!(fcx.sess(), span, E0034,\n+                      \"multiple applicable methods in scope\");\n+\n+            report_candidates(fcx, span, method_name, sources);\n+        }\n+    }\n+\n+    fn report_candidates(fcx: &FnCtxt,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         mut sources: Vec<CandidateSource>) {\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                CandidateSource::ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the method, if local to crate, else\n+                    // the impl, if local to crate (method may be defaulted), else the call site.\n+                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+\n+                    let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n+\n+                    let insertion = match ty::impl_trait_ref(fcx.tcx(), impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => format!(\" of the trait `{}`\",\n+                                                   ty::item_path_str(fcx.tcx(),\n+                                                                     trait_ref.def_id)),\n+                    };\n+\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                               idx + 1u,\n+                               insertion,\n+                               impl_ty.user_string(fcx.tcx()));\n+                }\n+                CandidateSource::TraitSource(trait_did) => {\n+                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1u,\n+                               ty::item_path_str(fcx.tcx(), trait_did));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+pub type AllTraitsVec = Vec<TraitInfo>;\n+\n+fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      span: Span,\n+                                      _rcvr_ty: Ty<'tcx>,\n+                                      method_name: ast::Name,\n+                                      valid_out_of_scope_traits: Vec<ast::DefId>)\n+{\n+    let tcx = fcx.tcx();\n+    let method_ustring = method_name.user_string(tcx);\n+\n+    if !valid_out_of_scope_traits.is_empty() {\n+        let mut candidates = valid_out_of_scope_traits;\n+        candidates.sort();\n+        let msg = format!(\n+            \"methods from traits can only be called if the trait is in scope; \\\n+             the following {traits_are} implemented and {define} a method `{name}`:\",\n+            traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n+            define = if candidates.len() == 1 {\"defines\"} else {\"define\"},\n+            name = method_ustring);\n+\n+        fcx.sess().fileline_help(span, &msg[]);\n+\n+        for (i, trait_did) in candidates.iter().enumerate() {\n+            fcx.sess().fileline_help(span,\n+                                     &*format!(\"candidate #{}: `{}`\",\n+                                               i + 1,\n+                                               ty::item_path_str(fcx.tcx(), *trait_did)))\n+\n+        }\n+        return\n+    }\n+\n+    // there's no implemented traits, so lets suggest some traits to implement\n+    let mut candidates = all_traits(fcx.ccx)\n+        .filter(|info| trait_method(tcx, info.def_id, method_name).is_some())\n+        .collect::<Vec<_>>();\n+\n+    if candidates.len() > 0 {\n+        // sort from most relevant to least relevant\n+        candidates.sort_by(|a, b| a.cmp(b).reverse());\n+\n+        let msg = format!(\n+            \"methods from traits can only be called if the trait is implemented and \\\n+             in scope; no such traits are but the following {traits_define} a method `{name}`:\",\n+            traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n+            name = method_ustring);\n+\n+        fcx.sess().fileline_help(span, &msg[]);\n+\n+        for (i, trait_info) in candidates.iter().enumerate() {\n+            fcx.sess().fileline_help(span,\n+                                     &*format!(\"candidate #{}: `{}`\",\n+                                               i + 1,\n+                                               ty::item_path_str(fcx.tcx(), trait_info.def_id)))\n+        }\n+    }\n+}\n+\n+#[derive(Copy)]\n+pub struct TraitInfo {\n+    pub def_id: ast::DefId,\n+}\n+\n+impl TraitInfo {\n+    fn new(def_id: ast::DefId) -> TraitInfo {\n+        TraitInfo {\n+            def_id: def_id,\n+        }\n+    }\n+}\n+impl PartialEq for TraitInfo {\n+    fn eq(&self, other: &TraitInfo) -> bool {\n+        self.cmp(other) == Ordering::Equal\n+    }\n+}\n+impl Eq for TraitInfo {}\n+impl PartialOrd for TraitInfo {\n+    fn partial_cmp(&self, other: &TraitInfo) -> Option<Ordering> { Some(self.cmp(other)) }\n+}\n+impl Ord for TraitInfo {\n+    fn cmp(&self, other: &TraitInfo) -> Ordering {\n+        // accessible traits are more important/relevant than\n+        // inaccessible ones, local crates are more important than\n+        // remote ones (local: cnum == 0), and NodeIds just for\n+        // totality.\n+\n+        let lhs = (other.def_id.krate, other.def_id.node);\n+        let rhs = (self.def_id.krate, self.def_id.node);\n+        lhs.cmp(&rhs)\n+    }\n+}\n+\n+/// Retrieve all traits in this crate and any dependent crates.\n+pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n+    if ccx.all_traits.borrow().is_none() {\n+        use syntax::visit;\n+\n+        let mut traits = vec![];\n+\n+        // Crate-local:\n+        //\n+        // meh.\n+        struct Visitor<'a, 'b: 'a, 'tcx: 'a + 'b> {\n+            traits: &'a mut AllTraitsVec,\n+        }\n+        impl<'v,'a, 'b, 'tcx> visit::Visitor<'v> for Visitor<'a, 'b, 'tcx> {\n+            fn visit_item(&mut self, i: &'v ast::Item) {\n+                match i.node {\n+                    ast::ItemTrait(..) => {\n+                        self.traits.push(TraitInfo::new(ast_util::local_def(i.id)));\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, i)\n+            }\n+        }\n+        visit::walk_crate(&mut Visitor {\n+            traits: &mut traits\n+        }, ccx.tcx.map.krate());\n+\n+        // Cross-crate:\n+        fn handle_external_def(traits: &mut AllTraitsVec,\n+                               ccx: &CrateCtxt,\n+                               cstore: &cstore::CStore,\n+                               dl: decoder::DefLike) {\n+            match dl {\n+                decoder::DlDef(def::DefTrait(did)) => {\n+                    traits.push(TraitInfo::new(did));\n+                }\n+                decoder::DlDef(def::DefMod(did)) => {\n+                    csearch::each_child_of_item(cstore, did, |dl, _, _| {\n+                        handle_external_def(traits, ccx, cstore, dl)\n+                    })\n+                }\n+                _ => {}\n+            }\n+        }\n+        let cstore = &ccx.tcx.sess.cstore;\n+        cstore.iter_crate_data(|&mut: cnum, _| {\n+            csearch::each_top_level_item_of_crate(cstore, cnum, |dl, _, _| {\n+                handle_external_def(&mut traits, ccx, cstore, dl)\n+            })\n+        });\n+\n+        *ccx.all_traits.borrow_mut() = Some(traits);\n+    }\n+\n+    let borrow = ccx.all_traits.borrow();\n+    assert!(borrow.is_some());\n+    AllTraits {\n+        borrow: borrow,\n+        idx: 0\n+    }\n+}\n+\n+pub struct AllTraits<'a> {\n+    borrow: cell::Ref<'a Option<AllTraitsVec>>,\n+    idx: usize\n+}\n+\n+impl<'a> Iterator for AllTraits<'a> {\n+    type Item = TraitInfo;\n+\n+    fn next(&mut self) -> Option<TraitInfo> {\n+        let AllTraits { ref borrow, ref mut idx } = *self;\n+        // ugh.\n+        borrow.as_ref().unwrap().get(*idx).map(|info| {\n+            *idx += 1;\n+            *info\n+        })\n+    }\n+}"}, {"sha": "88fe88bf2654052346aff8a87763b075df8b5f61", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -108,6 +108,8 @@ use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n use syntax::ast_util::local_def;\n \n+use std::cell::RefCell;\n+\n mod check;\n mod rscope;\n mod astconv;\n@@ -123,6 +125,11 @@ struct TypeAndSubsts<'tcx> {\n struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: ty::TraitMap,\n+    /// A vector of every trait accessible in the whole crate\n+    /// (i.e. including those from subcrates). This is used only for\n+    /// error reporting, and so is lazily initialised and generally\n+    /// shouldn't taint the common path (hence the RefCell).\n+    all_traits: RefCell<Option<check::method::AllTraitsVec>>,\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n@@ -320,6 +327,7 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n+        all_traits: RefCell::new(None),\n         tcx: tcx\n     };\n "}, {"sha": "7213b0fa9556cf0eb51021ecbf1e8fbe5463b74f", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -118,6 +118,9 @@ impl SpanHandler {\n     pub fn fileline_note(&self, sp: Span, msg: &str) {\n         self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n     }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Help);\n+    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n         panic!(ExplicitBug);"}, {"sha": "328561495eef0a2efafd011611c14e1b7120b1a3", "filename": "src/test/auxiliary/no_method_suggested_traits.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fno_method_suggested_traits.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use reexport::Reexported;\n+\n+pub mod foo {\n+    pub trait PubPub {\n+        fn method(&self) {}\n+\n+        fn method3(&self) {}\n+    }\n+\n+    impl PubPub for u32 {}\n+    impl PubPub for i32 {}\n+}\n+pub mod bar {\n+    trait PubPriv {\n+        fn method(&self);\n+    }\n+}\n+mod qux {\n+    pub trait PrivPub {\n+        fn method(&self);\n+    }\n+}\n+mod quz {\n+    trait PrivPriv {\n+        fn method(&self);\n+    }\n+}\n+\n+mod reexport {\n+    pub trait Reexported {\n+        fn method(&self);\n+    }\n+}"}, {"sha": "277800778a87ebc67c493c2e15f13c7e545e1d3c", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed530d7a3b67989047e6fe61fe101b9d8158585f/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=ed530d7a3b67989047e6fe61fe101b9d8158585f", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:no_method_suggested_traits.rs\n+\n+extern crate no_method_suggested_traits;\n+\n+mod foo {\n+    trait Bar {\n+        fn method(&self) {}\n+\n+        fn method2(&self) {}\n+    }\n+\n+    impl Bar for u32 {}\n+\n+    impl Bar for char {}\n+}\n+\n+fn main() {\n+    1u32.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following traits are implemented and define a method `method`\n+    //~^^^ HELP `foo::Bar`\n+    //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+\n+    'a'.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^^ HELP `foo::Bar`\n+\n+    1i32.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+\n+    1u64.method();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following traits define a method `method`\n+    //~^^^ HELP `foo::Bar`\n+    //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+    //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n+    //~^^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n+    //~^^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n+    //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n+\n+    1u64.method2();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait defines a method `method2`\n+    //~^^^ HELP `foo::Bar`\n+    1u64.method3();\n+    //~^ ERROR does not implement\n+    //~^^ HELP the following trait defines a method `method3`\n+    //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n+}"}]}