{"sha": "1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMGM2NjY1ZDlkNGM1MDk1Yzg2YWMxZTcwZTMwOWM3ZWM5YzJjYTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-04T21:42:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-04T21:42:39Z"}, "message": "Merge remote-tracking branch 'brson/repl'\n\nConflicts:\n\tmk/install.mk\n\tsrc/rt/rustrt.def.in", "tree": {"sha": "f4d466623ab391dcbadb3985826e60837549e039", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4d466623ab391dcbadb3985826e60837549e039"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "html_url": "https://github.com/rust-lang/rust/commit/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45a908cad04b10fea8446fbd2589a499f7fa7617", "url": "https://api.github.com/repos/rust-lang/rust/commits/45a908cad04b10fea8446fbd2589a499f7fa7617", "html_url": "https://github.com/rust-lang/rust/commit/45a908cad04b10fea8446fbd2589a499f7fa7617"}, {"sha": "799eb105b92a8ef2238b217291ea6169d70acec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/799eb105b92a8ef2238b217291ea6169d70acec4", "html_url": "https://github.com/rust-lang/rust/commit/799eb105b92a8ef2238b217291ea6169d70acec4"}], "stats": {"total": 2331, "additions": 2298, "deletions": 33}, "files": [{"sha": "a9bb2820ee1c63a1ef22a09b737461dbd55bcce5", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -23,6 +23,7 @@ Benjamin Peterson <benjamin@python.org>\n Brendan Eich <brendan@mozilla.org>\n Brian Anderson <banderson@mozilla.com>\n Brian J. Burg <burg@cs.washington.edu>\n+Brian Leibig <brian.leibig@gmail.com>\n Chris Double <chris.double@double.co.nz>\n Chris Peterson <cpeterson@mozilla.com>\n Damian Gryski <damian@gryski.com>"}, {"sha": "d8db8b3fcb2b50aab1f81c8cb728141b9dbd8cbd", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -460,8 +460,9 @@ TSREQS :=\t\t\t\t\t\t\t\t\t\t\t\\\n FUZZ := $(HBIN2_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n CARGO := $(HBIN2_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n RUSTDOC := $(HBIN2_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n+RUSTI := $(HBIN2_H_$(CFG_HOST_TRIPLE))/rusti$(X)\n \n-all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC)\n+all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC) $(RUSTI)\n \n endif\n "}, {"sha": "c09f2c7a9e5efc918c90d72aea3dabe791f1313d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -529,7 +529,7 @@ for t in $CFG_TARGET_TRIPLES\n do\n   make_dir rt/$t\n   for i in                                          \\\n-    isaac bigint sync test arch/i386 arch/x86_64    \\\n+    isaac linenoise bigint sync test arch/i386 arch/x86_64    \\\n     libuv libuv/src/ares libuv/src/eio libuv/src/ev\n   do\n     make_dir rt/$t/$i"}, {"sha": "0bdf764c153e337fc2e186c9f4afbc0c7b255047", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -22,6 +22,7 @@ PKG_FILES := \\\n     $(addprefix $(S)src/,                      \\\n       README.txt                               \\\n       cargo                                    \\\n+      rusti                                    \\\n       rustc                                    \\\n       compiletest                              \\\n       etc                                      \\"}, {"sha": "1ba5fe63912bf6d85540d473a686111be8b28c65", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -75,6 +75,7 @@ install-host: $(SREQ$(ISTAGE)_T_$(CFG_HOST_TRIPLE)_H_$(CFG_HOST_TRIPLE))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBFUZZER))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),cargo$(X))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBCARGO))\n+\t$(Q)$(call INSTALL,$(HB2),$(PHB),rusti$(X))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBRUSTDOC))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUNTIME))\n@@ -95,6 +96,7 @@ HOST_LIB_FROM_HL_GLOB = \\\n uninstall:\n \t$(Q)rm -f $(PHB)/rustc$(X)\n \t$(Q)rm -f $(PHB)/cargo$(X)\n+\t$(Q)rm -f $(PHB)/rusti$(X)\n \t$(Q)rm -f $(PHB)/rustdoc$(X)\n \t$(Q)rm -f $(PHL)/$(CFG_RUSTLLVM)\n \t$(Q)rm -f $(PHL)/$(CFG_FUZZER)"}, {"sha": "ba0d076552422190250acffda6f88507b73e68f5", "filename": "mk/platform.mk", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -103,7 +103,7 @@ endif\n \n # Hack: not sure how to test if a file exists in make other than this\n OS_SUPP = $(patsubst %,--suppressions=%,\\\n-\t    $(wildcard $(CFG_SRC_DIR)src/etc/$(CFG_OSTYPE).supp*))\n+      $(wildcard $(CFG_SRC_DIR)src/etc/$(CFG_OSTYPE).supp*))\n \n ifneq ($(findstring mingw,$(CFG_OSTYPE)),)\n   CFG_WINDOWSY := 1\n@@ -212,24 +212,37 @@ ifeq ($(CFG_C_COMPILER),clang)\n   ifeq ($(origin CPP),default)\n     CPP=clang -E\n   endif\n-  CFG_GCCISH_CFLAGS += -Wall -Werror -fno-rtti -g\n+  CFG_GCCISH_CFLAGS += -Wall -Werror -g\n+  CFG_GCCISH_CXXFLAGS += -fno-rtti\n   CFG_GCCISH_LINK_FLAGS += -g\n   # These flags will cause the compiler to produce a .d file\n   # next to the .o file that lists header deps.\n   CFG_DEPEND_FLAGS = -MMD -MP -MT $(1) -MF $(1:%.o=%.d)\n \n   define CFG_MAKE_CC\n-\tCFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n-\t\t$$(CFG_GCCISH_CFLAGS) $$(CFG_CLANG_CFLAGS)\t\t\\\n-\t\t$$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n-\t    $$(CFG_CLANG_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n+  CFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CC)  \\\n+    $$(CFG_GCCISH_CFLAGS) $$(CFG_CLANG_CFLAGS)    \\\n+    $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))       \\\n+      $$(CFG_CLANG_CFLAGS_$$(HOST_$(1)))        \\\n         $$(CFG_DEPEND_FLAGS)                            \\\n-\t\t-c -o $$(1) $$(2)\n-    CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n-\t\t$$(CFG_GCCISH_LINK_FLAGS) -o $$(1)\t\t\t\\\n-\t\t$$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))\t\t\\\n-        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)\t\t\t\\\n-\t    $$(call CFG_INSTALL_NAME,$$(4))\n+    -c -o $$(1) $$(2)\n+    CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CC) \\\n+    $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)      \\\n+    $$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))   \\\n+        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)      \\\n+      $$(call CFG_INSTALL_NAME,$$(4))\n+  CFG_COMPILE_CXX_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)  \\\n+    $$(CFG_GCCISH_CFLAGS) $$(CFG_CLANG_CFLAGS)    \\\n+    $$(CFG_GCCISH_CXXFLAGS)                       \\\n+    $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))       \\\n+      $$(CFG_CLANG_CFLAGS_$$(HOST_$(1)))        \\\n+        $$(CFG_DEPEND_FLAGS)                            \\\n+    -c -o $$(1) $$(2)\n+    CFG_LINK_CXX_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX) \\\n+    $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)      \\\n+    $$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))   \\\n+        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)      \\\n+      $$(call CFG_INSTALL_NAME,$$(4))\n   endef\n \n   $(foreach target,$(CFG_TARGET_TRIPLES), \\\n@@ -245,24 +258,38 @@ ifeq ($(CFG_C_COMPILER),gcc)\n   ifeq ($(origin CPP),default)\n     CPP=gcc -E\n   endif\n-  CFG_GCCISH_CFLAGS += -Wall -Werror -fno-rtti -g\n+  CFG_GCCISH_CFLAGS += -Wall -Werror -g\n+  CFG_GCCISH_CXXFLAGS += -fno-rtti\n   CFG_GCCISH_LINK_FLAGS += -g\n   # These flags will cause the compiler to produce a .d file\n   # next to the .o file that lists header deps.\n   CFG_DEPEND_FLAGS = -MMD -MP -MT $(1) -MF $(1:%.o=%.d)\n \n   define CFG_MAKE_CC\n-\tCFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n-        $$(CFG_GCCISH_CFLAGS)\t\t\t\t\t\t\t\\\n-\t    $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n-        $$(CFG_GCC_CFLAGS)\t\t\t\t\t\t\t\t\\\n-        $$(CFG_GCC_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n+  CFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CC)  \\\n+        $$(CFG_GCCISH_CFLAGS)             \\\n+      $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))       \\\n+        $$(CFG_GCC_CFLAGS)                \\\n+        $$(CFG_GCC_CFLAGS_$$(HOST_$(1)))        \\\n+        $$(CFG_DEPEND_FLAGS)                            \\\n+        -c -o $$(1) $$(2)\n+    CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CC) \\\n+        $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)      \\\n+    $$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))   \\\n+        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)      \\\n+        $$(call CFG_INSTALL_NAME,$$(4))\n+  CFG_COMPILE_CXX_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)  \\\n+        $$(CFG_GCCISH_CFLAGS)             \\\n+        $$(CFG_GCCISH_CXXFLAGS)           \\\n+      $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))       \\\n+        $$(CFG_GCC_CFLAGS)                \\\n+        $$(CFG_GCC_CFLAGS_$$(HOST_$(1)))        \\\n         $$(CFG_DEPEND_FLAGS)                            \\\n         -c -o $$(1) $$(2)\n-    CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n-        $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)\t\t\t\\\n-\t\t$$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))\t\t\\\n-        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)\t\t\t\\\n+    CFG_LINK_CXX_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX) \\\n+        $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)      \\\n+    $$(CFG_GCCISH_LINK_FLAGS_$$(HOST_$(1)))   \\\n+        $$(CFG_GCCISH_DEF_FLAG)$$(3) $$(2)      \\\n         $$(call CFG_INSTALL_NAME,$$(4))\n   endef\n \n@@ -285,4 +312,4 @@ define CFG_MAKE_ASSEMBLER\n endef\n \n $(foreach target,$(CFG_TARGET_TRIPLES),\\\n-  $(eval $(call CFG_MAKE_ASSEMBLER,$(target))))\n+  $(eval $(call CFG_MAKE_ASSEMBLER,$(target))))\n\\ No newline at end of file"}, {"sha": "34ca47463fdda26080b3027271c45e5cfbc961dc", "filename": "mk/pp.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fpp.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Fpp.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fpp.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -8,7 +8,8 @@ else\n               $(wildcard $(S)src/test/*/*.rs    \\\n                          $(S)src/test/*/*/*.rs) \\\n               $(wildcard $(S)src/fuzzer/*.rs)   \\\n-              $(wildcard $(S)src/cargo/*.rs)\n+              $(wildcard $(S)src/cargo/*.rs) \\\n+              $(wildcard $(S)src/rusti/*.rs)\n \n   PP_INPUTS_FILTERED = $(shell echo $(PP_INPUTS) | xargs grep -L \\\n                        \"no-reformat\\|xfail-pretty\\|xfail-test\")"}, {"sha": "fd948fbc53aaf806e3c50b7edb1ee69f35c24308", "filename": "mk/rt.mk", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -42,7 +42,7 @@ define DEF_RUNTIME_TARGETS\n # Runtime (C++) library variables\n ######################################################################\n \n-RUNTIME_CS_$(1) := \\\n+RUNTIME_CXXS_$(1) := \\\n               rt/sync/timer.cpp \\\n               rt/sync/lock_and_signal.cpp \\\n               rt/sync/rust_thread.cpp \\\n@@ -77,6 +77,8 @@ RUNTIME_CS_$(1) := \\\n               rt/arch/$$(HOST_$(1))/context.cpp \\\n               rt/arch/$$(HOST_$(1))/gpr.cpp\n \n+RUNTIME_CS_$(1) := rt/linenoise/linenoise.c rt/linenoise/utf8.c\n+\n RUNTIME_S_$(1) := rt/arch/$$(HOST_$(1))/_context.S \\\n                   rt/arch/$$(HOST_$(1))/ccall.S \\\n                   rt/arch/$$(HOST_$(1))/record_sp.S\n@@ -103,9 +105,11 @@ endif\n \n RUNTIME_DEF_$(1) := rt/rustrt$$(CFG_DEF_SUFFIX)\n RUNTIME_INCS_$(1) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n-                -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n-\t\t\t\t-I $$(S)src/libuv/include\n-RUNTIME_OBJS_$(1) := $$(RUNTIME_CS_$(1):rt/%.cpp=rt/$(1)/%.o) \\\n+                     -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n+                     -I $$(S)src/rt/linenoise \\\n+                     -I $$(S)src/libuv/include\n+RUNTIME_OBJS_$(1) := $$(RUNTIME_CXXS_$(1):rt/%.cpp=rt/$(1)/%.o) \\\n+                     $$(RUNTIME_CS_$(1):rt/%.c=rt/$(1)/%.o) \\\n                      $$(RUNTIME_S_$(1):rt/%.S=rt/$(1)/%.o)\n ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1))\n \n@@ -115,6 +119,11 @@ ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1))\n RUNTIME_LIBS_$(1) := $$(LIBUV_LIB_$(1))\n \n rt/$(1)/%.o: rt/%.cpp $$(MKFILE_DEPS)\n+\t@$$(call E, compile: $$@)\n+\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(RUNTIME_INCS_$(1)) \\\n+                 $$(SNAP_DEFINES)) $$<\n+\n+rt/$(1)/%.o: rt/%.c $$(MKFILE_DEPS)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, $$(RUNTIME_INCS_$(1)) \\\n                  $$(SNAP_DEFINES)) $$<\n@@ -132,7 +141,7 @@ rt/$(1)/$(CFG_RUNTIME): $$(RUNTIME_OBJS_$(1)) $$(MKFILE_DEPS) \\\n                         $$(RUNTIME_DEF_$(1)) \\\n                         $$(RUNTIME_LIBS_$(1))\n \t@$$(call E, link: $$@)\n-\t$$(Q)$$(call CFG_LINK_C_$(1),$$@, $$(RUNTIME_OBJS_$(1)) \\\n+\t$$(Q)$$(call CFG_LINK_CXX_$(1),$$@, $$(RUNTIME_OBJS_$(1)) \\\n \t  $$(CFG_GCCISH_POST_LIB_FLAGS) $$(RUNTIME_LIBS_$(1)) \\\n \t  $$(CFG_LIBUV_LINK_FLAGS),$$(RUNTIME_DEF_$(1)),$$(CFG_RUNTIME))\n "}, {"sha": "c56220af05eeaa8021176f0e12c76cf94cd60146", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -25,14 +25,14 @@ ALL_OBJ_FILES += $$(RUSTLLVM_OBJS_OBJS_$(1))\n rustllvm/$(1)/$(CFG_RUSTLLVM): $$(RUSTLLVM_OBJS_OBJS_$(1)) \\\n                           $$(MKFILE_DEPS) $$(RUSTLLVM_DEF_$(1))\n \t@$$(call E, link: $$@)\n-\t$$(Q)$$(call CFG_LINK_C_$(1),$$@,$$(RUSTLLVM_OBJS_OBJS_$(1)) \\\n+\t$$(Q)$$(call CFG_LINK_CXX_$(1),$$@,$$(RUSTLLVM_OBJS_OBJS_$(1)) \\\n \t  $$(CFG_GCCISH_PRE_LIB_FLAGS) $$(LLVM_LIBS_$(1)) \\\n           $$(CFG_GCCISH_POST_LIB_FLAGS) \\\n           $$(LLVM_LDFLAGS_$(1)),$$(RUSTLLVM_DEF_$(1)),$$(CFG_RUSTLLVM))\n \n rustllvm/$(1)/%.o: rustllvm/%.cpp $$(MKFILE_DEPS) $$(LLVM_CONFIG_$(1))\n \t@$$(call E, compile: $$@)\n-\t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, $$(LLVM_CXXFLAGS_$(1)) $$(RUSTLLVM_INCS_$(1))) $$<\n+\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(LLVM_CXXFLAGS_$(1)) $$(RUSTLLVM_INCS_$(1))) $$<\n endef\n \n # Instantiate template for all stages"}, {"sha": "2eec607ff81d75de69f8a59f2401a0296324c051", "filename": "mk/tests.mk", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -122,6 +122,7 @@ ALL_CS := $(wildcard $(S)src/rt/*.cpp \\\n ALL_CS := $(filter-out $(S)src/rt/bigint/bigint_ext.cpp \\\n                        $(S)src/rt/bigint/bigint_int.cpp \\\n                        $(S)src/rt/miniz.cpp \\\n+                       $(S)src/rt/linenoise/linenoise.c \\\n \t,$(ALL_CS))\n ALL_HS := $(wildcard $(S)src/rt/*.h \\\n                      $(S)src/rt/*/*.h \\\n@@ -135,6 +136,7 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n                        $(S)src/rt/msvc/stdint.h \\\n                        $(S)src/rt/msvc/inttypes.h \\\n                        $(S)src/rt/bigint/bigint.h \\\n+                       $(S)src/rt/linenoise/linenoise.h \\\n \t,$(ALL_HS))\n \n tidy:\n@@ -229,6 +231,7 @@ check-stage$(1)-T-$(2)-H-$(3):     \t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-bench\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty        \\\n     check-stage$(1)-T-$(2)-H-$(3)-rustdoc       \\\n+    check-stage$(1)-T-$(2)-H-$(3)-rusti       \\\n     check-stage$(1)-T-$(2)-H-$(3)-cargo       \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial  \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi  \\\n@@ -289,6 +292,9 @@ check-stage$(1)-T-$(2)-H-$(3)-pretty-pretty:\t\t\t\t\\\n check-stage$(1)-T-$(2)-H-$(3)-rustdoc:\t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rustdoc-dummy\n \n+check-stage$(1)-T-$(2)-H-$(3)-rusti:\t\t\t\t\\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-rusti-dummy\n+\n check-stage$(1)-T-$(2)-H-$(3)-cargo:\t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cargo-dummy\n \n@@ -371,6 +377,24 @@ check-stage$(1)-T-$(2)-H-$(3)-rustdoc-dummy:\t\t\\\n \t$$(Q)$$(call CFG_RUN_TEST,$$<,$(2),$(3)) $$(TESTARGS)\t\\\n \t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-rustdoc.log\n \n+# Rules for the rusti test runner\n+\n+$(3)/test/rustitest.stage$(1)-$(2)$$(X):\t\t\t\t\t\\\n+\t\t$$(RUSTI_CRATE) $$(RUSTI_INPUTS)\t\t\\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB)  \\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB)   \\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC)\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n+\n+check-stage$(1)-T-$(2)-H-$(3)-rusti-dummy:\t\t\\\n+\t\t$(3)/test/rustitest.stage$(1)-$(2)$$(X)\n+\t@$$(call E, run: $$<)\n+\t$$(Q)$$(call CFG_RUN_TEST,$$<,$(2),$(3)) $$(TESTARGS)\t\\\n+\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-rusti.log\n+\n+\n # Rules for the cargo test runner\n \n $(3)/test/cargotest.stage$(1)-$(2)$$(X):\t\t\t\t\t\\\n@@ -756,6 +780,9 @@ check-stage$(1)-H-$(2)-pretty-pretty:\t\t\t\t\\\n check-stage$(1)-H-$(2)-rustdoc:\t\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-rustdoc)\n+check-stage$(1)-H-$(2)-rusti:\t\t\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-rusti)\n check-stage$(1)-H-$(2)-cargo:\t\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-cargo)"}, {"sha": "98356985654b2319c843b9b36aae8cb5d6b6ab11", "filename": "mk/tools.mk", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -18,6 +18,10 @@ CARGO_INPUTS := $(wildcard $(S)src/cargo/*rs)\n RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rc\n RUSTDOC_INPUTS := $(wildcard $(S)src/rustdoc/*.rs)\n \n+# Rusti, the JIT REPL\n+RUSTI_CRATE := $(S)src/rusti/rusti.rc\n+RUSTI_INPUTS := $(wildcard $(S)src/rusti/*.rs)\n+\n # FIXME: These are only built for the host arch. Eventually we'll\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N\n@@ -126,6 +130,21 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n+$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X):\t\t\t\\\n+\t\t$$(RUSTI_CRATE) $$(RUSTI_INPUTS)\t\t\\\n+\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_CORELIB)  \\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_STDLIB)   \\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTC)\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$<\n+\n+$$(HBIN$(2)_H_$(4))/rusti$$(X):\t\t\t\t\\\n+\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X)\t\\\n+\t\t$$(HSREQ$(2)_H_$(4))\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n endef\n \n $(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\t\\"}, {"sha": "d32751cf576a50aa09bc31bfa5c4e9bebb76ccc4", "filename": "src/README.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -30,6 +30,8 @@ compiletest/       The test runner\n \n cargo/             The package manager\n \n+rusti/             The JIT REPL\n+\n rustdoc/           The Rust API documentation tool\n \n llvm/              The LLVM submodule"}, {"sha": "dc09858638211966c4206e7f109ae8b210f7b8bc", "filename": "src/libstd/rl.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,69 @@\n+use libc::{c_char, c_int};\n+\n+extern mod rustrt {\n+    #[legacy_exports];\n+    fn linenoise(prompt: *c_char) -> *c_char;\n+    fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n+    fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n+    fn linenoiseHistorySave(file: *c_char) -> c_int;\n+    fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n+    fn linenoiseSetCompletionCallback(callback: *u8);\n+    fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+}\n+\n+/// Add a line to history\n+pub fn add_history(line: ~str) -> bool {\n+    do str::as_c_str(line) |buf| {\n+        rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n+    }\n+}\n+\n+/// Set the maximum amount of lines stored\n+pub fn set_history_max_len(len: int) -> bool {\n+    rustrt::linenoiseHistorySetMaxLen(len as c_int) == 1 as c_int\n+}\n+\n+/// Save line history to a file\n+pub fn save_history(file: ~str) -> bool {\n+    do str::as_c_str(file) |buf| {\n+        rustrt::linenoiseHistorySave(buf) == 1 as c_int\n+    }\n+}\n+\n+/// Load line history from a file\n+pub fn load_history(file: ~str) -> bool {\n+    do str::as_c_str(file) |buf| {\n+        rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n+    }\n+}\n+\n+/// Print out a prompt and then wait for input and return it\n+pub fn read(prompt: ~str) -> Option<~str> {\n+    do str::as_c_str(prompt) |buf| unsafe {\n+        let line = rustrt::linenoise(buf);\n+\n+        if line.is_null() { None }\n+        else { Some(str::raw::from_c_str(line)) }\n+    }\n+}\n+\n+pub type CompletionCb = fn~(~str, fn(~str));\n+\n+fn complete_key(_v: @CompletionCb) {}\n+\n+/// Bind to the main completion callback\n+pub fn complete(cb: CompletionCb) unsafe {\n+    task::local_data::local_data_set(complete_key, @(move cb));\n+\n+    extern fn callback(line: *c_char, completions: *()) unsafe {\n+        let cb = copy *task::local_data::local_data_get(complete_key).get();\n+\n+        do cb(str::raw::from_c_str(line)) |suggestion| {\n+            do str::as_c_str(suggestion) |buf| {\n+                rustrt::linenoiseAddCompletion(completions, buf);\n+            }\n+        }\n+    }\n+\n+    rustrt::linenoiseSetCompletionCallback(callback);\n+}\n\\ No newline at end of file"}, {"sha": "ee1b8ab57733a7ed400f025054f58a2a839a7525", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -83,6 +83,7 @@ pub mod arena;\n pub mod par;\n pub mod cmp;\n pub mod base64;\n+pub mod rl;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "f008d2d3d5e38f6c4c29f6a767ca39c62853ce38", "filename": "src/rt/linenoise/README.markdown", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2FREADME.markdown?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,47 @@\n+# Linenoise\n+\n+A minimal, zero-config, BSD licensed, readline replacement.\n+\n+News: linenoise now includes minimal completion support, thanks to Pieter Noordhuis (@pnoordhuis).\n+\n+News: linenoise is now part of [Android](http://android.git.kernel.org/?p=platform/system/core.git;a=tree;f=liblinenoise;h=56450eaed7f783760e5e6a5993ef75cde2e29dea;hb=HEAD Android)!\n+\n+## Can a line editing library be 20k lines of code?\n+\n+Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?\n+\n+So what usually happens is either:\n+\n+ * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (Real world example of this problem: Tclsh).\n+ * Smaller programs not using a configure script not supporting line editing at all (A problem we had with Redis-cli for instance).\n+ \n+The result is a pollution of binaries without line editing support.\n+\n+So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to linenoise if not.\n+\n+## Terminals, in 2010.\n+\n+Apparently almost every terminal you can happen to use today has some kind of support for VT100 alike escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it.\n+\n+Since it's so young I guess there are a few bugs, or the lib may not compile or work with some operating system, but it's a matter of a few weeks and eventually we'll get it right, and there will be no excuses for not shipping command line tools without built-in line editing support.\n+\n+The library is currently less than 400 lines of code. In order to use it in your project just look at the *example.c* file in the source distribution, it is trivial. Linenoise is BSD code, so you can use both in free software and commercial software.\n+\n+## Tested with...\n+\n+ * Linux text only console ($TERM = linux)\n+ * Linux KDE terminal application ($TERM = xterm)\n+ * Linux xterm ($TERM = xterm)\n+ * Mac OS X iTerm ($TERM = xterm)\n+ * Mac OS X default Terminal.app ($TERM = xterm)\n+ * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)\n+ * IBM AIX 6.1\n+ * FreeBSD xterm ($TERM = xterm)\n+\n+Please test it everywhere you can and report back!\n+\n+## Let's push this forward!\n+\n+Please fork it and add something interesting and send me a pull request. What's especially interesting are fixes, new key bindings, completion.\n+\n+Send feedbacks to antirez at gmail"}, {"sha": "cb51a0af8f9259eca7504261e63bb35627f3cc5c", "filename": "src/rt/linenoise/example.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Fexample.c", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Fexample.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Fexample.c?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,30 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"linenoise.h\"\n+\n+#ifndef NO_COMPLETION\n+void completion(const char *buf, linenoiseCompletions *lc) {\n+    if (buf[0] == 'h') {\n+        linenoiseAddCompletion(lc,\"hello\");\n+        linenoiseAddCompletion(lc,\"hello there\");\n+    }\n+}\n+#endif\n+\n+int main(void) {\n+    char *line;\n+\n+#ifndef NO_COMPLETION\n+    linenoiseSetCompletionCallback(completion);\n+#endif\n+    linenoiseHistoryLoad(\"history.txt\"); /* Load the history at startup */\n+    while((line = linenoise(\"hello> \")) != NULL) {\n+        if (line[0] != '\\0') {\n+            printf(\"echo: '%s'\\n\", line);\n+            linenoiseHistoryAdd(line);\n+            linenoiseHistorySave(\"history.txt\"); /* Save every new entry */\n+        }\n+        free(line);\n+    }\n+    return 0;\n+}"}, {"sha": "5e3216e4591d719df286f4ce4c886fcb17232cce", "filename": "src/rt/linenoise/linenoise.c", "status": "added", "additions": 1391, "deletions": 0, "changes": 1391, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Flinenoise.c", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Flinenoise.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.c?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,1391 @@\n+/* linenoise.c -- guerrilla line editing library against the idea that a\n+ * line editing lib needs to be 20,000 lines of C code.\n+ *\n+ * You can find the latest source code at:\n+ *\n+ *   http://github.com/msteveb/linenoise\n+ *   (forked from http://github.com/antirez/linenoise)\n+ *\n+ * Does a number of crazy assumptions that happen to be true in 99.9999% of\n+ * the 2010 UNIX computers around.\n+ *\n+ * ------------------------------------------------------------------------\n+ *\n+ * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n+ * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n+ * Copyright (c) 2011, Steve Bennett <steveb at workware dot net dot au>\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are\n+ * met:\n+ *\n+ *  *  Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *  *  Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * ------------------------------------------------------------------------\n+ *\n+ * References:\n+ * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n+ * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n+ *\n+ * Bloat:\n+ * - Completion?\n+ *\n+ * Unix/termios\n+ * ------------\n+ * List of escape sequences used by this program, we do everything just\n+ * a few sequences. In order to be so cheap we may have some\n+ * flickering effect with some slow terminal, but the lesser sequences\n+ * the more compatible.\n+ *\n+ * EL (Erase Line)\n+ *    Sequence: ESC [ n K\n+ *    Effect: if n is 0 or missing, clear from cursor to end of line\n+ *    Effect: if n is 1, clear from beginning of line to cursor\n+ *    Effect: if n is 2, clear entire line\n+ *\n+ * CUF (CUrsor Forward)\n+ *    Sequence: ESC [ n C\n+ *    Effect: moves cursor forward of n chars\n+ *\n+ * CR (Carriage Return)\n+ *    Sequence: \\r\n+ *    Effect: moves cursor to column 1\n+ *\n+ * The following are used to clear the screen: ESC [ H ESC [ 2 J\n+ * This is actually composed of two sequences:\n+ *\n+ * cursorhome\n+ *    Sequence: ESC [ H\n+ *    Effect: moves the cursor to upper left corner\n+ *\n+ * ED2 (Clear entire screen)\n+ *    Sequence: ESC [ 2 J\n+ *    Effect: clear the whole screen\n+ *\n+ * == For highlighting control characters, we also use the following two ==\n+ * SO (enter StandOut)\n+ *    Sequence: ESC [ 7 m\n+ *    Effect: Uses some standout mode such as reverse video\n+ *\n+ * SE (Standout End)\n+ *    Sequence: ESC [ 0 m\n+ *    Effect: Exit standout mode\n+ *\n+ * == Only used if TIOCGWINSZ fails ==\n+ * DSR/CPR (Report cursor position)\n+ *    Sequence: ESC [ 6 n\n+ *    Effect: reports current cursor position as ESC [ NNN ; MMM R\n+ *\n+ * win32/console\n+ * -------------\n+ * If __MINGW32__ is defined, the win32 console API is used.\n+ * This could probably be made to work for the msvc compiler too.\n+ * This support based in part on work by Jon Griffiths.\n+ */\n+\n+#ifdef _WIN32 /* Windows platform, either MinGW or Visual Studio (MSVC) */\n+#include <windows.h>\n+#include <fcntl.h>\n+#define USE_WINCONSOLE\n+#ifdef __MINGW32__\n+#define HAVE_UNISTD_H\n+#else\n+/* Microsoft headers don't like old POSIX names */\n+#define strdup _strdup\n+#define snprintf _snprintf\n+#endif\n+#else\n+#include <termios.h>\n+#include <sys/ioctl.h>\n+#include <sys/poll.h>\n+#define USE_TERMIOS\n+#define HAVE_UNISTD_H\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+\n+#include \"linenoise.h\"\n+#include \"utf8.h\"\n+\n+#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100\n+#define LINENOISE_MAX_LINE 4096\n+\n+#define ctrl(C) ((C) - '@')\n+\n+/* Use -ve numbers here to co-exist with normal unicode chars */\n+enum {\n+    SPECIAL_NONE,\n+    SPECIAL_UP = -20,\n+    SPECIAL_DOWN = -21,\n+    SPECIAL_LEFT = -22,\n+    SPECIAL_RIGHT = -23,\n+    SPECIAL_DELETE = -24,\n+    SPECIAL_HOME = -25,\n+    SPECIAL_END = -26,\n+};\n+\n+static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n+static int history_len = 0;\n+static char **history = NULL;\n+\n+/* Structure to contain the status of the current (being edited) line */\n+struct current {\n+    char *buf;  /* Current buffer. Always null terminated */\n+    int bufmax; /* Size of the buffer, including space for the null termination */\n+    int len;    /* Number of bytes in 'buf' */\n+    int chars;  /* Number of chars in 'buf' (utf-8 chars) */\n+    int pos;    /* Cursor position, measured in chars */\n+    int cols;   /* Size of the window, in chars */\n+    const char *prompt;\n+#if defined(USE_TERMIOS)\n+    int fd;     /* Terminal fd */\n+#elif defined(USE_WINCONSOLE)\n+    HANDLE outh; /* Console output handle */\n+    HANDLE inh; /* Console input handle */\n+    int rows;   /* Screen rows */\n+    int x;      /* Current column during output */\n+    int y;      /* Current row */\n+#endif\n+};\n+\n+static int fd_read(struct current *current);\n+static int getWindowSize(struct current *current);\n+\n+void linenoiseHistoryFree(void) {\n+    if (history) {\n+        int j;\n+\n+        for (j = 0; j < history_len; j++)\n+            free(history[j]);\n+        free(history);\n+        history = NULL;\n+    }\n+}\n+\n+#if defined(USE_TERMIOS)\n+static void linenoiseAtExit(void);\n+static struct termios orig_termios; /* in order to restore at exit */\n+static int rawmode = 0; /* for atexit() function to check if restore is needed*/\n+static int atexit_registered = 0; /* register atexit just 1 time */\n+\n+static const char *unsupported_term[] = {\"dumb\",\"cons25\",NULL};\n+\n+static int isUnsupportedTerm(void) {\n+    char *term = getenv(\"TERM\");\n+\n+    if (term) {\n+        int j;\n+        for (j = 0; unsupported_term[j]; j++) {\n+            if (strcasecmp(term, unsupported_term[j]) == 0) {\n+                return 1;\n+            }\n+        }\n+    }\n+    return 0;\n+}\n+\n+static int enableRawMode(struct current *current) {\n+    struct termios raw;\n+\n+    current->fd = STDIN_FILENO;\n+\n+    if (!isatty(current->fd) || isUnsupportedTerm() ||\n+        tcgetattr(current->fd, &orig_termios) == -1) {\n+fatal:\n+        errno = ENOTTY;\n+        return -1;\n+    }\n+\n+    if (!atexit_registered) {\n+        atexit(linenoiseAtExit);\n+        atexit_registered = 1;\n+    }\n+\n+    raw = orig_termios;  /* modify the original mode */\n+    /* input modes: no break, no CR to NL, no parity check, no strip char,\n+     * no start/stop output control. */\n+    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n+    /* output modes - disable post processing */\n+    raw.c_oflag &= ~(OPOST);\n+    /* control modes - set 8 bit chars */\n+    raw.c_cflag |= (CS8);\n+    /* local modes - choing off, canonical off, no extended functions,\n+     * no signal chars (^Z,^C) */\n+    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n+    /* control chars - set return condition: min number of bytes and timer.\n+     * We want read to return every single byte, without timeout. */\n+    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n+\n+    /* put terminal in raw mode after flushing */\n+    if (tcsetattr(current->fd,TCSADRAIN,&raw) < 0) {\n+        goto fatal;\n+    }\n+    rawmode = 1;\n+\n+    current->cols = 0;\n+    return 0;\n+}\n+\n+static void disableRawMode(struct current *current) {\n+    /* Don't even check the return value as it's too late. */\n+    if (rawmode && tcsetattr(current->fd,TCSADRAIN,&orig_termios) != -1)\n+        rawmode = 0;\n+}\n+\n+/* At exit we'll try to fix the terminal to the initial conditions. */\n+static void linenoiseAtExit(void) {\n+    if (rawmode) {\n+        tcsetattr(STDIN_FILENO, TCSADRAIN, &orig_termios);\n+    }\n+    linenoiseHistoryFree();\n+}\n+\n+/* gcc/glibc insists that we care about the return code of write! */\n+#define IGNORE_RC(EXPR) if (EXPR) {}\n+\n+/* This is fdprintf() on some systems, but use a different\n+ * name to avoid conflicts\n+ */\n+static void fd_printf(int fd, const char *format, ...)\n+{\n+    va_list args;\n+    char buf[64];\n+    int n;\n+\n+    va_start(args, format);\n+    n = vsnprintf(buf, sizeof(buf), format, args);\n+    va_end(args);\n+    IGNORE_RC(write(fd, buf, n));\n+}\n+\n+static void clearScreen(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\x1b[H\\x1b[2J\");\n+}\n+\n+static void cursorToLeft(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\r\");\n+}\n+\n+static int outputChars(struct current *current, const char *buf, int len)\n+{\n+    return write(current->fd, buf, len);\n+}\n+\n+static void outputControlChar(struct current *current, char ch)\n+{\n+    fd_printf(current->fd, \"\\x1b[7m^%c\\x1b[0m\", ch);\n+}\n+\n+static void eraseEol(struct current *current)\n+{\n+    fd_printf(current->fd, \"\\x1b[0K\");\n+}\n+\n+static void setCursorPos(struct current *current, int x)\n+{\n+    fd_printf(current->fd, \"\\r\\x1b[%dC\", x);\n+}\n+\n+/**\n+ * Reads a char from 'fd', waiting at most 'timeout' milliseconds.\n+ *\n+ * A timeout of -1 means to wait forever.\n+ *\n+ * Returns -1 if no char is received within the time or an error occurs.\n+ */\n+static int fd_read_char(int fd, int timeout)\n+{\n+    struct pollfd p;\n+    unsigned char c;\n+\n+    p.fd = fd;\n+    p.events = POLLIN;\n+\n+    if (poll(&p, 1, timeout) == 0) {\n+        /* timeout */\n+        return -1;\n+    }\n+    if (read(fd, &c, 1) != 1) {\n+        return -1;\n+    }\n+    return c;\n+}\n+\n+/**\n+ * Reads a complete utf-8 character\n+ * and returns the unicode value, or -1 on error.\n+ */\n+static int fd_read(struct current *current)\n+{\n+#ifdef USE_UTF8\n+    char buf[4];\n+    int n;\n+    int i;\n+    int c;\n+\n+    if (read(current->fd, &buf[0], 1) != 1) {\n+        return -1;\n+    }\n+    n = utf8_charlen(buf[0]);\n+    if (n < 1 || n > 3) {\n+        return -1;\n+    }\n+    for (i = 1; i < n; i++) {\n+        if (read(current->fd, &buf[i], 1) != 1) {\n+            return -1;\n+        }\n+    }\n+    buf[n] = 0;\n+    /* decode and return the character */\n+    utf8_tounicode(buf, &c);\n+    return c;\n+#else\n+    return fd_read_char(current->fd, -1);\n+#endif\n+}\n+\n+static int getWindowSize(struct current *current)\n+{\n+    struct winsize ws;\n+\n+    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 && ws.ws_col != 0) {\n+        current->cols = ws.ws_col;\n+        return 0;\n+    }\n+\n+    /* Failed to query the window size. Perhaps we are on a serial terminal.\n+     * Try to query the width by sending the cursor as far to the right\n+     * and reading back the cursor position.\n+     * Note that this is only done once per call to linenoise rather than\n+     * every time the line is refreshed for efficiency reasons.\n+     */\n+    if (current->cols == 0) {\n+        current->cols = 80;\n+\n+        /* Move cursor far right and report cursor position, then back to the left */\n+        fd_printf(current->fd, \"\\x1b[999C\" \"\\x1b[6n\");\n+\n+        /* Parse the response: ESC [ rows ; cols R */\n+        if (fd_read_char(current->fd, 100) == 0x1b && fd_read_char(current->fd, 100) == '[') {\n+            int n = 0;\n+            while (1) {\n+                int ch = fd_read_char(current->fd, 100);\n+                if (ch == ';') {\n+                    /* Ignore rows */\n+                    n = 0;\n+                }\n+                else if (ch == 'R') {\n+                    /* Got cols */\n+                    if (n != 0 && n < 1000) {\n+                        current->cols = n;\n+                    }\n+                    break;\n+                }\n+                else if (ch >= 0 && ch <= '9') {\n+                    n = n * 10 + ch - '0';\n+                }\n+                else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    return 0;\n+}\n+\n+/**\n+ * If escape (27) was received, reads subsequent\n+ * chars to determine if this is a known special key.\n+ *\n+ * Returns SPECIAL_NONE if unrecognised, or -1 if EOF.\n+ *\n+ * If no additional char is received within a short time,\n+ * 27 is returned.\n+ */\n+static int check_special(int fd)\n+{\n+    int c = fd_read_char(fd, 50);\n+    int c2;\n+\n+    if (c < 0) {\n+        return 27;\n+    }\n+\n+    c2 = fd_read_char(fd, 50);\n+    if (c2 < 0) {\n+        return c2;\n+    }\n+    if (c == '[' || c == 'O') {\n+        /* Potential arrow key */\n+        switch (c2) {\n+            case 'A':\n+                return SPECIAL_UP;\n+            case 'B':\n+                return SPECIAL_DOWN;\n+            case 'C':\n+                return SPECIAL_RIGHT;\n+            case 'D':\n+                return SPECIAL_LEFT;\n+            case 'F':\n+                return SPECIAL_END;\n+            case 'H':\n+                return SPECIAL_HOME;\n+        }\n+    }\n+    if (c == '[' && c2 >= '1' && c2 <= '8') {\n+        /* extended escape */\n+        c = fd_read_char(fd, 50);\n+        if (c == '~') {\n+            switch (c2) {\n+                case '3':\n+                    return SPECIAL_DELETE;\n+                case '7':\n+                    return SPECIAL_HOME;\n+                case '8':\n+                    return SPECIAL_END;\n+            }\n+        }\n+        while (c != -1 && c != '~') {\n+            /* .e.g \\e[12~ or '\\e[11;2~   discard the complete sequence */\n+            c = fd_read_char(fd, 50);\n+        }\n+    }\n+\n+    return SPECIAL_NONE;\n+}\n+#elif defined(USE_WINCONSOLE)\n+\n+static DWORD orig_consolemode = 0;\n+\n+static int enableRawMode(struct current *current) {\n+    DWORD n;\n+    INPUT_RECORD irec;\n+\n+    current->outh = GetStdHandle(STD_OUTPUT_HANDLE);\n+    current->inh = GetStdHandle(STD_INPUT_HANDLE);\n+\n+    if (!PeekConsoleInput(current->inh, &irec, 1, &n)) {\n+        return -1;\n+    }\n+    if (getWindowSize(current) != 0) {\n+        return -1;\n+    }\n+    if (GetConsoleMode(current->inh, &orig_consolemode)) {\n+        SetConsoleMode(current->inh, ENABLE_PROCESSED_INPUT);\n+    }\n+    return 0;\n+}\n+\n+static void disableRawMode(struct current *current)\n+{\n+    SetConsoleMode(current->inh, orig_consolemode);\n+}\n+\n+static void clearScreen(struct current *current)\n+{\n+    COORD topleft = { 0, 0 };\n+    DWORD n;\n+\n+    FillConsoleOutputCharacter(current->outh, ' ',\n+        current->cols * current->rows, topleft, &n);\n+    FillConsoleOutputAttribute(current->outh,\n+        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,\n+        current->cols * current->rows, topleft, &n);\n+    SetConsoleCursorPosition(current->outh, topleft);\n+}\n+\n+static void cursorToLeft(struct current *current)\n+{\n+    COORD pos = { 0, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputAttribute(current->outh,\n+        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, current->cols, pos, &n);\n+    current->x = 0;\n+}\n+\n+static int outputChars(struct current *current, const char *buf, int len)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\t\n+    WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);\n+    current->x += len;\n+    return 0;\n+}\n+\n+static void outputControlChar(struct current *current, char ch)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputAttribute(current->outh, BACKGROUND_INTENSITY, 2, pos, &n);\n+    outputChars(current, \"^\", 1);\n+    outputChars(current, &ch, 1);\n+}\n+\n+static void eraseEol(struct current *current)\n+{\n+    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n+    DWORD n;\n+\n+    FillConsoleOutputCharacter(current->outh, ' ', current->cols - current->x, pos, &n);\n+}\n+\n+static void setCursorPos(struct current *current, int x)\n+{\n+    COORD pos = { (SHORT)x, (SHORT)current->y };\n+\n+    SetConsoleCursorPosition(current->outh, pos);\n+    current->x = x;\n+}\n+\n+static int fd_read(struct current *current)\n+{\n+    while (1) {\n+        INPUT_RECORD irec;\n+        DWORD n;\n+        if (WaitForSingleObject(current->inh, INFINITE) != WAIT_OBJECT_0) {\n+            break;\n+        }\n+        if (!ReadConsoleInput (current->inh, &irec, 1, &n)) {\n+            break;\n+        }\n+        if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown) {\n+            KEY_EVENT_RECORD *k = &irec.Event.KeyEvent;\n+            if (k->dwControlKeyState & ENHANCED_KEY) {\n+                switch (k->wVirtualKeyCode) {\n+                 case VK_LEFT:\n+                    return SPECIAL_LEFT;\n+                 case VK_RIGHT:\n+                    return SPECIAL_RIGHT;\n+                 case VK_UP:\n+                    return SPECIAL_UP;\n+                 case VK_DOWN:\n+                    return SPECIAL_DOWN;\n+                 case VK_DELETE:\n+                    return SPECIAL_DELETE;\n+                 case VK_HOME:\n+                    return SPECIAL_HOME;\n+                 case VK_END:\n+                    return SPECIAL_END;\n+                }\n+            }\n+            /* Note that control characters are already translated in AsciiChar */\n+            else {\n+#ifdef USE_UTF8\n+                return k->uChar.UnicodeChar;\n+#else\n+                return k->uChar.AsciiChar;\n+#endif\n+            }\n+        }\n+    }\n+    return -1;\n+}\n+\n+static int getWindowSize(struct current *current)\n+{\n+    CONSOLE_SCREEN_BUFFER_INFO info;\n+    if (!GetConsoleScreenBufferInfo(current->outh, &info)) {\n+        return -1;\n+    }\n+    current->cols = info.dwSize.X;\n+    current->rows = info.dwSize.Y;\n+    if (current->cols <= 0 || current->rows <= 0) {\n+        current->cols = 80;\n+        return -1;\n+    }\n+    current->y = info.dwCursorPosition.Y;\n+    current->x = info.dwCursorPosition.X;\n+    return 0;\n+}\n+#endif\n+\n+static int utf8_getchars(char *buf, int c)\n+{\n+#ifdef USE_UTF8\n+    return utf8_fromunicode(buf, c);\n+#else\n+    *buf = c;\n+    return 1;\n+#endif\n+}\n+\n+/**\n+ * Returns the unicode character at the given offset,\n+ * or -1 if none.\n+ */\n+static int get_char(struct current *current, int pos)\n+{\n+    if (pos >= 0 && pos < current->chars) {\n+        int c;\n+        int i = utf8_index(current->buf, pos);\n+        (void)utf8_tounicode(current->buf + i, &c);\n+        return c;\n+    }\n+    return -1;\n+}\n+\n+static void refreshLine(const char *prompt, struct current *current)\n+{\n+    int plen;\n+    int pchars;\n+    int backup = 0;\n+    int i;\n+    const char *buf = current->buf;\n+    int chars = current->chars;\n+    int pos = current->pos;\n+    int b;\n+    int ch;\n+    int n;\n+\n+    /* Should intercept SIGWINCH. For now, just get the size every time */\n+    getWindowSize(current);\n+\n+    plen = strlen(prompt);\n+    pchars = utf8_strlen(prompt, plen);\n+\n+    /* Account for a line which is too long to fit in the window.\n+     * Note that control chars require an extra column\n+     */\n+\n+    /* How many cols are required to the left of 'pos'?\n+     * The prompt, plus one extra for each control char\n+     */\n+    n = pchars + utf8_strlen(buf, current->len);\n+    b = 0;\n+    for (i = 0; i < pos; i++) {\n+        b += utf8_tounicode(buf + b, &ch);\n+        if (ch < ' ') {\n+            n++;\n+        }\n+    }\n+\n+    /* If too many are need, strip chars off the front of 'buf'\n+     * until it fits. Note that if the current char is a control character,\n+     * we need one extra col.\n+     */\n+    if (current->pos < current->chars && get_char(current, current->pos) < ' ') {\n+        n++;\n+    }\n+\n+    while (n >= current->cols && pos > 0) {\n+        b = utf8_tounicode(buf, &ch);\n+        if (ch < ' ') {\n+            n--;\n+        }\n+        n--;\n+        buf += b;\n+        pos--;\n+        chars--;\n+    }\n+\n+    /* Cursor to left edge, then the prompt */\n+    cursorToLeft(current);\n+    outputChars(current, prompt, plen);\n+\n+    /* Now the current buffer content */\n+\n+    /* Need special handling for control characters.\n+     * If we hit 'cols', stop.\n+     */\n+    b = 0; /* unwritted bytes */\n+    n = 0; /* How many control chars were written */\n+    for (i = 0; i < chars; i++) {\n+        int ch;\n+        int w = utf8_tounicode(buf + b, &ch);\n+        if (ch < ' ') {\n+            n++;\n+        }\n+        if (pchars + i + n >= current->cols) {\n+            break;\n+        }\n+        if (ch < ' ') {\n+            /* A control character, so write the buffer so far */\n+            outputChars(current, buf, b);\n+            buf += b + w;\n+            b = 0;\n+            outputControlChar(current, ch + '@');\n+            if (i < pos) {\n+                backup++;\n+            }\n+        }\n+        else {\n+            b += w;\n+        }\n+    }\n+    outputChars(current, buf, b);\n+\n+    /* Erase to right, move cursor to original position */\n+    eraseEol(current);\n+    setCursorPos(current, pos + pchars + backup);\n+}\n+\n+static void set_current(struct current *current, const char *str)\n+{\n+    strncpy(current->buf, str, current->bufmax);\n+    current->buf[current->bufmax - 1] = 0;\n+    current->len = strlen(current->buf);\n+    current->pos = current->chars = utf8_strlen(current->buf, current->len);\n+}\n+\n+static int has_room(struct current *current, int bytes)\n+{\n+    return current->len + bytes < current->bufmax - 1;\n+}\n+\n+/**\n+ * Removes the char at 'pos'.\n+ *\n+ * Returns 1 if the line needs to be refreshed, 2 if not\n+ * and 0 if nothing was removed\n+ */\n+static int remove_char(struct current *current, int pos)\n+{\n+    if (pos >= 0 && pos < current->chars) {\n+        int p1, p2;\n+        int ret = 1;\n+        p1 = utf8_index(current->buf, pos);\n+        p2 = p1 + utf8_index(current->buf + p1, 1);\n+\n+#ifdef USE_TERMIOS\n+        /* optimise remove char in the case of removing the last char */\n+        if (current->pos == pos + 1 && current->pos == current->chars) {\n+            if (current->buf[pos] >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n+                ret = 2;\n+                fd_printf(current->fd, \"\\b \\b\");\n+            }\n+        }\n+#endif\n+\n+        /* Move the null char too */\n+        memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);\n+        current->len -= (p2 - p1);\n+        current->chars--;\n+\n+        if (current->pos > pos) {\n+            current->pos--;\n+        }\n+        return ret;\n+    }\n+    return 0;\n+}\n+\n+/**\n+ * Insert 'ch' at position 'pos'\n+ *\n+ * Returns 1 if the line needs to be refreshed, 2 if not\n+ * and 0 if nothing was inserted (no room)\n+ */\n+static int insert_char(struct current *current, int pos, int ch)\n+{\n+    char buf[3];\n+    int n = utf8_getchars(buf, ch);\n+\n+    if (has_room(current, n) && pos >= 0 && pos <= current->chars) {\n+        int p1, p2;\n+        int ret = 1;\n+        p1 = utf8_index(current->buf, pos);\n+        p2 = p1 + n;\n+\n+#ifdef USE_TERMIOS\n+        /* optimise the case where adding a single char to the end and no scrolling is needed */\n+        if (current->pos == pos && current->chars == pos) {\n+            if (ch >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n+                IGNORE_RC(write(current->fd, buf, n));\n+                ret = 2;\n+            }\n+        }\n+#endif\n+\n+        memmove(current->buf + p2, current->buf + p1, current->len - p1);\n+        memcpy(current->buf + p1, buf, n);\n+        current->len += n;\n+\n+        current->chars++;\n+        if (current->pos >= pos) {\n+            current->pos++;\n+        }\n+        return ret;\n+    }\n+    return 0;\n+}\n+\n+/**\n+ * Returns 0 if no chars were removed or non-zero otherwise.\n+ */\n+static int remove_chars(struct current *current, int pos, int n)\n+{\n+    int removed = 0;\n+    while (n-- && remove_char(current, pos)) {\n+        removed++;\n+    }\n+    return removed;\n+}\n+\n+#ifndef NO_COMPLETION\n+static linenoiseCompletionCallback *completionCallback = NULL;\n+\n+static void beep() {\n+#ifdef USE_TERMIOS\n+    fprintf(stderr, \"\\x7\");\n+    fflush(stderr);\n+#endif\n+}\n+\n+static void freeCompletions(linenoiseCompletions *lc) {\n+    size_t i;\n+    for (i = 0; i < lc->len; i++)\n+        free(lc->cvec[i]);\n+    free(lc->cvec);\n+}\n+\n+static int completeLine(struct current *current) {\n+    linenoiseCompletions lc = { 0, NULL };\n+    int c = 0;\n+\n+    completionCallback(current->buf,&lc);\n+    if (lc.len == 0) {\n+        beep();\n+    } else {\n+        size_t stop = 0, i = 0;\n+\n+        while(!stop) {\n+            /* Show completion or original buffer */\n+            if (i < lc.len) {\n+                struct current tmp = *current;\n+                tmp.buf = lc.cvec[i];\n+                tmp.pos = tmp.len = strlen(tmp.buf);\n+                tmp.chars = utf8_strlen(tmp.buf, tmp.len);\n+                refreshLine(current->prompt, &tmp);\n+            } else {\n+                refreshLine(current->prompt, current);\n+            }\n+\n+            c = fd_read(current);\n+            if (c == -1) {\n+                break;\n+            }\n+\n+            switch(c) {\n+                case '\\t': /* tab */\n+                    i = (i+1) % (lc.len+1);\n+                    if (i == lc.len) beep();\n+                    break;\n+                case 27: /* escape */\n+                    /* Re-show original buffer */\n+                    if (i < lc.len) {\n+                        refreshLine(current->prompt, current);\n+                    }\n+                    stop = 1;\n+                    break;\n+                default:\n+                    /* Update buffer and return */\n+                    if (i < lc.len) {\n+                        set_current(current,lc.cvec[i]);\n+                    }\n+                    stop = 1;\n+                    break;\n+            }\n+        }\n+    }\n+\n+    freeCompletions(&lc);\n+    return c; /* Return last read character */\n+}\n+\n+/* Register a callback function to be called for tab-completion. */\n+void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n+    completionCallback = fn;\n+}\n+\n+void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n+    lc->cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n+    lc->cvec[lc->len++] = strdup(str);\n+}\n+\n+#endif\n+\n+static int linenoisePrompt(struct current *current) {\n+    int history_index = 0;\n+\n+    /* The latest history entry is always our current buffer, that\n+     * initially is just an empty string. */\n+    linenoiseHistoryAdd(\"\");\n+\n+    set_current(current, \"\");\n+    refreshLine(current->prompt, current);\n+\n+    while(1) {\n+        int dir = -1;\n+        int c = fd_read(current);\n+\n+#ifndef NO_COMPLETION\n+        /* Only autocomplete when the callback is set. It returns < 0 when\n+         * there was an error reading from fd. Otherwise it will return the\n+         * character that should be handled next. */\n+        if (c == '\\t' && current->pos == current->chars && completionCallback != NULL) {\n+            c = completeLine(current);\n+            /* Return on errors */\n+            if (c < 0) return current->len;\n+            /* Read next character when 0 */\n+            if (c == 0) continue;\n+        }\n+#endif\n+\n+process_char:\n+        if (c == -1) return current->len;\n+#ifdef USE_TERMIOS\n+        if (c == 27) {   /* escape sequence */\n+            c = check_special(current->fd);\n+        }\n+#endif\n+        switch(c) {\n+        case '\\r':    /* enter */\n+            history_len--;\n+            free(history[history_len]);\n+            return current->len;\n+        case ctrl('C'):     /* ctrl-c */\n+            errno = EAGAIN;\n+            return -1;\n+        case 127:   /* backspace */\n+        case ctrl('H'):\n+            if (remove_char(current, current->pos - 1) == 1) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('D'):     /* ctrl-d */\n+            if (current->len == 0) {\n+                /* Empty line, so EOF */\n+                history_len--;\n+                free(history[history_len]);\n+                return -1;\n+            }\n+            /* Otherwise fall through to delete char to right of cursor */\n+        case SPECIAL_DELETE:\n+            if (remove_char(current, current->pos) == 1) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('W'):    /* ctrl-w */\n+            /* eat any spaces on the left */\n+            {\n+                int pos = current->pos;\n+                while (pos > 0 && get_char(current, pos - 1) == ' ') {\n+                    pos--;\n+                }\n+\n+                /* now eat any non-spaces on the left */\n+                while (pos > 0 && get_char(current, pos - 1) != ' ') {\n+                    pos--;\n+                }\n+\n+                if (remove_chars(current, pos, current->pos - pos)) {\n+                    refreshLine(current->prompt, current);\n+                }\n+            }\n+            break;\n+        case ctrl('R'):    /* ctrl-r */\n+            {\n+                /* Display the reverse-i-search prompt and process chars */\n+                char rbuf[50];\n+                char rprompt[80];\n+                int rchars = 0;\n+                int rlen = 0;\n+                int searchpos = history_len - 1;\n+\n+                rbuf[0] = 0;\n+                while (1) {\n+                    int n = 0;\n+                    const char *p = NULL;\n+                    int skipsame = 0;\n+                    int searchdir = -1;\n+\n+                    snprintf(rprompt, sizeof(rprompt), \"(reverse-i-search)'%s': \", rbuf);\n+                    refreshLine(rprompt, current);\n+                    c = fd_read(current);\n+                    if (c == ctrl('H') || c == 127) {\n+                        if (rchars) {\n+                            int p = utf8_index(rbuf, --rchars);\n+                            rbuf[p] = 0;\n+                            rlen = strlen(rbuf);\n+                        }\n+                        continue;\n+                    }\n+#ifdef USE_TERMIOS\n+                    if (c == 27) {\n+                        c = check_special(current->fd);\n+                    }\n+#endif\n+                    if (c == ctrl('P') || c == SPECIAL_UP) {\n+                        /* Search for the previous (earlier) match */\n+                        if (searchpos > 0) {\n+                            searchpos--;\n+                        }\n+                        skipsame = 1;\n+                    }\n+                    else if (c == ctrl('N') || c == SPECIAL_DOWN) {\n+                        /* Search for the next (later) match */\n+                        if (searchpos < history_len) {\n+                            searchpos++;\n+                        }\n+                        searchdir = 1;\n+                        skipsame = 1;\n+                    }\n+                    else if (c >= ' ') {\n+                        if (rlen >= (int)sizeof(rbuf) + 3) {\n+                            continue;\n+                        }\n+\n+                        n = utf8_getchars(rbuf + rlen, c);\n+                        rlen += n;\n+                        rchars++;\n+                        rbuf[rlen] = 0;\n+\n+                        /* Adding a new char resets the search location */\n+                        searchpos = history_len - 1;\n+                    }\n+                    else {\n+                        /* Exit from incremental search mode */\n+                        break;\n+                    }\n+\n+                    /* Now search through the history for a match */\n+                    for (; searchpos >= 0 && searchpos < history_len; searchpos += searchdir) {\n+                        p = strstr(history[searchpos], rbuf);\n+                        if (p) {\n+                            /* Found a match */\n+                            if (skipsame && strcmp(history[searchpos], current->buf) == 0) {\n+                                /* But it is identical, so skip it */\n+                                continue;\n+                            }\n+                            /* Copy the matching line and set the cursor position */\n+                            set_current(current,history[searchpos]);\n+                            current->pos = utf8_strlen(history[searchpos], p - history[searchpos]);\n+                            break;\n+                        }\n+                    }\n+                    if (!p && n) {\n+                        /* No match, so don't add it */\n+                        rchars--;\n+                        rlen -= n;\n+                        rbuf[rlen] = 0;\n+                    }\n+                }\n+                if (c == ctrl('G') || c == ctrl('C')) {\n+                    /* ctrl-g terminates the search with no effect */\n+                    set_current(current, \"\");\n+                    c = 0;\n+                }\n+                else if (c == ctrl('J')) {\n+                    /* ctrl-j terminates the search leaving the buffer in place */\n+                    c = 0;\n+                }\n+                /* Go process the char normally */\n+                refreshLine(current->prompt, current);\n+                goto process_char;\n+            }\n+            break;\n+        case ctrl('T'):    /* ctrl-t */\n+            if (current->pos > 0 && current->pos < current->chars) {\n+                c = get_char(current, current->pos);\n+                remove_char(current, current->pos);\n+                insert_char(current, current->pos - 1, c);\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('V'):    /* ctrl-v */\n+            if (has_room(current, 3)) {\n+                /* Insert the ^V first */\n+                if (insert_char(current, current->pos, c)) {\n+                    refreshLine(current->prompt, current);\n+                    /* Now wait for the next char. Can insert anything except \\0 */\n+                    c = fd_read(current);\n+\n+                    /* Remove the ^V first */\n+                    remove_char(current, current->pos - 1);\n+                    if (c != -1) {\n+                        /* Insert the actual char */\n+                        insert_char(current, current->pos, c);\n+                    }\n+                    refreshLine(current->prompt, current);\n+                }\n+            }\n+            break;\n+        case ctrl('B'):\n+        case SPECIAL_LEFT:\n+            if (current->pos > 0) {\n+                current->pos--;\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('F'):\n+        case SPECIAL_RIGHT:\n+            if (current->pos < current->chars) {\n+                current->pos++;\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('P'):\n+        case SPECIAL_UP:\n+            dir = 1;\n+        case ctrl('N'):\n+        case SPECIAL_DOWN:\n+            if (history_len > 1) {\n+                /* Update the current history entry before to\n+                 * overwrite it with tne next one. */\n+                free(history[history_len-1-history_index]);\n+                history[history_len-1-history_index] = strdup(current->buf);\n+                /* Show the new entry */\n+                history_index += dir;\n+                if (history_index < 0) {\n+                    history_index = 0;\n+                    break;\n+                } else if (history_index >= history_len) {\n+                    history_index = history_len-1;\n+                    break;\n+                }\n+                set_current(current, history[history_len-1-history_index]);\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('A'): /* Ctrl+a, go to the start of the line */\n+        case SPECIAL_HOME:\n+            current->pos = 0;\n+            refreshLine(current->prompt, current);\n+            break;\n+        case ctrl('E'): /* ctrl+e, go to the end of the line */\n+        case SPECIAL_END:\n+            current->pos = current->chars;\n+            refreshLine(current->prompt, current);\n+            break;\n+        case ctrl('U'): /* Ctrl+u, delete to beginning of line. */\n+            if (remove_chars(current, 0, current->pos)) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('K'): /* Ctrl+k, delete from current to end of line. */\n+            if (remove_chars(current, current->pos, current->chars - current->pos)) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n+        case ctrl('L'): /* Ctrl+L, clear screen */\n+            clearScreen(current);\n+            /* Force recalc of window size for serial terminals */\n+            current->cols = 0;\n+            refreshLine(current->prompt, current);\n+            break;\n+        default:\n+            /* Only tab is allowed without ^V */\n+            if (c == '\\t' || c >= ' ') {\n+                if (insert_char(current, current->pos, c) == 1) {\n+                    refreshLine(current->prompt, current);\n+                }\n+            }\n+            break;\n+        }\n+    }\n+    return current->len;\n+}\n+\n+char *linenoise(const char *prompt)\n+{\n+    int count;\n+    struct current current;\n+    char buf[LINENOISE_MAX_LINE];\n+\n+    if (enableRawMode(&current) == -1) {\n+\tprintf(\"%s\", prompt);\n+        fflush(stdout);\n+        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n+\t\treturn NULL;\n+        }\n+        count = strlen(buf);\n+        if (count && buf[count-1] == '\\n') {\n+            count--;\n+            buf[count] = '\\0';\n+        }\n+    }\n+    else\n+    {\n+        current.buf = buf;\n+        current.bufmax = sizeof(buf);\n+        current.len = 0;\n+        current.chars = 0;\n+        current.pos = 0;\n+        current.prompt = prompt;\n+\n+        count = linenoisePrompt(&current);\n+        disableRawMode(&current);\n+        printf(\"\\n\");\n+        if (count == -1) {\n+            return NULL;\n+        }\n+    }\n+    return strdup(buf);\n+}\n+\n+/* Using a circular buffer is smarter, but a bit more complex to handle. */\n+int linenoiseHistoryAdd(const char *line) {\n+    char *linecopy;\n+\n+    if (history_max_len == 0) return 0;\n+    if (history == NULL) {\n+        history = (char **)malloc(sizeof(char*)*history_max_len);\n+        if (history == NULL) return 0;\n+        memset(history,0,(sizeof(char*)*history_max_len));\n+    }\n+\n+    /* do not insert duplicate lines into history */\n+    if (history_len > 0 && strcmp(line, history[history_len - 1]) == 0) {\n+        return 0;\n+    }\n+\n+    linecopy = strdup(line);\n+    if (!linecopy) return 0;\n+    if (history_len == history_max_len) {\n+        free(history[0]);\n+        memmove(history,history+1,sizeof(char*)*(history_max_len-1));\n+        history_len--;\n+    }\n+    history[history_len] = linecopy;\n+    history_len++;\n+    return 1;\n+}\n+\n+int linenoiseHistorySetMaxLen(int len) {\n+    char **newHistory;\n+\n+    if (len < 1) return 0;\n+    if (history) {\n+        int tocopy = history_len;\n+\n+        newHistory = (char **)malloc(sizeof(char*)*len);\n+        if (newHistory == NULL) return 0;\n+        if (len < tocopy) tocopy = len;\n+        memcpy(newHistory,history+(history_max_len-tocopy), sizeof(char*)*tocopy);\n+        free(history);\n+        history = newHistory;\n+    }\n+    history_max_len = len;\n+    if (history_len > history_max_len)\n+        history_len = history_max_len;\n+    return 1;\n+}\n+\n+/* Save the history in the specified file. On success 0 is returned\n+ * otherwise -1 is returned. */\n+int linenoiseHistorySave(const char *filename) {\n+    FILE *fp = fopen(filename,\"w\");\n+    int j;\n+\n+    if (fp == NULL) return -1;\n+    for (j = 0; j < history_len; j++) {\n+        const char *str = history[j];\n+        /* Need to encode backslash, nl and cr */\n+        while (*str) {\n+            if (*str == '\\\\') {\n+                fputs(\"\\\\\\\\\", fp);\n+            }\n+            else if (*str == '\\n') {\n+                fputs(\"\\\\n\", fp);\n+            }\n+            else if (*str == '\\r') {\n+                fputs(\"\\\\r\", fp);\n+            }\n+            else {\n+                fputc(*str, fp);\n+            }\n+            str++;\n+        }\n+        fputc('\\n', fp);\n+    }\n+\n+    fclose(fp);\n+    return 0;\n+}\n+\n+/* Load the history from the specified file. If the file does not exist\n+ * zero is returned and no operation is performed.\n+ *\n+ * If the file exists and the operation succeeded 0 is returned, otherwise\n+ * on error -1 is returned. */\n+int linenoiseHistoryLoad(const char *filename) {\n+    FILE *fp = fopen(filename,\"r\");\n+    char buf[LINENOISE_MAX_LINE];\n+\n+    if (fp == NULL) return -1;\n+\n+    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {\n+        char *src, *dest;\n+\n+        /* Decode backslash escaped values */\n+        for (src = dest = buf; *src; src++) {\n+            char ch = *src;\n+\n+            if (ch == '\\\\') {\n+                src++;\n+                if (*src == 'n') {\n+                    ch = '\\n';\n+                }\n+                else if (*src == 'r') {\n+                    ch = '\\r';\n+                } else {\n+                    ch = *src;\n+                }\n+            }\n+            *dest++ = ch;\n+        }\n+        /* Remove trailing newline */\n+        if (dest != buf && (dest[-1] == '\\n' || dest[-1] == '\\r')) {\n+            dest--;\n+        }\n+        *dest = 0;\n+\n+        linenoiseHistoryAdd(buf);\n+    }\n+    fclose(fp);\n+    return 0;\n+}\n+\n+/* Provide access to the history buffer.\n+ *\n+ * If 'len' is not NULL, the length is stored in *len.\n+ */\n+char **linenoiseHistory(int *len) {\n+    if (len) {\n+        *len = history_len;\n+    }\n+    return history;\n+}"}, {"sha": "59f28976d67e5a7280526c803f8da71dee8533ce", "filename": "src/rt/linenoise/linenoise.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Flinenoise.h", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Flinenoise.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.h?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,59 @@\n+/* linenoise.h -- guerrilla line editing library against the idea that a\n+ * line editing lib needs to be 20,000 lines of C code.\n+ *\n+ * See linenoise.c for more information.\n+ *\n+ * ------------------------------------------------------------------------\n+ *\n+ * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n+ * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are\n+ * met:\n+ *\n+ *  *  Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *  *  Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef __LINENOISE_H\n+#define __LINENOISE_H\n+\n+#ifndef NO_COMPLETION\n+typedef struct linenoiseCompletions {\n+  size_t len;\n+  char **cvec;\n+} linenoiseCompletions;\n+\n+typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);\n+void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);\n+void linenoiseAddCompletion(linenoiseCompletions *, const char *);\n+#endif\n+\n+char *linenoise(const char *prompt);\n+int linenoiseHistoryAdd(const char *line);\n+int linenoiseHistorySetMaxLen(int len);\n+int linenoiseHistorySave(const char *filename);\n+int linenoiseHistoryLoad(const char *filename);\n+void linenoiseHistoryFree(void);\n+char **linenoiseHistory(int *len);\n+\n+#endif /* __LINENOISE_H */"}, {"sha": "26924b46c19154755c904038c949a98b033e3c50", "filename": "src/rt/linenoise/utf8.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Futf8.c", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Futf8.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.c?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,115 @@\n+/**\n+ * UTF-8 utility functions\n+ *\n+ * (c) 2010 Steve Bennett <steveb@workware.net.au>\n+ *\n+ * See LICENCE for licence details.\n+ */\n+\n+#include <ctype.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include \"utf8.h\"\n+\n+#ifdef USE_UTF8\n+int utf8_fromunicode(char *p, unsigned short uc)\n+{\n+    if (uc <= 0x7f) {\n+        *p = uc;\n+        return 1;\n+    }\n+    else if (uc <= 0x7ff) {\n+        *p++ = 0xc0 | ((uc & 0x7c0) >> 6);\n+        *p = 0x80 | (uc & 0x3f);\n+        return 2;\n+    }\n+    else {\n+        *p++ = 0xe0 | ((uc & 0xf000) >> 12);\n+        *p++ = 0x80 | ((uc & 0xfc0) >> 6);\n+        *p = 0x80 | (uc & 0x3f);\n+        return 3;\n+    }\n+}\n+\n+int utf8_charlen(int c)\n+{\n+    if ((c & 0x80) == 0) {\n+        return 1;\n+    }\n+    if ((c & 0xe0) == 0xc0) {\n+        return 2;\n+    }\n+    if ((c & 0xf0) == 0xe0) {\n+        return 3;\n+    }\n+    if ((c & 0xf8) == 0xf0) {\n+        return 4;\n+    }\n+    /* Invalid sequence */\n+    return -1;\n+}\n+\n+int utf8_strlen(const char *str, int bytelen)\n+{\n+    int charlen = 0;\n+    if (bytelen < 0) {\n+        bytelen = strlen(str);\n+    }\n+    while (bytelen) {\n+        int c;\n+        int l = utf8_tounicode(str, &c);\n+        charlen++;\n+        str += l;\n+        bytelen -= l;\n+    }\n+    return charlen;\n+}\n+\n+int utf8_index(const char *str, int index)\n+{\n+    const char *s = str;\n+    while (index--) {\n+        int c;\n+        s += utf8_tounicode(s, &c);\n+    }\n+    return s - str;\n+}\n+\n+int utf8_charequal(const char *s1, const char *s2)\n+{\n+    int c1, c2;\n+\n+    utf8_tounicode(s1, &c1);\n+    utf8_tounicode(s2, &c2);\n+\n+    return c1 == c2;\n+}\n+\n+int utf8_tounicode(const char *str, int *uc)\n+{\n+    unsigned const char *s = (unsigned const char *)str;\n+\n+    if (s[0] < 0xc0) {\n+        *uc = s[0];\n+        return 1;\n+    }\n+    if (s[0] < 0xe0) {\n+        if ((s[1] & 0xc0) == 0x80) {\n+            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);\n+            return 2;\n+        }\n+    }\n+    else if (s[0] < 0xf0) {\n+        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {\n+            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);\n+            return 3;\n+        }\n+    }\n+\n+    /* Invalid sequence, so just return the byte */\n+    *uc = *s;\n+    return 1;\n+}\n+\n+#endif"}, {"sha": "9537939876ae091451500330b488485f740361f7", "filename": "src/rt/linenoise/utf8.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Futf8.h", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Flinenoise%2Futf8.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.h?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,79 @@\n+#ifndef UTF8_UTIL_H\n+#define UTF8_UTIL_H\n+/**\n+ * UTF-8 utility functions\n+ *\n+ * (c) 2010 Steve Bennett <steveb@workware.net.au>\n+ *\n+ * See LICENCE for licence details.\n+ */\n+\n+#ifndef USE_UTF8\n+#include <ctype.h>\n+\n+/* No utf-8 support. 1 byte = 1 char */\n+#define utf8_strlen(S, B) ((B) < 0 ? (int)strlen(S) : (B))\n+#define utf8_tounicode(S, CP) (*(CP) = (unsigned char)*(S), 1)\n+#define utf8_index(C, I) (I)\n+#define utf8_charlen(C) 1\n+\n+#else\n+/**\n+ * Converts the given unicode codepoint (0 - 0xffff) to utf-8\n+ * and stores the result at 'p'.\n+ * \n+ * Returns the number of utf-8 characters (1-3).\n+ */\n+int utf8_fromunicode(char *p, unsigned short uc);\n+\n+/**\n+ * Returns the length of the utf-8 sequence starting with 'c'.\n+ * \n+ * Returns 1-4, or -1 if this is not a valid start byte.\n+ *\n+ * Note that charlen=4 is not supported by the rest of the API.\n+ */\n+int utf8_charlen(int c);\n+\n+/**\n+ * Returns the number of characters in the utf-8 \n+ * string of the given byte length.\n+ *\n+ * Any bytes which are not part of an valid utf-8\n+ * sequence are treated as individual characters.\n+ *\n+ * The string *must* be null terminated.\n+ *\n+ * Does not support unicode code points > \\uffff\n+ */\n+int utf8_strlen(const char *str, int bytelen);\n+\n+/**\n+ * Returns the byte index of the given character in the utf-8 string.\n+ * \n+ * The string *must* be null terminated.\n+ *\n+ * This will return the byte length of a utf-8 string\n+ * if given the char length.\n+ */\n+int utf8_index(const char *str, int charindex);\n+\n+/**\n+ * Returns the unicode codepoint corresponding to the\n+ * utf-8 sequence 'str'.\n+ * \n+ * Stores the result in *uc and returns the number of bytes\n+ * consumed.\n+ *\n+ * If 'str' is null terminated, then an invalid utf-8 sequence\n+ * at the end of the string will be returned as individual bytes.\n+ *\n+ * If it is not null terminated, the length *must* be checked first.\n+ *\n+ * Does not support unicode code points > \\uffff\n+ */\n+int utf8_tounicode(const char *str, int *uc);\n+\n+#endif\n+\n+#endif"}, {"sha": "8dac7d515b36fa39caeae6e94745127fcc38f6eb", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -203,3 +203,10 @@ rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n rust_uv_tcp_getpeername6\n+linenoise\n+linenoiseSetCompletionCallback\n+linenoiseAddCompletion\n+linenoiseHistoryAdd\n+linenoiseHistorySetMaxLen\n+linenoiseHistorySave\n+linenoiseHistoryLoad"}, {"sha": "ac5edd4b48c247624c1135e85185d653b9cab5f4", "filename": "src/rusti/rusti.rc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frusti%2Frusti.rc?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,33 @@\n+// rusti - REPL using the JIT backend\n+\n+#[link(name = \"rusti\",\n+       vers = \"0.4\",\n+       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n+\n+#[crate_type = \"bin\"];\n+\n+#[no_core];\n+\n+#[allow(vecs_implicitly_copyable,\n+        non_implicitly_copyable_typarams)];\n+\n+extern mod core(vers = \"0.4\");\n+extern mod std(vers = \"0.4\");\n+extern mod rustc(vers = \"0.4\");\n+extern mod syntax(vers = \"0.4\");\n+\n+use core::*;\n+use io::{ReaderUtil, WriterUtil};\n+use rustc::back;\n+use rustc::driver::{driver, session};\n+use rustc::front;\n+use rustc::lib::llvm::llvm;\n+use rustc::metadata::{creader, filesearch};\n+use rustc::middle::{freevars, kind, lint, trans, ty, typeck};\n+use rustc::middle;\n+use syntax::{ast, ast_util, codemap, diagnostic, fold, parse, print, visit};\n+use syntax::ast_util::*;\n+use parse::token;\n+use print::{pp, pprust};\n+use std::rl;"}, {"sha": "5f1cad3ae17ce6544e0c65246dfc6a03c6cd2453", "filename": "src/rusti/rusti.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frusti%2Frusti.rs?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,325 @@\n+/**\n+ * A structure shared across REPL instances for storing history\n+ * such as statements and view items. I wish the AST was sendable.\n+ */\n+struct Repl {\n+    prompt: ~str,\n+    binary: ~str,\n+    running: bool,\n+    view_items: ~str,\n+    stmts: ~str\n+}\n+\n+/// A utility function that hands off a pretty printer to a callback.\n+fn with_pp(intr: @token::ident_interner,\n+           cb: fn(pprust::ps, io::Writer)) -> ~str {\n+    do io::with_str_writer |writer| {\n+        let pp = pprust::rust_printer(writer, intr);\n+\n+        cb(pp, writer);\n+        pp::eof(pp.s);\n+    }\n+}\n+\n+/**\n+ * The AST (or the rest of rustc) are not sendable yet,\n+ * so recorded things are printed to strings. A terrible hack that\n+ * needs changes to rustc in order to be outed. This is unfortunately\n+ * going to cause the REPL to regress in parser performance,\n+ * because it has to parse the statements and view_items on each\n+ * input.\n+ */\n+fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n+    let view_items = if blk.node.view_items.len() > 0 {\n+        let new_view_items = do with_pp(intr) |pp, writer| {\n+            for blk.node.view_items.each |view_item| {\n+                pprust::print_view_item(pp, *view_item);\n+                writer.write_line(~\"\");\n+            }\n+        };\n+\n+        debug!(\"new view items %s\", new_view_items);\n+\n+        repl.view_items + \"\\n\" + new_view_items\n+    } else { repl.view_items };\n+    let stmts = if blk.node.stmts.len() > 0 {\n+        let new_stmts = do with_pp(intr) |pp, writer| {\n+            for blk.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    ast::stmt_decl(*) => {\n+                        pprust::print_stmt(pp, **stmt);\n+                        writer.write_line(~\"\");\n+                    }\n+                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                        match expr.node {\n+                            ast::expr_assign(*) |\n+                            ast::expr_assign_op(*) |\n+                            ast::expr_swap(*) => {\n+                                pprust::print_stmt(pp, **stmt);\n+                                writer.write_line(~\"\");\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        debug!(\"new stmts %s\", new_stmts);\n+\n+        repl.stmts + \"\\n\" + new_stmts\n+    } else { repl.stmts };\n+\n+    Repl{\n+        view_items: view_items,\n+        stmts: stmts,\n+        .. repl\n+    }\n+}\n+\n+/// Run an input string in a Repl, returning the new Repl.\n+fn run(repl: Repl, input: ~str) -> Repl {\n+    let options: @session::options = @{\n+        crate_type: session::unknown_crate,\n+        binary: repl.binary,\n+        addl_lib_search_paths: ~[os::getcwd()],\n+        .. *session::basic_options()\n+    };\n+\n+    debug!(\"building driver input\");\n+    let head = include_str!(\"wrapper.rs\");\n+    let foot = fmt!(\"%s\\nfn main() {\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n+                    repl.view_items, repl.stmts, input);\n+    let wrapped = driver::str_input(head + foot);\n+\n+    debug!(\"inputting %s\", head + foot);\n+\n+    debug!(\"building a driver session\");\n+    let sess = driver::build_session(options, diagnostic::emit);\n+\n+    debug!(\"building driver configuration\");\n+    let cfg = driver::build_configuration(sess,\n+                                          repl.binary,\n+                                          wrapped);\n+\n+    debug!(\"parsing\");\n+    let mut crate = driver::parse_input(sess, cfg, wrapped);\n+    let mut opt = None;\n+\n+    for crate.node.module.items.each |item| {\n+        match item.node {\n+            ast::item_fn(_, _, _, blk) => {\n+                if item.ident == sess.ident_of(~\"main\") {\n+                    opt = blk.node.expr;\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let blk = match opt.get().node {\n+        ast::expr_call(_, exprs, _) => {\n+            match exprs[0].node {\n+                ast::expr_block(blk) => @blk,\n+                _ => fail\n+            }\n+        }\n+        _ => fail\n+    };\n+\n+    debug!(\"configuration\");\n+    crate = front::config::strip_unconfigured_items(crate);\n+\n+    debug!(\"maybe building test harness\");\n+    crate = front::test::modify_for_testing(sess, crate);\n+\n+    debug!(\"expansion\");\n+    crate = syntax::ext::expand::expand_crate(sess.parse_sess,\n+                                              sess.opts.cfg,\n+                                              crate);\n+\n+    debug!(\"intrinsic injection\");\n+    crate = front::intrinsic_inject::inject_intrinsic(sess, crate);\n+\n+    debug!(\"core injection\");\n+    crate = front::core_inject::maybe_inject_libcore_ref(sess, crate);\n+\n+    debug!(\"building lint settings table\");\n+    lint::build_settings_crate(sess, crate);\n+\n+    debug!(\"ast indexing\");\n+    let ast_map = syntax::ast_map::map_crate(sess.diagnostic(), *crate);\n+\n+    debug!(\"external crate/lib resolution\");\n+    creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+                         sess.filesearch,\n+                         session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                         sess.opts.static, sess.parse_sess.interner);\n+\n+    debug!(\"language item collection\");\n+    let lang_items = middle::lang_items::collect_language_items(crate, sess);\n+\n+    debug!(\"resolution\");\n+    let {def_map: def_map,\n+         exp_map2: exp_map2,\n+         trait_map: trait_map} = middle::resolve::resolve_crate(sess,\n+                                                                lang_items,\n+                                                                crate);\n+\n+    debug!(\"freevar finding\");\n+    let freevars = freevars::annotate_freevars(def_map, crate);\n+\n+    debug!(\"region_resolution\");\n+    let region_map = middle::region::resolve_crate(sess, def_map, crate);\n+\n+    debug!(\"region paramaterization inference\");\n+    let rp_set = middle::region::determine_rp_in_crate(sess, ast_map,\n+                                                       def_map, crate);\n+\n+    debug!(\"typechecking\");\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set, move lang_items, crate);\n+    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map,\n+                                                       crate);\n+\n+    debug!(\"const marking\");\n+    middle::const_eval::process_crate(crate, def_map, ty_cx);\n+\n+    debug!(\"const checking\");\n+    middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                     method_map, ty_cx);\n+\n+    debug!(\"privacy checking\");\n+    middle::privacy::check_crate(ty_cx, &method_map, crate);\n+\n+    debug!(\"loop checking\");\n+    middle::check_loop::check_crate(ty_cx, crate);\n+\n+    debug!(\"alt checking\");\n+    middle::check_alt::check_crate(ty_cx, crate);\n+\n+    debug!(\"liveness checking\");\n+    let last_use_map = middle::liveness::check_crate(ty_cx,\n+                                                     method_map, crate);\n+\n+    debug!(\"borrow checking\");\n+    let (root_map, mutbl_map) = middle::borrowck::check_crate(ty_cx,\n+                                                              method_map,\n+                                                              last_use_map,\n+                                                              crate);\n+\n+    debug!(\"kind checking\");\n+    kind::check_crate(ty_cx, method_map, last_use_map, crate);\n+\n+    debug!(\"lint checking\");\n+    lint::check_crate(ty_cx, crate);\n+\n+    let maps = {mutbl_map: mutbl_map,\n+                root_map: root_map,\n+                last_use_map: last_use_map,\n+                method_map: method_map,\n+                vtable_map: vtable_map};\n+\n+    debug!(\"translation\");\n+    let (llmod, _) = trans::base::trans_crate(sess, crate, ty_cx,\n+                                              ~path::from_str(\"<repl>\"),\n+                                              exp_map2, maps);\n+    let pm = llvm::LLVMCreatePassManager();\n+\n+    debug!(\"executing jit\");\n+    back::link::jit::exec(sess, pm, llmod, 0, false);\n+    llvm::LLVMDisposePassManager(pm);\n+\n+    debug!(\"recording input into repl history\");\n+    record(repl, blk, sess.parse_sess.interner)\n+}\n+\n+/// Run a command, e.g. :clear, :exit, etc.\n+fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n+           cmd: ~str, _args: ~[~str]) {\n+    match cmd {\n+        ~\"exit\" => repl.running = false,\n+        ~\"clear\" => {\n+            repl.view_items = ~\"\";\n+            repl.stmts = ~\"\";\n+\n+            // FIXME: Win32 version of linenoise doesn't have the required function\n+            //rl::clear();\n+        }\n+        ~\"help\" => {\n+            io::println(~\":clear - clear the screen\\n\" +\n+                        ~\":exit - exit from the repl\\n\" +\n+                        ~\":help - show this message\");\n+        }\n+        _ => io::println(~\"unknown cmd: \" + cmd)\n+    }\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let in = io::stdin();\n+    let out = io::stdout();\n+    let mut repl = Repl {\n+        prompt: ~\"rusti> \",\n+        binary: args[0],\n+        running: true,\n+        view_items: ~\"\",\n+        stmts: ~\"\"\n+    };\n+\n+    do rl::complete |line, suggest| {\n+        if line.starts_with(\":\") {\n+            suggest(~\":clear\");\n+            suggest(~\":exit\");\n+            suggest(~\":help\");\n+        }\n+    }\n+\n+    while repl.running {\n+        let result = rl::read(repl.prompt);\n+\n+        if result.is_none() {\n+            break;\n+        }\n+\n+        let line = result.get();\n+\n+        if line.is_empty() {\n+            io::println(~\"()\");\n+\n+            loop;\n+        }\n+\n+        rl::add_history(line);\n+\n+        if line.starts_with(~\":\") {\n+            let full = line.substr(1, line.len() - 1);\n+            let split = full.split_char(' ');\n+            let len = split.len();\n+\n+            if len > 0 {\n+                let cmd = split[0];\n+\n+                if !cmd.is_empty() {\n+                    let args = if len > 1 {\n+                        do vec::view(split, 1, len - 1).map |arg| {\n+                            *arg\n+                        }\n+                    } else { ~[] };\n+\n+                    run_cmd(&mut repl, in, out, cmd, args);\n+\n+                    loop;\n+                }\n+            }\n+        }\n+\n+        let result = do task::try |copy repl| {\n+            run(copy repl, line)\n+        };\n+\n+        if result.is_ok() {\n+            repl = result.get();\n+        }\n+    }\n+}"}, {"sha": "1e98aa81369c5fcdaa9a64a2c2a105eedccef9a3", "filename": "src/rusti/wrapper.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Fwrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0/src%2Frusti%2Fwrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frusti%2Fwrapper.rs?ref=1b0c6665d9d4c5095c86ac1e70e309c7ec9c2ca0", "patch": "@@ -0,0 +1,19 @@\n+#[allow(ctypes)];\n+#[allow(heap_memory)];\n+#[allow(implicit_copies)];\n+#[allow(managed_heap_memory)];\n+#[allow(non_camel_case_types)];\n+#[allow(non_implicitly_copyable_typarams)];\n+#[allow(owned_heap_memory)];\n+#[allow(path_statement)];\n+#[allow(structural_records)];\n+#[allow(unrecognized_lint)];\n+#[allow(unused_imports)];\n+#[allow(vecs_implicitly_copyable)];\n+#[allow(while_true)];\n+\n+extern mod std;\n+\n+fn print<T>(result: T) {\n+    io::println(fmt!(\"%?\", result));\n+}"}]}