{"sha": "b25e100173effba685d076cee16f8af150078617", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWUxMDAxNzNlZmZiYTY4NWQwNzZjZWUxNmY4YWYxNTAwNzg2MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T19:12:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T19:12:02Z"}, "message": "auto merge of #19665 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "6c045a3ce5fe575f6e4e4663d4e748780e7416cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c045a3ce5fe575f6e4e4663d4e748780e7416cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25e100173effba685d076cee16f8af150078617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25e100173effba685d076cee16f8af150078617", "html_url": "https://github.com/rust-lang/rust/commit/b25e100173effba685d076cee16f8af150078617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25e100173effba685d076cee16f8af150078617/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4982f0f8643af9e7deede95ad5e4e8df854d66", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4982f0f8643af9e7deede95ad5e4e8df854d66", "html_url": "https://github.com/rust-lang/rust/commit/ef4982f0f8643af9e7deede95ad5e4e8df854d66"}, {"sha": "1a61fe4280b476bb2131f76414c32676b91e163c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a61fe4280b476bb2131f76414c32676b91e163c", "html_url": "https://github.com/rust-lang/rust/commit/1a61fe4280b476bb2131f76414c32676b91e163c"}], "stats": {"total": 1102, "additions": 793, "deletions": 309}, "files": [{"sha": "0b9cd86c61fe47c668578026807de3c0fbbf6447", "filename": "mk/dist.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -123,15 +123,16 @@ PKG_EXE = dist/$(PKG_NAME)-$(CFG_BUILD).exe\n $(PKG_EXE): rust.iss modpath.iss upgrade.iss LICENSE.txt rust-logo.ico \\\n             $(CSREQ3_T_$(CFG_BUILD)_H_$(CFG_BUILD)) \\\n             dist-prepare-win\n-\t$(CFG_PYTHON) $(S)src/etc/make-win-dist.py tmp/dist/win $(CFG_BUILD)\n+\t$(Q)rm -rf tmp/dist/win/gcc\n+\t$(CFG_PYTHON) $(S)src/etc/make-win-dist.py tmp/dist/win/rust tmp/dist/win/gcc $(CFG_BUILD)\n \t@$(call E, ISCC: $@)\n \t$(Q)$(CFG_ISCC) $<\n \n $(eval $(call DEF_PREPARE,win))\n \n dist-prepare-win: PREPARE_HOST=$(CFG_BUILD)\n dist-prepare-win: PREPARE_TARGETS=$(CFG_BUILD)\n-dist-prepare-win: PREPARE_DEST_DIR=tmp/dist/win\n+dist-prepare-win: PREPARE_DEST_DIR=tmp/dist/win/rust\n dist-prepare-win: PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n dist-prepare-win: PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n dist-prepare-win: PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)"}, {"sha": "b567c747d6ff94da0faf22e00fa7b2b4527ca96f", "filename": "src/doc/guide-crates.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-crates.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-crates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-crates.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -32,7 +32,7 @@ two languages for those phrases to be in. We'll use this module layout:\n               +---------+   |   +-----------+\n               |             +---| farewells |\n +---------+   |                 +-----------+\n-| phrases |---+ \n+| phrases |---+\n +---------+   |                  +-----------+\n               |              +---| greetings |\n               +----------+   |   +-----------+\n@@ -219,7 +219,7 @@ Put this in `src/english/greetings.rs`:\n \n fn hello() -> String {\n     \"Hello!\".to_string()\n-}  \n+}\n ```\n \n Put this in `src/english/farewells.rs`:\n@@ -229,7 +229,7 @@ Put this in `src/english/farewells.rs`:\n \n fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n-} \n+}\n ```\n \n Put this in `src/japanese/greetings.rs`:\n@@ -239,7 +239,7 @@ Put this in `src/japanese/greetings.rs`:\n \n fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-}  \n+}\n ```\n \n Of course, you can copy and paste this from this web page, or just type\n@@ -253,7 +253,7 @@ Put this in `src/japanese/farewells.rs`:\n \n fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-} \n+}\n ```\n \n (This is \"Sayoonara\", if you're curious.)\n@@ -381,11 +381,11 @@ $ cargo run\n /home/you/projects/phrases/src/japanese/greetings.rs:1:1: 3:2 warning: code is never used: `hello`, #[warn(dead_code)] on by default\n /home/you/projects/phrases/src/japanese/greetings.rs:1 fn hello() -> String {\n /home/you/projects/phrases/src/japanese/greetings.rs:2     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-/home/you/projects/phrases/src/japanese/greetings.rs:3 } \n+/home/you/projects/phrases/src/japanese/greetings.rs:3 }\n /home/you/projects/phrases/src/japanese/farewells.rs:1:1: 3:2 warning: code is never used: `goodbye`, #[warn(dead_code)] on by default\n /home/you/projects/phrases/src/japanese/farewells.rs:1 fn goodbye() -> String {\n /home/you/projects/phrases/src/japanese/farewells.rs:2     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-/home/you/projects/phrases/src/japanese/farewells.rs:3 } \n+/home/you/projects/phrases/src/japanese/farewells.rs:3 }\n      Running `target/phrases`\n Hello in English: Hello!\n Goodbye in English: Goodbye.\n@@ -452,7 +452,7 @@ fn main() {\n \n Rust will give us a compile-time error:\n \n-```{notrust,ignore}\n+```{notrust}\n    Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n /home/you/projects/phrases/src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module\n /home/you/projects/phrases/src/main.rs:4 use phrases::japanese::greetings::hello;"}, {"sha": "71ca8913ab34b8443e5eb6de93002a5c82d7b711", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -2,7 +2,7 @@\n \n > The best-laid plans of mice and men\n > Often go awry\n-> \n+>\n > \"Tae a Moose\", Robert Burns\n \n Sometimes, things just go wrong. It's important to have a plan for when the\n@@ -76,7 +76,7 @@ fn main() {\n \n This will give us an error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: non-exhaustive patterns: `_` not covered [E0004]\n ```\n \n@@ -189,7 +189,7 @@ panic!(\"boom\");\n \n gives\n \n-```{notrust,ignore}\n+```{notrust}\n task '<main>' panicked at 'boom', hello.rs:2\n ```\n "}, {"sha": "aebafebf98ed376e893084fac84f8e4f51a5597f", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -93,7 +93,7 @@ must have a deallocation for each allocation. Rust handles this for you. It\n knows that our handle, `x`, is the owning reference to our box. Rust knows that\n `x` will go out of scope at the end of the block, and so it inserts a call to\n deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always exaclty one deallocations paired\n+for us, it's impossible to forget. We always have exactly one deallocation paired\n with each of our allocations.\n \n This is pretty straightforward, but what happens when we want to pass our box\n@@ -130,7 +130,7 @@ fn add_one(mut num: Box<int>) {\n \n This does not compile, and gives us an error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: use of moved value: `x`\n    println!(\"{}\", x);\n                   ^\n@@ -186,11 +186,11 @@ This function takes ownership, because it takes a `Box`, which owns its\n contents. But then we give ownership right back.\n \n In the physical world, you can give one of your possessions to someone for a\n-short period of time. You still own your posession, you're just letting someone\n+short period of time. You still own your possession, you're just letting someone\n else use it for a while. We call that 'lending' something to someone, and that\n person is said to be 'borrowing' that something from you.\n \n-Rust's ownershp system also allows an owner to lend out a handle for a limited\n+Rust's ownership system also allows an owner to lend out a handle for a limited\n period. This is also called 'borrowing.' Here's a version of `add_one` which\n borrows its argument rather than taking ownership:\n \n@@ -231,7 +231,7 @@ fn add_one(num: &int) -> int {\n \n Rust has a feature called 'lifetime elision,' which allows you to not write\n lifetime annotations in certain circumstances. This is one of them. Without\n-eliding the liftimes, `add_one` looks like this:\n+eliding the lifetimes, `add_one` looks like this:\n \n ```rust\n fn add_one<'a>(num: &'a int) -> int {\n@@ -254,7 +254,7 @@ This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n fn add_two<'a, 'b>(...)\n ```\n \n-Then in our parameter list, we use the liftimes we've named:\n+Then in our parameter list, we use the lifetimes we've named:\n \n ```{rust,ignore}\n ...(num: &'a int) -> ...\n@@ -279,7 +279,7 @@ fn main() {\n }\n ```\n \n-As you can see, `struct`s can also have liftimes. In a similar way to functions,\n+As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n \n ```{rust}\n struct Foo<'a> {\n@@ -295,7 +295,7 @@ x: &'a int,\n # }\n ```\n \n-uses it. So why do we need a liftime here? We need to ensure that any reference\n+uses it. So why do we need a lifetime here? We need to ensure that any reference\n to a `Foo` cannot outlive the reference to an `int` it contains.\n \n ## Thinking in scopes\n@@ -406,7 +406,7 @@ fn main() {\n We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n compiler knows that on the second iteration of the loop, there's a problem:\n \n-```{notrust,ignore}\n+```{notrust}\n error: use of moved value: `car`\n     Wheel { size: 360, owner: car };\n                               ^~~"}, {"sha": "206df711c1a53613e75971439d64f36575fd8d5a", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -84,7 +84,7 @@ println!(\"{}\", x + z);\n \n This gives us an error:\n \n-```{notrust,ignore}\n+```{notrust}\n hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n@@ -132,7 +132,7 @@ Pointers are useful in languages that are pass-by-value, rather than\n pass-by-reference. Basically, languages can make two choices (this is made\n up syntax, it's not Rust):\n \n-```{notrust,ignore}\n+```{ignore}\n func foo(x) {\n     x = 5\n }\n@@ -152,7 +152,7 @@ and therefore, can change its value. At the comment, `i` will be `5`.\n So what do pointers have to do with this? Well, since pointers point to a\n location in memory...\n \n-```{notrust,ignore}\n+```{ignore}\n func foo(&int x) {\n     *x = 5\n }\n@@ -179,7 +179,7 @@ but here are problems with pointers in other languages:\n Uninitialized pointers can cause a problem. For example, what does this program\n do?\n \n-```{notrust,ignore}\n+```{ignore}\n &int x;\n *x = 5; // whoops!\n ```\n@@ -191,7 +191,7 @@ knows. This might be harmless, and it might be catastrophic.\n When you combine pointers and functions, it's easy to accidentally invalidate\n the memory the pointer is pointing to. For example:\n \n-```{notrust,ignore}\n+```{ignore}\n func make_pointer(): &int {\n     x = 5;\n \n@@ -213,7 +213,7 @@ As one last example of a big problem with pointers, **aliasing** can be an\n issue. Two pointers are said to alias when they point at the same location\n in memory. Like this:\n \n-```{notrust,ignore}\n+```{ignore}\n func mutate(&int i, int j) {\n     *i = j;\n }\n@@ -398,7 +398,7 @@ fn main() {\n \n It gives this error:\n \n-```{notrust,ignore}\n+```{notrust}\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n test.rs:5         *x -= 1;\n                   ^~\n@@ -522,7 +522,7 @@ boxes, though. As a rough approximation, you can treat this Rust code:\n \n As being similar to this C code:\n \n-```{notrust,ignore}\n+```{ignore}\n {\n     int *x;\n     x = (int *)malloc(sizeof(int));\n@@ -626,7 +626,7 @@ fn main() {\n \n This prints:\n \n-```{notrust,ignore}\n+```{ignore}\n Cons(1, box Cons(2, box Cons(3, box Nil)))\n ```\n "}, {"sha": "43cc8483bcec54a6784ed71a6c0209b36711f29a", "filename": "src/doc/guide-strings.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -181,7 +181,7 @@ for l in s.graphemes(true) {\n \n This prints:\n \n-```{notrust,ignore}\n+```{text}\n u\u0354\n n\u030e\u0348\u0330\n i\u0319\u032e\u035a\u0326\n@@ -207,7 +207,7 @@ for l in s.chars() {\n \n This prints:\n \n-```{notrust,ignore}\n+```{text}\n u\n \u0354\n n\n@@ -252,7 +252,7 @@ for l in s.bytes() {\n \n This will print:\n \n-```{notrust,ignore}\n+```{text}\n 117\n 205\n 148"}, {"sha": "21043cfef1480e6b41b97963f0f5ce44aade292e", "filename": "src/doc/guide.md", "status": "modified", "additions": 102, "deletions": 53, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -355,7 +355,7 @@ just `cargo build` and it'll work the right way.\n \n You'll also notice that Cargo has created a new file: `Cargo.lock`.\n \n-```{ignore,notrust}\n+```{ignore}\n [root]\n name = \"hello_world\"\n version = \"0.0.1\"\n@@ -426,7 +426,7 @@ x = 10i;\n \n It will give you this error:\n \n-```{ignore,notrust}\n+```{notrust}\n error: re-assignment of immutable variable `x`\n      x = 10i;\n      ^~~~~~~\n@@ -486,7 +486,7 @@ fn main() {\n You can use `cargo build` on the command line to build it. You'll get a warning,\n but it will still print \"Hello, world!\":\n \n-```{ignore,notrust}\n+```{notrust}\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n src/main.rs:2     let x: int;\n@@ -664,7 +664,7 @@ let y: int = if x == 5i { 10i; } else { 15i; };\n \n Note the semicolons after the 10 and 15. Rust will give us the following error:\n \n-```{ignore,notrust}\n+```{notrust}\n error: mismatched types: expected `int` but found `()` (expected int but found ())\n ```\n \n@@ -747,7 +747,7 @@ fn print_number(x, y) {\n \n You get this error:\n \n-```{ignore,notrust}\n+```{notrust}\n hello.rs:5:18: 5:19 error: expected `:` but found `,`\n hello.rs:5 fn print_number(x, y) {\n ```\n@@ -779,7 +779,7 @@ fn add_one(x: int) -> int {\n \n We would get an error:\n \n-```{ignore,notrust}\n+```{ignore}\n error: not all control paths return a value\n fn add_one(x: int) -> int {\n      x + 1;\n@@ -1160,6 +1160,55 @@ Where a `StringResult` is either an `StringOK`, with the result of a computation\n `ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n `enum`s are actually very useful and are even part of the standard library.\n \n+Enum variants are namespaced under the enum names. For example, here is an example of using\n+our `StringResult`:\n+\n+```rust\n+# enum StringResult {\n+#     StringOK(String),\n+#     ErrorReason(String),\n+# }\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringResult::StringOK(\"Good morning!\".to_string())\n+    } else {\n+        StringResult::ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n+we didn't need to with `Ordering`, we just said `Greater` rather than `Ordering::Greater`.\n+There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n+itself. We can use the `use` keyword to do something similar with `StringResult`:\n+\n+```rust\n+use StringResult::StringOK;\n+use StringResult::ErrorReason;\n+\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n+# fn main() {}\n+\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringOK(\"Good morning!\".to_string())\n+    } else {\n+        ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+We'll learn more about `use` later, but it's used to bring names into scope. `use` declarations\n+must come before anything else, which looks a little strange in this example, since we `use`\n+the variants before we define them. Anyway, in the body of `respond`, we can just say `StringOK`\n+now, rather than the full `StringResult::StringOK`. Importing variants can be convenient, but can\n+also cause name conflicts, so do this with caution. It's considered good style to rarely import\n+variants for this reason.\n+\n As you can see `enum`s with values are quite a powerful tool for data representation,\n and can be even more useful when they're generic across types. But before we get to\n generics, let's talk about how to use them with pattern matching, a tool that will\n@@ -1197,7 +1246,7 @@ So what's the big advantage here? Well, there are a few. First of all, `match`\n enforces 'exhaustiveness checking.' Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n-```{ignore,notrust}\n+```{notrust}\n error: non-exhaustive patterns: `_` not covered\n ```\n \n@@ -1344,7 +1393,7 @@ for x in range(0i, 10i) {\n \n In slightly more abstract terms,\n \n-```{ignore,notrust}\n+```{ignore}\n for var in expression {\n     code\n }\n@@ -1849,7 +1898,7 @@ Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n is kind of like `cargo build`, but it also then runs the produced executable.\n Try it out:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -1947,7 +1996,7 @@ for this example, it is not important.\n \n Let's try to compile this using `cargo build`:\n \n-```{notrust,no_run}\n+```{notrust}\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:7:26: 7:34 error: the type of this value must be known in this context\n@@ -1995,7 +2044,7 @@ fn main() {\n \n Try running our new program a few times:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2048,7 +2097,7 @@ fn main() {\n \n And trying it out:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2103,7 +2152,7 @@ fn cmp(a: int, b: int) -> Ordering {\n \n If we try to compile, we'll get some errors:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)\n@@ -2157,7 +2206,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n And try compiling again:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n@@ -2170,7 +2219,7 @@ This error is similar to the last one: we expected to get a `uint`, but we got\n a `String` instead! That's because our `input` variable is coming from the\n standard input, and you can guess anything. Try it:\n \n-```{notrust,ignore}\n+```{notrust}\n $ ./target/guessing_game\n Guess the number!\n The secret number is: 73\n@@ -2254,7 +2303,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Let's try it out!\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n@@ -2313,7 +2362,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n We use a `match` to either give us the `uint` inside of the `Option`, or we\n print an error message and return. Let's give this a shot:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2378,7 +2427,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Let's try it!\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2455,7 +2504,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2587,7 +2636,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n \n Now we should be good! Let's try:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n@@ -2703,7 +2752,7 @@ $ cd modules\n \n Let's double check our work by compiling:\n \n-```{bash,notrust}\n+```{bash}\n $ cargo run\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n      Running `target/modules`\n@@ -2765,7 +2814,7 @@ mod hello {\n \n It gives an error:\n \n-```{notrust,ignore}\n+```{notrust}\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n src/main.rs:2:5: 2:23 error: function `print_hello` is private\n src/main.rs:2     hello::print_hello();\n@@ -2789,7 +2838,7 @@ mod hello {\n Usage of the `pub` keyword is sometimes called 'exporting', because\n we're making the function available for other modules. This will work:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n      Running `target/modules`\n@@ -2923,7 +2972,7 @@ $ cd testing\n \n And try it out:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running `target/testing`\n@@ -2955,7 +3004,7 @@ you give them descriptive names. You'll see why in a moment. We then use a\n macro, `assert!`, to assert that something is true. In this case, we're giving\n it `false`, so this test should fail. Let's try it!\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n@@ -2984,15 +3033,15 @@ task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.\n \n Lots of output! Let's break this down:\n \n-```{notrust,ignore}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n ```\n \n You can run all of your tests with `cargo test`. This runs both your tests in\n `tests`, as well as the tests you put inside of your crate.\n \n-```{notrust,ignore}\n+```{notrust}\n /home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n /home/you/projects/testing/src/main.rs:1 fn main() {\n /home/you/projects/testing/src/main.rs:2     println!(\"Hello, world!\")\n@@ -3006,7 +3055,7 @@ case, Rust is warning us that we've written some code that's never used: our\n We'll turn this lint off for just this function soon. For now, just ignore this\n output.\n \n-```{notrust,ignore}\n+```{ignore}\n      Running target/lib-654ce120f310a3a5\n \n running 1 test\n@@ -3018,7 +3067,7 @@ with good names? This is why. Here, it says 'test foo' because we called our\n test 'foo.' If we had given it a good name, it'd be more clear which test\n failed, especially as we accumulate more tests.\n \n-```{notrust,ignore}\n+```{notrust}\n failures:\n \n ---- foo stdout ----\n@@ -3049,7 +3098,7 @@ fn foo() {\n \n And then try to run our tests again:\n \n-```{notrust,ignore}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3089,7 +3138,7 @@ include `main` when it's _not_ true. So we use `not` to negate things:\n With this attribute we won't get the warning (even\n though `src/main.rs` gets recompiled this time):\n \n-```{notrust,ignore}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3120,7 +3169,7 @@ fn math_checks_out() {\n \n And try to run the test:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/tests/lib.rs:3:18: 3:38 error: unresolved name `add_three_times_four`.\n@@ -3180,7 +3229,7 @@ fn math_checks_out() {\n \n Let's give it a run:\n \n-```{ignore,notrust}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3229,7 +3278,7 @@ fn times_four(x: int) -> int { x * 4 }\n \n If you run `cargo test`, you should get the same output:\n \n-```{ignore,notrust}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3283,7 +3332,7 @@ fn test_add_three() {\n \n We'd get this error:\n \n-```{notrust,ignore}\n+```{notrust}\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/tests/lib.rs:3:5: 3:24 error: function `add_three` is private\n /home/you/projects/testing/tests/lib.rs:3 use testing::add_three;\n@@ -3325,7 +3374,7 @@ mod test {\n \n Let's give it a shot:\n \n-```{ignore,notrust}\n+```{ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n      Running target/lib-654ce120f310a3a5\n@@ -3455,7 +3504,7 @@ let y = &mut x;\n \n Rust will complain:\n \n-```{ignore,notrust}\n+```{notrust}\n error: cannot borrow immutable local variable `x` as mutable\n  let y = &mut x;\n               ^\n@@ -3482,7 +3531,7 @@ let z = &mut x;\n \n It gives us this error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3628,7 +3677,7 @@ let z = &mut x;\n \n The error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3646,7 +3695,7 @@ note: previous borrow ends here\n \n This error comes in three parts. Let's go over each in turn.\n \n-```{notrust,ignore}\n+```{notrust}\n error: cannot borrow `x` as mutable more than once at a time\n      let z = &mut x;\n                   ^\n@@ -3655,7 +3704,7 @@ error: cannot borrow `x` as mutable more than once at a time\n This error states the restriction: you cannot lend out something mutable more\n than once at the same time. The borrow checker knows the rules!\n \n-```{notrust,ignore}\n+```{notrust}\n note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends\n      let y = &mut x;\n                   ^\n@@ -3667,7 +3716,7 @@ the first mutable borrow occurred. The error showed us the second. So now we\n see both parts of the problem. It also alludes to rule #3, by reminding us that\n we can't change `x` until the borrow is over.\n \n-```{notrust,ignore}\n+```{ignore}\n note: previous borrow ends here\n  fn main() {\n      let mut x = 5i;\n@@ -3681,8 +3730,8 @@ Here's the second note, which lets us know where the first borrow would be over.\n This is useful, because if we wait to try to borrow `x` after this borrow is\n over, then everything will work.\n \n-For more advanced patterns, please consult the [Lifetime\n-Guide](guide-lifetimes.html).  You'll also learn what this type signature with\n+For more advanced patterns, please consult the [Ownership\n+Guide](guide-ownership.html).  You'll also learn what this type signature with\n the `'a` syntax is:\n \n ```{rust,ignore}\n@@ -3770,7 +3819,7 @@ let y = &mut x;\n \n This gives us this error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: cannot use `*x` because it was mutably borrowed\n  *x;\n  ^~\n@@ -4595,7 +4644,7 @@ element reference has the closure it's been given as an argument called on it.\n So this would give us the numbers from `2-100`. Well, almost! If you\n compile the example, you'll get a warning:\n \n-```{notrust,ignore}\n+```{ignore}\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n  range(1i, 100i).map(|x| x + 1i);\n@@ -4625,7 +4674,7 @@ for i in std::iter::count(1i, 5i).take(5) {\n \n This will print\n \n-```{notrust,ignore}\n+```{ignore}\n 1\n 6\n 11\n@@ -4838,7 +4887,7 @@ We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n of the `Result` has type `T`. However, if we try to compile that example, we'll get\n an error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n@@ -4894,7 +4943,7 @@ we use `impl Trait for Item`, rather than just `impl Item`.\n So what's the big deal? Remember the error we were getting with our generic\n `inverse` function?\n \n-```{notrust,ignore}\n+```{notrust}\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n@@ -4909,7 +4958,7 @@ fn print_area<T>(shape: T) {\n \n Rust complains:\n \n-```{notrust,ignore}\n+```{notrust}\n error: type `T` does not implement any method in scope named `area`\n ```\n \n@@ -4985,7 +5034,7 @@ fn main() {\n \n This program outputs:\n \n-```{notrust,ignore}\n+```{ignore}\n This shape has an area of 3.141593\n This shape has an area of 1\n ```\n@@ -4999,7 +5048,7 @@ print_area(5i);\n \n We get a compile-time error:\n \n-```{notrust,ignore}\n+```{ignore}\n error: failed to find an implementation of trait main::HasArea for int\n ```\n \n@@ -5066,7 +5115,7 @@ fn main() {\n Now that we've moved the structs and traits into their own module, we get an\n error:\n \n-```{notrust,ignore}\n+```{notrust}\n error: type `shapes::Circle` does not implement any method in scope named `area`\n ```\n "}, {"sha": "e2cccef5b4a1d13afadaf7546874bd4660df5c7d", "filename": "src/doc/intro.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -58,13 +58,13 @@ authors = [\"Your Name <you@example.com>\"]\n ```\n \n This is called a **manifest**, and it contains all of the metadata that Cargo\n-needs to compile your project. \n+needs to compile your project.\n \n Here's what's in `src/main.rs`:\n \n ```{rust}\n fn main() {\n-    println!(\"Hello, world!\")\n+    println!(\"Hello, world!\");\n }\n ```\n \n@@ -207,7 +207,7 @@ and two...\n \n ```{bash}\n $ g++ hello.cpp -Wall -Werror\n-$ ./a.out \n+$ ./a.out\n Segmentation fault (core dumped)\n ```\n \n@@ -313,7 +313,7 @@ print `\"Hello\"`, or does Rust crash?\n \n Neither. It refuses to compile:\n \n-```{notrust,ignore}\n+```{notrust}\n $ cargo run\n    Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n main.rs:8:5: 8:6 error: cannot borrow `v` as mutable because it is also borrowed as immutable\n@@ -428,7 +428,7 @@ fn main() {\n \n It gives us this error:\n \n-```{notrust,ignore}\n+```{notrust}\n 6:71 error: capture of moved value: `numbers`\n     for j in range(0, 3) { numbers[j] += 1 }\n                ^~~~~~~"}, {"sha": "660a97cd55f3343465abd15aaf77fc99ef7a6dac", "filename": "src/doc/reference.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -496,9 +496,8 @@ Examples of integer literals of various forms:\n \n A _floating-point literal_ has one of two forms:\n \n-* Two _decimal literals_ separated by a period\n-  character `U+002E` (`.`), with an optional _exponent_ trailing after the\n-  second decimal literal.\n+* A _decimal literal_ followed by a period character `U+002E` (`.`). This is\n+  optionally followed by another decimal literal, with an optional _exponent_.\n * A single _decimal literal_ followed by an _exponent_.\n \n By default, a floating-point literal has a generic type, and, like integer\n@@ -509,12 +508,17 @@ types), which explicitly determine the type of the literal.\n Examples of floating-point literals of various forms:\n \n ```\n-123.0f64;                          // type f64\n-0.1f64;                            // type f64\n-0.1f32;                            // type f32\n-12E+99_f64;                        // type f64\n+123.0f64;        // type f64\n+0.1f64;          // type f64\n+0.1f32;          // type f32\n+12E+99_f64;      // type f64\n+let x: f64 = 2.; // type f64\n ```\n \n+This last example is different because it is not possible to use the suffix\n+syntax with a floating point literal ending in a period. `2.f64` would attempt\n+to call a method named `f64` on `2`.\n+\n ##### Boolean literals\n \n The two values of the boolean type are written `true` and `false`."}, {"sha": "7fb86f904a20be3e023fb28f4c8a4df383655021", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -8,6 +8,12 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n+# Script parameters:\n+#     argv[1] = rust component root,\n+#     argv[2] = gcc component root,\n+#     argv[3] = target triple\n+# The first two correspond to the two installable components defined in the setup script.\n+\n import sys, os, shutil, subprocess\n \n def find_files(files, path):\n@@ -22,7 +28,7 @@ def find_files(files, path):\n             raise Exception(\"Could not find '%s' in %s\" % (fname, path))\n     return found\n \n-def make_win_dist(dist_root, target_triple):\n+def make_win_dist(rust_root, gcc_root, target_triple):\n     # Ask gcc where it keeps its stuff\n     gcc_out = subprocess.check_output([\"gcc.exe\", \"-print-search-dirs\"])\n     bin_path = os.environ[\"PATH\"].split(os.pathsep)\n@@ -90,29 +96,29 @@ def make_win_dist(dist_root, target_triple):\n     target_libs = find_files(target_libs, lib_path)\n \n     # Copy runtime dlls next to rustc.exe\n-    dist_bin_dir = os.path.join(dist_root, \"bin\")\n+    dist_bin_dir = os.path.join(rust_root, \"bin\")\n     for src in rustc_dlls:\n         shutil.copy(src, dist_bin_dir)\n \n     # Copy platform tools to platform-specific bin directory\n-    target_bin_dir = os.path.join(dist_root, \"bin\", \"rustlib\", target_triple, \"bin\")\n+    target_bin_dir = os.path.join(gcc_root, \"bin\", \"rustlib\", target_triple, \"bin\")\n     if not os.path.exists(target_bin_dir):\n         os.makedirs(target_bin_dir)\n     for src in target_tools:\n         shutil.copy(src, target_bin_dir)\n \n     # Copy platform libs to platform-spcific lib directory\n-    target_lib_dir = os.path.join(dist_root, \"bin\", \"rustlib\", target_triple, \"lib\")\n+    target_lib_dir = os.path.join(gcc_root, \"bin\", \"rustlib\", target_triple, \"lib\")\n     if not os.path.exists(target_lib_dir):\n         os.makedirs(target_lib_dir)\n     for src in target_libs:\n         shutil.copy(src, target_lib_dir)\n \n     # Copy license files\n-    lic_dir = os.path.join(dist_root, \"bin\", \"third-party\")\n+    lic_dir = os.path.join(rust_root, \"bin\", \"third-party\")\n     if os.path.exists(lic_dir):\n         shutil.rmtree(lic_dir) # copytree() won't overwrite existing files\n     shutil.copytree(os.path.join(os.path.dirname(__file__), \"third-party\"), lic_dir)\n \n if __name__==\"__main__\":\n-    make_win_dist(sys.argv[1], sys.argv[2])\n+    make_win_dist(sys.argv[1], sys.argv[2], sys.argv[3])"}, {"sha": "c57a7ab6c7059d98048203d6b9d9dda5ad0e9f78", "filename": "src/etc/pkg/rust.iss", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fetc%2Fpkg%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fetc%2Fpkg%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Frust.iss?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -14,6 +14,7 @@ AppPublisherURL=http://www.rust-lang.org\n VersionInfoVersion={#CFG_VERSION_WIN}\n LicenseFile=LICENSE.txt\n \n+PrivilegesRequired=lowest\n DisableWelcomePage=true\n DisableProgramGroupPage=true\n DisableReadyPage=true\n@@ -37,8 +38,13 @@ Uninstallable=yes\n [Tasks]\n Name: modifypath; Description: &Add {app}\\bin to your PATH (recommended)\n \n+[Components]\n+Name: rust; Description: \"Rust compiler and standard crates\"; Types: full compact custom; Flags: fixed\n+Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n+\n [Files]\n-Source: \"tmp/dist/win/*.*\" ; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs\n+Source: \"tmp/dist/win/rust/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n+Source: \"tmp/dist/win/gcc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: gcc\n \n [Code]\n const"}, {"sha": "217c898e661a0596c2470c149b57201f2df7c72d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -141,6 +141,7 @@\n \n #![stable]\n \n+use core::borrow::BorrowFrom;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n@@ -349,6 +350,12 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+impl<T> BorrowFrom<Rc<T>> for T {\n+    fn borrow_from(owned: &Rc<T>) -> &T {\n+        &**owned\n+    }\n+}\n+\n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Rc<T> {\n     #[inline(always)]"}, {"sha": "86eaa04b3e2e381835761058b7ace660a5281bf1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -1026,6 +1026,24 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// map.insert(2u, \"b\");\n+    /// map.insert(3u, \"c\");\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    ///\n+    /// let (first_key, first_value) = map.iter().next().unwrap();\n+    /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n+    /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         let len = self.len();"}, {"sha": "712c0bcabd58ce15b6181beecd9bd57569d6af43", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -11,9 +11,6 @@\n //! A doubly-linked list with owned nodes.\n //!\n //! The `DList` allows pushing and popping elements at either end.\n-//!\n-//! `DList` implements the trait `Deque`. It should be imported with\n-//! `use collections::Deque`.\n \n // DList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field."}, {"sha": "516b953dad9ba443d21d4e712e30e2e48f4db693", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -11,7 +11,6 @@\n //! This crate implements a double-ended queue with `O(1)` amortized inserts and removals from both\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n-//! Its interface `Deque` is defined in `collections`.\n \n use core::prelude::*;\n \n@@ -35,7 +34,7 @@ static MINIMUM_CAPACITY: uint = 2u;\n // FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n // be scrapped anyway. Defer to rewrite?\n \n-/// `RingBuf` is a circular buffer that implements `Deque`.\n+/// `RingBuf` is a circular buffer.\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points"}, {"sha": "6943ec69359f8af6d28cfc2eb5104e4133cb5b51", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -729,15 +729,38 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[experimental = \"waiting on FromIterator stabilization\"]\n+impl<'a> FromIterator<&'a str> for String {\n+    fn from_iter<I:Iterator<&'a str>>(iterator: I) -> String {\n+        let mut buf = String::new();\n+        buf.extend(iterator);\n+        buf\n+    }\n+}\n+\n #[experimental = \"waiting on Extend stabilization\"]\n impl Extend<char> for String {\n     fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n+        let (lower_bound, _) = iterator.size_hint();\n+        self.reserve(lower_bound);\n         for ch in iterator {\n             self.push(ch)\n         }\n     }\n }\n \n+#[experimental = \"waiting on Extend stabilization\"]\n+impl<'a> Extend<&'a str> for String {\n+    fn extend<I: Iterator<&'a str>>(&mut self, mut iterator: I) {\n+        // A guess that at least one byte per iterator element will be needed.\n+        let (lower_bound, _) = iterator.size_hint();\n+        self.reserve(lower_bound);\n+        for s in iterator {\n+            self.push_str(s)\n+        }\n+    }\n+}\n+\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -1307,6 +1330,27 @@ mod tests {\n                \"[[], [1], [1, 1]]\");\n     }\n \n+    #[test]\n+    fn test_from_iterator() {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string();\n+        let t = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let u = \"Vi\u1ec7t Nam\";\n+\n+        let a: String = s.chars().collect();\n+        assert_eq!(s, a);\n+\n+        let mut b = t.to_string();\n+        b.extend(u.chars());\n+        assert_eq!(s, b);\n+\n+        let c: String = vec![t, u].into_iter().collect();\n+        assert_eq!(s, c);\n+\n+        let mut d = t.to_string();\n+        d.extend(vec![u].into_iter());\n+        assert_eq!(s, d);\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "4235531c199a2f09a917ba739a2d279925290687", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -44,7 +44,7 @@\n pub use self::Ordering::*;\n \n use kinds::{Copy, Sized};\n-use option::{Option, Some, None};\n+use option::Option::{mod, Some, None};\n \n /// Trait for values that can be compared for equality and inequality.\n ///"}, {"sha": "84d84cbd5e1905ae2e6b521af96d2abadcadfcdd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -59,7 +59,7 @@\n #![allow(unknown_features, raw_pointer_deriving)]\n #![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![feature(default_type_params)]\n+#![feature(default_type_params, unboxed_closures)]\n #![deny(missing_docs)]\n \n mod macros;"}, {"sha": "0697dfbb0f2e4bae53f8460de8fb84ca40a40c38", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -143,7 +143,10 @@\n \n #![stable]\n \n+#[cfg(stage0)]\n pub use self::Option::*;\n+#[cfg(not(stage0))]\n+use self::Option::*;\n \n use cmp::{Eq, Ord};\n use default::Default;"}, {"sha": "8125afee13f586ab31e946cf1f5341d959f8b020", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -230,7 +230,7 @@\n \n #![stable]\n \n-pub use self::Result::*;\n+use self::Result::*;\n \n use kinds::Copy;\n use std::fmt::Show;"}, {"sha": "baa739b06833ce82f9247c75edb0b14dc0cb8f21", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -76,7 +76,7 @@ impl FromStr for bool {\n Section: Creating a string\n */\n \n-/// Converts a vector to a string slice without performing any allocations.\n+/// Converts a slice of bytes to a string slice without performing any allocations.\n ///\n /// Once the slice has been validated as utf-8, it is transmuted in-place and\n /// returned as a '&str' instead of a '&[u8]'"}, {"sha": "ad5884c16c5c1b00c8c8aea3be03ac1f34be1919", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -117,7 +117,7 @@ impl ChaChaRng {\n     /// security proof for a more involved example of this.\n     ///\n     /// The modified word layout is:\n-    /// ```notrust\n+    /// ```ignore\n     /// constant constant constant constant\n     /// key      key      key      key\n     /// key      key      key      key"}, {"sha": "77c0a8abe6466cdfb50485c55ead831e916ba313", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -120,7 +120,7 @@\n //!\n //! The compiler accepts a flag of this form a number of times:\n //!\n-//! ```notrust\n+//! ```ignore\n //! --extern crate-name=path/to/the/crate.rlib\n //! ```\n //!\n@@ -152,7 +152,7 @@\n //!\n //! and the compiler would be invoked as:\n //!\n-//! ```notrust\n+//! ```ignore\n //! rustc a.rs --extern b1=path/to/libb1.rlib --extern b2=path/to/libb2.rlib\n //! ```\n //!\n@@ -178,7 +178,7 @@\n //! dependencies, not the upstream transitive dependencies. Consider this\n //! dependency graph:\n //!\n-//! ```notrust\n+//! ```ignore\n //! A.1   A.2\n //! |     |\n //! |     |"}, {"sha": "1811388662c45f1ef4e77d897b3b3b582964c3c5", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -288,7 +288,6 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debuginfo::create_captured_var_metadata(\n                 bcx,\n                 def_id.node,\n-                cdata_ty,\n                 env_pointer_alloca,\n                 i,\n                 captured_by_ref,\n@@ -328,7 +327,7 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     // Store the pointer to closure data in an alloca for debug info because that's what the\n     // llvm.dbg.declare intrinsic expects\n     let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n-        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), self_type), \"__debuginfo_env_ptr\");\n+        let alloc = alloca(bcx, val_ty(llenv), \"__debuginfo_env_ptr\");\n         Store(bcx, llenv, alloc);\n         Some(alloc)\n     } else {\n@@ -357,7 +356,6 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n             debuginfo::create_captured_var_metadata(\n                 bcx,\n                 def_id.node,\n-                self_type,\n                 env_pointer_alloca,\n                 i,\n                 captured_by_ref,"}, {"sha": "f6c4ba64576f76d656efae22d1a556861501fffb", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -884,7 +884,6 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                 node_id: ast::NodeId,\n-                                                env_data_type: Ty<'tcx>,\n                                                 env_pointer: ValueRef,\n                                                 env_index: uint,\n                                                 captured_by_ref: bool,\n@@ -930,7 +929,10 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let variable_type = node_id_type(bcx, node_id);\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n-    let llvm_env_data_type = type_of::type_of(cx, env_data_type);\n+    // env_pointer is the alloca containing the pointer to the environment,\n+    // so it's type is **EnvironmentType. In order to find out the type of\n+    // the environment we have to \"dereference\" two times.\n+    let llvm_env_data_type = val_ty(env_pointer).element_type().element_type();\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n                                                               llvm_env_data_type,\n                                                               env_index);"}, {"sha": "7f1aad8ca77c56f81fb7dae5d1e2113e1b7239e7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -386,20 +386,81 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n     (regions, types)\n }\n \n+/// Returns the appropriate lifetime to use for any output lifetimes\n+/// (if one exists) and a vector of the (pattern, number of lifetimes)\n+/// corresponding to each input type/pattern.\n+fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n+                              -> (Option<ty::Region>, Vec<(String, uint)>)\n+{\n+    let mut lifetimes_for_params: Vec<(String, uint)> = Vec::new();\n+    let mut possible_implied_output_region = None;\n+\n+    for (input_type, input_pat) in input_tys.iter().zip(input_pats.into_iter()) {\n+        let mut accumulator = Vec::new();\n+        ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+\n+        if accumulator.len() == 1 {\n+            // there's a chance that the unique lifetime of this\n+            // iteration will be the appropriate lifetime for output\n+            // parameters, so lets store it.\n+            possible_implied_output_region = Some(accumulator[0])\n+        }\n+\n+        lifetimes_for_params.push((input_pat, accumulator.len()));\n+    }\n+\n+    let implied_output_region = if lifetimes_for_params.iter().map(|&(_, n)| n).sum() == 1 {\n+        assert!(possible_implied_output_region.is_some());\n+        possible_implied_output_region\n+    } else {\n+        None\n+    };\n+    (implied_output_region, lifetimes_for_params)\n+}\n+\n+fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n+                                             implied_output_region: Option<ty::Region>,\n+                                             param_lifetimes: Vec<(String, uint)>,\n+                                             ty: &ast::Ty)\n+                                             -> Ty<'tcx>\n+    where AC: AstConv<'tcx>\n+{\n+    match implied_output_region {\n+        Some(implied_output_region) => {\n+            let rb = SpecificRscope::new(implied_output_region);\n+            ast_ty_to_ty(this, &rb, ty)\n+        }\n+        None => {\n+            // All regions must be explicitly specified in the output\n+            // if the lifetime elision rules do not apply. This saves\n+            // the user from potentially-confusing errors.\n+            let rb = UnelidableRscope::new(param_lifetimes);\n+            ast_ty_to_ty(this, &rb, ty)\n+        }\n+    }\n+}\n+\n fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                                              data: &ast::ParenthesizedParameterData)\n                                              -> Vec<Ty<'tcx>>\n     where AC: AstConv<'tcx>\n {\n     let binding_rscope = BindingRscope::new();\n-\n     let inputs = data.inputs.iter()\n                             .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n-                            .collect();\n+                            .collect::<Vec<Ty<'tcx>>>();\n+\n+    let input_params = Vec::from_elem(inputs.len(), String::new());\n+    let (implied_output_region,\n+         params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n+\n     let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n     let output = match data.output {\n-        Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+        Some(ref output_ty) => convert_ty_with_lifetime_elision(this,\n+                                                                implied_output_region,\n+                                                                params_lifetimes,\n+                                                                &**output_ty),\n         None => ty::mk_nil(this.tcx()),\n     };\n \n@@ -1059,55 +1120,33 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let self_and_input_tys: Vec<Ty> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n-    let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n-    if implied_output_region.is_none() {\n-        let mut self_and_input_tys_iter = self_and_input_tys.iter();\n-        if self_ty.is_some() {\n+    let lifetimes_for_params = if implied_output_region.is_none() {\n+        let input_tys = if self_ty.is_some() {\n             // Skip the first argument if `self` is present.\n-            drop(self_and_input_tys_iter.next())\n-        }\n-\n-        for (input_type, input_pat) in self_and_input_tys_iter.zip(input_pats.into_iter()) {\n-            let mut accumulator = Vec::new();\n-            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n-            lifetimes_for_params.push((input_pat, accumulator));\n-        }\n-\n-        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum() == 1 {\n-            implied_output_region =\n-                Some(lifetimes_for_params.iter()\n-                                         .filter_map(|&(_, ref x)|\n-                                            if x.len() == 1 { Some(x[0]) } else { None })\n-                                         .next().unwrap());\n-        }\n-    }\n+            self_and_input_tys.slice_from(1)\n+        } else {\n+            self_and_input_tys.slice_from(0)\n+        };\n \n-    let param_lifetimes: Vec<(String, uint)> = lifetimes_for_params.into_iter()\n-                                                                   .map(|(n, v)| (n, v.len()))\n-                                                                   .filter(|&(_, l)| l != 0)\n-                                                                   .collect();\n+        let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n+        implied_output_region = ior;\n+        lfp\n+    } else {\n+        vec![]\n+    };\n \n     let output_ty = match decl.output {\n         ast::Return(ref output) if output.node == ast::TyInfer =>\n             ty::FnConverging(this.ty_infer(output.span)),\n         ast::Return(ref output) =>\n-            ty::FnConverging(match implied_output_region {\n-                Some(implied_output_region) => {\n-                    let rb = SpecificRscope::new(implied_output_region);\n-                    ast_ty_to_ty(this, &rb, &**output)\n-                }\n-                None => {\n-                    // All regions must be explicitly specified in the output\n-                    // if the lifetime elision rules do not apply. This saves\n-                    // the user from potentially-confusing errors.\n-                    let rb = UnelidableRscope::new(param_lifetimes);\n-                    ast_ty_to_ty(this, &rb, &**output)\n-                }\n-            }),\n+            ty::FnConverging(convert_ty_with_lifetime_elision(this,\n+                                                              implied_output_region,\n+                                                              lifetimes_for_params,\n+                                                              &**output)),\n         ast::NoReturn(_) => ty::FnDiverging\n     };\n "}, {"sha": "ee93c896433a18bf95a8621d4e2a05aef066a84d", "filename": "src/librustc_typeck/check/callee.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use CrateCtxt;\n+\n+/// Check that it is legal to call methods of the trait corresponding\n+/// to `trait_id` (this only cares about the trait, not the specific\n+/// method that is called)\n+pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: ast::DefId) {\n+    let tcx = ccx.tcx;\n+    let did = Some(trait_id);\n+    let li = &tcx.lang_items;\n+\n+    if did == li.drop_trait() {\n+        span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\");\n+    } else if !tcx.sess.features.borrow().unboxed_closures {\n+        // the #[feature(unboxed_closures)] feature isn't\n+        // activated so we need to enforce the closure\n+        // restrictions.\n+\n+        let method = if did == li.fn_trait() {\n+            \"call\"\n+        } else if did == li.fn_mut_trait() {\n+            \"call_mut\"\n+        } else if did == li.fn_once_trait() {\n+            \"call_once\"\n+        } else {\n+            return // not a closure method, everything is OK.\n+        };\n+\n+        span_err!(tcx.sess, span, E0174,\n+                  \"explicit use of unboxed closure method `{}` is experimental\",\n+                  method);\n+        span_help!(tcx.sess, span,\n+                   \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    }\n+}"}, {"sha": "b6a9e2cbc59eae956c6874d780a4832ea65c9022", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -10,7 +10,7 @@\n \n use super::probe;\n \n-use check::{mod, FnCtxt, NoPreference, PreferMutLvalue};\n+use check::{mod, FnCtxt, NoPreference, PreferMutLvalue, callee};\n use middle::subst::{mod, Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n@@ -90,7 +90,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick.adjustment);\n \n         // Make sure nobody calls `drop()` explicitly.\n-        self.enforce_drop_trait_limitations(&pick);\n+        self.enforce_illegal_method_limitations(&pick);\n \n         // Create substitutions for the method's type parameters.\n         let (rcvr_substs, method_origin) =\n@@ -624,14 +624,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.fcx.infcx()\n     }\n \n-    fn enforce_drop_trait_limitations(&self, pick: &probe::Pick) {\n+    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.method_ty.container {\n             ty::TraitContainer(trait_def_id) => {\n-                if Some(trait_def_id) == self.tcx().lang_items.drop_trait() {\n-                    span_err!(self.tcx().sess, self.span, E0040,\n-                              \"explicit call to destructor\");\n-                }\n+                callee::check_legal_trait_for_method_call(self.fcx.ccx, self.span, trait_def_id)\n             }\n             ty::ImplContainer(..) => {\n                 // Since `drop` is a trait method, we expect that any"}, {"sha": "8288cce395838f8a07de8b07418a9bb7b6c98547", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -130,6 +130,7 @@ pub mod demand;\n pub mod method;\n pub mod wf;\n mod closure;\n+mod callee;\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n@@ -5095,8 +5096,17 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Case 3. Reference to a method.\n-        def::DefStaticMethod(..) => {\n+        def::DefStaticMethod(_, providence) |\n+        def::DefMethod(_, _, providence) => {\n             assert!(path.segments.len() >= 2);\n+\n+            match providence {\n+                def::FromTrait(trait_did) => {\n+                    callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n+                }\n+                def::FromImpl(_) => {}\n+            }\n+\n             segment_spaces = Vec::from_elem(path.segments.len() - 2, None);\n             segment_spaces.push(Some(subst::TypeSpace));\n             segment_spaces.push(Some(subst::FnSpace));\n@@ -5108,7 +5118,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefMod(..) |\n         def::DefForeignMod(..) |\n         def::DefLocal(..) |\n-        def::DefMethod(..) |\n         def::DefUse(..) |\n         def::DefRegion(..) |\n         def::DefLabel(..) |"}, {"sha": "c4e1f6fe8eb180cfc5a7be8db2383d0da13778ce", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -212,6 +212,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n \n+            enforce_trait_manually_implementable(self.crate_context.tcx,\n+                                                 item.span,\n+                                                 trait_ref.def_id);\n             self.add_trait_impl(trait_ref.def_id, impl_did);\n         }\n \n@@ -542,6 +545,28 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n+fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: ast::DefId) {\n+    if tcx.sess.features.borrow().unboxed_closures {\n+        // the feature gate allows all of them\n+        return\n+    }\n+    let did = Some(trait_def_id);\n+    let li = &tcx.lang_items;\n+\n+    let trait_name = if did == li.fn_trait() {\n+        \"Fn\"\n+    } else if did == li.fn_mut_trait() {\n+        \"FnMut\"\n+    } else if did == li.fn_once_trait() {\n+        \"FnOnce\"\n+    } else {\n+        return // everything OK\n+    };\n+    span_err!(tcx.sess, sp, E0173, \"manual implementations of `{}` are experimental\", trait_name);\n+    span_help!(tcx.sess, sp,\n+               \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+}\n+\n fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            impl_id: ast::DefId,\n                                            impl_poly_type: &ty::Polytype<'tcx>,"}, {"sha": "e026fbd05c7f039c5ca6e4fc9c83d4f7a07744de", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -53,7 +53,7 @@ register_diagnostics!(\n     E0035,\n     E0036,\n     E0038,\n-    E0040,\n+    E0040, // explicit use of destructor method\n     E0044,\n     E0045,\n     E0046,\n@@ -147,5 +147,7 @@ register_diagnostics!(\n     E0168,\n     E0169,\n     E0171,\n-    E0172\n+    E0172,\n+    E0173, // manual implementations of unboxed closure traits are experimental\n+    E0174 // explicit use of unboxed closure methods are experimental\n )"}, {"sha": "59faf75c0c30cffccb66c2828135d539fee4e506", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -28,10 +28,22 @@ pub enum CharacterSet {\n \n impl Copy for CharacterSet {}\n \n+/// Available newline types\n+pub enum Newline {\n+    /// A linefeed (i.e. Unix-style newline)\n+    LF,\n+    /// A carriage return and a linefeed (i.e. Windows-style newline)\n+    CRLF\n+}\n+\n+impl Copy for Newline {}\n+\n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n     pub char_set: CharacterSet,\n+    /// Newline to use\n+    pub newline: Newline,\n     /// True to pad output with `=` characters\n     pub pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n@@ -42,15 +54,15 @@ impl Copy for Config {}\n \n /// Configuration for RFC 4648 standard base64 encoding\n pub static STANDARD: Config =\n-    Config {char_set: Standard, pad: true, line_length: None};\n+    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: None};\n \n /// Configuration for RFC 4648 base64url encoding\n pub static URL_SAFE: Config =\n-    Config {char_set: UrlSafe, pad: false, line_length: None};\n+    Config {char_set: UrlSafe, newline: Newline::CRLF, pad: false, line_length: None};\n \n /// Configuration for RFC 2045 MIME base64 encoding\n pub static MIME: Config =\n-    Config {char_set: Standard, pad: true, line_length: Some(76)};\n+    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: Some(76)};\n \n static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                         abcdefghijklmnopqrstuvwxyz\\\n@@ -87,24 +99,30 @@ impl ToBase64 for [u8] {\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut v = Vec::new();\n+        // In general, this Vec only needs (4/3) * self.len() memory, but\n+        // addition is faster than multiplication and division.\n+        let mut v = Vec::with_capacity(self.len() + self.len());\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n-        while i < len - (len % 3) {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                        cur_length = 0;\n-                    },\n-                None => ()\n+        let mod_len = len % 3;\n+        let cond_len = len - mod_len;\n+        let newline = match config.newline {\n+            Newline::LF => b\"\\n\",\n+            Newline::CRLF => b\"\\r\\n\"\n+        };\n+        while i < cond_len {\n+            let (first, second, third) = (self[i], self[i + 1], self[i + 2]);\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(newline);\n+                    cur_length = 0;\n+                }\n             }\n \n-            let n = (self[i] as u32) << 16 |\n-                    (self[i + 1] as u32) << 8 |\n-                    (self[i + 2] as u32);\n+            let n = (first  as u32) << 16 |\n+                    (second as u32) << 8 |\n+                    (third  as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n             v.push(bytes[((n >> 18) & 63) as uint]);\n@@ -116,20 +134,17 @@ impl ToBase64 for [u8] {\n             i += 3;\n         }\n \n-        if len % 3 != 0 {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                    },\n-                None => ()\n+        if mod_len != 0 {\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(newline);\n+                }\n             }\n         }\n \n         // Heh, would be cool if we knew this was exhaustive\n         // (the dream of bounded integer types)\n-        match len % 3 {\n+        match mod_len {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n@@ -232,7 +247,7 @@ impl FromBase64 for str {\n \n impl FromBase64 for [u8] {\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n-        let mut r = Vec::new();\n+        let mut r = Vec::with_capacity(self.len());\n         let mut buf: u32 = 0;\n         let mut modulus = 0i;\n \n@@ -288,7 +303,7 @@ impl FromBase64 for [u8] {\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n-    use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE};\n+    use base64::{Config, Newline, FromBase64, ToBase64, STANDARD, URL_SAFE};\n \n     #[test]\n     fn test_to_base64_basic() {\n@@ -302,14 +317,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_base64_line_break() {\n+    fn test_to_base64_crlf_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n                               .contains(\"\\r\\n\"));\n-        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n-                                                         ..STANDARD}),\n+        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n+                                               ..STANDARD}),\n                    \"Zm9v\\r\\nYmFy\");\n     }\n \n+    #[test]\n+    fn test_to_base64_lf_line_break() {\n+        assert!(![0u8, ..1000].to_base64(Config {line_length: None,\n+                                                 newline: Newline::LF,\n+                                                 ..STANDARD})\n+                              .as_slice()\n+                              .contains(\"\\n\"));\n+        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n+                                               newline: Newline::LF,\n+                                               ..STANDARD}),\n+                   \"Zm9v\\nYmFy\");\n+    }\n+\n     #[test]\n     fn test_to_base64_padding() {\n         assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\");\n@@ -344,6 +372,10 @@ mod tests {\n                    b\"foobar\");\n         assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n                    b\"foob\");\n+        assert_eq!(\"Zm9v\\nYmFy\".from_base64().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"Zm9vYg==\\n\".from_base64().unwrap(),\n+                   b\"foob\");\n     }\n \n     #[test]"}, {"sha": "1cff4c334e7430d1d8827e6e89281e0c862dc934", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -23,7 +23,7 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n+#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs, if_let)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "96b075ab569bf35827d0201ddcc472b64111f2c0", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -21,9 +21,11 @@ use iter::IteratorExt;\n use mem;\n use ops::*;\n use option::*;\n+use option::Option::{None, Some};\n use os;\n use path::{Path,GenericPath};\n use result::*;\n+use result::Result::{Err, Ok};\n use slice::{AsSlice,SlicePrelude};\n use str;\n use string::String;\n@@ -216,6 +218,7 @@ pub mod dl {\n     use kinds::Copy;\n     use ptr;\n     use result::*;\n+    use result::Result::{Err, Ok};\n     use string::String;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {"}, {"sha": "6c91010f4cb35730c82ff2dc5a804e06f134a0b1", "filename": "src/libstd/os.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -160,7 +160,7 @@ pub fn getcwd() -> IoResult<Path> {\n }\n \n #[cfg(windows)]\n-pub mod windows {\n+pub mod windoze {\n     use libc::types::os::arch::extra::DWORD;\n     use libc;\n     use option::Option;\n@@ -386,7 +386,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n-            use os::windows::{fill_utf16_buf_and_decode};\n+            use os::windoze::{fill_utf16_buf_and_decode};\n             let mut n: Vec<u16> = n.utf16_units().collect();\n             n.push(0);\n             fill_utf16_buf_and_decode(|buf, sz| {\n@@ -715,7 +715,7 @@ pub fn self_exe_name() -> Option<Path> {\n     #[cfg(windows)]\n     fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n-            use os::windows::fill_utf16_buf_and_decode;\n+            use os::windoze::fill_utf16_buf_and_decode;\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n             }).map(|s| s.into_string().into_bytes())\n@@ -1215,7 +1215,11 @@ pub enum MapOption {\n     /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n     /// POSIX.\n     MapAddr(*const u8),\n+    /// Create a memory mapping for a file with a given HANDLE.\n+    #[cfg(windows)]\n+    MapFd(libc::HANDLE),\n     /// Create a memory mapping for a file with a given fd.\n+    #[cfg(not(windows))]\n     MapFd(c_int),\n     /// When using `MapFd`, the start of the map is `uint` bytes from the start\n     /// of the file.\n@@ -1413,7 +1417,7 @@ impl MemoryMap {\n         let mut readable = false;\n         let mut writable = false;\n         let mut executable = false;\n-        let mut fd: c_int = -1;\n+        let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n         let mut offset: uint = 0;\n         let len = round_up(min_len, page_size());\n \n@@ -1423,23 +1427,23 @@ impl MemoryMap {\n                 MapWritable => { writable = true; },\n                 MapExecutable => { executable = true; }\n                 MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n-                MapFd(fd_) => { fd = fd_; },\n+                MapFd(handle_) => { handle = handle_; },\n                 MapOffset(offset_) => { offset = offset_; },\n                 MapNonStandardFlags(..) => {}\n             }\n         }\n \n         let flProtect = match (executable, readable, writable) {\n-            (false, false, false) if fd == -1 => libc::PAGE_NOACCESS,\n+            (false, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_NOACCESS,\n             (false, true, false) => libc::PAGE_READONLY,\n             (false, true, true) => libc::PAGE_READWRITE,\n-            (true, false, false) if fd == -1 => libc::PAGE_EXECUTE,\n+            (true, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_EXECUTE,\n             (true, true, false) => libc::PAGE_EXECUTE_READ,\n             (true, true, true) => libc::PAGE_EXECUTE_READWRITE,\n             _ => return Err(ErrUnsupProt)\n         };\n \n-        if fd == -1 {\n+        if handle == libc::INVALID_HANDLE_VALUE {\n             if offset != 0 {\n                 return Err(ErrUnsupOffset);\n             }\n@@ -1467,7 +1471,7 @@ impl MemoryMap {\n                                               // we should never get here.\n             };\n             unsafe {\n-                let hFile = libc::get_osfhandle(fd) as HANDLE;\n+                let hFile = handle;\n                 let mapping = libc::CreateFileMappingW(hFile,\n                                                        ptr::null_mut(),\n                                                        flProtect,\n@@ -1991,55 +1995,47 @@ mod tests {\n \n     #[test]\n     fn memory_map_file() {\n-        use result::Result::{Ok, Err};\n+        use libc;\n         use os::*;\n-        use libc::*;\n-        use io::fs;\n-\n-        #[cfg(unix)]\n-        fn lseek_(fd: c_int, size: uint) {\n-            unsafe {\n-                assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n-            }\n+        use io::fs::{File, unlink};\n+        use io::SeekStyle::SeekSet;\n+        use io::FileMode::Open;\n+        use io::FileAccess::ReadWrite;\n+\n+        #[cfg(not(windows))]\n+        fn get_fd(file: &File) -> libc::c_int {\n+            use os::unix::AsRawFd;\n+            file.as_raw_fd()\n         }\n+\n         #[cfg(windows)]\n-        fn lseek_(fd: c_int, size: uint) {\n-           unsafe {\n-               assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);\n-           }\n+        fn get_fd(file: &File) -> libc::HANDLE {\n+            use os::windows::AsRawHandle;\n+            file.as_raw_handle()\n         }\n \n         let mut path = tmpdir();\n         path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n+        let mut file = File::open_mode(&path, Open, ReadWrite).unwrap();\n+        file.seek(size as i64, SeekSet);\n+        file.write_u8(0);\n \n-        let fd = unsafe {\n-            let fd = path.with_c_str(|path| {\n-                open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n-            });\n-            lseek_(fd, size);\n-            \"x\".with_c_str(|x| assert!(write(fd, x as *const c_void, 1) == 1));\n-            fd\n-        };\n-        let chunk = match MemoryMap::new(size / 2, &[\n+        let chunk = MemoryMap::new(size / 2, &[\n             MapReadable,\n             MapWritable,\n-            MapFd(fd),\n+            MapFd(get_fd(&file)),\n             MapOffset(size / 2)\n-        ]) {\n-            Ok(chunk) => chunk,\n-            Err(msg) => panic!(\"{}\", msg)\n-        };\n+        ]).unwrap();\n         assert!(chunk.len > 0);\n \n         unsafe {\n             *chunk.data = 0xbe;\n             assert!(*chunk.data == 0xbe);\n-            close(fd);\n         }\n         drop(chunk);\n \n-        fs::unlink(&path).unwrap();\n+        unlink(&path).unwrap();\n     }\n \n     #[test]"}, {"sha": "5b5fa2952e6bd06bcbe12f0a93cfd769c72e14cf", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -80,7 +80,7 @@\n //! circle, both centered at the origin. Since the area of a unit circle is \u03c0,\n //! we have:\n //!\n-//! ```notrust\n+//! ```text\n //!     (area of unit circle) / (area of square) = \u03c0 / 4\n //! ```\n //!"}, {"sha": "ee1515566204b0c545e935c8588e183aef563cbe", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::None;\n+use option::Option::None;\n use rustrt::task::Task;\n use rustrt::local::Local;\n "}, {"sha": "3eb0e3f46cb90e81cdb229ecb0251e18ad5d291b", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -185,7 +185,23 @@ impl StaticKey {\n     }\n \n     unsafe fn lazy_init(&self) -> uint {\n-        let key = imp::create(self.dtor);\n+        // POSIX allows the key created here to be 0, but the compare_and_swap\n+        // below relies on using 0 as a sentinel value to check who won the\n+        // race to set the shared TLS key. As far as I know, there is no\n+        // guaranteed value that cannot be returned as a posix_key_create key,\n+        // so there is no value we can initialize the inner key with to\n+        // prove that it has not yet been set. As such, we'll continue using a\n+        // value of 0, but with some gyrations to make sure we have a non-0\n+        // value returned from the creation routine.\n+        // FIXME: this is clearly a hack, and should be cleaned up.\n+        let key1 = imp::create(self.dtor);\n+        let key = if key1 != 0 {\n+            key1\n+        } else {\n+            let key2 = imp::create(self.dtor);\n+            imp::destroy(key1);\n+            key2\n+        };\n         assert!(key != 0);\n         match self.inner.key.compare_and_swap(0, key as uint, atomic::SeqCst) {\n             // The CAS succeeded, so we've created the actual key"}, {"sha": "05be8de0b56e2e81db34f2c2274f1c4eb99b9921", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -15,7 +15,7 @@ use libc::{mod, c_int};\n \n use c_str::CString;\n use mem;\n-use os::windows::fill_utf16_buf_and_decode;\n+use os::windoze::fill_utf16_buf_and_decode;\n use path;\n use ptr;\n use str;"}, {"sha": "6900773f44d4bec09aeba6251d00e03c145b4b13", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -66,12 +66,19 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                                           cx.ident_of(\"cmp\"),\n                                           cx.ident_of(\"Equal\")));\n \n+    let cmp_path = vec![\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"cmp\"),\n+        cx.ident_of(\"Ord\"),\n+        cx.ident_of(\"cmp\"),\n+    ];\n+\n     /*\n     Builds:\n \n-    let __test = self_field1.cmp(&other_field2);\n+    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n     if other == ::std::cmp::Ordering::Equal {\n-        let __test = self_field2.cmp(&other_field2);\n+        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n         if __test == ::std::cmp::Ordering::Equal {\n             ...\n         } else {\n@@ -83,18 +90,32 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n \n     FIXME #6449: These `if`s could/should be `match`es.\n     */\n-    cs_same_method_fold(\n+    cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, new| {\n+        |cx, span, old, self_f, other_fs| {\n             // let __test = new;\n             // if __test == ::std::cmp::Ordering::Equal {\n             //    old\n             // } else {\n             //    __test\n             // }\n \n+            let new = {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(PartialOrd)`\"),\n+                };\n+\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_f),\n+                    cx.expr_addr_of(span, other_f.clone()),\n+                ];\n+\n+                cx.expr_call_global(span, cmp_path.clone(), args)\n+            };\n+\n             let assign = cx.stmt_let(span, false, test_id, new);\n \n             let cond = cx.expr_binary(span, ast::BiEq,"}, {"sha": "6b334dd6ecdfc0689ca704d1ed00aa2380e1031e", "filename": "src/test/compile-fail/explicit-call-to-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-dtor.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -20,5 +20,5 @@ impl Drop for Foo {\n \n fn main() {\n     let x = Foo { x: 3 };\n-    x.drop();   //~ ERROR explicit call to destructor\n+    x.drop();   //~ ERROR explicit use of destructor method\n }"}, {"sha": "d0dd0e68da6bd363ed54dd39cfd36b8c8c764175", "filename": "src/test/compile-fail/explicit-call-to-supertrait-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-supertrait-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-supertrait-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-call-to-supertrait-dtor.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -24,7 +24,7 @@ impl Drop for Foo {\n \n impl Bar for Foo {\n     fn blah(&self) {\n-        self.drop();    //~ ERROR explicit call to destructor\n+        self.drop();    //~ ERROR explicit use of destructor method\n     }\n }\n "}, {"sha": "8999da5b1755552122936f015384a1c6be38cf17", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+struct Foo;\n+impl Fn<(), ()> for Foo { //~ ERROR manual implementations of `Fn` are experimental\n+    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+}\n+struct Bar;\n+impl FnMut<(), ()> for Bar { //~ ERROR manual implementations of `FnMut` are experimental\n+    extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n+}\n+struct Baz;\n+impl FnOnce<(), ()> for Baz { //~ ERROR manual implementations of `FnOnce` are experimental\n+    extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n+}\n+\n+fn main() {}"}, {"sha": "5a066c441cfe5fe1afc9ffa31789cb2077dcc40e", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-method-calls.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-method-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-method-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-method-calls.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+fn foo<F: Fn<(), ()>>(mut f: F) {\n+    f.call(()); //~ ERROR explicit use of unboxed closure method `call`\n+    f.call_mut(()); //~ ERROR explicit use of unboxed closure method `call_mut`\n+    f.call_once(()); //~ ERROR explicit use of unboxed closure method `call_once`\n+}\n+\n+fn main() {}"}, {"sha": "8efaf00c9c8484560e796233e8f94f4a71290fcb", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-ufcs-calls.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-ufcs-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-ufcs-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-ufcs-calls.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+fn foo<F: Fn<(), ()>>(mut f: F, mut g: F) {\n+    Fn::call(&g, ()); //~ ERROR explicit use of unboxed closure method `call`\n+    FnMut::call_mut(&mut g, ()); //~ ERROR explicit use of unboxed closure method `call_mut`\n+    FnOnce::call_once(g, ()); //~ ERROR explicit use of unboxed closure method `call_once`\n+}\n+\n+fn main() {}"}, {"sha": "f4c653bd57323e56b67193e933f1628e74681b39", "filename": "src/test/compile-fail/illegal-ufcs-drop.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fillegal-ufcs-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Fillegal-ufcs-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fillegal-ufcs-drop.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+struct Foo;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    Drop::drop(&mut Foo) //~ ERROR explicit use of destructor method\n+}"}, {"sha": "817582a877fa9e8fb2d48c0d7fb7e8feb989f0d8", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -33,7 +33,6 @@ fn h(_x: &Foo) -> &int { //~ ERROR missing lifetime specifier\n \n fn i(_x: int) -> &int { //~ ERROR missing lifetime specifier\n //~^ HELP this function's return type contains a borrowed value\n-//~^^ HELP consider giving it a 'static lifetime\n     panic!()\n }\n "}, {"sha": "308b33f9b4db195d381cff13eb8192cdd8793c83", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -44,9 +44,9 @@ fn test<'a,'b>() {\n     eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n           Foo(&int,&uint) -> uint                             >();\n \n-    // FIXME(#18992) Test lifetime elision in `()` form:\n-    // eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n-    //      Foo(&int) -> &int                                   >();\n+    // lifetime elision\n+    eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n+          Foo(&int) -> &int                                   >();\n \n     // Errors expected:\n     eq::< Foo<(),()>,                   Foo(char)                     >();"}, {"sha": "e08d84944c02a58beaa20727a81154ccb9897fe6", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![feature(unboxed_closures)]\n+#![allow(dead_code)]\n+\n+trait Foo<T,U> {\n+    fn dummy(&self, t: T, u: U);\n+}\n+\n+trait Eq<Sized? X> for Sized? { }\n+impl<Sized? X> Eq<X> for X { }\n+fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+\n+fn main() {\n+    eq::< for<'a> Foo<(&'a int,), &'a int>,\n+          Foo(&int) -> &int                                   >();\n+    eq::< for<'a> Foo<(&'a int,), (&'a int, &'a int)>,\n+          Foo(&int) -> (&int, &int)                           >();\n+\n+    let _: Foo(&int, &uint) -> &uint; //~ ERROR missing lifetime specifier\n+}"}, {"sha": "761d0f0be8f583309d5a682b6ddfdbb264693438", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -28,6 +28,19 @@\n // gdb-command:print *owned\n // gdb-check:$5 = 6\n \n+// gdb-command:continue\n+\n+// gdb-command:print variable\n+// gdb-check:$6 = 2\n+// gdb-command:print constant\n+// gdb-check:$7 = 2\n+// gdb-command:print a_struct\n+// gdb-check:$8 = {a = -3, b = 4.5, c = 5}\n+// gdb-command:print *struct_ref\n+// gdb-check:$9 = {a = -3, b = 4.5, c = 5}\n+// gdb-command:print *owned\n+// gdb-check:$10 = 6\n+\n \n // === LLDB TESTS ==================================================================================\n \n@@ -44,6 +57,20 @@\n // lldb-command:print *owned\n // lldb-check:[...]$4 = 6\n \n+// lldb-command:continue\n+\n+// lldb-command:print variable\n+// lldb-check:[...]$5 = 2\n+// lldb-command:print constant\n+// lldb-check:[...]$6 = 2\n+// lldb-command:print a_struct\n+// lldb-check:[...]$7 = Struct { a: -3, b: 4.5, c: 5 }\n+// lldb-command:print *struct_ref\n+// lldb-check:[...]$8 = Struct { a: -3, b: 4.5, c: 5 }\n+// lldb-command:print *owned\n+// lldb-check:[...]$9 = 6\n+\n+#![feature(unboxed_closures)]\n #![allow(unused_variables)]\n \n struct Struct {\n@@ -65,12 +92,22 @@ fn main() {\n     let struct_ref = &a_struct;\n     let owned = box 6;\n \n-    let closure = || {\n-        zzz(); // #break\n-        variable = constant + a_struct.a + struct_ref.a + *owned;\n-    };\n-\n-    closure();\n+    {\n+        let closure = || {\n+            zzz(); // #break\n+            variable = constant + a_struct.a + struct_ref.a + *owned;\n+        };\n+\n+        closure();\n+    }\n+\n+    {\n+        let mut unboxed_closure = |&mut:| {\n+            zzz(); // #break\n+            variable = constant + a_struct.a + struct_ref.a + *owned;\n+        };\n+        unboxed_closure();\n+    }\n }\n \n fn zzz() {()}"}, {"sha": "35bd68d803a2e3d43edef6382ef20b35f6cf324e", "filename": "src/test/run-pass/issue-18738.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18738.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(PartialEq, PartialOrd)]\n+#[deriving(Eq, PartialEq, PartialOrd, Ord)]\n enum Test<'a> {\n     Int(&'a int),\n     Slice(&'a [u8]),\n }\n \n-#[deriving(PartialEq, PartialOrd)]\n+#[deriving(Eq, PartialEq, PartialOrd, Ord)]\n struct Version {\n     vendor_info: &'static str\n }\n \n-#[deriving(PartialEq, PartialOrd)]\n+#[deriving(Eq, PartialEq, PartialOrd, Ord)]\n struct Foo(&'static str);\n \n fn main() {}"}, {"sha": "ccd5a225222da2e29bcbde97da17aa5cba88b76a", "filename": "src/test/run-pass/ufcs-type-params.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fufcs-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fufcs-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-type-params.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo<T> {\n+    fn get(&self) -> T;\n+}\n+\n+impl Foo<i32> for i32 {\n+    fn get(&self) -> i32 { *self }\n+}\n+\n+fn main() {\n+    let x: i32 = 1;\n+    Foo::<i32>::get(&x);\n+}"}, {"sha": "577e114945c66ee33ed254b9a39c3ee681a07933", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25e100173effba685d076cee16f8af150078617/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=b25e100173effba685d076cee16f8af150078617", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n-\n extern crate libc;\n \n use std::io::process::Command;\n@@ -18,51 +16,38 @@ use std::iter::IteratorExt;\n use libc::funcs::posix88::unistd;\n \n \n-// \"ps -A -o pid,sid,command\" with GNU ps should output something like this:\n-//   PID   SID COMMAND\n-//     1     1 /sbin/init\n+// The output from \"ps -A -o pid,ppid,args\" should look like this:\n+//   PID  PPID COMMAND\n+//     1     0 /sbin/init\n //     2     0 [kthreadd]\n-//     3     0 [ksoftirqd/0]\n // ...\n-// 12562  9237 ./spawn-failure\n-// 12563  9237 [spawn-failure] <defunct>\n-// 12564  9237 [spawn-failure] <defunct>\n+//  6076  9064 /bin/zsh\n+// ...\n+//  7164  6076 ./spawn-failure\n+//  7165  7164 [spawn-failure] <defunct>\n+//  7166  7164 [spawn-failure] <defunct>\n // ...\n-// 12592  9237 [spawn-failure] <defunct>\n-// 12593  9237 ps -A -o pid,sid,command\n-// 12884 12884 /bin/zsh\n-// 12922 12922 /bin/zsh\n+//  7197  7164 [spawn-failure] <defunct>\n+//  7198  7164 ps -A -o pid,ppid,command\n // ...\n \n #[cfg(unix)]\n fn find_zombies() {\n-    // http://man.freebsd.org/ps(1)\n-    // http://man7.org/linux/man-pages/man1/ps.1.html\n-    #[cfg(not(target_os = \"macos\"))]\n-    const FIELDS: &'static str = \"pid,sid,command\";\n-\n-    // https://developer.apple.com/library/mac/documentation/Darwin/\n-    // Reference/ManPages/man1/ps.1.html\n-    #[cfg(target_os = \"macos\")]\n-    const FIELDS: &'static str = \"pid,sess,command\";\n-\n-    let my_sid = unsafe { unistd::getsid(0) };\n+    let my_pid = unsafe { unistd::getpid() };\n \n-    let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", FIELDS]).output().unwrap();\n+    // http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ps.html\n+    let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", \"pid,ppid,args\"]).output().unwrap();\n     let ps_output = String::from_utf8_lossy(ps_cmd_output.output.as_slice());\n \n-    let found = ps_output.split('\\n').enumerate().any(|(line_no, line)|\n-        0 < line_no && 0 < line.len() &&\n-        my_sid == from_str(line.split(' ').filter(|w| 0 < w.len()).nth(1)\n-            .expect(\"1st column should be Session ID\")\n-            ).expect(\"Session ID string into integer\") &&\n-        line.contains(\"defunct\") && {\n-            println!(\"Zombie child {}\", line);\n-            true\n+    for (line_no, line) in ps_output.split('\\n').enumerate() {\n+        if 0 < line_no && 0 < line.len() &&\n+           my_pid == from_str(line.split(' ').filter(|w| 0 < w.len()).nth(1)\n+               .expect(\"1st column should be PPID\")\n+               ).expect(\"PPID string into integer\") &&\n+           line.contains(\"defunct\") {\n+            panic!(\"Zombie child {}\", line);\n         }\n-    );\n-\n-    assert!( ! found, \"Found at least one zombie child\");\n+    }\n }\n \n #[cfg(windows)]\n@@ -71,10 +56,13 @@ fn find_zombies() { }\n fn main() {\n     let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n \n-    for _ in range(0u32, 100) {\n-        let invalid = Command::new(too_long.as_slice()).spawn();\n-        assert!(invalid.is_err());\n-    }\n+    let _failures = Vec::from_fn(100, |_i| {\n+        let cmd = Command::new(too_long.as_slice());\n+        let failed = cmd.spawn();\n+        assert!(failed.is_err(), \"Make sure the command fails to spawn(): {}\", cmd);\n+        failed\n+    });\n \n     find_zombies();\n+    // then _failures goes out of scope\n }"}]}