{"sha": "4a22283d8bc872a8e3bd486744c261aca906f7f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMjIyODNkOGJjODcyYThlM2JkNDg2NzQ0YzI2MWFjYTkwNmY3ZjA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T03:18:39Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T03:18:39Z"}, "message": "Extract Terminator evaluation out of the main loop.", "tree": {"sha": "9cdb89d4f6e429e9330f1c8841b1f9f10a58db3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cdb89d4f6e429e9330f1c8841b1f9f10a58db3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a22283d8bc872a8e3bd486744c261aca906f7f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a22283d8bc872a8e3bd486744c261aca906f7f0", "html_url": "https://github.com/rust-lang/rust/commit/4a22283d8bc872a8e3bd486744c261aca906f7f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a22283d8bc872a8e3bd486744c261aca906f7f0/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bac5963b9d5f50b5652c071432445c0740ddef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bac5963b9d5f50b5652c071432445c0740ddef4", "html_url": "https://github.com/rust-lang/rust/commit/7bac5963b9d5f50b5652c071432445c0740ddef4"}], "stats": {"total": 193, "additions": 115, "deletions": 78}, "files": [{"sha": "09e24c90f38d4f3bb37987d9851eb3fe5dd25893", "filename": "src/interpreter.rs", "status": "modified", "additions": 115, "deletions": 78, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/4a22283d8bc872a8e3bd486744c261aca906f7f0/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a22283d8bc872a8e3bd486744c261aca906f7f0/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=4a22283d8bc872a8e3bd486744c261aca906f7f0", "patch": "@@ -62,15 +62,37 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     }\n }\n \n+struct Interpreter<'a, 'tcx: 'a> {\n+    /// The results of the type checker, from rustc.\n+    tcx: &'a TyCtxt<'tcx>,\n+\n+    /// A mapping from NodeIds to Mir, from rustc. Only contains MIR for crate-local items.\n+    mir_map: &'a MirMap<'tcx>,\n+\n+    /// A local cache from DefIds to Mir for non-crate-local items.\n+    mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n+\n+    /// The virtual memory system.\n+    memory: Memory,\n+\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'a, 'tcx>>,\n+\n+    /// Another stack containing the type substitutions for the current function invocation. Exists\n+    /// separately from `stack` because it must contain the `Substs` for a function while\n+    /// *creating* the `Frame` for that same function.\n+    substs_stack: Vec<&'tcx Substs<'tcx>>,\n+}\n+\n /// A stack frame.\n struct Frame<'a, 'tcx: 'a> {\n     /// The MIR for the function called on this frame.\n     mir: CachedMir<'a, 'tcx>,\n \n-    /// The block in the MIR this frame will execute once a fn call returns back to this frame.\n+    /// The block this frame will execute when a function call returns back to this frame.\n     next_block: mir::BasicBlock,\n \n-    /// A pointer for writing the return value of the current call, if it's not a diverging call.\n+    /// A pointer for writing the return value of the current call if it's not a diverging call.\n     return_ptr: Option<Pointer>,\n \n     /// The list of locals for the current function, stored in order as\n@@ -85,27 +107,16 @@ struct Frame<'a, 'tcx: 'a> {\n     temp_offset: usize,\n }\n \n-impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n-    fn arg_ptr(&self, i: u32) -> Pointer {\n-        self.locals[i as usize]\n-    }\n-\n-    fn var_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.var_offset + i as usize]\n-    }\n+/// Represents the action to be taken in the main loop as a result of executing a terminator.\n+enum TerminatorTarget {\n+    /// Make a local jump to the given block.\n+    Block(mir::BasicBlock),\n \n-    fn temp_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.temp_offset + i as usize]\n-    }\n-}\n+    /// Start executing from the new current frame. (For function calls.)\n+    Call,\n \n-struct Interpreter<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    mir_map: &'a MirMap<'tcx>,\n-    mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n-    memory: Memory,\n-    stack: Vec<Frame<'a, 'tcx>>,\n-    substs_stack: Vec<&'tcx Substs<'tcx>>,\n+    /// Stop executing the current frame and resume the previous frame.\n+    Return,\n }\n \n impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n@@ -195,82 +206,94 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                     try!(self.eval_assignment(lvalue, rvalue));\n                 }\n \n-                if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n+                let terminator = block_data.terminator();\n+                if TRACE_EXECUTION { println!(\"{:?}\", terminator); }\n+                match try!(self.eval_terminator(terminator)) {\n+                    TerminatorTarget::Block(block) => current_block = block,\n+                    TerminatorTarget::Return => break,\n+                    TerminatorTarget::Call => continue 'outer,\n+                }\n+            }\n+\n+            self.pop_stack_frame();\n+            self.substs_stack.pop();\n+        }\n \n-                use rustc::mir::repr::Terminator::*;\n-                match *block_data.terminator() {\n-                    Return => break,\n+        Ok(())\n+    }\n \n-                    Goto { target } => current_block = target,\n+    fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<TerminatorTarget> {\n+        use rustc::mir::repr::Terminator::*;\n+        let target = match *terminator {\n+            Return => TerminatorTarget::Return,\n \n-                    If { ref cond, targets: (then_target, else_target) } => {\n-                        let (cond_ptr, _) = try!(self.eval_operand(cond));\n-                        let cond_val = try!(self.memory.read_bool(cond_ptr));\n-                        current_block = if cond_val { then_target } else { else_target };\n-                    }\n+            Goto { target } => TerminatorTarget::Block(target),\n \n-                    SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                        let (discr_ptr, discr_repr) = try!(self.eval_lvalue(discr));\n-                        let discr_val = try!(self.memory.read_primval(discr_ptr, &discr_repr));\n+            If { ref cond, targets: (then_target, else_target) } => {\n+                let (cond_ptr, _) = try!(self.eval_operand(cond));\n+                let cond_val = try!(self.memory.read_bool(cond_ptr));\n+                TerminatorTarget::Block(if cond_val { then_target } else { else_target })\n+            }\n \n-                        // Branch to the `otherwise` case by default, if no match is found.\n-                        current_block = targets[targets.len() - 1];\n+            SwitchInt { ref discr, ref values, ref targets, .. } => {\n+                let (discr_ptr, discr_repr) = try!(self.eval_lvalue(discr));\n+                let discr_val = try!(self.memory.read_primval(discr_ptr, &discr_repr));\n \n-                        for (index, val_const) in values.iter().enumerate() {\n-                            let ptr = try!(self.const_to_ptr(val_const));\n-                            let val = try!(self.memory.read_primval(ptr, &discr_repr));\n-                            if discr_val == val {\n-                                current_block = targets[index];\n-                                break;\n-                            }\n-                        }\n-                    }\n+                // Branch to the `otherwise` case by default, if no match is found.\n+                let mut target_block = targets[targets.len() - 1];\n \n-                    Switch { ref discr, ref targets, .. } => {\n-                        let (adt_ptr, adt_repr) = try!(self.eval_lvalue(discr));\n-                        let discr_repr = match adt_repr {\n-                            Repr::Sum { ref discr, .. } => discr,\n-                            _ => panic!(\"attmpted to switch on non-sum type\"),\n-                        };\n-                        let discr_val = try!(self.memory.read_primval(adt_ptr, &discr_repr));\n-                        current_block = targets[discr_val.to_int() as usize];\n+                for (index, val_const) in values.iter().enumerate() {\n+                    let ptr = try!(self.const_to_ptr(val_const));\n+                    let val = try!(self.memory.read_primval(ptr, &discr_repr));\n+                    if discr_val == val {\n+                        target_block = targets[index];\n+                        break;\n                     }\n+                }\n \n-                    Call { ref func, ref args, ref destination, .. } => {\n-                        let mut return_ptr = None;\n-                        if let Some((ref lv, target)) = *destination {\n-                            self.current_frame_mut().next_block = target;\n-                            return_ptr = Some(try!(self.eval_lvalue(lv)).0)\n-                        }\n+                TerminatorTarget::Block(target_block)\n+            }\n \n-                        let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n+            Switch { ref discr, ref targets, .. } => {\n+                let (adt_ptr, adt_repr) = try!(self.eval_lvalue(discr));\n+                let discr_repr = match adt_repr {\n+                    Repr::Sum { ref discr, .. } => discr,\n+                    _ => panic!(\"attmpted to switch on non-sum type\"),\n+                };\n+                let discr_val = try!(self.memory.read_primval(adt_ptr, &discr_repr));\n+                TerminatorTarget::Block(targets[discr_val.to_int() as usize])\n+            }\n \n-                        match func_ty.sty {\n-                            ty::TyFnDef(def_id, substs, _) => {\n-                                let mir = self.load_mir(def_id);\n-                                self.substs_stack.push(substs);\n-                                try!(self.push_stack_frame(mir, args, return_ptr));\n-                                continue 'outer;\n-                            }\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let mut return_ptr = None;\n+                if let Some((ref lv, target)) = *destination {\n+                    self.current_frame_mut().next_block = target;\n+                    return_ptr = Some(try!(self.eval_lvalue(lv)).0)\n+                }\n \n-                            _ => panic!(\"can't handle callee of type {:?}\", func_ty),\n-                        }\n-                    }\n+                let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n \n-                    Drop { target, .. } => {\n-                        // TODO: Handle destructors and dynamic drop.\n-                        current_block = target;\n+                match func_ty.sty {\n+                    ty::TyFnDef(def_id, substs, _) => {\n+                        let mir = self.load_mir(def_id);\n+                        self.substs_stack.push(substs);\n+                        try!(self.push_stack_frame(mir, args, return_ptr));\n+                        TerminatorTarget::Call\n                     }\n \n-                    Resume => unimplemented!(),\n+                    _ => panic!(\"can't handle callee of type {:?}\", func_ty),\n                 }\n             }\n \n-            self.pop_stack_frame();\n-            self.substs_stack.pop();\n-        }\n+            Drop { target, .. } => {\n+                // TODO: Handle destructors and dynamic drop.\n+                TerminatorTarget::Block(target)\n+            }\n \n-        Ok(())\n+            Resume => unimplemented!(),\n+        };\n+\n+        Ok(target)\n     }\n \n     fn assign_to_product(&mut self, dest: Pointer, dest_repr: &Repr,\n@@ -521,6 +544,20 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n+    fn arg_ptr(&self, i: u32) -> Pointer {\n+        self.locals[i as usize]\n+    }\n+\n+    fn var_ptr(&self, i: u32) -> Pointer {\n+        self.locals[self.var_offset + i as usize]\n+    }\n+\n+    fn temp_ptr(&self, i: u32) -> Pointer {\n+        self.locals[self.temp_offset + i as usize]\n+    }\n+}\n+\n pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n     for (&id, mir) in &mir_map.map {\n         for attr in tcx.map.attrs(id) {"}]}