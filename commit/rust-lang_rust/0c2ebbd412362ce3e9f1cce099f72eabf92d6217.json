{"sha": "0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "node_id": "C_kwDOAAsO6NoAKDBjMmViYmQ0MTIzNjJjZTNlOWYxY2NlMDk5ZjcyZWFiZjkyZDYyMTc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-04T03:26:29Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-15T04:50:29Z"}, "message": "Rename `PtrKey` as `Interned` and improve it.\n\nIn particular, there's now more protection against incorrect usage,\nbecause you can only create one via `Interned::new_unchecked`, which\nmakes it more obvious that you must be careful.\n\nThere are also some tests.", "tree": {"sha": "d6afc689439a29266be7bc3d39411580a0432afd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6afc689439a29266be7bc3d39411580a0432afd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "html_url": "https://github.com/rust-lang/rust/commit/0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "028e57ba1dcb95481dee4744a101e75a13cc6482", "url": "https://api.github.com/repos/rust-lang/rust/commits/028e57ba1dcb95481dee4744a101e75a13cc6482", "html_url": "https://github.com/rust-lang/rust/commit/028e57ba1dcb95481dee4744a101e75a13cc6482"}], "stats": {"total": 227, "additions": 177, "deletions": 50}, "files": [{"sha": "e5d43db327bacf06a1af8c0cc60be110250fb909", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -0,0 +1,102 @@\n+use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher};\n+use std::ops::Deref;\n+use std::ptr;\n+\n+mod private {\n+    #[derive(Clone, Copy, Debug)]\n+    pub struct PrivateZst;\n+}\n+\n+/// A reference to a value that is interned, and is known to be unique.\n+///\n+/// Note that it is possible to have a `T` and a `Interned<T>` that are (or\n+/// refer to) equal but different values. But if you have two different\n+/// `Interned<T>`s, they both refer to the same value, at a single location in\n+/// memory. This means that equality and hashing can be done on the value's\n+/// address rather than the value's contents, which can improve performance.\n+///\n+/// The `PrivateZst` field means you can pattern match with `Interned(v, _)`\n+/// but you can only construct a `Interned` with `new_unchecked`, and not\n+/// directly.\n+#[derive(Debug)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Interned<'a, T>(pub &'a T, pub private::PrivateZst);\n+\n+impl<'a, T> Interned<'a, T> {\n+    /// Create a new `Interned` value. The value referred to *must* be interned\n+    /// and thus be unique, and it *must* remain unique in the future. This\n+    /// function has `_unchecked` in the name but is not `unsafe`, because if\n+    /// the uniqueness condition is violated condition it will cause incorrect\n+    /// behaviour but will not affect memory safety.\n+    #[inline]\n+    pub const fn new_unchecked(t: &'a T) -> Self {\n+        Interned(t, private::PrivateZst)\n+    }\n+}\n+\n+impl<'a, T> Clone for Interned<'a, T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<'a, T> Copy for Interned<'a, T> {}\n+\n+impl<'a, T> Deref for Interned<'a, T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        self.0\n+    }\n+}\n+\n+impl<'a, T> PartialEq for Interned<'a, T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        // Pointer equality implies equality, due to the uniqueness constraint.\n+        ptr::eq(self.0, other.0)\n+    }\n+}\n+\n+impl<'a, T> Eq for Interned<'a, T> {}\n+\n+impl<'a, T: PartialOrd> PartialOrd for Interned<'a, T> {\n+    fn partial_cmp(&self, other: &Interned<'a, T>) -> Option<Ordering> {\n+        // Pointer equality implies equality, due to the uniqueness constraint,\n+        // but the contents must be compared otherwise.\n+        if ptr::eq(self.0, other.0) {\n+            Some(Ordering::Equal)\n+        } else {\n+            let res = self.0.partial_cmp(&other.0);\n+            debug_assert!(res != Some(Ordering::Equal));\n+            res\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Ord for Interned<'a, T> {\n+    fn cmp(&self, other: &Interned<'a, T>) -> Ordering {\n+        // Pointer equality implies equality, due to the uniqueness constraint,\n+        // but the contents must be compared otherwise.\n+        if ptr::eq(self.0, other.0) {\n+            Ordering::Equal\n+        } else {\n+            let res = self.0.cmp(&other.0);\n+            debug_assert!(res != Ordering::Equal);\n+            res\n+        }\n+    }\n+}\n+\n+impl<'a, T> Hash for Interned<'a, T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient, due to the uniqueness constraint.\n+        ptr::hash(self.0, s)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "09810a0850e4d9c1df1fa8947cef0a0fb70e849d", "filename": "compiler/rustc_data_structures/src/intern/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -0,0 +1,59 @@\n+use super::*;\n+use std::cmp::Ordering;\n+\n+#[derive(Debug)]\n+struct S(u32);\n+\n+impl PartialEq for S {\n+    fn eq(&self, _other: &Self) -> bool {\n+        panic!(\"shouldn't be called\");\n+    }\n+}\n+\n+impl Eq for S {}\n+\n+impl PartialOrd for S {\n+    fn partial_cmp(&self, other: &S) -> Option<Ordering> {\n+        // The `==` case should be handled by `Interned`.\n+        assert_ne!(self.0, other.0);\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n+\n+impl Ord for S {\n+    fn cmp(&self, other: &S) -> Ordering {\n+        // The `==` case should be handled by `Interned`.\n+        assert_ne!(self.0, other.0);\n+        self.0.cmp(&other.0)\n+    }\n+}\n+\n+#[test]\n+fn test_uniq() {\n+    let s1 = S(1);\n+    let s2 = S(2);\n+    let s3 = S(3);\n+    let s4 = S(1); // violates uniqueness\n+\n+    let v1 = Interned::new_unchecked(&s1);\n+    let v2 = Interned::new_unchecked(&s2);\n+    let v3a = Interned::new_unchecked(&s3);\n+    let v3b = Interned::new_unchecked(&s3);\n+    let v4 = Interned::new_unchecked(&s4); // violates uniqueness\n+\n+    assert_ne!(v1, v2);\n+    assert_ne!(v2, v3a);\n+    assert_eq!(v1, v1);\n+    assert_eq!(v3a, v3b);\n+    assert_ne!(v1, v4); // same content but different addresses: not equal\n+\n+    assert_eq!(v1.cmp(&v2), Ordering::Less);\n+    assert_eq!(v3a.cmp(&v2), Ordering::Greater);\n+    assert_eq!(v1.cmp(&v1), Ordering::Equal); // only uses Interned::eq, not S::cmp\n+    assert_eq!(v3a.cmp(&v3b), Ordering::Equal); // only uses Interned::eq, not S::cmp\n+\n+    assert_eq!(v1.partial_cmp(&v2), Some(Ordering::Less));\n+    assert_eq!(v3a.partial_cmp(&v2), Some(Ordering::Greater));\n+    assert_eq!(v1.partial_cmp(&v1), Some(Ordering::Equal)); // only uses Interned::eq, not S::cmp\n+    assert_eq!(v3a.partial_cmp(&v3b), Some(Ordering::Equal)); // only uses Interned::eq, not S::cmp\n+}"}, {"sha": "80f83140f4b41a557338b02662b6c71e6d92aee8", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -21,6 +21,7 @@\n #![feature(type_alias_impl_trait)]\n #![feature(new_uninit)]\n #![feature(once_cell)]\n+#![feature(rustc_attrs)]\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n@@ -68,12 +69,12 @@ pub mod flock;\n pub mod functor;\n pub mod fx;\n pub mod graph;\n+pub mod intern;\n pub mod jobserver;\n pub mod macros;\n pub mod map_in_place;\n pub mod obligation_forest;\n pub mod owning_ref;\n-pub mod ptr_key;\n pub mod sip128;\n pub mod small_c_str;\n pub mod snapshot_map;"}, {"sha": "440ccb05d86e4a577d5b0619b089ac487fe6a753", "filename": "compiler/rustc_data_structures/src/ptr_key.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/028e57ba1dcb95481dee4744a101e75a13cc6482/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028e57ba1dcb95481dee4744a101e75a13cc6482/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs?ref=028e57ba1dcb95481dee4744a101e75a13cc6482", "patch": "@@ -1,37 +0,0 @@\n-use std::ops::Deref;\n-use std::{hash, ptr};\n-\n-/// A wrapper around reference that compares and hashes like a pointer.\n-/// Can be used as a key in sets/maps indexed by pointers to avoid `unsafe`.\n-#[derive(Debug)]\n-pub struct PtrKey<'a, T>(pub &'a T);\n-\n-impl<'a, T> Clone for PtrKey<'a, T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<'a, T> Copy for PtrKey<'a, T> {}\n-\n-impl<'a, T> PartialEq for PtrKey<'a, T> {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        ptr::eq(self.0, rhs.0)\n-    }\n-}\n-\n-impl<'a, T> Eq for PtrKey<'a, T> {}\n-\n-impl<'a, T> hash::Hash for PtrKey<'a, T> {\n-    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n-        (self.0 as *const T).hash(hasher)\n-    }\n-}\n-\n-impl<'a, T> Deref for PtrKey<'a, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        self.0\n-    }\n-}"}, {"sha": "a8c2a5e1424b829712ec6666a6f38aaf397cd641", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -11,7 +11,7 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n \n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir::def::{self, PartialRes};\n use rustc_hir::def_id::DefId;\n@@ -134,7 +134,7 @@ impl<'a> Import<'a> {\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n+    single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -153,7 +153,7 @@ impl<'a> NameResolution<'a> {\n     }\n \n     crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n-        self.single_imports.insert(PtrKey(import));\n+        self.single_imports.insert(Interned::new_unchecked(import));\n     }\n }\n \n@@ -850,7 +850,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     Err(Determined) => {\n                         let key = this.new_key(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&PtrKey(import));\n+                            resolution.single_imports.remove(&Interned::new_unchecked(import));\n                         });\n                     }\n                     Ok(binding) if !binding.is_importable() => {"}, {"sha": "28d8d9247ac131b827ec0b44cc5c2301521a4b39", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -38,7 +38,7 @@ use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n@@ -964,7 +964,7 @@ pub struct Resolver<'a> {\n     /// language items.\n     empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n+    binding_parent_modules: FxHashMap<Interned<'a, NameBinding<'a>>, Module<'a>>,\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n@@ -1115,7 +1115,7 @@ impl<'a> ResolverArenas<'a> {\n         self.name_resolutions.alloc(Default::default())\n     }\n     fn alloc_macro_rules_scope(&'a self, scope: MacroRulesScope<'a>) -> MacroRulesScopeRef<'a> {\n-        PtrKey(self.dropless.alloc(Cell::new(scope)))\n+        Interned::new_unchecked(self.dropless.alloc(Cell::new(scope)))\n     }\n     fn alloc_macro_rules_binding(\n         &'a self,\n@@ -2938,7 +2938,9 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn set_binding_parent_module(&mut self, binding: &'a NameBinding<'a>, module: Module<'a>) {\n-        if let Some(old_module) = self.binding_parent_modules.insert(PtrKey(binding), module) {\n+        if let Some(old_module) =\n+            self.binding_parent_modules.insert(Interned::new_unchecked(binding), module)\n+        {\n             if !ptr::eq(module, old_module) {\n                 span_bug!(binding.span, \"parent module is reset for binding\");\n             }\n@@ -2954,8 +2956,8 @@ impl<'a> Resolver<'a> {\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n-            self.binding_parent_modules.get(&PtrKey(macro_rules)),\n-            self.binding_parent_modules.get(&PtrKey(modularized)),\n+            self.binding_parent_modules.get(&Interned::new_unchecked(macro_rules)),\n+            self.binding_parent_modules.get(&Interned::new_unchecked(modularized)),\n         ) {\n             (Some(macro_rules), Some(modularized)) => {\n                 macro_rules.nearest_parent_mod() == modularized.nearest_parent_mod()"}, {"sha": "89c2a0c74bd36b950f89d88b749b00dc06b86b0e", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2ebbd412362ce3e9f1cce099f72eabf92d6217/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "patch": "@@ -11,7 +11,7 @@ use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, ResolverExpand};\n@@ -71,7 +71,7 @@ pub enum MacroRulesScope<'a> {\n /// This helps to avoid uncontrollable growth of `macro_rules!` scope chains,\n /// which usually grow lineraly with the number of macro invocations\n /// in a module (including derives) and hurt performance.\n-pub(crate) type MacroRulesScopeRef<'a> = PtrKey<'a, Cell<MacroRulesScope<'a>>>;\n+pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n // one for attribute-like macros (attributes, derives)."}]}