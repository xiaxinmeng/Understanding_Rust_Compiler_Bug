{"sha": "cf4683665f6808bb51c8d760efc953048b090137", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNDY4MzY2NWY2ODA4YmI1MWM4ZDc2MGVmYzk1MzA0OGIwOTAxMzc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-01T01:14:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-01T01:14:12Z"}, "message": "Rollup merge of #72823 - matthewjasper:describe-queries, r=eddyb\n\nAdd descriptions for all queries\n\nThis also removes the default description for queries with DefId keys and makes the macro validate that a description is provided.\n\ncc  #72730\nr? @eddyb", "tree": {"sha": "8914d552f22200251ea09a19289047e7848b1eb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8914d552f22200251ea09a19289047e7848b1eb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf4683665f6808bb51c8d760efc953048b090137", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe1FZkCRBK7hj4Ov3rIwAAdHIIAGcFJ3+TVKOqEeVIFGptJ6QX\nZlQ4gF8uEGs4ua2wKda7VALxoElKez0nWggN3nqDdyvexn2CRnhRGG12XWO+DbgH\n25BPXIKnhciojNaHDQzNiq07kYXNGrh8hwya6AE7dWIMFDhdG/6AxT0tc2gSV8AZ\nSFFx/xnHW4J1jNacRK5/KcZD4W17o4GgKOZ4lPWBNVpzfxuVEJRgfH/mzisFQwgi\nsma+MbJKHVvHZYMpyu6+amQoEa3q+/96gAITQvOTxtBI5/ucZ1IjaQyUPn2W2bwU\nV6vNpdydMi8u06R4ODxhLutF/9qNWRfYAV0ioOAsCA9kT74YFzM+7nIijRh69uI=\n=LBTn\n-----END PGP SIGNATURE-----\n", "payload": "tree 8914d552f22200251ea09a19289047e7848b1eb4\nparent 2e3417a82d8480a96832842193c7100d32d2db1c\nparent 8894bd220b82de486f2a8aecec6753c1b416b1f2\nauthor Dylan DPC <dylan.dpc@gmail.com> 1590974052 +0200\ncommitter GitHub <noreply@github.com> 1590974052 +0200\n\nRollup merge of #72823 - matthewjasper:describe-queries, r=eddyb\n\nAdd descriptions for all queries\n\nThis also removes the default description for queries with DefId keys and makes the macro validate that a description is provided.\n\ncc  #72730\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4683665f6808bb51c8d760efc953048b090137", "html_url": "https://github.com/rust-lang/rust/commit/cf4683665f6808bb51c8d760efc953048b090137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf4683665f6808bb51c8d760efc953048b090137/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e3417a82d8480a96832842193c7100d32d2db1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3417a82d8480a96832842193c7100d32d2db1c", "html_url": "https://github.com/rust-lang/rust/commit/2e3417a82d8480a96832842193c7100d32d2db1c"}, {"sha": "8894bd220b82de486f2a8aecec6753c1b416b1f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8894bd220b82de486f2a8aecec6753c1b416b1f2", "html_url": "https://github.com/rust-lang/rust/commit/8894bd220b82de486f2a8aecec6753c1b416b1f2"}], "stats": {"total": 431, "additions": 257, "deletions": 174}, "files": [{"sha": "41a49a38a19cf757c79b4866df92b64c688724cd", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -199,7 +199,7 @@ impl Parse for Group {\n \n struct QueryModifiers {\n     /// The description of the query.\n-    desc: Option<(Option<Ident>, Punctuated<Expr, Token![,]>)>,\n+    desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Use this type for the in-memory cache.\n     storage: Option<Type>,\n@@ -295,6 +295,9 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n             }\n         }\n     }\n+    let desc = desc.unwrap_or_else(|| {\n+        panic!(\"no description provided for query `{}`\", query.name);\n+    });\n     QueryModifiers {\n         load_cached,\n         storage,\n@@ -319,7 +322,7 @@ fn add_query_description_impl(\n     let key = &query.key.0;\n \n     // Find out if we should cache the query on disk\n-    let cache = modifiers.cache.as_ref().map(|(args, expr)| {\n+    let cache = if let Some((args, expr)) = modifiers.cache.as_ref() {\n         let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n             // Use custom code to load the query from disk\n             quote! {\n@@ -373,36 +376,32 @@ fn add_query_description_impl(\n \n             #try_load_from_disk\n         }\n-    });\n-\n-    if cache.is_none() && modifiers.load_cached.is_some() {\n-        panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n-    }\n+    } else {\n+        if modifiers.load_cached.is_some() {\n+            panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n+        }\n+        quote! {}\n+    };\n+\n+    let (tcx, desc) = modifiers.desc;\n+    let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+\n+    let desc = quote! {\n+        #[allow(unused_variables)]\n+        fn describe(\n+            #tcx: TyCtxt<'tcx>,\n+            #key: #arg,\n+        ) -> Cow<'static, str> {\n+            format!(#desc).into()\n+        }\n+    };\n \n-    let desc = modifiers.desc.as_ref().map(|(tcx, desc)| {\n-        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n-        quote! {\n-            #[allow(unused_variables)]\n-            fn describe(\n-                #tcx: TyCtxt<'tcx>,\n-                #key: #arg,\n-            ) -> Cow<'static, str> {\n-                format!(#desc).into()\n-            }\n+    impls.extend(quote! {\n+        impl<'tcx> QueryDescription<TyCtxt<'tcx>> for queries::#name<'tcx> {\n+            #desc\n+            #cache\n         }\n     });\n-\n-    if desc.is_some() || cache.is_some() {\n-        let cache = cache.unwrap_or(quote! {});\n-        let desc = desc.unwrap_or(quote! {});\n-\n-        impls.extend(quote! {\n-            impl<'tcx> QueryDescription<TyCtxt<'tcx>> for queries::#name<'tcx> {\n-                #desc\n-                #cache\n-            }\n-        });\n-    }\n }\n \n pub fn rustc_queries(input: TokenStream) -> TokenStream {"}, {"sha": "5a3ab205fc2381d323fe1a898d2a2ab0103e2192", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 168, "deletions": 66, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -7,10 +7,10 @@ use crate::traits::query::{\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n use crate::ty::query::queries;\n-use crate::ty::query::QueryDescription;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n+use rustc_query_system::query::QueryDescription;\n \n use rustc_span::symbol::Symbol;\n use std::borrow::Cow;\n@@ -91,6 +91,7 @@ rustc_queries! {\n \n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n+            desc { |tcx| \"computing type of `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -102,6 +103,7 @@ rustc_queries! {\n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> ty::Generics {\n+            desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n@@ -127,6 +129,7 @@ rustc_queries! {\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n         query predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing predicates of `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -172,16 +175,17 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+        query mir_built(key: LocalDefId) -> Steal<mir::Body<'tcx>> {\n             storage(ArenaCacheSelector<'tcx>)\n-            desc { \"building MIR for\" }\n+            desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n-        /// ready for const evaluation.\n+        /// ready for const qualification.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> Steal<mir::Body<'tcx>> {\n+        query mir_const(key: DefId) -> Steal<mir::Body<'tcx>> {\n+            desc { |tcx| \"processing MIR for `{}`\", tcx.def_path_str(key)  }\n             storage(ArenaCacheSelector<'tcx>)\n             no_hash\n         }\n@@ -199,11 +203,13 @@ rustc_queries! {\n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n         query optimized_mir(key: DefId) -> mir::Body<'tcx> {\n+            desc { |tcx| \"optimizing MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }\n \n         query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }\n@@ -237,14 +243,20 @@ rustc_queries! {\n         /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n-        query predicates_defined_on(_: DefId) -> ty::GenericPredicates<'tcx> {}\n+        query predicates_defined_on(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns the predicates written explicitly by the user.\n-        query explicit_predicates_of(_: DefId) -> ty::GenericPredicates<'tcx> {}\n+        query explicit_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing explicit predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        query inferred_outlives_of(_: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {}\n+        query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+            desc { |tcx| \"computing inferred outlives predicates of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of\n@@ -265,27 +277,34 @@ rustc_queries! {\n             }}\n         }\n \n-        query trait_def(_: DefId) -> ty::TraitDef {\n+        query trait_def(key: DefId) -> ty::TraitDef {\n+            desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n         }\n-        query adt_def(_: DefId) -> &'tcx ty::AdtDef {\n+        query adt_def(key: DefId) -> &'tcx ty::AdtDef {\n+            desc { |tcx| \"computing ADT definition for `{}`\", tcx.def_path_str(key) }\n+        }\n+        query adt_destructor(key: DefId) -> Option<ty::Destructor> {\n+            desc { |tcx| \"computing `Drop` impl for `{}`\", tcx.def_path_str(key) }\n         }\n-        query adt_destructor(_: DefId) -> Option<ty::Destructor> {}\n \n         // The cycle error here should be reported as an error by `check_representable`.\n         // We consider the type as Sized in the meanwhile to avoid\n         // further errors (done in impl Value for AdtSizedConstraint).\n         // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n         // in case we accidentally otherwise don't emit an error.\n         query adt_sized_constraint(\n-            _: DefId\n+            key: DefId\n         ) -> AdtSizedConstraint<'tcx> {\n+            desc { |tcx| \"computing `Sized` constraints for `{}`\", tcx.def_path_str(key) }\n             cycle_delay_bug\n         }\n \n         query adt_dtorck_constraint(\n-            _: DefId\n-        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}\n+            key: DefId\n+        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+            desc { |tcx| \"computing drop-check constraints for `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `true` if this is a const fn, use the `is_const_fn` to know whether your crate\n         /// actually sees it as const fn (e.g., the const-fn-ness might be unstable and you might\n@@ -316,18 +335,28 @@ rustc_queries! {\n         /// be removed in the future in favour of some form of check which figures out whether the\n         /// function does not inspect the bits of any of its arguments (so is essentially just a\n         /// constructor function).\n-        query is_promotable_const_fn(_: DefId) -> bool {}\n+        query is_promotable_const_fn(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is promotable: `{}`\", tcx.def_path_str(key) }\n+        }\n \n-        query const_fn_is_allowed_fn_ptr(_: DefId) -> bool {}\n+        query const_fn_is_allowed_fn_ptr(key: DefId) -> bool {\n+            desc { |tcx| \"checking if const fn allows `fn()` types: `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n-        query is_foreign_item(_: DefId) -> bool {}\n+        query is_foreign_item(key: DefId) -> bool {\n+            desc { |tcx| \"checking if `{}` is a foreign item\", tcx.def_path_str(key) }\n+        }\n \n         /// Returns `Some(mutability)` if the node pointed to by `def_id` is a static item.\n-        query static_mutability(_: DefId) -> Option<hir::Mutability> {}\n+        query static_mutability(def_id: DefId) -> Option<hir::Mutability> {\n+            desc { |tcx| \"looking up static mutability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Returns `Some(generator_kind)` if the node pointed to by `def_id` is a generator.\n-        query generator_kind(_: DefId) -> Option<hir::GeneratorKind> {}\n+        query generator_kind(def_id: DefId) -> Option<hir::GeneratorKind> {\n+            desc { |tcx| \"looking up generator kind of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Gets a map with the variance of every item; use `item_variance` instead.\n         query crate_variances(_: CrateNum) -> ty::CrateVariancesMap<'tcx> {\n@@ -336,7 +365,9 @@ rustc_queries! {\n         }\n \n         /// Maps from the `DefId` of a type or region parameter to its (inferred) variance.\n-        query variances_of(_: DefId) -> &'tcx [ty::Variance] {}\n+        query variances_of(def_id: DefId) -> &'tcx [ty::Variance] {\n+            desc { |tcx| \"computing the variances of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     TypeChecking {\n@@ -350,10 +381,13 @@ rustc_queries! {\n \n     Other {\n         /// Maps from an impl/trait `DefId to a list of the `DefId`s of its items.\n-        query associated_item_def_ids(_: DefId) -> &'tcx [DefId] {}\n+        query associated_item_def_ids(key: DefId) -> &'tcx [DefId] {\n+            desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n+        }\n \n         /// Maps from a trait item to the trait item \"descriptor\".\n-        query associated_item(_: DefId) -> ty::AssocItem {\n+        query associated_item(key: DefId) -> ty::AssocItem {\n+            desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n         }\n \n@@ -363,17 +397,24 @@ rustc_queries! {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n-        query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n-        query impl_polarity(_: DefId) -> ty::ImplPolarity {}\n+        query impl_trait_ref(key: DefId) -> Option<ty::TraitRef<'tcx>> {\n+            desc { |tcx| \"computing trait implemented by `{}`\", tcx.def_path_str(key) }\n+        }\n+        query impl_polarity(key: DefId) -> ty::ImplPolarity {\n+            desc { |tcx| \"computing implementation polarity of `{}`\", tcx.def_path_str(key) }\n+        }\n \n-        query issue33140_self_ty(_: DefId) -> Option<ty::Ty<'tcx>> {}\n+        query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n+            desc { |tcx| \"computing Self type wrt issue #33140 `{}`\", tcx.def_path_str(key) }\n+        }\n     }\n \n     TypeChecking {\n         /// Maps a `DefId` of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n-        query inherent_impls(_: DefId) -> &'tcx [DefId] {\n+        query inherent_impls(key: DefId) -> &'tcx [DefId] {\n+            desc { |tcx| \"collecting inherent impls for `{}`\", tcx.def_path_str(key) }\n             eval_always\n         }\n     }\n@@ -395,8 +436,10 @@ rustc_queries! {\n             desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        /// The signature of functions and closures.\n-        query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}\n+        /// The signature of functions.\n+        query fn_sig(key: DefId) -> ty::PolyFnSig<'tcx> {\n+            desc { |tcx| \"computing function signature of `{}`\", tcx.def_path_str(key) }\n+        }\n     }\n \n     Other {\n@@ -448,8 +491,10 @@ rustc_queries! {\n         }\n \n         /// Caches `CoerceUnsized` kinds for impls on custom types.\n-        query coerce_unsized_info(_: DefId)\n-            -> ty::adjustment::CoerceUnsizedInfo {}\n+        query coerce_unsized_info(key: DefId)\n+            -> ty::adjustment::CoerceUnsizedInfo {\n+                desc { |tcx| \"computing CoerceUnsized info for `{}`\", tcx.def_path_str(key) }\n+            }\n     }\n \n     TypeChecking {\n@@ -482,7 +527,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query has_typeck_tables(_: DefId) -> bool {}\n+        query has_typeck_tables(def_id: DefId) -> bool {\n+            desc { |tcx| \"checking whether `{}` has a body\", tcx.def_path_str(def_id) }\n+        }\n \n         query coherent_trait(def_id: DefId) -> () {\n             desc { |tcx| \"coherence checking all impls of trait `{}`\", tcx.def_path_str(def_id) }\n@@ -579,6 +626,7 @@ rustc_queries! {\n \n     TypeChecking {\n         query check_match(key: DefId) {\n+            desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -600,7 +648,9 @@ rustc_queries! {\n \n         /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n         /// in the case of closures, this will be redirected to the enclosing function.\n-        query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n+        query region_scope_tree(def_id: DefId) -> &'tcx region::ScopeTree {\n+            desc { |tcx| \"computing drop scopes for `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n             storage(ArenaCacheSelector<'tcx>)\n@@ -615,38 +665,58 @@ rustc_queries! {\n             cache_on_disk_if { true }\n         }\n \n-        query def_kind(_: DefId) -> DefKind {}\n-        query def_span(_: DefId) -> Span {\n+        query def_kind(def_id: DefId) -> DefKind {\n+            desc { |tcx| \"looking up definition kind of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query def_span(def_id: DefId) -> Span {\n+            desc { |tcx| \"looking up span for `{}`\", tcx.def_path_str(def_id) }\n             // FIXME(mw): DefSpans are not really inputs since they are derived from\n             // HIR. But at the moment HIR hashing still contains some hacks that allow\n             // to make type debuginfo to be source location independent. Declaring\n             // DefSpan an input makes sure that changes to these are always detected\n             // regardless of HIR hashing.\n             eval_always\n         }\n-        query lookup_stability(_: DefId) -> Option<&'tcx attr::Stability> {}\n-        query lookup_const_stability(_: DefId) -> Option<&'tcx attr::ConstStability> {}\n-        query lookup_deprecation_entry(_: DefId) -> Option<DeprecationEntry> {}\n-        query item_attrs(_: DefId) -> &'tcx [ast::Attribute] {}\n+        query lookup_stability(def_id: DefId) -> Option<&'tcx attr::Stability> {\n+            desc { |tcx| \"looking up stability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query lookup_const_stability(def_id: DefId) -> Option<&'tcx attr::ConstStability> {\n+            desc { |tcx| \"looking up const stability of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query lookup_deprecation_entry(def_id: DefId) -> Option<DeprecationEntry> {\n+            desc { |tcx| \"checking whether `{}` is deprecated\", tcx.def_path_str(def_id) }\n+        }\n+        query item_attrs(def_id: DefId) -> &'tcx [ast::Attribute] {\n+            desc { |tcx| \"collecting attributes of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Codegen {\n-        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {\n+        query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n+            desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { true }\n         }\n     }\n \n     Other {\n-        query fn_arg_names(_: DefId) -> &'tcx [Symbol] {}\n+        query fn_arg_names(def_id: DefId) -> &'tcx [Symbol] {\n+            desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n+        }\n         /// Gets the rendered value of the specified constant or associated constant.\n         /// Used by rustdoc.\n-        query rendered_const(_: DefId) -> String {}\n-        query impl_parent(_: DefId) -> Option<DefId> {}\n+        query rendered_const(def_id: DefId) -> String {\n+            desc { |tcx| \"rendering constant intializer of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query impl_parent(def_id: DefId) -> Option<DefId> {\n+            desc { |tcx| \"computing specialization parent impl of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     TypeChecking {\n-        query trait_of_item(_: DefId) -> Option<DefId> {}\n+        query trait_of_item(def_id: DefId) -> Option<DefId> {\n+            desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Codegen {\n@@ -692,12 +762,14 @@ rustc_queries! {\n         }\n \n         /// Gets the ParameterEnvironment for a given item; this environment\n-        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n+        /// will be in \"user-facing\" mode, meaning that it is suitable for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n         /// unless you are doing MIR optimizations, in which case you\n         /// might want to use `reveal_all()` method to change modes.\n-        query param_env(_: DefId) -> ty::ParamEnv<'tcx> {}\n+        query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n+            desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n+        }\n \n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n@@ -720,7 +792,8 @@ rustc_queries! {\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned.\n-        query adt_drop_tys(_: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+        query adt_drop_tys(def_id: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+            desc { |tcx| \"computing when `{}` needs drop\", tcx.def_path_str(def_id) }\n             cache_on_disk_if { true }\n         }\n \n@@ -774,7 +847,7 @@ rustc_queries! {\n             desc { \"query a crate's symbol mangling version\" }\n         }\n \n-        query extern_crate(_: DefId) -> Option<&'tcx ExternCrate> {\n+        query extern_crate(def_id: DefId) -> Option<&'tcx ExternCrate> {\n             eval_always\n             desc { \"getting crate's ExternCrateData\" }\n         }\n@@ -792,25 +865,29 @@ rustc_queries! {\n     }\n \n     Other {\n-        query module_exports(_: DefId) -> Option<&'tcx [Export<hir::HirId>]> {\n+        query module_exports(def_id: DefId) -> Option<&'tcx [Export<hir::HirId>]> {\n+            desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id) }\n             eval_always\n         }\n     }\n \n     TypeChecking {\n-        query impl_defaultness(_: DefId) -> hir::Defaultness {}\n+        query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n+            desc { |tcx| \"looking up whether `{}` is a default impl\", tcx.def_path_str(def_id) }\n+        }\n \n         query check_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n         query check_trait_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n         query check_impl_item_well_formed(key: LocalDefId) -> () {\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n     }\n \n+\n     Linking {\n         // The `DefId`s of all non-generic functions and statics in the given crate\n         // that can be reached from outside the crate.\n@@ -829,8 +906,15 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"looking up the exported symbols of a crate\" }\n         }\n-        query is_reachable_non_generic(_: DefId) -> bool {}\n-        query is_unreachable_local_definition(_: DefId) -> bool {}\n+        query is_reachable_non_generic(def_id: DefId) -> bool {\n+            desc { |tcx| \"checking whether `{}` is an exported symbol\", tcx.def_path_str(def_id) }\n+        }\n+        query is_unreachable_local_definition(def_id: DefId) -> bool {\n+            desc { |tcx|\n+                \"checking whether `{}` is reachable from outside the crate\",\n+                tcx.def_path_str(def_id),\n+            }\n+        }\n     }\n \n     Codegen {\n@@ -854,8 +938,13 @@ rustc_queries! {\n         ///\n         /// You likely want to call `Instance::upstream_monomorphization()`\n         /// instead of invoking this query directly.\n-        query upstream_monomorphizations_for(_: DefId)\n-            -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {}\n+        query upstream_monomorphizations_for(def_id: DefId)\n+            -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+                desc { |tcx|\n+                    \"collecting available upstream monomorphizations for `{}`\",\n+                    tcx.def_path_str(def_id),\n+                }\n+            }\n \n         /// Returns the upstream crate that exports drop-glue for the given\n         /// type (`substs` is expected to be a single-item list containing the\n@@ -932,10 +1021,16 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"dllimport_foreign_items\" }\n         }\n-        query is_dllimport_foreign_item(_: DefId) -> bool {}\n-        query is_statically_included_foreign_item(_: DefId) -> bool {}\n-        query native_library_kind(_: DefId)\n-            -> Option<NativeLibKind> {}\n+        query is_dllimport_foreign_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n+        }\n+        query is_statically_included_foreign_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"is_statically_included_foreign_item({})\", tcx.def_path_str(def_id) }\n+        }\n+        query native_library_kind(def_id: DefId)\n+            -> Option<NativeLibKind> {\n+            desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Linking {\n@@ -966,7 +1061,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query visibility(_: DefId) -> ty::Visibility {}\n+        query visibility(def_id: DefId) -> ty::Visibility {\n+            desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n+        }\n     }\n \n     Other {\n@@ -978,9 +1075,11 @@ rustc_queries! {\n             eval_always\n             desc { \"fetching what a crate is named\" }\n         }\n-        query item_children(_: DefId) -> &'tcx [Export<hir::HirId>] {}\n-        query extern_mod_stmt_cnum(_: LocalDefId) -> Option<CrateNum> {\n-            desc { \"fetching extern module statement\" }\n+        query item_children(def_id: DefId) -> &'tcx [Export<hir::HirId>] {\n+            desc { |tcx| \"collecting child items of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+        query extern_mod_stmt_cnum(def_id: LocalDefId) -> Option<CrateNum> {\n+            desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n \n         query get_lib_features(_: CrateNum) -> LibFeatures {\n@@ -1040,7 +1139,8 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query upvars_mentioned(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n+        query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n+            desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }\n             eval_always\n         }\n         query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n@@ -1094,7 +1194,9 @@ rustc_queries! {\n             eval_always\n             desc { \"collect_and_partition_mono_items\" }\n         }\n-        query is_codegened_item(_: DefId) -> bool {}\n+        query is_codegened_item(def_id: DefId) -> bool {\n+            desc { |tcx| \"determining whether `{}` needs codegen\", tcx.def_path_str(def_id) }\n+        }\n         query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n             desc { \"codegen_unit\" }\n         }"}, {"sha": "549056570f9bcec83e16859014c0eba31d518739", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -6,7 +6,6 @@ use crate::query::caches::QueryCache;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryState};\n use rustc_data_structures::profiling::ProfileCategory;\n-use rustc_span::def_id::DefId;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::borrow::Cow;\n@@ -132,25 +131,3 @@ where\n         try_load_from_disk: Q::try_load_from_disk,\n     };\n }\n-\n-impl<CTX: QueryContext, M> QueryDescription<CTX> for M\n-where\n-    M: QueryAccessors<CTX, Key = DefId>,\n-{\n-    default fn describe(tcx: CTX, def_id: DefId) -> Cow<'static, str> {\n-        if !tcx.verbose() {\n-            format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n-        } else {\n-            let name = ::std::any::type_name::<M>();\n-            format!(\"processing {:?} with query `{}`\", def_id, name).into()\n-        }\n-    }\n-\n-    default fn cache_on_disk(_: CTX, _: &Self::Key, _: Option<&Self::Value>) -> bool {\n-        false\n-    }\n-\n-    default fn try_load_from_disk(_: CTX, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n-        panic!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n-    }\n-}"}, {"sha": "1b4326ea56aaaaa7baea21921be6166fcce37b9a", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -30,7 +30,7 @@ note: ...which requires const-evaluating `<impl at $DIR/issue-24949-assoc-const-\n    |\n LL |     const BAR: u32 = IMPL_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n+note: ...which requires optimizing MIR for `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n    |\n LL |     const BAR: u32 = IMPL_REF_BAR;"}, {"sha": "8efa56a9a2e63133c6fe770db3753a5e70e89dd5", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait-default.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -30,7 +30,7 @@ note: ...which requires const-evaluating `FooDefault::BAR`...\n    |\n LL |     const BAR: u32 = DEFAULT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `FooDefault::BAR`...\n+note: ...which requires optimizing MIR for `FooDefault::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n    |\n LL |     const BAR: u32 = DEFAULT_REF_BAR;"}, {"sha": "78ce1a28a3fdcfb1c8f0a6dd641b9d13aa9153ae", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -30,7 +30,7 @@ note: ...which requires const-evaluating `<impl at $DIR/issue-24949-assoc-const-\n    |\n LL |     const BAR: u32 = TRAIT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n+note: ...which requires optimizing MIR for `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n    |\n LL |     const BAR: u32 = TRAIT_REF_BAR;"}, {"sha": "5fd7fe4480e3057b6378f23afacfa6735ff1d038", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -27,7 +27,7 @@ LL |     pub fn size_of<T>() -> usize;\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires normalizing `[u8; _]`...\n    = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Foo`\n+note: cycle used when checking that `Foo` is well-formed\n   --> $DIR/const-size_of-cycle.rs:3:1\n    |\n LL | struct Foo {"}, {"sha": "2c337cc6bf903bf6edefca9a1716777b93c41716", "filename": "src/test/ui/cycle-projection-based-on-where-clause.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -5,7 +5,7 @@ LL |           T : Add<T::Item>\n    |                   ^^^^^^^\n    |\n    = note: ...which again requires computing the bounds for type parameter `T`, completing the cycle\n-note: cycle used when processing `A`\n+note: cycle used when computing explicit predicates of `A`\n   --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n    |\n LL |           T : Add<T::Item>"}, {"sha": "58c458709a839513e898af68432ef03631f915a8", "filename": "src/test/ui/cycle-trait/cycle-trait-default-type-trait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-default-type-trait.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,23 +1,23 @@\n-error[E0391]: cycle detected when processing `Foo::X`\n+error[E0391]: cycle detected when computing type of `Foo::X`\n   --> $DIR/cycle-trait-default-type-trait.rs:4:23\n    |\n LL | trait Foo<X = Box<dyn Foo>> {\n    |                       ^^^\n    |\n-   = note: ...which again requires processing `Foo::X`, completing the cycle\n+   = note: ...which again requires computing type of `Foo::X`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-default-type-trait.rs:4:1\n    |\n LL | trait Foo<X = Box<dyn Foo>> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: cycle detected when processing `Foo::X`\n+error[E0391]: cycle detected when computing type of `Foo::X`\n   --> $DIR/cycle-trait-default-type-trait.rs:4:23\n    |\n LL | trait Foo<X = Box<dyn Foo>> {\n    |                       ^^^\n    |\n-   = note: ...which again requires processing `Foo::X`, completing the cycle\n+   = note: ...which again requires computing type of `Foo::X`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-default-type-trait.rs:4:1\n    |"}, {"sha": "64d02f07048e222d5705002107ff81719983d020", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n+error[E0391]: cycle detected when computing type of `cycle1::{{opaque}}#0`\n   --> $DIR/auto-trait-leak.rs:12:16\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -14,7 +14,7 @@ note: ...which requires processing `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n+note: ...which requires processing MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -24,7 +24,7 @@ note: ...which requires unsafety-checking `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -35,7 +35,7 @@ note: ...which requires type-checking `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{opaque}}#0`...\n+note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n   --> $DIR/auto-trait-leak.rs:22:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -50,7 +50,7 @@ note: ...which requires processing `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n+note: ...which requires processing MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -60,7 +60,7 @@ note: ...which requires unsafety-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -71,7 +71,7 @@ note: ...which requires type-checking `cycle2`...\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-   = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n+   = note: ...which again requires computing type of `cycle1::{{opaque}}#0`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n    |\n@@ -84,7 +84,7 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n+error[E0391]: cycle detected when computing type of `cycle1::{{opaque}}#0`\n   --> $DIR/auto-trait-leak.rs:12:16\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -100,7 +100,7 @@ note: ...which requires processing `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n+note: ...which requires processing MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -110,7 +110,7 @@ note: ...which requires unsafety-checking `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -121,7 +121,7 @@ note: ...which requires type-checking `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{opaque}}#0`...\n+note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n   --> $DIR/auto-trait-leak.rs:22:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -136,7 +136,7 @@ note: ...which requires processing `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n+note: ...which requires processing MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -146,7 +146,7 @@ note: ...which requires unsafety-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -156,7 +156,7 @@ note: ...which requires type-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n+   = note: ...which again requires computing type of `cycle1::{{opaque}}#0`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n    |\n@@ -169,7 +169,7 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n+error[E0391]: cycle detected when computing type of `cycle1::{{opaque}}#0`\n   --> $DIR/auto-trait-leak.rs:12:16\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -185,7 +185,7 @@ note: ...which requires processing `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n+note: ...which requires processing MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -195,7 +195,7 @@ note: ...which requires unsafety-checking `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -206,7 +206,7 @@ note: ...which requires type-checking `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{opaque}}#0`...\n+note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n   --> $DIR/auto-trait-leak.rs:22:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -221,7 +221,7 @@ note: ...which requires processing `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n+note: ...which requires processing MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -231,7 +231,7 @@ note: ...which requires unsafety-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for...\n+note: ...which requires building MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -241,7 +241,7 @@ note: ...which requires type-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n+   = note: ...which again requires computing type of `cycle1::{{opaque}}#0`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n    |"}, {"sha": "8578c5545bc90069fe449f2d3972753a31c0649a", "filename": "src/test/ui/infinite/infinite-tag-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.rs?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,5 +1,5 @@\n enum MList { Cons(isize, MList), Nil }\n //~^ ERROR recursive type `MList` has infinite size\n-//~| ERROR cycle detected when processing `MList`\n+//~| ERROR cycle detected when computing drop-check constraints for `MList`\n \n fn main() { let a = MList::Cons(10, MList::Cons(11, MList::Nil)); }"}, {"sha": "11f82b842ba6f600caba727f333441fbe102d653", "filename": "src/test/ui/infinite/infinite-tag-type-recursion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -8,13 +8,13 @@ LL | enum MList { Cons(isize, MList), Nil }\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `MList` representable\n \n-error[E0391]: cycle detected when processing `MList`\n+error[E0391]: cycle detected when computing drop-check constraints for `MList`\n   --> $DIR/infinite-tag-type-recursion.rs:1:1\n    |\n LL | enum MList { Cons(isize, MList), Nil }\n    | ^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `MList`, completing the cycle\n+   = note: ...which again requires computing drop-check constraints for `MList`, completing the cycle\n    = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: MList } }`\n \n error: aborting due to 2 previous errors"}, {"sha": "77adefeb124e355e2ec0482738e1a1f4631ed980", "filename": "src/test/ui/infinite/infinite-vec-type-recursion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-vec-type-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Finfinite%2Finfinite-vec-type-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-vec-type-recursion.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `X`\n+error[E0391]: cycle detected when computing type of `X`\n   --> $DIR/infinite-vec-type-recursion.rs:1:14\n    |\n LL | type X = Vec<X>;\n    |              ^\n    |\n-   = note: ...which again requires processing `X`, completing the cycle\n+   = note: ...which again requires computing type of `X`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/infinite-vec-type-recursion.rs:1:1\n    |"}, {"sha": "59cc6550a8bd6bb0736fbcfb360911e2fe39656f", "filename": "src/test/ui/issues/issue-21177.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21177.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -5,7 +5,7 @@ LL | fn foo<T: Trait<A = T::B>>() { }\n    |                     ^^^^\n    |\n    = note: ...which again requires computing the bounds for type parameter `T`, completing the cycle\n-note: cycle used when processing `foo`\n+note: cycle used when computing explicit predicates of `foo`\n   --> $DIR/issue-21177.rs:6:21\n    |\n LL | fn foo<T: Trait<A = T::B>>() { }"}, {"sha": "e8c1e8f9669731e963be73c8caea3eb3c8da995c", "filename": "src/test/ui/issues/issue-34373.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fissues%2Fissue-34373.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fissues%2Fissue-34373.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34373.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,15 +1,15 @@\n-error[E0391]: cycle detected when processing `Foo::T`\n+error[E0391]: cycle detected when computing type of `Foo::T`\n   --> $DIR/issue-34373.rs:7:30\n    |\n LL | pub struct Foo<T = Box<Trait<DefaultFoo>>>;\n    |                              ^^^^^^^^^^\n    |\n-note: ...which requires processing `DefaultFoo`...\n+note: ...which requires computing type of `DefaultFoo`...\n   --> $DIR/issue-34373.rs:8:19\n    |\n LL | type DefaultFoo = Foo;\n    |                   ^^^\n-   = note: ...which again requires processing `Foo::T`, completing the cycle\n+   = note: ...which again requires computing type of `Foo::T`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-34373.rs:1:1\n    |"}, {"sha": "4d1cd059c27b5e64e5072f33f2e3b920ba1687b7", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -4,10 +4,15 @@\n \n // build-fail\n \n-trait Mirror { type It: ?Sized; }\n-impl<T: ?Sized> Mirror for T { type It = Self; }\n+trait Mirror {\n+    type It: ?Sized;\n+}\n+impl<T: ?Sized> Mirror for T {\n+    type It = Self;\n+}\n struct S(Option<<S as Mirror>::It>);\n \n-fn main() { //~ NOTE cycle used when processing `main`\n+fn main() {\n+    //~^ NOTE cycle used when optimizing MIR for `main`\n     let _s = S(None);\n }"}, {"sha": "be55890c08c88598619337f96ed63a1f557e24db", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -2,8 +2,8 @@ error[E0391]: cycle detected when computing layout of `std::option::Option<S>`\n    |\n    = note: ...which requires computing layout of `S`...\n    = note: ...which again requires computing layout of `std::option::Option<S>`, completing the cycle\n-note: cycle used when processing `main`\n-  --> $DIR/issue-26548-recursion-via-normalize.rs:11:1\n+note: cycle used when optimizing MIR for `main`\n+  --> $DIR/issue-26548-recursion-via-normalize.rs:15:1\n    |\n LL | fn main() {\n    | ^^^^^^^^^"}, {"sha": "525b5cf7d8417f7d04573522598d4ca2ef6c65f9", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `<impl at $DIR/issue-23305.rs:5:1: 5:24>`\n+error[E0391]: cycle detected when computing type of `<impl at $DIR/issue-23305.rs:5:1: 5:24>`\n   --> $DIR/issue-23305.rs:5:16\n    |\n LL | impl dyn ToNbt<Self> {}\n    |                ^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/issue-23305.rs:5:1: 5:24>`, completing the cycle\n+   = note: ...which again requires computing type of `<impl at $DIR/issue-23305.rs:5:1: 5:24>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-23305.rs:1:1\n    |"}, {"sha": "5b5c1834cad1954c65d3ba0146726091b2eaafd1", "filename": "src/test/ui/resolve/resolve-self-in-impl.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fresolve%2Fresolve-self-in-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf4683665f6808bb51c8d760efc953048b090137/src%2Ftest%2Fui%2Fresolve%2Fresolve-self-in-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-self-in-impl.stderr?ref=cf4683665f6808bb51c8d760efc953048b090137", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `<impl at $DIR/resolve-self-in-impl.rs:14:1: 14:20>`\n+error[E0391]: cycle detected when computing type of `<impl at $DIR/resolve-self-in-impl.rs:14:1: 14:20>`\n   --> $DIR/resolve-self-in-impl.rs:14:13\n    |\n LL | impl Tr for Self {}\n    |             ^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/resolve-self-in-impl.rs:14:1: 14:20>`, completing the cycle\n+   = note: ...which again requires computing type of `<impl at $DIR/resolve-self-in-impl.rs:14:1: 14:20>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/resolve-self-in-impl.rs:1:1\n    |\n@@ -17,13 +17,13 @@ LL | |\n LL | | fn main() {}\n    | |____________^\n \n-error[E0391]: cycle detected when processing `<impl at $DIR/resolve-self-in-impl.rs:15:1: 15:23>`\n+error[E0391]: cycle detected when computing type of `<impl at $DIR/resolve-self-in-impl.rs:15:1: 15:23>`\n   --> $DIR/resolve-self-in-impl.rs:15:15\n    |\n LL | impl Tr for S<Self> {}\n    |               ^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/resolve-self-in-impl.rs:15:1: 15:23>`, completing the cycle\n+   = note: ...which again requires computing type of `<impl at $DIR/resolve-self-in-impl.rs:15:1: 15:23>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/resolve-self-in-impl.rs:1:1\n    |\n@@ -36,13 +36,13 @@ LL | |\n LL | | fn main() {}\n    | |____________^\n \n-error[E0391]: cycle detected when processing `<impl at $DIR/resolve-self-in-impl.rs:16:1: 16:13>`\n+error[E0391]: cycle detected when computing type of `<impl at $DIR/resolve-self-in-impl.rs:16:1: 16:13>`\n   --> $DIR/resolve-self-in-impl.rs:16:6\n    |\n LL | impl Self {}\n    |      ^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/resolve-self-in-impl.rs:16:1: 16:13>`, completing the cycle\n+   = note: ...which again requires computing type of `<impl at $DIR/resolve-self-in-impl.rs:16:1: 16:13>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/resolve-self-in-impl.rs:1:1\n    |\n@@ -55,13 +55,13 @@ LL | |\n LL | | fn main() {}\n    | |____________^\n \n-error[E0391]: cycle detected when processing `<impl at $DIR/resolve-self-in-impl.rs:17:1: 17:16>`\n+error[E0391]: cycle detected when computing type of `<impl at $DIR/resolve-self-in-impl.rs:17:1: 17:16>`\n   --> $DIR/resolve-self-in-impl.rs:17:8\n    |\n LL | impl S<Self> {}\n    |        ^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/resolve-self-in-impl.rs:17:1: 17:16>`, completing the cycle\n+   = note: ...which again requires computing type of `<impl at $DIR/resolve-self-in-impl.rs:17:1: 17:16>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/resolve-self-in-impl.rs:1:1\n    |\n@@ -74,13 +74,13 @@ LL | |\n LL | | fn main() {}\n    | |____________^\n \n-error[E0391]: cycle detected when processing `<impl at $DIR/resolve-self-in-impl.rs:18:1: 18:26>`\n+error[E0391]: cycle detected when computing trait implemented by `<impl at $DIR/resolve-self-in-impl.rs:18:1: 18:26>`\n   --> $DIR/resolve-self-in-impl.rs:18:1\n    |\n LL | impl Tr<Self::A> for S {}\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `<impl at $DIR/resolve-self-in-impl.rs:18:1: 18:26>`, completing the cycle\n+   = note: ...which again requires computing trait implemented by `<impl at $DIR/resolve-self-in-impl.rs:18:1: 18:26>`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/resolve-self-in-impl.rs:1:1\n    |"}]}