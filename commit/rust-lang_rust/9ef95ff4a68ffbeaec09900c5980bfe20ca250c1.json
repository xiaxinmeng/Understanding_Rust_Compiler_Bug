{"sha": "9ef95ff4a68ffbeaec09900c5980bfe20ca250c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjk1ZmY0YTY4ZmZiZWFlYzA5OTAwYzU5ODBiZmUyMGNhMjUwYzE=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-07-11T21:03:48Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-08-12T22:03:44Z"}, "message": "Reduce genericity in FlattenCompat", "tree": {"sha": "6768b5c776bfdb809e249aaaf125d5ac912fffd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6768b5c776bfdb809e249aaaf125d5ac912fffd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1", "html_url": "https://github.com/rust-lang/rust/commit/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ecbc7b7d1e78d1fac9e352ac9e9e843231cd37", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ecbc7b7d1e78d1fac9e352ac9e9e843231cd37", "html_url": "https://github.com/rust-lang/rust/commit/40ecbc7b7d1e78d1fac9e352ac9e9e843231cd37"}], "stats": {"total": 78, "additions": 52, "deletions": 26}, "files": [{"sha": "e3c85656116c0d5d91a23020603e9ccdf0c6f5c2", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef95ff4a68ffbeaec09900c5980bfe20ca250c1/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=9ef95ff4a68ffbeaec09900c5980bfe20ca250c1", "patch": "@@ -229,16 +229,16 @@ where\n                 if let elt@Some(_) = inner.next() { return elt }\n             }\n             match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                None => return self.backiter.as_mut()?.next(),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), U::size_hint);\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), U::size_hint);\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n@@ -250,20 +250,25 @@ where\n     fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            frontiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut *fold);\n+                *frontiter = Some(mid);\n+                r\n+            }\n+        }\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_fold(init, &mut fold)?;\n         }\n         self.frontiter = None;\n \n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n+        init = self.iter.try_fold(init, flatten(&mut self.frontiter, &mut fold))?;\n         self.frontiter = None;\n \n         if let Some(ref mut back) = self.backiter {\n@@ -275,13 +280,20 @@ where\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: Iterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.fold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+            .fold(init, flatten(fold))\n     }\n }\n \n@@ -297,7 +309,7 @@ where\n                 if let elt@Some(_) = inner.next_back() { return elt }\n             }\n             match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                None => return self.frontiter.as_mut()?.next_back(),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n         }\n@@ -307,20 +319,27 @@ where\n     fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            backiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a where\n+            T::IntoIter: DoubleEndedIterator,\n         {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n+            move |acc, x| {\n                 let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n+                let r = mid.try_rfold(acc, &mut *fold);\n                 *backiter = Some(mid);\n                 r\n-            })?;\n+            }\n         }\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        init = self.iter.try_rfold(init, flatten(&mut self.backiter, &mut fold))?;\n         self.backiter = None;\n \n         if let Some(ref mut front) = self.frontiter {\n@@ -332,12 +351,19 @@ where\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: DoubleEndedIterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.rfold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+            .rfold(init, flatten(fold))\n     }\n }"}]}