{"sha": "a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZTgzYTkwNWYxYWQ4MmYyZjM1ZmQ3MmI2YjY3OTdkN2I2MGI4ZDA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:30:43Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-03T15:30:43Z"}, "message": "s/AllocKind/AllocDiscriminant/", "tree": {"sha": "d487298b1c796cf66f35e5a5c05257e8393b365c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d487298b1c796cf66f35e5a5c05257e8393b365c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "html_url": "https://github.com/rust-lang/rust/commit/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d278e91882b2a15a06242f1c0846986f259a3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d278e91882b2a15a06242f1c0846986f259a3b7", "html_url": "https://github.com/rust-lang/rust/commit/3d278e91882b2a15a06242f1c0846986f259a3b7"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "8d8128f7a19b906d50f78d0d96f79e6379c45a7b", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a1e83a905f1ad82f2f35fd72b6b6797d7b60b8d0", "patch": "@@ -89,7 +89,7 @@ impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n #[derive(RustcDecodable, RustcEncodable)]\n-enum AllocKind {\n+enum AllocDiscriminant {\n     Alloc,\n     Fn,\n     Static,\n@@ -108,18 +108,18 @@ pub fn specialized_encode_alloc_id<\n     match alloc_type {\n         AllocType::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            AllocKind::Alloc.encode(encoder)?;\n+            AllocDiscriminant::Alloc.encode(encoder)?;\n             alloc.encode(encoder)?;\n         }\n         AllocType::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            AllocKind::Fn.encode(encoder)?;\n+            AllocDiscriminant::Fn.encode(encoder)?;\n             fn_instance.encode(encoder)?;\n         }\n         AllocType::Static(did) => {\n             // referring to statics doesn't need to know about their allocations,\n             // just about its DefId\n-            AllocKind::Static.encode(encoder)?;\n+            AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n     }\n@@ -188,10 +188,10 @@ impl<'s> AllocDecodingSession<'s> {\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocKind now so that we know if we have to reserve an\n+        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n         // AllocId.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n-            let alloc_kind = AllocKind::decode(decoder)?;\n+            let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n@@ -207,7 +207,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 ref mut entry @ State::Empty => {\n                     // We are allowed to decode\n                     match alloc_kind {\n-                        AllocKind::Alloc => {\n+                        AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // AllocId so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n@@ -216,7 +216,7 @@ impl<'s> AllocDecodingSession<'s> {\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n-                        AllocKind::Fn | AllocKind::Static => {\n+                        AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n                             // Fns and statics cannot be cyclic and their AllocId\n                             // is determined later by interning\n                             *entry = State::InProgressNonAlloc(\n@@ -250,23 +250,23 @@ impl<'s> AllocDecodingSession<'s> {\n         // Now decode the actual data\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n-                AllocKind::Alloc => {\n+                AllocDiscriminant::Alloc => {\n                     let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n                     // We already have a reserved AllocId.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n                     decoder.tcx().alloc_map.lock().set_id_same_memory(alloc_id, allocation);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Fn => {\n+                AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc id\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Static => {\n+                AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc id at\");\n                     let did = DefId::decode(decoder)?;"}]}