{"sha": "d699371f5ffe34801e002c80bbb3f75905b65ec8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OTkzNzFmNWZmZTM0ODAxZTAwMmM4MGJiYjNmNzU5MDViNjVlYzg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-20T14:16:23Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-20T14:16:23Z"}, "message": "\"Inline variable\" when on a use of the variable", "tree": {"sha": "45a95481959ab23ac5afb75ceb2a30eb97d684ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a95481959ab23ac5afb75ceb2a30eb97d684ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d699371f5ffe34801e002c80bbb3f75905b65ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d699371f5ffe34801e002c80bbb3f75905b65ec8", "html_url": "https://github.com/rust-lang/rust/commit/d699371f5ffe34801e002c80bbb3f75905b65ec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d699371f5ffe34801e002c80bbb3f75905b65ec8/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b34667c55e894e0a4881d1544bd2e89f932c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b34667c55e894e0a4881d1544bd2e89f932c01", "html_url": "https://github.com/rust-lang/rust/commit/15b34667c55e894e0a4881d1544bd2e89f932c01"}], "stats": {"total": 223, "additions": 185, "deletions": 38}, "files": [{"sha": "f5dafc8cb1fd8e05d84d2a347917fcfdf61024a6", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 185, "deletions": 38, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/d699371f5ffe34801e002c80bbb3f75905b65ec8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d699371f5ffe34801e002c80bbb3f75905b65ec8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=d699371f5ffe34801e002c80bbb3f75905b65ec8", "patch": "@@ -1,7 +1,9 @@\n-use ide_db::{defs::Definition, search::FileReference};\n+use either::Either;\n+use hir::PathResolution;\n+use ide_db::{base_db::FileId, defs::Definition, search::FileReference};\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n+    ast::{self, AstNode, AstToken, NameOwner},\n     TextRange,\n };\n \n@@ -27,44 +29,28 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n-    let bind_pat = match let_stmt.pat()? {\n-        ast::Pat::IdentPat(pat) => pat,\n-        _ => return None,\n-    };\n-    if bind_pat.mut_token().is_some() {\n-        cov_mark::hit!(test_not_inline_mut_variable);\n-        return None;\n-    }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n-        cov_mark::hit!(not_applicable_outside_of_bind_pat);\n-        return None;\n-    }\n+    let InlineData { let_stmt, delete_let, replace_usages, target } =\n+        inline_let(ctx).or_else(|| inline_usage(ctx))?;\n     let initializer_expr = let_stmt.initializer()?;\n \n-    let def = ctx.sema.to_def(&bind_pat)?;\n-    let def = Definition::Local(def);\n-    let usages = def.usages(&ctx.sema).all();\n-    if usages.is_empty() {\n-        cov_mark::hit!(test_not_applicable_if_variable_unused);\n-        return None;\n-    };\n-\n-    let delete_range = if let Some(whitespace) = let_stmt\n-        .syntax()\n-        .next_sibling_or_token()\n-        .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n-    {\n-        TextRange::new(\n-            let_stmt.syntax().text_range().start(),\n-            whitespace.syntax().text_range().end(),\n-        )\n+    let delete_range = if delete_let {\n+        if let Some(whitespace) = let_stmt\n+            .syntax()\n+            .next_sibling_or_token()\n+            .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n+        {\n+            Some(TextRange::new(\n+                let_stmt.syntax().text_range().start(),\n+                whitespace.syntax().text_range().end(),\n+            ))\n+        } else {\n+            Some(let_stmt.syntax().text_range())\n+        }\n     } else {\n-        let_stmt.syntax().text_range()\n+        None\n     };\n \n-    let wrap_in_parens = usages\n-        .references\n+    let wrap_in_parens = replace_usages\n         .iter()\n         .map(|(&file_id, refs)| {\n             refs.iter()\n@@ -114,14 +100,20 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n-    let target = bind_pat.syntax().text_range();\n+    let target = match target {\n+        ast::NameOrNameRef::Name(it) => it.syntax().text_range(),\n+        ast::NameOrNameRef::NameRef(it) => it.syntax().text_range(),\n+    };\n+\n     acc.add(\n         AssistId(\"inline_local_variable\", AssistKind::RefactorInline),\n         \"Inline variable\",\n         target,\n         move |builder| {\n-            builder.delete(delete_range);\n-            for (file_id, references) in usages.references {\n+            if let Some(range) = delete_range {\n+                builder.delete(range);\n+            }\n+            for (file_id, references) in replace_usages {\n                 for (&should_wrap, reference) in wrap_in_parens[&file_id].iter().zip(references) {\n                     let replacement =\n                         if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n@@ -140,6 +132,81 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n     )\n }\n \n+struct InlineData {\n+    let_stmt: ast::LetStmt,\n+    delete_let: bool,\n+    target: ast::NameOrNameRef,\n+    replace_usages: FxHashMap<FileId, Vec<FileReference>>,\n+}\n+\n+fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n+    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n+    let bind_pat = match let_stmt.pat()? {\n+        ast::Pat::IdentPat(pat) => pat,\n+        _ => return None,\n+    };\n+    if bind_pat.mut_token().is_some() {\n+        cov_mark::hit!(test_not_inline_mut_variable);\n+        return None;\n+    }\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n+        cov_mark::hit!(not_applicable_outside_of_bind_pat);\n+        return None;\n+    }\n+\n+    let def = ctx.sema.to_def(&bind_pat)?;\n+    let def = Definition::Local(def);\n+    let usages = def.usages(&ctx.sema).all();\n+    if usages.is_empty() {\n+        cov_mark::hit!(test_not_applicable_if_variable_unused);\n+        return None;\n+    };\n+\n+    Some(InlineData {\n+        let_stmt,\n+        delete_let: true,\n+        target: ast::NameOrNameRef::Name(bind_pat.name()?),\n+        replace_usages: usages.references,\n+    })\n+}\n+\n+fn inline_usage(ctx: &AssistContext) -> Option<InlineData> {\n+    let path_expr = ctx.find_node_at_offset::<ast::PathExpr>()?;\n+    let path = path_expr.path()?;\n+    let name = match path.as_single_segment()?.kind()? {\n+        ast::PathSegmentKind::Name(name) => name,\n+        _ => return None,\n+    };\n+\n+    let local = match ctx.sema.resolve_path(&path)? {\n+        PathResolution::Local(local) => local,\n+        _ => return None,\n+    };\n+\n+    let bind_pat = match local.source(ctx.db()).value {\n+        Either::Left(ident) => ident,\n+        _ => return None,\n+    };\n+\n+    let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n+\n+    let def = Definition::Local(local);\n+    let mut usages = def.usages(&ctx.sema).all();\n+\n+    let delete_let = usages.references.values().map(|v| v.len()).sum::<usize>() == 1;\n+\n+    for references in usages.references.values_mut() {\n+        references.retain(|reference| reference.name.as_name_ref() == Some(&name));\n+    }\n+\n+    Some(InlineData {\n+        let_stmt,\n+        delete_let,\n+        target: ast::NameOrNameRef::NameRef(name),\n+        replace_usages: usages.references,\n+    })\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -726,4 +793,84 @@ fn main() {\n \",\n         )\n     }\n+\n+    #[test]\n+    fn works_on_local_usage() {\n+        check_assist(\n+            inline_local_variable,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    xyz$0;\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_remove_let_when_multiple_usages() {\n+        check_assist(\n+            inline_local_variable,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    xyz$0;\n+    xyz;\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let xyz = 0;\n+    0;\n+    xyz;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_with_non_ident_pattern() {\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+fn main() {\n+    let (x, y) = (0, 1);\n+    x$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_on_local_usage_in_macro() {\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+macro_rules! m {\n+    ($i:ident) => { $i }\n+}\n+fn f() {\n+    let xyz = 0;\n+    m!(xyz$0); // replacing it would break the macro\n+}\n+\"#,\n+        );\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+macro_rules! m {\n+    ($i:ident) => { $i }\n+}\n+fn f() {\n+    let xyz$0 = 0;\n+    m!(xyz); // replacing it would break the macro\n+}\n+\"#,\n+        );\n+    }\n }"}]}