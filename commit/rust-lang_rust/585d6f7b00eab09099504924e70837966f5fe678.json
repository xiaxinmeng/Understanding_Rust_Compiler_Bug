{"sha": "585d6f7b00eab09099504924e70837966f5fe678", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NWQ2ZjdiMDBlYWIwOTA5OTUwNDkyNGU3MDgzNzk2NmY1ZmU2Nzg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-05T01:12:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:50:51Z"}, "message": "rustpkg: Massage for landing.", "tree": {"sha": "086b516f606d598da7d2fee28193e550ace8fbbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/086b516f606d598da7d2fee28193e550ace8fbbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/585d6f7b00eab09099504924e70837966f5fe678", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/585d6f7b00eab09099504924e70837966f5fe678", "html_url": "https://github.com/rust-lang/rust/commit/585d6f7b00eab09099504924e70837966f5fe678", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/585d6f7b00eab09099504924e70837966f5fe678/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e71da6ca1cd6953f3a8698cca5e16a9aadf0eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e71da6ca1cd6953f3a8698cca5e16a9aadf0eb", "html_url": "https://github.com/rust-lang/rust/commit/d4e71da6ca1cd6953f3a8698cca5e16a9aadf0eb"}], "stats": {"total": 915, "additions": 394, "deletions": 521}, "files": [{"sha": "13d4ec6e10df66c9dc6daadc2f2811a89fd08b7a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=585d6f7b00eab09099504924e70837966f5fe678", "patch": "@@ -41,7 +41,7 @@ let unwrapped_msg = match msg {\n \n */\n \n-use cmp::Eq;\n+use cmp::{Eq,Ord};\n use kinds::Copy;\n use option;\n use ptr;\n@@ -56,6 +56,34 @@ pub enum Option<T> {\n     Some(T),\n }\n \n+pub impl<T:Ord> Ord for Option<T> {\n+    pure fn lt(&self, other: &Option<T>) -> bool {\n+        match (self, other) {\n+            (&None, &None) => false,\n+            (&None, &Some(_)) => true,\n+            (&Some(_), &None) => false,\n+            (&Some(ref a), &Some(ref b)) => *a < *b\n+        }\n+    }\n+\n+    pure fn le(&self, other: &Option<T>) -> bool {\n+        match (self, other) {\n+            (&None, &None) => true,\n+            (&None, &Some(_)) => true,\n+            (&Some(_), &None) => false,\n+            (&Some(ref a), &Some(ref b)) => *a <= *b\n+        }\n+    }\n+\n+    pure fn ge(&self, other: &Option<T>) -> bool {\n+        ! (self < other)\n+    }\n+\n+    pure fn gt(&self, other: &Option<T>) -> bool {\n+        ! (self <= other)\n+    }\n+}\n+\n #[inline(always)]\n pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n     /*!"}, {"sha": "5b610bbb1f8ea0c6dbf9105a3cc9f048af210c66", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=585d6f7b00eab09099504924e70837966f5fe678", "patch": "@@ -20,6 +20,8 @@\n #[allow(vecs_implicitly_copyable,\n         non_implicitly_copyable_typarams)];\n \n+#[legacy_records];\n+\n extern mod core(vers = \"0.6\");\n extern mod std(vers = \"0.6\");\n extern mod rustc(vers = \"0.6\");\n@@ -29,10 +31,11 @@ use core::*;\n use io::{ReaderUtil, WriterUtil};\n use std::{json, semver, getopts};\n use std::net::url;\n-use send_map::linear::LinearMap;\n+use hashmap::linear::LinearMap;\n use rustc::metadata::filesearch;\n use rustc::driver::{driver, session};\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n+use syntax::codemap::spanned;\n \n mod usage;\n mod util;\n@@ -83,7 +86,7 @@ impl PackageScript {\n \n             for mis.each |a| {\n                 match a.node {\n-                    ast::meta_name_value(v, ast::spanned {\n+                    ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n                         match v {\n@@ -106,7 +109,7 @@ impl PackageScript {\n \n             for mis.each |a| {\n                 match a.node {\n-                    ast::meta_name_value(v, ast::spanned {\n+                    ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n                         match v {\n@@ -127,7 +130,7 @@ impl PackageScript {\n \n             for mis.each |a| {\n                 match a.node {\n-                    ast::meta_name_value(v, ast::spanned {\n+                    ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n                         match v {\n@@ -156,7 +159,7 @@ impl PackageScript {\n                             let (u, t) = load_pkg_dep_attr(mis);\n \n                             if u.is_none() {\n-                                fail ~\"pkg_dep attr without a url value\";\n+                                fail!(~\"pkg_dep attr without a url value\");\n                             }\n \n                             deps.push((u.get(), t));\n@@ -165,7 +168,7 @@ impl PackageScript {\n                             let f = load_pkg_crate_attr(mis);\n \n                             if f.is_none() {\n-                                fail ~\"pkg_file attr without a file value\";\n+                                fail!(~\"pkg_file attr without a file value\");\n                             }\n \n                             crates.push(f.get());\n@@ -222,7 +225,7 @@ impl PackageScript {\n \n     // Build the bootstrap and run a command\n     // FIXME (#4432): Use workcache to only compile the script when changed\n-    fn run(cmd: ~str, test: bool) -> int {\n+    fn run(&self, cmd: ~str, test: bool) -> int {\n         let work_dir = self.work_dir();\n         let input = self.input;\n         let sess = self.sess;\n@@ -238,12 +241,12 @@ impl PackageScript {\n         run::run_program(exe.to_str(), ~[root.to_str(), cmd, test.to_str()])\n     }\n \n-    fn hash() -> ~str {\n+    fn hash(&self) -> ~str {\n         fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()),\n                          self.vers.to_str())\n     }\n \n-    fn work_dir() -> Path {\n+    fn work_dir(&self) -> Path {\n         util::root().push(~\"work\").push(self.hash())\n     }\n }\n@@ -255,7 +258,7 @@ struct Ctx {\n }\n \n impl Ctx {\n-    fn run(cmd: ~str, args: ~[~str]) {\n+    fn run(&self, cmd: ~str, args: ~[~str]) {\n         let root = util::root();\n \n         util::need_dir(&root);\n@@ -333,11 +336,11 @@ impl Ctx {\n \n                 self.unprefer(name.get(), vers);\n             }\n-            _ => fail ~\"reached an unhandled command\"\n+            _ => fail!(~\"reached an unhandled command\")\n         }\n     }\n \n-    fn do_cmd(cmd: ~str) -> bool {\n+    fn do_cmd(&self, cmd: ~str) -> bool {\n         match cmd {\n             ~\"build\" | ~\"test\" => {\n                 util::error(~\"that command cannot be manually called\");\n@@ -367,7 +370,7 @@ impl Ctx {\n         status == 0\n     }\n \n-    fn build(dir: &Path, verbose: bool, opt: bool,\n+    fn build(&self, dir: &Path, verbose: bool, opt: bool,\n              test: bool) -> Option<PackageScript> {\n         let cwd = &os::getcwd();\n         let script = match PackageScript::parse(dir) {\n@@ -450,12 +453,12 @@ impl Ctx {\n         Some(script)\n     }\n \n-    fn compile(crate: &Path, dir: &Path, flags: ~[~str],\n+    fn compile(&self, crate: &Path, dir: &Path, flags: ~[~str],\n                cfgs: ~[~str], opt: bool, test: bool) -> bool {\n         util::compile_crate(None, crate, dir, flags, cfgs, opt, test)\n     }\n \n-    fn clean() -> bool {\n+    fn clean(&self) -> bool {\n         let script = match PackageScript::parse(&os::getcwd()) {\n             result::Ok(script) => script,\n             result::Err(err) => {\n@@ -480,23 +483,24 @@ impl Ctx {\n         true\n     }\n \n-    fn info() {\n+    fn info(&self) {\n         if self.json {\n             match PackageScript::parse(&os::getcwd()) {\n                 result::Ok(script) => {\n-                    let mut map = ~LinearMap();\n+                    let mut map = ~LinearMap::new();\n \n                     map.insert(~\"id\", json::String(script.id));\n                     map.insert(~\"name\", json::String(script.name));\n                     map.insert(~\"vers\", json::String(script.vers.to_str()));\n                     map.insert(~\"deps\", json::List(do script.deps.map |&dep| {\n                         let (url, target) = dep;\n-                        let mut inner = ~LinearMap();\n+                        let mut inner = ~LinearMap::new();\n \n                         inner.insert(~\"url\", json::String(url));\n \n                         if !target.is_none() {\n-                            inner.insert(~\"target\", json::String(target.get()));\n+                            inner.insert(~\"target\",\n+                                         json::String(target.get()));\n                         }\n \n                         json::Object(inner)\n@@ -519,7 +523,12 @@ impl Ctx {\n             util::note(fmt!(\"id: %s\", script.id));\n             util::note(fmt!(\"name: %s\", script.name));\n             util::note(fmt!(\"vers: %s\", script.vers.to_str()));\n-            util::note(fmt!(\"deps: %s\", if script.deps.len() > 0 { ~\"\" } else { ~\"none\" }));\n+            util::note(fmt!(\"deps: %s\",\n+                            if script.deps.len() > 0 {\n+                                ~\"\"\n+                            } else {\n+                                ~\"none\"\n+                            }));\n \n             for script.deps.each |&dep| {\n                 let (url, target) = dep;\n@@ -532,7 +541,8 @@ impl Ctx {\n         }\n     }\n \n-    fn install(url: Option<~str>, target: Option<~str>, cache: bool) -> bool {\n+    fn install(&self, url: Option<~str>,\n+               target: Option<~str>, cache: bool) -> bool {\n         let mut success;\n         let mut dir;\n \n@@ -608,7 +618,7 @@ impl Ctx {\n         true\n     }\n \n-    fn fetch(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+    fn fetch(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n         let url = if str::find_str(url, \"://\").is_none() {\n             ~\"http://\" + url }\n         else { url };\n@@ -641,7 +651,7 @@ impl Ctx {\n         }\n     }\n \n-    fn fetch_curl(dir: &Path, url: ~str) -> bool {\n+    fn fetch_curl(&self, dir: &Path, url: ~str) -> bool {\n         util::note(fmt!(\"fetching from %s using curl\", url));\n \n         let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n@@ -666,7 +676,7 @@ impl Ctx {\n         true\n     }\n \n-    fn fetch_git(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n@@ -698,7 +708,7 @@ impl Ctx {\n         true\n     }\n \n-    fn prefer(id: ~str, vers: Option<~str>) -> bool {\n+    fn prefer(&self, id: ~str, vers: Option<~str>) -> bool {\n         let package = match util::get_pkg(id, vers) {\n             result::Ok(package) => package,\n             result::Err(err) => {\n@@ -735,7 +745,7 @@ impl Ctx {\n         true\n     }\n \n-    fn test() -> bool {\n+    fn test(&self) -> bool {\n         let script = match self.build(&os::getcwd(), false, false, true) {\n             Some(script) => script,\n             None => {\n@@ -773,7 +783,7 @@ impl Ctx {\n         true\n     }\n \n-    fn uninstall(id: ~str, vers: Option<~str>) -> bool {\n+    fn uninstall(&self, id: ~str, vers: Option<~str>) -> bool {\n         let package = match util::get_pkg(id, vers) {\n             result::Ok(package) => package,\n             result::Err(err) => {\n@@ -812,7 +822,7 @@ impl Ctx {\n         true\n     }\n \n-    fn unprefer(id: ~str, vers: Option<~str>) -> bool {\n+    fn unprefer(&self, id: ~str, vers: Option<~str>) -> bool {\n         let package = match util::get_pkg(id, vers) {\n             result::Ok(package) => package,\n             result::Err(err) => {\n@@ -904,7 +914,7 @@ pub fn main() {\n     Ctx {\n         cfgs: cfgs,\n         json: json,\n-        mut dep_cache: LinearMap()\n+        mut dep_cache: LinearMap::new()\n     }.run(cmd, args);\n }\n \n@@ -942,31 +952,31 @@ pub fn run(listeners: ~[Listener]) {\n }\n \n pub impl Crate {\n-    pub fn flag(flag: ~str) -> Crate {\n+    pub fn flag(&self, flag: ~str) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, ~[flag]),\n-            .. copy self\n+            .. copy *self\n         }\n     }\n \n-    pub fn flags(flags: ~[~str]) -> Crate {\n+    pub fn flags(&self, flags: ~[~str]) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, flags),\n-            .. copy self\n+            .. copy *self\n         }\n     }\n \n-    pub fn cfg(cfg: ~str) -> Crate {\n+    pub fn cfg(&self, cfg: ~str) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, ~[cfg]),\n-            .. copy self\n+            .. copy *self\n         }\n     }\n \n-    pub fn cfgs(cfgs: ~[~str]) -> Crate {\n+    pub fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, cfgs),\n-            .. copy self\n+            .. copy *self\n         }\n     }\n }"}, {"sha": "1ad706742a8f6ec31b4ce44ba059ce2fe337f565", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 80, "deletions": 357, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=585d6f7b00eab09099504924e70837966f5fe678", "patch": "@@ -9,17 +9,20 @@\n // except according to those terms.\n \n use core::*;\n-use send_map::linear::LinearMap;\n+use hashmap::linear::LinearMap;\n use rustc::metadata::filesearch;\n use rustc::driver::{driver, session};\n use syntax::ast_util::*;\n use syntax::{ast, attr, codemap, diagnostic, fold, parse, visit};\n-use codemap::span;\n+use codemap::{span, dummy_sp, spanned};\n use std::semver;\n use std::{json, term, sort, getopts};\n use getopts::groups::getopts;\n use Listener;\n \n+use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::build;\n+\n pub struct Package {\n     id: ~str,\n     vers: semver::Version,\n@@ -30,7 +33,7 @@ pub struct Package {\n pub fn root() -> Path {\n     match filesearch::get_rustpkg_root() {\n         result::Ok(path) => path,\n-        result::Err(err) => fail err\n+        result::Err(err) => fail!(err)\n     }\n }\n \n@@ -59,23 +62,6 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n     result::Ok(parts.last())\n }\n \n-fn mk_rustpkg_use(ctx: @ReadyCtx) -> @ast::view_item {\n-    let vers = ast::lit_str(@~\"0.6\");\n-    let vers = no_span(vers);\n-    let mi = ast::meta_name_value(~\"vers\", vers);\n-    let mi = no_span(mi);\n-    let vi = ast::view_item_use(ctx.sess.ident_of(~\"rustpkg\"),\n-                                ~[@mi],\n-                                ctx.sess.next_node_id());\n-\n-    @ast::view_item {\n-        node: vi,\n-        attrs: ~[],\n-        vis: ast::private,\n-        span: dummy_sp()\n-    }\n-}\n-\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::span,\n@@ -85,11 +71,12 @@ struct ListenerFn {\n struct ReadyCtx {\n     sess: session::Session,\n     crate: @ast::crate,\n+    ext_cx: ext_ctxt,\n     mut path: ~[ast::ident],\n     mut fns: ~[ListenerFn]\n }\n \n-fn fold_mod(ctx: @ReadyCtx, m: ast::_mod,\n+fn fold_mod(_ctx: @ReadyCtx, m: ast::_mod,\n             fold: fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n@@ -101,23 +88,13 @@ fn fold_mod(ctx: @ReadyCtx, m: ast::_mod,\n     }\n \n     fold::noop_fold_mod(ast::_mod {\n-        view_items: vec::append_one(m.view_items, mk_rustpkg_use(ctx)),\n         items: do vec::map(m.items) |item| {\n             strip_main(*item)\n-        }\n+        },\n+        .. m\n     }, fold)\n }\n \n-fn fold_crate(ctx: @ReadyCtx, crate: ast::crate_,\n-              fold: fold::ast_fold) -> ast::crate_ {\n-    let folded = fold::noop_fold_crate(crate, fold);\n-\n-    ast::crate_ {\n-        module: add_pkg_module(ctx, /*bad*/copy folded.module),\n-        .. folded\n-    }\n-}\n-\n fn fold_item(ctx: @ReadyCtx, item: @ast::item,\n              fold: fold::ast_fold) -> Option<@ast::item> {\n \n@@ -156,315 +133,50 @@ fn fold_item(ctx: @ReadyCtx, item: @ast::item,\n     res\n }\n \n-fn mk_rustpkg_import(ctx: @ReadyCtx) -> @ast::view_item {\n-    let path = @ast::path {\n-        span: dummy_sp(),\n-        global: false,\n-        idents: ~[ctx.sess.ident_of(~\"rustpkg\")],\n-        rp: None,\n-        types: ~[]\n-    };\n-    let vp = @no_span(ast::view_path_simple(ctx.sess.ident_of(~\"rustpkg\"),\n-                                            path, ast::type_value_ns,\n-                                            ctx.sess.next_node_id()));\n-\n-    @ast::view_item {\n-        node: ast::view_item_import(~[vp]),\n-        attrs: ~[],\n-        vis: ast::private,\n-        span: dummy_sp()\n-    }\n-}\n-\n fn add_pkg_module(ctx: @ReadyCtx, m: ast::_mod) -> ast::_mod {\n-    let listeners = mk_listeners(ctx);\n-    let main = mk_main(ctx);\n-    let pkg_mod = @ast::_mod {\n-        view_items: ~[mk_rustpkg_import(ctx)],\n-        items: ~[main, listeners]\n-    };\n-    let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n-    let item_ = ast::item_mod(*pkg_mod);\n-    let item = @ast::item {\n-        ident: ctx.sess.ident_of(~\"__pkg\"),\n-        attrs: ~[resolve_unexported_attr],\n-        id: ctx.sess.next_node_id(),\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-    };\n-\n+    let listeners = mk_listener_vec(ctx);\n+    let ext_cx = ctx.ext_cx;\n+    let item = quote_item! (\n+        mod __pkg {\n+            extern mod rustpkg (vers=\"0.6\");\n+            const listeners : &[rustpkg::Listener] = $listeners;\n+            #[main]\n+            fn main() {\n+                rustpkg::run(listeners);\n+            }\n+        }\n+    );\n     ast::_mod {\n-        items: vec::append_one(/*bad*/copy m.items, item),\n+        items: vec::append_one(/*bad*/copy m.items, item.get()),\n         .. m\n     }\n }\n \n-fn no_span<T: Copy>(t: T) -> ast::spanned<T> {\n-    ast::spanned {\n-        node: t,\n-        span: dummy_sp()\n-    }\n-}\n-\n-fn path_node(ids: ~[ast::ident]) -> @ast::path {\n-    @ast::path {\n-        span: dummy_sp(),\n-        global: false,\n-        idents: ids,\n-        rp: None,\n-        types: ~[]\n-    }\n-}\n-\n-fn path_node_global(ids: ~[ast::ident]) -> @ast::path {\n-    @ast::path {\n-        span: dummy_sp(),\n-        global: true,\n-        idents: ids,\n-        rp: None,\n-        types: ~[]\n-    }\n-}\n-\n-fn mk_listeners(ctx: @ReadyCtx) -> @ast::item {\n-    let ret_ty = mk_listener_vec_ty(ctx);\n-    let decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: ret_ty,\n-        cf: ast::return_val\n-    };\n-    let listeners = mk_listener_vec(ctx);\n-    let body_ = default_block(~[], option::Some(listeners),\n-                              ctx.sess.next_node_id());\n-    let body = no_span(body_);\n-    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n-\n-    @ast::item {\n-        ident: ctx.sess.ident_of(~\"listeners\"),\n-        attrs: ~[],\n-        id: ctx.sess.next_node_id(),\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-    }\n-}\n-\n-fn mk_path(ctx: @ReadyCtx, path: ~[ast::ident]) -> @ast::path {\n-    path_node(~[ctx.sess.ident_of(~\"rustpkg\")] + path)\n-}\n-\n-fn mk_listener_vec_ty(ctx: @ReadyCtx) -> @ast::Ty {\n-    let listener_ty_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"Listener\")]);\n-    let listener_ty = ast::Ty {\n-        id: ctx.sess.next_node_id(),\n-        node: ast::ty_path(listener_ty_path,\n-                           ctx.sess.next_node_id()),\n-        span: dummy_sp()\n-    };\n-    let vec_mt = ast::mt {\n-        ty: @listener_ty,\n-        mutbl: ast::m_imm\n-    };\n-    let inner_ty = @ast::Ty {\n-        id: ctx.sess.next_node_id(),\n-        node: ast::ty_vec(vec_mt),\n-        span: dummy_sp()\n-    };\n-\n-    @ast::Ty {\n-        id: ctx.sess.next_node_id(),\n-        node: ast::ty_uniq(ast::mt {\n-            ty: inner_ty,\n-            mutbl: ast::m_imm\n-        }),\n-        span: dummy_sp()\n-    }\n-}\n-\n fn mk_listener_vec(ctx: @ReadyCtx) -> @ast::expr {\n     let fns = ctx.fns;\n-\n     let descs = do fns.map |listener| {\n         mk_listener_rec(ctx, *listener)\n     };\n-    let inner_expr = @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_vec(descs, ast::m_imm),\n-        span: dummy_sp()\n-    };\n-\n-    @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n-        span: dummy_sp()\n-    }\n+    build::mk_slice_vec_e(ctx.ext_cx, dummy_sp(), descs)\n }\n \n fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n+\n     let span = listener.span;\n-    let path = /*bad*/copy listener.path;\n-    let descs = do listener.cmds.map |&cmd| {\n-        let inner = @ast::expr {\n-            id: ctx.sess.next_node_id(),\n-            callee_id: ctx.sess.next_node_id(),\n-            node: ast::expr_lit(@no_span(ast::lit_str(@cmd))),\n-            span: span\n-        };\n-\n-        @ast::expr {\n-            id: ctx.sess.next_node_id(),\n-            callee_id: ctx.sess.next_node_id(),\n-            node: ast::expr_vstore(inner, ast::expr_vstore_uniq),\n-            span: dummy_sp()\n-        }\n-    };\n-    let cmd_expr_inner = @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_vec(descs, ast::m_imm),\n-        span: dummy_sp()\n-    };\n-    let cmd_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_vstore(cmd_expr_inner, ast::expr_vstore_uniq),\n-        span: dummy_sp()\n-    };\n-    let cmd_field = no_span(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: ctx.sess.ident_of(~\"cmds\"),\n-        expr: @cmd_expr,\n-    });\n-\n-    let cb_path = path_node_global(path);\n-    let cb_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_path(cb_path),\n-        span: span\n+    let cmds = do listener.cmds.map |&cmd| {\n+        build::mk_base_str(ctx.ext_cx, span, cmd)\n     };\n-    let cb_wrapper_expr = mk_fn_wrapper(ctx, cb_expr, span);\n-    let cb_field = no_span(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: ctx.sess.ident_of(~\"cb\"),\n-        expr: cb_wrapper_expr\n-    });\n-\n-    let listener_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"Listener\")]);\n-    let listener_rec_ = ast::expr_struct(listener_path,\n-                                         ~[cmd_field, cb_field],\n-                                         option::None);\n-    @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: listener_rec_,\n-        span: span\n-    }\n-}\n \n-fn mk_fn_wrapper(ctx: @ReadyCtx, fn_path_expr: ast::expr,\n-                 span: span) -> @ast::expr {\n-    let call_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_call(@fn_path_expr, ~[], false),\n-        span: span\n-    };\n-    let call_stmt = no_span(ast::stmt_semi(@call_expr,\n-                                           ctx.sess.next_node_id()));\n-    let wrapper_decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: @ast::Ty {\n-            id: ctx.sess.next_node_id(),\n-            node: ast::ty_nil, span: span\n-        },\n-        cf: ast::return_val\n-    };\n-    let wrapper_body = no_span(ast::blk_ {\n-        view_items: ~[],\n-        stmts: ~[@call_stmt],\n-        expr: option::None,\n-        id: ctx.sess.next_node_id(),\n-        rules: ast::default_blk\n-    });\n-\n-    @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: ast::expr_fn(ast::ProtoBare, wrapper_decl,\n-                           wrapper_body, @~[]),\n-        span: span\n-    }\n-}\n+    let cmds_expr = build::mk_slice_vec_e(ctx.ext_cx, span, cmds);\n+    let cb_expr = build::mk_path(ctx.ext_cx, span, copy listener.path);\n+    let ext_cx = ctx.ext_cx;\n \n-fn mk_main(ctx: @ReadyCtx) -> @ast::item {\n-    let ret_ty = ast::Ty {\n-        id: ctx.sess.next_node_id(),\n-        node: ast::ty_nil,\n-        span: dummy_sp()\n-    };\n-    let decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: @ret_ty,\n-        cf: ast::return_val\n-    };\n-    let run_call_expr = mk_run_call(ctx);\n-    let body_ = default_block(~[], option::Some(run_call_expr),\n-                              ctx.sess.next_node_id());\n-    let body = ast::spanned {\n-        node: body_,\n-        span: dummy_sp()\n-    };\n-    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n-\n-    @ast::item {\n-        ident: ctx.sess.ident_of(~\"main\"),\n-        attrs: ~[attr::mk_attr(attr::mk_word_item(~\"main\"))],\n-        id: ctx.sess.next_node_id(),\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-    }\n-}\n-\n-fn mk_run_call(ctx: @ReadyCtx) -> @ast::expr {\n-    let listener_path = path_node(~[ctx.sess.ident_of(~\"listeners\")]);\n-    let listener_path_expr_ = ast::expr_path(listener_path);\n-    let listener_path_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: listener_path_expr_,\n-        span: dummy_sp()\n-    };\n-    let listener_call_expr_ = ast::expr_call(@listener_path_expr, ~[], false);\n-    let listener_call_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: listener_call_expr_,\n-        span: dummy_sp()\n-    };\n-    let rustpkg_run_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"run\")]);\n-\n-    let rustpkg_run_path_expr_ = ast::expr_path(rustpkg_run_path);\n-    let rustpkg_run_path_expr = ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: rustpkg_run_path_expr_,\n-        span: dummy_sp()\n-    };\n-    let rustpkg_run_call_expr_ = ast::expr_call(@rustpkg_run_path_expr,\n-                                               ~[@listener_call_expr],\n-                                               false);\n-    @ast::expr {\n-        id: ctx.sess.next_node_id(),\n-        callee_id: ctx.sess.next_node_id(),\n-        node: rustpkg_run_call_expr_,\n-        span: dummy_sp()\n-    }\n+    quote_expr!(\n+        Listener {\n+            cmds: $cmds_expr,\n+            cb: $cb_expr\n+        }\n+    )\n }\n \n /// Generate/filter main function, add the list of commands, etc.\n@@ -473,11 +185,12 @@ pub fn ready_crate(sess: session::Session,\n     let ctx = @ReadyCtx {\n         sess: sess,\n         crate: crate,\n+        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n         mut path: ~[],\n         mut fns: ~[]\n     };\n     let precursor = @fold::AstFoldFns {\n-        fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n+        // fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n         fold_item: |a, b| fold_item(ctx, a, b),\n         fold_mod: |a, b| fold_mod(ctx, a, b),\n         .. *fold::default_ast_fold()\n@@ -497,7 +210,7 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n \n pub fn need_dir(s: &Path) {\n     if !os::path_is_dir(s) && !os::make_dir(s, 493_i32) {\n-        fail fmt!(\"can't create dir: %s\", s.to_str());\n+        fail!(fmt!(\"can't create dir: %s\", s.to_str()));\n     }\n }\n \n@@ -509,7 +222,9 @@ pub fn note(msg: ~str) {\n         out.write_str(~\"note: \");\n         term::reset(out);\n         out.write_line(msg);\n-    } else { out.write_line(~\"note: \" + msg); }\n+    } else {\n+        out.write_line(~\"note: \" + msg);\n+    }\n }\n \n pub fn warn(msg: ~str) {\n@@ -520,7 +235,9 @@ pub fn warn(msg: ~str) {\n         out.write_str(~\"warning: \");\n         term::reset(out);\n         out.write_line(msg);\n-    }else { out.write_line(~\"warning: \" + msg); }\n+    } else {\n+        out.write_line(~\"warning: \" + msg);\n+    }\n }\n \n pub fn error(msg: ~str) {\n@@ -531,8 +248,9 @@ pub fn error(msg: ~str) {\n         out.write_str(~\"error: \");\n         term::reset(out);\n         out.write_line(msg);\n+    } else {\n+        out.write_line(~\"error: \" + msg);\n     }\n-    else { out.write_line(~\"error: \" + msg); }\n }\n \n pub fn hash(data: ~str) -> ~str {\n@@ -590,23 +308,23 @@ pub fn wait_for_lock(path: &Path) {\n \n fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n     for packages.each |&package| {\n-        match package {\n-            json::Object(map) => {\n+        match &package {\n+            &json::Object(ref map) => {\n                 let mut has_id = false;\n \n                 match map.get(&~\"id\") {\n-                    json::String(str) => {\n-                        if pkg.id == str {\n+                    &json::String(ref str) => {\n+                        if pkg.id == *str {\n                             has_id = true;\n                         }\n                     }\n                     _ => {}\n                 }\n \n                 match map.get(&~\"vers\") {\n-                    json::String(str) => {\n-                        if has_id && pkg.vers.to_str() == str {\n-                            return packages;\n+                    &json::String(ref str) => {\n+                        if has_id && pkg.vers.to_str() == *str {\n+                            return copy packages;\n                         }\n                     }\n                     _ => {}\n@@ -616,7 +334,7 @@ fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n         }\n     }\n \n-    let mut map = ~LinearMap();\n+    let mut map = ~LinearMap::new();\n \n     map.insert(~\"id\", json::String(pkg.id));\n     map.insert(~\"vers\", json::String(pkg.vers.to_str()));\n@@ -631,13 +349,13 @@ fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n }\n \n fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n-    do packages.filter_map |&package| {\n-        match package {\n-            json::Object(map) => {\n+    do packages.filter_mapped |&package| {\n+        match &package {\n+            &json::Object(ref map) => {\n                 let mut has_id = false;\n \n                 match map.get(&~\"id\") {\n-                    json::String(str) => {\n+                    &json::String(str) => {\n                         if pkg.id == str {\n                             has_id = true;\n                         }\n@@ -646,14 +364,17 @@ fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n                 }\n \n                 match map.get(&~\"vers\") {\n-                    json::String(str) => {\n-                        if has_id && pkg.vers.to_str() == str { None }\n-                        else { Some(package) }\n+                    &json::String(ref str) => {\n+                        if has_id && pkg.vers.to_str() == *str {\n+                            None\n+                        } else {\n+                            Some(copy package)\n+                        }\n                     }\n-                    _ => { Some(package) }\n+                    _ => { Some(copy package) }\n                 }\n             }\n-            _ => { Some(package) }\n+            _ => { Some(copy package) }\n         }\n     }\n }\n@@ -722,7 +443,7 @@ pub fn get_pkg(id: ~str,\n         match package {\n             json::Object(map) => {\n                 let pid = match map.get(&~\"id\") {\n-                    json::String(str) => str,\n+                    &json::String(str) => str,\n                     _ => loop\n                 };\n                 let pname = match parse_name(pid) {\n@@ -734,12 +455,12 @@ pub fn get_pkg(id: ~str,\n                     }\n                 };\n                 let pvers = match map.get(&~\"vers\") {\n-                    json::String(str) => str,\n+                    &json::String(str) => str,\n                     _ => loop\n                 };\n                 if pid == id || pname == name {\n                     let bins = match map.get(&~\"bins\") {\n-                        json::List(list) => {\n+                        &json::List(ref list) => {\n                             do list.map |&bin| {\n                                 match bin {\n                                     json::String(str) => str,\n@@ -750,7 +471,7 @@ pub fn get_pkg(id: ~str,\n                         _ => ~[]\n                     };\n                     let libs = match map.get(&~\"libs\") {\n-                        json::List(list) => {\n+                        &json::List(ref list) => {\n                             do list.map |&lib| {\n                                 match lib {\n                                     json::String(str) => str,\n@@ -916,7 +637,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n \n         for mis.each |a| {\n             match a.node {\n-                ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+                ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n                                          span: _}) => {\n                     match v {\n                         ~\"name\" => name = Some(*s),\n@@ -934,7 +655,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n \n     for crate.node.attrs.each |a| {\n         match a.node.value.node {\n-            ast::meta_name_value(v, ast::spanned {node: ast::lit_str(s),\n+            ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n                                      span: _}) => {\n                 match v {\n                     ~\"crate_type\" => crate_type = Some(*s),\n@@ -1051,11 +772,13 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n-pub fn link_exe(src: &Path, dest: &Path) -> bool unsafe {\n-    do str::as_c_str(src.to_str()) |src_buf| {\n-        do str::as_c_str(dest.to_str()) |dest_buf| {\n-            libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n-            libc::chmod(dest_buf, 755) == 0 as libc::c_int\n+pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    unsafe {\n+        do str::as_c_str(src.to_str()) |src_buf| {\n+            do str::as_c_str(dest.to_str()) |dest_buf| {\n+                libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n+                    libc::chmod(dest_buf, 755) == 0 as libc::c_int\n+            }\n         }\n     }\n }"}, {"sha": "97c60330a7e31d60f290e73ec0a4340678074b03", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 238, "deletions": 126, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585d6f7b00eab09099504924e70837966f5fe678/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=585d6f7b00eab09099504924e70837966f5fe678", "patch": "@@ -19,169 +19,220 @@ use to_str::ToStr;\n use char;\n use core::cmp;\n \n+#[deriving_eq]\n+pub enum Identifier {\n+    Numeric(uint),\n+    AlphaNumeric(~str)\n+}\n+\n+impl cmp::Ord for Identifier {\n+    #[inline(always)]\n+    pure fn lt(&self, other: &Identifier) -> bool {\n+        match (self, other) {\n+            (&Numeric(a), &Numeric(b)) => a < b,\n+            (&Numeric(_), _) => true,\n+            (&AlphaNumeric(ref a), &AlphaNumeric(ref b)) => *a < *b,\n+            (&AlphaNumeric(_), _) => false\n+        }\n+    }\n+    #[inline(always)]\n+    pure fn le(&self, other: &Identifier) -> bool {\n+        ! (other < self)\n+    }\n+    #[inline(always)]\n+    pure fn gt(&self, other: &Identifier) -> bool {\n+        other < self\n+    }\n+    #[inline(always)]\n+    pure fn ge(&self, other: &Identifier) -> bool {\n+        ! (self < other)\n+    }\n+}\n+\n+impl ToStr for Identifier {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        match self {\n+            &Numeric(n) => n.to_str(),\n+            &AlphaNumeric(ref s) => s.to_str()\n+        }\n+    }\n+}\n+\n+\n+#[deriving_eq]\n pub struct Version {\n     major: uint,\n     minor: uint,\n     patch: uint,\n-    tag: Option<~str>,\n+    pre: ~[Identifier],\n+    build: ~[Identifier],\n }\n \n-impl Version: ToStr {\n+impl ToStr for Version {\n     #[inline(always)]\n-    pure fn to_str() -> ~str {\n-        let suffix = match copy self.tag {\n-            Some(tag) => ~\"-\" + tag,\n-            None => ~\"\"\n+    pure fn to_str(&self) -> ~str {\n+        let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n+        let s = if self.pre.is_empty() {\n+            s\n+        } else {\n+            s + \"-\" + str::connect(self.pre.map(|i| i.to_str()), \".\")\n         };\n-\n-        fmt!(\"%u.%u.%u%s\", self.major, self.minor, self.patch, suffix)\n+        if self.build.is_empty() {\n+            s\n+        } else {\n+            s + \"+\" + str::connect(self.build.map(|i| i.to_str()), \".\")\n+        }\n     }\n }\n \n-impl Version: cmp::Ord {\n+impl cmp::Ord for Version {\n     #[inline(always)]\n     pure fn lt(&self, other: &Version) -> bool {\n+\n         self.major < other.major ||\n-        self.minor < other.minor ||\n-        self.patch < other.patch ||\n-        (match self.tag {\n-            Some(stag) => match other.tag {\n-                Some(otag) => stag < otag,\n-                None => true\n-            },\n-            None => false\n-        })\n+\n+            (self.major == other.major &&\n+             self.minor < other.minor) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch < other.patch) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch == other.patch &&\n+             // NB: semver spec says 0.0.0-pre < 0.0.0\n+             // but the version of ord defined for vec\n+             // says that [] < [pre], so we alter it\n+             // here.\n+             (match (self.pre.len(), other.pre.len()) {\n+                 (0, 0) => false,\n+                 (0, _) => false,\n+                 (_, 0) => true,\n+                 (_, _) => self.pre < other.pre\n+             })) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch == other.patch &&\n+             self.pre == other.pre &&\n+             self.build < other.build)\n     }\n+\n     #[inline(always)]\n     pure fn le(&self, other: &Version) -> bool {\n-        self.major <= other.major ||\n-        self.minor <= other.minor ||\n-        self.patch <= other.patch ||\n-        (match self.tag {\n-            Some(stag) => match other.tag {\n-                Some(otag) => stag <= otag,\n-                None => true\n-            },\n-            None => false\n-        })\n+        ! (other < self)\n     }\n     #[inline(always)]\n     pure fn gt(&self, other: &Version) -> bool {\n-        self.major > other.major ||\n-        self.minor > other.minor ||\n-        self.patch > other.patch ||\n-        (match self.tag {\n-            Some(stag) => match other.tag {\n-                Some(otag) => stag > otag,\n-                None => false\n-            },\n-            None => true\n-        })\n+        other < self\n     }\n     #[inline(always)]\n     pure fn ge(&self, other: &Version) -> bool {\n-        self.major >= other.major ||\n-        self.minor >= other.minor ||\n-        self.patch >= other.patch ||\n-        (match self.tag {\n-            Some(stag) => match other.tag {\n-                Some(otag) => stag >= otag,\n-                None => false\n-            },\n-            None => true\n-        })\n+        ! (self < other)\n     }\n }\n \n-fn read_whitespace(rdr: io::Reader, ch: char) -> char {\n-    let mut nch = ch;\n+condition! {\n+    bad_parse: () -> ();\n+}\n \n-    while char::is_whitespace(nch) {\n-        nch = rdr.read_char();\n+fn take_nonempty_prefix(rdr: io::Reader,\n+                        ch: char,\n+                        pred: fn(char) -> bool) -> (~str, char) {\n+    let mut buf = ~\"\";\n+    let mut ch = ch;\n+    while pred(ch) {\n+        str::push_char(&mut buf, ch);\n+        ch = rdr.read_char();\n     }\n-\n-    nch\n+    if buf.is_empty() {\n+        bad_parse::cond.raise(())\n+    }\n+    debug!(\"extracted nonempty prefix: %s\", buf);\n+    (buf, ch)\n }\n \n-fn parse_reader(rdr: io::Reader) -> Option<(Version, char)> {\n-    fn read_digits(rdr: io::Reader, ch: char) -> Option<(uint, char)> {\n-        let mut buf = ~\"\";\n-        let mut nch = ch;\n-\n-        while nch != -1 as char {\n-            match nch {\n-              '0' .. '9' => buf += str::from_char(nch),\n-              _ => break\n-            }\n+fn take_num(rdr: io::Reader, ch: char) -> (uint, char) {\n+    let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n+    match uint::from_str(s) {\n+        None => { bad_parse::cond.raise(()); (0, ch) },\n+        Some(i) => (i, ch)\n+    }\n+}\n \n-            nch = rdr.read_char();\n+fn take_ident(rdr: io::Reader, ch: char) -> (Identifier, char) {\n+    let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n+    if s.all(char::is_digit) {\n+        match uint::from_str(s) {\n+            None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n+            Some(i) => (Numeric(i), ch)\n         }\n+    } else {\n+        (AlphaNumeric(s), ch)\n+    }\n+}\n \n-        do uint::from_str(buf).chain_ref |&i| {\n-            Some((i, nch))\n-        }\n+fn expect(ch: char, c: char) {\n+    if ch != c {\n+        bad_parse::cond.raise(())\n     }\n+}\n \n-    fn read_tag(rdr: io::Reader) -> Option<(~str, char)> {\n-        let mut ch = rdr.read_char();\n-        let mut buf = ~\"\";\n+fn parse_reader(rdr: io::Reader) -> Version {\n \n-        while ch != -1 as char {\n-            match ch {\n-                '0' .. '9' | 'A' .. 'Z' | 'a' .. 'z' | '-' => {\n-                    buf += str::from_char(ch);\n-                }\n-                _ => break\n-            }\n+    let (major, ch) = take_num(rdr, rdr.read_char());\n+    expect(ch, '.');\n+    let (minor, ch) = take_num(rdr, rdr.read_char());\n+    expect(ch, '.');\n+    let (patch, ch) = take_num(rdr, rdr.read_char());\n \n-            ch = rdr.read_char();\n-        }\n+    let mut pre = ~[];\n+    let mut build = ~[];\n \n-        if buf == ~\"\" { return None; }\n-        else { Some((buf, ch)) }\n+    let mut ch = ch;\n+    if ch == '-' {\n+        loop {\n+            let (id, c) = take_ident(rdr, rdr.read_char());\n+            pre.push(id);\n+            ch = c;\n+            if ch != '.' { break; }\n+        }\n     }\n \n-    let ch = read_whitespace(rdr, rdr.read_char());\n-    let (major, ch) = match read_digits(rdr, ch) {\n-        None => return None,\n-        Some(item) => item\n-    };\n-\n-    if ch != '.' { return None; }\n-\n-    let (minor, ch) = match read_digits(rdr, rdr.read_char()) {\n-        None => return None,\n-        Some(item) => item\n-    };\n-\n-    if ch != '.' { return None; }\n-\n-    let (patch, ch) = match read_digits(rdr, rdr.read_char()) {\n-        None => return None,\n-        Some(item) => item\n-    };\n-    let (tag, ch) = if ch == '-' {\n-        match read_tag(rdr) {\n-            None => return None,\n-            Some((tag, ch)) => (Some(tag), ch)\n+    if ch == '+' {\n+        loop {\n+            let (id, c) = take_ident(rdr, rdr.read_char());\n+            build.push(id);\n+            ch = c;\n+            if ch != '.' { break; }\n         }\n-    } else {\n-        (None, ch)\n-    };\n+    }\n \n-    Some((Version { major: major, minor: minor, patch: patch, tag: tag },\n-          ch))\n+    Version {\n+        major: major,\n+        minor: minor,\n+        patch: patch,\n+        pre: pre,\n+        build: build,\n+    }\n }\n \n-pub fn parse(s: &str) -> Option<Version> {\n-    do io::with_str_reader(s) |rdr| {\n-        do parse_reader(rdr).chain_ref |&item| {\n-            let (version, ch) = item;\n \n-            if read_whitespace(rdr, ch) != -1 as char {\n+pub fn parse(s: &str) -> Option<Version> {\n+    if ! str::is_ascii(s) {\n+        return None;\n+    }\n+    let s = s.trim();\n+    let mut bad = false;\n+    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).in {\n+        do io::with_str_reader(s) |rdr| {\n+            let v = parse_reader(rdr);\n+            if bad || v.to_str() != s {\n                 None\n             } else {\n-                Some(version)\n+                Some(v)\n             }\n         }\n     }\n@@ -204,26 +255,68 @@ fn test_parse() {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        tag: None,\n+        pre: ~[],\n+        build: ~[],\n     });\n     assert parse(\"  1.2.3  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        tag: None,\n+        pre: ~[],\n+        build: ~[],\n     });\n     assert parse(\"1.2.3-alpha1\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        tag: Some(\"alpha1\")\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[]\n     });\n     assert parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n-        tag: Some(\"alpha1\")\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[]\n     });\n+    assert parse(\"1.2.3+build5\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"  1.2.3+build5  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"1.2.3-alpha1+build5\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[Numeric(1),AlphaNumeric(~\"alpha1\"),Numeric(9)],\n+        build: ~[AlphaNumeric(~\"build5\"),\n+                 Numeric(7),\n+                 AlphaNumeric(~\"3aedf\")]\n+    });\n+\n }\n \n #[test]\n@@ -245,9 +338,8 @@ fn test_lt() {\n     assert parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\");\n     assert parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\");\n     assert parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.3\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3\");\n     assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\");\n-\n     assert !(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\"));\n }\n \n@@ -256,7 +348,6 @@ fn test_le() {\n     assert parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\");\n     assert parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\");\n     assert parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.3\")        <= parse(\"1.2.3-alpha2\");\n     assert parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\");\n     assert parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\");\n }\n@@ -266,9 +357,8 @@ fn test_gt() {\n     assert parse(\"1.2.3-alpha2\") > parse(\"0.0.0\");\n     assert parse(\"1.2.3-alpha2\") > parse(\"1.0.0\");\n     assert parse(\"1.2.3-alpha2\") > parse(\"1.2.0\");\n-    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3\");\n     assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\");\n-\n+    assert parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\");\n     assert !(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\"));\n }\n \n@@ -277,7 +367,29 @@ fn test_ge() {\n     assert parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\");\n     assert parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\");\n     assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\");\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3\");\n     assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\");\n     assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\");\n }\n+\n+#[test]\n+fn test_spec_order() {\n+\n+    let vs = [\"1.0.0-alpha\",\n+              \"1.0.0-alpha.1\",\n+              \"1.0.0-beta.2\",\n+              \"1.0.0-beta.11\",\n+              \"1.0.0-rc.1\",\n+              \"1.0.0-rc.1+build.1\",\n+              \"1.0.0\",\n+              \"1.0.0+0.3.7\",\n+              \"1.3.7+build\",\n+              \"1.3.7+build.2.b8f12d7\",\n+              \"1.3.7+build.11.e0f985a\"];\n+    let mut i = 1;\n+    while i < vs.len() {\n+        let a = parse(vs[i-1]).get();\n+        let b = parse(vs[i]).get();\n+        assert a < b;\n+        i += 1;\n+    }\n+}\n\\ No newline at end of file"}]}