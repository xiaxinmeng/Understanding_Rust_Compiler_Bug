{"sha": "c0956ff265d0459e6f643f5454a8560e5dc2712c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOTU2ZmYyNjVkMDQ1OWU2ZjY0M2Y1NDU0YTg1NjBlNWRjMjcxMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T07:50:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T07:50:18Z"}, "message": "Auto merge of #45319 - michaelwoerister:use-128bit-siphash, r=nikomatsakis\n\nincr.comp.: Use 128bit SipHash for fingerprinting\n\nThis PR switches incr. comp. result fingerprinting from 128 bit BLAKE2 to 128 bit SipHash. When we started using BLAKE2 for fingerprinting, the 128 bit version of SipHash was still experimental. Now that it isn't anymore we should be able to get a nice performance boost without significantly increasing collision probability.\n\n~~I'm going to start a try-build for this, so we can gauge the performance impact before merging (hence the `WIP` in the title).~~\n\nEDIT: Performance improvements look as expected. Tests seem to be passing.\n\nFixes #41215.", "tree": {"sha": "7073eb90ca95161c9d503f7567bcfbe1cfe4f8ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7073eb90ca95161c9d503f7567bcfbe1cfe4f8ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0956ff265d0459e6f643f5454a8560e5dc2712c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0956ff265d0459e6f643f5454a8560e5dc2712c", "html_url": "https://github.com/rust-lang/rust/commit/c0956ff265d0459e6f643f5454a8560e5dc2712c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0956ff265d0459e6f643f5454a8560e5dc2712c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e0a38101e750737e431b894167a8202ca8f46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e0a38101e750737e431b894167a8202ca8f46c", "html_url": "https://github.com/rust-lang/rust/commit/c0e0a38101e750737e431b894167a8202ca8f46c"}, {"sha": "27b6c9174d15872ec708d278ec98bcd9eb8fe0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/27b6c9174d15872ec708d278ec98bcd9eb8fe0ef", "html_url": "https://github.com/rust-lang/rust/commit/27b6c9174d15872ec708d278ec98bcd9eb8fe0ef"}], "stats": {"total": 674, "additions": 591, "deletions": 83}, "files": [{"sha": "d82de082da6d0d84cc4cd76b32bf08658bbe8a49", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -72,6 +72,7 @@ struct Hasher<S: Sip> {\n }\n \n #[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n struct State {\n     // v0, v2 and v1, v3 show up in pairs in the algorithm,\n     // and simd implementations of SipHash will use vectors"}, {"sha": "f3bb3b385667ed041d768cf584e49eb0007dc620", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::stable_hasher;\n-use std::mem;\n-use std::slice;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct Fingerprint(u64, u64);\n@@ -54,16 +52,9 @@ impl ::std::fmt::Display for Fingerprint {\n }\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n-    fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-\n-        assert!(hash_bytes.len() >= mem::size_of::<u64>() * 2);\n-        let hash_bytes: &[u64] = unsafe {\n-            slice::from_raw_parts(hash_bytes.as_ptr() as *const u64, 2)\n-        };\n-\n-        // The bytes returned bytes the Blake2B hasher are always little-endian.\n-        Fingerprint(u64::from_le(hash_bytes[0]), u64::from_le(hash_bytes[1]))\n+    fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        Fingerprint(_0, _1)\n     }\n }\n "}, {"sha": "3a20343033c233af91d976973b83e54e0b8ca37c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -28,6 +28,7 @@\n #![feature(fn_traits)]\n #![feature(unsize)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(conservative_impl_trait)]\n #![feature(specialization)]\n \n@@ -54,6 +55,7 @@ pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n+pub mod sip128;\n pub mod snapshot_map;\n pub mod snapshot_vec;\n pub mod stable_hasher;"}, {"sha": "1f0b0d9cbfb0b54f9c9a6af05aa598805b1c736a", "filename": "src/librustc_data_structures/sip128.rs", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -0,0 +1,533 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is a copy of `core::hash::sip` adapted to providing 128 bit hashes.\n+\n+use std::cmp;\n+use std::hash::Hasher;\n+use std::slice;\n+use std::ptr;\n+use std::mem;\n+\n+#[derive(Debug, Clone)]\n+pub struct SipHasher128 {\n+    k0: u64,\n+    k1: u64,\n+    length: usize, // how many bytes we've processed\n+    state: State, // hash State\n+    tail: u64, // unprocessed bytes le\n+    ntail: usize, // how many bytes in tail are valid\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n+struct State {\n+    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n+    // and simd implementations of SipHash will use vectors\n+    // of v02 and v13. By placing them in this order in the struct,\n+    // the compiler can pick up on just a few simd optimizations by itself.\n+    v0: u64,\n+    v2: u64,\n+    v1: u64,\n+    v3: u64,\n+}\n+\n+macro_rules! compress {\n+    ($state:expr) => ({\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    });\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n+    });\n+}\n+\n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n+    ({\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n+    });\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n+\n+impl SipHasher128 {\n+    #[inline]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher128 {\n+        let mut state = SipHasher128 {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            state: State {\n+                v0: 0,\n+                v1: 0,\n+                v2: 0,\n+                v3: 0,\n+            },\n+            tail: 0,\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n+\n+    #[inline]\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.state.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+\n+        // This is only done in the 128 bit version:\n+        self.state.v1 ^= 0xee;\n+    }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n+\n+    #[inline(always)]\n+    fn short_write_gen<T>(&mut self, x: T) {\n+        let bytes = unsafe {\n+            slice::from_raw_parts(&x as *const T as *const u8, mem::size_of::<T>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    #[inline]\n+    pub fn finish128(mut self) -> (u64, u64) {\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n+\n+        self.state.v3 ^= b;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= b;\n+\n+        self.state.v2 ^= 0xee;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _0 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+\n+        self.state.v1 ^= 0xdd;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _1 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+        (_0, _1)\n+    }\n+}\n+\n+impl Hasher for SipHasher128 {\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, i: i8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i16(&mut self, i: i16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i32(&mut self, i: i32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i64(&mut self, i: i64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_isize(&mut self, i: isize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let mut needed = 0;\n+\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n+            if length < needed {\n+                self.ntail += length;\n+                return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                Sip24Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n+            }\n+        }\n+\n+        // Buffered tail is now flushed, process new input.\n+        let len = length - needed;\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < len - left {\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n+\n+            self.state.v3 ^= mi;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.ntail = left;\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        panic!(\"SipHasher128 cannot provide valid 64 bit hashes\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct Sip24Rounds;\n+\n+impl Sip24Rounds {\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::hash::{Hash, Hasher};\n+    use std::{slice, mem};\n+    use super::SipHasher128;\n+\n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'a>(&'a [u8]);\n+\n+    impl<'a> Hash for Bytes<'a> {\n+        #[allow(unused_must_use)]\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            for byte in self.0 {\n+                state.write_u8(*byte);\n+            }\n+        }\n+    }\n+\n+    fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n+        x.hash(&mut st);\n+        st.finish128()\n+    }\n+\n+    fn hash<T: Hash>(x: &T) -> (u64, u64) {\n+        hash_with(SipHasher128::new_with_keys(0, 0), x)\n+    }\n+\n+    const TEST_VECTOR : [[u8; 16]; 64] = [\n+        [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n+        [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n+        [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n+        [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n+        [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n+        [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n+        [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n+        [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n+        [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n+        [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n+        [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n+        [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n+        [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n+        [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n+        [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n+        [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n+        [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n+        [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n+        [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n+        [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n+        [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n+        [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n+        [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n+        [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n+        [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n+        [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n+        [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n+        [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n+        [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n+        [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n+        [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n+        [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n+        [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n+        [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n+        [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n+        [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n+        [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n+        [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n+        [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n+        [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n+        [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n+        [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n+        [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n+        [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n+        [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n+        [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n+        [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n+        [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n+        [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n+        [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n+        [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n+        [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n+        [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n+        [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n+        [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n+        [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n+        [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n+        [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n+        [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n+        [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n+        [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n+        [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n+        [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n+        [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n+    ];\n+\n+    // Test vector from reference implementation\n+    #[test]\n+    fn test_siphash_2_4_test_vector() {\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+\n+        let mut input: Vec<u8> = Vec::new();\n+\n+        for i in 0 .. 64 {\n+            let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n+                                &Bytes(&input[..]));\n+            let expected = (\n+                ((TEST_VECTOR[i][0] as u64) <<  0) |\n+                ((TEST_VECTOR[i][1] as u64) <<  8) |\n+                ((TEST_VECTOR[i][2] as u64) << 16) |\n+                ((TEST_VECTOR[i][3] as u64) << 24) |\n+                ((TEST_VECTOR[i][4] as u64) << 32) |\n+                ((TEST_VECTOR[i][5] as u64) << 40) |\n+                ((TEST_VECTOR[i][6] as u64) << 48) |\n+                ((TEST_VECTOR[i][7] as u64) << 56),\n+\n+                ((TEST_VECTOR[i][8] as u64) <<  0) |\n+                ((TEST_VECTOR[i][9] as u64) <<  8) |\n+                ((TEST_VECTOR[i][10] as u64) << 16) |\n+                ((TEST_VECTOR[i][11] as u64) << 24) |\n+                ((TEST_VECTOR[i][12] as u64) << 32) |\n+                ((TEST_VECTOR[i][13] as u64) << 40) |\n+                ((TEST_VECTOR[i][14] as u64) << 48) |\n+                ((TEST_VECTOR[i][15] as u64) << 56),\n+            );\n+\n+            assert_eq!(out, expected);\n+            input.push(i as u8);\n+        }\n+    }\n+\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+        assert!(hash(&(val as u32)) != hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&val64), hash(&val64));\n+        let val32 = 0xdeadbeef_u32;\n+        assert_eq!(hash(&val32), hash(&val32));\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+        fn zero_byte(val: u64, byte: usize) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+        fn zero_byte(val: u32, byte: usize) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_concat_alias() {\n+        let s = (\"aa\", \"bb\");\n+        let t = (\"aabb\", \"\");\n+        let u = (\"a\", \"abb\");\n+\n+        assert!(s != t && t != u);\n+        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+        let u = [1, 0, 0, 0];\n+        let v = (&u[..1], &u[1..3], &u[3..]);\n+        let w = (&u[..], &u[4..4], &u[4..4]);\n+\n+        assert!(v != w);\n+        assert!(hash(&v) != hash(&w));\n+    }\n+\n+    #[test]\n+    fn test_write_short_works() {\n+        let test_usize = 0xd0c0b0a0usize;\n+        let mut h1 = SipHasher128::new_with_keys(0, 0);\n+        h1.write_usize(test_usize);\n+        h1.write(b\"bytes\");\n+        h1.write(b\"string\");\n+        h1.write_u8(0xFFu8);\n+        h1.write_u8(0x01u8);\n+        let mut h2 = SipHasher128::new_with_keys(0, 0);\n+        h2.write(unsafe {\n+            slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                                  mem::size_of::<usize>())\n+        });\n+        h2.write(b\"bytes\");\n+        h2.write(b\"string\");\n+        h2.write(&[0xFFu8, 0x01u8]);\n+        assert_eq!(h1.finish128(), h2.finish128());\n+    }\n+\n+}"}, {"sha": "831e113016fd903728c5fe3a8c54301dea745f43", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 39, "deletions": 57, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -11,16 +11,7 @@\n use std::hash::{Hash, Hasher, BuildHasher};\n use std::marker::PhantomData;\n use std::mem;\n-use blake2b::Blake2bHasher;\n-use rustc_serialize::leb128;\n-\n-fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n-    leb128::write_unsigned_leb128_to(value as u128, |i, v| buf[i] = v)\n-}\n-\n-fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n-    leb128::write_signed_leb128_to(value as i128, |i, v| buf[i] = v)\n-}\n+use sip128::SipHasher128;\n \n /// When hashing something that ends up affecting properties like symbol names. We\n /// want these symbol names to be calculated independent of other factors like\n@@ -41,7 +32,7 @@ fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n /// and allows for variable output lengths through its type\n /// parameter.\n pub struct StableHasher<W> {\n-    state: Blake2bHasher,\n+    state: SipHasher128,\n     bytes_hashed: u64,\n     width: PhantomData<W>,\n }\n@@ -59,7 +50,7 @@ pub trait StableHasherResult: Sized {\n impl<W: StableHasherResult> StableHasher<W> {\n     pub fn new() -> Self {\n         StableHasher {\n-            state: Blake2bHasher::new(mem::size_of::<W>(), &[]),\n+            state: SipHasher128::new_with_keys(0, 0),\n             bytes_hashed: 0,\n             width: PhantomData,\n         }\n@@ -70,66 +61,37 @@ impl<W: StableHasherResult> StableHasher<W> {\n     }\n }\n \n-impl StableHasherResult for [u8; 20] {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let mut result: [u8; 20] = [0; 20];\n-        result.copy_from_slice(hasher.state.finalize());\n-        result\n-    }\n-}\n-\n impl StableHasherResult for u128 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-        assert!(hash_bytes.len() >= mem::size_of::<u128>());\n-\n-        unsafe {\n-            ::std::ptr::read_unaligned(hash_bytes.as_ptr() as *const u128)\n-        }\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        (_0 as u128) | ((_1 as u128) << 64)\n     }\n }\n \n impl StableHasherResult for u64 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        hasher.state.finalize();\n-        hasher.state.finish()\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        hasher.finalize().0\n     }\n }\n \n impl<W> StableHasher<W> {\n     #[inline]\n-    pub fn finalize(&mut self) -> &[u8] {\n-        self.state.finalize()\n+    pub fn finalize(self) -> (u64, u64) {\n+        self.state.finish128()\n     }\n \n     #[inline]\n     pub fn bytes_hashed(&self) -> u64 {\n         self.bytes_hashed\n     }\n-\n-    #[inline]\n-    fn write_uleb128(&mut self, value: u64) {\n-        let mut buf = [0; 16];\n-        let len = write_unsigned_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n-\n-    #[inline]\n-    fn write_ileb128(&mut self, value: i64) {\n-        let mut buf = [0; 16];\n-        let len = write_signed_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n }\n \n // For the non-u8 integer cases we leb128 encode them first. Because small\n // integers dominate, this significantly and cheaply reduces the number of\n // bytes hashed, which is good because blake2b is expensive.\n impl<W> Hasher for StableHasher<W> {\n     fn finish(&self) -> u64 {\n-        panic!(\"use StableHasher::finish instead\");\n+        panic!(\"use StableHasher::finalize instead\");\n     }\n \n     #[inline]\n@@ -146,22 +108,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.write_uleb128(i);\n+        self.state.write_u64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_u128(&mut self, i: u128) {\n+        self.state.write_u128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_usize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<usize>() as u64;\n     }\n \n     #[inline]\n@@ -172,22 +144,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.write_ileb128(i);\n+        self.state.write_i64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_i128(&mut self, i: i128) {\n+        self.state.write_i128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_isize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<isize>() as u64;\n     }\n }\n "}, {"sha": "201d786776455483562ae6dd23976c3d0b3edf3e", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::ToHex;\n+use rustc::ich::Fingerprint;\n use {type_of, machine, monomorphize};\n use common::{self, CrateContext};\n use type_::Type;\n@@ -146,11 +146,10 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-\n-        let mut type_id_hasher = TypeIdHasher::<[u8; 20]>::new(cx.tcx());\n+        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx());\n         type_id_hasher.visit_ty(type_);\n-\n         let unique_type_id = type_id_hasher.finish().to_hex();\n+\n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n "}, {"sha": "22788d7a8985ef32b70a9fe416dccdb7f3f4a186", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -30,7 +30,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node12.EraseRegions.after.mir\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[8cd8]::{{impl}}[0]::foo[0] }, BrAnon(0)) Test, _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[8cd8]::{{impl}}[0]::foo[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[e36f]::{{impl}}[0]::foo[0] }, BrAnon(0)) Test, _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[e36f]::{{impl}}[0]::foo[0] }, BrAnon(1)) mut i32]);\n //         ...\n //         return;\n //     }\n@@ -62,7 +62,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[e36f]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[e36f]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);"}, {"sha": "d2852cf52261842c4ae865224559d094c8ae5c0d", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -51,8 +51,8 @@ fn main() {\n // fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(22)], _2: *mut i32) -> () {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[e36f]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[e36f]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         (*_3) = const 23i32;\n@@ -65,8 +65,8 @@ fn main() {\n // fn test(_1: &ReErased mut i32) -> () {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[e36f]::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[e36f]::test[0] }, BrAnon(0)) mut i32]);\n //         ...\n //         _3 = const write_42(_4) -> bb1;\n //     }\n@@ -81,8 +81,8 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[e36f]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[e36f]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[e36f]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[e36f]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         ...\n //         _0 = const write_42(_4) -> bb1;"}, {"sha": "98c553d6b35af1d7ec941df0ea3bbbd8f8ab2999", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0956ff265d0459e6f643f5454a8560e5dc2712c/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=c0956ff265d0459e6f643f5454a8560e5dc2712c", "patch": "@@ -37,7 +37,7 @@ fn main() {\n // fn test(_1: &ReErased mut i32) -> () {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_5[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_5[e36f]::test[0] }, BrAnon(0)) mut i32]);\n //         ...\n //         Validate(Release, [_3: bool, _4: *mut i32]);\n //         _3 = const write_42(_4) -> bb1;\n@@ -49,7 +49,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[e36f]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[e36f]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);"}]}