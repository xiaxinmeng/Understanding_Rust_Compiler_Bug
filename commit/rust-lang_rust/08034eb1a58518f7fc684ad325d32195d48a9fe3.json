{"sha": "08034eb1a58518f7fc684ad325d32195d48a9fe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MDM0ZWIxYTU4NTE4ZjdmYzY4NGFkMzI1ZDMyMTk1ZDQ4YTlmZTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-21T09:10:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:41:25Z"}, "message": "add `Issue32330` warning marker to bound regions\n\nThis indicates whether this `BoundRegion` will change from late to early\nbound when issue 32330 is fixed. It also indicates the function on\nwhich the lifetime is declared.", "tree": {"sha": "0b4ed78228e5930120e7ce06800732c50a5e0c58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b4ed78228e5930120e7ce06800732c50a5e0c58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08034eb1a58518f7fc684ad325d32195d48a9fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08034eb1a58518f7fc684ad325d32195d48a9fe3", "html_url": "https://github.com/rust-lang/rust/commit/08034eb1a58518f7fc684ad325d32195d48a9fe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08034eb1a58518f7fc684ad325d32195d48a9fe3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "html_url": "https://github.com/rust-lang/rust/commit/11984340bfe93be311eeea9881ae2d1fb8fb0ddb"}], "stats": {"total": 483, "additions": 313, "deletions": 170}, "files": [{"sha": "d47de676e796032f581973190125cfbc9fc57437", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -132,6 +132,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_generics(&mut self, g: &'v Generics) {\n         walk_generics(self, g)\n     }\n+    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n+        walk_where_predicate(self, predicate)\n+    }\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n@@ -529,29 +532,34 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n         walk_list!(visitor, visit_ty, &param.default);\n     }\n     walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n-    for predicate in &generics.where_clause.predicates {\n-        match predicate {\n-            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n-                                                                          ref bounds,\n-                                                                          ref bound_lifetimes,\n-                                                                          ..}) => {\n-                visitor.visit_ty(bounded_ty);\n-                walk_list!(visitor, visit_ty_param_bound, bounds);\n-                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n-            }\n-            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n-                                                                            ref bounds,\n-                                                                            ..}) => {\n-                visitor.visit_lifetime(lifetime);\n-                walk_list!(visitor, visit_lifetime, bounds);\n-            }\n-            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n-                                                                    ref path,\n-                                                                    ref ty,\n-                                                                    ..}) => {\n-                visitor.visit_path(path, id);\n-                visitor.visit_ty(ty);\n-            }\n+    walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n+}\n+\n+pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    predicate: &'v WherePredicate)\n+{\n+    match predicate {\n+        &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n+                                                            ref bounds,\n+                                                            ref bound_lifetimes,\n+                                                            ..}) => {\n+            visitor.visit_ty(bounded_ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n+        }\n+        &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n+                                                              ref bounds,\n+                                                              ..}) => {\n+            visitor.visit_lifetime(lifetime);\n+            walk_list!(visitor, visit_lifetime, bounds);\n+        }\n+        &WherePredicate::EqPredicate(WhereEqPredicate{id,\n+                                                      ref path,\n+                                                      ref ty,\n+                                                      ..}) => {\n+            visitor.visit_path(path, id);\n+            visitor.visit_ty(ty);\n         }\n     }\n }"}, {"sha": "804a0cd400c5114699bdca5bc36edd885c4da725", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -1140,7 +1140,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 ty::BrAnon(i) => {\n                     anon_nums.insert(i);\n                 }\n-                ty::BrNamed(_, name) => {\n+                ty::BrNamed(_, name, _) => {\n                     region_names.insert(name);\n                 }\n                 _ => ()\n@@ -1154,7 +1154,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         for sr in self.same_regions {\n             for br in &sr.regions {\n                 match *br {\n-                    ty::BrNamed(_, name) => {\n+                    ty::BrNamed(_, name, _) => {\n                         all_region_names.insert(name);\n                     }\n                     _ => ()"}, {"sha": "4dac47ea6c3f7a1de99662565b196a72a664189f", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -13,14 +13,12 @@\n \n use super::{CombinedSnapshot,\n             InferCtxt,\n-            LateBoundRegion,\n             HigherRankedType,\n             SubregionOrigin,\n             SkolemizationMap};\n use super::combine::CombineFields;\n use super::region_inference::{TaintDirections};\n \n-use infer::error_reporting;\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};"}, {"sha": "dcc84fb04399fa5ed812a5e9ca1735b468ed2185", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 179, "deletions": 110, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -22,6 +22,7 @@ use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n use hir::def::{Def, DefMap};\n+use hir::def_id::DefId;\n use middle::region;\n use ty::subst;\n use ty;\n@@ -32,6 +33,7 @@ use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n use util::nodemap::NodeMap;\n \n+use rustc_data_structures::fnv::FnvHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind};\n@@ -50,11 +52,21 @@ pub enum DefRegion {\n \n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n-pub type NamedRegionMap = NodeMap<DefRegion>;\n+pub struct NamedRegionMap {\n+    // maps from every use of a named (not anonymous) lifetime to a\n+    // `DefRegion` describing how that region is bound\n+    pub defs: NodeMap<DefRegion>,\n+\n+    // the set of lifetime def ids that are late-bound; late-bound ids\n+    // are named regions appearing in fn arguments that do not appear\n+    // in where-clauses\n+    pub late_bound: NodeMap<ty::Issue32330>,\n+}\n \n-struct LifetimeContext<'a> {\n+struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n-    named_region_map: &'a mut NamedRegionMap,\n+    hir_map: &'a Map<'tcx>,\n+    map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n     def_map: &'a DefMap,\n     // Deep breath. Our representation for poly trait refs contains a single\n@@ -101,21 +113,25 @@ pub fn krate(sess: &Session,\n              -> Result<NamedRegionMap, usize> {\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n-    let mut named_region_map = NodeMap();\n+    let mut map = NamedRegionMap {\n+        defs: NodeMap(),\n+        late_bound: NodeMap(),\n+    };\n     sess.track_errors(|| {\n         krate.visit_all_items(&mut LifetimeContext {\n             sess: sess,\n-            named_region_map: &mut named_region_map,\n+            hir_map: hir_map,\n+            map: &mut map,\n             scope: &ROOT_SCOPE,\n             def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         });\n     })?;\n-    Ok(named_region_map)\n+    Ok(map)\n }\n \n-impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         assert!(self.labels_in_fn.is_empty());\n \n@@ -164,8 +180,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                hir::ForeignItemFn(_, ref generics) => {\n-                    this.visit_early_late(subst::FnSpace, generics, |this| {\n+                hir::ForeignItemFn(ref decl, ref generics) => {\n+                    this.visit_early_late(item.id,\n+                                          subst::FnSpace,\n+                                          decl,\n+                                          generics,\n+                                          |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n                 }\n@@ -179,24 +199,27 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_early_late(subst::FnSpace, generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n+                self.visit_early_late(fn_id, subst::FnSpace, decl, generics, |this| {\n+                    this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n             FnKind::Method(_, sig, _, _) => {\n-                self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n-                })\n+                self.visit_early_late(\n+                    fn_id,\n+                    subst::FnSpace,\n+                    decl,\n+                    &sig.generics,\n+                    |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n             }\n             FnKind::Closure(_) => {\n                 // Closures have their own set of labels, save labels just\n                 // like for foreign items above.\n                 let saved = replace(&mut self.labels_in_fn, vec![]);\n-                let result = self.add_scope_and_walk_fn(fk, fd, b, s, fn_id);\n+                let result = self.add_scope_and_walk_fn(fk, decl, b, s, fn_id);\n                 replace(&mut self.labels_in_fn, saved);\n                 result\n             }\n@@ -240,7 +263,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n-                subst::FnSpace, &sig.generics,\n+                trait_item.id, subst::FnSpace,\n+                &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n@@ -380,8 +404,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n-\n+fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -468,7 +491,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n     }\n }\n \n-impl<'a> LifetimeContext<'a> {\n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn<'b>(&mut self,\n                                  fk: FnKind,\n                                  fd: &hir::FnDecl,\n@@ -501,10 +524,11 @@ impl<'a> LifetimeContext<'a> {\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n         F: FnOnce(Scope, &mut LifetimeContext),\n     {\n-        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n             sess: sess,\n-            named_region_map: *named_region_map,\n+            hir_map: hir_map,\n+            map: *map,\n             scope: &wrap_scope,\n             def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n@@ -534,20 +558,27 @@ impl<'a> LifetimeContext<'a> {\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n+                           fn_id: ast::NodeId,\n                            early_space: subst::ParamSpace,\n+                           decl: &hir::FnDecl,\n                            generics: &hir::Generics,\n                            walk: F) where\n         F: FnOnce(&mut LifetimeContext),\n     {\n-        let referenced_idents = early_bound_lifetime_names(generics);\n-\n-        debug!(\"visit_early_late: referenced_idents={:?}\",\n-               referenced_idents);\n-\n-        let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n-            |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n-\n-        self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {\n+        let fn_def_id = self.hir_map.local_def_id(fn_id);\n+        insert_late_bound_lifetimes(self.map,\n+                                    fn_def_id,\n+                                    decl,\n+                                    generics);\n+\n+        let (late, early): (Vec<_>, _) =\n+            generics.lifetimes\n+                    .iter()\n+                    .cloned()\n+                    .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n+\n+        let this = self;\n+        this.with(EarlyScope(early_space, &early, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -756,11 +787,12 @@ impl<'a> LifetimeContext<'a> {\n                        probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?}\",\n-                lifetime_to_string(lifetime_ref),\n-                lifetime_ref.id,\n-                def);\n-        self.named_region_map.insert(lifetime_ref.id, def);\n+        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?} span={:?}\",\n+               lifetime_to_string(lifetime_ref),\n+               lifetime_ref.id,\n+               def,\n+               self.sess.codemap().span_to_string(lifetime_ref.span));\n+        self.map.defs.insert(lifetime_ref.id, def);\n     }\n }\n \n@@ -777,95 +809,132 @@ fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn early_bound_lifetimes<'a>(generics: &'a hir::Generics) -> Vec<hir::LifetimeDef> {\n-    let referenced_idents = early_bound_lifetime_names(generics);\n-    if referenced_idents.is_empty() {\n-        return Vec::new();\n+/// Detects late-bound lifetimes and inserts them into\n+/// `map.late_bound`.\n+///\n+/// A region declared on a fn is **late-bound** if:\n+/// - it is constrained by an argument type;\n+/// - it does not appear in a where-clause.\n+///\n+/// \"Constrained\" basically means that it appears in any type but\n+/// not amongst the inputs to a projection.  In other words, `<&'a\n+/// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n+fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n+                               fn_def_id: DefId,\n+                               decl: &hir::FnDecl,\n+                               generics: &hir::Generics) {\n+    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n+\n+    let mut constrained_by_input = ConstrainedCollector { regions: FnvHashSet() };\n+    for arg in &decl.inputs {\n+        constrained_by_input.visit_ty(&arg.ty);\n     }\n \n-    generics.lifetimes.iter()\n-        .filter(|l| referenced_idents.iter().any(|&i| i == l.lifetime.name))\n-        .cloned()\n-        .collect()\n-}\n-\n-/// Given a set of generic declarations, returns a list of names containing all early bound\n-/// lifetime names for those generics. (In fact, this list may also contain other names.)\n-fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n-    // Create two lists, dividing the lifetimes into early/late bound.\n-    // Initially, all of them are considered late, but we will move\n-    // things from late into early as we go if we find references to\n-    // them.\n-    let mut early_bound = Vec::new();\n-    let mut late_bound = generics.lifetimes.iter()\n-                                           .map(|l| l.lifetime.name)\n-                                           .collect();\n-\n-    // Any lifetime that appears in a type bound is early.\n-    {\n-        let mut collector =\n-            FreeLifetimeCollector { early_bound: &mut early_bound,\n-                                    late_bound: &mut late_bound };\n-        for ty_param in generics.ty_params.iter() {\n-            walk_list!(&mut collector, visit_ty_param_bound, &ty_param.bounds);\n+    let mut appears_in_output = AllCollector { regions: FnvHashSet() };\n+    intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n+\n+    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+           constrained_by_input.regions);\n+\n+    // Walk the lifetimes that appear in where clauses.\n+    //\n+    // Subtle point: because we disallow nested bindings, we can just\n+    // ignore binders here and scrape up all names we see.\n+    let mut appears_in_where_clause = AllCollector { regions: FnvHashSet() };\n+    for ty_param in generics.ty_params.iter() {\n+        walk_list!(&mut appears_in_where_clause,\n+                   visit_ty_param_bound,\n+                   &ty_param.bounds);\n+    }\n+    walk_list!(&mut appears_in_where_clause,\n+               visit_where_predicate,\n+               &generics.where_clause.predicates);\n+    for lifetime_def in &generics.lifetimes {\n+        if !lifetime_def.bounds.is_empty() {\n+            // `'a: 'b` means both `'a` and `'b` are referenced\n+            appears_in_where_clause.visit_lifetime_def(lifetime_def);\n         }\n-        for predicate in &generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n-                                                                              ref bounded_ty,\n-                                                                              ..}) => {\n-                    collector.visit_ty(&bounded_ty);\n-                    walk_list!(&mut collector, visit_ty_param_bound, bounds);\n+    }\n+\n+    debug!(\"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n+           appears_in_where_clause.regions);\n+\n+    // Late bound regions are those that:\n+    // - appear in the inputs\n+    // - do not appear in the where-clauses\n+    for lifetime in &generics.lifetimes {\n+        let name = lifetime.lifetime.name;\n+\n+        // appears in the where clauses? early-bound.\n+        if appears_in_where_clause.regions.contains(&name) { continue; }\n+\n+        // does not appear in the inputs, but appears in the return\n+        // type? eventually this will be early-bound, but for now we\n+        // just mark it so we can issue warnings.\n+        let constrained_by_input = constrained_by_input.regions.contains(&name);\n+        let appears_in_output = appears_in_output.regions.contains(&name);\n+        let will_change = !constrained_by_input && appears_in_output;\n+        let issue_32330 = if will_change {\n+            ty::Issue32330::WillChange {\n+                fn_def_id: fn_def_id,\n+                region_name: name,\n+            }\n+        } else {\n+            ty::Issue32330::WontChange\n+        };\n+\n+        debug!(\"insert_late_bound_lifetimes: \\\n+                lifetime {:?} with id {:?} is late-bound ({:?}\",\n+               lifetime.lifetime.name, lifetime.lifetime.id, issue_32330);\n+\n+        let prev = map.late_bound.insert(lifetime.lifetime.id, issue_32330);\n+        assert!(prev.is_none(), \"visited lifetime {:?} twice\", lifetime.lifetime.id);\n+    }\n+\n+    return;\n+\n+    struct ConstrainedCollector {\n+        regions: FnvHashSet<ast::Name>,\n+    }\n+\n+    impl<'v> Visitor<'v> for ConstrainedCollector {\n+        fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+            match ty.node {\n+                hir::TyPath(Some(_), _) => {\n+                    // ignore lifetimes appearing in associated type\n+                    // projections, as they are not *constrained*\n+                    // (defined above)\n                 }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n-                                                                                ref bounds,\n-                                                                                ..}) => {\n-                    collector.visit_lifetime(lifetime);\n \n-                    for bound in bounds {\n-                        collector.visit_lifetime(bound);\n+                hir::TyPath(None, ref path) => {\n+                    // consider only the lifetimes on the final\n+                    // segment; I am not sure it's even currently\n+                    // valid to have them elsewhere, but even if it\n+                    // is, those would be potentially inputs to\n+                    // projections\n+                    if let Some(last_segment) = path.segments.last() {\n+                        self.visit_path_segment(path.span, last_segment);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(_) => bug!(\"unimplemented\")\n-            }\n-        }\n-    }\n \n-    // Any lifetime that either has a bound or is referenced by a\n-    // bound is early.\n-    for lifetime_def in &generics.lifetimes {\n-        if !lifetime_def.bounds.is_empty() {\n-            shuffle(&mut early_bound, &mut late_bound,\n-                    lifetime_def.lifetime.name);\n-            for bound in &lifetime_def.bounds {\n-                shuffle(&mut early_bound, &mut late_bound,\n-                        bound.name);\n+                _ => {\n+                    intravisit::walk_ty(self, ty);\n+                }\n             }\n         }\n-    }\n-    return early_bound;\n \n-    struct FreeLifetimeCollector<'a> {\n-        early_bound: &'a mut Vec<ast::Name>,\n-        late_bound: &'a mut Vec<ast::Name>,\n+        fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n+            self.regions.insert(lifetime_ref.name);\n+        }\n     }\n \n-    impl<'a, 'v> Visitor<'v> for FreeLifetimeCollector<'a> {\n-        fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-            shuffle(self.early_bound, self.late_bound,\n-                    lifetime_ref.name);\n-        }\n+    struct AllCollector {\n+        regions: FnvHashSet<ast::Name>,\n     }\n \n-    fn shuffle(early_bound: &mut Vec<ast::Name>,\n-               late_bound: &mut Vec<ast::Name>,\n-               name: ast::Name) {\n-        match late_bound.iter().position(|n| *n == name) {\n-            Some(index) => {\n-                late_bound.swap_remove(index);\n-                early_bound.push(name);\n-            }\n-            None => { }\n+    impl<'v> Visitor<'v> for AllCollector {\n+        fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n+            self.regions.insert(lifetime_ref.name);\n         }\n     }\n }"}, {"sha": "54ef17dce8f03db8ba8dbc24f98fdd612e751002", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -60,6 +60,7 @@ pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n+pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::FnOutput::*;\n@@ -527,7 +528,7 @@ bitflags! {\n \n         // Present if the type belongs in a local type context.\n         // Only set for TyInfer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX = 1 << 10,\n+        const KEEP_IN_LOCAL_TCX  = 1 << 11,\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n@@ -740,7 +741,8 @@ impl RegionParameterDef {\n         })\n     }\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+        // this is an early bound region, so unaffected by #32330\n+        ty::BoundRegion::BrNamed(self.def_id, self.name, Issue32330::WontChange)\n     }\n }\n \n@@ -2836,7 +2838,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         for def in generics.regions.as_slice() {\n             let region =\n                 ReFree(FreeRegion { scope: free_id_outlive,\n-                                    bound_region: BrNamed(def.def_id, def.name) });\n+                                    bound_region: def.to_bound_region() });\n             debug!(\"push_region_params {:?}\", region);\n             regions.push(def.space, region);\n         }"}, {"sha": "5a648dcbab71a6ded06f1397fc924be122402e21", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -58,7 +58,7 @@ pub enum BoundRegion {\n     ///\n     /// The def-id is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(DefId, Name),\n+    BrNamed(DefId, Name, Issue32330),\n \n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(u32),\n@@ -68,6 +68,25 @@ pub enum BoundRegion {\n     BrEnv\n }\n \n+/// True if this late-bound region is unconstrained, and hence will\n+/// become early-bound once #32330 is fixed.\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub enum Issue32330 {\n+    WontChange,\n+\n+    /// this region will change from late-bound to early-bound once\n+    /// #32330 is fixed.\n+    WillChange {\n+        /// fn where is region declared\n+        fn_def_id: DefId,\n+\n+        /// name of region; duplicates the info in BrNamed but convenient\n+        /// to have it here, and this code is only temporary\n+        region_name: ast::Name,\n+    }\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "a851e8354a9234995b64c2ebe9b43debe0cf89aa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -261,7 +261,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n     let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n         ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n-            ty::BrNamed(_, name) => {\n+            ty::BrNamed(_, name, _) => {\n                 let _ = write!(f, \"{}\", name);\n                 br\n             }\n@@ -270,7 +270,9 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID), name)\n+                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n+                            name,\n+                            ty::Issue32330::WontChange)\n             }\n         })\n     }).0;\n@@ -485,7 +487,7 @@ impl fmt::Display for ty::BoundRegion {\n         }\n \n         match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n+            BrNamed(_, name, _) => write!(f, \"{}\", name),\n             BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n         }\n     }\n@@ -496,8 +498,9 @@ impl fmt::Debug for ty::BoundRegion {\n         match *self {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\", did.krate, did.index, name)\n+            BrNamed(did, name, issue32330) => {\n+                write!(f, \"BrNamed({:?}:{:?}, {:?}, {:?})\",\n+                       did.krate, did.index, name, issue32330)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }"}, {"sha": "984ac226d85bfb06ca6bde2818bef6a17ea9c79e", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -158,8 +158,21 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             '[' => {\n                 let def = self.parse_def();\n-                let name = token::intern(&self.parse_str(']'));\n-                ty::BrNamed(def, name)\n+                let name = token::intern(&self.parse_str('|'));\n+                let issue32330 = match self.next() {\n+                    'n' => {\n+                        assert_eq!(self.next(), ']');\n+                        ty::Issue32330::WontChange\n+                    }\n+                    'y' => {\n+                        ty::Issue32330::WillChange {\n+                            fn_def_id: self.parse_def(),\n+                            region_name: token::intern(&self.parse_str(']')),\n+                        }\n+                    }\n+                    c => panic!(\"expected n or y not {}\", c)\n+                };\n+                ty::BrNamed(def, name, issue32330)\n             }\n             'f' => {\n                 let id = self.parse_u32();"}, {"sha": "87a2e50bb25e9b4e446778b56faef139f89844cd", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -308,10 +308,17 @@ fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n         ty::BrAnon(idx) => {\n             write!(w, \"a{}|\", idx);\n         }\n-        ty::BrNamed(d, name) => {\n-            write!(w, \"[{}|{}]\",\n-                     (cx.ds)(cx.tcx, d),\n-                     name);\n+        ty::BrNamed(d, name, issue32330) => {\n+            write!(w, \"[{}|{}|\",\n+                   (cx.ds)(cx.tcx, d),\n+                   name);\n+\n+            match issue32330 {\n+                ty::Issue32330::WontChange =>\n+                    write!(w, \"n]\"),\n+                ty::Issue32330::WillChange { fn_def_id, region_name } =>\n+                    write!(w, \"y{}|{}]\", (cx.ds)(cx.tcx, fn_def_id), region_name),\n+            };\n         }\n         ty::BrFresh(id) => {\n             write!(w, \"f{}|\", id);"}, {"sha": "472d6ac67f4f19eca852f2d461e33a52a35143c1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -170,7 +170,7 @@ type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjection\n \n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n-    let r = match tcx.named_region_map.get(&lifetime.id) {\n+    let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             span_bug!(lifetime.span, \"unresolved lifetime\");\n@@ -181,7 +181,20 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id), lifetime.name))\n+            // If this region is declared on a function, it will have\n+            // an entry in `late_bound`, but if it comes from\n+            // `for<'a>` in some type or something, it won't\n+            // necessarily have one. In that case though, we won't be\n+            // changed from late to early bound, so we can just\n+            // substitute false.\n+            let issue_32330 = tcx.named_region_map\n+                                 .late_bound\n+                                 .get(&id)\n+                                 .cloned()\n+                                 .unwrap_or(ty::Issue32330::WontChange);\n+            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id),\n+                                                  lifetime.name,\n+                                                  issue_32330))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, _)) => {\n@@ -193,11 +206,21 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefFreeRegion(scope, id)) => {\n+            // As in DefLateBoundRegion above, could be missing for some late-bound\n+            // regions, but also for early-bound regions.\n+            let issue_32330 = tcx.named_region_map\n+                                 .late_bound\n+                                 .get(&id)\n+                                 .cloned()\n+                                 .unwrap_or(ty::Issue32330::WontChange);\n             ty::ReFree(ty::FreeRegion {\n                     scope: scope.to_code_extent(&tcx.region_maps),\n                     bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n-                                              lifetime.name)\n-                })\n+                                              lifetime.name,\n+                                              issue_32330)\n+            })\n+\n+                // (*) -- not late-bound, won't change\n         }\n     };\n \n@@ -911,7 +934,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n         for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n             let br_name = match *br {\n-                ty::BrNamed(_, name) => name,\n+                ty::BrNamed(_, name, _) => name,\n                 _ => {\n                     span_bug!(\n                         binding.span,\n@@ -1675,7 +1698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n                 for br in late_bound_in_ret.difference(&late_bound_in_args) {\n                     let br_name = match *br {\n-                        ty::BrNamed(_, name) => name,\n+                        ty::BrNamed(_, name, _) => name,\n                         _ => {\n                             span_bug!(\n                                 bf.decl.output.span(),"}, {"sha": "e65f3f0ff413ff898fce31edf536569994498b11", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -64,7 +64,6 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n-use middle::resolve_lifetime;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n@@ -1745,14 +1744,16 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n /// the lifetimes that are declared. For fns or methods, we have to\n /// screen out those that do not appear in any where-clauses etc using\n /// `resolve_lifetime::early_bound_lifetimes`.\n-fn early_bound_lifetimes_from_generics(space: ParamSpace,\n-                                       ast_generics: &hir::Generics)\n-                                       -> Vec<hir::LifetimeDef>\n+fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n+    ccx: &CrateCtxt<'a, 'tcx>,\n+    ast_generics: &'hir hir::Generics)\n+    -> Vec<&'hir hir::LifetimeDef>\n {\n-    match space {\n-        SelfSpace | TypeSpace => ast_generics.lifetimes.to_vec(),\n-        FnSpace => resolve_lifetime::early_bound_lifetimes(ast_generics),\n-    }\n+    ast_generics\n+        .lifetimes\n+        .iter()\n+        .filter(|l| !ccx.tcx.named_region_map.late_bound.contains_key(&l.lifetime.id))\n+        .collect()\n }\n \n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n@@ -1781,7 +1782,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n-    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n         let region =\n@@ -1864,7 +1865,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let tcx = ccx.tcx;\n     let mut result = base_generics.clone();\n \n-    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (i, l) in early_lifetimes.iter().enumerate() {\n         let bounds = l.bounds.iter()\n                              .map(|l| ast_region_to_region(tcx, l))"}, {"sha": "612007da0e97acf33992d1ffd36e59fd8904af2a", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n-        match tcx.named_region_map.get(&param_id) {\n+        match tcx.named_region_map.defs.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),"}, {"sha": "0f3c62aca2a8595b51eba8be4f38b854ba3cbcce", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08034eb1a58518f7fc684ad325d32195d48a9fe3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=08034eb1a58518f7fc684ad325d32195d48a9fe3", "patch": "@@ -819,7 +819,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n+            ty::ReLateBound(_, ty::BrNamed(_, name, _)) => Some(Lifetime(name.to_string())),\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |"}]}