{"sha": "3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MDBmNjQxN2I2Y2QzMWMzMGY0ZDA3YmMzODNhZDEyYzQ4NGU3ZDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:17:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T01:17:25Z"}, "message": "rollup merge of #20688: jroesch/reject-non-param-bounds-followup\n\nThis is a follow up to my recent PR. r? @nikomatsakis", "tree": {"sha": "1ea5c37f9ce4567ae5cea7cdc397615b45fe8553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea5c37f9ce4567ae5cea7cdc397615b45fe8553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "html_url": "https://github.com/rust-lang/rust/commit/3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3800f6417b6cd31c30f4d07bc383ad12c484e7d1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6301c7878ebcaa45e77315db2a9afd8b5d1425c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6301c7878ebcaa45e77315db2a9afd8b5d1425c8", "html_url": "https://github.com/rust-lang/rust/commit/6301c7878ebcaa45e77315db2a9afd8b5d1425c8"}, {"sha": "120a52034d27a3ac08ed01a637569db9bc47108d", "url": "https://api.github.com/repos/rust-lang/rust/commits/120a52034d27a3ac08ed01a637569db9bc47108d", "html_url": "https://github.com/rust-lang/rust/commit/120a52034d27a3ac08ed01a637569db9bc47108d"}], "stats": {"total": 76, "additions": 57, "deletions": 19}, "files": [{"sha": "8b65895dad788f975fd639b2ac8ab469c0e2c2ff", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3800f6417b6cd31c30f4d07bc383ad12c484e7d1/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3800f6417b6cd31c30f4d07bc383ad12c484e7d1/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "patch": "@@ -77,6 +77,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     enum_variants(fcx, enum_def)\n                 });\n             }\n+            ast::ItemTrait(..) => {\n+                let trait_def =\n+                    ty::lookup_trait_def(ccx.tcx, local_def(item.id));\n+                reject_non_type_param_bounds(\n+                    ccx.tcx,\n+                    item.span,\n+                    &trait_def.generics);\n+            }\n             _ => {}\n         }\n     }\n@@ -237,21 +245,32 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       span: Span,\n                                       generics: &ty::Generics<'tcx>) {\n+\n     for predicate in generics.predicates.iter() {\n         match predicate {\n             &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n-                let self_ty = tr.self_ty();\n-                if !self_ty.walk().any(|t| is_ty_param(t)) {\n-                    tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot bound type `{}`, where clause \\\n-                                 bounds may only be attached to types involving \\\n-                                 type parameters\",\n-                                 self_ty.repr(tcx)).as_slice())\n-                }\n+                let found_param = tr.input_types().iter()\n+                                    .flat_map(|ty| ty.walk())\n+                                    .any(is_ty_param);\n+                if !found_param { report_bound_error(tcx, span, tr.self_ty() )}\n+            }\n+            &ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(ty, _))) => {\n+                let found_param = ty.walk().any(|t| is_ty_param(t));\n+                if !found_param { report_bound_error(tcx, span, ty) }\n             }\n             _ => {}\n-        }\n+        };\n+    }\n+\n+    fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n+                          span: Span,\n+                          bounded_ty: ty::Ty<'t>) {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"cannot bound type `{}`, where clause \\\n+                bounds may only be attached to types involving \\\n+                type parameters\",\n+                bounded_ty.repr(tcx)).as_slice())\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -267,6 +286,24 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.check_item_well_formed(i);\n         visit::walk_item(self, i);\n     }\n+\n+    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+        match t {\n+            &ast::TraitItem::ProvidedMethod(_) |\n+            &ast::TraitItem::TypeTraitItem(_) => {},\n+            &ast::TraitItem::RequiredMethod(ref method) => {\n+                match ty::impl_or_trait_item(self.ccx.tcx, local_def(method.id)) {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n+                        reject_non_type_param_bounds(\n+                            self.ccx.tcx,\n+                            method.span,\n+                            &ty_method.generics)\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n }\n \n pub struct BoundsChecker<'cx,'tcx:'cx> {\n@@ -455,7 +492,6 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     let arg_tys =\n                         ty::assert_no_late_bound_regions(\n                             fcx.tcx(), &ty::ty_fn_args(ctor_ty));\n-\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "d8af859c081e9a998ea3a6d3ec428102ef3e0663", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3800f6417b6cd31c30f4d07bc383ad12c484e7d1/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3800f6417b6cd31c30f4d07bc383ad12c484e7d1/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=3800f6417b6cd31c30f4d07bc383ad12c484e7d1", "patch": "@@ -8,32 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn equal<T>(_: &T, _: &T) -> bool where int : Eq {\n+fn equal<T>(_: &T, _: &T) -> bool where isize : Eq {\n     true //~^ ERROR cannot bound type `isize`, where clause bounds may only be attached\n }\n \n // This should be fine involves a type parameter.\n fn test<T: Eq>() -> bool where Option<T> : Eq {}\n \n // This should be rejected as well.\n-fn test2() -> bool where Option<int> : Eq {}\n-//~^ ERROR cannot bound type `core::option::Option<isize>`, where clause bounds\n+fn test2() -> bool where Option<isize> : Eq {}\n+//~^ ERROR cannot bound type `core::option::Option<isize>`, where clause bounds may\n \n #[derive(PartialEq)]\n //~^ ERROR cannot bound type `isize`, where clause bounds\n-enum Foo<T> where int : Eq { MkFoo }\n+enum Foo<T> where isize : Eq { MkFoo }\n //~^ ERROR cannot bound type `isize`, where clause bounds\n \n fn test3<T: Eq>() -> bool where Option<Foo<T>> : Eq {}\n \n-fn test4() -> bool where Option<Foo<int>> : Eq {}\n+fn test4() -> bool where Option<Foo<isize>> : Eq {}\n //~^ ERROR cannot bound type `core::option::Option<Foo<isize>>`, where clause bounds\n \n-trait Baz<T> where int : Eq {\n-    fn baz() where String : Eq;\n+trait Baz<T> where isize : Eq {\n+    //~^ ERROR cannot bound type `isize`, where clause bounds may only\n+    fn baz() where String : Eq; //~ ERROR cannot bound type `collections::string::String`\n+    //~^ ERROR cannot bound type `isize`, where clause\n }\n \n-impl Baz<int> for int where int : Eq {\n+impl Baz<int> for int where isize : Eq {\n     //~^ ERROR cannot bound type `isize`, where clause bounds\n     fn baz() where String : Eq {}\n }"}]}