{"sha": "b1d07bbe701641e3841c81da808159ef1710f70e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZDA3YmJlNzAxNjQxZTM4NDFjODFkYTgwODE1OWVmMTcxMGY3MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-21T05:04:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-21T05:04:32Z"}, "message": "Auto merge of #27837 - Gankro:weaknique, r=aturon\n\nThis prepares both for the FCP of #27718\r\n\r\nArc:\r\n\r\n* Add previously omitted function `Arc::try_unwrap(Self) -> Result<T, Self>`\r\n* Move `arc.downgrade()` to `Arc::downgrade(&Self)` per conventions.\r\n* Deprecate `Arc::weak_count` and `Arc::strong_count` for raciness. It is almost\r\n  impossible to correctly act on these results without a CAS loop on the actual\r\n  fields.\r\n* Rename `Arc::make_unique` to `Arc::make_mut` to avoid uniqueness terminology \r\n  and to clarify relation to `Arc::get_mut`.\r\n \r\n\r\nRc:\r\n* Add `Rc::would_unwrap(&Self) -> bool` to introspect whether try_unwrap would succeed, \r\n  because it's destructive (unlike get_mut).\r\n* Move `rc.downgrade()` to `Rc::downgrade(&Self)` per conventions.\r\n* Deprecate `Rc::weak_count` and `Rc::strong_count` for questionable utility.\r\n* Deprecate `Rc::is_unique` for questionable semantics (there are two kinds of \r\n  uniqueness with Weak pointers in play).\r\n* Rename `rc.make_unique()` to `Rc::make_mut(&mut Self)` per conventions, to\r\n  avoid uniqueness terminology, and to clarify the relation to `Rc::get_mut`.\r\n\r\nNotable omission:\r\n\r\n* Arc::would_unwrap is not added due to the fact that it's racy, and therefore doesn't \r\n  provide much actionable information.\r\n\r\n(note: rc_would_unwrap is not proposed for FCP as it is truly experimental)\r\n\r\n\r\nr? @aturon (careful attention needs to be taken for the new Arc::try_unwrap, but intuitively it should \"just work\" by virtue of being semantically equivalent to Drop).", "tree": {"sha": "58d9aca62f5fac9088ede087697a4e94defb609d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58d9aca62f5fac9088ede087697a4e94defb609d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d07bbe701641e3841c81da808159ef1710f70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d07bbe701641e3841c81da808159ef1710f70e", "html_url": "https://github.com/rust-lang/rust/commit/b1d07bbe701641e3841c81da808159ef1710f70e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d07bbe701641e3841c81da808159ef1710f70e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a407b6c4eea5d7bff34abf42518bcb8379c0cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a407b6c4eea5d7bff34abf42518bcb8379c0cfb", "html_url": "https://github.com/rust-lang/rust/commit/3a407b6c4eea5d7bff34abf42518bcb8379c0cfb"}, {"sha": "4c8d75fd9b4e0abf1107647a48e3578907e2e00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8d75fd9b4e0abf1107647a48e3578907e2e00e", "html_url": "https://github.com/rust-lang/rust/commit/4c8d75fd9b4e0abf1107647a48e3578907e2e00e"}], "stats": {"total": 400, "additions": 239, "deletions": 161}, "files": [{"sha": "aa71b7b132a1246a3b3739532b812e0649a3d30f", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 116, "deletions": 71, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -136,9 +136,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -162,7 +160,7 @@ struct ArcInner<T: ?Sized> {\n \n     // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n     // ability to upgrade weak pointers or downgrade strong ones; this is used\n-    // to avoid races in `make_unique` and `get_mut`.\n+    // to avoid races in `make_mut` and `get_mut`.\n     weak: atomic::AtomicUsize,\n \n     data: T,\n@@ -193,6 +191,44 @@ impl<T> Arc<T> {\n         };\n         Arc { _ptr: unsafe { NonZero::new(Box::into_raw(x)) } }\n     }\n+\n+    /// Unwraps the contained value if the `Arc<T>` has only one strong reference.\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// Otherwise, an `Err` is returned with the same `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_unique)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    ///\n+    /// let x = Arc::new(4);\n+    /// let _y = x.clone();\n+    /// assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n+        // See `drop` for why all these atomics are like this\n+        if this.inner().strong.compare_and_swap(1, 0, Release) != 1 { return Err(this) }\n+\n+        atomic::fence(Acquire);\n+\n+        unsafe {\n+            let ptr = *this._ptr;\n+            let elem = ptr::read(&(*ptr).data);\n+\n+            // Make a weak pointer to clean up the implicit strong-weak reference\n+            let _weak = Weak { _ptr: this._ptr };\n+            mem::forget(this);\n+\n+            Ok(elem)\n+        }\n+    }\n }\n \n impl<T: ?Sized> Arc<T> {\n@@ -202,21 +238,18 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Arc::downgrade(&five);\n     /// ```\n-    #[unstable(feature = \"arc_weak\",\n-               reason = \"Weak pointers may not belong in this module.\",\n-               issue = \"27718\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n+    #[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn downgrade(this: &Self) -> Weak<T> {\n         loop {\n             // This Relaxed is OK because we're checking the value in the CAS\n             // below.\n-            let cur = self.inner().weak.load(Relaxed);\n+            let cur = this.inner().weak.load(Relaxed);\n \n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX { continue }\n@@ -228,23 +261,23 @@ impl<T: ?Sized> Arc<T> {\n             // Unlike with Clone(), we need this to be an Acquire read to\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n-            if self.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n-                return Weak { _ptr: self._ptr }\n+            if this.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n+                return Weak { _ptr: this._ptr }\n             }\n         }\n     }\n \n     /// Get the number of weak references to this value.\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", issue = \"27718\")]\n-    pub fn weak_count(this: &Arc<T>) -> usize {\n+    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\", issue = \"27718\")]\n+    pub fn weak_count(this: &Self) -> usize {\n         this.inner().weak.load(SeqCst) - 1\n     }\n \n     /// Get the number of strong references to this value.\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", issue = \"27718\")]\n-    pub fn strong_count(this: &Arc<T>) -> usize {\n+    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\", issue = \"27718\")]\n+    pub fn strong_count(this: &Self) -> usize {\n         this.inner().strong.load(SeqCst)\n     }\n \n@@ -332,27 +365,40 @@ impl<T: ?Sized> Deref for Arc<T> {\n }\n \n impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference from the given `Arc<T>`.\n+    #[unstable(feature = \"arc_unique\", reason = \"renamed to Arc::make_mut\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"renamed to Arc::make_mut\")]\n+    pub fn make_unique(this: &mut Self) -> &mut T {\n+        Arc::make_mut(this)\n+    }\n+\n+    /// Make a mutable reference into the given `Arc<T>` by cloning the inner\n+    /// data if the `Arc<T>` doesn't have one strong reference and no weak\n+    /// references.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the (strong) reference count is greater than one. If\n-    /// we hold the only strong reference, any existing weak references will no\n-    /// longer be upgradeable.\n+    /// This is also referred to as a copy-on-write.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(arc_unique)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n-    /// let mut five = Arc::new(5);\n+    /// let mut data = Arc::new(5);\n+    ///\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// let mut other_data = data.clone();      // Won't clone inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n+    ///\n+    /// // Note: data and other_data now point to different numbers\n+    /// assert_eq!(*data, 8);\n+    /// assert_eq!(*other_data, 12);\n     ///\n-    /// let mut_five = Arc::make_unique(&mut five);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_unique\", issue = \"27718\")]\n-    pub fn make_unique(this: &mut Arc<T>) -> &mut T {\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn make_mut(this: &mut Self) -> &mut T {\n         // Note that we hold both a strong reference and a weak reference.\n         // Thus, releasing our strong reference only will not, by itself, cause\n         // the memory to be deallocated.\n@@ -407,30 +453,25 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n-    ///\n-    /// Returns `None` if the `Arc<T>` is not unique.\n+    /// Returns a mutable reference to the contained value if the `Arc<T>` has\n+    /// one strong reference and no weak references.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(arc_unique, alloc)]\n-    ///\n-    /// extern crate alloc;\n-    /// # fn main() {\n-    /// use alloc::arc::Arc;\n+    /// #![feature(arc_unique)]\n+    /// use std::sync::Arc;\n     ///\n     /// let mut x = Arc::new(3);\n     /// *Arc::get_mut(&mut x).unwrap() = 4;\n     /// assert_eq!(*x, 4);\n     ///\n     /// let _y = x.clone();\n     /// assert!(Arc::get_mut(&mut x).is_none());\n-    /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_unique\", issue = \"27718\")]\n-    pub fn get_mut(this: &mut Arc<T>) -> Option<&mut T> {\n+    #[unstable(feature = \"arc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if this.is_unique() {\n             // This unsafety is ok because we're guaranteed that the pointer\n             // returned is the *only* pointer that will ever be returned to T. Our\n@@ -542,9 +583,6 @@ impl<T: ?Sized> Drop for Arc<T> {\n     }\n }\n \n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -557,15 +595,15 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Arc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n     /// ```\n+    #[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n@@ -591,9 +629,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"arc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"arc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n impl<T: ?Sized> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -603,10 +639,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n-    /// let weak_five = Arc::new(5).downgrade();\n+    /// let weak_five = Arc::downgrade(&Arc::new(5));\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -637,20 +672,19 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// ```\n     /// #![feature(arc_weak)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// {\n     ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Arc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Arc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n@@ -890,23 +924,35 @@ mod tests {\n         assert!(Arc::get_mut(&mut x).is_none());\n         drop(y);\n         assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = x.downgrade();\n+        let _w = Arc::downgrade(&x);\n         assert!(Arc::get_mut(&mut x).is_none());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_make_unique() {\n+    fn try_unwrap() {\n+        let x = Arc::new(3);\n+        assert_eq!(Arc::try_unwrap(x), Ok(3));\n+        let x = Arc::new(4);\n+        let _y = x.clone();\n+        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+        let x = Arc::new(5);\n+        let _w = Arc::downgrade(&x);\n+        assert_eq!(Arc::try_unwrap(x), Ok(5));\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n-        assert!(75 == *Arc::make_unique(&mut cow0));\n-        assert!(75 == *Arc::make_unique(&mut cow1));\n-        assert!(75 == *Arc::make_unique(&mut cow2));\n+        assert!(75 == *Arc::make_mut(&mut cow0));\n+        assert!(75 == *Arc::make_mut(&mut cow1));\n+        assert!(75 == *Arc::make_mut(&mut cow2));\n \n-        *Arc::make_unique(&mut cow0) += 1;\n-        *Arc::make_unique(&mut cow1) += 2;\n-        *Arc::make_unique(&mut cow2) += 3;\n+        *Arc::make_mut(&mut cow0) += 1;\n+        *Arc::make_mut(&mut cow1) += 2;\n+        *Arc::make_mut(&mut cow2) += 3;\n \n         assert!(76 == *cow0);\n         assert!(77 == *cow1);\n@@ -928,8 +974,7 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        *Arc::make_unique(&mut cow0) += 1;\n-\n+        *Arc::make_mut(&mut cow0) += 1;\n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n@@ -944,12 +989,12 @@ mod tests {\n     #[test]\n     fn test_cowarc_clone_weak() {\n         let mut cow0 = Arc::new(75);\n-        let cow1_weak = cow0.downgrade();\n+        let cow1_weak = Arc::downgrade(&cow0);\n \n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        *Arc::make_unique(&mut cow0) += 1;\n+        *Arc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());\n@@ -958,14 +1003,14 @@ mod tests {\n     #[test]\n     fn test_live() {\n         let x = Arc::new(5);\n-        let y = x.downgrade();\n+        let y = Arc::downgrade(&x);\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n         let x = Arc::new(5);\n-        let y = x.downgrade();\n+        let y = Arc::downgrade(&x);\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }\n@@ -977,7 +1022,7 @@ mod tests {\n         }\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = a.clone().downgrade();\n+        let b = Arc::downgrade(&a.clone());\n         *a.x.lock().unwrap() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n@@ -995,7 +1040,7 @@ mod tests {\n     fn drop_arc_weak() {\n         let mut canary = atomic::AtomicUsize::new(0);\n         let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = arc.downgrade();\n+        let arc_weak = Arc::downgrade(&arc);\n         assert!(canary.load(Acquire) == 0);\n         drop(arc);\n         assert!(canary.load(Acquire) == 1);\n@@ -1006,7 +1051,7 @@ mod tests {\n     fn test_strong_count() {\n         let a = Arc::new(0u32);\n         assert!(Arc::strong_count(&a) == 1);\n-        let w = a.downgrade();\n+        let w = Arc::downgrade(&a);\n         assert!(Arc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"\");\n         assert!(Arc::strong_count(&b) == 2);\n@@ -1024,7 +1069,7 @@ mod tests {\n         let a = Arc::new(0u32);\n         assert!(Arc::strong_count(&a) == 1);\n         assert!(Arc::weak_count(&a) == 0);\n-        let w = a.downgrade();\n+        let w = Arc::downgrade(&a);\n         assert!(Arc::strong_count(&a) == 1);\n         assert!(Arc::weak_count(&a) == 1);\n         let x = w.clone();\n@@ -1036,7 +1081,7 @@ mod tests {\n         let c = a.clone();\n         assert!(Arc::strong_count(&a) == 2);\n         assert!(Arc::weak_count(&a) == 0);\n-        let d = c.downgrade();\n+        let d = Arc::downgrade(&c);\n         assert!(Arc::weak_count(&c) == 1);\n         assert!(Arc::strong_count(&c) == 2);\n \n@@ -1059,7 +1104,7 @@ mod tests {\n     fn test_unsized() {\n         let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n         assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = x.clone().downgrade();\n+        let y = Arc::downgrade(&x.clone());\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }"}, {"sha": "9649d0f71a14d94aa717ab9b34b2285b1f0ba8b2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 114, "deletions": 82, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(27718): rc_counts stuff is useful internally, but was previously public\n+#![allow(deprecated)]\n+\n //! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n //! The `Rc<T>` type provides shared ownership of an immutable value.\n@@ -126,8 +129,8 @@\n //!\n //!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n //!     // the RefCell holding the Owner's Gadgets.\n-//!     gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n-//!     gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n+//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));\n+//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));\n //!\n //!     // Iterate over our Gadgets, printing their details out\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n@@ -161,7 +164,7 @@ use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::intrinsics::{assume, drop_in_place, abort};\n use core::marker::{self, Unsize};\n-use core::mem::{self, align_of, size_of, align_of_val, size_of_val, forget};\n+use core::mem::{self, align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n use core::ops::{CoerceUnsized, Deref};\n use core::ptr;\n@@ -218,10 +221,10 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Unwraps the contained value if the `Rc<T>` is unique.\n+    /// Unwraps the contained value if the `Rc<T>` has only one strong reference.\n+    /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// If the `Rc<T>` is not unique, an `Err` is returned with the same\n-    /// `Rc<T>`.\n+    /// Otherwise, an `Err` is returned with the same `Rc<T>`.\n     ///\n     /// # Examples\n     ///\n@@ -238,22 +241,32 @@ impl<T> Rc<T> {\n     /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn try_unwrap(rc: Rc<T>) -> Result<T, Rc<T>> {\n-        if Rc::is_unique(&rc) {\n+    #[unstable(feature = \"rc_unique\", reason=  \"needs FCP\", issue = \"27718\")]\n+    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n+        if Rc::would_unwrap(&this) {\n             unsafe {\n-                let val = ptr::read(&*rc); // copy the contained object\n-                // destruct the box and skip our Drop\n-                // we can ignore the refcounts because we know we're unique\n-                deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                            align_of::<RcBox<T>>());\n-                forget(rc);\n+                let val = ptr::read(&*this); // copy the contained object\n+\n+                // Indicate to Weaks that they can't be promoted by decrememting\n+                // the strong count, and then remove the implicit \"strong weak\"\n+                // pointer while also handling drop logic by just crafting a\n+                // fake Weak.\n+                this.dec_strong();\n+                let _weak = Weak { _ptr: this._ptr };\n+                forget(this);\n                 Ok(val)\n             }\n         } else {\n-            Err(rc)\n+            Err(this)\n         }\n     }\n+\n+    /// Checks if `Rc::try_unwrap` would return `Ok`.\n+    #[unstable(feature = \"rc_would_unwrap\", reason = \"just added for niche usecase\",\n+               issue = \"27718\")]\n+    pub fn would_unwrap(this: &Self) -> bool {\n+        Rc::strong_count(&this) == 1\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {\n@@ -268,33 +281,31 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Rc::downgrade(&five);\n     /// ```\n-    #[unstable(feature = \"rc_weak\",\n-               reason = \"Weak pointers may not belong in this module\",\n-               issue = \"27718\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n+    #[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn downgrade(this: &Self) -> Weak<T> {\n+        this.inc_weak();\n+        Weak { _ptr: this._ptr }\n     }\n \n     /// Get the number of weak references to this value.\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", issue = \"27718\")]\n-    pub fn weak_count(this: &Rc<T>) -> usize { this.weak() - 1 }\n+    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\", issue = \"27718\")]\n+    pub fn weak_count(this: &Self) -> usize { this.weak() - 1 }\n \n     /// Get the number of strong references to this value.\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", issue= \"27718\")]\n-    pub fn strong_count(this: &Rc<T>) -> usize { this.strong() }\n+    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\", issue = \"27718\")]\n+    pub fn strong_count(this: &Self) -> usize { this.strong() }\n \n     /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n     /// the same inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_unique)]\n+    /// #![feature(rc_counts)]\n     ///\n     /// use std::rc::Rc;\n     ///\n@@ -303,13 +314,13 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::is_unique(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn is_unique(rc: &Rc<T>) -> bool {\n-        Rc::weak_count(rc) == 0 && Rc::strong_count(rc) == 1\n+    #[unstable(feature = \"rc_counts\", reason = \"uniqueness has unclear meaning\", issue = \"27718\")]\n+    pub fn is_unique(this: &Self) -> bool {\n+        Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the contained value if the `Rc<T>` is\n-    /// unique.\n+    /// Returns a mutable reference to the contained value if the `Rc<T>` has\n+    /// one strong reference and no weak references.\n     ///\n     /// Returns `None` if the `Rc<T>` is not unique.\n     ///\n@@ -328,10 +339,10 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::get_mut(&mut x).is_none());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn get_mut(rc: &mut Rc<T>) -> Option<&mut T> {\n-        if Rc::is_unique(rc) {\n-            let inner = unsafe { &mut **rc._ptr };\n+    #[unstable(feature = \"rc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n+        if Rc::is_unique(this) {\n+            let inner = unsafe { &mut **this._ptr };\n             Some(&mut inner.value)\n         } else {\n             None\n@@ -340,34 +351,62 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Make a mutable reference from the given `Rc<T>`.\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\", reason = \"renamed to Rc::make_mut\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"renamed to Rc::make_mut\")]\n+    pub fn make_unique(&mut self) -> &mut T {\n+        Rc::make_mut(self)\n+    }\n+\n+    /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n+    /// data if the `Rc<T>` doesn't have one strong reference and no weak\n+    /// references.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(rc_unique)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n-    /// let mut five = Rc::new(5);\n+    /// let mut data = Rc::new(5);\n+    ///\n+    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n+    /// let mut other_data = data.clone(); // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;             // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;       // Won't clone anything\n+    ///\n+    /// // Note: data and other_data now point to different numbers\n+    /// assert_eq!(*data, 8);\n+    /// assert_eq!(*other_data, 12);\n     ///\n-    /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n-        if !Rc::is_unique(self) {\n-            *self = Rc::new((**self).clone())\n+    #[unstable(feature = \"rc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn make_mut(this: &mut Self) -> &mut T {\n+        if Rc::strong_count(this) != 1 {\n+            // Gotta clone the data, there are other Rcs\n+            *this = Rc::new((**this).clone())\n+        } else if Rc::weak_count(this) != 0 {\n+            // Can just steal the data, all that's left is Weaks\n+            unsafe {\n+                let mut swap = Rc::new(ptr::read(&(**this._ptr).value));\n+                mem::swap(this, &mut swap);\n+                swap.dec_strong();\n+                // Remove implicit strong-weak ref (no need to craft a fake\n+                // Weak here -- we know other Weaks can clean up for us)\n+                swap.dec_weak();\n+                forget(swap);\n+            }\n         }\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut **self._ptr };\n+        let inner = unsafe { &mut **this._ptr };\n         &mut inner.value\n     }\n }\n@@ -413,7 +452,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as *const () as usize != mem::POST_DROP_USIZE {\n+                ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     // destroy the contained object\n@@ -653,9 +692,7 @@ impl<T> fmt::Pointer for Rc<T> {\n ///\n /// See the [module level documentation](./index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -667,11 +704,7 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n impl<T: ?Sized> Weak<T> {\n-\n     /// Upgrades a weak reference to a strong reference.\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n@@ -688,10 +721,11 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Rc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n     /// ```\n+    #[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -717,15 +751,15 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// {\n     ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Rc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Rc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n@@ -735,7 +769,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as *const () as usize != mem::POST_DROP_USIZE {\n+                ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared.\n@@ -748,9 +782,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n impl<T: ?Sized> Clone for Weak<T> {\n \n     /// Makes a clone of the `Weak<T>`.\n@@ -764,7 +796,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let weak_five = Rc::new(5).downgrade();\n+    /// let weak_five = Rc::downgrade(&Rc::new(5));\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -888,14 +920,14 @@ mod tests {\n     #[test]\n     fn test_live() {\n         let x = Rc::new(5);\n-        let y = x.downgrade();\n+        let y = Rc::downgrade(&x);\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n         let x = Rc::new(5);\n-        let y = x.downgrade();\n+        let y = Rc::downgrade(&x);\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }\n@@ -907,7 +939,7 @@ mod tests {\n         }\n \n         let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = a.clone().downgrade();\n+        let b = Rc::downgrade(&a.clone());\n         *a.x.borrow_mut() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n@@ -921,7 +953,7 @@ mod tests {\n         assert!(!Rc::is_unique(&x));\n         drop(y);\n         assert!(Rc::is_unique(&x));\n-        let w = x.downgrade();\n+        let w = Rc::downgrade(&x);\n         assert!(!Rc::is_unique(&x));\n         drop(w);\n         assert!(Rc::is_unique(&x));\n@@ -931,7 +963,7 @@ mod tests {\n     fn test_strong_count() {\n         let a = Rc::new(0u32);\n         assert!(Rc::strong_count(&a) == 1);\n-        let w = a.downgrade();\n+        let w = Rc::downgrade(&a);\n         assert!(Rc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"upgrade of live rc failed\");\n         assert!(Rc::strong_count(&b) == 2);\n@@ -949,7 +981,7 @@ mod tests {\n         let a = Rc::new(0u32);\n         assert!(Rc::strong_count(&a) == 1);\n         assert!(Rc::weak_count(&a) == 0);\n-        let w = a.downgrade();\n+        let w = Rc::downgrade(&a);\n         assert!(Rc::strong_count(&a) == 1);\n         assert!(Rc::weak_count(&a) == 1);\n         drop(w);\n@@ -969,8 +1001,8 @@ mod tests {\n         let _y = x.clone();\n         assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n         let x = Rc::new(5);\n-        let _w = x.downgrade();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(5)));\n+        let _w = Rc::downgrade(&x);\n+        assert_eq!(Rc::try_unwrap(x), Ok(5));\n     }\n \n     #[test]\n@@ -982,7 +1014,7 @@ mod tests {\n         assert!(Rc::get_mut(&mut x).is_none());\n         drop(y);\n         assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = x.downgrade();\n+        let _w = Rc::downgrade(&x);\n         assert!(Rc::get_mut(&mut x).is_none());\n     }\n \n@@ -992,13 +1024,13 @@ mod tests {\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n-        assert!(75 == *cow0.make_unique());\n-        assert!(75 == *cow1.make_unique());\n-        assert!(75 == *cow2.make_unique());\n+        assert!(75 == *Rc::make_mut(&mut cow0));\n+        assert!(75 == *Rc::make_mut(&mut cow1));\n+        assert!(75 == *Rc::make_mut(&mut cow2));\n \n-        *cow0.make_unique() += 1;\n-        *cow1.make_unique() += 2;\n-        *cow2.make_unique() += 3;\n+        *Rc::make_mut(&mut cow0) += 1;\n+        *Rc::make_mut(&mut cow1) += 2;\n+        *Rc::make_mut(&mut cow2) += 3;\n \n         assert!(76 == *cow0);\n         assert!(77 == *cow1);\n@@ -1020,7 +1052,7 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        *cow0.make_unique() += 1;\n+        *Rc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n@@ -1036,12 +1068,12 @@ mod tests {\n     #[test]\n     fn test_cowrc_clone_weak() {\n         let mut cow0 = Rc::new(75);\n-        let cow1_weak = cow0.downgrade();\n+        let cow1_weak = Rc::downgrade(&cow0);\n \n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        *cow0.make_unique() += 1;\n+        *Rc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());"}, {"sha": "17fb1ee2cb4b1cb4bba7a13d17c3a1c47254ff10", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn get_parent_link(&mut self, parent: &Rc<Module>, name: Name) -> ParentLink {\n-        ModuleParentLink(parent.downgrade(), name)\n+        ModuleParentLink(Rc::downgrade(parent), name)\n     }\n \n     /// Constructs the reduced graph for one item.\n@@ -390,7 +390,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId { krate: crate_id, node: 0 };\n                     self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(parent.downgrade(), name);\n+                    let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,\n                                                               Some(def_id),\n                                                               NormalModuleKind,\n@@ -638,7 +638,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                    block_id);\n \n             let new_module = Rc::new(Module::new(\n-                BlockParentLink(parent.downgrade(), block_id),\n+                BlockParentLink(Rc::downgrade(parent), block_id),\n                 None,\n                 AnonymousModuleKind,\n                 false,"}, {"sha": "e5ca4c4c6f001e4c6f423d3a34f2d1558d6797d8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -21,11 +21,11 @@\n \n #![feature(associated_consts)]\n #![feature(borrow_state)]\n-#![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_splits)]\n #![feature(staged_api)]\n+#![feature(rc_weak)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "b42a37e78dc8043eed3c7dcdfa359f3f9ce7edde", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -36,13 +36,13 @@\n #![feature(path_relative_from)]\n #![feature(path_relative_from)]\n #![feature(quote)]\n-#![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n+#![feature(rc_weak)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "f294a48b57588fb5bc412accc860ac77160de757", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -109,7 +109,7 @@ pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<Namespace\n                     let node = Rc::new(NamespaceTreeNode {\n                         name: name,\n                         scope: scope,\n-                        parent: parent_node.map(|parent| parent.downgrade()),\n+                        parent: parent_node.map(|parent| Rc::downgrade(&parent)),\n                     });\n \n                     debug_context(cx).namespace_map.borrow_mut()"}, {"sha": "039f4d8fd510d2fd6c30e3e78c0e4dbaf10f80d5", "filename": "src/test/run-pass/dst-coerce-rc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d07bbe701641e3841c81da808159ef1710f70e/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coerce-rc.rs?ref=b1d07bbe701641e3841c81da808159ef1710f70e", "patch": "@@ -36,13 +36,14 @@ fn main() {\n     let b: Rc<Baz> = a.clone();\n     assert_eq!(b.get(), 42);\n \n-    let c: Weak<i32> = a.downgrade();\n+    let c: Weak<i32> = Rc::downgrade(&a);\n     let d: Weak<Baz> = c.clone();\n \n     let _c = b.clone();\n \n     let a: Rc<RefCell<i32>> = Rc::new(RefCell::new(42));\n     let b: Rc<RefCell<Baz>> = a.clone();\n     assert_eq!(b.borrow().get(), 42);\n-    let c: Weak<RefCell<Baz>> = a.downgrade();\n+    // FIXME\n+    let c: Weak<RefCell<Baz>> = Rc::downgrade(&a) as Weak<_>;\n }"}]}