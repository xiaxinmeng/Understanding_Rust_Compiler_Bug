{"sha": "5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNDg1Y2U0YTM3NjdiY2FjNmJjYzdiZjY2ODY3YzU5YzMwZWFlYjE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-01T01:24:05Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-05T01:57:14Z"}, "message": "Use self profile infrastructure for -Z time and -Z time-passes", "tree": {"sha": "1ea3869a0eb039709e0bd528f6c9c63f1f54daf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea3869a0eb039709e0bd528f6c9c63f1f54daf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "html_url": "https://github.com/rust-lang/rust/commit/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7494250106003d698579edef215d0c01810b5156", "url": "https://api.github.com/repos/rust-lang/rust/commits/7494250106003d698579edef215d0c01810b5156", "html_url": "https://github.com/rust-lang/rust/commit/7494250106003d698579edef215d0c01810b5156"}], "stats": {"total": 949, "additions": 472, "deletions": 477}, "files": [{"sha": "fc23482958357beeb1967adac62ddcd74900c932", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -11,8 +11,6 @@ use crate::hir::print::Nested;\n use crate::hir::*;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::ty::query::Providers;\n-use crate::util::common::time;\n-\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_index::vec::IndexVec;\n@@ -1245,7 +1243,7 @@ pub fn map_crate<'hir>(\n         definitions,\n     };\n \n-    time(sess, \"validate HIR map\", || {\n+    sess.time(\"validate HIR map\", || {\n         hir_id_validator::check_crate(&map);\n     });\n "}, {"sha": "ce8263f81a72f5f1b634e4395fb452411bb8d210", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -66,8 +66,6 @@\n extern crate bitflags;\n #[macro_use]\n extern crate scoped_tls;\n-#[cfg(windows)]\n-extern crate libc;\n #[macro_use]\n extern crate rustc_macros;\n #[macro_use]"}, {"sha": "6758aedfabc14a3083fb2677dca86253f337585c", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -9,7 +9,6 @@ use crate::session::{CrateDisambiguator, Session};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n-use crate::util::common::{time, time_ext};\n \n use errors::Diagnostic;\n use rustc_data_structures::fx::FxHashMap;\n@@ -200,7 +199,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n-            time(tcx.sess, \"encode query results\", || {\n+            tcx.sess.time(\"encode query results\", || {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n \n@@ -1056,23 +1055,22 @@ where\n     E: 'a + TyEncoder,\n {\n     let desc = &format!(\"encode_query_results for {}\", ::std::any::type_name::<Q>());\n+    let _timer = tcx.sess.prof.generic_pass(desc);\n \n-    time_ext(tcx.sess.time_extended(), desc, || {\n-        let shards = Q::query_cache(tcx).lock_shards();\n-        assert!(shards.iter().all(|shard| shard.active.is_empty()));\n-        for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n-            if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n-                let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n+    let shards = Q::query_cache(tcx).lock_shards();\n+    assert!(shards.iter().all(|shard| shard.active.is_empty()));\n+    for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n+        if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n+            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n-                // Record position of the cache entry.\n-                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n+            // Record position of the cache entry.\n+            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-                // Encode the type check tables with the `SerializedDepNodeIndex`\n-                // as tag.\n-                encoder.encode_tagged(dep_node, &entry.value)?;\n-            }\n+            // Encode the type check tables with the `SerializedDepNodeIndex`\n+            // as tag.\n+            encoder.encode_tagged(dep_node, &entry.value)?;\n         }\n+    }\n \n-        Ok(())\n-    })\n+    Ok(())\n }"}, {"sha": "9574685215741baf8f7b232626a6bd58689b5ceb", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -2,11 +2,9 @@\n \n use rustc_data_structures::sync::Lock;\n \n-use std::cell::Cell;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use crate::session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n #[cfg(test)]\n@@ -17,85 +15,6 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n pub use errors::ErrorReported;\n \n-thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n-\n-#[allow(nonstandard_style)]\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct QueryMsg {\n-    pub query: &'static str,\n-    pub msg: Option<String>,\n-}\n-\n-/// Read the current depth of `time()` calls. This is used to\n-/// encourage indentation across threads.\n-pub fn time_depth() -> usize {\n-    TIME_DEPTH.with(|slot| slot.get())\n-}\n-\n-/// Sets the current depth of `time()` calls. The idea is to call\n-/// `set_time_depth()` with the result from `time_depth()` in the\n-/// parent thread.\n-pub fn set_time_depth(depth: usize) {\n-    TIME_DEPTH.with(|slot| slot.set(depth));\n-}\n-\n-pub fn time<T, F>(sess: &Session, what: &str, f: F) -> T\n-where\n-    F: FnOnce() -> T,\n-{\n-    time_ext(sess.time_passes(), what, f)\n-}\n-\n-pub fn time_ext<T, F>(do_it: bool, what: &str, f: F) -> T\n-where\n-    F: FnOnce() -> T,\n-{\n-    if !do_it {\n-        return f();\n-    }\n-\n-    let old = TIME_DEPTH.with(|slot| {\n-        let r = slot.get();\n-        slot.set(r + 1);\n-        r\n-    });\n-\n-    let start = Instant::now();\n-    let rv = f();\n-    let dur = start.elapsed();\n-\n-    print_time_passes_entry(true, what, dur);\n-\n-    TIME_DEPTH.with(|slot| slot.set(old));\n-\n-    rv\n-}\n-\n-pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n-    if !do_it {\n-        return;\n-    }\n-\n-    let indentation = TIME_DEPTH.with(|slot| slot.get());\n-\n-    let mem_string = match get_resident() {\n-        Some(n) => {\n-            let mb = n as f64 / 1_000_000.0;\n-            format!(\"; rss: {}MB\", mb.round() as usize)\n-        }\n-        None => String::new(),\n-    };\n-    println!(\n-        \"{}time: {}{}\\t{}\",\n-        \"  \".repeat(indentation),\n-        duration_to_secs_str(dur),\n-        mem_string,\n-        what\n-    );\n-}\n-\n-pub use rustc_session::utils::duration_to_secs_str;\n-\n pub fn to_readable_str(mut val: usize) -> String {\n     let mut groups = vec![];\n     loop {\n@@ -128,58 +47,6 @@ where\n     rv\n }\n \n-// Memory reporting\n-#[cfg(unix)]\n-fn get_resident() -> Option<usize> {\n-    use std::fs;\n-\n-    let field = 1;\n-    let contents = fs::read(\"/proc/self/statm\").ok()?;\n-    let contents = String::from_utf8(contents).ok()?;\n-    let s = contents.split_whitespace().nth(field)?;\n-    let npages = s.parse::<usize>().ok()?;\n-    Some(npages * 4096)\n-}\n-\n-#[cfg(windows)]\n-fn get_resident() -> Option<usize> {\n-    type BOOL = i32;\n-    type DWORD = u32;\n-    type HANDLE = *mut u8;\n-    use libc::size_t;\n-    use std::mem;\n-    #[repr(C)]\n-    #[allow(non_snake_case)]\n-    struct PROCESS_MEMORY_COUNTERS {\n-        cb: DWORD,\n-        PageFaultCount: DWORD,\n-        PeakWorkingSetSize: size_t,\n-        WorkingSetSize: size_t,\n-        QuotaPeakPagedPoolUsage: size_t,\n-        QuotaPagedPoolUsage: size_t,\n-        QuotaPeakNonPagedPoolUsage: size_t,\n-        QuotaNonPagedPoolUsage: size_t,\n-        PagefileUsage: size_t,\n-        PeakPagefileUsage: size_t,\n-    }\n-    type PPROCESS_MEMORY_COUNTERS = *mut PROCESS_MEMORY_COUNTERS;\n-    #[link(name = \"psapi\")]\n-    extern \"system\" {\n-        fn GetCurrentProcess() -> HANDLE;\n-        fn GetProcessMemoryInfo(\n-            Process: HANDLE,\n-            ppsmemCounters: PPROCESS_MEMORY_COUNTERS,\n-            cb: DWORD,\n-        ) -> BOOL;\n-    }\n-    let mut pmc: PROCESS_MEMORY_COUNTERS = unsafe { mem::zeroed() };\n-    pmc.cb = mem::size_of_val(&pmc) as DWORD;\n-    match unsafe { GetProcessMemoryInfo(GetCurrentProcess(), &mut pmc, pmc.cb) } {\n-        0 => None,\n-        _ => Some(pmc.WorkingSetSize as usize),\n-    }\n-}\n-\n pub fn indent<R, F>(op: F) -> R\n where\n     R: Debug,"}, {"sha": "ca95a3163499caaebb172846273b34b874877bbb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -11,7 +11,6 @@ use rustc::dep_graph::WorkProduct;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n-use rustc::util::common::time_ext;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n@@ -121,7 +120,7 @@ fn prepare_lto(\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = time_ext(cgcx.time_passes, &format!(\"decode {}\", name), || {\n+                let (bc, id) = cgcx.prof.generic_pass(&format!(\"decode {}\", name)).run(|| {\n                     match DecodedBytecode::new(bc_encoded) {\n                         Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n                         Err(e) => Err(diag_handler.fatal(&e)),\n@@ -281,9 +280,8 @@ fn fat_lto(\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n-            time_ext(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n+            cgcx.prof.generic_pass(&format!(\"ll link {:?}\", name)).run(|| {\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n@@ -634,9 +632,9 @@ pub(crate) fn run_pass_manager(\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, \"LTO passes\", || {\n-            llvm::LLVMRunPassManager(pm, module.module_llvm.llmod())\n-        });\n+        cgcx.prof\n+            .generic_pass(\"LTO passes\")\n+            .run(|| llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);\n     }"}, {"sha": "fa4d8a8d847f643fcaaa6f2b55cd6a59c50889bb", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 91, "deletions": 104, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -16,7 +16,6 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::config::{self, Lto, OutputType, Passes, Sanitizer, SwitchWithOptPath};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc::util::common::time_ext;\n use rustc_codegen_ssa::back::write::{run_assembler, CodegenContext, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n@@ -425,20 +424,14 @@ pub(crate) unsafe fn optimize(\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n-            time_ext(\n-                config.time_passes,\n-                &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n-                || llvm::LLVMRustRunFunctionPassManager(fpm, llmod),\n-            );\n+            let desc = &format!(\"llvm function passes [{}]\", module_name.unwrap());\n+            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n         }\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n-            time_ext(\n-                config.time_passes,\n-                &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n-                || llvm::LLVMRunPassManager(mpm, llmod),\n-            );\n+            let desc = &format!(\"llvm module passes [{}]\", module_name.unwrap());\n+            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+            llvm::LLVMRunPassManager(mpm, llmod);\n         }\n \n         // Deallocate managers that we're now done with\n@@ -561,103 +554,97 @@ pub(crate) unsafe fn codegen(\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n-        time_ext(\n-            config.time_passes,\n-            &format!(\"codegen passes [{}]\", module_name.unwrap()),\n-            || -> Result<(), FatalError> {\n-                if config.emit_ir {\n-                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n-                    let out =\n-                        cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-                    let out_c = path_to_c_string(&out);\n-\n-                    extern \"C\" fn demangle_callback(\n-                        input_ptr: *const c_char,\n-                        input_len: size_t,\n-                        output_ptr: *mut c_char,\n-                        output_len: size_t,\n-                    ) -> size_t {\n-                        let input = unsafe {\n-                            slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n-                        };\n-\n-                        let input = match str::from_utf8(input) {\n-                            Ok(s) => s,\n-                            Err(_) => return 0,\n-                        };\n-\n-                        let output = unsafe {\n-                            slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n-                        };\n-                        let mut cursor = io::Cursor::new(output);\n-\n-                        let demangled = match rustc_demangle::try_demangle(input) {\n-                            Ok(d) => d,\n-                            Err(_) => return 0,\n-                        };\n-\n-                        if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n-                            // Possible only if provided buffer is not big enough\n-                            return 0;\n-                        }\n-\n-                        cursor.position() as size_t\n+        {\n+            let desc = &format!(\"codegen passes [{}]\", module_name.unwrap());\n+            let _timer = if config.time_module { Some(cgcx.prof.generic_pass(desc)) } else { None };\n+\n+            if config.emit_ir {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n+                let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+                let out_c = path_to_c_string(&out);\n+\n+                extern \"C\" fn demangle_callback(\n+                    input_ptr: *const c_char,\n+                    input_len: size_t,\n+                    output_ptr: *mut c_char,\n+                    output_len: size_t,\n+                ) -> size_t {\n+                    let input = unsafe {\n+                        slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n+                    };\n+\n+                    let input = match str::from_utf8(input) {\n+                        Ok(s) => s,\n+                        Err(_) => return 0,\n+                    };\n+\n+                    let output = unsafe {\n+                        slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                    };\n+                    let mut cursor = io::Cursor::new(output);\n+\n+                    let demangled = match rustc_demangle::try_demangle(input) {\n+                        Ok(d) => d,\n+                        Err(_) => return 0,\n+                    };\n+\n+                    if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n+                        // Possible only if provided buffer is not big enough\n+                        return 0;\n                     }\n \n-                    let result =\n-                        llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n-                    result.into_result().map_err(|()| {\n-                        let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                        llvm_err(diag_handler, &msg)\n-                    })?;\n+                    cursor.position() as size_t\n                 }\n \n-                if config.emit_asm || asm_to_obj {\n-                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n-                    let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-\n-                    // We can't use the same module for asm and binary output, because that triggers\n-                    // various errors like invalid IR or broken binaries, so we might have to clone the\n-                    // module to produce the asm output\n-                    let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n-                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                        write_output_file(\n-                            diag_handler,\n-                            tm,\n-                            cpm,\n-                            llmod,\n-                            &path,\n-                            llvm::FileType::AssemblyFile,\n-                        )\n-                    })?;\n-                }\n+                let result = llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n+                result.into_result().map_err(|()| {\n+                    let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n+                    llvm_err(diag_handler, &msg)\n+                })?;\n+            }\n \n-                if write_obj {\n-                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n-                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                        write_output_file(\n-                            diag_handler,\n-                            tm,\n-                            cpm,\n-                            llmod,\n-                            &obj_out,\n-                            llvm::FileType::ObjectFile,\n-                        )\n-                    })?;\n-                } else if asm_to_obj {\n-                    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n-                    let assembly =\n-                        cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-                    run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-\n-                    if !config.emit_asm && !cgcx.save_temps {\n-                        drop(fs::remove_file(&assembly));\n-                    }\n-                }\n+            if config.emit_asm || asm_to_obj {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n+                let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+\n+                // We can't use the same module for asm and binary output, because that triggers\n+                // various errors like invalid IR or broken binaries, so we might have to clone the\n+                // module to produce the asm output\n+                let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(\n+                        diag_handler,\n+                        tm,\n+                        cpm,\n+                        llmod,\n+                        &path,\n+                        llvm::FileType::AssemblyFile,\n+                    )\n+                })?;\n+            }\n \n-                Ok(())\n-            },\n-        )?;\n+            if write_obj {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(\n+                        diag_handler,\n+                        tm,\n+                        cpm,\n+                        llmod,\n+                        &obj_out,\n+                        llvm::FileType::ObjectFile,\n+                    )\n+                })?;\n+            } else if asm_to_obj {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n+                let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+                run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+\n+                if !config.emit_asm && !cgcx.save_temps {\n+                    drop(fs::remove_file(&assembly));\n+                }\n+            }\n+        }\n \n         if copy_bc_to_obj {\n             debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);"}, {"sha": "349cff79c784399a9f9f5c92f76c7a24633d9ced", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -275,7 +275,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n-        use rustc::util::common::time;\n         let (codegen_results, work_products) = ongoing_codegen\n             .downcast::<rustc_codegen_ssa::back::write::OngoingCodegen<LlvmCodegenBackend>>()\n             .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n@@ -284,7 +283,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n             rustc_codegen_ssa::back::write::dump_incremental_data(&codegen_results);\n         }\n \n-        time(sess, \"serialize work products\", move || {\n+        sess.time(\"serialize work products\", move || {\n             rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n         });\n \n@@ -301,9 +300,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        time(sess, \"linking\", || {\n-            let _prof_timer = sess.prof.generic_activity(\"link_crate\");\n-\n+        sess.time(\"linking\", || {\n             use crate::back::archive::LlvmArchiveBuilder;\n             use rustc_codegen_ssa::back::link::link_binary;\n "}, {"sha": "2151c0580421f805ee64c37035a8e479f24dd21c", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -8,7 +8,6 @@ use rustc::session::search_paths::PathKind;\n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n use rustc::session::{filesearch, Session};\n-use rustc::util::common::{time, time_ext};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_span::symbol::Symbol;\n@@ -578,7 +577,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = time(sess, \"running linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n+        prog = sess.time(\"running linker\", || exec_linker(sess, &mut cmd, out_filename, tmpdir));\n         let output = match prog {\n             Ok(ref output) => output,\n             Err(_) => break,\n@@ -1563,7 +1562,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time_ext(sess.time_extended(), &format!(\"altering {}.rlib\", name), || {\n+        sess.prof.generic_pass(&format!(\"altering {}.rlib\", name)).run(|| {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "44ed297ea8396adfce2e5be3aab5edbb8fd7eee2", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -18,9 +18,9 @@ use rustc::session::config::{\n };\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc::util::common::{print_time_passes_entry, set_time_depth, time_depth};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n@@ -45,7 +45,6 @@ use std::str;\n use std::sync::mpsc::{channel, Receiver, Sender};\n use std::sync::Arc;\n use std::thread;\n-use std::time::Instant;\n \n const PRE_LTO_BC_EXT: &str = \"pre-lto.bc\";\n \n@@ -81,7 +80,7 @@ pub struct ModuleConfig {\n     pub verify_llvm_ir: bool,\n     pub no_prepopulate_passes: bool,\n     pub no_builtins: bool,\n-    pub time_passes: bool,\n+    pub time_module: bool,\n     pub vectorize_loop: bool,\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n@@ -125,7 +124,7 @@ impl ModuleConfig {\n             verify_llvm_ir: false,\n             no_prepopulate_passes: false,\n             no_builtins: false,\n-            time_passes: false,\n+            time_module: true,\n             vectorize_loop: false,\n             vectorize_slp: false,\n             merge_functions: false,\n@@ -137,7 +136,6 @@ impl ModuleConfig {\n         self.verify_llvm_ir = sess.verify_llvm_ir();\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n-        self.time_passes = sess.time_extended();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode =\n             sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n@@ -212,7 +210,6 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n pub struct CodegenContext<B: WriteBackendMethods> {\n     // Resources needed when running LTO\n     pub backend: B,\n-    pub time_passes: bool,\n     pub prof: SelfProfilerRef,\n     pub lto: Lto,\n     pub no_landing_pads: bool,\n@@ -434,8 +431,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     // Exclude metadata and allocator modules from time_passes output, since\n     // they throw off the \"LLVM passes\" measurement.\n-    metadata_config.time_passes = false;\n-    allocator_config.time_passes = false;\n+    metadata_config.time_module = false;\n+    allocator_config.time_module = false;\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (codegen_worker_send, codegen_worker_receive) = channel();\n@@ -1026,7 +1023,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n-        time_passes: sess.time_extended(),\n         prof: sess.prof.clone(),\n         exported_symbols,\n         remark: sess.opts.cg.remark.clone(),\n@@ -1184,9 +1180,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // necessary. There's already optimizations in place to avoid sending work\n     // back to the coordinator if LTO isn't requested.\n     return thread::spawn(move || {\n-        // We pretend to be within the top-level LLVM time-passes task here:\n-        set_time_depth(1);\n-\n         let max_workers = ::num_cpus::get();\n         let mut worker_id_counter = 0;\n         let mut free_worker_ids = Vec::new();\n@@ -1224,7 +1217,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         let mut main_thread_worker_state = MainThreadWorkerState::Idle;\n         let mut running = 0;\n \n-        let mut llvm_start_time = None;\n+        let prof = &cgcx.prof;\n+        let mut llvm_start_time: Option<VerboseTimingGuard<'_>> = None;\n \n         // Run the message loop while there's still anything that needs message\n         // processing. Note that as soon as codegen is aborted we simply want to\n@@ -1262,6 +1256,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                             ..cgcx.clone()\n                         };\n                         maybe_start_llvm_timer(\n+                            prof,\n                             cgcx.config(item.module_kind()),\n                             &mut llvm_start_time,\n                         );\n@@ -1313,6 +1308,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                                 ..cgcx.clone()\n                             };\n                             maybe_start_llvm_timer(\n+                                prof,\n                                 cgcx.config(item.module_kind()),\n                                 &mut llvm_start_time,\n                             );\n@@ -1345,7 +1341,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             while !codegen_aborted && work_items.len() > 0 && running < tokens.len() {\n                 let (item, _) = work_items.pop().unwrap();\n \n-                maybe_start_llvm_timer(cgcx.config(item.module_kind()), &mut llvm_start_time);\n+                maybe_start_llvm_timer(prof, cgcx.config(item.module_kind()), &mut llvm_start_time);\n \n                 let cgcx =\n                     CodegenContext { worker: get_worker_id(&mut free_worker_ids), ..cgcx.clone() };\n@@ -1483,13 +1479,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             }\n         }\n \n-        if let Some(llvm_start_time) = llvm_start_time {\n-            let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n-            // This is the top-level timing for all of LLVM, set the time-depth\n-            // to zero.\n-            set_time_depth(1);\n-            print_time_passes_entry(cgcx.time_passes, \"LLVM passes\", total_llvm_time);\n-        }\n+        // Drop to print timings\n+        drop(llvm_start_time);\n \n         // Regardless of what order these modules completed in, report them to\n         // the backend in the same order every time to ensure that we're handing\n@@ -1514,25 +1505,21 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         items_in_queue > 0 && items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n     }\n \n-    fn maybe_start_llvm_timer(config: &ModuleConfig, llvm_start_time: &mut Option<Instant>) {\n-        // We keep track of the -Ztime-passes output manually,\n-        // since the closure-based interface does not fit well here.\n-        if config.time_passes {\n-            if llvm_start_time.is_none() {\n-                *llvm_start_time = Some(Instant::now());\n-            }\n+    fn maybe_start_llvm_timer<'a>(\n+        prof: &'a SelfProfilerRef,\n+        config: &ModuleConfig,\n+        llvm_start_time: &mut Option<VerboseTimingGuard<'a>>,\n+    ) {\n+        if config.time_module && llvm_start_time.is_none() {\n+            *llvm_start_time = Some(prof.generic_pass(\"LLVM passes\"));\n         }\n     }\n }\n \n pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n \n fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>) {\n-    let depth = time_depth();\n-\n     thread::spawn(move || {\n-        set_time_depth(depth);\n-\n         // Set up a destructor which will fire off a message that we're done as\n         // we exit.\n         struct Bomb<B: ExtraBackendMethods> {"}, {"sha": "6750b7e65ba9ef9e64a35e2bcaa551021399aae9", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -39,9 +39,9 @@ use rustc::ty::layout::{self, Align, HasTyCtxt, LayoutOf, TyLayout, VariantIdx};\n use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, Instance, Ty, TyCtxt};\n-use rustc::util::common::{print_time_passes_entry, set_time_depth, time, time_depth};\n use rustc_codegen_utils::{check_for_rustc_errors_attr, symbol_names_test};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_index::vec::Idx;\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_span::Span;\n@@ -565,9 +565,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let mut modules = backend.new_metadata(tcx, &llmod_id);\n-        time(tcx.sess, \"write allocator module\", || {\n-            backend.codegen_allocator(tcx, &mut modules, kind)\n-        });\n+        tcx.sess\n+            .time(\"write allocator module\", || backend.codegen_allocator(tcx, &mut modules, kind));\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm: modules, kind: ModuleKind::Allocator })\n     } else {\n@@ -583,7 +582,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let metadata_cgu_name =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n         let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n-        time(tcx.sess, \"write compressed metadata\", || {\n+        tcx.sess.time(\"write compressed metadata\", || {\n             backend.write_compressed_metadata(\n                 tcx,\n                 &ongoing_codegen.metadata,\n@@ -653,10 +652,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    let time_depth = time_depth();\n-    set_time_depth(time_depth + 1);\n     print_time_passes_entry(tcx.sess.time_passes(), \"codegen to LLVM IR\", total_codegen_time);\n-    set_time_depth(time_depth);\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n \n@@ -716,9 +712,9 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n }\n \n fn assert_and_save_dep_graph(tcx: TyCtxt<'_>) {\n-    time(tcx.sess, \"assert dep graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n+    tcx.sess.time(\"assert dep graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n \n-    time(tcx.sess, \"serialize dep graph\", || ::rustc_incremental::save_dep_graph(tcx));\n+    tcx.sess.time(\"serialize dep graph\", || ::rustc_incremental::save_dep_graph(tcx));\n }\n \n impl CrateInfo {"}, {"sha": "d1b7ee9e83e76717ab315f77e7fc183bc6fa3755", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -33,6 +33,9 @@ extern crate libc;\n #[macro_use]\n extern crate cfg_if;\n \n+#[cfg(windows)]\n+extern crate libc;\n+\n pub use rustc_serialize::hex::ToHex;\n \n #[inline(never)]"}, {"sha": "840a2603deb79f7a03e655400621b2e2bd98836a", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 210, "deletions": 19, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -5,8 +5,11 @@ use std::path::Path;\n use std::process;\n use std::sync::Arc;\n use std::thread::ThreadId;\n+use std::time::{Duration, Instant};\n use std::u32;\n \n+use crate::cold_path;\n+\n use measureme::StringId;\n \n /// MmapSerializatioSink is faster on macOS and Linux\n@@ -41,11 +44,15 @@ bitflags::bitflags! {\n         const QUERY_CACHE_HITS   = 1 << 2;\n         const QUERY_BLOCKED      = 1 << 3;\n         const INCR_CACHE_LOADS   = 1 << 4;\n+        const SPARSE_PASS   = 1 << 5;\n+        const GENERIC_PASS   = 1 << 6;\n \n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n-                        Self::INCR_CACHE_LOADS.bits;\n+                        Self::INCR_CACHE_LOADS.bits |\n+                        Self::SPARSE_PASS.bits |\n+                        Self::GENERIC_PASS.bits;\n \n         // empty() and none() aren't const-fns unfortunately\n         const NONE = 0;\n@@ -56,6 +63,8 @@ bitflags::bitflags! {\n const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"none\", EventFilter::NONE),\n     (\"all\", EventFilter::ALL),\n+    (\"sparse-pass\", EventFilter::SPARSE_PASS),\n+    (\"generic-pass\", EventFilter::GENERIC_PASS),\n     (\"generic-activity\", EventFilter::GENERIC_ACTIVITIES),\n     (\"query-provider\", EventFilter::QUERY_PROVIDERS),\n     (\"query-cache-hit\", EventFilter::QUERY_CACHE_HITS),\n@@ -79,44 +88,105 @@ pub struct SelfProfilerRef {\n     // cost anything and allows for filtering with checking if the profiler is\n     // actually enabled.\n     event_filter_mask: EventFilter,\n+\n+    // Print sparse passes to stdout\n+    verbose_sparse: bool,\n+\n+    // Print generic passes to stdout\n+    verbose_generic: bool,\n }\n \n impl SelfProfilerRef {\n-    pub fn new(profiler: Option<Arc<SelfProfiler>>) -> SelfProfilerRef {\n+    pub fn new(\n+        profiler: Option<Arc<SelfProfiler>>,\n+        verbose_sparse: bool,\n+        verbose_generic: bool,\n+    ) -> SelfProfilerRef {\n         // If there is no SelfProfiler then the filter mask is set to NONE,\n         // ensuring that nothing ever tries to actually access it.\n-        let event_filter_mask =\n+        let mut event_filter_mask =\n             profiler.as_ref().map(|p| p.event_filter_mask).unwrap_or(EventFilter::NONE);\n \n-        SelfProfilerRef { profiler, event_filter_mask }\n+        if verbose_sparse {\n+            event_filter_mask |= EventFilter::SPARSE_PASS;\n+        }\n+\n+        if verbose_generic {\n+            event_filter_mask |= EventFilter::GENERIC_PASS;\n+        }\n+\n+        SelfProfilerRef { profiler, event_filter_mask, verbose_sparse, verbose_generic }\n     }\n \n-    // This shim makes sure that calls only get executed if the filter mask\n-    // lets them pass. It also contains some trickery to make sure that\n-    // code is optimized for non-profiling compilation sessions, i.e. anything\n-    // past the filter check is never inlined so it doesn't clutter the fast\n-    // path.\n     #[inline(always)]\n     fn exec<F>(&self, event_filter: EventFilter, f: F) -> TimingGuard<'_>\n     where\n         F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n     {\n-        #[inline(never)]\n-        fn cold_call<F>(profiler_ref: &SelfProfilerRef, f: F) -> TimingGuard<'_>\n-        where\n-            F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n-        {\n-            let profiler = profiler_ref.profiler.as_ref().unwrap();\n-            f(&**profiler)\n-        }\n+        self.handle_event(\n+            event_filter,\n+            || f(self.profiler.as_ref().unwrap()),\n+            || TimingGuard::none(),\n+        )\n+    }\n \n+    // This shim makes sure that cold calls only get executed if the filter mask\n+    // lets them pass. It also contains some trickery to make sure that\n+    // code is optimized for non-profiling compilation sessions, i.e. anything\n+    // past the filter check is never inlined so it doesn't clutter the fast\n+    // path.\n+    #[inline(always)]\n+    fn handle_event<R>(\n+        &self,\n+        event_filter: EventFilter,\n+        cold: impl FnOnce() -> R,\n+        hot: impl FnOnce() -> R,\n+    ) -> R {\n         if unlikely!(self.event_filter_mask.contains(event_filter)) {\n-            cold_call(self, f)\n+            cold_path(|| cold())\n         } else {\n-            TimingGuard::none()\n+            hot()\n         }\n     }\n \n+    /// Start profiling a sparse pass. Profiling continues until the\n+    /// VerboseTimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn sparse_pass<'a>(&'a self, event_id: &'a str) -> VerboseTimingGuard<'a> {\n+        self.handle_event(\n+            EventFilter::SPARSE_PASS,\n+            || {\n+                VerboseTimingGuard::start(\n+                    self.profiler\n+                        .as_ref()\n+                        .map(|profiler| (&**profiler, profiler.sparse_pass_event_kind)),\n+                    event_id,\n+                    self.verbose_sparse,\n+                )\n+            },\n+            || VerboseTimingGuard::none(),\n+        )\n+    }\n+\n+    /// Start profiling a generic pass. Profiling continues until the\n+    /// VerboseTimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_pass<'a>(&'a self, event_id: &'a str) -> VerboseTimingGuard<'a> {\n+        self.handle_event(\n+            EventFilter::GENERIC_PASS,\n+            || {\n+                VerboseTimingGuard::start(\n+                    self.profiler\n+                        .as_ref()\n+                        .map(|profiler| (&**profiler, profiler.generic_pass_event_kind)),\n+                    event_id,\n+                    self.verbose_generic,\n+                )\n+            },\n+            || VerboseTimingGuard::none(),\n+        )\n+    }\n+\n     /// Start profiling a generic activity. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]\n@@ -197,6 +267,8 @@ pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n     query_event_kind: StringId,\n+    sparse_pass_event_kind: StringId,\n+    generic_pass_event_kind: StringId,\n     generic_activity_event_kind: StringId,\n     incremental_load_result_event_kind: StringId,\n     query_blocked_event_kind: StringId,\n@@ -217,6 +289,8 @@ impl SelfProfiler {\n         let profiler = Profiler::new(&path)?;\n \n         let query_event_kind = profiler.alloc_string(\"Query\");\n+        let sparse_pass_event_kind = profiler.alloc_string(\"SparsePass\");\n+        let generic_pass_event_kind = profiler.alloc_string(\"GenericPass\");\n         let generic_activity_event_kind = profiler.alloc_string(\"GenericActivity\");\n         let incremental_load_result_event_kind = profiler.alloc_string(\"IncrementalLoadResult\");\n         let query_blocked_event_kind = profiler.alloc_string(\"QueryBlocked\");\n@@ -259,6 +333,8 @@ impl SelfProfiler {\n             profiler,\n             event_filter_mask,\n             query_event_kind,\n+            sparse_pass_event_kind,\n+            generic_pass_event_kind,\n             generic_activity_event_kind,\n             incremental_load_result_event_kind,\n             query_blocked_event_kind,\n@@ -301,3 +377,118 @@ impl<'a> TimingGuard<'a> {\n         TimingGuard(None)\n     }\n }\n+\n+#[must_use]\n+pub struct VerboseTimingGuard<'a> {\n+    event_id: &'a str,\n+    start: Option<Instant>,\n+    _guard: TimingGuard<'a>,\n+}\n+\n+impl<'a> VerboseTimingGuard<'a> {\n+    pub fn start(\n+        profiler: Option<(&'a SelfProfiler, StringId)>,\n+        event_id: &'a str,\n+        verbose: bool,\n+    ) -> Self {\n+        let _guard = profiler.map_or(TimingGuard::none(), |(profiler, event_kind)| {\n+            let event = profiler.profiler.alloc_string(event_id);\n+            TimingGuard::start(profiler, event_kind, event)\n+        });\n+        VerboseTimingGuard {\n+            event_id,\n+            _guard,\n+            start: if verbose { Some(Instant::now()) } else { None },\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn run<R>(self, f: impl FnOnce() -> R) -> R {\n+        let _timer = self;\n+        f()\n+    }\n+\n+    fn none() -> Self {\n+        VerboseTimingGuard { event_id: \"\", start: None, _guard: TimingGuard::none() }\n+    }\n+}\n+\n+impl Drop for VerboseTimingGuard<'_> {\n+    fn drop(&mut self) {\n+        self.start.map(|start| print_time_passes_entry(true, self.event_id, start.elapsed()));\n+    }\n+}\n+\n+pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n+    if !do_it {\n+        return;\n+    }\n+\n+    let mem_string = match get_resident() {\n+        Some(n) => {\n+            let mb = n as f64 / 1_000_000.0;\n+            format!(\"; rss: {}MB\", mb.round() as usize)\n+        }\n+        None => String::new(),\n+    };\n+    println!(\"time: {}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n+}\n+\n+// Hack up our own formatting for the duration to make it easier for scripts\n+// to parse (always use the same number of decimal places and the same unit).\n+pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n+    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n+    let secs = dur.as_secs() as f64 + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n+\n+    format!(\"{:.3}\", secs)\n+}\n+\n+// Memory reporting\n+#[cfg(unix)]\n+fn get_resident() -> Option<usize> {\n+    let field = 1;\n+    let contents = fs::read(\"/proc/self/statm\").ok()?;\n+    let contents = String::from_utf8(contents).ok()?;\n+    let s = contents.split_whitespace().nth(field)?;\n+    let npages = s.parse::<usize>().ok()?;\n+    Some(npages * 4096)\n+}\n+\n+#[cfg(windows)]\n+fn get_resident() -> Option<usize> {\n+    type BOOL = i32;\n+    type DWORD = u32;\n+    type HANDLE = *mut u8;\n+    use libc::size_t;\n+    #[repr(C)]\n+    #[allow(non_snake_case)]\n+    struct PROCESS_MEMORY_COUNTERS {\n+        cb: DWORD,\n+        PageFaultCount: DWORD,\n+        PeakWorkingSetSize: size_t,\n+        WorkingSetSize: size_t,\n+        QuotaPeakPagedPoolUsage: size_t,\n+        QuotaPagedPoolUsage: size_t,\n+        QuotaPeakNonPagedPoolUsage: size_t,\n+        QuotaNonPagedPoolUsage: size_t,\n+        PagefileUsage: size_t,\n+        PeakPagefileUsage: size_t,\n+    }\n+    #[allow(non_camel_case_types)]\n+    type PPROCESS_MEMORY_COUNTERS = *mut PROCESS_MEMORY_COUNTERS;\n+    #[link(name = \"psapi\")]\n+    extern \"system\" {\n+        fn GetCurrentProcess() -> HANDLE;\n+        fn GetProcessMemoryInfo(\n+            Process: HANDLE,\n+            ppsmemCounters: PPROCESS_MEMORY_COUNTERS,\n+            cb: DWORD,\n+        ) -> BOOL;\n+    }\n+    let mut pmc: PROCESS_MEMORY_COUNTERS = unsafe { mem::zeroed() };\n+    pmc.cb = mem::size_of_val(&pmc) as DWORD;\n+    match unsafe { GetProcessMemoryInfo(GetCurrentProcess(), &mut pmc, pmc.cb) } {\n+        0 => None,\n+        _ => Some(pmc.WorkingSetSize as usize),\n+    }\n+}"}, {"sha": "379e9bdfa878a84eecfeb3d85a7571eb192bde11", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -34,8 +34,9 @@ use rustc::session::config::{ErrorOutputType, Input, OutputType, PrintRequest};\n use rustc::session::{config, DiagnosticOutput, Session};\n use rustc::session::{early_error, early_warn};\n use rustc::ty::TyCtxt;\n-use rustc::util::common::{print_time_passes_entry, set_time_depth, time, ErrorReported};\n+use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::SeqCst;\n use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_interface::util::get_builtin_codegen_backend;\n@@ -368,7 +369,7 @@ pub fn run_compiler(\n                 queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let result = tcx.analysis(LOCAL_CRATE);\n \n-                    time(sess, \"save analysis\", || {\n+                    sess.time(\"save analysis\", || {\n                         save::process_crate(\n                             tcx,\n                             &expanded_crate,\n@@ -1260,7 +1261,6 @@ pub fn main() {\n         Err(_) => EXIT_FAILURE,\n     };\n     // The extra `\\t` is necessary to align this label with the others.\n-    set_time_depth(0);\n     print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n     process::exit(exit_code);\n }"}, {"sha": "cb06dae6ac9197ffb275b04acf3a49d188c9cca7", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -4,7 +4,6 @@ use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkPr\n use rustc::session::Session;\n use rustc::ty::query::OnDiskCache;\n use rustc::ty::TyCtxt;\n-use rustc::util::common::time_ext;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::opaque::Decoder;\n use rustc_serialize::Decodable as RustcDecodable;\n@@ -96,7 +95,6 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     // Since `sess` isn't `Sync`, we perform all accesses to `sess`\n     // before we fire the background thread.\n \n-    let time_passes = sess.time_passes();\n     let prof = sess.prof.clone();\n \n     if sess.opts.incremental.is_none() {\n@@ -161,38 +159,36 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     }\n \n     MaybeAsync::Async(std::thread::spawn(move || {\n-        time_ext(time_passes, \"background load prev dep-graph\", move || {\n-            let _prof_timer = prof.generic_activity(\"incr_comp_load_dep_graph\");\n-\n-            match load_data(report_incremental_info, &path) {\n-                LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n-                LoadResult::Error { message } => LoadResult::Error { message },\n-                LoadResult::Ok { data: (bytes, start_pos) } => {\n-                    let mut decoder = Decoder::new(&bytes, start_pos);\n-                    let prev_commandline_args_hash = u64::decode(&mut decoder)\n-                        .expect(\"Error reading commandline arg hash from cached dep-graph\");\n-\n-                    if prev_commandline_args_hash != expected_hash {\n-                        if report_incremental_info {\n-                            println!(\n-                                \"[incremental] completely ignoring cache because of \\\n+        let _prof_timer = prof.generic_pass(\"background load prev dep-graph\");\n+\n+        match load_data(report_incremental_info, &path) {\n+            LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n+            LoadResult::Error { message } => LoadResult::Error { message },\n+            LoadResult::Ok { data: (bytes, start_pos) } => {\n+                let mut decoder = Decoder::new(&bytes, start_pos);\n+                let prev_commandline_args_hash = u64::decode(&mut decoder)\n+                    .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+\n+                if prev_commandline_args_hash != expected_hash {\n+                    if report_incremental_info {\n+                        println!(\n+                            \"[incremental] completely ignoring cache because of \\\n                                     differing commandline arguments\"\n-                            );\n-                        }\n-                        // We can't reuse the cache, purge it.\n-                        debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n-\n-                        // No need to do any further work\n-                        return LoadResult::DataOutOfDate;\n+                        );\n                     }\n+                    // We can't reuse the cache, purge it.\n+                    debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n \n-                    let dep_graph = SerializedDepGraph::decode(&mut decoder)\n-                        .expect(\"Error reading cached dep-graph\");\n-\n-                    LoadResult::Ok { data: (PreviousDepGraph::new(dep_graph), prev_work_products) }\n+                    // No need to do any further work\n+                    return LoadResult::DataOutOfDate;\n                 }\n+\n+                let dep_graph = SerializedDepGraph::decode(&mut decoder)\n+                    .expect(\"Error reading cached dep-graph\");\n+\n+                LoadResult::Ok { data: (PreviousDepGraph::new(dep_graph), prev_work_products) }\n             }\n-        })\n+        }\n     }))\n }\n "}, {"sha": "9487f02aa8e08ff03fb476832b507c9134c73958", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -1,7 +1,6 @@\n use rustc::dep_graph::{DepGraph, DepKind, WorkProduct, WorkProductId};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc::util::common::time;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n use rustc_serialize::opaque::Encoder;\n@@ -33,19 +32,15 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n         join(\n             move || {\n                 if tcx.sess.opts.debugging_opts.incremental_queries {\n-                    let _timer = tcx.prof.generic_activity(\"incr_comp_persist_result_cache\");\n-\n-                    time(sess, \"persist query result cache\", || {\n+                    sess.time(\"persist query result cache\", || {\n                         save_in(sess, query_cache_path, |e| encode_query_cache(tcx, e));\n                     });\n                 }\n             },\n             || {\n-                time(sess, \"persist dep-graph\", || {\n-                    let _timer = tcx.prof.generic_activity(\"incr_comp_persist_dep_graph\");\n-\n+                sess.time(\"persist dep-graph\", || {\n                     save_in(sess, dep_graph_path, |e| {\n-                        time(sess, \"encode dep-graph\", || encode_dep_graph(tcx, e))\n+                        sess.time(\"encode dep-graph\", || encode_dep_graph(tcx, e))\n                     });\n                 });\n             },\n@@ -147,10 +142,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n     // Encode the graph data.\n-    let serialized_graph = time(tcx.sess, \"getting serialized graph\", || {\n-        let _timer = tcx.prof.generic_activity(\"incr_comp_serialize_dep_graph\");\n-        tcx.dep_graph.serialize()\n-    });\n+    let serialized_graph = tcx.sess.time(\"getting serialized graph\", || tcx.dep_graph.serialize());\n \n     if tcx.sess.opts.debugging_opts.incremental_info {\n         #[derive(Clone)]\n@@ -231,8 +223,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n         println!(\"[incremental]\");\n     }\n \n-    time(tcx.sess, \"encoding serialized graph\", || {\n-        let _timer = tcx.prof.generic_activity(\"incr_comp_encode_serialized_dep_graph\");\n+    tcx.sess.time(\"encoding serialized graph\", || {\n         serialized_graph.encode(encoder).unwrap();\n     });\n }\n@@ -253,9 +244,7 @@ fn encode_work_product_index(\n }\n \n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n-    time(tcx.sess, \"serialize query result cache\", || {\n-        let _timer = tcx.prof.generic_activity(\"incr_comp_serialize_result_cache\");\n-\n+    tcx.sess.time(\"serialize query result cache\", || {\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })\n }"}, {"sha": "cd632c310f0a3f82f100424a76e7a500b7492e0f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -17,7 +17,7 @@ use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::steal::Steal;\n use rustc::ty::{self, AllArenas, GlobalCtxt, ResolverOutputs, TyCtxt};\n-use rustc::util::common::{time, ErrorReported};\n+use rustc::util::common::ErrorReported;\n use rustc_builtin_macros;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -55,14 +55,10 @@ use std::{env, fs, iter, mem};\n \n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     sess.diagnostic().set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n-    let krate = time(sess, \"parsing\", || {\n-        let _prof_timer = sess.prof.generic_activity(\"parse_crate\");\n-\n-        match input {\n-            Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n-            Input::Str { input, name } => {\n-                parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n-            }\n+    let krate = sess.time(\"parsing\", || match input {\n+        Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n+        Input::Str { input, name } => {\n+            parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n         }\n     })?;\n \n@@ -162,7 +158,7 @@ pub fn register_plugins<'a>(\n     mut krate: ast::Crate,\n     crate_name: &str,\n ) -> Result<(ast::Crate, Lrc<lint::LintStore>)> {\n-    krate = time(sess, \"attributes injection\", || {\n+    krate = sess.time(\"attributes injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n             krate,\n             &sess.parse_sess,\n@@ -187,7 +183,7 @@ pub fn register_plugins<'a>(\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n-        time(sess, \"garbage-collect incremental cache directory\", || {\n+        sess.time(\"garbage-collect incremental cache directory\", || {\n             let _prof_timer =\n                 sess.prof.generic_activity(\"incr_comp_garbage_collect_session_directories\");\n             if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n@@ -200,7 +196,7 @@ pub fn register_plugins<'a>(\n         });\n     }\n \n-    time(sess, \"recursion limit\", || {\n+    sess.time(\"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n@@ -211,8 +207,8 @@ pub fn register_plugins<'a>(\n     register_lints(&sess, &mut lint_store);\n \n     let registrars =\n-        time(sess, \"plugin loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n-    time(sess, \"plugin registration\", || {\n+        sess.time(\"plugin loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n+    sess.time(\"plugin registration\", || {\n         let mut registry = plugin::Registry { lint_store: &mut lint_store };\n         for registrar in registrars {\n             registrar(&mut registry);\n@@ -230,7 +226,7 @@ fn configure_and_expand_inner<'a>(\n     resolver_arenas: &'a ResolverArenas<'a>,\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n-    time(sess, \"pre-AST-expansion lint checks\", || {\n+    sess.time(\"pre-AST-expansion lint checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n@@ -244,7 +240,7 @@ fn configure_and_expand_inner<'a>(\n     let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n     rustc_builtin_macros::register_builtin_macros(&mut resolver, sess.edition());\n \n-    krate = time(sess, \"crate injection\", || {\n+    krate = sess.time(\"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n         let (krate, name) = rustc_builtin_macros::standard_library_imports::inject(\n             krate,\n@@ -261,8 +257,7 @@ fn configure_and_expand_inner<'a>(\n     util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n-    krate = time(sess, \"expansion\", || {\n-        let _prof_timer = sess.prof.generic_activity(\"macro_expand_crate\");\n+    krate = sess.time(\"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n         // dependent dlls. Note that this uses cfg!(windows) as opposed to\n@@ -307,11 +302,11 @@ fn configure_and_expand_inner<'a>(\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n \n         // Expand macros now!\n-        let krate = time(sess, \"expand crate\", || ecx.monotonic_expander().expand_crate(krate));\n+        let krate = sess.time(\"expand crate\", || ecx.monotonic_expander().expand_crate(krate));\n \n         // The rest is error reporting\n \n-        time(sess, \"check unused macros\", || {\n+        sess.time(\"check unused macros\", || {\n             ecx.check_unused_macros();\n         });\n \n@@ -330,7 +325,7 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n-    time(sess, \"maybe building test harness\", || {\n+    sess.time(\"maybe building test harness\", || {\n         rustc_builtin_macros::test_harness::inject(\n             &sess.parse_sess,\n             &mut resolver,\n@@ -354,7 +349,7 @@ fn configure_and_expand_inner<'a>(\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n \n-    let has_proc_macro_decls = time(sess, \"AST validation\", || {\n+    let has_proc_macro_decls = sess.time(\"AST validation\", || {\n         ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n@@ -376,7 +371,7 @@ fn configure_and_expand_inner<'a>(\n         msg.warn(\"The generated documentation may be incorrect\");\n         msg.emit()\n     } else {\n-        krate = time(sess, \"maybe creating a macro crate\", || {\n+        krate = sess.time(\"maybe creating a macro crate\", || {\n             let num_crate_types = crate_types.len();\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n@@ -406,12 +401,12 @@ fn configure_and_expand_inner<'a>(\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    time(sess, \"name resolution\", || {\n+    sess.time(\"name resolution\", || {\n         resolver.resolve_crate(&krate);\n     });\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n-    time(sess, \"complete gated feature checking\", || {\n+    sess.time(\"complete gated feature checking\", || {\n         syntax::feature_gate::check_crate(\n             &krate,\n             &sess.parse_sess,\n@@ -440,7 +435,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n     arena: &'tcx Arena<'tcx>,\n ) -> Result<hir::map::Forest<'tcx>> {\n     // Lower AST to HIR.\n-    let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n+    let hir_forest = sess.time(\"lowering AST -> HIR\", || {\n         let hir_crate = rustc_ast_lowering::lower_crate(\n             sess,\n             &dep_graph,\n@@ -457,7 +452,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n         hir::map::Forest::new(hir_crate, &dep_graph)\n     });\n \n-    time(sess, \"early lint checks\", || {\n+    sess.time(\"early lint checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n@@ -731,12 +726,12 @@ pub fn create_global_ctxt<'tcx>(\n     let defs = mem::take(&mut resolver_outputs.definitions);\n \n     // Construct the HIR map.\n-    let hir_map = time(sess, \"indexing HIR\", || {\n+    let hir_map = sess.time(\"indexing HIR\", || {\n         hir::map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs)\n     });\n \n     let query_result_on_disk_cache =\n-        time(sess, \"load query result cache\", || rustc_incremental::load_query_result_cache(sess));\n+        sess.time(\"load query result cache\", || rustc_incremental::load_query_result_cache(sess));\n \n     let codegen_backend = compiler.codegen_backend();\n     let mut local_providers = ty::query::Providers::default();\n@@ -769,7 +764,7 @@ pub fn create_global_ctxt<'tcx>(\n \n     // Do some initialization of the DepGraph that can only be done with the tcx available.\n     ty::tls::enter_global(&gcx, |tcx| {\n-        time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n+        tcx.sess.time(\"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n     });\n \n     QueryContext(gcx)\n@@ -783,18 +778,17 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     let sess = tcx.sess;\n     let mut entry_point = None;\n \n-    time(sess, \"misc checking 1\", || {\n+    sess.time(\"misc checking 1\", || {\n         parallel!(\n             {\n-                entry_point = time(sess, \"looking for entry point\", || {\n-                    rustc_passes::entry::find_entry_point(tcx)\n-                });\n+                entry_point = sess\n+                    .time(\"looking for entry point\", || rustc_passes::entry::find_entry_point(tcx));\n \n-                time(sess, \"looking for plugin registrar\", || {\n+                sess.time(\"looking for plugin registrar\", || {\n                     plugin::build::find_plugin_registrar(tcx)\n                 });\n \n-                time(sess, \"looking for derive registrar\", || proc_macro_decls::find(tcx));\n+                sess.time(\"looking for derive registrar\", || proc_macro_decls::find(tcx));\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n@@ -811,17 +805,17 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     // passes are timed inside typeck\n     typeck::check_crate(tcx)?;\n \n-    time(sess, \"misc checking 2\", || {\n+    sess.time(\"misc checking 2\", || {\n         parallel!(\n             {\n-                time(sess, \"match checking\", || {\n+                sess.time(\"match checking\", || {\n                     tcx.par_body_owners(|def_id| {\n                         tcx.ensure().check_match(def_id);\n                     });\n                 });\n             },\n             {\n-                time(sess, \"liveness checking + intrinsic checking\", || {\n+                sess.time(\"liveness checking + intrinsic checking\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                         // this must run before MIR dump, because\n                         // \"not all control paths return a value\" is reported here.\n@@ -837,21 +831,21 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         );\n     });\n \n-    time(sess, \"MIR borrow checking\", || {\n+    sess.time(\"MIR borrow checking\", || {\n         tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });\n \n-    time(sess, \"dumping Chalk-like clauses\", || {\n+    sess.time(\"dumping Chalk-like clauses\", || {\n         rustc_traits::lowering::dump_program_clauses(tcx);\n     });\n \n-    time(sess, \"MIR effect checking\", || {\n+    sess.time(\"MIR effect checking\", || {\n         for def_id in tcx.body_owners() {\n             mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n         }\n     });\n \n-    time(sess, \"layout testing\", || layout_test::test_layout(tcx));\n+    sess.time(\"layout testing\", || layout_test::test_layout(tcx));\n \n     // Avoid overwhelming user with errors if borrow checking failed.\n     // I'm not sure how helpful this is, to be honest, but it avoids a\n@@ -862,28 +856,28 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         return Err(ErrorReported);\n     }\n \n-    time(sess, \"misc checking 3\", || {\n+    sess.time(\"misc checking 3\", || {\n         parallel!(\n             {\n-                time(sess, \"privacy access levels\", || {\n+                sess.time(\"privacy access levels\", || {\n                     tcx.ensure().privacy_access_levels(LOCAL_CRATE);\n                 });\n                 parallel!(\n                     {\n-                        time(sess, \"private in public\", || {\n+                        sess.time(\"private in public\", || {\n                             tcx.ensure().check_private_in_public(LOCAL_CRATE);\n                         });\n                     },\n                     {\n-                        time(sess, \"death checking\", || rustc_passes::dead::check_crate(tcx));\n+                        sess.time(\"death checking\", || rustc_passes::dead::check_crate(tcx));\n                     },\n                     {\n-                        time(sess, \"unused lib feature checking\", || {\n+                        sess.time(\"unused lib feature checking\", || {\n                             rustc_passes::stability::check_unused_or_stable_features(tcx)\n                         });\n                     },\n                     {\n-                        time(sess, \"lint checking\", || {\n+                        sess.time(\"lint checking\", || {\n                             rustc_lint::check_crate(tcx, || {\n                                 rustc_lint::BuiltinCombinedLateLintPass::new()\n                             });\n@@ -892,7 +886,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                 );\n             },\n             {\n-                time(sess, \"privacy checking modules\", || {\n+                sess.time(\"privacy checking modules\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                         tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n                     });\n@@ -978,10 +972,9 @@ pub fn start_codegen<'tcx>(\n     }\n \n     let (metadata, need_metadata_module) =\n-        time(tcx.sess, \"metadata encoding and writing\", || encode_and_write_metadata(tcx, outputs));\n+        tcx.sess.time(\"metadata encoding and writing\", || encode_and_write_metadata(tcx, outputs));\n \n-    let codegen = time(tcx.sess, \"codegen\", move || {\n-        let _prof_timer = tcx.prof.generic_activity(\"codegen_crate\");\n+    let codegen = tcx.sess.time(\"codegen\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n "}, {"sha": "c0a75e7efbfe22c5989307ed44f7de56959d77f4", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -11,7 +11,7 @@ use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n use rustc::ty::{AllArenas, GlobalCtxt, ResolverOutputs};\n-use rustc::util::common::{time, ErrorReported};\n+use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n use rustc_incremental::DepGraphFuture;\n@@ -195,7 +195,7 @@ impl<'tcx> Queries<'tcx> {\n                 None => DepGraph::new_disabled(),\n                 Some(future) => {\n                     let (prev_graph, prev_work_products) =\n-                        time(self.session(), \"blocked while dep-graph loading finishes\", || {\n+                        self.session().time(\"blocked while dep-graph loading finishes\", || {\n                             future\n                                 .open()\n                                 .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {"}, {"sha": "a09956854594379bf0bfaf19060c66b13d384c99", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -18,7 +18,6 @@ use rustc::lint::{EarlyContext, LintStore};\n use rustc::lint::{EarlyLintPass, EarlyLintPassObject};\n use rustc::lint::{LintBuffer, LintContext, LintPass};\n use rustc::session::Session;\n-use rustc::util::common::time;\n \n use rustc_span::Span;\n use std::slice;\n@@ -351,7 +350,7 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     } else {\n         for pass in &mut passes {\n-            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n+            buffered = sess.time(&format!(\"running lint: {}\", pass.name()), || {\n                 early_lint_crate(\n                     sess,\n                     lint_store,"}, {"sha": "e66de9cc1bbc787ddbc0fdc8ab1125742a1fa2ce", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -22,7 +22,6 @@ use rustc::lint::LateContext;\n use rustc::lint::LintPass;\n use rustc::lint::{LateLintPass, LateLintPassObject};\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::common::time;\n \n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_span::Span;\n@@ -433,7 +432,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         late_lint_pass_crate(tcx, builtin_lints);\n     } else {\n         for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+            tcx.sess.time(&format!(\"running late lint: {}\", pass.name()), || {\n                 late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n             });\n         }\n@@ -442,7 +441,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n             tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+            tcx.sess.time(&format!(\"running late module lint: {}\", pass.name()), || {\n                 late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n             });\n         }\n@@ -456,13 +455,13 @@ pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n ) {\n     join(\n         || {\n-            time(tcx.sess, \"crate lints\", || {\n+            tcx.sess.time(\"crate lints\", || {\n                 // Run whole crate non-incremental lints\n                 late_lint_crate(tcx, builtin_lints());\n             });\n         },\n         || {\n-            time(tcx.sess, \"module lints\", || {\n+            tcx.sess.time(\"module lints\", || {\n                 // Run per-module lints\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n                     tcx.ensure().lint_mod(tcx.hir().local_def_id(module));"}, {"sha": "231ee792918b37a8cdece151142408dcbfa23718", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -191,7 +191,6 @@ use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common::time;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -284,7 +283,7 @@ pub fn collect_crate_mono_items(\n ) -> (FxHashSet<MonoItem<'_>>, InliningMap<'_>) {\n     let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector\");\n \n-    let roots = time(tcx.sess, \"collecting roots\", || {\n+    let roots = tcx.sess.time(\"collecting roots\", || {\n         let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector_root_collections\");\n         collect_roots(tcx, mode)\n     });\n@@ -295,12 +294,10 @@ pub fn collect_crate_mono_items(\n     let mut inlining_map = MTLock::new(InliningMap::new());\n \n     {\n-        let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector_graph_walk\");\n-\n         let visited: MTRef<'_, _> = &mut visited;\n         let inlining_map: MTRef<'_, _> = &mut inlining_map;\n \n-        time(tcx.sess, \"collecting mono items\", || {\n+        tcx.sess.time(\"collecting mono items\", || {\n             par_iter(roots).for_each(|root| {\n                 let mut recursion_depths = DefIdMap::default();\n                 collect_items_rec(tcx, root, visited, &mut recursion_depths, inlining_map);"}, {"sha": "766d6bbe5176dc3397404e0f427c3152ac68394a", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -105,7 +105,6 @@ use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n-use rustc::util::common::time;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_span::symbol::Symbol;\n \n@@ -866,7 +865,7 @@ fn collect_and_partition_mono_items(\n         }\n     };\n \n-    let (items, inlining_map) = time(tcx.sess, \"monomorphization collection\", || {\n+    let (items, inlining_map) = tcx.sess.time(\"monomorphization collection\", || {\n         collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n@@ -880,7 +879,7 @@ fn collect_and_partition_mono_items(\n         PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n     };\n \n-    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n+    let codegen_units = tcx.sess.time(\"codegen unit partitioning\", || {\n         partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n             .into_iter()\n             .map(Arc::new)"}, {"sha": "dba5b9f3f14c229f47a326de065107e9e7ed0a6a", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -9,7 +9,7 @@ use crate::config::{self, OutputType, PrintRequest, Sanitizer, SwitchWithOptPath\n use crate::filesearch;\n use crate::lint;\n use crate::search_paths::{PathKind, SearchPath};\n-use crate::utils::duration_to_secs_str;\n+use rustc_data_structures::profiling::duration_to_secs_str;\n use rustc_errors::ErrorReported;\n \n use rustc_data_structures::base_n;\n@@ -398,9 +398,6 @@ impl Session {\n     pub fn time_passes(&self) -> bool {\n         self.opts.debugging_opts.time_passes || self.opts.debugging_opts.time\n     }\n-    pub fn time_extended(&self) -> bool {\n-        self.opts.debugging_opts.time_passes\n-    }\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n@@ -1030,6 +1027,12 @@ fn build_session_(\n         CguReuseTracker::new_disabled()\n     };\n \n+    let prof = SelfProfilerRef::new(\n+        self_profiler,\n+        sopts.debugging_opts.time_passes || sopts.debugging_opts.time,\n+        sopts.debugging_opts.time_passes,\n+    );\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1049,7 +1052,7 @@ fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n-        prof: SelfProfilerRef::new(self_profiler),\n+        prof,\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "7806f5e8753f22b9fcea1275ecabcf33e7571ca1", "filename": "src/librustc_session/utils.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_session%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_session%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Futils.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -1,10 +1,13 @@\n-// Hack up our own formatting for the duration to make it easier for scripts\n-// to parse (always use the same number of decimal places and the same unit).\n-pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64 + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n+use crate::session::Session;\n+use rustc_data_structures::profiling::VerboseTimingGuard;\n \n-    format!(\"{:.3}\", secs)\n+impl Session {\n+    pub fn timer<'a>(&'a self, what: &'a str) -> VerboseTimingGuard<'a> {\n+        self.prof.sparse_pass(what)\n+    }\n+    pub fn time<R>(&self, what: &str, f: impl FnOnce() -> R) -> R {\n+        self.prof.sparse_pass(what).run(f)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "2d19b73eac380ff995056821071a7ae9533e5e42", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -10,7 +10,6 @@ use crate::hir::HirId;\n use rustc::traits;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::util::common::time;\n \n use rustc_error_codes::*;\n \n@@ -146,8 +145,8 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n \n-    time(tcx.sess, \"unsafety checking\", || unsafety::check(tcx));\n-    time(tcx.sess, \"orphan checking\", || orphan::check(tcx));\n+    tcx.sess.time(\"unsafety checking\", || unsafety::check(tcx));\n+    tcx.sess.time(\"orphan checking\", || orphan::check(tcx));\n \n     // these queries are executed for side-effects (error reporting):\n     tcx.ensure().crate_inherent_impls(LOCAL_CRATE);"}, {"sha": "dbf4c7655c14b63131b67f8e42e47d70c3bd86ed", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5a485ce4a3767bcac6bcc7bf66867c59c30eaeb1", "patch": "@@ -108,7 +108,6 @@ use rustc::util;\n use rustc::util::common::ErrorReported;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use util::common::time;\n \n use rustc_error_codes::*;\n \n@@ -304,13 +303,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n-    let _prof_timer = tcx.prof.generic_activity(\"type_check_crate\");\n+    let _prof_timer = tcx.sess.timer(\"type_check_crate\");\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     // FIXME(matthewjasper) We shouldn't need to do this.\n     tcx.sess.track_errors(|| {\n-        time(tcx.sess, \"type collecting\", || {\n+        tcx.sess.time(\"type collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n                 tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n             }\n@@ -319,35 +318,35 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n     if tcx.features().rustc_attrs {\n         tcx.sess.track_errors(|| {\n-            time(tcx.sess, \"outlives testing\", || outlives::test::test_inferred_outlives(tcx));\n+            tcx.sess.time(\"outlives testing\", || outlives::test::test_inferred_outlives(tcx));\n         })?;\n     }\n \n     tcx.sess.track_errors(|| {\n-        time(tcx.sess, \"impl wf inference\", || impl_wf_check::impl_wf_check(tcx));\n+        tcx.sess.time(\"impl wf inference\", || impl_wf_check::impl_wf_check(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n-        time(tcx.sess, \"coherence checking\", || coherence::check_coherence(tcx));\n+        tcx.sess.time(\"coherence checking\", || coherence::check_coherence(tcx));\n     })?;\n \n     if tcx.features().rustc_attrs {\n         tcx.sess.track_errors(|| {\n-            time(tcx.sess, \"variance testing\", || variance::test::test_variance(tcx));\n+            tcx.sess.time(\"variance testing\", || variance::test::test_variance(tcx));\n         })?;\n     }\n \n     tcx.sess.track_errors(|| {\n-        time(tcx.sess, \"wf checking\", || check::check_wf_new(tcx));\n+        tcx.sess.time(\"wf checking\", || check::check_wf_new(tcx));\n     })?;\n \n-    time(tcx.sess, \"item-types checking\", || {\n+    tcx.sess.time(\"item-types checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n             tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n         }\n     });\n \n-    time(tcx.sess, \"item-bodies checking\", || tcx.typeck_item_bodies(LOCAL_CRATE));\n+    tcx.sess.time(\"item-bodies checking\", || tcx.typeck_item_bodies(LOCAL_CRATE));\n \n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);"}]}