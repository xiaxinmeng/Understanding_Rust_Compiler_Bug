{"sha": "28d042e198d700287f0b946b13dab3b99e0ed962", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZDA0MmUxOThkNzAwMjg3ZjBiOTQ2YjEzZGFiM2I5OWUwZWQ5NjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T18:16:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T18:16:12Z"}, "message": "auto merge of #8994 : alexcrichton/rust/upgrade-libuv, r=brson\n\nThis is a reopening of the libuv-upgrade part of #8645. Hopefully this won't\r\ncause random segfaults all over the place. The windows regression in testing\r\nshould also be fixed (it shouldn't build the whole compiler twice).\r\n\r\nA notable difference from before is that gyp is now a git submodule instead of\r\nalways git-cloned at make time. This allows bundling for releases more easily.\r\n\r\nCloses #8850", "tree": {"sha": "ceec36b952fe9b00f2c77c71e2f15fe8d058bafe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceec36b952fe9b00f2c77c71e2f15fe8d058bafe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d042e198d700287f0b946b13dab3b99e0ed962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d042e198d700287f0b946b13dab3b99e0ed962", "html_url": "https://github.com/rust-lang/rust/commit/28d042e198d700287f0b946b13dab3b99e0ed962", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d042e198d700287f0b946b13dab3b99e0ed962/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d39cec65b025ad4c6de50e778ffd1177279b5b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d39cec65b025ad4c6de50e778ffd1177279b5b3d", "html_url": "https://github.com/rust-lang/rust/commit/d39cec65b025ad4c6de50e778ffd1177279b5b3d"}, {"sha": "b4c36c2d1b8079cdb14bd3bf85c1ffc43f1f1d15", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c36c2d1b8079cdb14bd3bf85c1ffc43f1f1d15", "html_url": "https://github.com/rust-lang/rust/commit/b4c36c2d1b8079cdb14bd3bf85c1ffc43f1f1d15"}], "stats": {"total": 262, "additions": 115, "deletions": 147}, "files": [{"sha": "97e327ebfa4f859d31da2c6f4458e2aaba2469e6", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -4,5 +4,8 @@\n \tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n-\turl = https://github.com/brson/libuv.git\n+\turl = https://github.com/alexcrichton/libuv.git\n \tbranch = master\n+[submodule \"src/gyp\"]\n+\tpath = src/gyp\n+\turl = https://git.chromium.org/external/gyp.git"}, {"sha": "4a980edf7673141df16ae7895f9c14c37e9b5f7e", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -12,7 +12,7 @@ PKG_ICO = $(S)src/etc/pkg/rust-logo.ico\n PKG_EXE = $(PKG_DIR)-install.exe\n endif\n \n-PKG_GITMODULES := $(S)src/libuv $(S)src/llvm\n+PKG_GITMODULES := $(S)src/libuv $(S)src/llvm $(S)src/gyp\n \n PKG_FILES := \\\n     $(S)COPYRIGHT                              \\"}, {"sha": "14aa2884b600eacd52bbce1e75f7d5f81ae4460a", "filename": "mk/rt.mk", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -170,36 +170,51 @@ LIBUV_DEPS := $$(wildcard \\\n               $$(S)src/libuv/*/*/*/*)\n endif\n \n+LIBUV_MAKEFILE_$(1)_$(2) := $$(CFG_BUILD_DIR)$$(RT_BUILD_DIR_$(1)_$(2))/libuv/Makefile\n+LIBUV_NO_LOAD = run-benchmarks.target.mk run-tests.target.mk \\\n+\t\tuv_dtrace_header.target.mk uv_dtrace_provider.target.mk\n+\n+export PYTHONPATH := $(PYTHONPATH):$$(S)src/gyp/pylib\n+\n+$$(LIBUV_MAKEFILE_$(1)_$(2)):\n+\t(cd $(S)src/libuv/ && \\\n+\t ./gyp_uv -f make -Dtarget_arch=$$(LIBUV_ARCH_$(1)) -D ninja \\\n+\t   -Goutput_dir=$$(@D) --generator-output $$(@D))\n+\n # XXX: Shouldn't need platform-specific conditions here\n ifdef CFG_WINDOWSY_$(1)\n $$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/$$(RT_BUILD_DIR_$(1)_$(2))/libuv\" \\\n-\t\tOS=mingw \\\n+\t$$(Q)$$(MAKE) -C $$(S)src/libuv -f Makefile.mingw \\\n+\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tAR=\"$$(AR_$(1))\" \\\n \t\tV=$$(VERBOSE)\n+\t$$(Q)cp $$(S)src/libuv/libuv.a $$@\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n+\t$$(Q)$$(MAKE) -C $$(@D) \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t \tLINK=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tPLATFORM=android \\\n-\t\tBUILDTYPE=Release \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/$$(RT_BUILD_DIR_$(1)_$(2))/libuv\" \\\n \t\thost=android OS=linux \\\n+\t\tbuilddir=\".\" \\\n+\t\tBUILDTYPE=Release \\\n+\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n \t\tV=$$(VERBOSE)\n else\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n+\t$$(Q)$$(MAKE) -C $$(@D) \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n-\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/$$(RT_BUILD_DIR_$(1)_$(2))/libuv\" \\\n+\t\tbuilddir=\".\" \\\n+\t\tBUILDTYPE=Release \\\n+\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n \t\tV=$$(VERBOSE)\n endif\n "}, {"sha": "f407f09c94e00d2d570e8e42114e3f6848b2deb2", "filename": "src/gyp", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgyp?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -0,0 +1 @@\n+Subproject commit f407f09c94e00d2d570e8e42114e3f6848b2deb2"}, {"sha": "b533ebe923b7c87d55cb4096d5233e6c252a3b8d", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -182,7 +182,7 @@ mod test {\n         do run_in_newsched_task {\n             let mut called = false;\n             do io_error::cond.trap(|e| {\n-                assert!(e.kind == ConnectionRefused);\n+                assert_eq!(e.kind, ConnectionRefused);\n                 called = true;\n             }).inside {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };"}, {"sha": "83a7e64b1397f6b944667d1029a1a9e282dd5b1a", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -17,7 +17,7 @@ use ptr::null;\n use rt::uv::uvll;\n use rt::uv::uvll::UV_GETADDRINFO;\n use rt::uv::{Loop, UvError, NativeHandle};\n-use rt::uv::status_to_maybe_uv_error_with_loop;\n+use rt::uv::status_to_maybe_uv_error;\n use rt::uv::net::UvAddrInfo;\n \n type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>);\n@@ -90,8 +90,7 @@ impl GetAddrInfoRequest {\n                                      status: c_int,\n                                      res: *uvll::addrinfo) {\n             let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n-            let loop_ = req.get_loop();\n-            let err = status_to_maybe_uv_error_with_loop(loop_.native_handle(), status);\n+            let err = status_to_maybe_uv_error(status);\n             let addrinfo = UvAddrInfo(res);\n             let data = req.get_req_data();\n             (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);"}, {"sha": "ff7bb9dd03abcf8403fd40a0d703e44c2c339618", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -34,7 +34,7 @@ impl AsyncWatcher {\n \n         extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             let data = watcher.get_watcher_data();\n             let cb = data.async_cb.get_ref();\n             (*cb)(watcher, status);"}, {"sha": "45a5fce3f1e8aa0e33575244b98897eb3f73a4f8", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -12,7 +12,7 @@ use prelude::*;\n use ptr::null;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n-             status_to_maybe_uv_error_with_loop, UvError};\n+             status_to_maybe_uv_error, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n@@ -62,7 +62,7 @@ impl FsRequest {\n     pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n           -> Result<int, UvError> {\n         let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n@@ -83,11 +83,11 @@ impl FsRequest {\n     }\n     pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n         let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(loop_, result);\n+        sync_cleanup(result);\n     }\n     pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n         let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n@@ -140,9 +140,9 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n     }\n }\n \n-fn sync_cleanup(loop_: &Loop, result: int)\n+fn sync_cleanup(result: int)\n     -> Result<int, UvError> {\n-    match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n+    match status_to_maybe_uv_error(result as i32) {\n         Some(err) => Err(err),\n         None => Ok(result)\n     }\n@@ -186,7 +186,7 @@ impl FileDescriptor {\n     pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn read_common(&mut self, loop_: &Loop, buf: Buf,\n@@ -214,7 +214,7 @@ impl FileDescriptor {\n     pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n \n     fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n@@ -236,12 +236,11 @@ impl FileDescriptor {\n     }\n     pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n         let result = self.close_common(loop_, None);\n-        sync_cleanup(loop_, result)\n+        sync_cleanup(result)\n     }\n }\n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n-    let loop_ = req.get_loop();\n     // pull the user cb out of the req data\n     let cb = {\n         let data = req.get_req_data();\n@@ -252,8 +251,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n     // in uv_fs_open calls, the result will be the fd in the\n     // case of success, otherwise it's -1 indicating an error\n     let result = req.get_result();\n-    let status = status_to_maybe_uv_error_with_loop(\n-        loop_.native_handle(), result);\n+    let status = status_to_maybe_uv_error(result);\n     // we have a req and status, call the user cb..\n     // only giving the user a ref to the FsRequest, as we\n     // have to clean it up, afterwards (and they aren't really"}, {"sha": "8cbcd7b77c0824fdea0b1df2e1234cdc0a412b3c", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -43,7 +43,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(idle_watcher, status);\n         }\n     }\n@@ -57,7 +57,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(idle_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(idle_watcher, status);\n         }\n     }"}, {"sha": "451d454d2d822262c4279ca94f379cb8f0e29b98", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -204,12 +204,12 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n // XXX: Need to define the error constants like EOF so they can be\n // compared to the UvError type\n \n-pub struct UvError(uvll::uv_err_t);\n+pub struct UvError(c_int);\n \n impl UvError {\n     pub fn name(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n+            let inner = match self { &UvError(a) => a };\n             let name_str = uvll::err_name(inner);\n             assert!(name_str.is_not_null());\n             from_c_str(name_str)\n@@ -218,15 +218,15 @@ impl UvError {\n \n     pub fn desc(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n+            let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::strerror(inner);\n             assert!(desc_str.is_not_null());\n             from_c_str(desc_str)\n         }\n     }\n \n     pub fn is_eof(&self) -> bool {\n-        self.code == uvll::EOF\n+        **self == uvll::EOF\n     }\n }\n \n@@ -238,38 +238,30 @@ impl ToStr for UvError {\n \n #[test]\n fn error_smoke_test() {\n-    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n-    let err: UvError = UvError(err);\n+    let err: UvError = UvError(uvll::EOF);\n     assert_eq!(err.to_str(), ~\"EOF: end of file\");\n }\n \n-pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n-    unsafe {\n-        let loop_ = watcher.event_loop();\n-        UvError(uvll::last_error(loop_.native_handle()))\n-    }\n-}\n-\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     unsafe {\n         // Importing error constants\n         use rt::uv::uvll::*;\n         use rt::io::*;\n \n         // uv error descriptions are static\n-        let c_desc = uvll::strerror(&*uverr);\n+        let c_desc = uvll::strerror(*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n-        let kind = match uverr.code {\n+        let kind = match *uverr {\n             UNKNOWN => OtherIoError,\n             OK => OtherIoError,\n             EOF => EndOfFile,\n             EACCES => PermissionDenied,\n             ECONNREFUSED => ConnectionRefused,\n             ECONNRESET => ConnectionReset,\n             EPIPE => BrokenPipe,\n-            _ => {\n-                rtdebug!(\"uverr.code %u\", uverr.code as uint);\n+            err => {\n+                rtdebug!(\"uverr.code %d\", err as int);\n                 // XXX: Need to map remaining uv error types\n                 OtherIoError\n             }\n@@ -284,30 +276,12 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n }\n \n /// Given a uv handle, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error_with_loop(\n-    loop_: *uvll::uv_loop_t,\n-    status: c_int) -> Option<UvError> {\n-    if status != -1 {\n+pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError>\n+{\n+    if status >= 0 {\n         None\n     } else {\n-        unsafe {\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-/// Given a uv handle, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n-                                                                 status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n-            status_to_maybe_uv_error_with_loop(loop_, status)\n-        }\n+        Some(UvError(status))\n     }\n }\n "}, {"sha": "2535e40ba4f0f641f5b87c5dc8d348fe02bf11e4", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -16,7 +16,6 @@ use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n@@ -161,7 +160,7 @@ impl StreamWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream_watcher, nread as c_int);\n+            let status = status_to_maybe_uv_error(nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n     }\n@@ -191,7 +190,7 @@ impl StreamWatcher {\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             cb(stream_watcher, status);\n         }\n     }\n@@ -256,7 +255,7 @@ impl TcpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(last_uv_error(self)),\n+                _ => Err(UvError(result)),\n             }\n         }\n     }\n@@ -284,7 +283,7 @@ impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(stream_watcher, status);\n+                let status = status_to_maybe_uv_error(status);\n                 cb(stream_watcher, status);\n             }\n         }\n@@ -307,7 +306,7 @@ impl TcpWatcher {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(stream_watcher, status);\n         }\n     }\n@@ -351,7 +350,7 @@ impl UdpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(last_uv_error(self)),\n+                _ => Err(UvError(result)),\n             }\n         }\n     }\n@@ -384,7 +383,7 @@ impl UdpWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n+            let status = status_to_maybe_uv_error(nread as c_int);\n             let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n@@ -419,7 +418,7 @@ impl UdpWatcher {\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n             let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(udp_watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             cb(udp_watcher, status);\n         }\n     }"}, {"sha": "7b09cf2eb0e3ab058f4c2cf2d65526585964e758", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -43,7 +43,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(watcher, status);\n+            let status = status_to_maybe_uv_error(status);\n             (*cb)(watcher, status);\n         }\n     }"}, {"sha": "c9b12e47f9226a7a3003daa79590d1bcf6e84645", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -154,7 +154,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n     };\n \n     if r != 0 {\n-        let status = status_to_maybe_uv_error(handle, r);\n+        let status = status_to_maybe_uv_error(r);\n         return Err(uv_error_to_io_error(status.unwrap()));\n     }\n \n@@ -728,7 +728,7 @@ impl RtioTcpAcceptor for UvTcpAcceptor {\n                 uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.listener.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -741,7 +741,7 @@ impl RtioTcpAcceptor for UvTcpAcceptor {\n                 uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.listener.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -862,7 +862,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -873,7 +873,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -887,7 +887,7 @@ impl RtioTcpStream for UvTcpStream {\n                                     delay_in_seconds as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -900,7 +900,7 @@ impl RtioTcpStream for UvTcpStream {\n                 uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1012,7 +1012,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1028,7 +1028,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1042,7 +1042,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1056,7 +1056,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1070,7 +1070,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1084,7 +1084,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1098,7 +1098,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1112,7 +1112,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher, r) {\n+            match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }"}, {"sha": "4ef97677bd353b54b4118550d3cb469641c61e8e", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -37,21 +37,34 @@ use libc::{malloc, free};\n use libc;\n use prelude::*;\n use ptr;\n-use str;\n use vec;\n \n-pub static UNKNOWN: c_int = -1;\n+pub use self::errors::*;\n+\n pub static OK: c_int = 0;\n-pub static EOF: c_int = 1;\n-pub static EADDRINFO: c_int = 2;\n-pub static EACCES: c_int = 3;\n-pub static ECONNREFUSED: c_int = 12;\n-pub static ECONNRESET: c_int = 13;\n-pub static EPIPE: c_int = 36;\n+pub static EOF: c_int = -4095;\n+pub static UNKNOWN: c_int = -4094;\n+\n+// uv-errno.h redefines error codes for windows, but not for unix...\n+\n+#[cfg(windows)]\n+pub mod errors {\n+    use libc::c_int;\n \n-pub struct uv_err_t {\n-    code: c_int,\n-    sys_errno_: c_int\n+    pub static EACCES: c_int = -4093;\n+    pub static ECONNREFUSED: c_int = -4079;\n+    pub static ECONNRESET: c_int = -4078;\n+    pub static EPIPE: c_int = -4048;\n+}\n+#[cfg(not(windows))]\n+pub mod errors {\n+    use libc;\n+    use libc::c_int;\n+\n+    pub static EACCES: c_int = -libc::EACCES;\n+    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n+    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n+    pub static EPIPE: c_int = -libc::EPIPE;\n }\n \n pub struct uv_buf_t {\n@@ -537,20 +550,12 @@ pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n     return rust_uv_read_stop(stream as *c_void);\n }\n \n-pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_last_error(loop_handle);\n-}\n-\n-pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+pub unsafe fn strerror(err: c_int) -> *c_char {\n     #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_strerror(err);\n }\n-pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+pub unsafe fn err_name(err: c_int) -> *c_char {\n     #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_err_name(err);\n }\n \n@@ -787,23 +792,6 @@ pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n     rust_uv_freeaddrinfo(ai);\n }\n \n-pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg);\n-}\n-\n-pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    uv_err_data { err_name: err_name, err_msg: err_msg }\n-}\n-\n pub struct uv_err_data {\n     err_name: ~str,\n     err_msg: ~str,\n@@ -835,9 +823,8 @@ extern {\n                           cb: uv_async_cb) -> c_int;\n     fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n     fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n-    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n-    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_strerror(err: c_int) -> *c_char;\n+    fn rust_uv_err_name(err: c_int) -> *c_char;\n     fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n     fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n     fn rust_uv_free_ip4_addr(addr: *sockaddr_in);"}, {"sha": "d88cf5652a1afb23939da0bae86c70ec521b9921", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -1 +1 @@\n-Subproject commit dfae9c3e958dc086d9c0ab068cd76d196c95a433\n+Subproject commit d88cf5652a1afb23939da0bae86c70ec521b9921"}, {"sha": "bfdf0e67a9b81f8616d7873edf9b0d8d4f7a543c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -329,20 +329,13 @@ rust_uv_get_len_from_buf(uv_buf_t buf) {\n     return buf.len;\n }\n \n-extern \"C\" uv_err_t\n-rust_uv_last_error(uv_loop_t* loop) {\n-    return uv_last_error(loop);\n-}\n-\n extern \"C\" const char*\n-rust_uv_strerror(uv_err_t* err_ptr) {\n-    uv_err_t err = *err_ptr;\n+rust_uv_strerror(int err) {\n     return uv_strerror(err);\n }\n \n extern \"C\" const char*\n-rust_uv_err_name(uv_err_t* err_ptr) {\n-    uv_err_t err = *err_ptr;\n+rust_uv_err_name(int err) {\n     return uv_err_name(err);\n }\n "}, {"sha": "bf3500e4c724e12548cd245955d8a83ff8d5df1f", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/28d042e198d700287f0b946b13dab3b99e0ed962/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=28d042e198d700287f0b946b13dab3b99e0ed962", "patch": "@@ -47,7 +47,6 @@ rust_uv_timer_start\n rust_uv_timer_stop\n rust_uv_tcp_init\n rust_uv_buf_init\n-rust_uv_last_error\n rust_uv_strerror\n rust_uv_err_name\n rust_uv_ip4_addr"}]}