{"sha": "f74fd03999bed3686195a1a7d42259ae11331e32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NGZkMDM5OTliZWQzNjg2MTk1YTFhN2Q0MjI1OWFlMTEzMzFlMzI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-08T17:20:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:22:44Z"}, "message": "Make QueryAccessor argument a type.", "tree": {"sha": "f51e9f820189b06caebe67f3fc0f781f59ce53eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f51e9f820189b06caebe67f3fc0f781f59ce53eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f74fd03999bed3686195a1a7d42259ae11331e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f74fd03999bed3686195a1a7d42259ae11331e32", "html_url": "https://github.com/rust-lang/rust/commit/f74fd03999bed3686195a1a7d42259ae11331e32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f74fd03999bed3686195a1a7d42259ae11331e32/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c1c90bb5c351d3577a803d0ac2abf9ea213e56b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c1c90bb5c351d3577a803d0ac2abf9ea213e56b", "html_url": "https://github.com/rust-lang/rust/commit/8c1c90bb5c351d3577a803d0ac2abf9ea213e56b"}], "stats": {"total": 216, "additions": 127, "deletions": 89}, "files": [{"sha": "7dd858142daa70f5a99295d6e554fc767ac1a4d0", "filename": "src/librustc/ty/query/caches.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -23,7 +23,7 @@ pub(crate) trait QueryCache: Default {\n     /// to compute it.\n     fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Self>,\n+        state: &'tcx QueryState<TyCtxt<'tcx>, Self>,\n         get_cache: GetCache,\n         key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n@@ -32,10 +32,10 @@ pub(crate) trait QueryCache: Default {\n     ) -> R\n     where\n         GetCache: for<'a> Fn(\n-            &'a mut QueryStateShard<'tcx, Self::Key, Self::Sharded>,\n+            &'a mut QueryStateShard<TyCtxt<'tcx>, Self::Key, Self::Sharded>,\n         ) -> &'a mut Self::Sharded,\n         OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Self::Key, QueryLookup<'tcx, Self::Key, Self::Sharded>) -> R;\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'tcx, TyCtxt<'tcx>, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n@@ -78,17 +78,18 @@ impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n     #[inline(always)]\n     fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Self>,\n+        state: &'tcx QueryState<TyCtxt<'tcx>, Self>,\n         get_cache: GetCache,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        GetCache:\n-            for<'a> Fn(&'a mut QueryStateShard<'tcx, K, Self::Sharded>) -> &'a mut Self::Sharded,\n+        GetCache: for<'a> Fn(\n+            &'a mut QueryStateShard<TyCtxt<'tcx>, K, Self::Sharded>,\n+        ) -> &'a mut Self::Sharded,\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, K, Self::Sharded>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, TyCtxt<'tcx>, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;"}, {"sha": "eaa1006791b565c152133943dcddac43c64fdabc", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -23,28 +23,32 @@ pub trait QueryConfig<CTX> {\n     type Value: Clone;\n }\n \n-pub(crate) trait QueryAccessors<'tcx>: QueryConfig<TyCtxt<'tcx>> {\n+pub trait QueryContext: Copy {\n+    type Query;\n+}\n+\n+pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: DepKind;\n \n     type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self::Cache>;\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;\n \n-    fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n+    fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value;\n+    fn compute(tcx: CTX, key: Self::Key) -> Self::Value;\n \n     fn hash_result(hcx: &mut StableHashingContext<'_>, result: &Self::Value)\n     -> Option<Fingerprint>;\n \n-    fn handle_cycle_error(tcx: TyCtxt<'tcx>, error: CycleError<'tcx>) -> Self::Value;\n+    fn handle_cycle_error(tcx: CTX, error: CycleError<CTX>) -> Self::Value;\n }\n \n-pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n+pub(crate) trait QueryDescription<'tcx>: QueryAccessors<TyCtxt<'tcx>> {\n     fn describe(tcx: TyCtxt<'_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n@@ -57,7 +61,11 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M> QueryDescription<'tcx> for M\n+where\n+    M: QueryAccessors<TyCtxt<'tcx>, Key = DefId>,\n+    //M::Cache: QueryCache<DefId, M::Value>,\n+{\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "e52c25d86b13ab9986123f5d79d7bcf039809516", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -1,5 +1,6 @@\n use crate::dep_graph::DepKind;\n use crate::ty::context::TyCtxt;\n+use crate::ty::query::config::QueryContext;\n use crate::ty::query::plumbing::CycleError;\n use crate::ty::query::Query;\n use crate::ty::tls;\n@@ -27,13 +28,13 @@ use {\n \n /// Represents a span and a query key.\n #[derive(Clone, Debug)]\n-pub struct QueryInfo<'tcx> {\n+pub struct QueryInfo<CTX: QueryContext> {\n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n-    pub query: Query<'tcx>,\n+    pub query: CTX::Query,\n }\n \n-type QueryMap<'tcx> = FxHashMap<QueryJobId, QueryJobInfo<'tcx>>;\n+type QueryMap<'tcx> = FxHashMap<QueryJobId, QueryJobInfo<TyCtxt<'tcx>>>;\n \n /// A value uniquely identifiying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n@@ -72,19 +73,19 @@ impl QueryJobId {\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a, 'tcx>(self, map: &'a QueryMap<'tcx>) -> Option<&'a QueryLatch<'tcx>> {\n+    fn latch<'a, 'tcx>(self, map: &'a QueryMap<'tcx>) -> Option<&'a QueryLatch<TyCtxt<'tcx>>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n-pub struct QueryJobInfo<'tcx> {\n-    pub info: QueryInfo<'tcx>,\n-    pub job: QueryJob<'tcx>,\n+pub struct QueryJobInfo<CTX: QueryContext> {\n+    pub info: QueryInfo<CTX>,\n+    pub job: QueryJob<CTX>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob<'tcx> {\n+pub struct QueryJob<CTX: QueryContext> {\n     pub id: QueryShardJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n@@ -95,12 +96,12 @@ pub struct QueryJob<'tcx> {\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch<'tcx>>,\n+    latch: Option<QueryLatch<CTX>>,\n \n-    dummy: PhantomData<QueryLatch<'tcx>>,\n+    dummy: PhantomData<QueryLatch<CTX>>,\n }\n \n-impl<'tcx> QueryJob<'tcx> {\n+impl<CTX: QueryContext> QueryJob<CTX> {\n     /// Creates a new query job.\n     pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId>) -> Self {\n         QueryJob {\n@@ -114,15 +115,15 @@ impl<'tcx> QueryJob<'tcx> {\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self, _id: QueryJobId) -> QueryLatch<'tcx> {\n+    pub(super) fn latch(&mut self, _id: QueryJobId) -> QueryLatch<CTX> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n         self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn latch(&mut self, id: QueryJobId) -> QueryLatch<'tcx> {\n+    pub(super) fn latch(&mut self, id: QueryJobId) -> QueryLatch<CTX> {\n         QueryLatch { id, dummy: PhantomData }\n     }\n \n@@ -138,14 +139,18 @@ impl<'tcx> QueryJob<'tcx> {\n \n #[cfg(not(parallel_compiler))]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<'tcx> {\n+pub(super) struct QueryLatch<CTX> {\n     id: QueryJobId,\n-    dummy: PhantomData<&'tcx ()>,\n+    dummy: PhantomData<CTX>,\n }\n \n #[cfg(not(parallel_compiler))]\n-impl<'tcx> QueryLatch<'tcx> {\n-    pub(super) fn find_cycle_in_stack(&self, tcx: TyCtxt<'tcx>, span: Span) -> CycleError<'tcx> {\n+impl<'tcx> QueryLatch<TyCtxt<'tcx>> {\n+    pub(super) fn find_cycle_in_stack(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> CycleError<TyCtxt<'tcx>> {\n         let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n \n         // Get the current executing query (waiter) and find the waitee amongst its parents\n@@ -181,44 +186,50 @@ impl<'tcx> QueryLatch<'tcx> {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter<'tcx> {\n+struct QueryWaiter<CTX: QueryContext> {\n     query: Option<QueryJobId>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError<'tcx>>>,\n+    cycle: Lock<Option<CycleError<CTX>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<'tcx> QueryWaiter<'tcx> {\n+impl<CTX: QueryContext> QueryWaiter<CTX> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo<'tcx> {\n+struct QueryLatchInfo<CTX: QueryContext> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter<'tcx>>>,\n+    waiters: Vec<Lrc<QueryWaiter<CTX>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<'tcx> {\n-    info: Lrc<Mutex<QueryLatchInfo<'tcx>>>,\n+pub(super) struct QueryLatch<CTX: QueryContext> {\n+    info: Lrc<Mutex<QueryLatchInfo<CTX>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<'tcx> QueryLatch<'tcx> {\n+impl<CTX: QueryContext> QueryLatch<CTX> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n         }\n     }\n+}\n \n+#[cfg(parallel_compiler)]\n+impl<'tcx> QueryLatch<TyCtxt<'tcx>> {\n     /// Awaits for the query job to complete.\n-    #[cfg(parallel_compiler)]\n-    pub(super) fn wait_on(&self, tcx: TyCtxt<'tcx>, span: Span) -> Result<(), CycleError<'tcx>> {\n+    pub(super) fn wait_on(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> Result<(), CycleError<TyCtxt<'tcx>>> {\n         tls::with_related_context(tcx, move |icx| {\n             let waiter = Lrc::new(QueryWaiter {\n                 query: icx.query,\n@@ -237,9 +248,12 @@ impl<'tcx> QueryLatch<'tcx> {\n             }\n         })\n     }\n+}\n \n+#[cfg(parallel_compiler)]\n+impl<CTX: QueryContext> QueryLatch<CTX> {\n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<CTX>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -273,7 +287,7 @@ impl<'tcx> QueryLatch<'tcx> {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<'tcx>> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<CTX>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -427,7 +441,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId)>(\n fn remove_cycle<'tcx>(\n     query_map: &QueryMap<'tcx>,\n     jobs: &mut Vec<QueryJobId>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<TyCtxt<'tcx>>>>,\n     tcx: TyCtxt<'tcx>,\n ) -> bool {\n     let mut visited = FxHashSet::default();"}, {"sha": "6506e1f83b43b57020ac2fc1a8f7f2750ea981df", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -4,7 +4,7 @@\n \n use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::QueryDescription;\n+use crate::ty::query::config::{QueryContext, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n@@ -29,38 +29,38 @@ use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(crate) struct QueryStateShard<'tcx, K, C> {\n+pub(crate) struct QueryStateShard<CTX: QueryContext, K, C> {\n     cache: C,\n-    active: FxHashMap<K, QueryResult<'tcx>>,\n+    active: FxHashMap<K, QueryResult<CTX>>,\n \n     /// Used to generate unique ids for active jobs.\n     jobs: u32,\n }\n \n-impl<'tcx, K, C> QueryStateShard<'tcx, K, C> {\n+impl<CTX: QueryContext, K, C> QueryStateShard<CTX, K, C> {\n     fn get_cache(&mut self) -> &mut C {\n         &mut self.cache\n     }\n }\n \n-impl<'tcx, K, C: Default> Default for QueryStateShard<'tcx, K, C> {\n-    fn default() -> QueryStateShard<'tcx, K, C> {\n+impl<CTX: QueryContext, K, C: Default> Default for QueryStateShard<CTX, K, C> {\n+    fn default() -> QueryStateShard<CTX, K, C> {\n         QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub(crate) struct QueryState<'tcx, C: QueryCache> {\n+pub(crate) struct QueryState<CTX: QueryContext, C: QueryCache> {\n     cache: C,\n-    shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n+    shards: Sharded<QueryStateShard<CTX, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: AtomicUsize,\n }\n \n-impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n     pub(super) fn get_lookup<K2: Hash>(\n         &'tcx self,\n         key: &K2,\n-    ) -> QueryLookup<'tcx, C::Key, C::Sharded> {\n+    ) -> QueryLookup<'tcx, CTX, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -75,16 +75,16 @@ impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult<'tcx> {\n+enum QueryResult<CTX: QueryContext> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob<'tcx>),\n+    Started(QueryJob<CTX>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n     pub(super) fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n@@ -101,8 +101,8 @@ impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n     pub(super) fn try_collect_active_jobs(\n         &self,\n         kind: DepKind,\n-        make_query: fn(C::Key) -> Query<'tcx>,\n-        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<'tcx>>,\n+        make_query: fn(C::Key) -> CTX::Query,\n+        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<CTX>>,\n     ) -> Option<()>\n     where\n         C::Key: Clone,\n@@ -128,8 +128,8 @@ impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n     }\n }\n \n-impl<'tcx, C: QueryCache> Default for QueryState<'tcx, C> {\n-    fn default() -> QueryState<'tcx, C> {\n+impl<CTX: QueryContext, C: QueryCache> Default for QueryState<CTX, C> {\n+    fn default() -> QueryState<CTX, C> {\n         QueryState {\n             cache: C::default(),\n             shards: Default::default(),\n@@ -140,26 +140,26 @@ impl<'tcx, C: QueryCache> Default for QueryState<'tcx, C> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub(crate) struct QueryLookup<'tcx, K, C> {\n+pub(crate) struct QueryLookup<'tcx, CTX: QueryContext, K, C> {\n     pub(super) key_hash: u64,\n     shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, K, C>>,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<CTX, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, C>\n+struct JobOwner<'tcx, CTX: QueryContext, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n     C::Value: Clone,\n {\n-    state: &'tcx QueryState<'tcx, C>,\n+    state: &'tcx QueryState<CTX, C>,\n     key: C::Key,\n     id: QueryJobId,\n }\n \n-impl<'tcx, C: QueryCache> JobOwner<'tcx, C>\n+impl<'tcx, C: QueryCache> JobOwner<'tcx, TyCtxt<'tcx>, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n@@ -178,7 +178,7 @@ where\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n         key: &C::Key,\n-        mut lookup: QueryLookup<'tcx, C::Key, C::Sharded>,\n+        mut lookup: QueryLookup<'tcx, TyCtxt<'tcx>, C::Key, C::Sharded>,\n     ) -> TryGetJob<'tcx, C>\n     where\n         Q: QueryDescription<'tcx, Key = C::Key, Value = C::Value, Cache = C>,\n@@ -258,7 +258,14 @@ where\n             return TryGetJob::JobCompleted(cached);\n         }\n     }\n+}\n \n+impl<'tcx, CTX: QueryContext, C: QueryCache> JobOwner<'tcx, CTX, C>\n+where\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n@@ -295,7 +302,7 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, C: QueryCache> Drop for JobOwner<'tcx, C>\n+impl<'tcx, CTX: QueryContext, C: QueryCache> Drop for JobOwner<'tcx, CTX, C>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n     C::Value: Clone,\n@@ -322,10 +329,10 @@ where\n }\n \n #[derive(Clone)]\n-pub(crate) struct CycleError<'tcx> {\n+pub(crate) struct CycleError<CTX: QueryContext> {\n     /// The query and related span that uses the cycle.\n-    pub(super) usage: Option<(Span, Query<'tcx>)>,\n-    pub(super) cycle: Vec<QueryInfo<'tcx>>,\n+    pub(super) usage: Option<(Span, CTX::Query)>,\n+    pub(super) cycle: Vec<QueryInfo<CTX>>,\n }\n \n /// The result of `try_start`.\n@@ -335,7 +342,7 @@ where\n     C::Value: Clone,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, C>),\n+    NotYetStarted(JobOwner<'tcx, TyCtxt<'tcx>, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -347,6 +354,10 @@ where\n     Cycle(C::Value),\n }\n \n+impl QueryContext for TyCtxt<'tcx> {\n+    type Query = Query<'tcx>;\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n@@ -383,7 +394,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<'tcx>,\n+        CycleError { usage, cycle: stack }: CycleError<TyCtxt<'tcx>>,\n     ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n@@ -476,7 +487,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     fn try_get_cached<C, R, OnHit, OnMiss>(\n         self,\n-        state: &'tcx QueryState<'tcx, C>,\n+        state: &'tcx QueryState<TyCtxt<'tcx>, C>,\n         key: C::Key,\n         // `on_hit` can be called while holding a lock to the query cache\n         on_hit: OnHit,\n@@ -485,11 +496,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         C: QueryCache,\n         OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(C::Key, QueryLookup<'tcx, C::Key, C::Sharded>) -> R,\n+        OnMiss: FnOnce(C::Key, QueryLookup<'tcx, TyCtxt<'tcx>, C::Key, C::Sharded>) -> R,\n     {\n         state.cache.lookup(\n             state,\n-            QueryStateShard::<C::Key, C::Sharded>::get_cache,\n+            QueryStateShard::<TyCtxt<'tcx>, C::Key, C::Sharded>::get_cache,\n             key,\n             |value, index| {\n                 if unlikely!(self.prof.enabled()) {\n@@ -529,7 +540,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         span: Span,\n         key: Q::Key,\n-        lookup: QueryLookup<'tcx, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n+        lookup: QueryLookup<'tcx, TyCtxt<'tcx>, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n     ) -> Q::Value {\n         let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n@@ -690,7 +701,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn force_query_with_job<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'tcx, Q::Cache>,\n+        job: JobOwner<'tcx, TyCtxt<'tcx>, Q::Cache>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -963,15 +974,15 @@ macro_rules! define_queries_inner {\n             const CATEGORY: ProfileCategory = $category;\n         }\n \n-        impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n+        impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n             const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n \n             type Cache = query_storage!([$($modifiers)*][$K, $V]);\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self::Cache> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<TyCtxt<$tcx>, Self::Cache> {\n                 &tcx.queries.$name\n             }\n \n@@ -1002,7 +1013,7 @@ macro_rules! define_queries_inner {\n \n             fn handle_cycle_error(\n                 tcx: TyCtxt<'tcx>,\n-                error: CycleError<'tcx>\n+                error: CycleError<TyCtxt<'tcx>>\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }\n@@ -1124,8 +1135,8 @@ macro_rules! define_queries_struct {\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n             $($(#[$attr])*  $name: QueryState<\n-                $tcx,\n-                <queries::$name<$tcx> as QueryAccessors<'tcx>>::Cache,\n+                TyCtxt<$tcx>,\n+                <queries::$name<$tcx> as QueryAccessors<TyCtxt<'tcx>>>::Cache,\n             >,)*\n         }\n \n@@ -1145,12 +1156,12 @@ macro_rules! define_queries_struct {\n \n             pub(crate) fn try_collect_active_jobs(\n                 &self\n-            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n+            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<TyCtxt<'tcx>>>> {\n                 let mut jobs = FxHashMap::default();\n \n                 $(\n                     self.$name.try_collect_active_jobs(\n-                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n+                        <queries::$name<'tcx> as QueryAccessors<TyCtxt<'tcx>>>::DEP_KIND,\n                         Query::$name,\n                         &mut jobs,\n                     )?;"}, {"sha": "a540a18a19ffa16e6a37f47633f78744eaf11356", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -160,7 +160,7 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<'tcx, C>,\n+    query_state: &QueryState<TyCtxt<'tcx>, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n     C: QueryCache,"}, {"sha": "e6578d1eb5ff45b8153f94190bc99095631af2da", "filename": "src/librustc/ty/query/stats.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74fd03999bed3686195a1a7d42259ae11331e32/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=f74fd03999bed3686195a1a7d42259ae11331e32", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::config::{QueryAccessors, QueryContext};\n use crate::ty::query::plumbing::QueryState;\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n@@ -38,7 +38,10 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<'tcx, C: QueryCache>(name: &'static str, map: &QueryState<'tcx, C>) -> QueryStats {\n+fn stats<CTX: QueryContext, C: QueryCache>(\n+    name: &'static str,\n+    map: &QueryState<CTX, C>,\n+) -> QueryStats {\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n@@ -124,7 +127,8 @@ macro_rules! print_stats {\n \n             $($(\n                 queries.push(stats::<\n-                    <queries::$name<'_> as QueryAccessors<'_>>::Cache,\n+                    TyCtxt<'_>,\n+                    <queries::$name<'_> as QueryAccessors<TyCtxt<'_>>>::Cache,\n                 >(\n                     stringify!($name),\n                     &tcx.queries.$name,"}]}