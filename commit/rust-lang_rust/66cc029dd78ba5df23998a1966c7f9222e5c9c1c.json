{"sha": "66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2Y2MwMjlkZDc4YmE1ZGYyMzk5OGExOTY2YzdmOTIyMmU1YzljMWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-28T05:00:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: assert `ty::print::FORCE_ABSOLUTE` isn't needed anymore.", "tree": {"sha": "b7ecda5c1caf87b784699a5e33d1cb6a04f486ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7ecda5c1caf87b784699a5e33d1cb6a04f486ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "html_url": "https://github.com/rust-lang/rust/commit/66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66cc029dd78ba5df23998a1966c7f9222e5c9c1c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2", "html_url": "https://github.com/rust-lang/rust/commit/df6650f38cb2bed40fb1b1fe5d6a6e08dab963e2"}], "stats": {"total": 81, "additions": 63, "deletions": 18}, "files": [{"sha": "04f0710436b5d0497b0edaae876a840dc86d80a5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/66cc029dd78ba5df23998a1966c7f9222e5c9c1c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66cc029dd78ba5df23998a1966c7f9222e5c9c1c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "patch": "@@ -58,7 +58,7 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use std::{cmp, fmt};\n+use std::{cmp, fmt, iter};\n use syntax_pos::{Pos, Span};\n \n mod note;\n@@ -444,20 +444,69 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         terr: &TypeError<'tcx>,\n         sp: Span,\n     ) {\n+        use hir::def::Namespace;\n+        use hir::def_id::CrateNum;\n+        use ty::print::{PrintCx, Printer};\n+        use ty::subst::Substs;\n+\n+        struct AbsolutePathPrinter;\n+\n+        struct NonTrivialPath;\n+\n+        impl Printer for AbsolutePathPrinter {\n+            type Path = Result<Vec<String>, NonTrivialPath>;\n+\n+            fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+                Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n+            }\n+            fn path_qualified<'tcx>(\n+                self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+                _impl_prefix: Option<Self::Path>,\n+                _self_ty: Ty<'tcx>,\n+                _trait_ref: Option<ty::TraitRef<'tcx>>,\n+                _ns: Namespace,\n+            ) -> Self::Path {\n+                Err(NonTrivialPath)\n+            }\n+            fn path_append(\n+                self: &mut PrintCx<'_, '_, '_, Self>,\n+                path: Self::Path,\n+                text: &str,\n+            ) -> Self::Path {\n+                let mut path = path?;\n+                path.push(text.to_string());\n+                Ok(path)\n+            }\n+            fn path_generic_args<'tcx>(\n+                self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+                path: Self::Path,\n+                _params: &[ty::GenericParamDef],\n+                _substs: &'tcx Substs<'tcx>,\n+                _ns: Namespace,\n+                _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+            ) -> Self::Path {\n+                path\n+            }\n+        }\n+\n         let report_path_match = |err: &mut DiagnosticBuilder<'_>, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n-                let exp_path = self.tcx.def_path_str(did1);\n-                let found_path = self.tcx.def_path_str(did2);\n-                // HACK(eddyb) switch form `with_forced_absolute_paths`\n-                // to a custom implementation of `ty::print::Printer`.\n-                let (exp_abs_path, found_abs_path) = ty::print::with_forced_absolute_paths(|| {\n-                    (self.tcx.def_path_str(did1), self.tcx.def_path_str(did2))\n-                });\n+                let abs_path = |def_id| {\n+                    PrintCx::new(self.tcx, AbsolutePathPrinter)\n+                        .print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n+                };\n+\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path || exp_abs_path == found_abs_path {\n+                let same_path = || -> Result<_, NonTrivialPath> {\n+                    Ok(\n+                        self.tcx.def_path_str(did1) == self.tcx.def_path_str(did2) ||\n+                        abs_path(did1)? == abs_path(did2)?\n+                    )\n+                };\n+                if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(\n                         sp,"}, {"sha": "dca9ddc4a5b4089234bd261aaccf5b51c1573468", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66cc029dd78ba5df23998a1966c7f9222e5c9c1c/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66cc029dd78ba5df23998a1966c7f9222e5c9c1c/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=66cc029dd78ba5df23998a1966c7f9222e5c9c1c", "patch": "@@ -722,9 +722,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n         // both here and in `default_print_def_path`.\n         let generics = substs.map(|_| self.tcx.generics_of(def_id));\n-        if // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n-            !FORCE_ABSOLUTE.with(|force| force.get()) &&\n-            generics.as_ref().and_then(|g| g.parent).is_none() {\n+        // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n+        assert!(!FORCE_ABSOLUTE.with(|force| force.get()));\n+        if generics.as_ref().and_then(|g| g.parent).is_none() {\n             if let Some(path) = self.try_print_visible_def_path(def_id) {\n                 let path = if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n@@ -742,8 +742,6 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             // Always use types for non-local impls, where types are always\n             // available, and filename/line-number is mostly uninteresting.\n             let use_types =\n-                // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n-                FORCE_ABSOLUTE.with(|force| force.get()) ||\n                 !def_id.is_local() || {\n                     // Otherwise, use filename/line-number if forced.\n                     let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n@@ -766,10 +764,8 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n         // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n-        if FORCE_ABSOLUTE.with(|force| force.get()) {\n-            write!(self.printer, \"{}\", self.tcx.original_crate_name(cnum))?;\n-            return Ok(PrettyPath { empty: false });\n-        }\n+        assert!(!FORCE_ABSOLUTE.with(|force| force.get()));\n+\n         if cnum == LOCAL_CRATE {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired."}]}