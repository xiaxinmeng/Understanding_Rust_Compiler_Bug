{"sha": "18162d3261e4214c0f55479b3fba29d1ed5e634a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MTYyZDMyNjFlNDIxNGMwZjU1NDc5YjNmYmEyOWQxZWQ1ZTYzNGE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-19T21:17:23Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-19T21:30:53Z"}, "message": "Some progress on issue #540.", "tree": {"sha": "d928b05dec53cb2a500c3e8b280e32ad96963fa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d928b05dec53cb2a500c3e8b280e32ad96963fa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18162d3261e4214c0f55479b3fba29d1ed5e634a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18162d3261e4214c0f55479b3fba29d1ed5e634a", "html_url": "https://github.com/rust-lang/rust/commit/18162d3261e4214c0f55479b3fba29d1ed5e634a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18162d3261e4214c0f55479b3fba29d1ed5e634a/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14e5e70462fed497ce8e12e52c1ef099678a8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14e5e70462fed497ce8e12e52c1ef099678a8de", "html_url": "https://github.com/rust-lang/rust/commit/a14e5e70462fed497ce8e12e52c1ef099678a8de"}], "stats": {"total": 122, "additions": 76, "deletions": 46}, "files": [{"sha": "b53f54ec61455a13eb11088a3c55f9c91ed73118", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 76, "deletions": 44, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/18162d3261e4214c0f55479b3fba29d1ed5e634a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18162d3261e4214c0f55479b3fba29d1ed5e634a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=18162d3261e4214c0f55479b3fba29d1ed5e634a", "patch": "@@ -52,7 +52,13 @@ export check_crate;\n \n type ty_table = hashmap[ast::def_id, ty::t];\n \n-type obj_info = rec(ast::obj_field[] obj_fields, ast::node_id this_obj);\n+// Used for typechecking the methods of an object.\n+tag obj_info {\n+    // Regular objects have a node_id at compile time.\n+    regular_obj(ast::obj_field[], ast::node_id);\n+    // Anonymous objects only have a type at compile time.\n+    anon_obj(ast::obj_field[], ty::t);\n+}\n \n type crate_ctxt = rec(mutable obj_info[] obj_infos, ty::ctxt tcx);\n \n@@ -622,8 +628,8 @@ mod collect {\n                 ret ty_of_fn_decl(cx, convert, f, fn_info.decl, fn_info.proto,\n                                   tps, some(local_def(it.id)));\n             }\n-            case (ast::item_obj(?obj_info, ?tps, _)) {\n-                auto t_obj = ty_of_obj(cx, it.ident, obj_info, tps);\n+            case (ast::item_obj(?ob, ?tps, _)) {\n+                auto t_obj = ty_of_obj(cx, it.ident, ob, tps);\n                 cx.tcx.tcache.insert(local_def(it.id), t_obj);\n                 ret t_obj;\n             }\n@@ -1196,10 +1202,21 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n     // Add object fields, if any.\n     alt (get_obj_info(ccx)) {\n         case (option::some(?oinfo)) {\n-            for (ast::obj_field f in oinfo.obj_fields) {\n-                auto field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n-                assign(ccx.tcx, vb, locals, local_names, nvi, f.id,\n-                       f.ident, some(field_ty));\n+            alt (oinfo) {\n+                case (regular_obj(?obj_fields, _)) {\n+                    for (ast::obj_field f in obj_fields) {\n+                        auto field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n+                        assign(ccx.tcx, vb, locals, local_names, nvi, f.id,\n+                               f.ident, some(field_ty));\n+                    }\n+                }\n+                case (anon_obj(?obj_fields, _)) {\n+                    for (ast::obj_field f in obj_fields) {\n+                        auto field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n+                        assign(ccx.tcx, vb, locals, local_names, nvi, f.id,\n+                               f.ident, some(field_ty));\n+                    }\n+                }\n             }\n         }\n         case (option::none) {/* no fields */ }\n@@ -2095,16 +2112,30 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             let ty::t this_obj_ty = ty::mk_nil(fcx.ccx.tcx);\n             let option::t[obj_info] this_obj_info = get_obj_info(fcx.ccx);\n             alt (this_obj_info) {\n-                case (\n-                     // If we're inside a current object, grab its type.\n-                     some(?obj_info)) {\n-                    // FIXME: In the case of anonymous objects with methods\n-                    // containing self-calls, this lookup fails because\n-                    // obj_info.this_obj is not in the type cache\n-\n-                    this_obj_ty =\n-                        ty::lookup_item_type(fcx.ccx.tcx,\n-                                             local_def(obj_info.this_obj))._1;\n+                case (some(?oinfo)) {\n+                    alt (oinfo) {\n+                        case (regular_obj(_, ?obj_id)) {\n+                            auto did = local_def(obj_id);\n+                            // Try looking up the current object in the type\n+                            // cache.\n+                            alt (fcx.ccx.tcx.tcache.find(did)) {\n+                                case (some(?tpt)) {\n+                                    // If we're typechecking a self-method on\n+                                    // a regular object, this lookup should\n+                                    // succeed.\n+                                    this_obj_ty = tpt._1;\n+                                }\n+                                case (none) {\n+                                    fcx.ccx.tcx.sess.bug(\n+                                        \"didn't find \" + int::str(did._1) +\n+                                        \" in type cache\");\n+                                }\n+                            }\n+                        }\n+                        case (anon_obj(_, ?obj_ty)) {\n+                            this_obj_ty = obj_ty;\n+                        }\n+                    }\n                 }\n                 case (none) {\n                     // Shouldn't happen.\n@@ -2353,36 +2384,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps)) {\n-            // TODO: We probably need to do more work here to be able to\n-            // handle additional methods that use 'self'\n-\n-            // We're entering an object, so gather up the info we need.\n+        case (ast::expr_anon_obj(?ao, ?tps)) {\n \n             let ast::anon_obj_field[] fields = ~[];\n-            alt (anon_obj.fields) {\n+            alt (ao.fields) {\n                 case (none) { }\n                 case (some(?v)) { fields = v; }\n             }\n \n-            // FIXME: this is duplicated between here and trans -- it should\n-            // appear in one place\n-            fn anon_obj_field_to_obj_field(&ast::anon_obj_field f)\n-                -> ast::obj_field {\n-                ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n-            }\n-\n-            fcx.ccx.obj_infos +=\n-                ~[rec(obj_fields=ivec::map(anon_obj_field_to_obj_field,\n-                                           fields),\n-                      this_obj=id)];\n-\n             // FIXME: These next three functions are largely ripped off from\n             // similar ones in collect::.  Is there a better way to do this?\n             fn ty_of_arg(@crate_ctxt ccx, &ast::arg a) -> ty::arg {\n                 auto ty_mode = ast_mode_to_mode(a.mode);\n                 ret rec(mode=ty_mode, ty=ast_ty_to_ty_crate(ccx, a.ty));\n             }\n+\n             fn ty_of_method(@crate_ctxt ccx, &@ast::method m) -> ty::method {\n                 auto convert = bind ast_ty_to_ty_crate(ccx, _);\n \n@@ -2402,14 +2418,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                         constrs=out_constrs);\n             }\n+\n             fn get_anon_obj_method_types(@fn_ctxt fcx,\n-                                         &ast::anon_obj anon_obj)\n+                                         &ast::anon_obj ao,\n+                                         &ast::anon_obj_field[] fields,\n+                                         &ast::ty_param[] tps)\n                 -> ty::method[] {\n \n                 let ty::method[] methods = ~[];\n \n                 // Outer methods.\n-                for (@ast::method m in anon_obj.methods) {\n+                for (@ast::method m in ao.methods) {\n                     methods += ~[ty_of_method(fcx.ccx, m)];\n                 }\n \n@@ -2418,11 +2437,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 // Typecheck 'with_obj'.  If it exists, it had better have\n                 // object type.\n                 let ty::method[] with_obj_methods = ~[];\n-                alt (anon_obj.with_obj) {\n+                auto with_obj_ty = ty::mk_nil(fcx.ccx.tcx);\n+                alt (ao.with_obj) {\n                     case (none) { }\n                     case (some(?e)) {\n                         check_expr(fcx, e);\n-                        auto with_obj_ty = expr_ty(fcx.ccx.tcx, e);\n+                        with_obj_ty = expr_ty(fcx.ccx.tcx, e);\n \n                         alt (structure_of(fcx, e.span, with_obj_ty)) {\n                             case (ty::ty_obj(?ms)) {\n@@ -2438,28 +2458,40 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         }\n                     }\n                 }\n+\n+                log_err \"Pushing an anon obj onto the obj_infos stack...\";\n+                fn anon_obj_field_to_obj_field(&ast::anon_obj_field f)\n+                    -> ast::obj_field {\n+                    ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n+                }\n+                fcx.ccx.obj_infos +=\n+                    ~[anon_obj(ivec::map(anon_obj_field_to_obj_field,\n+                                         fields),\n+                               with_obj_ty)];\n+\n                 methods += with_obj_methods;\n \n                 ret methods;\n             }\n \n-            auto method_types = get_anon_obj_method_types(fcx, anon_obj);\n+            auto method_types = get_anon_obj_method_types(fcx, ao,\n+                                                          fields, tps);\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n \n             write::ty_only_fixup(fcx, id, ot);\n             // Write the methods into the node type table.  (This happens in\n             // collect::convert for regular objects.)\n \n             auto i = 0u;\n-            while (i < ivec::len[@ast::method](anon_obj.methods)) {\n-                write::ty_only(fcx.ccx.tcx, anon_obj.methods.(i).node.id,\n+            while (i < ivec::len[@ast::method](ao.methods)) {\n+                write::ty_only(fcx.ccx.tcx, ao.methods.(i).node.id,\n                                ty::method_ty_to_fn_ty(fcx.ccx.tcx,\n                                                       method_types.(i)));\n                 i += 1u;\n             }\n \n             // Typecheck the methods.\n-            for (@ast::method method in anon_obj.methods) {\n+            for (@ast::method method in ao.methods) {\n                 check_method(fcx.ccx, method);\n             }\n             next_ty_var(fcx);\n@@ -2654,8 +2686,8 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n         }\n         case (ast::item_obj(?ob, _, _)) {\n             // We're entering an object, so gather up the info we need.\n+            ccx.obj_infos += ~[regular_obj(ob.fields, it.id)];\n \n-            ccx.obj_infos += ~[rec(obj_fields=ob.fields, this_obj=it.id)];\n             // Typecheck the methods.\n             for (@ast::method method in ob.methods) {\n                 check_method(ccx, method);"}, {"sha": "18ccc8af75d4f46b0182b83bf65e45c2a3f8bbef", "filename": "src/test/run-pass/anon-obj-with-self-call.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18162d3261e4214c0f55479b3fba29d1ed5e634a/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18162d3261e4214c0f55479b3fba29d1ed5e634a/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs?ref=18162d3261e4214c0f55479b3fba29d1ed5e634a", "patch": "@@ -19,8 +19,6 @@ fn main() {\n     // Extending an object with a new method that contains a simple\n     // self-call.  Adding support for this is issue #540.\n \n-    // Right now, this fails with a failed lookup in a hashmap; not\n-    // sure where, but I think it might be during typeck.\n     auto my_b = obj {\n         fn baz() -> int {\n             ret self.foo();"}]}