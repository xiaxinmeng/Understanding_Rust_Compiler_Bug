{"sha": "af2c50fb89840852c5181c6e8aeb7be94d85f8df", "node_id": "C_kwDOAAsO6NoAKGFmMmM1MGZiODk4NDA4NTJjNTE4MWM2ZThhZWI3YmU5NGQ4NWY4ZGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T00:34:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T00:34:00Z"}, "message": "Auto merge of #2328 - RalfJung:perf, r=RalfJung\n\nmove checking ptr tracking on item pop into cold helper function\n\nBefore:\n```\nBenchmark 1: cargo miri run --manifest-path bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      6.729 s \u00b1  0.050 s    [User: 6.608 s, System: 0.124 s]\n  Range (min \u2026 max):    6.665 s \u2026  6.799 s    5 runs\n\nBenchmark 2: cargo miri run --manifest-path bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):     20.923 s \u00b1  0.271 s    [User: 20.386 s, System: 0.537 s]\n  Range (min \u2026 max):   20.580 s \u2026 21.165 s    5 runs\n```\nAfter:\n```\nBenchmark 1: cargo miri run --manifest-path bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      6.562 s \u00b1  0.023 s    [User: 6.430 s, System: 0.135 s]\n  Range (min \u2026 max):    6.544 s \u2026  6.594 s    5 runs\n\nBenchmark 2: cargo miri run --manifest-path bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):     20.375 s \u00b1  0.228 s    [User: 19.964 s, System: 0.413 s]\n  Range (min \u2026 max):   20.201 s \u2026 20.736 s    5 runs\n```\nNothing major, but we'll take it I guess. :shrug:\n\nFixes https://github.com/rust-lang/miri/issues/2132", "tree": {"sha": "78fc390a9e3b7826132f9f3dee83ee4fc062a2e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78fc390a9e3b7826132f9f3dee83ee4fc062a2e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af2c50fb89840852c5181c6e8aeb7be94d85f8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af2c50fb89840852c5181c6e8aeb7be94d85f8df", "html_url": "https://github.com/rust-lang/rust/commit/af2c50fb89840852c5181c6e8aeb7be94d85f8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af2c50fb89840852c5181c6e8aeb7be94d85f8df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e16705de25de50995416ac8a7b1442cadae43906", "url": "https://api.github.com/repos/rust-lang/rust/commits/e16705de25de50995416ac8a7b1442cadae43906", "html_url": "https://github.com/rust-lang/rust/commit/e16705de25de50995416ac8a7b1442cadae43906"}, {"sha": "3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "html_url": "https://github.com/rust-lang/rust/commit/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3"}], "stats": {"total": 101, "additions": 62, "deletions": 39}, "files": [{"sha": "d9ccc773a01814dd1a1893a2fa64a0c496292e0c", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/af2c50fb89840852c5181c6e8aeb7be94d85f8df/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2c50fb89840852c5181c6e8aeb7be94d85f8df/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=af2c50fb89840852c5181c6e8aeb7be94d85f8df", "patch": "@@ -316,11 +316,22 @@ impl<'tcx> Stack {\n         alloc_history: &mut AllocHistory,\n         threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n-        if global.tracked_pointer_tags.contains(&item.tag()) {\n-            register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                *item,\n-                provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n-            ));\n+        if !global.tracked_pointer_tags.is_empty() {\n+            check_tracked(item, &provoking_access, global);\n+\n+            #[inline(never)] // cold path\n+            fn check_tracked(\n+                item: &Item,\n+                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                global: &GlobalStateInner,\n+            ) {\n+                if global.tracked_pointer_tags.contains(&item.tag()) {\n+                    register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                        *item,\n+                        provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n+                    ));\n+                }\n+            }\n         }\n \n         if !item.protected() {\n@@ -341,40 +352,52 @@ impl<'tcx> Stack {\n         //    which ends up about linear in the number of protected tags in the program into a\n         //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n         if global.protected_tags.contains(&item.tag()) {\n-            // This path is cold because it is fatal to the program. So here it is fine to do the\n-            // more expensive search to figure out which call is responsible for protecting this\n-            // tag.\n-            let call_id = threads\n-                .all_stacks()\n-                .flatten()\n-                .map(|frame| {\n-                    frame\n-                        .extra\n-                        .stacked_borrows\n-                        .as_ref()\n-                        .expect(\"we should have Stacked Borrows data\")\n-                })\n-                .find(|frame| frame.protected_tags.contains(&item.tag()))\n-                .map(|frame| frame.call_id)\n-                .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n-            if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n-                Err(err_sb_ub(\n-                    format!(\n-                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n-                        tag, item, call_id\n-                    ),\n-                    None,\n-                    tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag()))),\n-                ))?\n-            } else {\n-                Err(err_sb_ub(\n-                    format!(\n-                        \"deallocating while item {:?} is protected by call {:?}\",\n-                        item, call_id\n-                    ),\n-                    None,\n-                    None,\n-                ))?\n+            return Err(protector_error(item, &provoking_access, alloc_history, threads));\n+\n+            #[inline(never)] // cold path\n+            fn protector_error<'tcx>(\n+                item: &Item,\n+                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                alloc_history: &mut AllocHistory,\n+                threads: &ThreadManager<'_, 'tcx>,\n+            ) -> InterpErrorInfo<'tcx> {\n+                // This path is cold because it is fatal to the program. So here it is fine to do the\n+                // more expensive search to figure out which call is responsible for protecting this\n+                // tag.\n+                let call_id = threads\n+                    .all_stacks()\n+                    .flatten()\n+                    .map(|frame| {\n+                        frame\n+                            .extra\n+                            .stacked_borrows\n+                            .as_ref()\n+                            .expect(\"we should have Stacked Borrows data\")\n+                    })\n+                    .find(|frame| frame.protected_tags.contains(&item.tag()))\n+                    .map(|frame| frame.call_id)\n+                    .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n+                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n+                    err_sb_ub(\n+                        format!(\n+                            \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n+                            tag, item, call_id\n+                        ),\n+                        None,\n+                        tag.and_then(|tag| {\n+                            alloc_history.get_logs_relevant_to(tag, Some(item.tag()))\n+                        }),\n+                    )\n+                } else {\n+                    err_sb_ub(\n+                        format!(\n+                            \"deallocating while item {:?} is protected by call {:?}\",\n+                            item, call_id\n+                        ),\n+                        None,\n+                        None,\n+                    )\n+                }.into()\n             }\n         }\n         Ok(())"}]}