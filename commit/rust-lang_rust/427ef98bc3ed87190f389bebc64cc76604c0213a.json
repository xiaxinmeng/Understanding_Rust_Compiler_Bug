{"sha": "427ef98bc3ed87190f389bebc64cc76604c0213a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyN2VmOThiYzNlZDg3MTkwZjM4OWJlYmM2NGNjNzY2MDRjMDIxM2E=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-11T06:26:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-11T06:26:34Z"}, "message": "Rollup merge of #74076 - sunfishcode:wasi-fileext-newmethods, r=alexcrichton\n\nAdd `read_exact_at` and `write_all_at` to WASI's `FileExt`\n\nThis adds `read_exact_at` and `write_all_at` to WASI's `FileExt`,\nsimilar to the Unix versions of the same names.", "tree": {"sha": "d90160d0a1c771b5709dc44ddf843e999d110be9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d90160d0a1c771b5709dc44ddf843e999d110be9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/427ef98bc3ed87190f389bebc64cc76604c0213a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfCVuaCRBK7hj4Ov3rIwAAdHIIAJyuTLDaxeh+GuZK90oo52uI\nZ+4geEgkC334+ItjbRqoLJvHnfYyJmgvcj2eljMfJDr8Eu2pLG8AL+YWOortYL8K\nQ3afdEgEMGXmvWYZxcXNODBS++XybqldJsACiXKWA8+54AcPB8wdTdAxpr7OJo0O\nUvAnEQhaF9RX84eAOu1DTIZRM1KlOvZIl1TlBU3piMkRZaS4tcCfsO79p4Oha8bz\nmt+j8ttzzj0p+qcvuVTleCaUyJs2tzme0R2eJwhKAiaYANN7Zw0gciEjjZ+Y+Iys\ntJ4U29Ma0u4FlCqMqGPtAX4Hj/tBrrcdrJmsoaFQi25R1ndqNZ4U1DIjH68Vdvg=\n=edAK\n-----END PGP SIGNATURE-----\n", "payload": "tree d90160d0a1c771b5709dc44ddf843e999d110be9\nparent 2ae7d8cdba4ee8584bdcdcd22699d151a6b8959f\nparent 58fc61b79cd15fdafad6e15991553f5c33422ade\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594448794 -0700\ncommitter GitHub <noreply@github.com> 1594448794 -0700\n\nRollup merge of #74076 - sunfishcode:wasi-fileext-newmethods, r=alexcrichton\n\nAdd `read_exact_at` and `write_all_at` to WASI's `FileExt`\n\nThis adds `read_exact_at` and `write_all_at` to WASI's `FileExt`,\nsimilar to the Unix versions of the same names.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/427ef98bc3ed87190f389bebc64cc76604c0213a", "html_url": "https://github.com/rust-lang/rust/commit/427ef98bc3ed87190f389bebc64cc76604c0213a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/427ef98bc3ed87190f389bebc64cc76604c0213a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ae7d8cdba4ee8584bdcdcd22699d151a6b8959f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae7d8cdba4ee8584bdcdcd22699d151a6b8959f", "html_url": "https://github.com/rust-lang/rust/commit/2ae7d8cdba4ee8584bdcdcd22699d151a6b8959f"}, {"sha": "58fc61b79cd15fdafad6e15991553f5c33422ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/58fc61b79cd15fdafad6e15991553f5c33422ade", "html_url": "https://github.com/rust-lang/rust/commit/58fc61b79cd15fdafad6e15991553f5c33422ade"}], "stats": {"total": 141, "additions": 137, "deletions": 4}, "files": [{"sha": "f41c6626ccf120824fb683d8a5d850d471886a9d", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 137, "deletions": 4, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/427ef98bc3ed87190f389bebc64cc76604c0213a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/427ef98bc3ed87190f389bebc64cc76604c0213a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=427ef98bc3ed87190f389bebc64cc76604c0213a", "patch": "@@ -12,6 +12,24 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n ///\n /// [`File`]: ../../../../std/fs/struct.File.html\n pub trait FileExt {\n+    /// Reads a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Note that similar to [`File::read`], it is not an error to return with a\n+    /// short read.\n+    ///\n+    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        let bufs = &mut [IoSliceMut::new(buf)];\n+        self.read_vectored_at(bufs, offset)\n+    }\n+\n     /// Reads a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes read.\n@@ -25,7 +43,80 @@ pub trait FileExt {\n     /// return with a short read.\n     ///\n     /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n-    fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n+    fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n+\n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Writes a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropriately\n+    /// extended and the intermediate bytes are initialized with the value 0.\n+    ///\n+    /// Note that similar to [`File::write`], it is not an error to return a\n+    /// short write.\n+    ///\n+    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        let bufs = &[IoSlice::new(buf)];\n+        self.write_vectored_at(bufs, offset)\n+    }\n \n     /// Writes a number of bytes starting from a given offset.\n     ///\n@@ -43,7 +134,49 @@ pub trait FileExt {\n     /// short write.\n     ///\n     /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n-    fn write_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n+    fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n+\n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n \n     /// Returns the current position within the file.\n     ///\n@@ -105,11 +238,11 @@ pub trait FileExt {\n // FIXME: bind random_get maybe? - on crates.io for unix\n \n impl FileExt for fs::File {\n-    fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+    fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n         self.as_inner().fd().pread(bufs, offset)\n     }\n \n-    fn write_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+    fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n         self.as_inner().fd().pwrite(bufs, offset)\n     }\n "}]}