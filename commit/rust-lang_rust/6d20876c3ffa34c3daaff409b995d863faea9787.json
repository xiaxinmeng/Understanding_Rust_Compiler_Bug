{"sha": "6d20876c3ffa34c3daaff409b995d863faea9787", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjA4NzZjM2ZmYTM0YzNkYWFmZjQwOWI5OTVkODYzZmFlYTk3ODc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2014-01-02T14:20:43Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2014-01-02T14:20:43Z"}, "message": "debuginfo: Fix issue #11083 and some minor clean up.", "tree": {"sha": "f7bf582b3accd739bcabe27b03d5d187eacea125", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7bf582b3accd739bcabe27b03d5d187eacea125"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d20876c3ffa34c3daaff409b995d863faea9787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d20876c3ffa34c3daaff409b995d863faea9787", "html_url": "https://github.com/rust-lang/rust/commit/6d20876c3ffa34c3daaff409b995d863faea9787", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d20876c3ffa34c3daaff409b995d863faea9787/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d459e805df076ace12ed3f7f57f2b1378f0e2403", "url": "https://api.github.com/repos/rust-lang/rust/commits/d459e805df076ace12ed3f7f57f2b1378f0e2403", "html_url": "https://github.com/rust-lang/rust/commit/d459e805df076ace12ed3f7f57f2b1378f0e2403"}], "stats": {"total": 139, "additions": 75, "deletions": 64}, "files": [{"sha": "cb746e8c0e3affca1f8efeb30aa8bb8e6f72b74a", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6d20876c3ffa34c3daaff409b995d863faea9787", "patch": "@@ -1653,7 +1653,8 @@ pub mod llvm {\n                                             AlignInBits: c_ulonglong,\n                                             Flags: c_uint,\n                                             Elements: ValueRef,\n-                                            RunTimeLang: c_uint)\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *c_char)\n                                             -> ValueRef;\n \n         pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);"}, {"sha": "094c44b8a18798af48ea51b1dab0642e96b0ae51", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6d20876c3ffa34c3daaff409b995d863faea9787", "patch": "@@ -157,7 +157,7 @@ use syntax::parse::token::special_idents;\n static DW_LANG_RUST: c_uint = 0x9000;\n \n static DW_TAG_auto_variable: c_uint = 0x100;\n-// static DW_TAG_arg_variable: c_uint = 0x101;\n+static DW_TAG_arg_variable: c_uint = 0x101;\n \n static DW_ATE_boolean: c_uint = 0x02;\n static DW_ATE_float: c_uint = 0x04;\n@@ -980,11 +980,11 @@ fn declare_local(bcx: @Block,\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n-    let argument_index = match variable_kind {\n-        ArgumentVariable(index) => index,\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n         LocalVariable    |\n-        CapturedVariable => 0\n-    } as c_uint;\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n \n     let (var_alloca, var_metadata) = name.with_c_str(|name| {\n         match variable_access {\n@@ -993,7 +993,7 @@ fn declare_local(bcx: @Block,\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateLocalVariable(\n                         DIB(cx),\n-                        DW_TAG_auto_variable,\n+                        dwarf_tag,\n                         scope_metadata,\n                         name,\n                         file_metadata,\n@@ -1009,7 +1009,7 @@ fn declare_local(bcx: @Block,\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateComplexVariable(\n                         DIB(cx),\n-                        DW_TAG_auto_variable,\n+                        dwarf_tag,\n                         scope_metadata,\n                         name,\n                         file_metadata,\n@@ -1256,14 +1256,12 @@ impl RecursiveTypeDescription {\n             } => {\n                 // Insert the stub into the cache in order to allow recursive references ...\n                 {\n-                    let mut created_types = debug_context(cx).created_types\n-                                                             .borrow_mut();\n+                    let mut created_types = debug_context(cx).created_types.borrow_mut();\n                     created_types.get().insert(cache_id, metadata_stub);\n                 }\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory.\n-                    create_member_descriptions(cx);\n+                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n@@ -1348,13 +1346,13 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n             .enumerate()\n             .map(|(i, struct_def)| {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n-                    describe_variant(cx,\n-                                     struct_def,\n-                                     self.variants[i],\n-                                     Some(self.discriminant_type_metadata),\n-                                     self.containing_scope,\n-                                     self.file_metadata,\n-                                     self.span);\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          self.variants[i],\n+                                          Some(self.discriminant_type_metadata),\n+                                          self.containing_scope,\n+                                          self.file_metadata,\n+                                          self.span);\n \n                 let member_descriptions =\n                     member_desc_factory.create_member_descriptions(cx);\n@@ -1398,14 +1396,14 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     }\n }\n \n-fn describe_variant(cx: &CrateContext,\n-                    struct_def: &adt::Struct,\n-                    variant_info: &ty::VariantInfo,\n-                    discriminant_type_metadata: Option<DIType>,\n-                    containing_scope: DIScope,\n-                    file_metadata: DIFile,\n-                    span: Span)\n-                 -> (DICompositeType, Type, @MemberDescriptionFactory) {\n+fn describe_enum_variant(cx: &CrateContext,\n+                         struct_def: &adt::Struct,\n+                         variant_info: &ty::VariantInfo,\n+                         discriminant_type_metadata: Option<DIType>,\n+                         containing_scope: DIScope,\n+                         file_metadata: DIFile,\n+                         span: Span)\n+                      -> (DICompositeType, Type, @MemberDescriptionFactory) {\n     let variant_name = token::ident_to_str(&variant_info.name);\n     let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                           struct_def.packed);\n@@ -1538,13 +1536,13 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             assert!(variants.len() == 1);\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_variant(cx,\n-                                                                struct_def,\n-                                                                variants[0],\n-                                                                None,\n-                                                                containing_scope,\n-                                                                file_metadata,\n-                                                                span);\n+                 member_description_factory) = describe_enum_variant(cx,\n+                                                                     struct_def,\n+                                                                     variants[0],\n+                                                                     None,\n+                                                                     containing_scope,\n+                                                                     file_metadata,\n+                                                                     span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1557,21 +1555,25 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             let discriminant_type_metadata = discriminant_type_metadata(inttype);\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+            let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n \n             let enum_metadata = enum_name.with_c_str(|enum_name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateUnionType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    enum_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(enum_type_size),\n-                    bytes_to_bits(enum_type_align),\n-                    0, // Flags\n-                    ptr::null(),\n-                    0) // RuntimeLang\n-                }\n+                unique_id.with_c_str(|unique_id| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateUnionType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        enum_name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        bytes_to_bits(enum_type_size),\n+                        bytes_to_bits(enum_type_align),\n+                        0, // Flags\n+                        ptr::null(),\n+                        0, // RuntimeLang\n+                        unique_id)\n+                    }\n+                })\n             });\n \n             UnfinishedMetadata {\n@@ -1592,13 +1594,13 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_variant(cx,\n-                                                                struct_def,\n-                                                                variants[nndiscr],\n-                                                                None,\n-                                                                containing_scope,\n-                                                                file_metadata,\n-                                                                span);\n+                 member_description_factory) = describe_enum_variant(cx,\n+                                                                     struct_def,\n+                                                                     variants[nndiscr],\n+                                                                     None,\n+                                                                     containing_scope,\n+                                                                     file_metadata,\n+                                                                     span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1725,10 +1727,7 @@ fn create_struct_stub(cx: &CrateContext,\n \n     // We assign unique IDs to the type stubs so LLVM metadata uniquing does not reuse instances\n     // where we don't want it.\n-    let unique_id = unsafe {\n-        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-        format!(\"DiStructStub{}\", unique_id_counter.fetch_add(1, atomics::SeqCst))\n-    };\n+    let unique_id = generate_unique_type_id(\"DI_STRUCT_\");\n \n     return unsafe {\n         struct_type_name.with_c_str(|name| {\n@@ -2059,10 +2058,6 @@ fn trait_metadata(cx: &CrateContext,\n                                    definition_span);\n }\n \n-fn cache_id_for_type(t: ty::t) -> uint {\n-    ty::type_id(t)\n-}\n-\n fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n@@ -2244,6 +2239,19 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n //  Utility Functions\n //=-------------------------------------------------------------------------------------------------\n \n+fn cache_id_for_type(t: ty::t) -> uint {\n+    ty::type_id(t)\n+}\n+\n+// Used to avoid LLVM metadata uniquing problems. See `create_struct_stub()` and\n+// `prepare_enum_metadata()`.\n+fn generate_unique_type_id(prefix: &'static str) -> ~str {\n+    unsafe {\n+        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+        format!(\"{}{}\", prefix, unique_id_counter.fetch_add(1, atomics::SeqCst))\n+    }\n+}\n+\n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)"}, {"sha": "39991701b065a2bb60701ef86d815e6eaf754923", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6d20876c3ffa34c3daaff409b995d863faea9787/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=6d20876c3ffa34c3daaff409b995d863faea9787", "patch": "@@ -442,7 +442,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n     uint64_t AlignInBits,\n     unsigned Flags,\n     LLVMValueRef Elements,\n-    unsigned RunTimeLang)\n+    unsigned RunTimeLang,\n+    const char* UniqueId)\n {\n     return wrap(Builder->createUnionType(\n         unwrapDI<DIDescriptor>(Scope),\n@@ -453,7 +454,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n         AlignInBits,\n         Flags,\n         unwrapDI<DIArray>(Elements),\n-        RunTimeLang));\n+        RunTimeLang,\n+        UniqueId));\n }\n \n extern \"C\" void LLVMSetUnnamedAddr(LLVMValueRef Value, LLVMBool Unnamed) {"}]}