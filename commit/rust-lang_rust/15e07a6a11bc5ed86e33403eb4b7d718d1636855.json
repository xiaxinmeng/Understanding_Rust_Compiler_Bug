{"sha": "15e07a6a11bc5ed86e33403eb4b7d718d1636855", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZTA3YTZhMTFiYzVlZDg2ZTMzNDAzZWI0YjdkNzE4ZDE2MzY4NTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T12:37:23Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T14:16:36Z"}, "message": "parser: fuse `trait` parsing & layer with `is_path_start_item`", "tree": {"sha": "36c36cef6be5290b58d19b7173a83b5982e2732f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c36cef6be5290b58d19b7173a83b5982e2732f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15e07a6a11bc5ed86e33403eb4b7d718d1636855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15e07a6a11bc5ed86e33403eb4b7d718d1636855", "html_url": "https://github.com/rust-lang/rust/commit/15e07a6a11bc5ed86e33403eb4b7d718d1636855", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15e07a6a11bc5ed86e33403eb4b7d718d1636855/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd64b3bcdfcc844b9b25318106917937f7b17b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd64b3bcdfcc844b9b25318106917937f7b17b94", "html_url": "https://github.com/rust-lang/rust/commit/fd64b3bcdfcc844b9b25318106917937f7b17b94"}], "stats": {"total": 62, "additions": 27, "deletions": 35}, "files": [{"sha": "6de82d8f9be59e4a2d2e92ed02e3e9c11ba403c6", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/15e07a6a11bc5ed86e33403eb4b7d718d1636855/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e07a6a11bc5ed86e33403eb4b7d718d1636855/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=15e07a6a11bc5ed86e33403eb4b7d718d1636855", "patch": "@@ -152,11 +152,9 @@ impl<'a> Parser<'a> {\n             }\n \n             self.parse_item_const(None)?\n-        } else if self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n-        {\n-            // UNSAFE TRAIT ITEM\n-            let unsafety = self.parse_unsafety();\n-            self.parse_item_trait(attrs, lo, unsafety)?\n+        } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n+            // TRAIT ITEM\n+            self.parse_item_trait(attrs, lo)?\n         } else if self.check_keyword(kw::Impl)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n             || self.check_keyword(kw::Default) && self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n@@ -176,11 +174,6 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n-        } else if self.check_keyword(kw::Trait)\n-            || (self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait]))\n-        {\n-            // TRAIT ITEM\n-            self.parse_item_trait(attrs, lo, Unsafe::No)?\n         } else if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n             self.parse_item_struct()?\n@@ -209,6 +202,15 @@ impl<'a> Parser<'a> {\n         Ok(Some(info))\n     }\n \n+    /// When parsing a statement, would the start of a path be an item?\n+    pub(super) fn is_path_start_item(&mut self) -> bool {\n+        self.is_crate_vis() // no: `crate::b`, yes: `crate $item`\n+        || self.is_union_item() // no: `union::b`, yes: `union U { .. }`\n+        || self.check_auto_or_unsafe_trait_item() // no: `auto::b`, yes: `auto trait X { .. }`\n+        || self.is_async_fn() // no(2015): `async::b`, yes: `async fn`\n+        || self.is_macro_rules_item() // no: `macro_rules::b`, yes: `macro_rules! mac`\n+    }\n+\n     /// Recover on encountering a struct or method definition where the user\n     /// forgot to add the `struct` or `fn` keyword after writing `pub`: `pub S {}`.\n     fn recover_missing_kw_before_item(&mut self) -> PResult<'a, ()> {\n@@ -338,7 +340,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    pub(super) fn is_async_fn(&self) -> bool {\n+    fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) && self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n@@ -609,13 +611,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(\n-        &mut self,\n-        attrs: &mut Vec<Attribute>,\n-        lo: Span,\n-        unsafety: Unsafe,\n-    ) -> PResult<'a, ItemInfo> {\n+    /// Is this an `(unsafe auto? | auto) trait` item?\n+    fn check_auto_or_unsafe_trait_item(&mut self) -> bool {\n+        // auto trait\n+        self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait])\n+            // unsafe auto trait\n+            || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+    }\n+\n+    /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, attrs: &mut Vec<Attribute>, lo: Span) -> PResult<'a, ItemInfo> {\n+        let unsafety = self.parse_unsafety();\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -1179,7 +1185,7 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n-    pub(super) fn is_union_item(&self) -> bool {\n+    fn is_union_item(&self) -> bool {\n         self.token.is_keyword(kw::Union)\n             && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n@@ -1362,7 +1368,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n-    pub(super) fn is_macro_rules_item(&mut self) -> bool {\n+    fn is_macro_rules_item(&mut self) -> bool {\n         self.check_keyword(sym::macro_rules)\n             && self.look_ahead(1, |t| *t == token::Not)\n             && self.look_ahead(2, |t| t.is_ident())"}, {"sha": "439d0368d096105c049bf5af7d4af500a852f540", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15e07a6a11bc5ed86e33403eb4b7d718d1636855/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e07a6a11bc5ed86e33403eb4b7d718d1636855/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=15e07a6a11bc5ed86e33403eb4b7d718d1636855", "patch": "@@ -61,11 +61,7 @@ impl<'a> Parser<'a> {\n         // like a path (1 token), but it fact not a path.\n         if self.token.is_path_start()\n             && !self.token.is_qpath_start()\n-            && !self.is_union_item() // `union::b::c` - path, `union U { ... }` - not a path.\n-            && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n-            && !self.is_auto_trait_item()\n-            && !self.is_async_fn()\n-            && !self.is_macro_rules_item()\n+            && !self.is_path_start_item() // Confirm we don't steal syntax from `parse_item_`.\n         {\n             let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -295,16 +291,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_auto_trait_item(&self) -> bool {\n-        // auto trait\n-        (self.token.is_keyword(kw::Auto) &&\n-            self.is_keyword_ahead(1, &[kw::Trait]))\n-        || // unsafe auto trait\n-        (self.token.is_keyword(kw::Unsafe) &&\n-         self.is_keyword_ahead(1, &[kw::Auto]) &&\n-         self.is_keyword_ahead(2, &[kw::Trait]))\n-    }\n-\n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);"}]}