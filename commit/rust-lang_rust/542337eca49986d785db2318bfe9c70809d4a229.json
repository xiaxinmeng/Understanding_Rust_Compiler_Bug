{"sha": "542337eca49986d785db2318bfe9c70809d4a229", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MjMzN2VjYTQ5OTg2ZDc4NWRiMjMxOGJmZTljNzA4MDlkNGEyMjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-22T13:30:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-22T13:30:32Z"}, "message": "Merge #8868\n\n8868: internal: replace AstTransformer with mutable syntax trees r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8a19fddbb72a4871a1840a45321c3c3b3af0876c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a19fddbb72a4871a1840a45321c3c3b3af0876c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542337eca49986d785db2318bfe9c70809d4a229", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqQd4CRBK7hj4Ov3rIwAABakIAJHGuz0g1paF8ptCseXnlHvr\nC8Xu0LcTs4LFQe1PfW/jhEDw9C0EZ6zNdmZWrZMWsQ4IoU1c9q3rLoT/wB3XIFd1\nNMW5Y9j51omLmY+ChSRhH3vcZkpy3R/5IdxwBeEswoERXPdN0UhHKLVGZRlQ2B5m\nwyFlsEiIovs0DMJRsyBWrbbDTYJ8RYTPF/bphYC3wcNrWKyQXYPuKFKNTIKs83fN\nqsxEAzJsdlL75JPKIOHO7lLADTGXOcfe8sT1zdhDhi4iHuv3w1Hq21CUIxEIs0//\nagk+PEObLmIpoAlnzvhyBMo+hTPzIQMQAByE5NXxqNT9XYfz6xplvtqbF1g3rzA=\n=BWrK\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a19fddbb72a4871a1840a45321c3c3b3af0876c\nparent 057e2ed574bb54afeca35f032774bb8b94aaa1d1\nparent e6776c3e1b66c8946873d20e1e3bc1d743c952fe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621690232 +0000\ncommitter GitHub <noreply@github.com> 1621690232 +0000\n\nMerge #8868\n\n8868: internal: replace AstTransformer with mutable syntax trees r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542337eca49986d785db2318bfe9c70809d4a229", "html_url": "https://github.com/rust-lang/rust/commit/542337eca49986d785db2318bfe9c70809d4a229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542337eca49986d785db2318bfe9c70809d4a229/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "057e2ed574bb54afeca35f032774bb8b94aaa1d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/057e2ed574bb54afeca35f032774bb8b94aaa1d1", "html_url": "https://github.com/rust-lang/rust/commit/057e2ed574bb54afeca35f032774bb8b94aaa1d1"}, {"sha": "e6776c3e1b66c8946873d20e1e3bc1d743c952fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6776c3e1b66c8946873d20e1e3bc1d743c952fe", "html_url": "https://github.com/rust-lang/rust/commit/e6776c3e1b66c8946873d20e1e3bc1d743c952fe"}], "stats": {"total": 474, "additions": 192, "deletions": 282}, "files": [{"sha": "e5ae718c9fd148292bb2b62ad9a0a244e2e90a11", "filename": "crates/ide_assists/src/ast_transform.rs", "status": "removed", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/057e2ed574bb54afeca35f032774bb8b94aaa1d1/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057e2ed574bb54afeca35f032774bb8b94aaa1d1/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fast_transform.rs?ref=057e2ed574bb54afeca35f032774bb8b94aaa1d1", "patch": "@@ -1,218 +0,0 @@\n-//! `AstTransformer`s are functions that replace nodes in an AST and can be easily combined.\n-use hir::{HirDisplay, PathResolution, SemanticsScope};\n-use ide_db::helpers::mod_path_to_ast;\n-use rustc_hash::FxHashMap;\n-use syntax::{\n-    ast::{self, AstNode},\n-    ted, SyntaxNode,\n-};\n-\n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n-    let mut skip_to = None;\n-    for event in node.syntax().preorder() {\n-        match event {\n-            syntax::WalkEvent::Enter(node) if skip_to.is_none() => {\n-                skip_to = transformer.get_substitution(&node, transformer).zip(Some(node));\n-            }\n-            syntax::WalkEvent::Enter(_) => (),\n-            syntax::WalkEvent::Leave(node) => match &skip_to {\n-                Some((replacement, skip_target)) if *skip_target == node => {\n-                    ted::replace(node, replacement.clone_for_update());\n-                    skip_to.take();\n-                }\n-                _ => (),\n-            },\n-        }\n-    }\n-}\n-\n-/// `AstTransform` helps with applying bulk transformations to syntax nodes.\n-///\n-/// This is mostly useful for IDE code generation. If you paste some existing\n-/// code into a new context (for example, to add method overrides to an `impl`\n-/// block), you generally want to appropriately qualify the names, and sometimes\n-/// you might want to substitute generic parameters as well:\n-///\n-/// ```\n-/// mod x {\n-///   pub struct A;\n-///   pub trait T<U> { fn foo(&self, _: U) -> A; }\n-/// }\n-///\n-/// mod y {\n-///   use x::T;\n-///\n-///   impl T<()> for () {\n-///      // If we invoke **Add Missing Members** here, we want to copy-paste `foo`.\n-///      // But we want a slightly-modified version of it:\n-///      fn foo(&self, _: ()) -> x::A {}\n-///   }\n-/// }\n-/// ```\n-///\n-/// So, a single `AstTransform` describes such function from `SyntaxNode` to\n-/// `SyntaxNode`. Note that the API here is a bit too high-order and high-brow.\n-/// We'd want to somehow express this concept simpler, but so far nobody got to\n-/// simplifying this!\n-pub trait AstTransform<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode>;\n-\n-    fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n-    where\n-        Self: Sized + 'a,\n-    {\n-        Box::new(Or(Box::new(self), Box::new(other)))\n-    }\n-}\n-\n-struct Or<'a>(Box<dyn AstTransform<'a> + 'a>, Box<dyn AstTransform<'a> + 'a>);\n-\n-impl<'a> AstTransform<'a> for Or<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        self.0.get_substitution(node, recur).or_else(|| self.1.get_substitution(node, recur))\n-    }\n-}\n-\n-pub struct SubstituteTypeParams<'a> {\n-    source_scope: &'a SemanticsScope<'a>,\n-    substs: FxHashMap<hir::TypeParam, ast::Type>,\n-}\n-\n-impl<'a> SubstituteTypeParams<'a> {\n-    pub fn for_trait_impl(\n-        source_scope: &'a SemanticsScope<'a>,\n-        // FIXME: there's implicit invariant that `trait_` and  `source_scope` match...\n-        trait_: hir::Trait,\n-        impl_def: ast::Impl,\n-    ) -> SubstituteTypeParams<'a> {\n-        let substs = get_syntactic_substs(impl_def).unwrap_or_default();\n-        let generic_def: hir::GenericDef = trait_.into();\n-        let substs_by_param: FxHashMap<_, _> = generic_def\n-            .type_params(source_scope.db)\n-            .into_iter()\n-            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            .skip(1)\n-            // The actual list of trait type parameters may be longer than the one\n-            // used in the `impl` block due to trailing default type parameters.\n-            // For that case we extend the `substs` with an empty iterator so we\n-            // can still hit those trailing values and check if they actually have\n-            // a default type. If they do, go for that type from `hir` to `ast` so\n-            // the resulting change can be applied correctly.\n-            .zip(substs.into_iter().map(Some).chain(std::iter::repeat(None)))\n-            .filter_map(|(k, v)| match v {\n-                Some(v) => Some((k, v)),\n-                None => {\n-                    let default = k.default(source_scope.db)?;\n-                    Some((\n-                        k,\n-                        ast::make::ty(\n-                            &default\n-                                .display_source_code(source_scope.db, source_scope.module()?.into())\n-                                .ok()?,\n-                        ),\n-                    ))\n-                }\n-            })\n-            .collect();\n-        return SubstituteTypeParams { source_scope, substs: substs_by_param };\n-\n-        // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-        // trait ref, and then go from the types in the substs back to the syntax).\n-        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n-            let target_trait = impl_def.trait_()?;\n-            let path_type = match target_trait {\n-                ast::Type::PathType(path) => path,\n-                _ => return None,\n-            };\n-            let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n-\n-            let mut result = Vec::new();\n-            for generic_arg in generic_arg_list.generic_args() {\n-                match generic_arg {\n-                    ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n-                    ast::GenericArg::AssocTypeArg(_)\n-                    | ast::GenericArg::LifetimeArg(_)\n-                    | ast::GenericArg::ConstArg(_) => (),\n-                }\n-            }\n-\n-            Some(result)\n-        }\n-    }\n-}\n-\n-impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        _recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        let type_ref = ast::Type::cast(node.clone())?;\n-        let path = match &type_ref {\n-            ast::Type::PathType(path_type) => path_type.path()?,\n-            _ => return None,\n-        };\n-        let resolution = self.source_scope.speculative_resolve(&path)?;\n-        match resolution {\n-            hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-pub struct QualifyPaths<'a> {\n-    target_scope: &'a SemanticsScope<'a>,\n-    source_scope: &'a SemanticsScope<'a>,\n-}\n-\n-impl<'a> QualifyPaths<'a> {\n-    pub fn new(target_scope: &'a SemanticsScope<'a>, source_scope: &'a SemanticsScope<'a>) -> Self {\n-        Self { target_scope, source_scope }\n-    }\n-}\n-\n-impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n-    fn get_substitution(\n-        &self,\n-        node: &SyntaxNode,\n-        recur: &dyn AstTransform<'a>,\n-    ) -> Option<SyntaxNode> {\n-        // FIXME handle value ns?\n-        let from = self.target_scope.module()?;\n-        let p = ast::Path::cast(node.clone())?;\n-        if p.segment().and_then(|s| s.param_list()).is_some() {\n-            // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n-            return None;\n-        }\n-        let resolution = self.source_scope.speculative_resolve(&p)?;\n-        match resolution {\n-            PathResolution::Def(def) => {\n-                let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n-                let mut path = mod_path_to_ast(&found_path);\n-\n-                let type_args = p.segment().and_then(|s| s.generic_arg_list());\n-                if let Some(type_args) = type_args {\n-                    apply(recur, &type_args);\n-                    let last_segment = path.segment().unwrap();\n-                    path = path.with_segment(last_segment.with_generic_args(type_args))\n-                }\n-\n-                Some(path.syntax().clone())\n-            }\n-            PathResolution::Local(_)\n-            | PathResolution::TypeParam(_)\n-            | PathResolution::SelfType(_)\n-            | PathResolution::ConstParam(_) => None,\n-            PathResolution::Macro(_) => None,\n-            PathResolution::AssocItem(_) => None,\n-        }\n-    }\n-}"}, {"sha": "05644b6ff5c44ea64ef10e1ab0d5cbd28c9398b9", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -15,7 +15,7 @@ mod assist_context;\n #[cfg(test)]\n mod tests;\n pub mod utils;\n-pub mod ast_transform;\n+pub mod path_transform;\n \n use std::str::FromStr;\n "}, {"sha": "6ec318c4cec27d5d911bbf0d133e572b1397cc5b", "filename": "crates/ide_assists/src/path_transform.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fpath_transform.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -0,0 +1,159 @@\n+//! See `PathTransform`\n+use hir::{HirDisplay, SemanticsScope};\n+use ide_db::helpers::mod_path_to_ast;\n+use rustc_hash::FxHashMap;\n+use syntax::{\n+    ast::{self, AstNode},\n+    ted,\n+};\n+\n+/// `PathTransform` substitutes path in SyntaxNodes in bulk.\n+///\n+/// This is mostly useful for IDE code generation. If you paste some existing\n+/// code into a new context (for example, to add method overrides to an `impl`\n+/// block), you generally want to appropriately qualify the names, and sometimes\n+/// you might want to substitute generic parameters as well:\n+///\n+/// ```\n+/// mod x {\n+///   pub struct A<V>;\n+///   pub trait T<U> { fn foo(&self, _: U) -> A<U>; }\n+/// }\n+///\n+/// mod y {\n+///   use x::T;\n+///\n+///   impl T<()> for () {\n+///      // If we invoke **Add Missing Members** here, we want to copy-paste `foo`.\n+///      // But we want a slightly-modified version of it:\n+///      fn foo(&self, _: ()) -> x::A<()> {}\n+///   }\n+/// }\n+/// ```\n+pub(crate) struct PathTransform<'a> {\n+    pub(crate) subst: (hir::Trait, ast::Impl),\n+    pub(crate) target_scope: &'a SemanticsScope<'a>,\n+    pub(crate) source_scope: &'a SemanticsScope<'a>,\n+}\n+\n+impl<'a> PathTransform<'a> {\n+    pub(crate) fn apply(&self, item: ast::AssocItem) {\n+        if let Some(ctx) = self.build_ctx() {\n+            ctx.apply(item)\n+        }\n+    }\n+    fn build_ctx(&self) -> Option<Ctx<'a>> {\n+        let db = self.source_scope.db;\n+        let target_module = self.target_scope.module()?;\n+        let source_module = self.source_scope.module()?;\n+\n+        let substs = get_syntactic_substs(self.subst.1.clone()).unwrap_or_default();\n+        let generic_def: hir::GenericDef = self.subst.0.into();\n+        let substs_by_param: FxHashMap<_, _> = generic_def\n+            .type_params(db)\n+            .into_iter()\n+            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n+            .skip(1)\n+            // The actual list of trait type parameters may be longer than the one\n+            // used in the `impl` block due to trailing default type parameters.\n+            // For that case we extend the `substs` with an empty iterator so we\n+            // can still hit those trailing values and check if they actually have\n+            // a default type. If they do, go for that type from `hir` to `ast` so\n+            // the resulting change can be applied correctly.\n+            .zip(substs.into_iter().map(Some).chain(std::iter::repeat(None)))\n+            .filter_map(|(k, v)| match v {\n+                Some(v) => Some((k, v)),\n+                None => {\n+                    let default = k.default(db)?;\n+                    Some((\n+                        k,\n+                        ast::make::ty(&default.display_source_code(db, source_module.into()).ok()?),\n+                    ))\n+                }\n+            })\n+            .collect();\n+\n+        let res = Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope };\n+        Some(res)\n+    }\n+}\n+\n+struct Ctx<'a> {\n+    substs: FxHashMap<hir::TypeParam, ast::Type>,\n+    target_module: hir::Module,\n+    source_scope: &'a SemanticsScope<'a>,\n+}\n+\n+impl<'a> Ctx<'a> {\n+    fn apply(&self, item: ast::AssocItem) {\n+        for event in item.syntax().preorder() {\n+            let node = match event {\n+                syntax::WalkEvent::Enter(_) => continue,\n+                syntax::WalkEvent::Leave(it) => it,\n+            };\n+            if let Some(path) = ast::Path::cast(node.clone()) {\n+                self.transform_path(path);\n+            }\n+        }\n+    }\n+    fn transform_path(&self, path: ast::Path) -> Option<()> {\n+        if path.qualifier().is_some() {\n+            return None;\n+        }\n+        if path.segment().and_then(|s| s.param_list()).is_some() {\n+            // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n+            return None;\n+        }\n+\n+        let resolution = self.source_scope.speculative_resolve(&path)?;\n+\n+        match resolution {\n+            hir::PathResolution::TypeParam(tp) => {\n+                if let Some(subst) = self.substs.get(&tp) {\n+                    ted::replace(path.syntax(), subst.clone_subtree().clone_for_update().syntax())\n+                }\n+            }\n+            hir::PathResolution::Def(def) => {\n+                let found_path =\n+                    self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n+                let res = mod_path_to_ast(&found_path).clone_for_update();\n+                if let Some(args) = path.segment().and_then(|it| it.generic_arg_list()) {\n+                    if let Some(segment) = res.segment() {\n+                        let old = segment.get_or_create_generic_arg_list();\n+                        ted::replace(old.syntax(), args.clone_subtree().syntax().clone_for_update())\n+                    }\n+                }\n+                ted::replace(path.syntax(), res.syntax())\n+            }\n+            hir::PathResolution::Local(_)\n+            | hir::PathResolution::ConstParam(_)\n+            | hir::PathResolution::SelfType(_)\n+            | hir::PathResolution::Macro(_)\n+            | hir::PathResolution::AssocItem(_) => (),\n+        }\n+        Some(())\n+    }\n+}\n+\n+// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n+// trait ref, and then go from the types in the substs back to the syntax).\n+fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n+    let target_trait = impl_def.trait_()?;\n+    let path_type = match target_trait {\n+        ast::Type::PathType(path) => path,\n+        _ => return None,\n+    };\n+    let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n+\n+    let mut result = Vec::new();\n+    for generic_arg in generic_arg_list.generic_args() {\n+        match generic_arg {\n+            ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n+            ast::GenericArg::AssocTypeArg(_)\n+            | ast::GenericArg::LifetimeArg(_)\n+            | ast::GenericArg::ConstArg(_) => (),\n+        }\n+    }\n+\n+    Some(result)\n+}"}, {"sha": "30128a24a222ed872edc1554bc212b5931c41ac2", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -24,7 +24,7 @@ use syntax::{\n \n use crate::{\n     assist_context::{AssistBuilder, AssistContext},\n-    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+    path_transform::PathTransform,\n };\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n@@ -132,14 +132,18 @@ pub fn add_trait_assoc_items_to_impl(\n     target_scope: hir::SemanticsScope,\n ) -> (ast::Impl, ast::AssocItem) {\n     let source_scope = sema.scope_for_def(trait_);\n-    let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_.clone()));\n-\n-    let items = items\n-        .into_iter()\n-        .map(|it| it.clone_for_update())\n-        .inspect(|it| ast_transform::apply(&*ast_transform, it))\n-        .map(|it| edit::remove_attrs_and_docs(&it).clone_subtree().clone_for_update());\n+\n+    let transform = PathTransform {\n+        subst: (trait_, impl_.clone()),\n+        source_scope: &source_scope,\n+        target_scope: &target_scope,\n+    };\n+\n+    let items = items.into_iter().map(|assoc_item| {\n+        let assoc_item = assoc_item.clone_for_update();\n+        transform.apply(assoc_item.clone());\n+        edit::remove_attrs_and_docs(&assoc_item).clone_subtree().clone_for_update()\n+    });\n \n     let res = impl_.clone_for_update();\n "}, {"sha": "19107ee3812d4c1c585afc1ff69e9ae86e7765ab", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -6,14 +6,12 @@ use std::{\n     ops::{self, RangeInclusive},\n };\n \n-use arrayvec::ArrayVec;\n-\n use crate::{\n     algo,\n     ast::{self, make, AstNode},\n-    ted, AstToken, InsertPosition, NodeOrToken, SyntaxElement, SyntaxKind,\n+    ted, AstToken, NodeOrToken, SyntaxElement, SyntaxKind,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n-    SyntaxNode, SyntaxToken, T,\n+    SyntaxNode, SyntaxToken,\n };\n \n impl ast::BinExpr {\n@@ -25,46 +23,6 @@ impl ast::BinExpr {\n     }\n }\n \n-impl ast::Path {\n-    #[must_use]\n-    pub fn with_segment(&self, segment: ast::PathSegment) -> ast::Path {\n-        if let Some(old) = self.segment() {\n-            return self.replace_children(\n-                single_node(old.syntax().clone()),\n-                iter::once(segment.syntax().clone().into()),\n-            );\n-        }\n-        self.clone()\n-    }\n-}\n-\n-impl ast::PathSegment {\n-    #[must_use]\n-    pub fn with_generic_args(&self, type_args: ast::GenericArgList) -> ast::PathSegment {\n-        self._with_generic_args(type_args, false)\n-    }\n-\n-    #[must_use]\n-    pub fn with_turbo_fish(&self, type_args: ast::GenericArgList) -> ast::PathSegment {\n-        self._with_generic_args(type_args, true)\n-    }\n-\n-    fn _with_generic_args(&self, type_args: ast::GenericArgList, turbo: bool) -> ast::PathSegment {\n-        if let Some(old) = self.generic_arg_list() {\n-            return self.replace_children(\n-                single_node(old.syntax().clone()),\n-                iter::once(type_args.syntax().clone().into()),\n-            );\n-        }\n-        let mut to_insert: ArrayVec<SyntaxElement, 2> = ArrayVec::new();\n-        if turbo {\n-            to_insert.push(make::token(T![::]).into());\n-        }\n-        to_insert.push(type_args.syntax().clone().into());\n-        self.insert_children(InsertPosition::Last, to_insert)\n-    }\n-}\n-\n impl ast::UseTree {\n     /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n     #[must_use]\n@@ -233,16 +191,6 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n }\n \n pub trait AstNodeEdit: AstNode + Clone + Sized {\n-    #[must_use]\n-    fn insert_children(\n-        &self,\n-        position: InsertPosition<SyntaxElement>,\n-        to_insert: impl IntoIterator<Item = SyntaxElement>,\n-    ) -> Self {\n-        let new_syntax = algo::insert_children(self.syntax(), position, to_insert);\n-        Self::cast(new_syntax).unwrap()\n-    }\n-\n     #[must_use]\n     fn replace_children(\n         &self,"}, {"sha": "ca8103668b8c474fd76bf73636aceb94afff9f33", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -239,6 +239,16 @@ impl ast::TypeBoundList {\n     }\n }\n \n+impl ast::PathSegment {\n+    pub fn get_or_create_generic_arg_list(&self) -> ast::GenericArgList {\n+        if self.generic_arg_list().is_none() {\n+            let arg_list = make::generic_arg_list().clone_for_update();\n+            ted::append_child(self.syntax(), arg_list.syntax())\n+        }\n+        self.generic_arg_list().unwrap()\n+    }\n+}\n+\n impl ast::UseTree {\n     pub fn remove(&self) {\n         for &dir in [Direction::Next, Direction::Prev].iter() {"}, {"sha": "0cf17062610996e5079b39d9c38e255215cd623e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -106,6 +106,10 @@ pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {\n     ast_from_text(&format!(\"impl {} for {} {{}}\", trait_, ty))\n }\n \n+pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n+    ast_from_text(\"const S: T<> = ();\")\n+}\n+\n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"use {};\", name_ref))\n }"}, {"sha": "ae970f44f16a02368dedc75dfa928a3a13072d73", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542337eca49986d785db2318bfe9c70809d4a229/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=542337eca49986d785db2318bfe9c70809d4a229", "patch": "@@ -184,6 +184,9 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     if left.kind() == T![&] && right.kind() == SyntaxKind::LIFETIME {\n         return None;\n     }\n+    if right.kind() == SyntaxKind::GENERIC_ARG_LIST {\n+        return None;\n+    }\n \n     if right.kind() == SyntaxKind::USE {\n         let mut indent = IndentLevel::from_element(left);"}]}