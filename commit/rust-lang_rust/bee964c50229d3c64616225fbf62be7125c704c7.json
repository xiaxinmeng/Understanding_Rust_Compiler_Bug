{"sha": "bee964c50229d3c64616225fbf62be7125c704c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZTk2NGM1MDIyOWQzYzY0NjE2MjI1ZmJmNjJiZTcxMjVjNzA0Yzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-03T02:05:05Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-04T03:32:38Z"}, "message": "Clarify unaligned fields in ptr::read_unaligned.", "tree": {"sha": "78cbc6344fafa451d2ac973910c36f6c8ce08423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78cbc6344fafa451d2ac973910c36f6c8ce08423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bee964c50229d3c64616225fbf62be7125c704c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bee964c50229d3c64616225fbf62be7125c704c7", "html_url": "https://github.com/rust-lang/rust/commit/bee964c50229d3c64616225fbf62be7125c704c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bee964c50229d3c64616225fbf62be7125c704c7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "html_url": "https://github.com/rust-lang/rust/commit/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "7a33174d59ffc970e1e8f6d56baba7c5574b8704", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bee964c50229d3c64616225fbf62be7125c704c7/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee964c50229d3c64616225fbf62be7125c704c7/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=bee964c50229d3c64616225fbf62be7125c704c7", "patch": "@@ -647,42 +647,50 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n /// [valid]: ../ptr/index.html#safety\n ///\n-/// # Examples\n+/// ## On `packed` structs\n ///\n-/// Access members of a packed struct by reference:\n+/// It is currently impossible to create raw pointers to unaligned fields\n+/// of a packed struct.\n ///\n-/// ```\n-/// use std::ptr;\n+/// Attempting to create a raw pointer to an `unaligned` struct field with\n+/// an expression such as `&packed.unaligned as *const FieldType` creates an\n+/// intermediate unaligned reference before converting that to a raw pointer.\n+/// That this reference is temporary and immediately cast is inconsequential\n+/// as the compiler always expects references to be properly aligned.\n+/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n+/// *undefined behavior* in your program.\n ///\n+/// An example of what not to do and how this relates to `read_unaligned` is:\n+///\n+/// ```\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n-/// let x = Packed {\n+/// let packed = Packed {\n ///     _padding: 0x00,\n ///     unaligned: 0x01020304,\n /// };\n ///\n /// let v = unsafe {\n-///     // Take the address of a 32-bit integer which is not aligned.\n-///     // This must be done as a raw pointer; unaligned references are invalid.\n-///     let unaligned = &x.unaligned as *const u32;\n+///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n+///     let unaligned =\n+///         // A temporary unaligned reference is created here which results in\n+///         // undefined behavior regardless of whether the reference is used or not.\n+///         &packed.unaligned\n+///         // Casting to a raw pointer doesn't help; the mistake already happened.\n+///         as *const u32;\n ///\n-///     // Dereferencing normally will emit an aligned load instruction,\n-///     // causing undefined behavior.\n-///     // let v = *unaligned; // ERROR\n-///\n-///     // Instead, use `read_unaligned` to read improperly aligned values.\n-///     let v = ptr::read_unaligned(unaligned);\n+///     let v = std::ptr::read_unaligned(unaligned);\n ///\n ///     v\n /// };\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n /// ```\n+///\n+/// Accessing unaligned values directly with e.g. `packed.unaligned` is safe however.\n+// FIXME: Update docs based on outcome of RFC #2582 and friends.\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n@@ -811,38 +819,48 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n-/// # Examples\n+/// ## On `packed` structs\n ///\n-/// Access fields in a packed struct:\n+/// It is currently impossible to create raw pointers to unaligned fields\n+/// of a packed struct.\n ///\n-/// ```\n-/// use std::{mem, ptr};\n+/// Attempting to create a raw pointer to an `unaligned` struct field with\n+/// an expression such as `&packed.unaligned as *const FieldType` creates an\n+/// intermediate unaligned reference before converting that to a raw pointer.\n+/// That this reference is temporary and immediately cast is inconsequential\n+/// as the compiler always expects references to be properly aligned.\n+/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n+/// *undefined behavior* in your program.\n ///\n+/// An example of what not to do and how this relates to `write_unaligned` is:\n+///\n+/// ```\n /// #[repr(packed, C)]\n-/// #[derive(Default)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n /// let v = 0x01020304;\n-/// let mut x: Packed = unsafe { mem::zeroed() };\n+/// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n-/// unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &mut x.unaligned as *mut u32;\n+/// let v = unsafe {\n+///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n+///     let unaligned =\n+///         // A temporary unaligned reference is created here which results in\n+///         // undefined behavior regardless of whether the reference is used or not.\n+///         &mut packed.unaligned\n+///         // Casting to a raw pointer doesn't help; the mistake already happened.\n+///         as *mut u32;\n ///\n-///     // Dereferencing normally will emit an aligned store instruction,\n-///     // causing undefined behavior because the pointer is not aligned.\n-///     // *unaligned = v; // ERROR\n+///     std::ptr::write_unaligned(unaligned, v);\n ///\n-///     // Instead, use `write_unaligned` to write improperly aligned values.\n-///     ptr::write_unaligned(unaligned, v);\n-/// }\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n+///     v\n+/// };\n /// ```\n+///\n+/// Accessing unaligned values directly with e.g. `packed.unaligned` is safe however.\n+// FIXME: Update docs based on outcome of RFC #2582 and friends.\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {"}]}