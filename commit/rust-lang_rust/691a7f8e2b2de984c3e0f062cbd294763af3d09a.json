{"sha": "691a7f8e2b2de984c3e0f062cbd294763af3d09a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MWE3ZjhlMmIyZGU5ODRjM2UwZjA2MmNiZDI5NDc2M2FmM2QwOWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-27T09:30:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-27T09:30:15Z"}, "message": "Auto merge of #56094 - RalfJung:memory-data-revived, r=oli-obk\n\nmiri: Memory data revived, Hooks for stack frame push/pop\n\nr? @oli-obk", "tree": {"sha": "0a10c3722177375062d614d157beec39b76a180e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a10c3722177375062d614d157beec39b76a180e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/691a7f8e2b2de984c3e0f062cbd294763af3d09a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/691a7f8e2b2de984c3e0f062cbd294763af3d09a", "html_url": "https://github.com/rust-lang/rust/commit/691a7f8e2b2de984c3e0f062cbd294763af3d09a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/691a7f8e2b2de984c3e0f062cbd294763af3d09a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45205f2ac18e926ec61f2672d16ec3b955de5652", "url": "https://api.github.com/repos/rust-lang/rust/commits/45205f2ac18e926ec61f2672d16ec3b955de5652", "html_url": "https://github.com/rust-lang/rust/commit/45205f2ac18e926ec61f2672d16ec3b955de5652"}, {"sha": "349271ab2c795b068dd208176fe00d9b257ab4f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/349271ab2c795b068dd208176fe00d9b257ab4f0", "html_url": "https://github.com/rust-lang/rust/commit/349271ab2c795b068dd208176fe00d9b257ab4f0"}], "stats": {"total": 393, "additions": 258, "deletions": 135}, "files": [{"sha": "ab3bc4cdf9fb6b311037ebd1016e73a9bf670a0a", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 151, "deletions": 99, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -53,6 +53,94 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub extra: Extra,\n }\n \n+\n+pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n+    /// Hook to initialize the extra data when an allocation gets created.\n+    fn memory_allocated(\n+        _size: Size,\n+        _memory_extra: &MemoryExtra\n+    ) -> Self;\n+\n+    /// Hook for performing extra checks on a memory read access.\n+    ///\n+    /// Takes read-only access to the allocation so we can keep all the memory read\n+    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// need to mutate.\n+    #[inline(always)]\n+    fn memory_read(\n+        _alloc: &Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory write access.\n+    #[inline(always)]\n+    fn memory_written(\n+        _alloc: &mut Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory deallocation.\n+    /// `size` will be the size of the allocation.\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        _alloc: &mut Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+}\n+\n+impl AllocationExtra<(), ()> for () {\n+    #[inline(always)]\n+    fn memory_allocated(\n+        _size: Size,\n+        _memory_extra: &()\n+    ) -> Self {\n+        ()\n+    }\n+}\n+\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a read-only allocation initialized by the given bytes\n+    pub fn from_bytes(slice: &[u8], align: Align, extra: Extra) -> Self {\n+        let mut undef_mask = UndefMask::new(Size::ZERO);\n+        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n+        Self {\n+            bytes: slice.to_owned(),\n+            relocations: Relocations::new(),\n+            undef_mask,\n+            align,\n+            mutability: Mutability::Immutable,\n+            extra,\n+        }\n+    }\n+\n+    pub fn from_byte_aligned_bytes(slice: &[u8], extra: Extra) -> Self {\n+        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap(), extra)\n+    }\n+\n+    pub fn undef(size: Size, align: Align, extra: Extra) -> Self {\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        Allocation {\n+            bytes: vec![0; size.bytes() as usize],\n+            relocations: Relocations::new(),\n+            undef_mask: UndefMask::new(size),\n+            align,\n+            mutability: Mutability::Mutable,\n+            extra,\n+        }\n+    }\n+}\n+\n+impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n+\n /// Alignment and bounds checks\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n@@ -81,21 +169,24 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n-    fn get_bytes_internal(\n+    fn get_bytes_internal<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.check_bounds(cx, ptr, size)?;\n \n         if check_defined_and_ptr {\n@@ -115,35 +206,44 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     #[inline]\n-    pub fn get_bytes(\n+    pub fn get_bytes<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_undef_and_ptr<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n-    pub fn get_bytes_mut(\n+    pub fn get_bytes_mut<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n+    ) -> EvalResult<'tcx, &mut [u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_bounds(cx, ptr, size)?;\n \n@@ -160,14 +260,17 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n }\n \n /// Reading and writing\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n-    pub fn read_c_str(\n+    pub fn read_c_str<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         match self.bytes[offset..].iter().position(|&c| c == 0) {\n@@ -185,13 +288,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor undef bytes.\n-    pub fn check_bytes(\n+    pub fn check_bytes<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         // Check bounds and relocations on the edges\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Check undef and ptr\n@@ -205,25 +311,31 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// Will do bounds checks on the allocation.\n-    pub fn write_bytes(\n+    pub fn write_bytes<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    pub fn write_repeat(\n+    pub fn write_repeat<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n             *b = val;\n@@ -239,12 +351,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_scalar(\n+    pub fn read_scalar<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         // get_bytes_unchecked tests relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n@@ -274,11 +389,14 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_ptr_sized(\n+    pub fn read_ptr_sized<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n@@ -290,13 +408,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_scalar(\n+    pub fn write_scalar<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n@@ -335,12 +456,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_ptr_sized(\n+    pub fn write_ptr_sized<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr.into(), val, ptr_size)\n     }\n@@ -464,79 +588,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Default + Clone {\n-    /// Hook for performing extra checks on a memory read access.\n-    ///\n-    /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n-    /// need to mutate.\n-    #[inline]\n-    fn memory_read(\n-        _alloc: &Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Hook for performing extra checks on a memory write access.\n-    #[inline]\n-    fn memory_written(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Hook for performing extra checks on a memory deallocation.\n-    /// `size` will be the size of the allocation.\n-    #[inline]\n-    fn memory_deallocated(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-}\n-\n-impl AllocationExtra<()> for () {}\n-\n-impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n-    /// Creates a read-only allocation initialized by the given bytes\n-    pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::ZERO);\n-        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n-        Self {\n-            bytes: slice.to_owned(),\n-            relocations: Relocations::new(),\n-            undef_mask,\n-            align,\n-            mutability: Mutability::Immutable,\n-            extra: Extra::default(),\n-        }\n-    }\n-\n-    pub fn from_byte_aligned_bytes(slice: &[u8]) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n-    }\n-\n-    pub fn undef(size: Size, align: Align) -> Self {\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        Allocation {\n-            bytes: vec![0; size.bytes() as usize],\n-            relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size),\n-            align,\n-            mutability: Mutability::Mutable,\n-            extra: Extra::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n-\n+/// Relocations\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n "}, {"sha": "5780fbe55ad1f34100169c6842dd8acf062e9d18", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n-        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n+        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes, ());\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().allocate(alloc)\n     }"}, {"sha": "291b5c170ef365c328f82240f0e8cada7696a45e", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -65,6 +65,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n         return_place: None,\n         return_to_block: StackPopCleanup::Goto(None), // never pop\n         stmt: 0,\n+        extra: (),\n     });\n     Ok(ecx)\n }\n@@ -353,9 +354,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     for CompileTimeInterpreter<'a, 'mir, 'tcx>\n {\n     type MemoryKinds = !;\n-    type AllocExtra = ();\n     type PointerTag = ();\n \n+    type FrameExtra = ();\n+    type MemoryExtra = ();\n+    type AllocExtra = ();\n+\n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n@@ -432,16 +436,18 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn find_foreign_static(\n-        _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         _def_id: DefId,\n+        _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        _memory_extra: &(),\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n-    fn adjust_static_allocation(\n-        alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n+    fn adjust_static_allocation<'b>(\n+        alloc: &'b Allocation,\n+        _memory_extra: &(),\n+    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n         // We do not use a tag so we can just cheaply forward the reference\n         Cow::Borrowed(alloc)\n     }\n@@ -487,6 +493,22 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(ptr)\n     }\n+\n+    #[inline(always)]\n+    fn stack_push(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Called immediately before a stack frame gets popped\n+    #[inline(always)]\n+    fn stack_pop(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _extra: (),\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "d36d530fe78b24ecdaeeddfe23c626373545e3ec", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -49,15 +49,15 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub(crate) memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag>>,\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n \n     /// A cache for deduplicating vtables\n     pub(super) vtables: FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), AllocId>,\n }\n \n /// A stack frame.\n #[derive(Clone)]\n-pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n+pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -96,6 +96,9 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n \n     /// The index of the currently evaluated statement.\n     pub stmt: usize,\n+\n+    /// Extra data for the machine\n+    pub extra: Extra,\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n@@ -196,7 +199,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag>] {\n+    pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         &self.stack\n     }\n \n@@ -207,12 +210,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag> {\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n-    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n@@ -294,7 +297,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n     pub fn layout_of_local(\n         &self,\n-        frame: &Frame<'mir, 'tcx, M::PointerTag>,\n+        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local\n     ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n         let local_ty = frame.mir.local_decls[local].ty;\n@@ -424,6 +427,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         ::log_settings::settings().indentation += 1;\n \n         // first push a stack frame so we have access to the local substs\n+        let extra = M::stack_push(self)?;\n         self.stack.push(Frame {\n             mir,\n             block: mir::START_BLOCK,\n@@ -435,6 +439,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             span,\n             instance,\n             stmt: 0,\n+            extra,\n         });\n \n         // don't allocate at all for trivial constants\n@@ -504,6 +509,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n+        M::stack_pop(self, frame.extra)?;\n         // Abort early if we do not want to clean up: We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n         match frame.return_to_block {"}, {"sha": "d7a3a27bbe8c2b2e8d4eb60f88402f69a7e4cd6b", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -77,8 +77,16 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n \n+    /// Extra data stored in every call frame.\n+    type FrameExtra;\n+\n+    /// Extra data stored in memory.  A reference to this is available when `AllocExtra`\n+    /// gets initialized, so you can e.g. have an `Rc` here if there is global state you\n+    /// need access to in the `AllocExtra` hooks.\n+    type MemoryExtra: Default;\n+\n     /// Extra data stored in every allocation.\n-    type AllocExtra: AllocationExtra<Self::PointerTag>;\n+    type AllocExtra: AllocationExtra<Self::PointerTag, Self::MemoryExtra>;\n \n     /// Memory's allocation map\n     type MemoryMap:\n@@ -136,8 +144,9 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     fn find_foreign_static(\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        memory_extra: &Self::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n     /// Called to turn an allocation obtained from the `tcx` into one that has\n@@ -147,9 +156,10 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    fn adjust_static_allocation(\n-        alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Self::PointerTag, Self::AllocExtra>>;\n+    fn adjust_static_allocation<'b>(\n+        alloc: &'b Allocation,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -207,4 +217,15 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n+\n+    /// Called immediately before a new stack frame got pushed\n+    fn stack_push(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+    ) -> EvalResult<'tcx, Self::FrameExtra>;\n+\n+    /// Called immediately after a stack frame gets popped\n+    fn stack_pop(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        extra: Self::FrameExtra,\n+    ) -> EvalResult<'tcx>;\n }"}, {"sha": "97d7e1586b811354abed733e7fc43497180e0395", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -73,6 +73,9 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// that do not exist any more.\n     dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n+    /// Extra data added by the machine.\n+    pub extra: M::MemoryExtra,\n+\n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n     pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n@@ -88,13 +91,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n \n // FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n-impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n-    Clone for Memory<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M>\n+    Clone\n+for\n+    Memory<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n+            extra: (),\n             tcx: self.tcx,\n         }\n     }\n@@ -103,8 +112,9 @@ impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>) -> Self {\n         Memory {\n-            alloc_map: Default::default(),\n+            alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n+            extra: M::MemoryExtra::default(),\n             tcx,\n         }\n     }\n@@ -133,7 +143,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n-        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?))\n+        let extra = AllocationExtra::memory_allocated(size, &self.extra);\n+        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)?))\n     }\n \n     pub fn reallocate(\n@@ -309,15 +320,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// this machine use the same pointer tag, so it is indirected through\n     /// `M::static_with_default_tag`.\n     fn get_static_alloc(\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         id: AllocId,\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        memory_extra: &M::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n             Some(AllocType::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n-                return Ok(M::adjust_static_allocation(mem))\n+                return Ok(M::adjust_static_allocation(mem, memory_extra))\n             }\n             Some(AllocType::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n@@ -331,7 +343,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // We got a \"lazy\" static that has not been computed yet, do some work\n         trace!(\"static_alloc: Need to compute {:?}\", def_id);\n         if tcx.is_foreign_item(def_id) {\n-            return M::find_foreign_static(tcx, def_id);\n+            return M::find_foreign_static(def_id, tcx, memory_extra);\n         }\n         let instance = Instance::mono(tcx.tcx, def_id);\n         let gid = GlobalId {\n@@ -351,7 +363,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n             // We got tcx memory. Let the machine figure out whether and how to\n             // turn that into memory with the right pointer tag.\n-            M::adjust_static_allocation(allocation)\n+            M::adjust_static_allocation(allocation, memory_extra)\n         })\n     }\n \n@@ -361,7 +373,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `EvalResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(self.tcx, id).map_err(Err)?;\n+            let alloc = Self::get_static_alloc(id, self.tcx, &self.extra).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -390,10 +402,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n+        let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = Self::get_static_alloc(tcx, id)?;\n+            let alloc = Self::get_static_alloc(id, tcx, memory_extra)?;\n             if alloc.mutability == Mutability::Immutable {\n                 return err!(ModifiedConstantMemory);\n             }\n@@ -601,7 +614,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n /// Interning (for CTFE)\n impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=()>,\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     /// mark an allocation as static and initialized, either mutable or not"}, {"sha": "83ceadada65ce68f0e1a62c47a064e6f65a47aee", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// When you know the layout of the local in advance, you can pass it as last argument\n     pub fn access_local(\n         &self,\n-        frame: &super::Frame<'mir, 'tcx, M::PointerTag>,\n+        frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {"}, {"sha": "1b47530eaec65437065339102c8f736b4fdbc2ef", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -295,10 +295,12 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n where\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<Tag>,\n+    M::AllocExtra: AllocationExtra<Tag, M::MemoryExtra>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`."}, {"sha": "f9ce7b4319fac9d30231f07f0a93e41ddf6d0930", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -323,6 +323,7 @@ impl_stable_hash_for!(impl<'tcx, 'mir: 'tcx> for struct Frame<'mir, 'tcx> {\n     locals,\n     block,\n     stmt,\n+    extra,\n });\n \n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n@@ -340,6 +341,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             locals,\n             block,\n             stmt,\n+            extra: _,\n         } = self;\n \n         FrameSnapshot {"}, {"sha": "d98d05bc01b8504905e74987db362b474da3e87d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691a7f8e2b2de984c3e0f062cbd294763af3d09a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=691a7f8e2b2de984c3e0f062cbd294763af3d09a", "patch": "@@ -312,12 +312,16 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                // No undef allowed here.  Eventually this should be consistent with\n-                // the integer types.\n-                let _ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", self.path);\n-                let _meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", self.path);\n+                if self.const_mode {\n+                    // Integers/floats in CTFE: For consistency with integers, we do not\n+                    // accept undef.\n+                    let _ptr = try_validation!(value.to_scalar_ptr(),\n+                        \"undefined address in raw pointer\", self.path);\n+                    let _meta = try_validation!(value.to_meta(),\n+                        \"uninitialized data in raw fat pointer metadata\", self.path);\n+                } else {\n+                    // Remain consistent with `usize`: Accept anything.\n+                }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle fat pointers."}]}