{"sha": "a419dd1c013846754c0a3c8dae3842c2739864d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTlkZDFjMDEzODQ2NzU0YzBhM2M4ZGFlMzg0MmMyNzM5ODY0ZDQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-05T17:45:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-05T17:45:15Z"}, "message": "Rollup merge of #39538 - stjepang:slightly-optimize-sort, r=alexcrichton\n\nSlightly optimize slice::sort\n\nFirst, get rid of some bound checks.\n\nSecond, instead of comparing by ternary `compare` function, use a binary function testing whether an element is less than some other element. This apparently makes it easier for the compiler to reason about the code. I've noticed the same effect with [pdqsort](https://github.com/stjepang/pdqsort) crate.\n\nBenchmark:\n\n```\nname                                        before ns/iter        after ns/iter         diff ns/iter   diff %\nslice::bench::sort_large_ascending          8,969 (8919 MB/s)     7,410 (10796 MB/s)          -1,559  -17.38%\nslice::bench::sort_large_big_ascending      355,640 (3599 MB/s)   359,137 (3564 MB/s)          3,497    0.98%\nslice::bench::sort_large_big_descending     427,112 (2996 MB/s)   424,721 (3013 MB/s)         -2,391   -0.56%\nslice::bench::sort_large_big_random         2,207,799 (579 MB/s)  2,138,804 (598 MB/s)       -68,995   -3.13%\nslice::bench::sort_large_descending         13,694 (5841 MB/s)    13,514 (5919 MB/s)            -180   -1.31%\nslice::bench::sort_large_mostly_ascending   239,697 (333 MB/s)    203,542 (393 MB/s)         -36,155  -15.08%\nslice::bench::sort_large_mostly_descending  270,102 (296 MB/s)    234,263 (341 MB/s)         -35,839  -13.27%\nslice::bench::sort_large_random             513,406 (155 MB/s)    470,084 (170 MB/s)         -43,322   -8.44%\nslice::bench::sort_large_random_expensive   23,650,321 (3 MB/s)   23,675,098 (3 MB/s)         24,777    0.10%\nslice::bench::sort_medium_ascending         143 (5594 MB/s)       132 (6060 MB/s)                -11   -7.69%\nslice::bench::sort_medium_descending        197 (4060 MB/s)       188 (4255 MB/s)                 -9   -4.57%\nslice::bench::sort_medium_random            3,358 (238 MB/s)      3,271 (244 MB/s)               -87   -2.59%\nslice::bench::sort_small_ascending          32 (2500 MB/s)        32 (2500 MB/s)                   0    0.00%\nslice::bench::sort_small_big_ascending      97 (13195 MB/s)       97 (13195 MB/s)                  0    0.00%\nslice::bench::sort_small_big_descending     247 (5182 MB/s)       249 (5140 MB/s)                  2    0.81%\nslice::bench::sort_small_big_random         502 (2549 MB/s)       498 (2570 MB/s)                 -4   -0.80%\nslice::bench::sort_small_descending         55 (1454 MB/s)        61 (1311 MB/s)                   6   10.91%\nslice::bench::sort_small_random             358 (223 MB/s)        356 (224 MB/s)                  -2   -0.56%\n```", "tree": {"sha": "fcd949b4bceb0b1f8b20a2b51ae401f710f44162", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd949b4bceb0b1f8b20a2b51ae401f710f44162"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a419dd1c013846754c0a3c8dae3842c2739864d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a419dd1c013846754c0a3c8dae3842c2739864d4", "html_url": "https://github.com/rust-lang/rust/commit/a419dd1c013846754c0a3c8dae3842c2739864d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a419dd1c013846754c0a3c8dae3842c2739864d4/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70cc1d34fd2d34bfc931782486a83ac040d8aa05", "url": "https://api.github.com/repos/rust-lang/rust/commits/70cc1d34fd2d34bfc931782486a83ac040d8aa05", "html_url": "https://github.com/rust-lang/rust/commit/70cc1d34fd2d34bfc931782486a83ac040d8aa05"}, {"sha": "fa457bff264ea62acf56bb9e645b8227ecdc7529", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa457bff264ea62acf56bb9e645b8227ecdc7529", "html_url": "https://github.com/rust-lang/rust/commit/fa457bff264ea62acf56bb9e645b8227ecdc7529"}], "stats": {"total": 77, "additions": 39, "deletions": 38}, "files": [{"sha": "2ea953df8735729b6d02dbecf7453d1a07615d9d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a419dd1c013846754c0a3c8dae3842c2739864d4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a419dd1c013846754c0a3c8dae3842c2739864d4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a419dd1c013846754c0a3c8dae3842c2739864d4", "patch": "@@ -98,7 +98,7 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use alloc::boxed::Box;\n-use core::cmp::Ordering::{self, Greater};\n+use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n@@ -1089,7 +1089,7 @@ impl<T> [T] {\n     pub fn sort(&mut self)\n         where T: Ord\n     {\n-        self.sort_by(|a, b| a.cmp(b))\n+        merge_sort(self, |a, b| a.lt(b));\n     }\n \n     /// Sorts the slice using `f` to extract a key to compare elements by.\n@@ -1119,7 +1119,7 @@ impl<T> [T] {\n     pub fn sort_by_key<B, F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> B, B: Ord\n     {\n-        self.sort_by(|a, b| f(a).cmp(&f(b)))\n+        merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Sorts the slice using `compare` to compare elements.\n@@ -1149,10 +1149,10 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F)\n+    pub fn sort_by<F>(&mut self, mut compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n     {\n-        merge_sort(self, compare)\n+        merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n     /// Copies the elements from `src` into `self`.\n@@ -1355,10 +1355,10 @@ impl<T: Clone> ToOwned for [T] {\n /// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n ///\n /// This is the integral subroutine of insertion sort.\n-fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n-    if v.len() >= 2 && compare(&v[0], &v[1]) == Greater {\n+    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n             // There are three ways to implement insertion here:\n             //\n@@ -1381,12 +1381,12 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `compare`.\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n             // 2. Fills the remaining hole in `v` in the end.\n             //\n             // Panic safety:\n             //\n-            // If `compare` panics at any point during the process, `hole` will get dropped and\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n             let mut hole = InsertionHole {\n@@ -1396,7 +1396,7 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n-                if compare(&tmp.value, &v[i]) != Greater {\n+                if !is_less(&v[i], &tmp.value) {\n                     break;\n                 }\n                 ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n@@ -1432,8 +1432,8 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n ///\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n-unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -1449,12 +1449,12 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n     // hole in `v`.\n     //\n     // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n-    // 1. Protects integrity of `v` from panics in `compare`.\n+    // 1. Protects integrity of `v` from panics in `is_less`.\n     // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n     //\n     // Panic safety:\n     //\n-    // If `compare` panics at any point during the process, `hole` will get dropped and fill the\n+    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n     // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n     // object it initially held exactly once.\n     let mut hole;\n@@ -1476,7 +1476,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n-            let to_copy = if compare(&**left, &*right) == Greater {\n+            let to_copy = if is_less(&*right, &**left) {\n                 get_and_increment(&mut right)\n             } else {\n                 get_and_increment(left)\n@@ -1500,7 +1500,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n-            let to_copy = if compare(&*left.offset(-1), &*right.offset(-1)) == Greater {\n+            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n                 decrement_and_get(left)\n             } else {\n                 decrement_and_get(right)\n@@ -1550,8 +1550,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n-fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if size_of::<T>() == 0 {\n@@ -1565,7 +1565,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     //\n     // Short runs are extended using insertion sort to span at least `min_run` elements, in order\n     // to improve performance.\n-    let (max_insertion, min_run) = if size_of::<T>() <= 16 {\n+    let (max_insertion, min_run) = if size_of::<T>() <= 2 * mem::size_of::<usize>() {\n         (64, 32)\n     } else {\n         (32, 16)\n@@ -1577,15 +1577,15 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     if len <= max_insertion {\n         if len >= 2 {\n             for i in (0..len-1).rev() {\n-                insert_head(&mut v[i..], &mut compare);\n+                insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n         return;\n     }\n \n     // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n     // shallow copies of the contents of `v` without risking the dtors running on copies if\n-    // `compare` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n     let mut buf = Vec::with_capacity(len / 2);\n \n@@ -1600,14 +1600,18 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         let mut start = end - 1;\n         if start > 0 {\n             start -= 1;\n-            if compare(&v[start], &v[start + 1]) == Greater {\n-                while start > 0 && compare(&v[start - 1], &v[start]) == Greater {\n-                    start -= 1;\n-                }\n-                v[start..end].reverse();\n-            } else {\n-                while start > 0 && compare(&v[start - 1], &v[start]) != Greater {\n-                    start -= 1;\n+            unsafe {\n+                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n+                    while start > 0 && is_less(v.get_unchecked(start),\n+                                               v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n+                    v[start..end].reverse();\n+                } else {\n+                    while start > 0 && !is_less(v.get_unchecked(start),\n+                                                v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n                 }\n             }\n         }\n@@ -1616,7 +1620,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         // merge sort on short sequences, so this significantly improves performance.\n         while start > 0 && end - start < min_run {\n             start -= 1;\n-            insert_head(&mut v[start..end], &mut compare);\n+            insert_head(&mut v[start..end], &mut is_less);\n         }\n \n         // Push this run onto the stack.\n@@ -1632,7 +1636,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n             let right = runs[r];\n             unsafe {\n                 merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut compare);\n+                      &mut is_less);\n             }\n             runs[r] = Run {\n                 start: left.start,"}, {"sha": "b9dec6be7b8853b9401c6089b6455e049bec145a", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a419dd1c013846754c0a3c8dae3842c2739864d4/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a419dd1c013846754c0a3c8dae3842c2739864d4/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=a419dd1c013846754c0a3c8dae3842c2739864d4", "patch": "@@ -1429,18 +1429,15 @@ mod bench {\n     fn sort_large_random_expensive(b: &mut Bencher) {\n         let len = 10000;\n         b.iter(|| {\n+            let mut v = gen_random(len);\n             let mut count = 0;\n-            let cmp = move |a: &u64, b: &u64| {\n+            v.sort_by(|a: &u64, b: &u64| {\n                 count += 1;\n                 if count % 1_000_000_000 == 0 {\n                     panic!(\"should not happen\");\n                 }\n                 (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n-            };\n-\n-            let mut v = gen_random(len);\n-            v.sort_by(cmp);\n-\n+            });\n             black_box(count);\n         });\n         b.bytes = len as u64 * mem::size_of::<u64>() as u64;"}]}