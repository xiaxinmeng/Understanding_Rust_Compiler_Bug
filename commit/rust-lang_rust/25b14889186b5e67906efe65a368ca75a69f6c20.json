{"sha": "25b14889186b5e67906efe65a368ca75a69f6c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YjE0ODg5MTg2YjVlNjc5MDZlZmU2NWEzNjhjYTc1YTY5ZjZjMjA=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2017-02-20T21:14:25Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2017-02-20T22:19:41Z"}, "message": "Simplify adaptive hashmap", "tree": {"sha": "bbbf27e854c318def9f03c52488511f20491c35d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbbf27e854c318def9f03c52488511f20491c35d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25b14889186b5e67906efe65a368ca75a69f6c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25b14889186b5e67906efe65a368ca75a69f6c20", "html_url": "https://github.com/rust-lang/rust/commit/25b14889186b5e67906efe65a368ca75a69f6c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25b14889186b5e67906efe65a368ca75a69f6c20/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1368fc4f497b6387b00850dc5a95df5d6974b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1368fc4f497b6387b00850dc5a95df5d6974b43", "html_url": "https://github.com/rust-lang/rust/commit/c1368fc4f497b6387b00850dc5a95df5d6974b43"}], "stats": {"total": 34, "additions": 11, "deletions": 23}, "files": [{"sha": "f0738fe9b7033fea50795eaccb0dbe33238f4760", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25b14889186b5e67906efe65a368ca75a69f6c20/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b14889186b5e67906efe65a368ca75a69f6c20/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=25b14889186b5e67906efe65a368ca75a69f6c20", "patch": "@@ -182,46 +182,37 @@ impl DefaultResizePolicy {\n // ----------------------\n // To protect against degenerate performance scenarios (including DOS attacks),\n // the implementation includes an adaptive behavior that can resize the map\n-// early (before its capacity is exceeded) when suspiciously long probe or\n-// forward shifts sequences are encountered.\n+// early (before its capacity is exceeded) when suspiciously long probe sequences\n+// are encountered.\n //\n // With this algorithm in place it would be possible to turn a CPU attack into\n // a memory attack due to the aggressive resizing. To prevent that the\n-// adaptive behavior only triggers when the map occupancy is half the maximum occupancy.\n+// adaptive behavior only triggers when the map is at least half full.\n // This reduces the effectiveness of the algorithm but also makes it completely safe.\n //\n // The previous safety measure also prevents degenerate interactions with\n // really bad quality hash algorithms that can make normal inputs look like a\n // DOS attack.\n //\n const DISPLACEMENT_THRESHOLD: usize = 128;\n-const FORWARD_SHIFT_THRESHOLD: usize = 512;\n //\n-// The thresholds of 128 and 512 are chosen to minimize the chance of exceeding them.\n+// The threshold of 128 is chosen to minimize the chance of exceeding it.\n // In particular, we want that chance to be less than 10^-8 with a load of 90%.\n // For displacement, the smallest constant that fits our needs is 90,\n-// so we round that up to 128. For the number of forward-shifted buckets,\n-// we choose k=512. Keep in mind that the run length is a sum of the displacement and\n-// the number of forward-shifted buckets, so its threshold is 128+512=640.\n-// Even though the probability of having a run length of more than 640 buckets may be\n-// higher than the probability we want, it should be low enough.\n+// so we round that up to 128.\n //\n // At a load factor of \u03b1, the odds of finding the target bucket after exactly n\n // unsuccesful probes[1] are\n //\n // Pr_\u03b1{displacement = n} =\n // (1 - \u03b1) / \u03b1 * \u2211_{k\u22651} e^(-k\u03b1) * (k\u03b1)^(k+n) / (k + n)! * (1 - k\u03b1 / (k + n + 1))\n //\n-// We use this formula to find the probability of loading half of triggering the adaptive behavior\n+// We use this formula to find the probability of triggering the adaptive behavior\n //\n // Pr_0.909{displacement > 128} = 1.601 * 10^-11\n //\n-// FIXME: Extend with math for shift threshold in [2]\n-//\n // 1. Alfredo Viola (2005). Distributional analysis of Robin Hood linear probing\n //    hashing with buckets.\n-// 2. http://www.cs.tau.ac.il/~zwick/Adv-Alg-2015/Linear-Probing.pdf\n-\n \n /// A hash map implementation which uses linear probing with Robin Hood bucket\n /// stealing.\n@@ -494,7 +485,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n-                                -> (usize, &'a mut V) {\n+                                -> &'a mut V {\n     let start_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -519,15 +510,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                 Empty(bucket) => {\n                     // Found a hole!\n                     let bucket = bucket.put(hash, key, val);\n-                    let end_index = bucket.index();\n                     // Now that it's stolen, just read the value's pointer\n                     // right out of the table! Go back to the *starting point*.\n                     //\n                     // This use of `into_table` is misleading. It turns the\n                     // bucket, which is a FullBucket on top of a\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n-                    return (end_index - start_index, bucket.into_table().into_mut_refs().1);\n+                    return bucket.into_table().into_mut_refs().1;\n                 }\n                 Full(bucket) => bucket,\n             };\n@@ -2128,18 +2118,16 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, disp) => {\n-                let (shift, v_ref) = robin_hood(bucket, disp, self.hash, self.key, value);\n-                if disp >= DISPLACEMENT_THRESHOLD || shift >= FORWARD_SHIFT_THRESHOLD {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                v_ref\n+                robin_hood(bucket, disp, self.hash, self.key, value)\n             },\n             NoElem(bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                let bucket = bucket.put(self.hash, self.key, value);\n-                bucket.into_mut_refs().1\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             },\n         }\n     }"}]}