{"sha": "c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDRjMzFlZTQ2NTdkZTFlMTJkNTBmYWMyMzA2ZDBlNDZiMmIwNGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T00:42:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T00:43:06Z"}, "message": "rustc: Don't rebuild the AST when typechecking expressions", "tree": {"sha": "d3d50a519d607510904acb165b12f6048fbaf9a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d50a519d607510904acb165b12f6048fbaf9a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "html_url": "https://github.com/rust-lang/rust/commit/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3812afc3e9b83fdd8f1c4b8290968141725828", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3812afc3e9b83fdd8f1c4b8290968141725828", "html_url": "https://github.com/rust-lang/rust/commit/7a3812afc3e9b83fdd8f1c4b8290968141725828"}], "stats": {"total": 757, "additions": 232, "deletions": 525}, "files": [{"sha": "00c54e7b1669f25085b355dcd680098a9bdaee5e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 221, "deletions": 520, "changes": 741, "blob_url": "https://github.com/rust-lang/rust/blob/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "patch": "@@ -394,6 +394,12 @@ fn write_nil_type(ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n     be write_type_only(ntt, node_id, ty::mk_nil(tcx));\n }\n \n+// Writes the bottom type into the node type table.\n+fn write_bot_type(ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n+    // FIXME: Should be mk_bot(), but this breaks lots of stuff.\n+    be write_type_only(ntt, node_id, ty::mk_nil(tcx));\n+}\n+\n \n // Item collection - a pair of bootstrap passes:\n //\n@@ -1175,47 +1181,39 @@ mod Pushdown {\n     // TODO: enforce this via a predicate.\n     // TODO: This function is incomplete.\n \n-    fn pushdown_expr(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e)\n-            -> @ast::expr {\n+    fn pushdown_expr(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e) {\n         be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n     }\n \n     fn pushdown_expr_full(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e,\n-                          autoderef_kind adk) -> @ast::expr {\n-        auto e_1;\n-\n+                          autoderef_kind adk) {\n         alt (e.node) {\n             case (ast::expr_vec(?es_0, ?mut, ?ann)) {\n                 // TODO: enforce mutability\n \n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[@ast::expr] es_1 = [];\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n                         for (@ast::expr e_0 in es_0) {\n-                            es_1 += [pushdown_expr(fcx, mt.ty, e_0)];\n+                            pushdown_expr(fcx, mt.ty, e_0);\n                         }\n                     }\n                     case (_) {\n                         log_err \"vec expr doesn't have a vec type!\";\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_vec(es_1, mut, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[ast::elt] elts_1 = [];\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast::elt elt_0 in es_0) {\n-                            auto e_1 = pushdown_expr(fcx, mts.(i).ty,\n-                                                     elt_0.expr);\n-                            elts_1 += [rec(mut=elt_0.mut, expr=e_1)];\n+                            pushdown_expr(fcx, mts.(i).ty, elt_0.expr);\n                             i += 1u;\n                         }\n                     }\n@@ -1224,53 +1222,37 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_tup(elts_1, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n-                auto base_1 = base_0;\n-\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[ast::field] fields_1 = [];\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n                             case (none[@ast::expr]) {\n                                 auto i = 0u;\n                                 for (ast::field field_0 in fields_0) {\n                                     assert (str::eq(field_0.ident,\n-                                                   field_mts.(i).ident));\n-                                    auto e_1 =\n-                                        pushdown_expr(fcx,\n-                                                      field_mts.(i).mt.ty,\n-                                                      field_0.expr);\n-                                    fields_1 += [rec(mut=field_0.mut,\n-                                                        ident=field_0.ident,\n-                                                        expr=e_1)];\n+                                                    field_mts.(i).ident));\n+                                    pushdown_expr(fcx,\n+                                                  field_mts.(i).mt.ty,\n+                                                  field_0.expr);\n                                     i += 1u;\n                                 }\n                             }\n                             case (some[@ast::expr](?bx)) {\n \n-                                base_1 = some[@ast::expr]\n-                                    (pushdown_expr(fcx, t, bx));\n-\n                                 let vec[field] base_fields = [];\n \n                                 for (ast::field field_0 in fields_0) {\n \n                                     for (ty::field ft in field_mts) {\n                                         if (str::eq(field_0.ident,\n                                                     ft.ident)) {\n-                                            auto e_1 =\n-                                                pushdown_expr(fcx, ft.mt.ty,\n-                                                              field_0.expr);\n-                                            fields_1 +=\n-                                                [rec(mut=field_0.mut,\n-                                                        ident=field_0.ident,\n-                                                        expr=e_1)];\n+                                            pushdown_expr(fcx, ft.mt.ty,\n+                                                          field_0.expr);\n                                         }\n                                     }\n                                 }\n@@ -1282,13 +1264,11 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_rec(fields_1, base_1, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_bind(sube, es, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n@@ -1298,115 +1278,95 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_call(sube, es, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_self_method(id, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_binary(bop, lhs, rhs, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_unary(uop, sube, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_lit(lit, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_cast(sube, ast_ty, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                auto then_1 = pushdown_block(fcx, expected, then_0);\n+                pushdown_block(fcx, expected, then_0);\n \n-                auto else_1;\n                 alt (else_0) {\n-                    case (none[@ast::expr]) { else_1 = none[@ast::expr]; }\n+                    case (none[@ast::expr]) { /* no-op */ }\n                     case (some[@ast::expr](?e_0)) {\n-                        auto e_1 = pushdown_expr(fcx, expected, e_0);\n-                        else_1 = some[@ast::expr](e_1);\n+                        pushdown_expr(fcx, expected, e_0);\n                     }\n                 }\n-                e_1 = ast::expr_if(cond, then_1, else_1, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_for(decl, seq, bloc, triv_ann(ann.id, t));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_for_each(decl, seq, bloc,\n-                                         triv_ann(ann.id, t));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_while(cond, bloc, triv_ann(ann.id, t));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_do_while(bloc, cond, triv_ann(ann.id, t));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_block(bloc, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n-                auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast::expr_assign(lhs_1, rhs_1, triv_ann(ann.id, t));\n+                pushdown_expr(fcx, expected, lhs_0);\n+                pushdown_expr(fcx, expected, rhs_0);\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n-                auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast::expr_assign_op(op, lhs_1, rhs_1,\n-                                          triv_ann(ann.id, t));\n+                pushdown_expr(fcx, expected, lhs_0);\n+                pushdown_expr(fcx, expected, rhs_0);\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_field(lhs, rhs, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_index(base, index, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n@@ -1415,13 +1375,14 @@ mod Pushdown {\n                 auto t_0 = ann_to_type(fcx.ccx.node_types, ann);\n \n                 auto result_0 = Demand::full(fcx, e.span, expected, t_0,\n-                                            tp_substs_0, adk);\n+                                             tp_substs_0, adk);\n                 auto t = result_0._1;\n \n                 // Fill in the type parameter substitutions if they weren't\n                 // provided by the programmer.\n                 auto ty_params_opt;\n-                alt (ann.tps) {\n+                alt (ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n+                                                           ann)._0) {\n                     case (none[vec[ty::t]]) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n@@ -1430,83 +1391,67 @@ mod Pushdown {\n                     }\n                 }\n \n-                e_1 = ast::expr_path(pth, mk_ann_type(ann.id, t,\n-                                                      ty_params_opt));\n                 write_type(fcx.ccx.node_types, ann.id, tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n                     ann_to_type(fcx.ccx.node_types, ann), adk);\n-                e_1 = ast::expr_ext(p, args, body, expanded,\n-                                    triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n-            case (ast::expr_fail(_))  { e_1 = e.node; }\n-            case (ast::expr_log(_,_,_)) { e_1 = e.node; }\n-            case (ast::expr_break(_)) { e_1 = e.node; }\n-            case (ast::expr_cont(_))  { e_1 = e.node; }\n-            case (ast::expr_ret(_,_)) { e_1 = e.node; }\n-            case (ast::expr_put(_,_)) { e_1 = e.node; }\n-            case (ast::expr_be(_,_))  { e_1 = e.node; }\n-            case (ast::expr_check(_,_)) { e_1 = e.node; }\n-            case (ast::expr_assert(_,_)) { e_1 = e.node; }\n+            case (ast::expr_fail(_))  { /* no-op */ }\n+            case (ast::expr_log(_,_,_)) { /* no-op */ }\n+            case (ast::expr_break(_)) { /* no-op */ }\n+            case (ast::expr_cont(_))  { /* no-op */ }\n+            case (ast::expr_ret(_,_)) { /* no-op */ }\n+            case (ast::expr_put(_,_)) { /* no-op */ }\n+            case (ast::expr_be(_,_))  { /* no-op */ }\n+            case (ast::expr_check(_,_)) { /* no-op */ }\n+            case (ast::expr_assert(_,_)) { /* no-op */ }\n \n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                e_1 = ast::expr_port(triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                let @ast::expr es_1;\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n                         auto pt = ty::mk_port(fcx.ccx.tcx, subty);\n-                        es_1 = pushdown_expr(fcx, pt, es);\n+                        pushdown_expr(fcx, pt, es);\n                     }\n                     case (_) {\n                         log \"chan expr doesn't have a chan type!\";\n                         fail;\n                     }\n                 }\n-                e_1 = ast::expr_chan(es_1, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n                 auto t = expected;\n-                let vec[ast::arm] arms_1 = [];\n                 for (ast::arm arm_0 in arms_0) {\n-                    auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n-                    t = Demand::simple(fcx, e.span, t,\n-                        block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_1));\n-                    auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n-                    arms_1 += [arm_1];\n+                    pushdown_block(fcx, expected, arm_0.block);\n+                    auto bty = block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                        arm_0.block);\n+                    t = Demand::simple(fcx, e.span, t, bty);\n                 }\n-                e_1 = ast::expr_alt(discrim, arms_1, triv_ann(ann.id, t));\n                 write_type_only(fcx.ccx.node_types, ann.id, t);\n             }\n \n-            case (ast::expr_recv(?lval_0, ?expr_0, ?ann)) {\n-                auto lval_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n-                                            lval_0);\n-                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lval_1);\n-                auto expr_1 = pushdown_expr(fcx, ty::mk_port(fcx.ccx.tcx, t),\n-                                            expr_0);\n-                e_1 = ast::expr_recv(lval_1, expr_1, ann);\n+            case (ast::expr_recv(?lval, ?expr, ?ann)) {\n+                pushdown_expr(fcx, next_ty_var(fcx.ccx), lval);\n+                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lval);\n+                pushdown_expr(fcx, ty::mk_port(fcx.ccx.tcx, t), expr);\n             }\n \n-            case (ast::expr_send(?lval_0, ?expr_0, ?ann)) {\n-                auto expr_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n-                                            expr_0);\n-                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n-                auto lval_1 = pushdown_expr(fcx, ty::mk_chan(fcx.ccx.tcx, t),\n-                                            lval_0);\n-                e_1 = ast::expr_send(lval_1, expr_1, ann);\n+            case (ast::expr_send(?lval, ?expr, ?ann)) {\n+                pushdown_expr(fcx, next_ty_var(fcx.ccx), expr);\n+                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n+                pushdown_expr(fcx, ty::mk_chan(fcx.ccx.tcx, t), lval);\n             }\n \n             case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?ann)) {\n@@ -1528,32 +1473,21 @@ mod Pushdown {\n                 fail;\n             }\n         }\n-\n-        ret @fold::respan[ast::expr_](e.span, e_1);\n     }\n \n     // Push-down over typed blocks.\n-    fn pushdown_block(&@fn_ctxt fcx, &ty::t expected, &ast::block bloc)\n-            -> ast::block {\n+    fn pushdown_block(&@fn_ctxt fcx, &ty::t expected, &ast::block bloc) {\n         alt (bloc.node.expr) {\n             case (some[@ast::expr](?e_0)) {\n-                auto e_1 = pushdown_expr(fcx, expected, e_0);\n-                auto block_ = rec(stmts=bloc.node.stmts,\n-                                  expr=some[@ast::expr](e_1),\n-                                  a=plain_ann(bloc.node.a.id,\n-                                              fcx.ccx.tcx));\n+                pushdown_expr(fcx, expected, e_0);\n                 write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n                                bloc.node.a.id);\n-                ret fold::respan[ast::block_](bloc.span, block_);\n             }\n             case (none[@ast::expr]) {\n                 Demand::simple(fcx, bloc.span, expected,\n-                              ty::mk_nil(fcx.ccx.tcx));\n-                auto new_ann = plain_ann(bloc.node.a.id, fcx.ccx.tcx);\n+                               ty::mk_nil(fcx.ccx.tcx));\n                 write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n                                bloc.node.a.id);\n-                ret fold::respan(bloc.span, rec(a=new_ann with bloc.node));\n-                                            \n             }\n         }\n     }\n@@ -1794,7 +1728,7 @@ fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) -> () {\n     }\n }\n \n-fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n+fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     //fcx.ccx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                       util::common::expr_to_str(expr));\n \n@@ -1853,61 +1787,48 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n     // A generic function for checking assignment expressions\n     fn check_assignment(&@fn_ctxt fcx, &@ast::expr lhs, &@ast::expr rhs,\n-                        &ast::ann a)\n-        -> tup(@ast::expr, @ast::expr, ast::ann) {\n-        auto lhs_0 = check_expr(fcx, lhs);\n-        auto rhs_0 = check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n-        auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n+                        &ast::ann a) {\n+        check_expr(fcx, lhs);\n+        check_expr(fcx, rhs);\n+        auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+        auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n \n-        auto lhs_1 = Pushdown::pushdown_expr(fcx, rhs_t0, lhs_0);\n-        auto rhs_1 = Pushdown::pushdown_expr(fcx,\n-            expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0);\n+        Pushdown::pushdown_expr(fcx, rhs_t0, lhs);\n+        auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+        Pushdown::pushdown_expr(fcx, lhs_t1, rhs);\n+        auto rhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n \n-        auto ann = triv_ann(a.id,\n-                            expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n-        write_type_only(fcx.ccx.node_types, a.id,\n-                        expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_1));\n-        ret tup(lhs_1, rhs_1, ann);\n+        auto ann = triv_ann(a.id, rhs_t1);\n+        write_type_only(fcx.ccx.node_types, a.id, rhs_t1);\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(&@fn_ctxt fcx, &@ast::expr f, &vec[@ast::expr] args)\n-        -> tup(@ast::expr, vec[@ast::expr]) {\n-\n+    fn check_call(&@fn_ctxt fcx, &@ast::expr f, &vec[@ast::expr] args) {\n         let vec[option::t[@ast::expr]] args_opt_0 = [];\n         for (@ast::expr arg in args) {\n             args_opt_0 += [some[@ast::expr](arg)];\n         }\n \n         // Call the generic checker.\n         check_call_or_bind(fcx, f, args_opt_0);\n-\n-        ret tup(f, args);\n     }\n \n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span, ast::expr_lit(lit, ann));\n         }\n \n-\n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n-            auto lhs_0 = check_expr(fcx, lhs);\n-            auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n-            auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n+            check_expr(fcx, lhs);\n+            check_expr(fcx, rhs);\n+            auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+            auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n \n             // FIXME: Binops have a bit more subtlety than this.\n-            auto lhs_1 = Pushdown::pushdown_expr_full(fcx, rhs_t0, lhs_0,\n-                                                     AUTODEREF_OK);\n-            auto rhs_1 =\n-                Pushdown::pushdown_expr_full(fcx,\n-                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0,\n-                    AUTODEREF_OK);\n+            Pushdown::pushdown_expr_full(fcx, rhs_t0, lhs, AUTODEREF_OK);\n+            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+            Pushdown::pushdown_expr_full(fcx, lhs_t1, rhs, AUTODEREF_OK);\n \n             auto t = strip_boxes(fcx.ccx.tcx, lhs_t0);\n             alt (binop) {\n@@ -1920,27 +1841,20 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { /* fall through */ }\n             }\n \n-            auto ann = triv_ann(a.id, t);\n             write_type_only(fcx.ccx.node_types, a.id, t);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_binary(binop, lhs_1,\n-                                                           rhs_1, ann));\n         }\n \n-\n         case (ast::expr_unary(?unop, ?oper, ?a)) {\n-            auto oper_1 = check_expr(fcx, oper);\n-            auto oper_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, oper_1);\n+            check_expr(fcx, oper);\n+\n+            auto oper_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, oper);\n             alt (unop) {\n                 case (ast::box(?mut)) {\n-                    oper_t = ty::mk_box(fcx.ccx.tcx,\n-                                       rec(ty=oper_t, mut=mut));\n+                    oper_t = ty::mk_box(fcx.ccx.tcx, rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast::deref) {\n                     alt (struct(fcx.ccx.tcx, oper_t)) {\n-                        case (ty::ty_box(?inner)) {\n-                            oper_t = inner.ty;\n-                        }\n+                        case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n                                 (expr.span,\n@@ -1952,10 +1866,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n             }\n \n-            auto ann = triv_ann(a.id, oper_t);\n             write_type_only(fcx.ccx.node_types, a.id, oper_t);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_unary(unop, oper_1, ann));\n         }\n \n         case (ast::expr_path(?pth, ?old_ann)) {\n@@ -1966,11 +1877,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n-                auto did = ast::def_id_of_def(defn);\n                 write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n-                ret @fold::respan[ast::expr_](expr.span,\n-                    ast::expr_path(pth, mk_ann_type(old_ann.id, path_tpot._1,\n-                                                    path_tpot._0)));\n+                ret;\n             }\n \n             // The definition doesn't take type parameters. If the programmer\n@@ -1981,68 +1889,45 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 fail;\n             }\n \n-            auto e = ast::expr_path(pth, triv_ann(old_ann.id, tpt._1));\n             write_type_only(fcx.ccx.node_types, old_ann.id, tpt._1);\n-            ret @fold::respan[ast::expr_](expr.span, e);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n-            auto exp_ = check_expr(fcx, expanded);\n-            auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, exp_);\n-            auto ann = triv_ann(a.id, t);\n+            check_expr(fcx, expanded);\n+            auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expanded);\n             write_type_only(fcx.ccx.node_types, a.id, t);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_ext(p, args, body, exp_,\n-                                                        ann));\n         }\n \n         case (ast::expr_fail(?a)) {\n-            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-            ret @fold::respan[ast::expr_](expr.span, ast::expr_fail(new_ann));\n+            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_break(?a)) {\n-            // TODO: should be something like 'a or noret\n-            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_break(new_ann));\n+            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_cont(?a)) {\n-            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-            ret @fold::respan[ast::expr_](expr.span, ast::expr_cont(new_ann));\n+            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n+                        // TODO: span_err\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n                     }\n \n-                    auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-\n-                    ret @fold::respan[ast::expr_]\n-                        (expr.span,\n-                         ast::expr_ret(none[@ast::expr], new_ann));\n+                    write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n-                    auto expr_0 = check_expr(fcx, e);\n-                    auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty,\n-                                                         expr_0);\n-\n-                    auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+                    check_expr(fcx, e);\n+                    Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n \n-                    ret @fold::respan[ast::expr_]\n-                        (expr.span, ast::expr_ret(some(expr_1), new_ann));\n+                    write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n                 }\n             }\n         }\n@@ -2054,57 +1939,42 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n+                        // TODO: span_err\n                         fcx.ccx.sess.err(\"put; in function \"\n                                          + \"putting non-nil\");\n                     }\n \n-                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n                     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-\n-                    ret @fold::respan[ast::expr_]\n-                        (expr.span, ast::expr_put(none[@ast::expr], new_ann));\n                 }\n \n                 case (some[@ast::expr](?e)) {\n-                    auto expr_0 = check_expr(fcx, e);\n-                    auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty,\n-                                                         expr_0);\n+                    check_expr(fcx, e);\n+                    Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n \n-                    auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n                     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-\n-                    ret @fold::respan[ast::expr_]\n-                        (expr.span, ast::expr_put(some(expr_1), new_ann));\n                 }\n             }\n         }\n \n         case (ast::expr_be(?e, ?a)) {\n-            /* FIXME: prove instead of check */\n+            // FIXME: prove instead of assert\n             assert (ast::is_call_expr(e));\n-            auto expr_0 = check_expr(fcx, e);\n-            auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty, expr_0);\n \n-            auto new_ann = bot_ann(a.id, fcx.ccx.tcx);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            check_expr(fcx, e);\n+            Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n \n-            ret @fold::respan(expr.span, ast::expr_be(expr_1, new_ann));\n+            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_log(?l, ?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n-\n-            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_log(l, expr_t, new_ann));\n         }\n \n         case (ast::expr_check(?e, ?a)) {\n-            auto expr_t = check_expr(fcx, e);\n+            check_expr(fcx, e);\n             Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                          expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t));\n+                           expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e));\n             /* e must be a call expr where all arguments are either\n              literals or slots */\n             alt (e.node) {\n@@ -2125,12 +1995,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n                             require_pure_function(fcx.ccx, d_id, expr.span);\n \n-                            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n                             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n                                            a.id);\n-\n-                            ret @fold::respan[ast::expr_]\n-                                (expr.span, ast::expr_check(expr_t, new_ann));\n                         }\n                         case (_) {\n                            fcx.ccx.sess.span_err(expr.span,\n@@ -2147,192 +2013,132 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         case (ast::expr_assert(?e, ?a)) {\n-            auto expr_t = check_expr(fcx, e);\n-            Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                          expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t));\n+            check_expr(fcx, e);\n+            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n+            Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n \n-            auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n-\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_assert(expr_t, new_ann));\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n-\n-            auto checked = check_assignment(fcx, lhs, rhs, a);\n-            auto newexpr = ast::expr_assign(checked._0,\n-                                           checked._1,\n-                                           checked._2);\n-            ret @fold::respan[ast::expr_](expr.span, newexpr);\n+            check_assignment(fcx, lhs, rhs, a);\n         }\n \n         case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n-\n-            auto checked = check_assignment(fcx, lhs, rhs, a);\n-            auto newexpr = ast::expr_assign_op(op,\n-                                              checked._0,\n-                                              checked._1,\n-                                              checked._2);\n-            ret @fold::respan[ast::expr_](expr.span, newexpr);\n+            check_assignment(fcx, lhs, rhs, a);\n         }\n \n         case (ast::expr_send(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n-            auto lhs_0 = check_expr(fcx, lhs);\n-            auto rhs_0 = check_expr(fcx, rhs);\n-            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n+            check_expr(fcx, lhs);\n+            check_expr(fcx, rhs);\n+            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n \n             auto chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n-            auto lhs_1 = Pushdown::pushdown_expr(fcx, chan_t, lhs_0);\n+            Pushdown::pushdown_expr(fcx, chan_t, lhs);\n             auto item_t;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             lhs_1))) {\n-                case (ty::ty_chan(?it)) {\n-                    item_t = it;\n-                }\n-                case (_) {\n-                    fail;\n-                }\n+            auto lhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+            alt (struct(fcx.ccx.tcx, lhs_t)) {\n+                case (ty::ty_chan(?it)) { item_t = it; }\n+                case (_) { fail; }\n             }\n-            auto rhs_1 = Pushdown::pushdown_expr(fcx, item_t, rhs_0);\n+            Pushdown::pushdown_expr(fcx, item_t, rhs);\n \n-            auto ann = triv_ann(a.id, chan_t);\n             write_type_only(fcx.ccx.node_types, a.id, chan_t);\n-            auto newexpr = ast::expr_send(lhs_1, rhs_1, ann);\n-            ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n \n         case (ast::expr_recv(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n-            auto lhs_0 = check_expr(fcx, lhs);\n-            auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n+            check_expr(fcx, lhs);\n+            check_expr(fcx, rhs);\n+            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n \n             auto port_t = ty::mk_port(fcx.ccx.tcx, lhs_t1);\n-            auto rhs_1 = Pushdown::pushdown_expr(fcx, port_t, rhs_0);\n+            Pushdown::pushdown_expr(fcx, port_t, rhs);\n             auto item_t;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             rhs_0))) {\n-                case (ty::ty_port(?it)) {\n-                    item_t = it;\n-                }\n-                case (_) {\n-                    fail;\n-                }\n+            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n+            alt (struct(fcx.ccx.tcx, rhs_t)) {\n+                case (ty::ty_port(?it)) { item_t = it; }\n+                case (_) { fail; }\n             }\n-            auto lhs_1 = Pushdown::pushdown_expr(fcx, item_t, lhs_0);\n+            Pushdown::pushdown_expr(fcx, item_t, lhs);\n \n-            auto ann = triv_ann(a.id, item_t);\n             write_type_only(fcx.ccx.node_types, a.id, item_t);\n-            auto newexpr = ast::expr_recv(lhs_1, rhs_1, ann);\n-            ret @fold::respan[ast::expr_](expr.span, newexpr);\n         }\n \n         case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n-            auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown::pushdown_expr(fcx,\n-                                                  ty::mk_bool(fcx.ccx.tcx),\n-                                                  cond_0);\n+            check_expr(fcx, cond);\n+            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n \n-            auto thn_0 = check_block(fcx, thn);\n-            auto thn_t = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, thn_0);\n+            check_block(fcx, thn);\n+            auto thn_t = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, thn);\n \n-            auto elsopt_1;\n             auto elsopt_t;\n             alt (elsopt) {\n                 case (some[@ast::expr](?els)) {\n-                    auto els_0 = check_expr(fcx, els);\n-                    auto els_1 = Pushdown::pushdown_expr(fcx, thn_t, els_0);\n-                    elsopt_1 = some[@ast::expr](els_1);\n-                    elsopt_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                       els_1);\n+                    check_expr(fcx, els);\n+                    Pushdown::pushdown_expr(fcx, thn_t, els);\n+                    elsopt_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, els);\n                 }\n                 case (none[@ast::expr]) {\n-                    elsopt_1 = none[@ast::expr];\n                     elsopt_t = ty::mk_nil(fcx.ccx.tcx);\n                 }\n             }\n \n-            auto thn_1 = Pushdown::pushdown_block(fcx, elsopt_t, thn_0);\n+            Pushdown::pushdown_block(fcx, elsopt_t, thn);\n \n-            auto ann = triv_ann(a.id, elsopt_t);\n             write_type_only(fcx.ccx.node_types, a.id, elsopt_t);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_if(cond_1, thn_1,\n-                                                    elsopt_1, ann));\n         }\n \n         case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n-            auto decl_1 = check_decl_local(fcx, decl);\n-            auto seq_1 = check_expr(fcx, seq);\n-            auto body_1 = check_block(fcx, body);\n+            check_decl_local(fcx, decl);\n+            check_expr(fcx, seq);\n+            check_block(fcx, body);\n \n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_for(decl_1, seq_1,\n-                                                      body_1, ann));\n         }\n \n         case (ast::expr_for_each(?decl, ?seq, ?body, ?a)) {\n-            auto decl_1 = check_decl_local(fcx, decl);\n-            auto seq_1 = check_expr(fcx, seq);\n-            auto body_1 = check_block(fcx, body);\n+            check_decl_local(fcx, decl);\n+            check_expr(fcx, seq);\n+            check_block(fcx, body);\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_for_each(decl_1, seq_1,\n-                                                           body_1, ann));\n         }\n \n         case (ast::expr_while(?cond, ?body, ?a)) {\n-            auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown::pushdown_expr(fcx,\n-                                                  ty::mk_bool(fcx.ccx.tcx),\n-                                                  cond_0);\n-            auto body_1 = check_block(fcx, body);\n+            check_expr(fcx, cond);\n+            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n+            check_block(fcx, body);\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_while(cond_1, body_1,\n-                                                          ann));\n         }\n \n         case (ast::expr_do_while(?body, ?cond, ?a)) {\n-            auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown::pushdown_expr(fcx,\n-                                                  ty::mk_bool(fcx.ccx.tcx),\n-                                                  cond_0);\n-            auto body_1 = check_block(fcx, body);\n+            check_expr(fcx, cond);\n+            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n+            check_block(fcx, body);\n \n-            auto typ = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, body_1);\n-            auto ann = triv_ann(a.id, typ);\n+            auto typ = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, body);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_do_while(body_1, cond_1,\n-                                                             ann));\n         }\n \n         case (ast::expr_alt(?expr, ?arms, ?a)) {\n-            auto expr_0 = check_expr(fcx, expr);\n+            check_expr(fcx, expr);\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                      expr_0);\n+            auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n \n             let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n@@ -2349,50 +2155,38 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // Now typecheck the blocks.\n             auto result_ty = next_ty_var(fcx.ccx);\n \n-            let vec[ast::block] blocks_0 = [];\n+            let vec[ast::block] blocks = [];\n             for (ast::arm arm in arms) {\n-                auto block_0 = check_block(fcx, arm.block);\n-                result_ty = Demand::simple(fcx, block_0.span, result_ty,\n-                    block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_0));\n-                blocks_0 += [block_0];\n+                check_block(fcx, arm.block);\n+\n+                auto bty = block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                    arm.block);\n+                result_ty = Demand::simple(fcx, arm.block.span, result_ty,\n+                                           bty);\n             }\n \n-            let vec[ast::arm] arms_1 = [];\n             auto i = 0u;\n-            for (ast::block block_0 in blocks_0) {\n-                auto block_1 = Pushdown::pushdown_block(fcx, result_ty,\n-                                                       block_0);\n-                auto pat = pats.(i);\n-                auto arm = arms.(i);\n-                auto arm_1 = rec(pat=pat, block=block_1);\n-                arms_1 += [arm_1];\n-                i += 1u;\n+            for (ast::block bloc in blocks) {\n+                Pushdown::pushdown_block(fcx, result_ty, bloc);\n             }\n \n-            auto expr_1 = Pushdown::pushdown_expr(fcx, pattern_ty, expr_0);\n+            Pushdown::pushdown_expr(fcx, pattern_ty, expr);\n \n-            auto ann = triv_ann(a.id, result_ty);\n             write_type_only(fcx.ccx.node_types, a.id, result_ty);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_alt(expr_1, arms_1, ann));\n         }\n \n         case (ast::expr_block(?b, ?a)) {\n-            auto b_0 = check_block(fcx, b);\n-            auto ann;\n-            alt (b_0.node.expr) {\n+            check_block(fcx, b);\n+            alt (b.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n                     auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n-                    ann = triv_ann(a.id, typ);\n                     write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_nil(fcx.ccx.tcx);\n-                    ann = triv_ann(a.id, typ);\n                     write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n             }\n-            ret @fold::respan(expr.span, ast::expr_block(b_0, ann));\n         }\n \n         case (ast::expr_bind(?f, ?args, ?a)) {\n@@ -2403,8 +2197,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto proto_1;\n             let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             f))) {\n+            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n+            alt (struct(fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2429,10 +2223,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n \n             auto t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            auto ann = triv_ann(a.id, t_1);\n             write_type_only(fcx.ccx.node_types, a.id, t_1);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_bind(f, args, ann));\n         }\n \n         case (ast::expr_call(?f, ?args, ?a)) {\n@@ -2442,26 +2233,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             function name onto purity-designation */\n             require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n \n-            auto result = check_call(fcx, f, args);\n-            auto f_1 = result._0;\n-            auto args_1 = result._1;\n+            check_call(fcx, f, args);\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty::mk_nil(fcx.ccx.tcx);  // FIXME: typestate botch\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             f_1))) {\n-                case (ty::ty_fn(_,_,?rt))    { rt_1 = rt; }\n-                case (ty::ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n+            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n+            alt (struct(fcx.ccx.tcx, fty)) {\n+                case (ty::ty_fn(_,_,?rt))           { rt_1 = rt; }\n+                case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n                 case (_) {\n                     log_err \"LHS of call expr didn't have a function type?!\";\n                     fail;\n                 }\n             }\n \n-            auto ann = triv_ann(a.id, rt_1);\n             write_type_only(fcx.ccx.node_types, a.id, rt_1);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_call(f_1, args_1, ann));\n         }\n \n         case (ast::expr_self_method(?id, ?a)) {\n@@ -2496,23 +2282,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (_) { fail; }\n             }\n \n-            auto ann = triv_ann(a.id, t);\n             write_type_only(fcx.ccx.node_types, a.id, t);\n \n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n-\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_self_method(id, ann));\n         }\n \n-        case (ast::expr_spawn(?dom, ?name, ?f, ?args, ?a)) {\n-            auto result = check_call(fcx, f, args);\n-            auto f_1 = result._0;\n-            auto args_1 = result._1;\n+        case (ast::expr_spawn(_, _, ?f, ?args, ?a)) {\n+            check_call(fcx, f, args);\n \n             // Check the return type\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             f_1))) {\n+            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n+            alt (struct(fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(_,_,?rt)) {\n                     alt (struct(fcx.ccx.tcx, rt)) {\n                         case (ty::ty_nil) {\n@@ -2531,129 +2311,98 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // FIXME: Other typechecks needed\n \n             auto typ = ty::mk_task(fcx.ccx.tcx);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_spawn(dom, name,\n-                                                          f_1, args_1, ann));\n         }\n \n         case (ast::expr_cast(?e, ?t, ?a)) {\n-            auto e_1 = check_expr(fcx, e);\n+            check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n             if (! (type_is_scalar(fcx.ccx.tcx,\n-                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e_1)) &&\n+                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e)) &&\n                     type_is_scalar(fcx.ccx.tcx, t_1))) {\n                 fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n                     ty_to_str(fcx.ccx.tcx,\n-                              expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e_1)) +\n+                              expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e)) +\n                     \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n-            auto ann = triv_ann(a.id, t_1);\n             write_type_only(fcx.ccx.node_types, a.id, t_1);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_cast(e_1, t, ann));\n         }\n \n         case (ast::expr_vec(?args, ?mut, ?a)) {\n-            let vec[@ast::expr] args_1 = [];\n-\n             let ty::t t;\n             if (vec::len[@ast::expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n-                auto expr_1 = check_expr(fcx, args.(0));\n-                t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n+                check_expr(fcx, args.(0));\n+                t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, args.(0));\n             }\n \n             for (@ast::expr e in args) {\n-                auto expr_1 = check_expr(fcx, e);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                      expr_1);\n+                check_expr(fcx, e);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n                 Demand::simple(fcx, expr.span, t, expr_t);\n-                vec::push[@ast::expr](args_1,expr_1);\n             }\n \n             auto typ = ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_vec(args_1, mut, ann));\n         }\n \n         case (ast::expr_tup(?elts, ?a)) {\n-            let vec[ast::elt] elts_1 = [];\n             let vec[ty::mt] elts_mt = [];\n \n             for (ast::elt e in elts) {\n-                auto expr_1 = check_expr(fcx, e.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                      expr_1);\n-                vec::push[ast::elt](elts_1, rec(expr=expr_1 with e));\n-                elts_mt += [rec(ty=expr_t, mut=e.mut)];\n+                check_expr(fcx, e.expr);\n+                auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e.expr);\n+                elts_mt += [rec(ty=ety, mut=e.mut)];\n             }\n \n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n-            auto ann = triv_ann(a.id, typ);\n             write_type_only(fcx.ccx.node_types, a.id, typ);\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_tup(elts_1, ann));\n         }\n \n         case (ast::expr_rec(?fields, ?base, ?a)) {\n \n-            auto base_1;\n             alt (base) {\n-                case (none[@ast::expr]) { base_1 = none[@ast::expr]; }\n-                case (some[@ast::expr](?b_0)) {\n-                    base_1 = some[@ast::expr](check_expr(fcx, b_0));\n-                }\n+                case (none[@ast::expr]) { /* no-op */}\n+                case (some[@ast::expr](?b_0)) { check_expr(fcx, b_0); }\n             }\n \n-            let vec[ast::field] fields_1 = [];\n             let vec[field] fields_t = [];\n \n             for (ast::field f in fields) {\n-                auto expr_1 = check_expr(fcx, f.expr);\n+                check_expr(fcx, f.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                      expr_1);\n-                vec::push[ast::field](fields_1, rec(expr=expr_1 with f));\n+                                      f.expr);\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n                 vec::push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n             }\n \n-            auto ann;\n-\n             alt (base) {\n                 case (none[@ast::expr]) {\n                     auto typ = ty::mk_rec(fcx.ccx.tcx, fields_t);\n-                    ann = triv_ann(a.id, typ);\n                     write_type_only(fcx.ccx.node_types, a.id, typ);\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n-                    auto bexpr_1 = check_expr(fcx, bexpr);\n+                    check_expr(fcx, bexpr);\n                     auto bexpr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                           bexpr_1);\n+                                           bexpr);\n \n                     let vec[field] base_fields = [];\n \n                     alt (struct(fcx.ccx.tcx, bexpr_t)) {\n-                        case (ty::ty_rec(?flds)) {\n-                            base_fields = flds;\n-                        }\n+                        case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"record update non-record base\");\n                         }\n                     }\n \n-                    ann = triv_ann(a.id, bexpr_t);\n                     write_type_only(fcx.ccx.node_types, a.id, bexpr_t);\n \n                     for (ty::field f in fields_t) {\n@@ -2674,15 +2423,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     }\n                 }\n             }\n-\n-            ret @fold::respan[ast::expr_](expr.span,\n-                                        ast::expr_rec(fields_1, base_1, ann));\n         }\n \n         case (ast::expr_field(?base, ?field, ?a)) {\n-            auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(fcx.ccx.tcx,\n-                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base_1));\n+            check_expr(fcx, base);\n+            auto base_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base);\n+            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n             alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix = ty::field_num(fcx.ccx.sess,\n@@ -2691,47 +2437,32 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = triv_ann(a.id, args.(ix).ty);\n                     write_type_only(fcx.ccx.node_types, a.id,\n                                     args.(ix).ty);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_field(base_1,\n-                                                               field,\n-                                                               ann));\n                 }\n \n                 case (ty::ty_rec(?fields)) {\n                     let uint ix = ty::field_idx(fcx.ccx.sess,\n-                                               expr.span, field, fields);\n+                                                expr.span, field, fields);\n                     if (ix >= vec::len[typeck::field](fields)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = triv_ann(a.id, fields.(ix).mt.ty);\n                     write_type_only(fcx.ccx.node_types, a.id,\n                                     fields.(ix).mt.ty);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_field(base_1,\n-                                                               field,\n-                                                               ann));\n                 }\n \n                 case (ty::ty_obj(?methods)) {\n                     let uint ix = ty::method_idx(fcx.ccx.sess,\n-                                                expr.span, field, methods);\n+                                                 expr.span, field, methods);\n                     if (ix >= vec::len[typeck::method](methods)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n-                                      meth.inputs, meth.output);\n-                    auto ann = triv_ann(a.id, t);\n+                                       meth.inputs, meth.output);\n                     write_type_only(fcx.ccx.node_types, a.id, t);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_field(base_1,\n-                                                               field,\n-                                                               ann));\n                 }\n \n                 case (_) {\n@@ -2743,12 +2474,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         case (ast::expr_index(?base, ?idx, ?a)) {\n-            auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(fcx.ccx.tcx,\n-                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base_1));\n+            check_expr(fcx, base);\n+            auto base_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base);\n+            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n \n-            auto idx_1 = check_expr(fcx, idx);\n-            auto idx_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, idx_1);\n+            check_expr(fcx, idx);\n+            auto idx_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, idx);\n             alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n                     if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n@@ -2757,12 +2488,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(a.id, mt.ty);\n                     write_type_only(fcx.ccx.node_types, a.id, mt.ty);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_index(base_1,\n-                                                               idx_1,\n-                                                               ann));\n                 }\n                 case (ty::ty_str) {\n                     if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n@@ -2772,12 +2498,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n                     auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n-                    auto ann = triv_ann(a.id, typ);\n                     write_type_only(fcx.ccx.node_types, a.id, typ);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_index(base_1,\n-                                                               idx_1,\n-                                                               ann));\n                 }\n                 case (_) {\n                     fcx.ccx.sess.span_err\n@@ -2791,21 +2512,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_port(?a)) {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n-            auto ann = triv_ann(a.id, pt);\n             write_type_only(fcx.ccx.node_types, a.id, pt);\n-            ret @fold::respan[ast::expr_](expr.span, ast::expr_port(ann));\n         }\n \n         case (ast::expr_chan(?x, ?a)) {\n-            auto expr_1 = check_expr(fcx, x);\n-            auto port_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n+            check_expr(fcx, x);\n+            auto port_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n             alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n-                    auto ann = triv_ann(a.id, ct);\n                     write_type_only(fcx.ccx.node_types, a.id, ct);\n-                    ret @fold::respan[ast::expr_](expr.span,\n-                                                ast::expr_chan(expr_1, ann));\n                 }\n                 case (_) {\n                     fcx.ccx.sess.span_err(expr.span,\n@@ -2814,11 +2530,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             }\n         }\n \n-        case (_) {\n-            fcx.ccx.sess.unimpl(\"expr type in typeck::check_expr\");\n-            // TODO\n-            ret expr;\n-        }\n+        case (_) { fcx.ccx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n }\n \n@@ -2831,10 +2543,7 @@ fn next_ty_var(&@crate_ctxt ccx) -> ty::t {\n fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n     alt (decl.node) {\n         case (ast::decl_local(?local)) {\n-\n-            auto t;\n-\n-            t = ty::mk_nil(fcx.ccx.tcx);\n+            auto t = ty::mk_nil(fcx.ccx.tcx);\n \n             alt (local.ty) {\n                 case (none[@ast::ty]) {\n@@ -2854,29 +2563,22 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             auto initopt = local.init;\n             alt (local.init) {\n                 case (some[ast::initializer](?init)) {\n-                    auto expr_0 = check_expr(fcx, init.expr);\n+                    check_expr(fcx, init.expr);\n                     auto lty = ty::mk_local(fcx.ccx.tcx, local.id);\n-                    auto expr_1;\n                     alt (init.op) {\n                         case (ast::init_assign) {\n-                            expr_1 = Pushdown::pushdown_expr(fcx, lty,\n-                                                             expr_0);\n+                            Pushdown::pushdown_expr(fcx, lty, init.expr);\n                         }\n                         case (ast::init_recv) {\n                             auto port_ty = ty::mk_port(fcx.ccx.tcx, lty);\n-                            expr_1 = Pushdown::pushdown_expr(fcx, port_ty,\n-                                                            expr_0);\n+                            Pushdown::pushdown_expr(fcx, port_ty, init.expr);\n                         }\n                     }\n-\n-                    auto init_0 = rec(expr = expr_1 with init);\n-                    initopt = some[ast::initializer](init_0);\n                 }\n                 case (_) { /* fall through */  }\n             }\n             auto local_1 = @rec(init = initopt, ann = a_res with *local);\n-            ret @rec(node=ast::decl_local(local_1)\n-                     with *decl);\n+            ret @rec(node=ast::decl_local(local_1) with *decl);\n         }\n     }\n }\n@@ -2909,14 +2611,14 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n         }\n \n         case (ast::stmt_expr(?expr,?a)) {\n-            auto expr_t = check_expr(fcx, expr);\n-            expr_t = Pushdown::pushdown_expr(fcx,\n-                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t), expr_t);\n+            check_expr(fcx, expr);\n+            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n+            Pushdown::pushdown_expr(fcx, ety, expr);\n \n             auto new_ann = plain_ann(a.id, fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n \n-            ret @fold::respan(stmt.span, ast::stmt_expr(expr_t, new_ann));\n+            ret @fold::respan(stmt.span, ast::stmt_expr(expr, new_ann));\n         }\n     }\n \n@@ -2929,21 +2631,20 @@ fn check_block(&@fn_ctxt fcx, &ast::block block) -> ast::block {\n         vec::push[@ast::stmt](stmts, check_stmt(fcx, s));\n     }\n \n-    auto expr = none[@ast::expr];\n     alt (block.node.expr) {\n         case (none[@ast::expr]) { /* empty */ }\n         case (some[@ast::expr](?e)) {\n-            auto expr_t = check_expr(fcx, e);\n-            expr_t = Pushdown::pushdown_expr(fcx,\n-                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t), expr_t);\n-            expr = some[@ast::expr](expr_t);\n+            check_expr(fcx, e);\n+            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n+            Pushdown::pushdown_expr(fcx, ety, e);\n         }\n     }\n \n     auto new_ann = plain_ann(block.node.a.id, fcx.ccx.tcx);\n     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, block.node.a.id);\n \n-    ret fold::respan(block.span, rec(stmts=stmts, expr=expr, a=new_ann));\n+    ret fold::respan(block.span,\n+                     rec(stmts=stmts, expr=block.node.expr, a=new_ann));\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, &ast::ident ident, &@ast::ty t,\n@@ -2955,10 +2656,10 @@ fn check_const(&@crate_ctxt ccx, &span sp, &ast::ident ident, &@ast::ty t,\n                             purity = ast::pure_fn,\n                             locals = @common::new_def_hash[ty::t](),\n                             ccx = ccx);\n-    auto e_ = check_expr(fcx, e);\n+    check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n-    Pushdown::pushdown_expr(fcx, rty, e_);\n-    auto item = ast::item_const(ident, t, e_, id, ann);\n+    Pushdown::pushdown_expr(fcx, rty, e);\n+    auto item = ast::item_const(ident, t, e, id, ann);\n     ret @fold::respan[ast::item_](sp, item);\n }\n "}, {"sha": "deb73c84a7cba33dcf99d2c237f69e0a68132aec", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d4c31ee4657de1e12d50fac2306d0e46b2b04a/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=c6d4c31ee4657de1e12d50fac2306d0e46b2b04a", "patch": "@@ -20,6 +20,7 @@ import pretty::pprust::print_expr;\n import pretty::pprust::print_decl;\n import pretty::pprust::print_fn;\n import pretty::pprust::print_type;\n+import pretty::pprust::mo_untyped;\n import pretty::pp::mkstate;\n \n type filename = str;\n@@ -125,7 +126,8 @@ fn expr_to_str(&@ast::expr e) -> str {\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u);\n+                  mutable cur_cmnt=0u,\n+                  mode=mo_untyped);\n   print_expr(out, e);\n   ret s.get_str();\n }\n@@ -135,7 +137,8 @@ fn ty_to_str(&ty t) -> str {\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u);\n+                  mutable cur_cmnt=0u,\n+                  mode=mo_untyped);\n   print_type(out, @t);\n   ret s.get_str();\n }\n@@ -161,7 +164,8 @@ fn block_to_str(&ast::block b) -> str {\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u);\n+                  mutable cur_cmnt=0u,\n+                  mode=mo_untyped);\n \n   print_block(out, b);\n   ret s.get_str();\n@@ -180,7 +184,8 @@ fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u);\n+                  mutable cur_cmnt=0u,\n+                  mode=mo_untyped);\n \n   print_fn(out, f.decl, name, params);\n   ret s.get_str();\n@@ -199,7 +204,8 @@ fn stmt_to_str(&ast::stmt st) -> str {\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u);\n+                  mutable cur_cmnt=0u,\n+                  mode=mo_untyped);\n   alt (st.node) {\n     case (ast::stmt_decl(?decl,_)) {\n       print_decl(out, decl);"}]}