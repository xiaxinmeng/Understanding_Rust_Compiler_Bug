{"sha": "38eeebdfed97af43354ed924e498764e8f9cdae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZWVlYmRmZWQ5N2FmNDMzNTRlZDkyNGU0OTg3NjRlOGY5Y2RhZTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-08-02T19:06:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-08-07T14:12:23Z"}, "message": "rustc: Refactor MonoItem linkage/visibility calculation\n\nThe previous iteration was a large `match` which was quite heavily indented,\nmaking it slightly difficult to read and see what was going on. This iteration\nis a refactoring (no functional change intended) to make it a bit easier on the\neyes and a bit easier to modify over time.", "tree": {"sha": "396e83e5f1356a628007ae4c83d9eacb6bb276fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/396e83e5f1356a628007ae4c83d9eacb6bb276fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38eeebdfed97af43354ed924e498764e8f9cdae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38eeebdfed97af43354ed924e498764e8f9cdae5", "html_url": "https://github.com/rust-lang/rust/commit/38eeebdfed97af43354ed924e498764e8f9cdae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38eeebdfed97af43354ed924e498764e8f9cdae5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18925dee25ce649562d203e72068e3a57b60b153", "url": "https://api.github.com/repos/rust-lang/rust/commits/18925dee25ce649562d203e72068e3a57b60b153", "html_url": "https://github.com/rust-lang/rust/commit/18925dee25ce649562d203e72068e3a57b60b153"}], "stats": {"total": 291, "additions": 151, "deletions": 140}, "files": [{"sha": "31aa918b56f9969fc0be157556ff835578a21d86", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 151, "deletions": 140, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/38eeebdfed97af43354ed924e498764e8f9cdae5/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eeebdfed97af43354ed924e498764e8f9cdae5/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=38eeebdfed97af43354ed924e498764e8f9cdae5", "patch": "@@ -300,13 +300,6 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n     let mut internalization_candidates = FxHashSet();\n \n-    // Determine if monomorphizations instantiated in this crate will be made\n-    // available to downstream crates. This depends on whether we are in\n-    // share-generics mode and whether the current crate can even have\n-    // downstream crates.\n-    let export_generics = tcx.sess.opts.share_generics() &&\n-                          tcx.local_crate_exports_generics();\n-\n     for mono_item in mono_items {\n         match mono_item.instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n@@ -322,146 +315,38 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             None => fallback_cgu_name(tcx),\n         };\n \n-        let make_codegen_unit = || {\n-            CodegenUnit::new(codegen_unit_name.clone())\n-        };\n-\n         let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-                                            .or_insert_with(make_codegen_unit);\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name.clone()));\n \n         let mut can_be_internalized = true;\n-        let default_visibility = |id: DefId, is_generic: bool| {\n-            if !tcx.sess.target.target.options.default_hidden_visibility {\n-                return Visibility::Default\n-            }\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            &|id, is_generic| {\n+                if !tcx.sess.target.target.options.default_hidden_visibility {\n+                    return Visibility::Default\n+                }\n \n-            // Generic functions never have export level C\n-            if is_generic {\n-                return Visibility::Hidden\n-            }\n+                // Generic functions never have export level C\n+                if is_generic {\n+                    return Visibility::Hidden\n+                }\n \n-            // Things with export level C don't get instantiated in downstream\n-            // crates\n-            if !id.is_local() {\n-                return Visibility::Hidden\n-            }\n+                // Things with export level C don't get instantiated in\n+                // downstream crates\n+                if !id.is_local() {\n+                    return Visibility::Hidden\n+                }\n \n-            if let Some(&SymbolExportLevel::C) = tcx.reachable_non_generics(id.krate)\n-                                                    .get(&id) {\n-                Visibility::Default\n-            } else {\n-                Visibility::Hidden\n-            }\n-        };\n-        let (linkage, visibility) = match mono_item.explicit_linkage(tcx) {\n-            Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n-            None => {\n-                match mono_item {\n-                    MonoItem::Fn(ref instance) => {\n-                        let visibility = match instance.def {\n-                            InstanceDef::Item(def_id) => {\n-                                let is_generic = instance.substs\n-                                                         .types()\n-                                                         .next()\n-                                                         .is_some();\n-\n-                                // The `start_fn` lang item is actually a\n-                                // monomorphized instance of a function in the\n-                                // standard library, used for the `main`\n-                                // function. We don't want to export it so we\n-                                // tag it with `Hidden` visibility but this\n-                                // symbol is only referenced from the actual\n-                                // `main` symbol which we unfortunately don't\n-                                // know anything about during\n-                                // partitioning/collection. As a result we\n-                                // forcibly keep this symbol out of the\n-                                // `internalization_candidates` set.\n-                                //\n-                                // FIXME: eventually we don't want to always\n-                                // force this symbol to have hidden\n-                                // visibility, it should indeed be a candidate\n-                                // for internalization, but we have to\n-                                // understand that it's referenced from the\n-                                // `main` symbol we'll generate later.\n-                                if tcx.lang_items().start_fn() == Some(def_id) {\n-                                    can_be_internalized = false;\n-                                    Visibility::Hidden\n-                                } else if def_id.is_local() {\n-                                    if is_generic {\n-                                        if export_generics {\n-                                            if tcx.is_unreachable_local_definition(def_id) {\n-                                                // This instance cannot be used\n-                                                // from another crate.\n-                                                Visibility::Hidden\n-                                            } else {\n-                                                // This instance might be useful in\n-                                                // a downstream crate.\n-                                                can_be_internalized = false;\n-                                                default_visibility(def_id, true)\n-                                            }\n-                                        } else {\n-                                            // We are not exporting generics or\n-                                            // the definition is not reachable\n-                                            // for downstream crates, we can\n-                                            // internalize its instantiations.\n-                                            Visibility::Hidden\n-                                        }\n-                                    } else {\n-                                        // This isn't a generic function.\n-                                        if tcx.is_reachable_non_generic(def_id) {\n-                                            can_be_internalized = false;\n-                                            debug_assert!(!is_generic);\n-                                            default_visibility(def_id, false)\n-                                        } else {\n-                                            Visibility::Hidden\n-                                        }\n-                                    }\n-                                } else {\n-                                    // This is an upstream DefId.\n-                                    if export_generics && is_generic {\n-                                        // If it is a upstream monomorphization\n-                                        // and we export generics, we must make\n-                                        // it available to downstream crates.\n-                                        can_be_internalized = false;\n-                                        default_visibility(def_id, true)\n-                                    } else {\n-                                        Visibility::Hidden\n-                                    }\n-                                }\n-                            }\n-                            InstanceDef::FnPtrShim(..) |\n-                            InstanceDef::Virtual(..) |\n-                            InstanceDef::Intrinsic(..) |\n-                            InstanceDef::ClosureOnceShim { .. } |\n-                            InstanceDef::DropGlue(..) |\n-                            InstanceDef::CloneShim(..) => {\n-                                Visibility::Hidden\n-                            }\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n-                    MonoItem::Static(def_id) => {\n-                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n-                            can_be_internalized = false;\n-                            default_visibility(def_id, false)\n-                        } else {\n-                            Visibility::Hidden\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n-                    MonoItem::GlobalAsm(node_id) => {\n-                        let def_id = tcx.hir.local_def_id(node_id);\n-                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n-                            can_be_internalized = false;\n-                            default_visibility(def_id, false)\n-                        } else {\n-                            Visibility::Hidden\n-                        };\n-                        (Linkage::External, visibility)\n-                    }\n+                // C-export level items remain at `Default`, all other internal\n+                // items become `Hidden`\n+                match tcx.reachable_non_generics(id.krate).get(&id) {\n+                    Some(SymbolExportLevel::C) => Visibility::Default,\n+                    _ => Visibility::Hidden,\n                 }\n-            }\n-        };\n+            },\n+        );\n         if visibility == Visibility::Hidden && can_be_internalized {\n             internalization_candidates.insert(mono_item);\n         }\n@@ -487,6 +372,132 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn mono_item_linkage_and_visibility(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    default: &dyn Fn(DefId, bool) -> Visibility,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default)\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, default);\n+    (Linkage::External, vis)\n+}\n+\n+fn mono_item_visibility(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    default_visibility: &dyn Fn(DefId, bool) -> Visibility,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated, go below\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise\n+        MonoItem::Static(def_id) => {\n+            return if tcx.is_reachable_non_generic(*def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(*def_id, false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+        MonoItem::GlobalAsm(node_id) => {\n+            let def_id = tcx.hir.local_def_id(*node_id);\n+            return if tcx.is_reachable_non_generic(def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(def_id, false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) => def_id,\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::FnPtrShim(..) |\n+        InstanceDef::Virtual(..) |\n+        InstanceDef::Intrinsic(..) |\n+        InstanceDef::ClosureOnceShim { .. } |\n+        InstanceDef::DropGlue(..) |\n+        InstanceDef::CloneShim(..) => {\n+            return Visibility::Hidden\n+        }\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden\n+    }\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics = tcx.sess.opts.share_generics() &&\n+                          tcx.local_crate_exports_generics();\n+\n+    let is_generic = instance.substs.types().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones\n+    if !def_id.is_local() {\n+        return if export_generics && is_generic {\n+            // If it is a upstream monomorphization\n+            // and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        }\n+    }\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used\n+                // from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in\n+                // a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(def_id, true)\n+            }\n+        } else {\n+            // We are not exporting generics or\n+            // the definition is not reachable\n+            // for downstream crates, we can\n+            // internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // This isn't a generic function.\n+        if tcx.is_reachable_non_generic(def_id) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            default_visibility(def_id, false)\n+        } else {\n+            Visibility::Hidden\n+        }\n+    }\n+}\n+\n fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {"}]}