{"sha": "dc45735f29788924b9fc351d100e5bf3ebdca162", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDU3MzVmMjk3ODg5MjRiOWZjMzUxZDEwMGU1YmYzZWJkY2ExNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T04:29:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T04:29:18Z"}, "message": "Auto merge of #64513 - varkor:sty-begone, r=eddyb\n\nRename `TyS.sty` to `TyS.kind`\n\nFixes https://github.com/rust-lang/rust/issues/64353.\n\nr? @eddyb", "tree": {"sha": "8f2ac002f1aa9d021189c20afb62780efcfbeb08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f2ac002f1aa9d021189c20afb62780efcfbeb08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc45735f29788924b9fc351d100e5bf3ebdca162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc45735f29788924b9fc351d100e5bf3ebdca162", "html_url": "https://github.com/rust-lang/rust/commit/dc45735f29788924b9fc351d100e5bf3ebdca162", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc45735f29788924b9fc351d100e5bf3ebdca162/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5bc0f0e3f0c58518c0537d82dee0fcfeb57115c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5bc0f0e3f0c58518c0537d82dee0fcfeb57115c", "html_url": "https://github.com/rust-lang/rust/commit/a5bc0f0e3f0c58518c0537d82dee0fcfeb57115c"}, {"sha": "bc2a373af216aa40032cf51fb435b21f416f0b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2a373af216aa40032cf51fb435b21f416f0b26", "html_url": "https://github.com/rust-lang/rust/commit/bc2a373af216aa40032cf51fb435b21f416f0b26"}], "stats": {"total": 1471, "additions": 735, "deletions": 736}, "files": [{"sha": "bd003735a892c53b5b4c3fc918171ab179e02932", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -343,7 +343,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n+        match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_ty_var(vid) {"}, {"sha": "ae1624fc5a242e0adbbc46d4dac60c3d8aaf3ce0", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -471,7 +471,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             match result_value.unpack() {\n                 UnpackedKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::Bound(debruijn, b) = result_value.sty {\n+                    if let ty::Bound(debruijn, b) = result_value.kind {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(?U)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "6f73275d455f5e0ffb5ee11fecea45a686b963fe", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -70,7 +70,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     {\n         let a_is_expected = relation.a_is_expected();\n \n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             // Relate integral variables to other types\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.int_unification_table\n@@ -486,7 +486,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n-        match t.sty {\n+        match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n                 let mut variables = self.infcx.type_variables.borrow_mut();\n                 let vid = variables.root_var(vid);"}, {"sha": "aea58acab54503b50a9ef1cea3ed201ef8044290", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -68,7 +68,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);\n             }"}, {"sha": "15a664cb33b6f53fada3864795d87489cc5a23c7", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _))\n-                     = (&exp_found.expected.sty, &exp_found.found.sty)\n+                     = (&exp_found.expected.kind, &exp_found.found.kind)\n                 {\n                     report_path_match(err, exp_adt.did, found_adt.did);\n                 }\n@@ -803,7 +803,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                 return Some(());\n             }\n-            if let &ty::Adt(def, _) = &ta.sty {\n+            if let &ty::Adt(def, _) = &ta.kind {\n                 let path_ = self.tcx.def_path_str(def.did.clone());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -868,7 +868,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-            match (&a.sty, &b.sty) {\n+            match (&a.kind, &b.kind) {\n                 (a, b) if *a == *b => true,\n                 (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n                 | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_))\n@@ -902,7 +902,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             s.push_normal(ty.to_string());\n         }\n \n-        match (&t1.sty, &t2.sty) {\n+        match (&t1.kind, &t2.kind) {\n             (&ty::Adt(def1, sub1), &ty::Adt(def2, sub2)) => {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n@@ -1138,7 +1138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n                     let sort_string = | a_type: Ty<'tcx> |\n-                        if let ty::Opaque(def_id, _) = a_type.sty {\n+                        if let ty::Opaque(def_id, _) = a_type.kind {\n                             format!(\" (opaque type at {})\", self.tcx.sess.source_map()\n                                 .mk_substr_filename(self.tcx.def_span(def_id)))\n                         } else {\n@@ -1179,9 +1179,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n         diag: &mut DiagnosticBuilder<'tcx>,\n     ) {\n-        match (&exp_found.expected.sty, &exp_found.found.sty) {\n+        match (&exp_found.expected.kind, &exp_found.found.kind) {\n             (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) => {\n-                if let ty::Adt(found_def, found_substs) = found_ty.sty {\n+                if let ty::Adt(found_def, found_substs) = found_ty.kind {\n                     let path_str = format!(\"{:?}\", exp_def);\n                     if exp_def == &found_def {\n                         let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n@@ -1203,9 +1203,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         {\n                             let mut show_suggestion = true;\n                             for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n-                                match exp_ty.sty {\n+                                match exp_ty.kind {\n                                     ty::Ref(_, exp_ty, _) => {\n-                                        match (&exp_ty.sty, &found_ty.sty) {\n+                                        match (&exp_ty.kind, &found_ty.kind) {\n                                             (_, ty::Param(_)) |\n                                             (_, ty::Infer(_)) |\n                                             (ty::Param(_), _) |"}, {"sha": "d56a6cf1f7bcb2d15d0c9c261d9bb6f953c400ca", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n             Some(ty) => {\n                 let ty = self.infcx.resolve_vars_if_possible(&ty);\n                 if ty.walk().any(|inner_ty| {\n-                    inner_ty == self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n+                    inner_ty == self.target_ty || match (&inner_ty.kind, &self.target_ty.kind) {\n                         (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n                             self.infcx\n                                 .type_variables\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>) {\n-        if let ty::Infer(ty::TyVar(ty_vid)) = ty.sty {\n+        if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n             let ty_vars = self.type_variables.borrow();\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let ty_msg = match local_visitor.found_ty {\n-            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+            Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n                 let fn_sig = substs.closure_sig(*def_id, self.tcx);\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         let suffix = match local_visitor.found_ty {\n-            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+            Some(ty::TyS { kind: ty::Closure(def_id, substs), .. }) => {\n                 let fn_sig = substs.closure_sig(*def_id, self.tcx);\n                 let ret = fn_sig.output().skip_binder().to_string();\n "}, {"sha": "a2e48cf07cb7ca3a5d7883030b3bc6b6fb119046", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         decl: &hir::FnDecl,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx().type_of(scope_def_id);\n-        if let ty::FnDef(_, _) = ret_ty.sty {\n+        if let ty::FnDef(_, _) = ret_ty.kind {\n             let sig = ret_ty.fn_sig(self.tcx());\n             let late_bound_regions = self.tcx()\n                 .collect_referenced_late_bound_regions(&sig.output());"}, {"sha": "9e9220cc3d8cc2f623e364b398da6b34aafab755", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n \n-        match t.sty {\n+        match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen_ty("}, {"sha": "e27766f461697527b396e40a3d2b99c9b5dcad82", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 if self.type_vars.0.contains(&vid) {\n                     // This variable was created during the fudging."}, {"sha": "39701231aad7e4b1ba2e35e7fd63913652bf301e", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -61,7 +61,7 @@ where\n     let infcx = this.infcx();\n     let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n     let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n-    match (&a.sty, &b.sty) {\n+    match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n         // relate `v` to the non-type-variable first (by passing it"}, {"sha": "c1782f53f0d2fb79ca570ce25a74069a544e8df4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -614,7 +614,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false,\n         }\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n         use crate::ty::error::UnconstrainedNumeric::Neither;\n         use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match ty.sty {\n+        match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n                 if self.int_unification_table\n                     .borrow_mut()\n@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n     }\n \n     pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.sty {\n+        match typ.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n@@ -1604,7 +1604,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n     // are extremely hot.\n     #[inline(always)]\n     pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n-        match typ.sty {\n+        match typ.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 use self::type_variable::TypeVariableValue;\n "}, {"sha": "50a2c95ed6f22e0809ef40065c12a695d21d0eba", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -274,7 +274,7 @@ where\n         use crate::traits::WhereClause;\n         use syntax_pos::DUMMY_SP;\n \n-        match value_ty.sty {\n+        match value_ty.kind {\n             ty::Projection(other_projection_ty) => {\n                 let var = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n@@ -328,7 +328,7 @@ where\n         // This only presently applies to chalk integration, as NLL\n         // doesn't permit type variables to appear on both sides (and\n         // doesn't use lazy norm).\n-        match value_ty.sty {\n+        match value_ty.kind {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n                 self.infcx\n@@ -548,7 +548,7 @@ where\n             b = self.infcx.shallow_resolve(b);\n         }\n \n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (_, &ty::Infer(ty::TyVar(vid))) => {\n                 if D::forbid_inference_vars() {\n                     // Forbid inference variables in the RHS.\n@@ -878,7 +878,7 @@ where\n \n         debug!(\"TypeGeneralizer::tys(a={:?})\", a);\n \n-        match a.sty {\n+        match a.kind {\n             ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n                 if D::forbid_inference_vars() =>\n             {"}, {"sha": "9b447f192a97a20cab63c4f6a2195e458a31f90e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -720,7 +720,7 @@ where\n             return false; // keep visiting\n         }\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Closure(def_id, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n@@ -857,7 +857,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n                 // we encounter a closure here, it is always a closure\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             ty_op: |ty| {\n                 if ty.references_error() {\n                     return tcx.types.err;\n-                } else if let ty::Opaque(def_id, substs) = ty.sty {\n+                } else if let ty::Opaque(def_id, substs) = ty.kind {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is"}, {"sha": "df491aef54fb99d9db9cf617420169e9c767c55f", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -403,7 +403,7 @@ where\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n         approx_env_bounds.retain(|bound| {\n-            match bound.0.sty {\n+            match bound.0.kind {\n                 ty::Projection(projection_ty) => {\n                     self.verify_bound.projection_declared_bounds_from_trait(projection_ty)\n                         .all(|r| r != bound.1)"}, {"sha": "3110b027c5bbe5f360aea5b5a85a9a2e455b992c", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -44,7 +44,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     }\n \n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Param(p) => self.param_bound(p),\n             ty::Projection(data) => self.projection_bound(data),\n             _ => self.recursive_type_bound(ty),\n@@ -87,7 +87,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n         self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n-            if let ty::Projection(..) = ty.sty {\n+            if let ty::Projection(..) = ty.kind {\n                 let erased_ty = self.tcx.erase_regions(&ty);\n                 erased_ty == erased_projection_ty\n             } else {"}, {"sha": "2db18674e2f53a8a423802b50ae175b681195da5", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n-            if let ty::Infer(infer_ty) = t.sty {\n+            if let ty::Infer(infer_ty) = t.kind {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span =\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n               // defaulted tuples.\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n-            match t.sty {\n+            match t.kind {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n                     self.tcx().types.err"}, {"sha": "21c847e80f4135dd02c188254efa9d6cc67f01f8", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -71,7 +71,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental"}, {"sha": "ce1b54bb1c81d4e9e37e81cd9f89dd2e6b3112b6", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -247,7 +247,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// instantiated, then return the with which it was\n     /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n+        match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     TypeVariableValue::Unknown { .. } => t,"}, {"sha": "e2582346de84c9f9b1412a0690b1c5c17dfcb33f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 trait_ref: Option<ty::TraitRef<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n                 if trait_ref.is_none() {\n-                    if let ty::Adt(def, substs) = self_ty.sty {\n+                    if let ty::Adt(def, substs) = self_ty.kind {\n                         return self.print_def_path(def.did, substs);\n                     }\n                 }"}, {"sha": "821ede37229b5df6b641dcb7f194059a93d02caf", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n-        match self.tables.expr_ty_adjusted(lhs).sty {\n+        match self.tables.expr_ty_adjusted(lhs).kind {\n             ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(hir_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res, pats: &[hir::FieldPat]) {\n-        let variant = match self.tables.node_type(lhs.hir_id).sty {\n+        let variant = match self.tables.node_type(lhs.hir_id).kind {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n-                if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {\n+                if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).kind {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }"}, {"sha": "1b1491a8febff74d029a41240dc4f10a6aed3c5b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::Ref(r, _, _) = expr_ty.sty {\n+                if let ty::Ref(r, _, _) = expr_ty.kind {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let callee_ty = return_if_err!(self.mc.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n-        match callee_ty.sty {\n+        match callee_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 self.consume_expr(callee);\n             }\n@@ -658,7 +658,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        match with_cmt.ty.sty {\n+        match with_cmt.ty.kind {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n-                            if let ty::Ref(r, _, _) = pat_ty.sty {\n+                            if let ty::Ref(r, _, _) = pat_ty.kind {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n                                 delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }"}, {"sha": "73a2e7dff6b15540b2648474de79fcf721cb0c74", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -37,7 +37,7 @@ struct ExprVisitor<'tcx> {\n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let (def, substs) = match ty.sty {\n+    let (def, substs) = match ty.kind {\n         ty::Adt(def, substs) => (def, substs),\n         _ => return ty\n     };\n@@ -83,7 +83,7 @@ impl ExprVisitor<'tcx> {\n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx.global_tcx(), from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.kind, sk_to) {\n                 if size_to == Pointer.size(&self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"can't transmute zero-sized type\")"}, {"sha": "e0149a3b9de5519aba74fa66b7ab8697f2c595ab", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -738,7 +738,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             LocalDefId::from_def_id(closure_expr_def_id),\n         );\n         let ty = self.node_ty(fn_hir_id)?;\n-        let kind = match ty.sty {\n+        let kind = match ty.kind {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n             ty::Closure(closure_def_id, closure_substs) => {\n                 match self.infcx {\n@@ -900,7 +900,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n \n         // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n-        let promotable = match expr_ty.sty {\n+        let promotable = match expr_ty.kind {\n             ty::Array(_, len) if len.try_eval_usize(self.tcx, self.param_env) == Some(0) => true,\n             _ => promotable,\n         };\n@@ -974,7 +974,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n-        let (region, mutbl) = match base_ty.sty {\n+        let (region, mutbl) = match base_ty.kind {\n             ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n         };\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n         };\n \n-        let ptr = match base_cmt.ty.sty {\n+        let ptr = match base_cmt.ty.kind {\n             ty::Adt(def, ..) if def.is_box() => Unique,\n             ty::RawPtr(ref mt) => UnsafePtr(mt.mutbl),\n             ty::Ref(r, _, mutbl) => {\n@@ -1230,7 +1230,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n                     | Res::SelfCtor(..) => {\n                         let ty = self.pat_ty_unadjusted(&pat)?;\n-                        match ty.sty {\n+                        match ty.kind {\n                             ty::Adt(adt_def, _) => {\n                                 (cmt, adt_def.non_enum_variant().fields.len())\n                             }\n@@ -1303,7 +1303,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             PatKind::Tuple(ref subpats, ddpos) => {\n                 // (p1, ..., pN)\n                 let ty = self.pat_ty_unadjusted(&pat)?;\n-                let expected_len = match ty.sty {\n+                let expected_len = match ty.kind {\n                     ty::Tuple(ref tys) => tys.len(),\n                     _ => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n                 };"}, {"sha": "26f718e858da8ea85b2c52bb935a280692b6ca91", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     ///\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: &Field) -> Ty<'tcx> {\n-        let answer = match self.ty.sty {\n+        let answer = match self.ty.kind {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n                     None => adt_def.non_enum_variant(),\n@@ -89,7 +89,7 @@ impl<'tcx> PlaceTy<'tcx> {\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n                 PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n             ProjectionElem::Subslice { from, to } => {\n-                PlaceTy::from_ty(match self.ty.sty {\n+                PlaceTy::from_ty(match self.ty.kind {\n                     ty::Array(inner, size) => {\n                         let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n@@ -195,7 +195,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::Discriminant(ref place) => {\n                 let ty = place.ty(local_decls, tcx).ty;\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n                     ty::Generator(_, substs, _) => substs.discr_ty(tcx),\n                     _ => {"}, {"sha": "6c0ea128df892ca5989fc3973795e871be4a74b4", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -601,15 +601,15 @@ impl AutoTraitFinder<'tcx> {\n     }\n \n     pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n-        return match ty.sty {\n+        return match ty.kind {\n             ty::Param(_) => true,\n             ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         };\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n-        match p.ty().skip_binder().sty {\n+        match p.ty().skip_binder().kind {\n             ty::Projection(proj) if proj == p.skip_binder().projection_ty => {\n                 true\n             },"}, {"sha": "039973d80dbf115f3597b8158ee88a84178685e0", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -383,7 +383,7 @@ fn orphan_check_trait_ref<'tcx>(\n             if ty_is_local(tcx, input_ty, in_crate) {\n                 debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n                 return Ok(());\n-            } else if let ty::Param(_) = input_ty.sty {\n+            } else if let ty::Param(_) = input_ty.kind {\n                 debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n                 return Err(OrphanCheckErr::UncoveredTy(input_ty))\n             }\n@@ -444,7 +444,7 @@ fn uncovered_tys<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<\n }\n \n fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Projection(..) | ty::Param(..) => true,\n         _ => false,\n     }\n@@ -456,7 +456,7 @@ fn ty_is_local(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n }\n \n fn fundamental_ty(ty: Ty<'_>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Ref(..) => true,\n         ty::Adt(def, _) => def.is_fundamental(),\n         _ => false\n@@ -475,7 +475,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n-    match ty.sty {\n+    match ty.kind {\n         ty::Bool |\n         ty::Char |\n         ty::Int(..) |"}, {"sha": "0683940af985e32173b8d055c3d6c3fb3a7dcf91", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         /// returns the fuzzy category of a given type, or None\n         /// if the type can be equated to any type.\n         fn type_category(t: Ty<'_>) -> Option<u32> {\n-            match t.sty {\n+            match t.kind {\n                 ty::Bool => Some(0),\n                 ty::Char => Some(1),\n                 ty::Str => Some(2),\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         match (type_category(a), type_category(b)) {\n-            (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n                 (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b\n             },\n@@ -419,7 +419,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n         }\n \n-        if let ty::Array(aty, len) = self_ty.sty {\n+        if let ty::Array(aty, len) = self_ty.kind {\n             flags.push((sym::_Self, Some(\"[]\".to_owned())));\n             flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n             if let Some(def) = aty.ty_adt_def() {\n@@ -876,7 +876,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 let found_trait_ty = found_trait_ref.self_ty();\n \n-                let found_did = match found_trait_ty.sty {\n+                let found_did = match found_trait_ty.kind {\n                     ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n                     ty::Adt(def, _) => Some(def.did),\n                     _ => None,\n@@ -886,13 +886,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.hir().span_if_local(did)\n                 ).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n                     ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n                     _ => vec![ArgKind::empty()],\n                 };\n \n                 let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.sty {\n+                let expected = match expected_ty.kind {\n                     ty::Tuple(ref tys) => tys.iter()\n                         .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span))).collect(),\n                     _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n@@ -979,7 +979,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         points_at_arg: bool,\n     ) {\n         let self_ty = trait_ref.self_ty();\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::FnDef(def_id, _) => {\n                 // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n                 // to a type that *would* satisfy the trait binding. If it would, suggest calling\n@@ -1066,7 +1066,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let mut trait_type = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::Ref(_, t_type, _) = trait_type.sty {\n+                if let ty::Ref(_, t_type, _) = trait_type.kind {\n                     trait_type = t_type;\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n@@ -1340,7 +1340,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         fn build_fn_sig_string<'tcx>(tcx: TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n-            let sig = if let ty::Tuple(inputs) = inputs.sty {\n+            let sig = if let ty::Tuple(inputs) = inputs.kind {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|k| k.expect_ty()),\n                     tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n@@ -1463,7 +1463,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n-                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.sty, trait_ref);\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n \n                 if predicate.references_error() {\n                     return;\n@@ -1564,7 +1564,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Param(ty::ParamTy {name, .. }) = ty.sty {\n+                if let ty::Param(ty::ParamTy {name, .. }) = ty.kind {\n                     let infcx = self.infcx;\n                     self.var_map.entry(ty).or_insert_with(||\n                         infcx.next_ty_var(\n@@ -1834,7 +1834,7 @@ impl ArgKind {\n     /// Creates an `ArgKind` from the expected type of an\n     /// argument. It has no name (`_`) and an optional source span.\n     pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n-        match t.sty {\n+        match t.kind {\n             ty::Tuple(ref tys) => ArgKind::Tuple(\n                 span,\n                 tys.iter()"}, {"sha": "0a190af1f986d24738ca54d1de037313b47e05b9", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -548,7 +548,7 @@ fn trait_ref_type_vars<'a, 'tcx>(\n      .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n-     .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })\n+     .filter(|t| match t.kind { ty::Infer(_) => true, _ => false })\n      .collect()\n }\n "}, {"sha": "e0ef179911b6c2b51a92f5535e0c053157d10348", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -677,7 +677,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut error = false;\n         let self_ty = self.types.self_param;\n         ty.maybe_walk(|ty| {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Param(_) => {\n                     if ty == self_ty {\n                         error = true;"}, {"sha": "57077bcdffa72900785d3209aabb9f9a73e7fb1f", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // should occur eventually).\n \n         let ty = ty.super_fold_with(self);\n-        match ty.sty {\n+        match ty.kind {\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n@@ -921,7 +921,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n \n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n-    let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n+    let (def_id, substs) = match obligation_trait_ref.self_ty().kind {\n         ty::Projection(ref data) => {\n             (data.trait_ref(tcx).def_id, data.substs)\n         }\n@@ -1199,7 +1199,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n-    let data = match object_ty.sty {\n+    let data = match object_ty.kind {\n         ty::Dynamic(ref data, ..) => data,\n         _ => {\n             span_bug!("}, {"sha": "673cae1ca0309bcdabe8423cbea92480d5d33946", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -186,7 +186,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's\n         // execution."}, {"sha": "b334e6dd8f84e128c0e899640b7ca06a670177e9", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -88,7 +88,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n-        match ty.sty {\n+        match ty.kind {\n             ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen."}, {"sha": "87191a4b4558d763c86ab77e6036933257c64a64", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1785,7 +1785,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n-        match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n+        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n             ty::Projection(_) | ty::Opaque(..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(\n@@ -1823,7 +1823,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             placeholder_trait_predicate,\n         );\n \n-        let (def_id, substs) = match placeholder_trait_predicate.trait_ref.self_ty().sty {\n+        let (def_id, substs) = match placeholder_trait_predicate.trait_ref.self_ty().kind {\n             ty::Projection(ref data) => (data.trait_ref(self.tcx()).def_id, data.substs),\n             ty::Opaque(def_id, substs) => (def_id, substs),\n             _ => {\n@@ -1971,7 +1971,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Generator(..) => {\n                 debug!(\n                     \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n@@ -2014,7 +2014,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        match obligation.self_ty().skip_binder().sty {\n+        match obligation.self_ty().skip_binder().kind {\n             ty::Closure(closure_def_id, closure_substs) => {\n                 debug!(\n                     \"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n@@ -2063,7 +2063,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n@@ -2125,7 +2125,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let def_id = obligation.predicate.def_id();\n \n         if self.tcx().trait_is_auto(def_id) {\n-            match self_ty.sty {\n+            match self_ty.kind {\n                 ty::Dynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. This means we conservatively\n@@ -2198,7 +2198,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n             let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n-            let poly_trait_ref = match self_ty.sty {\n+            let poly_trait_ref = match self_ty.kind {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits()\n                         .any(|did| did == obligation.predicate.def_id())\n@@ -2294,7 +2294,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             source, target\n         );\n \n-        let may_apply = match (&source.sty, &target.sty) {\n+        let may_apply = match (&source.kind, &target.kind) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n@@ -2532,7 +2532,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx\n             .shallow_resolve(obligation.predicate.skip_binder().self_ty());\n \n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Infer(ty::IntVar(_))\n             | ty::Infer(ty::FloatVar(_))\n             | ty::Uint(_)\n@@ -2598,7 +2598,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Infer(ty::IntVar(_))\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n@@ -2680,7 +2680,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n     fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        match t.sty {\n+        match t.kind {\n             ty::Uint(_)\n             | ty::Int(_)\n             | ty::Bool\n@@ -3118,7 +3118,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // results.\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.sty {\n+        let poly_trait_ref = match self_ty.kind {\n             ty::Dynamic(ref data, ..) =>\n                 data.principal().unwrap_or_else(|| {\n                     span_bug!(obligation.cause.span, \"object candidate with no principal\")\n@@ -3252,7 +3252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (generator_def_id, substs) = match self_ty.sty {\n+        let (generator_def_id, substs) = match self_ty.kind {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n@@ -3309,7 +3309,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match self_ty.sty {\n+        let (closure_def_id, substs) = match self_ty.kind {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n@@ -3418,7 +3418,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         let mut nested = vec![];\n-        match (&source.sty, &target.sty) {\n+        match (&source.kind, &target.kind) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n@@ -3550,7 +3550,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let mut ty_params = GrowableBitSet::new_empty();\n                 let mut found = false;\n                 for ty in field.walk() {\n-                    if let ty::Param(p) = ty.sty {\n+                    if let ty::Param(p) = ty.kind {\n                         ty_params.insert(p.index as usize);\n                         found = true;\n                     }"}, {"sha": "8cbadebaea5a591444fe8bc61d101001c2ce6d49", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -85,11 +85,11 @@ impl<'tcx> Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n-            debug!(\"insert_blindly: impl_def_id={:?} sty={:?}\", impl_def_id, sty);\n-            self.nonblanket_impls.entry(sty).or_default().push(impl_def_id)\n+        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+            debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n+            self.nonblanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n-            debug!(\"insert_blindly: impl_def_id={:?} sty=None\", impl_def_id);\n+            debug!(\"insert_blindly: impl_def_id={:?} st=None\", impl_def_id);\n             self.blanket_impls.push(impl_def_id)\n         }\n     }\n@@ -100,11 +100,11 @@ impl<'tcx> Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n-            debug!(\"remove_existing: impl_def_id={:?} sty={:?}\", impl_def_id, sty);\n-            vec = self.nonblanket_impls.get_mut(&sty).unwrap();\n+        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+            debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n+            vec = self.nonblanket_impls.get_mut(&st).unwrap();\n         } else {\n-            debug!(\"remove_existing: impl_def_id={:?} sty=None\", impl_def_id);\n+            debug!(\"remove_existing: impl_def_id={:?} st=None\", impl_def_id);\n             vec = &mut self.blanket_impls;\n         }\n \n@@ -130,7 +130,7 @@ impl<'tcx> Children {\n         );\n \n         let possible_siblings = match simplified_self {\n-            Some(sty) => PotentialSiblings::Filtered(self.filtered(sty)),\n+            Some(st) => PotentialSiblings::Filtered(self.filtered(st)),\n             None => PotentialSiblings::Unfiltered(self.iter()),\n         };\n \n@@ -249,8 +249,8 @@ impl<'tcx> Children {\n         self.blanket_impls.iter().chain(nonblanket).cloned()\n     }\n \n-    fn filtered(&mut self, sty: SimplifiedType) -> impl Iterator<Item = DefId> + '_ {\n-        let nonblanket = self.nonblanket_impls.entry(sty).or_default().iter();\n+    fn filtered(&mut self, st: SimplifiedType) -> impl Iterator<Item = DefId> + '_ {\n+        let nonblanket = self.nonblanket_impls.entry(st).or_default().iter();\n         self.blanket_impls.iter().chain(nonblanket).cloned()\n     }\n }"}, {"sha": "dab62a6bcb5b1dda15990b84d1d197355173d66b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.sty {\n+        match t.kind {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 self.types.insert(\n                     bound_ty.var.as_u32(),"}, {"sha": "a0d22789dae3576c7f1b488fbab39aaf39c03681", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -59,7 +59,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n                a, b);\n         if a == b { return Ok(a); }\n \n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (_, &ty::Infer(ty::FreshTy(_))) |\n             (_, &ty::Infer(ty::FreshIntTy(_))) |\n             (_, &ty::Infer(ty::FreshFloatTy(_))) => {"}, {"sha": "bc12412312debcb100a70d0d5f0cbd9bcfb4bdf2", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> CastTy<'tcx> {\n     /// Returns `Some` for integral/pointer casts.\n     /// casts like unsizing casts will return `None`\n     pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n-        match t.sty {\n+        match t.kind {\n             ty::Bool => Some(CastTy::Int(IntTy::Bool)),\n             ty::Char => Some(CastTy::Int(IntTy::Char)),\n             ty::Int(_) => Some(CastTy::Int(IntTy::I)),"}, {"sha": "bd4913c88fd1f19686f0c87fd820a93285706bcb", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -31,7 +31,7 @@ pub trait EncodableWithShorthand: Clone + Eq + Hash {\n impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n-        &self.sty\n+        &self.kind\n     }\n }\n "}, {"sha": "8a466567319e711434e8af2b4f33617057e17ed4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             let flags = super::flags::FlagComputation::for_sty(&st);\n \n             let ty_struct = TyS {\n-                sty: st,\n+                kind: st,\n                 flags: flags.flags,\n                 outer_exclusive_binder: flags.outer_exclusive_binder,\n             };\n@@ -828,7 +828,7 @@ impl CanonicalUserType<'tcx> {\n \n                 user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n                     match kind.unpack() {\n-                        UnpackedKind::Type(ty) => match ty.sty {\n+                        UnpackedKind::Type(ty) => match ty.kind {\n                             ty::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n@@ -890,7 +890,7 @@ EnumLiftImpl! {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n-        let mk = |sty| interners.intern_ty(sty);\n+        let mk = |ty| interners.intern_ty(ty);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1565,7 +1565,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         let ret_ty = self.type_of(scope_def_id);\n-        match ret_ty.sty {\n+        match ret_ty.kind {\n             ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(*self);\n                 let output = self.erase_late_bound_regions(&sig.output());\n@@ -2011,7 +2011,7 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &Interned(t) in types {\n-                    let variant = match t.sty {\n+                    let variant = match t.kind {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error => /* unimportant */ continue,\n@@ -2080,25 +2080,25 @@ impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n }\n impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n \n-// N.B., an `Interned<Ty>` compares and hashes as a sty.\n+// N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n-        self.0.sty == other.0.sty\n+        self.0.kind == other.0.kind\n     }\n }\n \n impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n \n impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.0.sty.hash(s)\n+        self.0.kind.hash(s)\n     }\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.sty\n+        &self.0.kind\n     }\n }\n \n@@ -2292,7 +2292,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// It cannot convert a closure that requires unsafe.\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>, unsafety: hir::Unsafety) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n-            let params_iter = match s.inputs()[0].sty {\n+            let params_iter = match s.inputs()[0].kind {\n                 ty::Tuple(params) => {\n                     params.into_iter().map(|k| k.expect_ty())\n                 }"}, {"sha": "d12039de3136e67daa463e0d6c8a2242d743026f", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -185,7 +185,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n \n impl<'tcx> ty::TyS<'tcx> {\n     pub fn sort_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n-        match self.sty {\n+        match self.kind {\n             ty::Bool | ty::Char | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n             ty::Tuple(ref tys) if tys.is_empty() => self.to_string().into(),\n@@ -275,7 +275,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  `.await`ing on both of them\");\n                     }\n                 }\n-                match (&values.expected.sty, &values.found.sty) {\n+                match (&values.expected.kind, &values.found.kind) {\n                     (ty::Float(_), ty::Infer(ty::IntVar(_))) => if let Ok( // Issue #53280\n                         snippet,\n                     ) = self.sess.source_map().span_to_snippet(sp) {\n@@ -373,9 +373,9 @@ impl Trait for X {\n                 debug!(\n                     \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n                     values.expected,\n-                    values.expected.sty,\n+                    values.expected.kind,\n                     values.found,\n-                    values.found.sty,\n+                    values.found.kind,\n                 );\n             },\n             CyclicTy(ty) => {"}, {"sha": "7d6ae3f815af18ce52202162cfe9cb90ca24bc08", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -60,7 +60,7 @@ pub fn simplify_type(\n     ty: Ty<'_>,\n     can_simplify_params: bool,\n ) -> Option<SimplifiedType> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Bool => Some(BoolSimplifiedType),\n         ty::Char => Some(CharSimplifiedType),\n         ty::Int(int_type) => Some(IntSimplifiedType(int_type)),"}, {"sha": "f6a5092d30d407b51aa43770cfc99a757dbde4c8", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n+        match t.kind {\n             ty::Bound(debruijn, bound_ty) => {\n                 if debruijn == self.current_index {\n                     let fld_t = &mut self.fld_t;\n@@ -776,7 +776,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Bound(debruijn, bound_ty) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n@@ -985,7 +985,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            match t.sty {\n+            match t.kind {\n                 ty::Projection(..) | ty::Opaque(..) => { return false; }\n                 _ => { }\n             }"}, {"sha": "bc0cf4deaa47ba04c8b40cb594e63bfb69e68090", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -181,7 +181,7 @@ impl<'tcx> FieldDef {\n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),\n \n             Never => DefIdForest::full(tcx),"}, {"sha": "ecb512b0cd1a2d2b50ec29563bd7fb0a83d1b8fe", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> Instance<'tcx> {\n \n     fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         let ty = self.ty(tcx);\n-        match ty.sty {\n+        match ty.kind {\n             ty::FnDef(..) |\n             // Shims currently have type FnPtr. Not sure this should remain.\n             ty::FnPtr(_) => ty.fn_sig(tcx),\n@@ -255,7 +255,7 @@ impl<'tcx> Instance<'tcx> {\n                 &ty,\n             );\n \n-            let def = match item_type.sty {\n+            let def = match item_type.kind {\n                 ty::FnDef(..) if {\n                     let f = item_type.fn_sig(tcx);\n                     f.abi() == Abi::RustIntrinsic ||"}, {"sha": "790b0c5cb48f4612c681e6d8e7f70fc0e441fdbb", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -520,7 +520,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n         debug_assert!(!ty.has_infer_types());\n \n-        Ok(match ty.sty {\n+        Ok(match ty.kind {\n             // Basic scalars.\n             ty::Bool => {\n                 tcx.intern_layout(LayoutDetails::scalar(self, Scalar {\n@@ -573,7 +573,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n \n                 let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n-                let metadata = match unsized_part.sty {\n+                let metadata = match unsized_part.kind {\n                     ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                     }\n@@ -1618,7 +1618,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                                                    variants);\n         };\n \n-        let adt_def = match layout.ty.sty {\n+        let adt_def = match layout.ty.kind {\n             ty::Adt(ref adt_def, _) => {\n                 debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n                 adt_def\n@@ -1759,12 +1759,12 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             Err(err) => err\n         };\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Ref(_, pointee, _) |\n             ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n-                match tail.sty {\n+                match tail.kind {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n@@ -2040,7 +2040,7 @@ where\n                     assert_eq!(layout.variants, Variants::Single { index });\n                 }\n \n-                let fields = match this.ty.sty {\n+                let fields = match this.ty.kind {\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!()\n                 };\n@@ -2078,7 +2078,7 @@ where\n             }))\n         };\n \n-        cx.layout_of(match this.ty.sty {\n+        cx.layout_of(match this.ty.kind {\n             ty::Bool |\n             ty::Char |\n             ty::Int(_) |\n@@ -2115,7 +2115,7 @@ where\n                     }));\n                 }\n \n-                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).sty {\n+                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind {\n                     ty::Slice(_) |\n                     ty::Str => tcx.types.usize,\n                     ty::Dynamic(_, _) => {\n@@ -2202,7 +2202,7 @@ where\n         cx: &C,\n         offset: Size,\n     ) -> Option<PointeeInfo> {\n-        match this.ty.sty {\n+        match this.ty.kind {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 cx.layout_of(mt.ty).to_result().ok()\n                     .map(|layout| PointeeInfo {\n@@ -2309,7 +2309,7 @@ where\n \n                 // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n                 if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = this.ty.sty {\n+                    if let ty::Adt(def, _) = this.ty.kind {\n                         if def.is_box() && offset.bytes() == 0 {\n                             pointee.safe = Some(PointerKind::UniqueOwned);\n                         }\n@@ -2641,7 +2641,7 @@ where\n         let extra_args = if sig.abi == RustCall {\n             assert!(!sig.c_variadic && extra_args.is_empty());\n \n-            match sig.inputs().last().unwrap().sty {\n+            match sig.inputs().last().unwrap().kind {\n                 ty::Tuple(tupled_arguments) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n@@ -2753,7 +2753,7 @@ where\n                             Some(did) => did,\n                             None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n                         };\n-                        match ty.sty {\n+                        match ty.kind {\n                             ty::Adt(def, _) if def.did == va_list_did => {\n                                 // This is the \"spoofed\" `VaListImpl`. Set the arguments mode\n                                 // so that it will be ignored."}, {"sha": "3d1ae838d816785df8b3031dc93323fb76c1b9d6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -479,7 +479,7 @@ bitflags! {\n \n #[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n-    pub sty: TyKind<'tcx>,\n+    pub kind: TyKind<'tcx>,\n     pub flags: TypeFlags,\n \n     /// This is a kind of confusing thing: it stores the smallest\n@@ -508,13 +508,13 @@ static_assert_size!(TyS<'_>, 32);\n \n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        self.sty.cmp(&other.sty)\n+        self.kind.cmp(&other.kind)\n     }\n }\n \n impl<'tcx> PartialOrd for TyS<'tcx> {\n     fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.sty.cmp(&other.sty))\n+        Some(self.kind.cmp(&other.kind))\n     }\n }\n \n@@ -534,7 +534,7 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Bool |\n             Char |\n             Int(_) |\n@@ -550,7 +550,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     pub fn is_suggestable(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Opaque(..) |\n             FnDef(..) |\n             FnPtr(..) |\n@@ -568,16 +568,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n-            ref sty,\n+            ref kind,\n \n             // The other fields just provide fast access to information that is\n-            // also contained in `sty`, so no need to hash them.\n+            // also contained in `kind`, so no need to hash them.\n             flags: _,\n \n             outer_exclusive_binder: _,\n         } = *self;\n \n-        sty.hash_stable(hcx, hasher);\n+        kind.hash_stable(hcx, hasher);\n     }\n }\n \n@@ -2494,7 +2494,7 @@ impl<'tcx> AdtDef {\n     }\n \n     fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        let result = match ty.sty {\n+        let result = match ty.kind {\n             Bool | Char | Int(..) | Uint(..) | Float(..) |\n             RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n             Array(..) | Closure(..) | Generator(..) | Never => {\n@@ -3339,7 +3339,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     }\n \n     let self_ty = trait_ref.self_ty();\n-    let self_ty_matches = match self_ty.sty {\n+    let self_ty_matches = match self_ty.kind {\n         ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n         _ => false\n     };"}, {"sha": "9a2e30f7f45ede4aa99c5296f92aa7d01f426585", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // with `collect()` because of the need to sometimes skip subtrees\n         // in the `subtys` iterator (e.g., when encountering a\n         // projection).\n-        match ty.sty {\n+        match ty.kind {\n             ty::Closure(def_id, ref substs) => {\n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);"}, {"sha": "727397d7a29ab3196b9eabd109a7deddb061409b", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -266,7 +266,7 @@ pub trait Printer<'tcx>: Sized {\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n         ty::Dynamic(data, ..) => data.principal_def_id(),"}, {"sha": "d7d43b8203f6f2b2761c01a9f9824793efa955da", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -34,7 +34,7 @@ impl DefPathBasedNames<'tcx> {\n     // When being used for codegen purposes, `debug` should be set to `false`\n     // in order to catch unexpected types that should never end up in a type name.\n     pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String, debug: bool) {\n-        match t.sty {\n+        match t.kind {\n             ty::Bool => output.push_str(\"bool\"),\n             ty::Char => output.push_str(\"char\"),\n             ty::Str => output.push_str(\"str\"),"}, {"sha": "a38a00ff5b759a5300c1440ade89987a38ff9496", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -414,7 +414,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n             // anything other than a simple path.\n-            match self_ty.sty {\n+            match self_ty.kind {\n                 ty::Adt(..) | ty::Foreign(_) |\n                 ty::Bool | ty::Char | ty::Str |\n                 ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n@@ -463,7 +463,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Type, Self::Error> {\n         define_scoped_cx!(self);\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Bool => p!(write(\"bool\")),\n             ty::Char => p!(write(\"char\")),\n             ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n@@ -739,7 +739,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Special-case `Fn(...) -> ...` and resugar it.\n             let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n-                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();\n                     if let (Some(proj), None) = (projections.next(), projections.next()) {\n                         let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n@@ -856,7 +856,7 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         let u8 = self.tcx().types.u8;\n-        if let ty::FnDef(did, substs) = ct.ty.sty {\n+        if let ty::FnDef(did, substs) = ct.ty.kind {\n             p!(print_value_path(did, substs));\n             return Ok(self);\n         }\n@@ -887,7 +887,7 @@ pub trait PrettyPrinter<'tcx>:\n             return Ok(self);\n         }\n         if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n-            match ct.ty.sty {\n+            match ct.ty.kind {\n                 ty::Bool => {\n                     p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n                     return Ok(self);\n@@ -935,8 +935,8 @@ pub trait PrettyPrinter<'tcx>:\n                 _ => {},\n             }\n         }\n-        if let ty::Ref(_, ref_ty, _) = ct.ty.sty {\n-            let byte_str = match (ct.val, &ref_ty.sty) {\n+        if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n+            let byte_str = match (ct.val, &ref_ty.kind) {\n                 (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n                     let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n                     Some(self.tcx()"}, {"sha": "d6bd4eeb7367ad27d64e34da006609ab64a0570f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -349,7 +349,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n ) -> RelateResult<'tcx, Ty<'tcx>> {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n-    match (&a.sty, &b.sty) {\n+    match (&a.kind, &b.kind) {\n         (&ty::Infer(_), _) |\n         (_, &ty::Infer(_)) =>\n         {"}, {"sha": "42d632d120ea1992a34f70261b22f62df6d698ad", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1023,7 +1023,7 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let sty = match self.sty {\n+        let kind = match self.kind {\n             ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n             ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n             ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n@@ -1064,13 +1064,13 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::Bound(..) |\n             ty::Placeholder(..) |\n             ty::Never |\n-            ty::Foreign(..) => return self\n+            ty::Foreign(..) => return self,\n         };\n \n-        if self.sty == sty {\n+        if self.kind == kind {\n             self\n         } else {\n-            folder.tcx().mk_ty(sty)\n+            folder.tcx().mk_ty(kind)\n         }\n     }\n \n@@ -1079,7 +1079,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match self.sty {\n+        match self.kind {\n             ty::RawPtr(ref tm) => tm.visit_with(visitor),\n             ty::Array(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n             ty::Slice(typ) => typ.visit_with(visitor),"}, {"sha": "6510aea8c256d9333631b57863d0969369a0312a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -384,9 +384,9 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n-        match ty.sty {\n+        match ty.kind {\n             ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.sty),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.kind),\n         }\n     }\n }\n@@ -1678,15 +1678,15 @@ impl RegionKind {\n impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_unit(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_never(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Never => true,\n             _ => false,\n         }\n@@ -1701,7 +1701,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n-        match self.sty {\n+        match self.kind {\n             ty::Never => true,\n             ty::Adt(def, _) if def.is_union() => {\n                 // For now, `union`s are never considered uninhabited.\n@@ -1741,52 +1741,52 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_ty_var(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Infer(TyVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Infer(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        if let Adt(def, _) = self.sty {\n+        if let Adt(def, _) = self.kind {\n             def.is_phantom_data()\n         } else {\n             false\n         }\n     }\n \n     #[inline]\n-    pub fn is_bool(&self) -> bool { self.sty == Bool }\n+    pub fn is_bool(&self) -> bool { self.kind == Bool }\n \n     #[inline]\n     pub fn is_param(&self, index: u32) -> bool {\n-        match self.sty {\n+        match self.kind {\n             ty::Param(ref data) => data.index == index,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_slice(&self) -> bool {\n-        match self.sty {\n-            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.sty {\n+        match self.kind {\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.kind {\n                 Slice(_) | Str => true,\n                 _ => false,\n             },\n@@ -1796,22 +1796,22 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_simd(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n     pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.sty {\n+        match self.kind {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n     pub fn simd_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n             }\n@@ -1820,23 +1820,23 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     pub fn simd_size(&self, _cx: TyCtxt<'_>) -> usize {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) => def.non_enum_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n \n     #[inline]\n     pub fn is_region_ptr(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Ref(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n             Ref(_, _, hir::Mutability::MutMutable) => true,\n             _ => false\n@@ -1845,7 +1845,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_unsafe_ptr(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             RawPtr(_) => return true,\n             _ => return false,\n         }\n@@ -1860,7 +1860,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Returns `true` if this type is an `Arc<T>`.\n     #[inline]\n     pub fn is_arc(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) => def.is_arc(),\n             _ => false,\n         }\n@@ -1869,23 +1869,23 @@ impl<'tcx> TyS<'tcx> {\n     /// Returns `true` if this type is an `Rc<T>`.\n     #[inline]\n     pub fn is_rc(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) => def.is_rc(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// panics if called on any type other than `Box<T>`\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n@@ -1896,7 +1896,7 @@ impl<'tcx> TyS<'tcx> {\n     /// contents are abstract to rustc.)\n     #[inline]\n     pub fn is_scalar(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Bool | Char | Int(_) | Float(_) | Uint(_) |\n             Infer(IntVar(_)) | Infer(FloatVar(_)) |\n             FnDef(..) | FnPtr(_) | RawPtr(_) => true,\n@@ -1907,7 +1907,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Returns `true` if this type is a floating point type.\n     #[inline]\n     pub fn is_floating_point(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Float(_) |\n             Infer(FloatVar(_)) => true,\n             _ => false,\n@@ -1916,15 +1916,15 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_trait(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Dynamic(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Adt(adt_def, _) => {\n                 adt_def.is_enum()\n             }\n@@ -1934,39 +1934,39 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_closure(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Closure(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_generator(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Generator(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_integral(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Infer(IntVar(_)) | Int(_) | Uint(_) => true,\n             _ => false\n         }\n     }\n \n     #[inline]\n     pub fn is_fresh_ty(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Infer(FreshTy(_)) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_fresh(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Infer(FreshTy(_)) => true,\n             Infer(FreshIntTy(_)) => true,\n             Infer(FreshFloatTy(_)) => true,\n@@ -1976,7 +1976,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_char(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Char => true,\n             _ => false,\n         }\n@@ -1989,31 +1989,31 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_signed(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Int(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_ptr_sized_integral(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_machine(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Param(_) | Infer(_) | Error => false,\n             _ => true,\n         }\n@@ -2024,7 +2024,7 @@ impl<'tcx> TyS<'tcx> {\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n     /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n-        match self.sty {\n+        match self.kind {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n@@ -2039,14 +2039,14 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Returns the type of `ty[i]`.\n     pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n-        match self.sty {\n+        match self.kind {\n             Array(ty, _) | Slice(ty) => Some(ty),\n             _ => None,\n         }\n     }\n \n     pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n-        match self.sty {\n+        match self.kind {\n             FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n             }\n@@ -2063,31 +2063,31 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_fn(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             FnDef(..) | FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_fn_ptr(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_impl_trait(&self) -> bool {\n-        match self.sty {\n+        match self.kind {\n             Opaque(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n-        match self.sty {\n+        match self.kind {\n             Adt(adt, _) => Some(adt),\n             _ => None,\n         }\n@@ -2096,7 +2096,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Iterates over tuple fields.\n     /// Panics when called on anything but a tuple.\n     pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> {\n-        match self.sty {\n+        match self.kind {\n             Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n         }\n@@ -2106,7 +2106,7 @@ impl<'tcx> TyS<'tcx> {\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n-        match self.sty {\n+        match self.kind {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n             _ => None,\n@@ -2122,7 +2122,7 @@ impl<'tcx> TyS<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n-        match self.sty {\n+        match self.kind {\n             TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n             TyKind::Generator(def_id, substs, _) =>\n                 Some(substs.discriminant_for_variant(def_id, tcx, variant_index)),\n@@ -2134,7 +2134,7 @@ impl<'tcx> TyS<'tcx> {\n     /// types reachable from this type via `walk_tys`). This ignores late-bound\n     /// regions binders.\n     pub fn push_regions(&self, out: &mut SmallVec<[ty::Region<'tcx>; 4]>) {\n-        match self.sty {\n+        match self.kind {\n             Ref(region, _, _) => {\n                 out.push(region);\n             }\n@@ -2190,7 +2190,7 @@ impl<'tcx> TyS<'tcx> {\n     /// inferred. Once upvar inference (in `src/librustc_typeck/check/upvar.rs`)\n     /// is complete, that type variable will be unified.\n     pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n-        match self.sty {\n+        match self.kind {\n             Int(int_ty) => match int_ty {\n                 ast::IntTy::I8 => Some(ty::ClosureKind::Fn),\n                 ast::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n@@ -2211,7 +2211,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        match self.sty {\n+        match self.kind {\n             ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n             ty::FnDef(..) | ty::FnPtr(_) | ty::RawPtr(..) |"}, {"sha": "b5debc179e9233297d57a59b24c32fce5b773e5d", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n         self.ty_stack_depth += 1;\n \n-        let t1 = match t.sty {\n+        let t1 = match t.kind {\n             ty::Param(p) => {\n                 self.ty_for_param(p, t)\n             }"}, {"sha": "714ebf4c42ff8eaa45b084a0d8a4b13a56209d26", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -33,7 +33,7 @@ pub struct Discr<'tcx> {\n \n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.ty.sty {\n+        match self.ty.kind {\n             ty::Int(ity) => {\n                 let size = ty::tls::with(|tcx| {\n                     Integer::from_attr(&tcx, SignedInt(ity)).size()\n@@ -54,7 +54,7 @@ impl<'tcx> Discr<'tcx> {\n         self.checked_add(tcx, 1).0\n     }\n     pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n-        let (int, signed) = match self.ty.sty {\n+        let (int, signed) = match self.ty.kind {\n             Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n             Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n             _ => bug!(\"non integer discriminant\"),\n@@ -179,7 +179,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n     ) -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n-            let (adt, substs) = match self_type.sty {\n+            let (adt, substs) = match self_type.kind {\n                 // These types used to have a builtin impl.\n                 // Now libcore provides that impl.\n                 ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n@@ -246,10 +246,10 @@ impl<'tcx> TyCtxt<'tcx> {\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n-        if let ty::Adt(def, substs) = ty.sty {\n+        if let ty::Adt(def, substs) = ty.kind {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error = field_ty.sty {\n+                if let Error = field_ty.kind {\n                     return true;\n                 }\n             }\n@@ -298,7 +298,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                       -> Ty<'tcx>\n     {\n         loop {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(def, substs) => {\n                     if !def.is_struct() {\n                         break;\n@@ -370,7 +370,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         let (mut a, mut b) = (source, target);\n         loop {\n-            match (&a.sty, &b.sty) {\n+            match (&a.kind, &b.kind) {\n                 (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n                         if a_def == b_def && a_def.is_struct() => {\n                     if let Some(f) = a_def.non_enum_variant().fields.last() {\n@@ -544,12 +544,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // <P1, P2, P0>, and then look up which of the impl substs refer to\n         // parameters marked as pure.\n \n-        let impl_substs = match self.type_of(impl_def_id).sty {\n+        let impl_substs = match self.type_of(impl_def_id).kind {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n-        let item_substs = match self.type_of(def.did).sty {\n+        let item_substs = match self.type_of(def.did).kind {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n@@ -561,7 +561,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n                     }\n                     UnpackedKind::Type(&ty::TyS {\n-                        sty: ty::Param(ref pt), ..\n+                        kind: ty::Param(ref pt), ..\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n@@ -733,7 +733,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n \n             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Opaque(def_id, substs) = t.sty {\n+                if let ty::Opaque(def_id, substs) = t.kind {\n                     self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n                 } else {\n                     t.super_fold_with(self)\n@@ -811,7 +811,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {\n                 if did_a != did_b {\n                     return false;\n@@ -846,7 +846,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n             ty: Ty<'tcx>,\n         ) -> Representability {\n-            match ty.sty {\n+            match ty.kind {\n                 Tuple(..) => {\n                     // Find non representable\n                     fold_repr(ty.tuple_fields().map(|ty| {\n@@ -889,7 +889,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n-            match ty.sty {\n+            match ty.kind {\n                 Adt(ty_def, _) => {\n                      ty_def == def\n                 }\n@@ -927,7 +927,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n             ty: Ty<'tcx>,\n         ) -> Representability {\n-            match ty.sty {\n+            match ty.kind {\n                 Adt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n@@ -1009,7 +1009,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n     pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n         let mut ty = self;\n-        while let Ref(_, inner_ty, _) = ty.sty {\n+        while let Ref(_, inner_ty, _) = ty.kind {\n             ty = inner_ty;\n         }\n         ty\n@@ -1067,7 +1067,7 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n \n     assert!(!ty.needs_infer());\n \n-    NeedsDrop(match ty.sty {\n+    NeedsDrop(match ty.kind {\n         // Fast-path for primitive types\n         ty::Infer(ty::FreshIntTy(_)) | ty::Infer(ty::FreshFloatTy(_)) |\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Never |\n@@ -1170,7 +1170,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n     {\n         use self::ExplicitSelf::*;\n \n-        match self_arg_ty.sty {\n+        match self_arg_ty.kind {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n             ty::Ref(region, ty, mutbl) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)"}, {"sha": "12f0d80cd0e1c83821fa7143b3369835e96b66d4", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -69,7 +69,7 @@ pub fn walk_shallow(ty: Ty<'_>) -> smallvec::IntoIter<TypeWalkerArray<'_>> {\n // natural order one would expect (basically, the order of the\n // types as they are written).\n fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n-    match parent_ty.sty {\n+    match parent_ty.kind {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n         ty::Str | ty::Infer(_) | ty::Param(_) | ty::Never | ty::Error |\n         ty::Placeholder(..) | ty::Bound(..) | ty::Foreign(..) => {"}, {"sha": "020926e7c8de8be41555a801cd4358cf62a2edac", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -236,7 +236,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let mut subtys = ty0.walk();\n         let param_env = self.param_env;\n         while let Some(ty) = subtys.next() {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Bool |\n                 ty::Char |\n                 ty::Int(..) |\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 //    is satisfied to ensure termination.)\n                 ty::Infer(_) => {\n                     let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::Infer(_) = ty.sty { // not yet resolved...\n+                    if let ty::Infer(_) = ty.kind { // not yet resolved...\n                         if ty == ty0 { // ...this is the type we started from! no progress.\n                             return false;\n                         }"}, {"sha": "fcede3eae976f61c56ab623c455c8af4f14672fc", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -615,7 +615,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, lp_base);\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n-                match lp_base.to_type().sty {\n+                match lp_base.to_type().kind {\n                     ty::Adt(def, _) if def.has_dtor(self.tcx()) => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of"}, {"sha": "2239bf56bbed2bd96b46cd9a1f94d8cb7fe05b1a", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -108,7 +108,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n-            match b.ty.sty {\n+            match b.ty.kind {\n                 ty::Adt(def, _) => {\n                     if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())"}, {"sha": "ee5099a97d57fcf8fc88e04d39d477bb65ad2bd8", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 let base_ty = cmt_base.ty;\n                 let result = self.restrict(&cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n-                match base_ty.sty {\n+                match base_ty.kind {\n                     ty::Adt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {"}, {"sha": "6bc42348bcf6c8db059c44a4b8d17a17f9b3a1e5", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -309,7 +309,7 @@ impl MoveData<'tcx> {\n         let mut lp = orig_lp.clone();\n         while let LpExtend(ref base_lp, mutbl, lp_elem) = lp.clone().kind {\n             if let (&ty::Adt(adt_def, _), LpInterior(opt_variant_id, interior))\n-                    = (&base_lp.ty.sty, lp_elem) {\n+                    = (&base_lp.ty.kind, lp_elem) {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n                         let field =\n@@ -361,7 +361,7 @@ impl MoveData<'tcx> {\n     ) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::Adt(adt_def, _) = base_lp.ty.sty {\n+            if let ty::Adt(adt_def, _) = base_lp.ty.kind {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n                         let field ="}, {"sha": "b8b0e77d0983026bc08afd6e837fd35b10bd3d31", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -324,7 +324,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use syntax::ast::UintTy::*;\n         use rustc::ty::{Int, Uint};\n \n-        let new_sty = match ty.sty {\n+        let new_sty = match ty.kind {\n             Int(Isize) => Int(self.tcx.sess.target.isize_ty),\n             Uint(Usize) => Uint(self.tcx.sess.target.usize_ty),\n             ref t @ Uint(_) | ref t @ Int(_) => t.clone(),"}, {"sha": "4fd971ca1153d9f6b71b1b2004a2a357f28a37b3", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -134,7 +134,7 @@ fn check_and_apply_linkage(\n         // extern \"C\" fn() from being non-null, so we can't just declare a\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n-        let llty2 = if let ty::RawPtr(ref mt) = ty.sty {\n+        let llty2 = if let ty::RawPtr(ref mt) = ty.kind {\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n             cx.sess().span_fatal("}, {"sha": "02d68f47c7e7d4667a533fa5677a93e541f743c7", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -340,7 +340,7 @@ fn fixed_vec_metadata(\n \n     let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n-    let upper_bound = match array_or_slice_type.sty {\n+    let upper_bound = match array_or_slice_type.kind {\n         ty::Array(_, len) => len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong,\n         _ => -1\n     };\n@@ -427,7 +427,7 @@ fn subroutine_type_metadata(\n \n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n-        match signature.output().sty {\n+        match signature.output().kind {\n             ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, signature.output(), span))\n         }\n@@ -466,7 +466,7 @@ fn trait_pointer_metadata(\n     // type is assigned the correct name, size, namespace, and source location.\n     // However, it does not describe the trait's methods.\n \n-    let containing_scope = match trait_type.sty {\n+    let containing_scope = match trait_type.kind {\n         ty::Dynamic(ref data, ..) =>\n             data.principal_def_id().map(|did| get_namespace_for_item(cx, did)),\n         _ => {\n@@ -563,7 +563,7 @@ pub fn type_metadata(\n     debug!(\"type_metadata: {:?}\", t);\n \n     let ptr_metadata = |ty: Ty<'tcx>| {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Slice(typ) => {\n                 Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n             }\n@@ -591,7 +591,7 @@ pub fn type_metadata(\n         }\n     };\n \n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.kind {\n         ty::Never    |\n         ty::Bool     |\n         ty::Char     |\n@@ -835,7 +835,7 @@ fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n-    let (name, encoding) = match t.sty {\n+    let (name, encoding) = match t.kind {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n         ty::Tuple(ref elements) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n@@ -1145,7 +1145,7 @@ fn prepare_struct_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n-    let (struct_def_id, variant) = match struct_type.sty {\n+    let (struct_def_id, variant) = match struct_type.kind {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n@@ -1268,7 +1268,7 @@ fn prepare_union_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n-    let (union_def_id, variant) = match union_type.sty {\n+    let (union_def_id, variant) = match union_type.kind {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n@@ -1334,7 +1334,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n         let variant_info_for = |index: VariantIdx| {\n-            match &self.enum_type.sty {\n+            match &self.enum_type.kind {\n                 ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n                 ty::Generator(def_id, substs, _) => {\n                     let generator_layout = cx.tcx.generator_layout(*def_id);\n@@ -1354,7 +1354,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                if let ty::Adt(adt, _) = &self.enum_type.sty {\n+                if let ty::Adt(adt, _) = &self.enum_type.kind {\n                     if adt.variants.is_empty() {\n                         return vec![];\n                     }\n@@ -1747,7 +1747,7 @@ fn prepare_enum_metadata(\n     let file_metadata = unknown_file_metadata(cx);\n \n     let discriminant_type_metadata = |discr: layout::Primitive| {\n-        let enumerators_metadata: Vec<_> = match enum_type.sty {\n+        let enumerators_metadata: Vec<_> = match enum_type.kind {\n             ty::Adt(def, _) => def\n                 .discriminants(cx.tcx)\n                 .zip(&def.variants)\n@@ -1790,7 +1790,7 @@ fn prepare_enum_metadata(\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n \n-                let discriminant_name = match enum_type.sty {\n+                let discriminant_name = match enum_type.kind {\n                     ty::Adt(..) => SmallCStr::new(&cx.tcx.item_name(enum_def_id).as_str()),\n                     ty::Generator(..) => SmallCStr::new(&enum_name),\n                     _ => bug!(),\n@@ -1881,7 +1881,7 @@ fn prepare_enum_metadata(\n         );\n     }\n \n-    let discriminator_name = match &enum_type.sty {\n+    let discriminator_name = match &enum_type.kind {\n         ty::Generator(..) => Some(SmallCStr::new(&\"__state\")),\n         _ => None,\n     };\n@@ -2091,7 +2091,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n // Compute the type parameters for a type, if any, for the given\n // metadata.\n fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'ll DIArray> {\n-    if let ty::Adt(def, substs) = ty.sty {\n+    if let ty::Adt(def, substs) = ty.kind {\n         if !substs.types().next().is_none() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);"}, {"sha": "08a37ce9bbfc8eb4b7318a2024f9977b83857bfa", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -377,7 +377,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n \n             // Return type -- llvm::DIBuilder wants this at index 0\n-            signature.push(match sig.output().sty {\n+            signature.push(match sig.output().kind {\n                 ty::Tuple(ref tys) if tys.is_empty() => None,\n                 _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n             });\n@@ -401,7 +401,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // This transformed type is wrong, but these function types are\n                 // already inaccurate due to ABI adjustments (see #42800).\n                 signature.extend(inputs.iter().map(|&t| {\n-                    let t = match t.sty {\n+                    let t = match t.kind {\n                         ty::Array(ct, _)\n                             if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n                             cx.tcx.mk_imm_ptr(ct)\n@@ -417,7 +417,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n \n             if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].kind {\n                     signature.extend(\n                         args.iter().map(|argument_type| {\n                             Some(type_metadata(cx, argument_type.expect_ty(), syntax_pos::DUMMY_SP))\n@@ -516,7 +516,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.sty {\n+                    match impl_self_ty.kind {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                         }"}, {"sha": "b7a410c3760cdd5cfa7e300674c4da0bf9c0d888", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -91,7 +91,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let tcx = self.tcx;\n         let callee_ty = instance.ty(tcx);\n \n-        let (def_id, substs) = match callee_ty.sty {\n+        let (def_id, substs) = match callee_ty.kind {\n             ty::FnDef(def_id, substs) => (def_id, substs),\n             _ => bug!(\"expected fn item type, found {}\", callee_ty)\n         };\n@@ -1074,7 +1074,7 @@ fn generic_simd_intrinsic(\n \n     if name == \"simd_select_bitmask\" {\n         let in_ty = arg_tys[0];\n-        let m_len = match in_ty.sty {\n+        let m_len = match in_ty.kind {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n             // of intentional as there's not currently a use case for that.\n             ty::Int(i) => i.bit_width().unwrap(),\n@@ -1203,7 +1203,7 @@ fn generic_simd_intrinsic(\n                  \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n                  m_len, v_len\n         );\n-        match m_elem_ty.sty {\n+        match m_elem_ty.kind {\n             ty::Int(_) => {},\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n@@ -1223,7 +1223,7 @@ fn generic_simd_intrinsic(\n         // If the vector has less than 8 lanes, an u8 is returned with zeroed\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n-        match ret_ty.sty {\n+        match ret_ty.kind {\n            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n             _ => return_error!(\n                 \"bitmask `{}`, expected `u{}`\",\n@@ -1232,7 +1232,7 @@ fn generic_simd_intrinsic(\n         }\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n-        let (i_xn, in_elem_bitwidth) = match in_elem.sty {\n+        let (i_xn, in_elem_bitwidth) = match in_elem.kind {\n             ty::Int(i) => (\n                 args[0].immediate(),\n                 i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits() as _)\n@@ -1288,7 +1288,7 @@ fn generic_simd_intrinsic(\n                 }\n             }\n         }\n-        let ety = match in_elem.sty {\n+        let ety = match in_elem.kind {\n             ty::Float(f) if f.bit_width() == 32 => {\n                 if in_len < 2 || in_len > 16 {\n                     return_error!(\n@@ -1375,7 +1375,7 @@ fn generic_simd_intrinsic(\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n     fn llvm_vector_str(elem_ty: Ty<'_>, vec_len: usize, no_pointers: usize) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n-        match elem_ty.sty {\n+        match elem_ty.kind {\n             ty::Int(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n             ty::Uint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n             ty::Float(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n@@ -1386,7 +1386,7 @@ fn generic_simd_intrinsic(\n     fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: Ty<'_>, vec_len: usize,\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n-        let mut elem_ty = match elem_ty.sty {\n+        let mut elem_ty = match elem_ty.kind {\n             ty::Int(v) => cx.type_int_from_ty( v),\n             ty::Uint(v) => cx.type_uint_from_ty( v),\n             ty::Float(v) => cx.type_float_from_ty( v),\n@@ -1430,23 +1430,23 @@ fn generic_simd_intrinsic(\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n-            match t.sty {\n+            match t.kind {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n-            match t.sty {\n+            match t.kind {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n             ty::RawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n                                                  non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {\n@@ -1463,7 +1463,7 @@ fn generic_simd_intrinsic(\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).sty {\n+        match arg_tys[2].simd_type(tcx).kind {\n             ty::Int(_) => (),\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n@@ -1529,23 +1529,23 @@ fn generic_simd_intrinsic(\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n-            match t.sty {\n+            match t.kind {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n-            match t.sty {\n+            match t.kind {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n             ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n@@ -1563,7 +1563,7 @@ fn generic_simd_intrinsic(\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).sty {\n+        match arg_tys[2].simd_type(tcx).kind {\n             ty::Int(_) => (),\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n@@ -1612,7 +1612,7 @@ fn generic_simd_intrinsic(\n                 require!(ret_ty == in_elem,\n                          \"expected return type `{}` (element of input `{}`), found `{}`\",\n                          in_elem, in_ty, ret_ty);\n-                return match in_elem.sty {\n+                return match in_elem.kind {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$integer_reduce(args[0].immediate());\n                         if $ordered {\n@@ -1669,7 +1669,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 require!(ret_ty == in_elem,\n                          \"expected return type `{}` (element of input `{}`), found `{}`\",\n                          in_elem, in_ty, ret_ty);\n-                return match in_elem.sty {\n+                return match in_elem.kind {\n                     ty::Int(_i) => {\n                         Ok(bx.$int_red(args[0].immediate(), true))\n                     },\n@@ -1704,7 +1704,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                              in_elem, in_ty, ret_ty);\n                     args[0].immediate()\n                 } else {\n-                    match in_elem.sty {\n+                    match in_elem.kind {\n                         ty::Int(_) | ty::Uint(_) => {},\n                         _ => {\n                             return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n@@ -1717,7 +1717,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     let i1xn = bx.type_vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n-                return match in_elem.sty {\n+                return match in_elem.kind {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$red(input);\n                         Ok(\n@@ -1758,15 +1758,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n         enum Style { Float, Int(/* is signed? */ bool), Unsupported }\n \n-        let (in_style, in_width) = match in_elem.sty {\n+        let (in_style, in_width) = match in_elem.kind {\n             // vectors of pointer-sized integers should've been\n             // disallowed before here, so this unwrap is safe.\n             ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n             ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0)\n         };\n-        let (out_style, out_width) = match out_elem.sty {\n+        let (out_style, out_width) = match out_elem.kind {\n             ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n             ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n@@ -1816,7 +1816,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n             $(if name == stringify!($name) {\n-                match in_elem.sty {\n+                match in_elem.kind {\n                     $($(ty::$p(_))|* => {\n                         return Ok(bx.$call(args[0].immediate(), args[1].immediate()))\n                     })*\n@@ -1850,7 +1850,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         let rhs = args[1].immediate();\n         let is_add = name == \"simd_saturating_add\";\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match in_elem.sty {\n+        let (signed, elem_width, elem_ty) = match in_elem.kind {\n             ty::Int(i) =>\n                 (\n                     true,\n@@ -1896,7 +1896,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Int(t) => Some((match t {\n             ast::IntTy::Isize => cx.tcx.sess.target.isize_ty.bit_width().unwrap() as u64,\n             ast::IntTy::I8 => 8,\n@@ -1920,7 +1920,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n // Returns the width of a float Ty\n // Returns None if the type is not a float\n fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Float(t) => Some(t.bit_width() as u64),\n         _ => None,\n     }"}, {"sha": "81a99bc5019b3ece4fd7bfe9873132b84dd35f15", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -43,7 +43,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         layout::Abi::Aggregate { .. } => {}\n     }\n \n-    let name = match layout.ty.sty {\n+    let name = match layout.ty.kind {\n         ty::Closure(..) |\n         ty::Generator(..) |\n         ty::Adt(..) |\n@@ -56,14 +56,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name, false);\n             if let (&ty::Adt(def, _), &layout::Variants::Single { index })\n-                 = (&layout.ty.sty, &layout.variants)\n+                 = (&layout.ty.kind, &layout.variants)\n             {\n                 if def.is_enum() && !def.variants.is_empty() {\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n             if let (&ty::Generator(_, substs, _), &layout::Variants::Single { index })\n-                 = (&layout.ty.sty, &layout.variants)\n+                 = (&layout.ty.kind, &layout.variants)\n             {\n                 write!(&mut name, \"::{}\", substs.variant_name(index)).unwrap();\n             }\n@@ -226,7 +226,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n                 return llty;\n             }\n-            let llty = match self.ty.sty {\n+            let llty = match self.ty.kind {\n                 ty::Ref(_, ty, _) |\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.type_ptr_to(cx.layout_of(ty).llvm_type(cx))\n@@ -318,7 +318,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                                          index: usize, immediate: bool) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n-        match self.ty.sty {\n+        match self.ty.kind {\n             ty::Ref(..) |\n             ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);"}, {"sha": "8f7f769f6b9961eb4f51fbc1e6de108d8ebdcab1", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -96,7 +96,7 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     ret_ty: Bx::Type,\n     op: hir::BinOpKind,\n ) -> Bx::Value {\n-    let signed = match t.sty {\n+    let signed = match t.kind {\n         ty::Float(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n             let cmp = bx.fcmp(cmp, lhs, rhs);\n@@ -130,7 +130,7 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n ) -> Cx::Value {\n     let (source, target) =\n         cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n-    match (&source.sty, &target.sty) {\n+    match (&source.kind, &target.kind) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n@@ -160,7 +160,7 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     dst_ty: Ty<'tcx>,\n ) -> (Bx::Value, Bx::Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n-    match (&src_ty.sty, &dst_ty.sty) {\n+    match (&src_ty.kind, &dst_ty.kind) {\n         (&ty::Ref(_, a, _),\n          &ty::Ref(_, b, _)) |\n         (&ty::Ref(_, a, _),\n@@ -232,7 +232,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         };\n         OperandValue::Pair(base, info).store(bx, dst);\n     };\n-    match (&src_ty.sty, &dst_ty.sty) {\n+    match (&src_ty.kind, &dst_ty.kind) {\n         (&ty::Ref(..), &ty::Ref(..)) |\n         (&ty::Ref(..), &ty::RawPtr(..)) |\n         (&ty::RawPtr(..), &ty::RawPtr(..)) => {"}, {"sha": "d875c60959cba12027136d46f8e6c11a41320ed7", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -32,7 +32,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n \n-    match t.sty {\n+    match t.kind {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),"}, {"sha": "9818bb78e757b984de7d2a0de87e4f989dec5f48", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -20,7 +20,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let align = bx.const_usize(layout.align.abi.bytes());\n         return (size, align);\n     }\n-    match t.sty {\n+    match t.kind {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n             let vtable = info.unwrap();\n@@ -64,7 +64,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let size = bx.add(sized_size, unsized_size);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::Adt(def, _) = t.sty {\n+            if let ty::Adt(def, _) = t.kind {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "05896523863c25f55a6b316b4109a47cb2a50d27", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -218,7 +218,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(ref c),\n                 ref args, ..\n-            } => match c.literal.ty.sty {\n+            } => match c.literal.ty.kind {\n                 ty::FnDef(did, _) => Some((did, args)),\n                 _ => None,\n             },"}, {"sha": "3069199a21256234177fd438fd02753e143d2199", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_ty) = match ty.sty {\n+        let (drop_fn, fn_ty) = match ty.kind {\n             ty::Dynamic(..) => {\n                 let sig = drop_fn.fn_sig(self.cx.tcx());\n                 let sig = self.cx.tcx().normalize_erasing_late_bound_regions(\n@@ -455,7 +455,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n         let callee = self.codegen_operand(&mut bx, func);\n \n-        let (instance, mut llfn) = match callee.layout.ty.sty {\n+        let (instance, mut llfn) = match callee.layout.ty.kind {\n             ty::FnDef(def_id, substs) => {\n                 (Some(ty::Instance::resolve(bx.tcx(),\n                                             ty::ParamEnv::reveal_all(),"}, {"sha": "9cfe410fcc5e036b532c047e20119da58a848587", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant\n             .map(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n-                let fields = match c.ty.sty {\n+                let fields = match c.ty.kind {\n                     ty::Array(_, n) => n.eval_usize(bx.tcx(), ty::ParamEnv::reveal_all()),\n                     _ => bug!(\"invalid simd shuffle type: {}\", c.ty),\n                 };"}, {"sha": "c341c0685c6a71a9b82ee347ac9e3ea2ccb4dd39", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -467,7 +467,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // individual LLVM function arguments.\n \n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n-            let tupled_arg_tys = match arg_ty.sty {\n+            let tupled_arg_tys = match arg_ty.kind {\n                 ty::Tuple(ref tys) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n@@ -573,7 +573,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     Some(did) => did,\n                     None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n                 };\n-                match arg_decl.ty.sty {\n+                match arg_decl.ty.kind {\n                     ty::Adt(def, _) if def.did == va_list_did => {\n                         // Call `va_start` on the spoofed `VaListImpl`.\n                         bx.va_start(tmp.llval);\n@@ -612,19 +612,19 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             let pin_did = tcx.lang_items().pin_type();\n             // Or is it the closure environment?\n-            let (closure_layout, env_ref) = match arg.layout.ty.sty {\n+            let (closure_layout, env_ref) = match arg.layout.ty.kind {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n                 ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n                 ty::Adt(def, substs) if Some(def.did) == pin_did => {\n-                    match substs.type_at(0).sty {\n+                    match substs.type_at(0).kind {\n                         ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n                         _ => (arg.layout, false),\n                     }\n                 }\n                 _ => (arg.layout, false)\n             };\n \n-            let (def_id, upvar_substs) = match closure_layout.ty.sty {\n+            let (def_id, upvar_substs) = match closure_layout.ty.kind {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n                 _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n@@ -641,7 +641,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     });\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n-                    let (def_id, gen_substs) = match closure_layout.ty.sty {\n+                    let (def_id, gen_substs) = match closure_layout.ty.kind {\n                         ty::Generator(def_id, substs, _) => (def_id, substs),\n                         _ => bug!(\"generator layout without generator substs\"),\n                     };\n@@ -695,7 +695,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // The environment and the capture can each be indirect.\n                 let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n \n-                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.sty) {\n+                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.kind) {\n                     ty\n                 } else {\n                     ops = &ops[..ops.len() - 1];"}, {"sha": "2d97f828f073de5ab50238f799b78c3916efc390", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         //   * no metadata available - just log the case\n         //   * known alignment - sized types, `[T]`, `str` or a foreign type\n         //   * packed struct - there is no alignment padding\n-        match field.ty.sty {\n+        match field.ty.kind {\n             _ if self.llextra.is_none() => {\n                 debug!(\"unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                     ix, self.llval);"}, {"sha": "9b69383b455cf28c71e8bcf6bc2524ea602b5f7e", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 let val = match *kind {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        match operand.layout.ty.sty {\n+                        match operand.layout.ty.kind {\n                             ty::FnDef(def_id, substs) => {\n                                 if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n                                     bug!(\"reifying a fn ptr that requires const arguments\");\n@@ -198,7 +198,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Pointer(PointerCast::ClosureFnPointer(_)) => {\n-                        match operand.layout.ty.sty {\n+                        match operand.layout.ty.kind {\n                             ty::Closure(def_id, substs) => {\n                                 let instance = Instance::resolve_closure(\n                                     bx.cx().tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n@@ -525,7 +525,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             projection: box [],\n         } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if let ty::Array(_, n) = op.layout.ty.sty {\n+                if let ty::Array(_, n) = op.layout.ty.kind {\n                     let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n                     return bx.cx().const_usize(n);\n                 }"}, {"sha": "19d41c6b37cbb765b67ea854f21ea9d41edb559b", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -83,7 +83,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n \n         let tail = self.tcx().struct_tail_erasing_lifetimes(ty, param_env);\n-        match tail.sty {\n+        match tail.kind {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n             _ => bug!(\"unexpected unsized tail: {:?}\", tail),"}, {"sha": "1b094e26c2443c403ae187aa811b59014888056d", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -111,7 +111,7 @@ fn get_symbol_hash<'tcx>(\n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.sty {\n+        if let ty::FnDef(..) = item_type.kind {\n             item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n \n@@ -218,7 +218,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n         self,\n         ty: Ty<'tcx>,\n     ) -> Result<Self::Type, Self::Error> {\n-        match ty.sty {\n+        match ty.kind {\n             // Print all nominal types as paths (unlike `pretty_print_type`).\n             ty::FnDef(def_id, substs) |\n             ty::Opaque(def_id, substs) |\n@@ -275,7 +275,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     ) -> Result<Self::Path, Self::Error> {\n         // Similar to `pretty_path_qualified`, but for the other\n         // types that are printed as paths (see `print_type` above).\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::FnDef(..) |\n             ty::Opaque(..) |\n             ty::Projection(_) |"}, {"sha": "f1f5913425d017e5a3a9a288b8b9cf90bd0d56ea", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -323,7 +323,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Result<Self::Type, Self::Error> {\n         // Basic types, never cached (single-character).\n-        let basic_type = match ty.sty {\n+        let basic_type = match ty.kind {\n             ty::Bool => \"b\",\n             ty::Char => \"c\",\n             ty::Str => \"e\",\n@@ -360,7 +360,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ty.sty {\n+        match ty.kind {\n             // Basic types, handled above.\n             ty::Bool | ty::Char | ty::Str |\n             ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n@@ -511,7 +511,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ct.ty.sty {\n+        match ct.ty.kind {\n             ty::Uint(_) => {}\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\","}, {"sha": "d08fd47dc169eee9a5efd6696bfe2a4d28845a80", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -918,7 +918,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n-        match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.sty, &ty2.sty)) {\n+        match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::MutMutable &&\n                    from_mt == hir::Mutability::MutImmutable {\n@@ -1954,7 +1954,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             init: InitKind,\n         ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n-            match ty.sty {\n+            match ty.kind {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),"}, {"sha": "3a037b4dfff1f7a0ae7c135e0d0581fe50e03d1c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -227,7 +227,7 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<String> {\n             }\n         }\n     }\n-    match t.sty {\n+    match t.kind {\n         ty::Int(i) => find_fit!(i, val, negative,\n                       I8 => [U8] => [I16, I32, I64, I128],\n                       I16 => [U16] => [I32, I64, I128],\n@@ -320,7 +320,7 @@ fn lint_uint_literal<'a, 'tcx>(\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.node {\n                 hir::ExprKind::Cast(..) => {\n-                    if let ty::Char = cx.tables.expr_ty(par_e).sty {\n+                    if let ty::Char = cx.tables.expr_ty(par_e).kind {\n                         let mut err = cx.struct_span_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n@@ -364,7 +364,7 @@ fn lint_literal<'a, 'tcx>(\n     e: &'tcx hir::Expr,\n     lit: &hir::Lit,\n ) {\n-    match cx.tables.node_type(e.hir_id).sty {\n+    match cx.tables.node_type(e.hir_id).kind {\n         ty::Int(t) => {\n             match lit.node {\n                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -453,7 +453,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.tables.node_type(expr.hir_id).sty {\n+            match cx.tables.node_type(expr.hir_id).kind {\n                 ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n@@ -526,7 +526,7 @@ fn is_zst<'tcx>(tcx: TyCtxt<'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n }\n \n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n         ty::Adt(field_def, substs) if field_def.repr.transparent() && !field_def.is_union() => {\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             return FfiSafe;\n         }\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(def, substs) => {\n                 if def.is_phantom_data() {\n                     return FfiPhantom(ty);\n@@ -876,7 +876,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             diag.help(help);\n         }\n         diag.note(note);\n-        if let ty::Adt(def, _) = ty.sty {\n+        if let ty::Adt(def, _) = ty.kind {\n             if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n                 diag.span_note(sp, \"type defined here\");\n             }\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'tcx> {\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-                if let ty::Opaque(..) = ty.sty {\n+                if let ty::Opaque(..) = ty.kind {\n                     self.ty = Some(ty);\n                     true\n                 } else {"}, {"sha": "86df0b9f681e4a9a2af05169c19e43d2d24db1fd", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n             let plural_suffix = pluralise!(plural_len);\n \n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(..) if ty.is_box() => {\n                     let boxed_ty = ty.boxed_ty();\n                     let descr_pre = &format!(\"{}boxed \", descr_pre);"}, {"sha": "38089f0dc73915167bd797c9cce55890d7025f41", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1427,7 +1427,7 @@ impl EncodeContext<'tcx> {\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let kind = match tables.node_type(hir_id).sty {\n+        let kind = match tables.node_type(hir_id).kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1978,7 +1978,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n pub fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(ref def, _) => return def.repr,\n         _ => bug!(\"{} is not an ADT\", ty),\n     }"}, {"sha": "5fb41dc20c741847208804ee589336bbb8e5de24", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -211,7 +211,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty =\n                 Place::ty_from(used_place.base, used_place.projection, self.body, self.infcx.tcx)\n                     .ty;\n-            let needs_note = match ty.sty {\n+            let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n@@ -232,7 +232,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n-                if let ty::Param(param_ty) = ty.sty {\n+                if let ty::Param(param_ty) = ty.kind {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let def_id = generics.type_param(&param_ty, tcx).def_id;\n@@ -1243,7 +1243,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let escapes_from = if tcx.is_closure(self.mir_def_id) {\n             let tables = tcx.typeck_tables_of(self.mir_def_id);\n             let mir_hir_id = tcx.hir().def_index_to_hir_id(self.mir_def_id.index);\n-            match tables.node_type(mir_hir_id).sty {\n+            match tables.node_type(mir_hir_id).kind {\n                 ty::Closure(..) => \"closure\",\n                 ty::Generator(..) => \"generator\",\n                 _ => bug!(\"Closure body doesn't have a closure or generator type\"),\n@@ -1543,7 +1543,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n                         let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n-                        match base_ty.sty {\n+                        match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n                                 match base_access {\n@@ -1579,7 +1579,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 None\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-                match ty.sty {\n+                match ty.kind {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n                         self.mir_def_id,\n                         self.infcx.tcx.fn_sig(self.mir_def_id),\n@@ -1834,13 +1834,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // 3. The return type is not a reference. In this case, we don't highlight\n         //    anything.\n         let return_ty = sig.output();\n-        match return_ty.skip_binder().sty {\n+        match return_ty.skip_binder().kind {\n             ty::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n                 // This is case 1 from above, return type is a named reference so we need to\n                 // search for relevant arguments.\n                 let mut arguments = Vec::new();\n                 for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n-                    if let ty::Ref(argument_region, _, _) = argument.sty {\n+                    if let ty::Ref(argument_region, _, _) = argument.kind {\n                         if argument_region == return_region {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n@@ -1886,9 +1886,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // Closure arguments are wrapped in a tuple, so we need to get the first\n                 // from that.\n-                if let ty::Tuple(elems) = argument_ty.sty {\n+                if let ty::Tuple(elems) = argument_ty.kind {\n                     let argument_ty = elems.first()?.expect_ty();\n-                    if let ty::Ref(_, _, _) = argument_ty.sty {\n+                    if let ty::Ref(_, _, _) = argument_ty.kind {\n                         return Some(AnnotatedBorrowFnSignature::Closure {\n                             argument_ty,\n                             argument_span,\n@@ -1908,7 +1908,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let return_ty = *sig.output().skip_binder();\n \n                 // We expect the first argument to be a reference.\n-                match argument_ty.sty {\n+                match argument_ty.kind {\n                     ty::Ref(_, _, _) => {}\n                     _ => return None,\n                 }"}, {"sha": "c0c0e7a32b672e0576123dc4c654cb7820efce8e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -58,7 +58,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n                 literal: ty::Const {\n-                    ty: &ty::TyS { sty: ty::FnDef(id, _), ..  },\n+                    ty: &ty::TyS { kind: ty::FnDef(id, _), ..  },\n                     ..\n                 },\n                 ..\n@@ -76,7 +76,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 };\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.sty {\n+                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -99,7 +99,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::Closure(did, _) = self.body.local_decls[target].ty.sty {\n+            if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -400,7 +400,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // If the type is a box, the field is described from the boxed type\n             self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n         } else {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(def, _) => {\n                     let variant = if let Some(idx) = variant_index {\n                         assert!(def.is_enum());\n@@ -558,7 +558,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n-        match ty.sty {\n+        match ty.kind {\n             ty::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n             | ty::Ref(\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n@@ -578,7 +578,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut s = String::new();\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n-        let region = match ty.sty {\n+        let region = match ty.kind {\n             ty::Ref(region, _, _) => {\n                 match region {\n                     ty::RegionKind::ReLateBound(_, br)\n@@ -754,7 +754,7 @@ impl BorrowedContentSource<'tcx> {\n     }\n \n     fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n-        match func.sty {\n+        match func.kind {\n             ty::FnDef(def_id, substs) => {\n                 let trait_id = tcx.trait_of_item(def_id)?;\n "}, {"sha": "b12af1a0e95227bf02b4e3a13010897b439ffec8", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1796,7 +1796,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n-                    match base_ty.sty {\n+                    match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n@@ -1902,7 +1902,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.sty\n+                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -2195,7 +2195,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n-                        match base_ty.sty {\n+                        match base_ty.kind {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable"}, {"sha": "bf5bddadd16f125c4c51943b8086f7aed3459207", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n \n         debug!(\"report: ty={:?}\", ty);\n-        let mut err = match ty.sty {\n+        let mut err = match ty.kind {\n             ty::Array(..) | ty::Slice(..) =>\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None),\n             ty::Closure(def_id, closure_substs)"}, {"sha": "c3aed74bcaad2891ea77ab4f7c81777632ab4407", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n                         if let ty::Ref(\n                             _, _, hir::Mutability::MutMutable\n-                        ) = local_decl.ty.sty {\n+                        ) = local_decl.ty.kind {\n                             true\n                         } else {\n                             false\n@@ -630,8 +630,8 @@ fn annotate_struct_field(\n     field: &mir::Field,\n ) -> Option<(Span, String)> {\n     // Expect our local to be a reference to a struct of some kind.\n-    if let ty::Ref(_, ty, _) = ty.sty {\n-        if let ty::Adt(def, _) = ty.sty {\n+    if let ty::Ref(_, ty, _) = ty.kind {\n+        if let ty::Adt(def, _) = ty.kind {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n             let hir_id = tcx.hir().as_local_hir_id(field.did)?;"}, {"sha": "ff4243df6e9b869cd9bd648de705c68fe040ff7f", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -95,7 +95,7 @@ impl BorrowExplanation {\n                 should_note_order,\n             } => {\n                 let local_decl = &body.local_decls[dropped_local];\n-                let (dtor_desc, type_desc) = match local_decl.ty.sty {\n+                let (dtor_desc, type_desc) = match local_decl.ty.kind {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => (\n@@ -612,7 +612,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n                                 // Check the type for a trait object.\n-                                return match ty.sty {\n+                                return match ty.kind {\n                                     // `&dyn Trait`\n                                     ty::Ref(_, ty, _) if ty.is_trait() => true,\n                                     // `Box<dyn Trait>`"}, {"sha": "e29e9232012bc52f8e67b82f9b660657a03c159b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n             if let Some(ty::TyS {\n-                sty: ty::Opaque(did, substs),\n+                kind: ty::Opaque(did, substs),\n                 ..\n             }) = infcx\n                 .tcx"}, {"sha": "ff77083a34dfa3e06be9b1f0824360d34860a21e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -527,7 +527,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n-            match (&ty.sty, &hir_ty.node) {\n+            match (&ty.kind, &hir_ty.node) {\n                 // Check if the `argument_ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:"}, {"sha": "eadc58cc80027185683a0f043867dfb692cf1692", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     );\n                 }\n             }\n-            if let ty::FnDef(def_id, substs) = constant.literal.ty.sty {\n+            if let ty::FnDef(def_id, substs) = constant.literal.ty.kind {\n                 let tcx = self.tcx();\n \n                 let instantiated_predicates = tcx\n@@ -342,7 +342,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             let ty = if !local_decl.is_nonref_binding() {\n                 // If we have a binding of the form `let ref x: T = ..` then remove the outermost\n                 // reference so we can check the type annotation for the remaining type.\n-                if let ty::Ref(_, rty, _) = local_decl.ty.sty {\n+                if let ty::Ref(_, rty, _) = local_decl.ty.kind {\n                     rty\n                 } else {\n                     bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n@@ -424,15 +424,15 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         let mut place_ty = match &place.base {\n             PlaceBase::Local(index) =>\n                 PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-            PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n-                let sty = self.sanitize_type(place, sty);\n+            PlaceBase::Static(box Static { kind, ty, def_id }) => {\n+                let san_ty = self.sanitize_type(place, ty);\n                 let check_err =\n                     |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n                      place: &Place<'tcx>,\n                      ty,\n-                     sty| {\n+                     san_ty| {\n                         if let Err(terr) = verifier.cx.eq_types(\n-                            sty,\n+                            san_ty,\n                             ty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n@@ -442,7 +442,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                             place,\n                             \"bad promoted type ({:?}: {:?}): {:?}\",\n                             ty,\n-                            sty,\n+                            san_ty,\n                             terr\n                         );\n                         };\n@@ -454,17 +454,17 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                             self.sanitize_promoted(promoted_body, location);\n \n                             let promoted_ty = promoted_body.return_ty();\n-                            check_err(self, place, promoted_ty, sty);\n+                            check_err(self, place, promoted_ty, san_ty);\n                         }\n                     }\n                     StaticKind::Static => {\n                         let ty = self.tcx().type_of(*def_id);\n                         let ty = self.cx.normalize(ty, location);\n \n-                        check_err(self, place, ty, sty);\n+                        check_err(self, place, ty, san_ty);\n                     }\n                 }\n-                PlaceTy::from_ty(sty)\n+                PlaceTy::from_ty(san_ty)\n             }\n         };\n \n@@ -637,7 +637,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 )\n             }\n             ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n-                match base_ty.sty {\n+                match base_ty.kind {\n                     ty::Array(inner, size) => {\n                         let size = size.eval_usize(tcx, self.cx.param_env);\n                         let min_size = (from as u64) + (to as u64);\n@@ -656,7 +656,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             ),\n-            ProjectionElem::Downcast(maybe_name, index) => match base_ty.sty {\n+            ProjectionElem::Downcast(maybe_name, index) => match base_ty.kind {\n                 ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n                         PlaceTy::from_ty(\n@@ -738,7 +738,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy { ty, variant_index: Some(variant_index) } => match ty.sty {\n+            PlaceTy { ty, variant_index: Some(variant_index) } => match ty.kind {\n                 ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n                 ty::Generator(def_id, substs, _) => {\n                     let mut variants = substs.state_tys(def_id, tcx);\n@@ -759,7 +759,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 _ => bug!(\"can't have downcast of non-adt non-generator type\"),\n             }\n-            PlaceTy { ty, variant_index: None } => match ty.sty {\n+            PlaceTy { ty, variant_index: None } => match ty.kind {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n                     (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n@@ -1142,7 +1142,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n         if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n-            if let ty::Opaque(..) = sup.sty {\n+            if let ty::Opaque(..) = sup.kind {\n                 // When you have `let x: impl Foo = ...` in a closure,\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n@@ -1430,7 +1430,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 variant_index,\n             } => {\n                 let place_type = place.ty(body, tcx).ty;\n-                let adt = match place_type.sty {\n+                let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n@@ -1559,7 +1559,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             } => {\n                 let func_ty = func.ty(body, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n-                let sig = match func_ty.sty {\n+                let sig = match func_ty.kind {\n                     ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n@@ -2056,7 +2056,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(body, tcx).sty {\n+                        let sig = match op.ty(body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2125,7 +2125,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body, tcx).sty {\n+                        let ty_from = match op.ty(body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::MutMutable,\n@@ -2140,7 +2140,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 return;\n                             }\n                         };\n-                        let ty_to = match ty.sty {\n+                        let ty_to = match ty.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n                                 mutbl: hir::MutImmutable,\n@@ -2173,11 +2173,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        if let ty::Ref(_, mut ty_from, _) = op.ty(body, tcx).sty {\n+                        if let ty::Ref(_, mut ty_from, _) = op.ty(body, tcx).kind {\n                             let (mut ty_to, mutability) = if let ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n                                 mutbl,\n-                            }) = ty.sty {\n+                            }) = ty.kind {\n                                 (ty_to, mutbl)\n                             } else {\n                                 span_mirbug!(\n@@ -2192,9 +2192,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                             // Handle the direct cast from `&[T; N]` to `*const T` by unwrapping\n                             // any array we find.\n-                            while let ty::Array(ty_elem_from, _) = ty_from.sty {\n+                            while let ty::Array(ty_elem_from, _) = ty_from.kind {\n                                 ty_from = ty_elem_from;\n-                                if let ty::Array(ty_elem_to, _) = ty_to.sty {\n+                                if let ty::Array(ty_elem_to, _) = ty_to.kind {\n                                     ty_to = ty_elem_to;\n                                 } else {\n                                     break;\n@@ -2250,7 +2250,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n                 let ty_left = left.ty(body, tcx);\n-                if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n                     let ty_right = right.ty(body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n@@ -2431,7 +2431,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n-                    match base_ty.sty {\n+                    match base_ty.kind {\n                         ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),"}, {"sha": "b5af97a2217e810009af604d74992ef96e21a4e3", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -486,7 +486,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let defining_ty = self.infcx\n                     .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n \n-                match defining_ty.sty {\n+                match defining_ty.kind {\n                     ty::Closure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n                     ty::Generator(def_id, substs, movability) => {\n                         DefiningTy::Generator(def_id, substs, movability)\n@@ -573,7 +573,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         // flattens this tuple.\n                         let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n                         assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                        let inputs = match tuplized_inputs[0].sty {\n+                        let inputs = match tuplized_inputs[0].kind {\n                             ty::Tuple(inputs) => inputs,\n                             _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n                         };"}, {"sha": "f437c7172966becd6988f36991b810253b9ea999", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.sty {\n+                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.kind {\n                     // For both derefs of raw pointers and `&T`\n                     // references, the original path is `Copy` and\n                     // therefore not significant.  In particular,"}, {"sha": "9dd3e119c217a1d6db1a3616f1f24fc0dc6746b7", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -231,7 +231,7 @@ fn place_components_conflict<'tcx>(\n             let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n             let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n \n-            match (elem, &base_ty.sty, access) {\n+            match (elem, &base_ty.kind, access) {\n                 (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n                 | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n                     // The array length is like  additional fields on the\n@@ -349,7 +349,7 @@ fn place_base_conflict<'tcx>(\n                 },\n                 (StaticKind::Promoted(promoted_1, _), StaticKind::Promoted(promoted_2, _)) => {\n                     if promoted_1 == promoted_2 {\n-                        if let ty::Array(_, len) = s1.ty.sty {\n+                        if let ty::Array(_, len) = s1.ty.kind {\n                             if let Some(0) = len.try_eval_usize(tcx, param_env) {\n                                 // Ignore conflicts with promoted [T; 0].\n                                 debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n@@ -404,7 +404,7 @@ fn place_projection_conflict<'tcx>(\n                 Overlap::EqualOrDisjoint\n             } else {\n                 let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck.\n                         debug!(\"place_element_conflict: STUCK-UNION\");"}, {"sha": "a46a1cc5647a9e597988d78254fba7e9ab39de69", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -144,7 +144,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // reference.\n \n                     let ty = Place::ty_from(cursor.base, proj_base, self.body, self.tcx).ty;\n-                    match ty.sty {\n+                    match ty.kind {\n                         ty::RawPtr(_) |\n                         ty::Ref(\n                             _, /*rgn*/"}, {"sha": "8a6bc5a2a764e961986e7bccd6878ce13341c328", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args, from_hir_call } => {\n-                let intrinsic = match ty.sty {\n+                let intrinsic = match ty.kind {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "224b1a2b4efeec592be7102769bc16cbe4fc003d", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatternKind::Range(PatternRange { lo, hi, end }) => {\n-                let (range, bias) = match lo.ty.sty {\n+                let (range, bias) = match lo.ty.kind {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }"}, {"sha": "03f9e4ccc970bb49fcf1bb7887428a0f90d94b66", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n                 let target_blocks = make_target_blocks(self);\n-                let terminator = if switch_ty.sty == ty::Bool {\n+                let terminator = if switch_ty.kind == ty::Bool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     if let [first_bb, second_bb] = *target_blocks {\n                         let (true_bb, false_bb) = match options[0] {\n@@ -400,8 +400,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // We want to do this even when the scrutinee is a reference to an\n         // array, so we can call `<[u8]>::eq` rather than having to find an\n         // `<[u8; N]>::eq`.\n-        let unsize = |ty: Ty<'tcx>| match ty.sty {\n-            ty::Ref(region, rty, _) => match rty.sty {\n+        let unsize = |ty: Ty<'tcx>| match ty.kind {\n+            ty::Ref(region, rty, _) => match rty.kind {\n                 ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n                 _ => None,\n             },\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             },\n         }\n \n-        let deref_ty = match ty.sty {\n+        let deref_ty = match ty.kind {\n             ty::Ref(_, deref_ty, _) => deref_ty,\n             _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };"}, {"sha": "b0572df9d0853b38982fe4f620e03e35cfb04aab", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -73,7 +73,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n-            let implicit_argument = match ty.sty {\n+            let implicit_argument = match ty.kind {\n                 ty::Closure(..) => {\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n@@ -127,7 +127,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n-                let gen_sig = match ty.sty {\n+                let gen_sig = match ty.kind {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n@@ -178,7 +178,7 @@ fn liberated_closure_env_ty(\n ) -> Ty<'_> {\n     let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n \n-    let (closure_def_id, closure_substs) = match closure_ty.sty {\n+    let (closure_def_id, closure_substs) = match closure_ty.kind {\n         ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n     };"}, {"sha": "ca238867421aba7d8c5e4602f0f30425215898ce", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -63,8 +63,8 @@ fn op_to_const<'tcx>(\n     // `Undef` situation.\n     let try_as_immediate = match op.layout.abi {\n         layout::Abi::Scalar(..) => true,\n-        layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n-            ty::Ref(_, inner, _) => match inner.sty {\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n+            ty::Ref(_, inner, _) => match inner.kind {\n                 ty::Slice(elem) => elem == ecx.tcx.types.u8,\n                 ty::Str => true,\n                 _ => false,\n@@ -608,7 +608,7 @@ pub fn const_eval_provider<'tcx>(\n     // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n     if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n         let ty = key.value.instance.ty(tcx);\n-        let substs = match ty.sty {\n+        let substs = match ty.kind {\n             ty::FnDef(_, substs) => substs,\n             _ => bug!(\"intrinsic with type {:?}\", ty),\n         };"}, {"sha": "51b717b69e9c1ab383a995874e39c96adbcfa44d", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -50,7 +50,7 @@ fn place_contents_drop_state_cannot_differ<'tcx>(\n     place: &mir::Place<'tcx>,\n ) -> bool {\n     let ty = place.ty(body, tcx).ty;\n-    match ty.sty {\n+    match ty.kind {\n         ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n                    place, ty);"}, {"sha": "d9119253cae5fe833273f08e0d19f4d77e8e3f21", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -106,7 +106,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             let body = self.builder.body;\n             let tcx = self.builder.tcx;\n             let place_ty = Place::ty_from(&place.base, proj_base, body, tcx).ty;\n-            match place_ty.sty {\n+            match place_ty.kind {\n                 ty::Ref(..) | ty::RawPtr(..) => {\n                     let proj = &place.projection[..i+1];\n                     return Err(MoveError::cannot_move_out_of(\n@@ -438,7 +438,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // of the union so it is marked as initialized again.\n         if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n-                Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.sty\n+                Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.kind\n             {\n                 if def.is_union() {\n                     place = PlaceRef { base: place.base, projection: proj_base }"}, {"sha": "956716f8ceaf7c74b85242d80bca346e27f9d185", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -49,7 +49,7 @@ crate fn lit_to_const<'tcx>(\n             parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n         }\n         LitKind::FloatUnsuffixed(n) => {\n-            let fty = match ty.sty {\n+            let fty = match ty.kind {\n                 ty::Float(fty) => fty,\n                 _ => bug!()\n             };"}, {"sha": "a24b14598eb5908a2113af9f6961b037d1e4fe23", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -442,7 +442,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n-            match expr_ty.sty {\n+            match expr_ty.kind {\n                 ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n@@ -505,7 +505,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n-            let (def_id, substs, movability) = match closure_ty.sty {\n+            let (def_id, substs, movability) = match closure_ty.kind {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n                 ty::Generator(def_id, substs, movability) => {\n                     (def_id, UpvarSubsts::Generator(substs), Some(movability))\n@@ -938,7 +938,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             let ty = cx.tables().node_type(expr.hir_id);\n-            match ty.sty {\n+            match ty.kind {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::Adt(adt_def, substs) => {\n@@ -1001,7 +1001,7 @@ fn convert_var(\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.sty {\n+            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind {\n                 match cx.infcx.closure_kind(closure_def_id, closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n@@ -1147,7 +1147,7 @@ fn overloaded_place<'a, 'tcx>(\n     // Reconstruct the output assuming it's a reference with the\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mutbl) = match recv_ty.sty {\n+    let (region, mutbl) = match recv_ty.kind {\n         ty::Ref(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };"}, {"sha": "e570ace8df1d28ff5897c1bb82121b9afeeea2c8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -213,7 +213,7 @@ impl LiteralExpander<'tcx> {\n         crty: Ty<'tcx>,\n     ) -> ConstValue<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.sty, &rty.sty) {\n+        match (val, &crty.kind, &rty.kind) {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n                 let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n@@ -244,13 +244,13 @@ impl LiteralExpander<'tcx> {\n \n impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n-        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.sty, pat.kind);\n-        match (&pat.ty.sty, &*pat.kind) {\n+        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind, pat.kind);\n+        match (&pat.ty.kind, &*pat.kind) {\n             (\n                 &ty::Ref(_, rty, _),\n                 &PatternKind::Constant { value: Const {\n                     val,\n-                    ty: ty::TyS { sty: ty::Ref(_, crty, _), .. },\n+                    ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n                 } },\n             ) => {\n                 Pattern {\n@@ -406,14 +406,14 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n             _ => false,\n         }\n     }\n \n     fn is_local(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n             _ => false,\n         }\n@@ -565,7 +565,7 @@ impl<'tcx> Witness<'tcx> {\n             let len = self.0.len() as u64;\n             let mut pats = self.0.drain((len - arity) as usize..).rev();\n \n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(..) |\n                 ty::Tuple(..) => {\n                     let pats = pats.enumerate().map(|(i, p)| {\n@@ -575,7 +575,7 @@ impl<'tcx> Witness<'tcx> {\n                         }\n                     }).collect();\n \n-                    if let ty::Adt(adt, substs) = ty.sty {\n+                    if let ty::Adt(adt, substs) = ty.kind {\n                         if adt.is_enum() {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n@@ -639,7 +639,7 @@ fn all_constructors<'a, 'tcx>(\n     pcx: PatternContext<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    let ctors = match pcx.ty.sty {\n+    let ctors = match pcx.ty.kind {\n         ty::Bool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n@@ -785,7 +785,7 @@ where\n         match *row.kind {\n             PatternKind::Constant { value } => {\n                 // extract the length of an array/slice from a constant\n-                match (value.val, &value.ty.sty) {\n+                match (value.val, &value.ty.kind) {\n                     (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n                         max_fixed_len,\n                         n.eval_usize(cx.tcx, cx.param_env),\n@@ -837,7 +837,7 @@ impl<'tcx> IntRange<'tcx> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         fn is_integral(ty: Ty<'_>) -> bool {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Char | ty::Int(_) | ty::Uint(_) => true,\n                 _ => false,\n             }\n@@ -896,7 +896,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n@@ -1345,7 +1345,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                 lo.ty,\n                 end,\n             )]),\n-        PatternKind::Array { .. } => match pcx.ty.sty {\n+        PatternKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n                 Slice(length.eval_usize(cx.tcx, cx.param_env))\n             ]),\n@@ -1372,7 +1372,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n /// A struct pattern's arity is the number of fields it contains, etc.\n fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n-    match ty.sty {\n+    match ty.kind {\n         ty::Tuple(ref fs) => fs.len() as u64,\n         ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n@@ -1397,7 +1397,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Vec<Ty<'tcx>> {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n-    match ty.sty {\n+    match ty.kind {\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n@@ -1415,7 +1415,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n                     if is_visible {\n                         let ty = field.ty(cx.tcx, substs);\n-                        match ty.sty {\n+                        match ty.kind {\n                             // If the field type returned is an array of an unknown\n                             // size return an TyErr.\n                             ty::Array(_, len)\n@@ -1451,7 +1451,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>],\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, ErrorReported> {\n-    let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n+    let data: &[u8] = match (const_val.val, &const_val.ty.kind) {\n         (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let n = n.eval_usize(tcx, param_env);\n@@ -1503,7 +1503,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n         ConstantRange(_, _, ty, _) => ty,\n         _ => return false,\n     };\n-    if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n+    if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.kind {\n         !ty.is_ptr_sized_integral() || tcx.features().precise_pointer_size_matching\n     } else {\n         false\n@@ -1775,7 +1775,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (alloc, offset, n, ty) = match value.ty.sty {\n+                    let (alloc, offset, n, ty) = match value.ty.kind {\n                         ty::Array(t, n) => {\n                             match value.val {\n                                 ConstValue::ByRef { offset, alloc, .. } => ("}, {"sha": "3791ae1c41e4a659487df36d9d66fc7a26a57398", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -186,7 +186,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n-                    match pat_ty.sty {\n+                    match pat_ty.kind {\n                         ty::Never => true,\n                         ty::Adt(def, _) => {\n                             def_span = self.tcx.hir().span_if_local(def.did);\n@@ -293,7 +293,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                     return true;\n                 }\n                 let pat_ty = cx.tables.pat_ty(p);\n-                if let ty::Adt(edef, _) = pat_ty.sty {\n+                if let ty::Adt(edef, _) = pat_ty.kind {\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n                         variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                     }) {\n@@ -487,7 +487,7 @@ fn adt_defined_here(\n     witnesses: &[Pattern<'_>],\n ) {\n     let ty = ty.peel_refs();\n-    if let ty::Adt(def, _) = ty.sty {\n+    if let ty::Adt(def, _) = ty.kind {\n         if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n             err.span_label(sp, format!(\"`{}` defined here\", ty));\n         }\n@@ -502,7 +502,7 @@ fn adt_defined_here(\n \n fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n-    if let ty::Adt(def, _) = ty.sty {\n+    if let ty::Adt(def, _) = ty.kind {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {"}, {"sha": "162251bf76e7f90c3d69c1b671b5ebda5557ca86", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -231,7 +231,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     PatternKind::Variant { adt_def, variant_index, .. } => {\n                         Some(&adt_def.variants[variant_index])\n                     }\n-                    _ => if let ty::Adt(adt, _) = self.ty.sty {\n+                    _ => if let ty::Adt(adt, _) = self.ty.kind {\n                         if !adt.is_enum() {\n                             Some(&adt.variants[VariantIdx::new(0)])\n                         } else {\n@@ -295,7 +295,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 Ok(())\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                match self.ty.sty {\n+                match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n                         write!(f, \"&\")?;\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Ref(_, ty, _) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n@@ -573,7 +573,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Tuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n@@ -595,7 +595,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_type(pat.hir_id);\n-                if let ty::Error = var_ty.sty {\n+                if let ty::Error = var_ty.kind {\n                     // Avoid ICE\n                     return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                 };\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::Ref(_, rty, _) = ty.sty {\n+                    if let ty::Ref(_, rty, _) = ty.kind {\n                         ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let adt_def = match ty.sty {\n+                let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n                     ty::Error => { // Avoid ICE (#50585)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n@@ -747,7 +747,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let (prefix, slice, suffix) =\n             self.flatten_nested_slice_patterns(prefix, slice, suffix);\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Slice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n@@ -787,7 +787,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n-                    let substs = match ty.sty {\n+                    let substs = match ty.kind {\n                         ty::Adt(_, substs) |\n                         ty::FnDef(_, substs) => substs,\n                         ty::Error => {  // Avoid ICE (#50585)\n@@ -1077,7 +1077,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n \n-        let kind = match cv.ty.sty {\n+        let kind = match cv.ty.kind {\n             ty::Float(_) => {\n                 self.tcx.lint_hir(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n@@ -1109,7 +1109,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n+            ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n             if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n                 // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n@@ -1224,7 +1224,7 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n             debug!(\"Search visiting ty: {:?}\", ty);\n \n-            let (adt_def, substs) = match ty.sty {\n+            let (adt_def, substs) = match ty.kind {\n                 ty::Adt(adt_def, substs) => (adt_def, substs),\n                 ty::RawPtr(..) => {\n                     // `#[structural_match]` ignores substructure of\n@@ -1501,7 +1501,7 @@ pub fn compare_const_vals<'tcx>(\n \n     if let (Some(a), Some(b)) = (a_bits, b_bits) {\n         use ::rustc_apfloat::Float;\n-        return match ty.sty {\n+        return match ty.kind {\n             ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1524,7 +1524,7 @@ pub fn compare_const_vals<'tcx>(\n         }\n     }\n \n-    if let ty::Str = ty.sty {\n+    if let ty::Str = ty.kind {\n         match (a.val, b.val) {\n             (\n                 ConstValue::Slice { data: alloc_a, start: offset_a, end: end_a },"}, {"sha": "d63541f7a3f56d3a0288c4ab94ed1294ac14f614", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -17,7 +17,7 @@ crate trait UserAnnotatedTyHelpers<'tcx> {\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         let ty = self.tables().node_type(hir_id);\n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n                     *did = adt_def.did;"}, {"sha": "d120412c901a692d3d3d8c8bf026ea27c73ce9c9", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -34,7 +34,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::ReifyFnPointer) => {\n                 // The src operand does not matter, just its type\n-                match src.layout.ty.sty {\n+                match src.layout.ty.kind {\n                     ty::FnDef(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n                         if src.layout.ty.needs_subst() {\n@@ -54,7 +54,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::UnsafeFnPointer) => {\n                 let src = self.read_immediate(src)?;\n-                match dest.layout.ty.sty {\n+                match dest.layout.ty.kind {\n                     ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n@@ -65,7 +65,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::ClosureFnPointer(_)) => {\n                 // The src operand does not matter, just its type\n-                match src.layout.ty.sty {\n+                match src.layout.ty.kind {\n                     ty::Closure(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n                         if src.layout.ty.needs_subst() {\n@@ -97,7 +97,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n \n-        match src.layout.ty.sty {\n+        match src.layout.ty.kind {\n             // Floating point\n             Float(FloatTy::F32) =>\n                 return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?.into()),\n@@ -176,7 +176,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n         use rustc::ty::TyKind::*;\n-        match dest_layout.ty.sty {\n+        match dest_layout.ty.kind {\n             Int(_) | Uint(_) | RawPtr(_) => {\n                 let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::from_uint(v, dest_layout.size))\n@@ -214,7 +214,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     where F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>\n     {\n         use rustc::ty::TyKind::*;\n-        match dest_ty.sty {\n+        match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n@@ -244,14 +244,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n-        sty: Ty<'tcx>,\n-        dty: Ty<'tcx>,\n+        source_ty: Ty<'tcx>,\n+        dest_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n         let (src_pointee_ty, dest_pointee_ty) =\n-            self.tcx.struct_lockstep_tails_erasing_lifetimes(sty, dty, self.param_env);\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, dest_ty, self.param_env);\n \n-        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+        match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n                 // u64 cast is from usize to u64, which is always good\n@@ -287,7 +287,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} into {:?}\", src, dest);\n-        match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n+        match (&src.layout.ty.kind, &dest.layout.ty.kind) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |\n             (&ty::Ref(_, s, _), &ty::RawPtr(TypeAndMut { ty: d, .. })) |\n             (&ty::RawPtr(TypeAndMut { ty: s, .. }),"}, {"sha": "fdf85260c3d961273e0079ad5e9994f3e993ae11", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -387,7 +387,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n         }\n-        match layout.ty.sty {\n+        match layout.ty.kind {\n             ty::Adt(..) | ty::Tuple(..) => {\n                 // First get the size of all statically known fields.\n                 // Don't use type_of::sizing_type_of because that expects t to be sized,"}, {"sha": "ec06b6298e11229e14593474c6ffd089fb2f6800", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -192,13 +192,13 @@ for\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let ty = mplace.layout.ty;\n-        if let ty::Ref(_, referenced_ty, mutability) = ty.sty {\n+        if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n                 if let ty::Dynamic(..) =\n                     self.ecx.tcx.struct_tail_erasing_lifetimes(\n-                        referenced_ty, self.ecx.param_env).sty\n+                        referenced_ty, self.ecx.param_env).kind\n                 {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n@@ -228,7 +228,7 @@ for\n                     // we statically prevent `&mut T` via `const_qualif` and double check this here\n                     (InternMode::ConstBase, hir::Mutability::MutMutable) |\n                     (InternMode::Const, hir::Mutability::MutMutable) => {\n-                        match referenced_ty.sty {\n+                        match referenced_ty.kind {\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)"}, {"sha": "a6b3b4e0ff67d8efa0882a42ddbdd9582f2780e0", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        match ty.sty {\n+        match ty.kind {\n             // Types without identity.\n             | ty::Bool\n             | ty::Char"}, {"sha": "f5d1ec3eb755613e0025af0000cc9b9b7581243a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -664,7 +664,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     bits_discr\n                 };\n                 // Make sure we catch invalid discriminants\n-                let index = match &rval.layout.ty.sty {\n+                let index = match &rval.layout.ty.kind {\n                     ty::Adt(adt, _) => adt\n                         .discriminants(self.tcx.tcx)\n                         .find(|(_, var)| var.val == real_discr),"}, {"sha": "176b084f22587c7d27dc5baa51313bb16e2675c6", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -274,7 +274,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n-        match left.layout.ty.sty {\n+        match left.layout.ty.kind {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n                 let left = left.to_scalar()?;\n@@ -348,7 +348,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let val = val.to_scalar()?;\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n-        match layout.ty.sty {\n+        match layout.ty.kind {\n             ty::Bool => {\n                 let val = val.to_bool()?;\n                 let res = match un_op {"}, {"sha": "2f1b35757fe9c3cca89041d379687223367ba053", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -193,7 +193,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub(super) fn len(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n-            match self.layout.ty.sty {\n+            match self.layout.ty.kind {\n                 ty::Slice(..) | ty::Str =>\n                     return self.mplace.meta.unwrap().to_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n@@ -210,7 +210,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n     #[inline]\n     pub(super) fn vtable(self) -> Scalar<Tag> {\n-        match self.layout.ty.sty {\n+        match self.layout.ty.kind {\n             ty::Dynamic(..) => self.mplace.meta.unwrap(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n@@ -459,7 +459,7 @@ where\n \n         // Compute meta and new layout\n         let inner_len = len - to - from;\n-        let (meta, ty) = match base.layout.ty.sty {\n+        let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n             ty::Array(inner, _) =>"}, {"sha": "ef6b7d626e7a456a4819263355a21137cd683211", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -75,7 +75,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi) = match func.layout.ty.sty {\n+                let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(func)?.not_undef()?;\n@@ -272,7 +272,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 {\n                     let callee_abi = {\n                         let instance_ty = instance.ty(*self.tcx);\n-                        match instance_ty.sty {\n+                        match instance_ty.kind {\n                             ty::FnDef(..) =>\n                                 instance_ty.fn_sig(*self.tcx).abi(),\n                             ty::Closure(..) => Abi::RustCall,\n@@ -479,7 +479,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n-        let (instance, place) = match place.layout.ty.sty {\n+        let (instance, place) = match place.layout.ty.kind {\n             ty::Dynamic(..) => {\n                 // Dropping a trait object.\n                 self.unpack_dyn_trait(place)?"}, {"sha": "e6fa833c7b25bd77dbe7aa73493ed8a44683e5c3", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -188,7 +188,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         layout: TyLayout<'tcx>,\n         field: usize,\n     ) -> PathElem {\n-        match layout.ty.sty {\n+        match layout.ty.kind {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let mut name = None;\n@@ -263,7 +263,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         pointee: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n-        match tail.sty {\n+        match tail.kind {\n             ty::Dynamic(..) => {\n                 let vtable = meta.unwrap();\n                 try_validation!(\n@@ -327,7 +327,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>\n     ) -> InterpResult<'tcx> {\n-        let name = match old_op.layout.ty.sty {\n+        let name = match old_op.layout.ty.kind {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n             // Generators also have variants\n             ty::Generator(..) => PathElem::GeneratorState(variant_id),\n@@ -362,7 +362,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         let value = self.ecx.read_immediate(value)?;\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n-        match ty.sty {\n+        match ty.kind {\n             ty::Bool => {\n                 let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_bool(),\n@@ -581,7 +581,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         op: OpTy<'tcx, M::PointerTag>,\n         fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n-        match op.layout.ty.sty {\n+        match op.layout.ty.kind {\n             ty::Str => {\n                 let mplace = op.assert_mem_place(); // strings are never immediate\n                 try_validation!(self.ecx.read_str(mplace),\n@@ -590,7 +590,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             ty::Array(tys, ..) | ty::Slice(tys) if {\n                 // This optimization applies only for integer and floating point types\n                 // (i.e., types that can hold arbitrary bytes).\n-                match tys.sty {\n+                match tys.kind {\n                     ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n                     _ => false,\n                 }"}, {"sha": "427f94f4fbb02c790e82d9b2cdaf8e8999e345dc", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -239,7 +239,7 @@ macro_rules! make_value_visitor {\n \n                 // Even for single variants, we might be able to get a more refined type:\n                 // If it is a trait object, switch to the actual type that was used to create it.\n-                match v.layout().ty.sty {\n+                match v.layout().ty.kind {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n                         let dest = v.to_op(self.ecx())?.assert_mem_place();"}, {"sha": "4f978051eaccdd8383bc8bde9bf8c9a47720d1a4", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -86,7 +86,7 @@ fn check_fn_for_unconditional_recursion(\n                 TerminatorKind::Call { ref func, .. } => {\n                     let func_ty = func.ty(body, tcx);\n \n-                    if let ty::FnDef(fn_def_id, substs) = func_ty.sty {\n+                    if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n                         let (call_fn_id, call_substs) =\n                             if let Some(instance) = Instance::resolve(tcx,\n                                                                         param_env,"}, {"sha": "d7a837e7ede667074f6eb4f2b43089f469f987a1", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -578,7 +578,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     ty::ParamEnv::reveal_all(),\n                     &source_ty,\n                 );\n-                match source_ty.sty {\n+                match source_ty.kind {\n                     ty::Closure(def_id, substs) => {\n                         let instance = Instance::resolve_closure(\n                             self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n@@ -712,7 +712,7 @@ fn visit_fn_use<'tcx>(\n     is_direct_call: bool,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let ty::FnDef(def_id, substs) = ty.sty {\n+    if let ty::FnDef(def_id, substs) = ty.kind {\n         let instance = ty::Instance::resolve(tcx,\n                                              ty::ParamEnv::reveal_all(),\n                                              def_id,\n@@ -874,7 +874,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n                 return false;\n             }\n             let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n-            match tail.sty {\n+            match tail.kind {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n                 _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n@@ -887,7 +887,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n         }\n     };\n \n-    match (&source_ty.sty, &target_ty.sty) {\n+    match (&source_ty.kind, &target_ty.kind) {\n         (&ty::Ref(_, a, _),\n          &ty::Ref(_, b, _)) |\n         (&ty::Ref(_, a, _),\n@@ -945,7 +945,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_bound_vars() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n-    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n+    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.kind {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_bound_vars());"}, {"sha": "f5eb07882fe3244d3c9566cc6c36afbed7411bae", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -167,7 +167,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n-    if let Some(&ty::TyS { sty: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n+    if let Some(&ty::TyS { kind: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n         let body = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n         return body.subst(tcx, substs.substs);\n     }\n@@ -311,7 +311,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let dest = Place::return_place();\n     let src = Place::from(Local::new(1+0)).deref();\n \n-    match self_ty.sty {\n+    match self_ty.kind {\n         _ if is_copy => builder.copy_shim(),\n         ty::Array(ty, len) => {\n             let len = len.eval_usize(tcx, param_env);\n@@ -857,7 +857,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         .expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.normalize_erasing_regions(param_env, sig);\n \n-    let (adt_def, substs) = match sig.output().sty {\n+    let (adt_def, substs) = match sig.output().kind {\n         ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n     };"}, {"sha": "b56a1b263fd6a62e08735f12bc9e90a975879675", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -37,7 +37,7 @@ fn is_stable(\n \n /// Determine whether this type may be a reference (or box), and thus needs retagging.\n fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n         ty::Float(_) | ty::Int(_) | ty::Uint(_) |"}, {"sha": "faec8c7cbe400f846f7f6d1d418112b78ef0ab68", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             // result of a comparison of addresses would differ between runtime and compile-time.\n             Rvalue::BinaryOp(_, ref lhs, _)\n             if self.const_context && self.tcx.features().const_compare_raw_pointers => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info: self.source_info,\n                         description: InternedString::intern(\"pointer operation\"),\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n             let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-            match base_ty.sty {\n+            match base_ty.kind {\n                 ty::RawPtr(..) => {\n                     self.require_unsafe(\"dereference of raw pointer\",\n                         \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                     let ty =\n                         Place::ty_from(&place.base, proj_base, &self.body.local_decls, self.tcx)\n                             .ty;\n-                    match ty.sty {\n+                    match ty.kind {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},\n                             _ => {"}, {"sha": "857757ada53b7dda66c70aa2daa89d51722fedee", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -372,15 +372,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let place = self.eval_place(&place, source_info)?;\n                 let mplace = place.try_as_mplace().ok()?;\n \n-                if let ty::Slice(_) = mplace.layout.ty.sty {\n+                if let ty::Slice(_) = mplace.layout.ty.kind {\n                     let len = mplace.meta.unwrap().to_usize(&self.ecx).unwrap();\n \n                     Some(ImmTy::from_uint(\n                         len,\n                         self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     ).into())\n                 } else {\n-                    trace!(\"not slice: {:?}\", mplace.layout.ty.sty);\n+                    trace!(\"not slice: {:?}\", mplace.layout.ty.kind);\n                     None\n                 }\n             },\n@@ -552,7 +552,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     ScalarMaybeUndef::Scalar(one),\n                     ScalarMaybeUndef::Scalar(two)\n                 ) => {\n-                    let ty = &value.layout.ty.sty;\n+                    let ty = &value.layout.ty.kind;\n                     if let ty::Tuple(substs) = ty {\n                         *rval = Rvalue::Aggregate(\n                             Box::new(AggregateKind::Tuple),"}, {"sha": "2b66e602370cca03153c8f6f2b5878384988b681", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -711,7 +711,7 @@ fn compute_layout<'tcx>(\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(upvars);\n-    let allowed = match interior.sty {\n+    let allowed = match interior.kind {\n         ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n     };\n@@ -1124,7 +1124,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let gen_ty = body.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n-        let (upvars, interior, discr_ty, movable) = match gen_ty.sty {\n+        let (upvars, interior, discr_ty, movable) = match gen_ty.kind {\n             ty::Generator(_, substs, movability) => {\n                 (substs.upvar_tys(def_id, tcx).collect(),\n                  substs.witness(def_id, tcx),"}, {"sha": "7f56c6f7986aa4afba53fd668553b5fde7be7bd2", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -177,7 +177,7 @@ impl Inliner<'tcx> {\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n-            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_body, self.tcx).sty {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_body, self.tcx).kind {\n                 let instance = Instance::resolve(self.tcx,\n                                                  param_env,\n                                                  callee_def_id,\n@@ -328,7 +328,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::FnDef(def_id, _) = f.literal.ty.sty {\n+                    if let ty::FnDef(def_id, _) = f.literal.ty.kind {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -546,7 +546,7 @@ impl Inliner<'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "6b609e25ec0424d675ef8ff0e451e1111d53cbef", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -102,7 +102,7 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n \n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-            if let ty::Array(_, len) = place_ty.sty {\n+            if let ty::Array(_, len) = place_ty.kind {\n                 let span = self.body.source_info(location).span;\n                 let constant = Constant { span, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);"}, {"sha": "abe2d2f4a549eb7100ae7d4d93f90fc2e0e519cf", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -294,7 +294,7 @@ trait Qualif {\n                 if let box [proj_base @ .., elem] = &place.projection {\n                     if ProjectionElem::Deref == *elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let ty::Ref(..) = base_ty.sty {\n+                        if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, PlaceRef {\n                                 base: &place.base,\n                                 projection: proj_base,\n@@ -365,11 +365,11 @@ impl Qualif for HasMutInterior {\n                     // is allowed right now, and only in functions.\n                     if cx.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.sty {\n+                        match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}\n                             _ => return true,\n                         }\n-                    } else if let ty::Array(_, len) = ty.sty {\n+                    } else if let ty::Array(_, len) = ty.kind {\n                         // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n                         match len.try_eval_usize(cx.tcx, cx.param_env) {\n@@ -500,7 +500,7 @@ impl Qualif for IsNotPromotable {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -526,7 +526,7 @@ impl Qualif for IsNotPromotable {\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n         let fn_ty = callee.ty(cx.body, cx.tcx);\n-        match fn_ty.sty {\n+        match fn_ty.kind {\n             ty::FnDef(def_id, _) => {\n                 match cx.tcx.fn_sig(def_id).abi() {\n                     Abi::RustIntrinsic |\n@@ -599,7 +599,7 @@ impl Qualif for IsNotImplicitlyPromotable {\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n         if cx.mode == Mode::NonConstFn {\n-            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).sty {\n+            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).kind {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n                 if !cx.tcx.is_promotable_const_fn(def_id) {\n@@ -1108,7 +1108,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     match self.mode {\n                         Mode::NonConstFn => {},\n                         _ => {\n-                            if let ty::RawPtr(_) = base_ty.sty {\n+                            if let ty::RawPtr(_) = base_ty.kind {\n                                 if !self.tcx.features().const_raw_ptr_deref {\n                                     emit_feature_err(\n                                         &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n@@ -1188,7 +1188,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             if let box [proj_base @ .., elem] = &place.projection {\n                 if *elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.sty {\n+                    if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n                     }\n                 }\n@@ -1257,7 +1257,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -1316,7 +1316,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             let fn_ty = func.ty(self.body, self.tcx);\n             let mut callee_def_id = None;\n             let mut is_shuffle = false;\n-            match fn_ty.sty {\n+            match fn_ty.kind {\n                 ty::FnDef(def_id, _) => {\n                     callee_def_id = Some(def_id);\n                     match self.tcx.fn_sig(def_id).abi() {"}, {"sha": "cf0ee1bf092223b03b61a98fe93608c1f80e6e5f", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -32,7 +32,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n-                    match pred.skip_binder().self_ty().sty {\n+                    match pred.skip_binder().self_ty().kind {\n                         ty::Param(ref p) => {\n                             let generics = tcx.generics_of(current);\n                             let def = generics.type_param(p, tcx);\n@@ -79,7 +79,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n \n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n                 span,\n                 \"mutable references in const fn are unstable\".into(),\n@@ -342,7 +342,7 @@ fn check_terminator(\n             cleanup: _,\n         } => {\n             let fn_ty = func.ty(body, tcx);\n-            if let ty::FnDef(def_id, _) = fn_ty.sty {\n+            if let ty::FnDef(def_id, _) = fn_ty.kind {\n \n                 // some intrinsics are waved through if called inside the\n                 // standard library. Users never need to call them directly"}, {"sha": "539645d0227f4b912b7eca1e3ce8265adf0de7ed", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -224,7 +224,7 @@ fn is_rustc_peek<'a, 'tcx>(\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.literal.ty.sty {\n+                if let ty::FnDef(def_id, _) = func.literal.ty.kind {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic && name == sym::rustc_peek {"}, {"sha": "eb61cd2f657a2a681930cf12412b4eaa75d1049e", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 } else {\n                     let place_ty =\n                         Place::ty_from(&src_place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Array(item_ty, const_size) = place_ty.sty {\n+                    if let ty::Array(item_ty, const_size) = place_ty.kind {\n                         if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n                             assert!(size <= u32::max_value() as u64,\n                                     \"uniform array move out doesn't supported\n@@ -224,7 +224,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty =\n                                 Place::ty_from(src_place.base, src_place.projection, body, tcx).ty;\n-                            if let ty::Array(_, ref size_o) = src_ty.sty {\n+                            if let ty::Array(_, ref size_o) = src_ty.kind {\n                                 size_o.try_eval_usize(tcx, param_env)\n                             } else {\n                                 None"}, {"sha": "1bad85ec42d08841f8c9c07534b0393863847232", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -47,7 +47,7 @@ where\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n                 let ty = Place::ty_from(&place.base, proj_base, local_decls, tcx).ty;\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n                     }"}, {"sha": "96ba829358280a5cef62c6716a82dabf8c2c97d8", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -324,7 +324,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         ty: Ty<'_>,\n         is_index: Option<bool>,\n     ) -> DiagnosticBuilder<'cx> {\n-        let type_name = match (&ty.sty, is_index) {\n+        let type_name = match (&ty.kind, is_index) {\n             (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n             (&ty::Slice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),"}, {"sha": "e1015edfa8eec791d2a7ea32b0857758b570731f", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -786,7 +786,7 @@ where\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n-        match ty.sty {\n+        match ty.kind {\n             ty::Closure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)"}, {"sha": "d4c3dc917e5e90ff36aac0da540d42dcfb6cd695", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -273,7 +273,7 @@ fn check_expr_kind<'a, 'tcx>(\n     v: &mut CheckCrateVisitor<'a, 'tcx>,\n     e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n \n-    let ty_result = match node_ty.sty {\n+    let ty_result = match node_ty.kind {\n         ty::Adt(def, _) if def.has_dtor(v.tcx) => {\n             NotPromotable\n         }\n@@ -298,7 +298,7 @@ fn check_expr_kind<'a, 'tcx>(\n             if v.tables.is_method_call(e) {\n                 return NotPromotable;\n             }\n-            match v.tables.node_type(lhs.hir_id).sty {\n+            match v.tables.node_type(lhs.hir_id).kind {\n                 ty::RawPtr(_) | ty::FnPtr(..) => {\n                     assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n                             op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n@@ -427,7 +427,7 @@ fn check_expr_kind<'a, 'tcx>(\n             if let Some(ref expr) = *option_expr {\n                 struct_result &= v.check_expr(&expr);\n             }\n-            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).sty {\n+            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).kind {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n                     return NotPromotable;"}, {"sha": "d7f5fdeb00c52b09b1a3b41a9b3e3b071748cd84", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -129,7 +129,7 @@ where\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`.\n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n             ty::Foreign(def_id) |\n             ty::FnDef(def_id, ..) |\n@@ -144,7 +144,7 @@ where\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n-                if let ty::FnDef(..) = ty.sty {\n+                if let ty::FnDef(..) = ty.kind {\n                     if tcx.fn_sig(def_id).visit_with(self) {\n                         return true;\n                     }"}, {"sha": "7b1a6a9765b80b18b25b0060c1347ff45966226f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -515,7 +515,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let expr_hir_id = self.tcx.hir().node_to_hir_id(expr.id);\n         let hir_node = self.tcx.hir().expect_expr(expr_hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || ty.unwrap().sty == ty::Error {\n+        if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n         match expr.node {\n@@ -532,7 +532,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tables.expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         let index = self.tcx.find_field_index(ident, variant).unwrap();\n@@ -552,7 +552,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tables.expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let sub_span = path.segments.last().unwrap().ident.span;\n                         filter!(self.span_utils, sub_span);"}, {"sha": "fe66b1932d5e88e4ec95168565b5d6513bf4cbc4", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -278,7 +278,7 @@ impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n                     }\n                     _ => false,\n                 },\n-                UnpackedKind::Type(ty) => match ty.sty {\n+                UnpackedKind::Type(ty) => match ty.kind {\n                     ty::Bound(debruijn, bound_ty) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == bound_ty.var"}, {"sha": "cc5ca3d92c9c1ae9d5b2d04b79171371908454ba", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -49,7 +49,7 @@ crate fn assemble_builtin_unsize_impls<'tcx>(\n     target: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>,\n ) {\n-    match (&source.sty, &target.sty) {\n+    match (&source.kind, &target.kind) {\n         (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n             if data_a.principal_def_id() != data_b.principal_def_id()\n                 || data_b.auto_traits().any(|b| data_a.auto_traits().all(|a| a != b))\n@@ -130,7 +130,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n     };\n \n-    match &ty.sty {\n+    match &ty.kind {\n         // Non parametric primitive types.\n         ty::Bool |\n         ty::Char |\n@@ -234,7 +234,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n     };\n \n-    match &ty.sty {\n+    match &ty.kind {\n         // Implementations provided in libcore.\n         ty::Bool |\n         ty::Char |\n@@ -264,7 +264,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         }\n         &ty::Closure(def_id, ..) => {\n             let closure_ty = generic_types::closure(tcx, def_id);\n-            let upvar_tys: Vec<_> = match &closure_ty.sty {\n+            let upvar_tys: Vec<_> = match &closure_ty.kind {\n                 ty::Closure(_, substs) => {\n                     substs.upvar_tys(def_id, tcx).map(|ty| Kind::from(ty)).collect()\n                 },"}, {"sha": "1b6a5902be69b0cc8e00e46997470a806895f83d", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -176,7 +176,7 @@ impl ChalkInferenceContext<'cx, 'tcx> {\n                 //   associated type (rule `WellFormed-AssocTy`)\n                 // * custom rules for built-in types\n                 // * the type definition otherwise (rule `WellFormed-Type`)\n-                let clauses = match ty.sty {\n+                let clauses = match ty.kind {\n                     ty::Projection(data) => {\n                         self.infcx.tcx.program_clauses_for(data.item_def_id)\n                     }"}, {"sha": "a871ad4b160e96c69202ee283e84b16ca5c5a558", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -212,15 +212,15 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         let b = self.infcx.shallow_resolve(b);\n         debug!(\"AnswerSubstitutor::tys(a = {:?}, b = {:?})\", a, b);\n \n-        if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n+        if let &ty::Bound(debruijn, bound_ty) = &a.kind {\n             // Free bound var\n             if debruijn == self.binder_index {\n                 self.unify_free_answer_var(bound_ty.var, b.into())?;\n                 return Ok(b);\n             }\n         }\n \n-        match (&a.sty, &b.sty) {\n+        match (&a.kind, &b.kind) {\n             (&ty::Bound(a_debruijn, a_bound), &ty::Bound(b_debruijn, b_bound)) => {\n                 assert_eq!(a_debruijn, b_debruijn);\n                 assert_eq!(a_bound.var, b_bound.var);"}, {"sha": "a36b381bed343210dd6514e69202f6607ec83200", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -105,7 +105,7 @@ fn dropck_outlives<'tcx>(\n \n                             debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n \n-                            match ty.sty {\n+                            match ty.kind {\n                                 // All parameters live for the duration of the\n                                 // function.\n                                 ty::Param(..) => {}\n@@ -166,7 +166,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         });\n     }\n \n-    let result = match ty.sty {\n+    let result = match ty.kind {\n         ty::Bool\n         | ty::Char\n         | ty::Int(_)"}, {"sha": "759eced1319819279453f6fd422cf99f8098f30e", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -25,7 +25,7 @@ impl ClauseVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Projection(data) => {\n                 self.round.extend(\n                     self.tcx.program_clauses_for(data.item_def_id)"}, {"sha": "2cd74281306f1ea892799d2567caed8986807463", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1608,7 +1608,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, _) = qself_ty.sty {\n+        if let ty::Adt(adt_def, _) = qself_ty.kind {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def.variants.iter().find(|vd| {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n@@ -1626,7 +1626,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n-        let bound = match (&qself_ty.sty, qself_res) {\n+        let bound = match (&qself_ty.kind, qself_res) {\n             (_, Res::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference."}, {"sha": "ab5cabcaa4f7f8397850ab47e7fa2f42e6e9c394", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n                 fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n                             Some(OverloadedDeref {\n                                 region,\n                                 mutbl,"}, {"sha": "e1f239d3d08ddf7f999474ff84d5deed95a06326", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // If the callee is a bare function or a closure, then we're all set.\n-        match adjusted_ty.sty {\n+        match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let adjustments = autoderef.adjust_steps(self, Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let (fn_sig, def_span) = match callee_ty.sty {\n+        let (fn_sig, def_span) = match callee_ty.kind {\n             ty::FnDef(def_id, _) => (\n                 callee_ty.fn_sig(self.tcx),\n                 self.tcx.hir().span_if_local(def_id),"}, {"sha": "dfeb5fb958cd8568e8d66d81000016a8e684af47", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n-        Ok(match t.sty {\n+        Ok(match t.kind {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, ..) =>\n                 Some(PointerKind::Vtable(tty.principal_def_id())),\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         // For better error messages, check for some obviously unsized\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n-        match cast_ty.sty {\n+        match cast_ty.kind {\n             ty::Dynamic(..) | ty::Slice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                          \"cast to unsized type: `{}` as `{}`\",\n                                          fcx.resolve_vars_if_possible(&self.expr_ty),\n                                          tstr);\n-        match self.expr_ty.sty {\n+        match self.expr_ty.kind {\n             ty::Ref(_, _, mt) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::FnDef(..) = self.expr_ty.sty {\n+                if let ty::FnDef(..) = self.expr_ty.kind {\n                     // Attempt a coercion to a fn pointer type.\n                     let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n             (RPtr(p), Int(_)) |\n             (RPtr(p), Float) => {\n-                match p.ty.sty {\n+                match p.ty.kind {\n                     ty::Int(_) |\n                     ty::Uint(_) |\n                     ty::Float(_) => {\n@@ -616,7 +616,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n-            if let ty::Array(ety, _) = m_expr.ty.sty {\n+            if let ty::Array(ety, _) = m_expr.ty.kind {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values."}, {"sha": "bdf8f3b1d4ae6e94d90c5f9bd6f73703fe810239", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expected_ty\n         );\n \n-        match expected_ty.sty {\n+        match expected_ty.kind {\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type\n                     .projection_bounds()\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n-            match arg_param_ty.sty {\n+            match arg_param_ty.kind {\n                 ty::Tuple(tys) => tys.into_iter().map(|k| k.expect_ty()).collect::<Vec<_>>(),\n                 _ => return None,\n             }"}, {"sha": "564a0eac7553977690c1f6acffb03b4fc227640c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -206,7 +206,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n-        match b.sty {\n+        match b.kind {\n             ty::RawPtr(mt_b) => {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n@@ -219,7 +219,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => {}\n         }\n \n-        match a.sty {\n+        match a.kind {\n             ty::FnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n@@ -264,7 +264,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let (r_a, mt_a) = match a.sty {\n+        let (r_a, mt_a) = match a.kind {\n             ty::Ref(r_a, ty, mutbl) => {\n                 let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n@@ -426,7 +426,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n-        let r_borrow = match ty.sty {\n+        let r_borrow = match ty.kind {\n             ty::Ref(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n@@ -470,7 +470,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // that, at which point we will need extra checks on the target here.\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n-        let reborrow = match (&source.sty, &target.sty) {\n+        let reborrow = match (&source.kind, &target.kind) {\n             (&ty::Ref(_, ty_a, mutbl_a), &ty::Ref(_, _, mutbl_b)) => {\n                 coerce_mutbls(mutbl_a, mutbl_b)?;\n \n@@ -566,15 +566,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n-                    if unsize_did == tr.def_id() {\n-                        let sty = &tr.skip_binder().input_types().nth(1).unwrap().sty;\n-                        if let ty::Tuple(..) = sty {\n+                ty::Predicate::Trait(ref t) if traits.contains(&t.def_id()) => {\n+                    if unsize_did == t.def_id() {\n+                        if let ty::Tuple(..) = &t.skip_binder().input_types().nth(1).unwrap().kind {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    tr.clone()\n+                    t.clone()\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);\n@@ -589,7 +588,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let self_ty = trait_ref.skip_binder().self_ty();\n                         let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);\n-                        match (&self_ty.sty, &unsize_ty.sty) {\n+                        match (&self_ty.kind, &unsize_ty.kind) {\n                             (ty::Infer(ty::TyVar(v)),\n                              ty::Dynamic(..)) if self.type_var_is_sized(*v) => {\n                                 debug!(\"coerce_unsized: have sized infer {:?}\", v);\n@@ -650,7 +649,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n               G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n-        if let ty::FnPtr(fn_ty_b) = b.sty {\n+        if let ty::FnPtr(fn_ty_b) = b.kind {\n             if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe)\n                 = (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n             {\n@@ -687,7 +686,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n-        match b.sty {\n+        match b.kind {\n             ty::FnPtr(_) => {\n                 let a_sig = a.fn_sig(self.tcx);\n                 // Intrinsics are not coercible to function pointers\n@@ -737,7 +736,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n \n-        match b.sty {\n+        match b.kind {\n             ty::FnPtr(fn_ty) if self.tcx.upvars(def_id_a).map_or(true, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n@@ -765,7 +764,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                          -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n-        let (is_ref, mt_a) = match a.sty {\n+        let (is_ref, mt_a) = match a.kind {\n             ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::RawPtr(mt) => (false, mt),\n             _ => return self.unify_and(a, b, identity)\n@@ -860,7 +859,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or InternalSubsts.\n-        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.kind, &new_ty.kind) {\n             // Don't reify if the function types have a LUB, i.e., they\n             // are the same function and their parameters have a LUB.\n             let lub_ty = self.commit_if_ok(|_| {\n@@ -929,7 +928,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     Adjustment { kind: Adjust::Deref(_), .. },\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n-                    match self.node_ty(expr.hir_id).sty {\n+                    match self.node_ty(expr.hir_id).kind {\n                         ty::Ref(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because"}, {"sha": "6c94f833196fbc0484933a62fc6f2ed2345acdba", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -150,7 +150,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n     ) {\n-        if let ty::Adt(expected_adt, substs) = expected.sty {\n+        if let ty::Adt(expected_adt, substs) = expected.kind {\n             if !expected_adt.is_enum() {\n                 return;\n             }\n@@ -351,8 +351,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // and make a good suggestion, so don't bother.\n         let is_macro = sp.from_expansion();\n \n-        match (&expr.node, &expected.sty, &checked_ty.sty) {\n-            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n+        match (&expr.node, &expected.kind, &checked_ty.kind) {\n+            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n                 (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n@@ -650,8 +650,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 \"{}{}{}{}\",\n                 if needs_paren { \"(\" } else { \"\" },\n                 if let (ty::Int(_), ty::Float(_)) | (ty::Uint(_), ty::Float(_)) = (\n-                    &expected_ty.sty,\n-                    &checked_ty.sty,\n+                    &expected_ty.kind,\n+                    &checked_ty.kind,\n                 ) {\n                     // Remove fractional part from literal, for example `42.0f32` into `42`\n                     let src = src.trim_end_matches(&checked_ty.to_string());\n@@ -695,7 +695,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             };\n \n-            match (&expected_ty.sty, &checked_ty.sty) {\n+            match (&expected_ty.kind, &checked_ty.kind) {\n                 (&ty::Int(ref exp), &ty::Int(ref found)) => {\n                     let is_fallible = match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => true,"}, {"sha": "a144e5938c3a8c586a267811bd3e5f9aed199a1a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Span;\n pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n-    match dtor_self_type.sty {\n+    match dtor_self_type.kind {\n         ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,"}, {"sha": "97fcfd7151a1c531c10b0030311f1ff5e92c189b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_box(&self, expr: &'tcx hir::Expr, expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(def, _) if def.is_box()\n                     => Expectation::rvalue_hint(self, ty.boxed_ty()),\n                 _ => NoExpectation\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     } else if let Some(ok) = self.try_overloaded_deref(\n                             expr.span, oprnd_t, needs) {\n                         let method = self.register_infer_ok_obligations(ok);\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                             let mutbl = match mutbl {\n                                 hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                 hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::UnNot => {\n                     let result = self.check_user_unop(expr, oprnd_t, unop);\n                     // If it's builtin, we can reuse the type, this helps inference.\n-                    if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n+                    if !(oprnd_t.is_integral() || oprnd_t.kind == ty::Bool) {\n                         oprnd_t = result;\n                     }\n                 }\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     if oprnd.is_place_expr() {\n                         // Places may legitimately have unsized types.\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n \n-        if let ty::FnDef(..) = ty.sty {\n+        if let ty::FnDef(..) = ty.kind {\n             let fn_sig = ty.fn_sig(tcx);\n             if !tcx.features().unsized_locals {\n                 // We want to remove some Sized bounds from std functions,\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     assert!(e_ty.is_unit());\n                     let ty = coerce.expected_ty();\n                     coerce.coerce_forced_unit(self, &cause, &mut |err| {\n-                        let val = match ty.sty {\n+                        let val = match ty.kind {\n                             ty::Bool => \"true\",\n                             ty::Char => \"'a'\",\n                             ty::Int(_) | ty::Uint(_) => \"42\",\n@@ -838,7 +838,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             error,\n             Some(args),\n         ) {\n-            if let ty::Adt(..) = rcvr_t.sty {\n+            if let ty::Adt(..) = rcvr_t.kind {\n                 // Try alternative arbitrary self types that could fulfill this call.\n                 // FIXME: probe for all types that *could* be arbitrary self-types, not\n                 // just this whitelist.\n@@ -889,7 +889,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr\n     ) -> Ty<'tcx> {\n         let uty = expected.to_option(self).and_then(|uty| {\n-            match uty.sty {\n+            match uty.kind {\n                 ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                 _ => None\n             }\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n-                match uty.sty {\n+                match uty.kind {\n                     ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                     _ => None\n                 }\n@@ -989,7 +989,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_type_vars_with_obligations(ty);\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Tuple(ref flds) => Some(&flds[..]),\n                 _ => None\n             }\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // when certain fields are assumed to exist that in fact do not.\n             if !error_happened {\n                 self.check_expr_has_type_or_error(base_expr, adt_ty);\n-                match adt_ty.sty {\n+                match adt_ty.kind {\n                     ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n@@ -1095,7 +1095,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n+        let (substs, adt_kind, kind_name) = match &adt_ty.kind {\n             &ty::Adt(adt, substs) => {\n                 (substs, adt.adt_kind(), adt.variant_descr())\n             }\n@@ -1217,7 +1217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let mut err = self.type_error_struct_with_diag(\n             field.ident.span,\n-            |actual| match ty.sty {\n+            |actual| match ty.kind {\n                 ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n                                      \"{} `{}::{}` has no field named `{}`\",\n@@ -1256,7 +1256,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    match ty.sty {\n+                    match ty.kind {\n                         ty::Adt(adt, ..) => {\n                             if adt.is_enum() {\n                                 err.span_label(field.ident.span, format!(\n@@ -1338,7 +1338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n-            match base_t.sty {\n+            match base_t.kind {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n@@ -1392,7 +1392,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if !expr_t.is_primitive_ty() {\n             let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n-            match expr_t.sty {\n+            match expr_t.kind {\n                 ty::Adt(def, _) if !def.is_enum() => {\n                     self.suggest_fields_on_recordish(&mut err, def, field);\n                 }\n@@ -1600,7 +1600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             \"cannot index into a value of type `{}`\",\n                                             base_t);\n                     // Try to give some advice about indexing tuples.\n-                    if let ty::Tuple(..) = base_t.sty {\n+                    if let ty::Tuple(..) = base_t.kind {\n                         let mut needs_note = true;\n                         // If the index is an integer, we can show the actual\n                         // fixed expression:"}, {"sha": "5d4893ae754837c4d5fba7fdaf32b02a86c51893", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -277,7 +277,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             .autoderef(self.span, self_ty)\n             .include_raw_pointers()\n             .filter_map(|(ty, _)|\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Dynamic(ref data, ..) => {\n                         Some(closure(self, ty, data.principal().unwrap_or_else(|| {\n                             span_bug!(self.span, \"calling trait method on empty object?\")\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n                         if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n                                 *deref = OverloadedDeref {\n                                     region,\n                                     mutbl,\n@@ -526,7 +526,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].sty {\n+        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n             (r, mutbl)\n         } else {\n             span_bug!(expr.span, \"input to place op is not a ref?\");\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 }\n             })\n             .any(|trait_pred| {\n-                match trait_pred.skip_binder().self_ty().sty {\n+                match trait_pred.skip_binder().self_ty().kind {\n                     ty::Dynamic(..) => true,\n                     _ => false,\n                 }"}, {"sha": "2be311127214d2b6c3b6fd804e4b15c63d079bd5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -410,7 +410,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // Check if we have an enum variant.\n-        if let ty::Adt(adt_def, _) = self_ty.sty {\n+        if let ty::Adt(adt_def, _) = self_ty.kind {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def.variants.iter().find(|vd| {\n                     tcx.hygienic_eq(method_name, vd.ident, adt_def.did)"}, {"sha": "593cf77a4a6c76890e32f384db1ab40d715bc8e6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -419,7 +419,7 @@ fn method_autoderef_steps<'tcx>(\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n                 };\n-                if let ty::RawPtr(_) = ty.sty {\n+                if let ty::RawPtr(_) = ty.kind {\n                     // all the subsequent steps will be from_unsafe_deref\n                     reached_raw_pointer = true;\n                 }\n@@ -428,7 +428,7 @@ fn method_autoderef_steps<'tcx>(\n             .collect();\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n-        let opt_bad_ty = match final_ty.sty {\n+        let opt_bad_ty = match final_ty.kind {\n             ty::Infer(ty::TyVar(_)) |\n             ty::Error => {\n                 Some(MethodAutoderefBadTy {\n@@ -541,7 +541,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n         let lang_items = self.tcx.lang_items();\n \n-        match self_ty.value.value.sty {\n+        match self_ty.value.value.kind {\n             ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n                     // Subtle: we can't use `instantiate_query_response` here: using it will\n@@ -735,7 +735,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n-        let principal = match self_ty.sty {\n+        let principal = match self_ty.kind {\n             ty::Dynamic(ref data, ..) => Some(data),\n             _ => None\n         }.and_then(|data| data.principal()).unwrap_or_else(|| {\n@@ -773,7 +773,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .filter_map(|predicate| {\n                 match *predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n-                        match trait_predicate.skip_binder().trait_ref.self_ty().sty {\n+                        match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n                             ty::Param(ref p) if *p == param_ty => {\n                                 Some(trait_predicate.to_poly_trait_ref())\n                             }\n@@ -1073,7 +1073,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::Ref(_, _, mutbl) = step.self_ty.value.value.sty {\n+                if let ty::Ref(_, _, mutbl) = step.self_ty.value.value.kind {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }"}, {"sha": "408532d1d1ee88f7fa6c821e7c4e7c8d50be74a2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -26,7 +26,7 @@ use super::probe::Mode;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let tcx = self.tcx;\n-        match ty.sty {\n+        match ty.kind {\n             // Not all of these (e.g., unsafe fns) implement `FnOnce`,\n             // so we look for these beforehand.\n             ty::Closure(..) |\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 );\n                             }\n                         }\n-                        if let ty::RawPtr(_) = &actual.sty {\n+                        if let ty::RawPtr(_) = &actual.kind {\n                             err.note(\"try using `<*const T>::as_ref()` to get a reference to the \\\n                                       type behind the pointer: https://doc.rust-lang.org/std/\\\n                                       primitive.pointer.html#method.as_ref\");\n@@ -372,7 +372,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let SelfSource::MethodCall(expr) = source {\n                     let field_receiver = self\n                         .autoderef(span, rcvr_ty)\n-                        .find_map(|(ty, _)| match ty.sty {\n+                        .find_map(|(ty, _)| match ty.kind {\n                             ty::Adt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n                                 self.tcx.find_field_index(item_name, variant).map(|index| {\n@@ -701,9 +701,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             candidates.sort_by(|a, b| a.cmp(b).reverse());\n             candidates.dedup();\n \n-            let param_type = match rcvr_ty.sty {\n+            let param_type = match rcvr_ty.kind {\n                 ty::Param(param) => Some(param),\n-                ty::Ref(_, ty, _) => match ty.sty {\n+                ty::Ref(_, ty, _) => match ty.kind {\n                     ty::Param(param) => Some(param),\n                     _ => None,\n                 }\n@@ -815,7 +815,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             rcvr_ty: Ty<'tcx>,\n                             source: SelfSource<'_>) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n "}, {"sha": "1d572c141211b9db4d5762ea15ae8bb49b0b6d2d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail_without_normalization(ty).sty {\n+        match fcx.tcx.struct_tail_without_normalization(ty).kind {\n             ty::Slice(_) | ty::Str | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n@@ -1230,7 +1230,7 @@ fn check_fn<'a, 'tcx>(\n                 // only happens if compilation succeeded\n                 fcx.tcx.sess.has_panic_handler.try_set_same(true);\n \n-                if declared_ret_ty.sty != ty::Never {\n+                if declared_ret_ty.kind != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1240,8 +1240,8 @@ fn check_fn<'a, 'tcx>(\n                 let inputs = fn_sig.inputs();\n                 let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n-                    let arg_is_panic_info = match inputs[0].sty {\n-                        ty::Ref(region, ty, mutbl) => match ty.sty {\n+                    let arg_is_panic_info = match inputs[0].kind {\n+                        ty::Ref(region, ty, mutbl) => match ty.kind {\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n                                     mutbl == hir::Mutability::MutImmutable &&\n@@ -1283,7 +1283,7 @@ fn check_fn<'a, 'tcx>(\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n         if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n-                if declared_ret_ty.sty != ty::Never {\n+                if declared_ret_ty.kind != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1293,7 +1293,7 @@ fn check_fn<'a, 'tcx>(\n                 let inputs = fn_sig.inputs();\n                 let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n-                    let arg_is_alloc_layout = match inputs[0].sty {\n+                    let arg_is_alloc_layout = match inputs[0].kind {\n                         ty::Adt(ref adt, _) => {\n                             adt.did == alloc_layout_did\n                         },\n@@ -1458,7 +1458,7 @@ fn check_opaque_for_cycles<'tcx>(\n                 \"opaque type expands to a recursive type\",\n             );\n             err.span_label(span, \"expands to a recursive type\");\n-            if let ty::Opaque(..) = partially_expanded_type.sty {\n+            if let ty::Opaque(..) = partially_expanded_type.kind {\n                 err.note(\"type resolves to itself\");\n             } else {\n                 err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n@@ -1884,7 +1884,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n-    if let ty::Adt(def, substs) = t.sty {\n+    if let ty::Adt(def, substs) = t.kind {\n         if def.is_struct() {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n@@ -1898,7 +1898,7 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n                                 .emit();\n                 return;\n             }\n-            match e.sty {\n+            match e.kind {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n                 _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n                 _ => {\n@@ -1945,7 +1945,7 @@ fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) ->\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n         return false;\n     }\n-    if let ty::Adt(def, substs) = t.sty {\n+    if let ty::Adt(def, substs) = t.kind {\n         if def.is_struct() || def.is_union() {\n             if tcx.adt_def(def.did).repr.align.is_some() {\n                 return true;\n@@ -1954,7 +1954,7 @@ fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) ->\n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n                 let f = field.ty(tcx, substs);\n-                if let ty::Adt(def, _) = f.sty {\n+                if let ty::Adt(def, _) = f.kind {\n                     if check_packed_inner(tcx, def.did, stack) {\n                         return true;\n                     }\n@@ -2974,7 +2974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut self_ty = adjusted_ty;\n             if unsize {\n                 // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.sty {\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n                     self_ty = self.tcx.mk_slice(element_ty);\n                 } else {\n                     continue;\n@@ -2996,7 +2996,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = autoderef.adjust_steps(self, needs);\n-                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n+                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n                     let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -3147,7 +3147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n             trait_ref, self_ty, expected_vid\n         );\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Infer(ty::TyVar(found_vid)) => {\n                 // FIXME: consider using `sub_root_var` here so we\n                 // can see through subtyping.\n@@ -3272,15 +3272,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n-            match tuple_type.sty {\n+            match tuple_type.kind {\n                 ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n                     param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n                     expected_arg_tys = vec![];\n                     self.err_args(args.len())\n                 }\n                 ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n-                        Some(&ty) => match ty.sty {\n+                        Some(&ty) => match ty.kind {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n                         },\n@@ -3421,7 +3421,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // There are a few types which get autopromoted when passed via varargs\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n-                match arg_ty.sty {\n+                match arg_ty.kind {\n                     ty::Float(ast::FloatTy::F32) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n                     }\n@@ -3548,7 +3548,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n             ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| {\n-                    match ty.sty {\n+                    match ty.kind {\n                         ty::Int(_) | ty::Uint(_) => Some(ty),\n                         ty::Char => Some(tcx.types.u8),\n                         ty::RawPtr(..) => Some(tcx.types.usize),\n@@ -3561,7 +3561,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ast::LitKind::Float(_, t) => tcx.mk_mach_float(t),\n             ast::LitKind::FloatUnsuffixed(_) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| {\n-                    match ty.sty {\n+                    match ty.kind {\n                         ty::Float(_) => Some(ty),\n                         _ => None\n                     }\n@@ -3657,7 +3657,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return None;\n             }\n             Res::Def(DefKind::Variant, _) => {\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_res(def), adt.did, substs))\n                     }\n@@ -3669,7 +3669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::AssocTy, _)\n             | Res::SelfTy(..) => {\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Adt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.non_enum_variant(), adt.did, substs))\n                     }\n@@ -4163,13 +4163,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n     ) -> bool {\n         let hir = self.tcx.hir();\n-        let (def_id, sig) = match found.sty {\n+        let (def_id, sig) = match found.kind {\n             ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n             ty::Closure(def_id, substs) => {\n                 // We don't use `closure_sig` to account for malformed closures like\n                 // `|_: [_; continue]| {}` and instead we don't suggest anything.\n                 let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n-                (def_id, match closure_sig_ty.sty {\n+                (def_id, match closure_sig_ty.kind {\n                     ty::FnPtr(sig) => sig,\n                     _ => return false,\n                 })\n@@ -4283,7 +4283,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Applicability::MachineApplicable,\n             );\n         } else if let (ty::FnDef(def_id, ..), true) = (\n-            &found.sty,\n+            &found.kind,\n             self.suggest_fn_call(err, expr, expected, found),\n         ) {\n             if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n@@ -4453,7 +4453,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n-                if ty.sty == expected.sty {\n+                if ty.kind == expected.kind {\n                     err.span_label(sp, format!(\"expected `{}` because of return type\",\n                                                expected));\n                     return true;\n@@ -4699,7 +4699,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = self.impl_self_ty(span, impl_def_id).ty;\n             let adt_def = ty.ty_adt_def();\n \n-            match ty.sty {\n+            match ty.kind {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n@@ -4999,10 +4999,10 @@ pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, t\n     let mut types_used = vec![false; own_counts.types];\n \n     for leaf_ty in ty.walk() {\n-        if let ty::Param(ty::ParamTy { index, .. }) = leaf_ty.sty {\n+        if let ty::Param(ty::ParamTy { index, .. }) = leaf_ty.kind {\n             debug!(\"found use of ty param num {}\", index);\n             types_used[index as usize - own_counts.lifetimes] = true;\n-        } else if let ty::Error = leaf_ty.sty {\n+        } else if let ty::Error = leaf_ty.kind {\n             // If there is already another error, do not emit\n             // an error for not using a type parameter.\n             assert!(tcx.sess.has_errors());"}, {"sha": "f9df2d1d848ff3d59fbae05f25887317dfd8f856", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 op.node.as_str(), lhs_ty),\n                             );\n                             let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.sty {\n+                            if let Ref(_, rty, _) = lhs_ty.kind {\n                                 if {\n                                     self.infcx.type_is_copy_modulo_regions(self.param_env,\n                                                                            rty,\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.sty {\n+                                } else if let ty::Param(_) = lhs_ty.kind {\n                                     // FIXME: point to span of param\n                                     err.note(&format!(\n                                         \"`{}` might need a bound for `{}`\",\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n \n                             let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.sty {\n+                            if let Ref(_, rty, _) = lhs_ty.kind {\n                                 if {\n                                     self.infcx.type_is_copy_modulo_regions(self.param_env,\n                                                                            rty,\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.sty {\n+                                } else if let ty::Param(_) = lhs_ty.kind {\n                                     // FIXME: point to span of param\n                                     err.note(&format!(\n                                         \"`{}` might need a bound for `{}`\",\n@@ -443,7 +443,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         is_assign: IsAssign,\n     ) -> bool /* did we suggest to call a function because of missing parenthesis? */ {\n         err.span_label(span, ty.to_string());\n-        if let FnDef(def_id, _) = ty.sty {\n+        if let FnDef(def_id, _) = ty.kind {\n             let source_map = self.tcx.sess.source_map();\n             let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n                 Some(hir_id) => hir_id,\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            let other_ty = if let FnDef(def_id, _) = other_ty.sty {\n+            let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n                 let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n                     Some(hir_id) => hir_id,\n                     None => return false,\n@@ -531,10 +531,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let is_std_string = |ty| &format!(\"{:?}\", ty) == \"std::string::String\";\n \n-        match (&lhs_ty.sty, &rhs_ty.sty) {\n+        match (&lhs_ty.kind, &rhs_ty.kind) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n-                if (l_ty.sty == Str || is_std_string(l_ty)) && (\n-                        r_ty.sty == Str || is_std_string(r_ty) ||\n+                if (l_ty.kind == Str || is_std_string(l_ty)) && (\n+                        r_ty.kind == Str || is_std_string(r_ty) ||\n                         &format!(\"{:?}\", rhs_ty) == \"&&str\"\n                     ) =>\n             {\n@@ -568,7 +568,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 true\n             }\n             (&Ref(_, l_ty, _), &Adt(..)) // Handle `&str` & `&String` + `String`\n-                if (l_ty.sty == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n+                if (l_ty.kind == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n             {\n                 err.span_label(\n                     op.span,\n@@ -626,12 +626,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                      op.as_str(), actual);\n                     err.span_label(ex.span, format!(\"cannot apply unary \\\n                                                     operator `{}`\", op.as_str()));\n-                    match actual.sty {\n+                    match actual.kind {\n                         Uint(_) if op == hir::UnNeg => {\n                             err.note(\"unsigned values cannot be negated\");\n                         },\n                         Str | Never | Char | Tuple(_) | Array(_,_) => {},\n-                        Ref(_, ref lty, _) if lty.sty == Str => {},\n+                        Ref(_, ref lty, _) if lty.kind == Str => {},\n                         _ => {\n                             let missing_trait = match op {\n                                 hir::UnNeg => \"std::ops::Neg\","}, {"sha": "af3259b987a2effa4efb72a6e649b3266d13e53e", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::Slice(..) => true,\n             PatKind::Lit(ref lt) => {\n                 let ty = self.check_expr(lt);\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Ref(..) => false,\n                     _ => true,\n                 }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // See the examples in `ui/match-defbm*.rs`.\n         let mut pat_adjustments = vec![];\n-        while let ty::Ref(_, inner_ty, inner_mutability) = expected.sty {\n+        while let ty::Ref(_, inner_ty, inner_mutability) = expected.kind {\n             debug!(\"inspecting {:?}\", expected);\n \n             debug!(\"current discriminant is Ref, inserting implicit deref\");\n@@ -309,8 +309,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let hir::ExprKind::Lit(ref lt) = lt.node {\n             if let ast::LitKind::ByteStr(_) = lt.node {\n                 let expected_ty = self.structurally_resolved_type(span, expected);\n-                if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n-                    if let ty::Slice(_) = r_ty.sty {\n+                if let ty::Ref(_, r_ty, _) = expected_ty.kind {\n+                    if let ty::Slice(_) = r_ty.kind {\n                         let tcx = self.tcx;\n                         pat_ty = tcx.mk_imm_ref(\n                             tcx.lifetimes.re_static,\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.sty {\n+                if let ty::Dynamic(..) = mt.ty.kind {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -673,7 +673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if subpats.len() == variant.fields.len()\n             || subpats.len() < variant.fields.len() && ddpos.is_some()\n         {\n-            let substs = match pat_ty.sty {\n+            let substs = match pat_ty.kind {\n                 ty::Adt(_, substs) => substs,\n                 _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n             };\n@@ -727,10 +727,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // More generally, the expected type wants a tuple variant with one field of an\n         // N-arity-tuple, e.g., `V_i((p_0, .., p_N))`. Meanwhile, the user supplied a pattern\n         // with the subpatterns directly in the tuple variant pattern, e.g., `V_i(p_0, .., p_N)`.\n-        let missing_parenthesis = match expected.sty {\n+        let missing_parenthesis = match expected.kind {\n             ty::Adt(_, substs) if fields.len() == 1 => {\n                 let field_ty = fields[0].ty(self.tcx, substs);\n-                match field_ty.sty {\n+                match field_ty.kind {\n                     ty::Tuple(_) => field_ty.tuple_fields().count() == subpats.len(),\n                     _ => false,\n                 }\n@@ -790,7 +790,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_len = elements.len();\n         if ddpos.is_some() {\n             // Require known type only when `..` is present.\n-            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).sty {\n+            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).kind {\n                 expected_len = tys.len();\n             }\n         }\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         let tcx = self.tcx;\n \n-        let (substs, adt) = match adt_ty.sty {\n+        let (substs, adt) = match adt_ty.kind {\n             ty::Adt(adt, substs) => (substs, adt),\n             _ => span_bug!(span, \"struct pattern is not an ADT\")\n         };\n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // to avoid creating needless variables. This also helps with\n             // the bad  interactions of the given hack detailed in (note_1).\n             debug!(\"check_pat_ref: expected={:?}\", expected);\n-            match expected.sty {\n+            match expected.kind {\n                 ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n                 _ => {\n                     let inner_ty = self.next_ty_var(\n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_ty = self.structurally_resolved_type(span, expected);\n-        let (inner_ty, slice_ty) = match expected_ty.sty {\n+        let (inner_ty, slice_ty) = match expected_ty.kind {\n             ty::Array(inner_ty, size) => {\n                 let slice_ty = if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n                     let min_len = before.len() as u64 + after.len() as u64;\n@@ -1212,8 +1212,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"expected an array or slice, found `{}`\",\n             expected_ty\n         );\n-        if let ty::Ref(_, ty, _) = expected_ty.sty {\n-            if let ty::Array(..) | ty::Slice(..) = ty.sty {\n+        if let ty::Ref(_, ty, _) = expected_ty.kind {\n+            if let ty::Array(..) | ty::Slice(..) = ty.kind {\n                 err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n             }\n         }"}, {"sha": "ac9f9f1ea25b15410ef6731ab35522cb6d27366f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -621,7 +621,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n                 let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::Ref(r_ptr, _, _) = base_ty.sty {\n+                if let ty::Ref(r_ptr, _, _) = base_ty.kind {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n@@ -720,7 +720,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n-        match (&from_ty.sty, &to_ty.sty) {\n+        match (&from_ty.kind, &to_ty.kind) {\n             /*From:*/\n             (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n-        match callee_ty.sty {\n+        match callee_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {}\n             _ => {\n                 // this should not happen, but it does if the program is\n@@ -966,8 +966,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             id: index_expr.hir_id.local_id,\n             data: region::ScopeData::Node,\n         });\n-        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n-            match r_ty.sty {\n+        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.kind {\n+            match r_ty.kind {\n                 ty::Slice(_) | ty::Str => {\n                     self.sub_regions(\n                         infer::IndexSlice(index_expr.span),\n@@ -1160,7 +1160,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::Ref(r, _, _) = rptr_ty.sty {\n+        if let ty::Ref(r, _, _) = rptr_ty.kind {\n             debug!(\"rptr_ty={}\", rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }"}, {"sha": "d57fec9947db1bbc877374795c2cd880b88596e5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Extract the type of the closure.\n         let ty = self.node_ty(closure_hir_id);\n-        let (closure_def_id, substs) = match ty.sty {\n+        let (closure_def_id, substs) = match ty.kind {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ty::Error => {"}, {"sha": "f67a8e90548537284e6d76cdd1a75abb8d22ad2c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -366,7 +366,7 @@ fn check_item_type(\n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n             let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n-            if let ty::Foreign(_) = tail.sty {\n+            if let ty::Foreign(_) = tail.kind {\n                 forbid_unsized = false;\n             }\n         }\n@@ -511,7 +511,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n         struct CountParams { params: FxHashSet<u32> }\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                if let ty::Param(param) = t.sty {\n+                if let ty::Param(param) = t.kind {\n                     self.params.insert(param.index);\n                 }\n                 t.super_visit_with(self)\n@@ -635,7 +635,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n-            if let ty::Opaque(def_id, substs) = ty.sty {\n+            if let ty::Opaque(def_id, substs) = ty.kind {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // Only check named `impl Trait` types defined in this crate.\n@@ -646,7 +646,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n-                                ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n+                                ty::subst::UnpackedKind::Type(ty) => match ty.kind {\n                                     ty::Param(..) => {}\n                                     // Prevent `fn foo() -> Foo<u32>` from being defining.\n                                     _ => {"}, {"sha": "f3ee64e9d136843221638d07f3d7b42fa8b3cd18", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -190,7 +190,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n-            if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n+            if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).kind {\n                 let index_ty = tables.expr_ty_adjusted(&index);\n                 let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n@@ -454,7 +454,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             let mut skip_add = false;\n \n-            if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n+            if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n                 if def_id == defin_ty_def_id {\n                     debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n                            opaque_defn, defin_ty_def_id);"}, {"sha": "9054c2b80102af4dba05ce27d7c97f3b409b8806", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> Checker<'tcx> {\n }\n \n fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n-    if let ty::Adt(..) = tcx.type_of(impl_did).sty {\n+    if let ty::Adt(..) = tcx.type_of(impl_did).kind {\n         /* do nothing */\n     } else {\n         // Destructors only work on nominal types.\n@@ -186,7 +186,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n             let cause = ObligationCause::misc(span, impl_hir_id);\n \n             use ty::TyKind::*;\n-            match (&source.sty, &target.sty) {\n+            match (&source.kind, &target.kind) {\n                 (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n                     if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok()\n                     && mutbl_a == *mutbl_b => (),\n@@ -367,7 +367,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n-        let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+        let (source, target, trait_def_id, kind) = match (&source.kind, &target.kind) {\n             (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };"}, {"sha": "d2651317da948f069d7a05c9480ce62a2eac86d5", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -57,7 +57,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n-        match self_ty.sty {\n+        match self_ty.kind {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did);\n             }"}, {"sha": "a44c475e0f8a943b41b82a17e0bbfb92d3ac9b18", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -167,7 +167,7 @@ fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n     tcx.specialization_graph_of(trait_def_id);\n \n     // check for overlap with the automatic `impl Trait for Trait`\n-    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().sty {\n+    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "8969bf894e0f6e86c874dcc0c57b31873b0e0347", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -102,7 +102,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             if self.tcx.trait_is_auto(trait_def_id) &&\n                !trait_def_id.is_local() {\n                 let self_ty = trait_ref.self_ty();\n-                let opt_self_def_id = match self_ty.sty {\n+                let opt_self_def_id = match self_ty.kind {\n                     ty::Adt(self_def, _) => Some(self_def.did),\n                     ty::Foreign(did) => Some(did),\n                     _ => None,"}, {"sha": "6a5be9023be7280a1a206ef29c243b51255b4f03", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1581,7 +1581,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 // their positions.\n                 for (idx, subst) in substs.iter().enumerate() {\n                     if let UnpackedKind::Type(ty) = subst.unpack() {\n-                        if let ty::Param(p) = ty.sty {\n+                        if let ty::Param(p) = ty.kind {\n                             if index_map.insert(p, idx).is_some() {\n                                 // There was already an entry for `p`, meaning a generic parameter\n                                 // was used twice.\n@@ -1611,11 +1611,11 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 let indices = concrete_type\n                     .subst(self.tcx, substs)\n                     .walk()\n-                    .filter_map(|t| match &t.sty {\n+                    .filter_map(|t| match &t.kind {\n                         ty::Param(p) => Some(*index_map.get(p).unwrap()),\n                         _ => None,\n                     }).collect();\n-                let is_param = |ty: Ty<'_>| match ty.sty {\n+                let is_param = |ty: Ty<'_>| match ty.kind {\n                     ty::Param(_) => true,\n                     _ => false,\n                 };\n@@ -1627,7 +1627,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n                     let mut ty = concrete_type.walk().fuse();\n                     let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.sty, &p.sty) {\n+                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n                         // Type parameters are equal to any other type parameter for the purpose of\n                         // concrete type equality, as it is possible to obtain the same type just\n                         // by passing matching parameters to a function.\n@@ -2198,7 +2198,7 @@ fn explicit_predicates_of(\n                 // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n                 // is still checked for WF.\n                 if bound_pred.bounds.is_empty() {\n-                    if let ty::Param(_) = ty.sty {\n+                    if let ty::Param(_) = ty.kind {\n                         // This is a `where T:`, which can be in the HIR from the\n                         // transformation that moves `?Sized` to `T`'s declaration.\n                         // We can skip the predicate because type parameters are"}, {"sha": "31476eb73179857bb866fa6f7c5009535eab26bb", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -55,7 +55,7 @@ struct ParameterCollector {\n \n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.sty {\n+        match t.kind {\n             ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;"}, {"sha": "dbff1e91617e526848d87922c278b1842475f4d0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -159,7 +159,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n-    match main_t.sty {\n+    match main_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n@@ -224,7 +224,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n-    match start_t.sty {\n+    match start_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {"}, {"sha": "f8d92f625c3013770a6bf70688e0c593f16388d7", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -123,7 +123,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) {\n     for ty in field_ty.walk() {\n-        match ty.sty {\n+        match ty.kind {\n             // The field is of type &'a T which means that we will have\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //"}, {"sha": "16d5fde815f6a757b880e2d25da52397fc32d848", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n-        match tcx.type_of(def_id).sty {\n+        match tcx.type_of(def_id).kind {\n             ty::Adt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                ty,\n                variance);\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n             ty::Str | ty::Never | ty::Foreign(..) => {\n                 // leaf type -- noop"}, {"sha": "fbd476ef832c4fa204a790f45fdd7af0b3c574f3", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             self.enforce_const_invariance(generics, variances);\n \n             // Functions are permitted to have unused generic parameters: make those invariant.\n-            if let ty::FnDef(..) = tcx.type_of(def_id).sty {\n+            if let ty::FnDef(..) = tcx.type_of(def_id).kind {\n                 for variance in variances.iter_mut() {\n                     if *variance == ty::Bivariant {\n                         *variance = ty::Invariant;"}, {"sha": "afed11e7fab26c607c288135398583a78868e41c", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         trait_def_id, impl_def_id);\n                 let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let may_apply = self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    match trait_ref.self_ty().sty {\n+                    match trait_ref.self_ty().kind {\n                         ty::Param(_) => {},\n                         _ => return false,\n                     }"}, {"sha": "46b71abac540938ff52b10e91dbafd6f27613227", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1108,7 +1108,7 @@ fn external_generic_args(\n             None\n         }\n         UnpackedKind::Type(ty) => {\n-            ty_sty = Some(&ty.sty);\n+            ty_sty = Some(&ty.kind);\n             Some(GenericArg::Type(ty.clean(cx)))\n         }\n         UnpackedKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n@@ -1124,7 +1124,7 @@ fn external_generic_args(\n             };\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n-            // match types[1].sty {\n+            // match types[1].kind {\n             //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n@@ -1162,9 +1162,9 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for ty_s in trait_ref.input_types().skip(1) {\n-            if let ty::Tuple(ts) = ty_s.sty {\n+            if let ty::Tuple(ts) = ty_s.kind {\n                 for &ty_s in ts {\n-                    if let ty::Ref(ref reg, _, _) = ty_s.expect_ty().sty {\n+                    if let ty::Ref(ref reg, _, _) = ty_s.expect_ty().kind {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(Lifetime(name)) = reg.clean(cx) {\n@@ -1705,15 +1705,15 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                 let mut projection = None;\n                 let param_idx = (|| {\n                     if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n-                        if let ty::Param(param) = trait_ref.self_ty().sty {\n+                        if let ty::Param(param) = trait_ref.self_ty().kind {\n                             return Some(param.index);\n                         }\n                     } else if let Some(outlives) = p.to_opt_type_outlives() {\n-                        if let ty::Param(param) = outlives.skip_binder().0.sty {\n+                        if let ty::Param(param) = outlives.skip_binder().0.kind {\n                             return Some(param.index);\n                         }\n                     } else if let ty::Predicate::Projection(p) = p {\n-                        if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().sty {\n+                        if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().kind {\n                             projection = Some(p);\n                             return Some(param.index);\n                         }\n@@ -2380,7 +2380,7 @@ impl Clean<Item> for ty::AssocItem {\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::Ref(_, ty, _) = self_arg_ty.sty {\n+                    } else if let ty::Ref(_, ty, _) = self_arg_ty.kind {\n                         if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef{ref mut type_, ..} => {\n@@ -3000,7 +3000,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut res = Res::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::Projection(proj) = ty.sty {\n+                if let ty::Projection(proj) = ty.kind {\n                     res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n@@ -3040,7 +3040,7 @@ impl Clean<Type> for hir::Ty {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n-        match self.sty {\n+        match self.kind {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n             ty::Char => Primitive(PrimitiveType::Char),"}, {"sha": "9186ed514202ff736ccb63cea9e67098e69ed86e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         };\n                         Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n-                        match cx.tcx.type_of(did).sty {\n+                        match cx.tcx.type_of(did).kind {\n                             ty::Adt(def, _) => {\n                                 if let Some(item) = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)"}, {"sha": "f716a78a031f25be07c25679094d00c652b18099", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -8,9 +8,9 @@ use rustc::ty::{self, Ty, TyKind};\n \n #[deny(rustc::usage_of_ty_tykind)]\n fn main() {\n-    let sty = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n+    let kind = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n \n-    match sty {\n+    match kind {\n         TyKind::Bool => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Char => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Int(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n@@ -41,9 +41,9 @@ fn main() {\n         TyKind::Error => (), //~ ERROR usage of `ty::TyKind::<kind>`\n     }\n \n-    if let ty::Int(int_ty) = sty {}\n+    if let ty::Int(int_ty) = kind {}\n \n-    if let TyKind::Int(int_ty) = sty {} //~ ERROR usage of `ty::TyKind::<kind>`\n+    if let TyKind::Int(int_ty) = kind {} //~ ERROR usage of `ty::TyKind::<kind>`\n \n     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {} //~ ERROR usage of `ty::TyKind`\n }"}, {"sha": "28c837adac3a193d5f0008cc545fb386e9817d32", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc45735f29788924b9fc351d100e5bf3ebdca162/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=dc45735f29788924b9fc351d100e5bf3ebdca162", "patch": "@@ -1,8 +1,8 @@\n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:11:15\n+  --> $DIR/ty_tykind_usage.rs:11:16\n    |\n-LL |     let sty = TyKind::Bool;\n-   |               ^^^^^^ help: try using ty::<kind> directly: `ty`\n+LL |     let kind = TyKind::Bool;\n+   |                ^^^^^^ help: try using ty::<kind> directly: `ty`\n    |\n note: lint level defined here\n   --> $DIR/ty_tykind_usage.rs:9:8\n@@ -181,7 +181,7 @@ LL |         TyKind::Error => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:46:12\n    |\n-LL |     if let TyKind::Int(int_ty) = sty {}\n+LL |     if let TyKind::Int(int_ty) = kind {}\n    |            ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind`"}]}