{"sha": "299a65ff71413de0fc26d880219402ceb7fa1bcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OWE2NWZmNzE0MTNkZTBmYzI2ZDg4MDIxOTQwMmNlYjdmYTFiY2I=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-28T19:57:56Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-30T19:39:30Z"}, "message": "Update chalk 0.32.0 -> 0.35.0", "tree": {"sha": "f3cb9a0c7c1ad5d47459279137998196f78f77d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3cb9a0c7c1ad5d47459279137998196f78f77d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/299a65ff71413de0fc26d880219402ceb7fa1bcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/299a65ff71413de0fc26d880219402ceb7fa1bcb", "html_url": "https://github.com/rust-lang/rust/commit/299a65ff71413de0fc26d880219402ceb7fa1bcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/299a65ff71413de0fc26d880219402ceb7fa1bcb/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5c655d0c379754c2c0e5a6b8194bd2ee91e455", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5c655d0c379754c2c0e5a6b8194bd2ee91e455", "html_url": "https://github.com/rust-lang/rust/commit/1f5c655d0c379754c2c0e5a6b8194bd2ee91e455"}], "stats": {"total": 518, "additions": 214, "deletions": 304}, "files": [{"sha": "6d4a8cc696d7f76fb3c0d4d5435428579fb66563", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -460,9 +460,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.32.0\"\n+version = \"0.35.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d072b2ba723f0bada7c515d8b3725224bc4f5052d2a92dcbeb0b118ff37084a\"\n+checksum = \"bc6d2895e93c0939074a7a0f525fd549b49da8362dea3def555e4aab95ff64cd\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -472,9 +472,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.32.0\"\n+version = \"0.35.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fb5475f6083d6d6c509e1c335c4f69ad04144ac090faa1afb134a53c3695841\"\n+checksum = \"93ed23c35d243ccc2caeae7ba4660a091e74b11c40e441d7849f07d8e71b5cb8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -485,19 +485,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.32.0\"\n+version = \"0.35.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f60cdb0e18c5455cb6a85e8464aad3622b70476018edfa8845691df66f7e9a05\"\n+checksum = \"40d7f6140cccc889117e7372b6f9cfbc8103c86a1a0269ff6ab868f20ab414d6\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.32.0\"\n+version = \"0.35.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"981534d499a8476ecc0b520be4d3864757f96211826a75360fbf2cb6fae362ab\"\n+checksum = \"fa65b636e64cbfcba31f053da97c32f3e15f2670b3cc620b84231a1656d754ec\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "03e7f137672588ffe5822b99f841b522d2e4c144", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -26,7 +26,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n+chalk-ir = \"0.35.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "f864ad8ebcd8a0f52fa34244d6c0c211e119d78e", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -102,48 +102,6 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write())\n     }\n \n-    fn debug_application_ty(\n-        application_ty: &chalk_ir::ApplicationTy<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        match application_ty.name {\n-            chalk_ir::TypeName::Ref(mutbl) => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (\n-                        chalk_ir::GenericArgData::Lifetime(lifetime),\n-                        chalk_ir::GenericArgData::Ty(ty),\n-                    ) => Some(match mutbl {\n-                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n-                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n-                    }),\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Array => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n-                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Slice => {\n-                let data = application_ty.substitution.interned();\n-                let ty = match &**data[0].interned() {\n-                    chalk_ir::GenericArgData::Ty(t) => t,\n-                    _ => unreachable!(),\n-                };\n-                Some(write!(fmt, \"[{:?}]\", ty))\n-            }\n-            _ => {\n-                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n-            }\n-        }\n-    }\n-\n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n@@ -174,6 +132,32 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write!(fmt, \"{:?}\", clauses.interned()))\n     }\n \n+    fn debug_ty(ty: &chalk_ir::Ty<Self>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        match &ty.interned().kind {\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Not, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Mut, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n+            chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n+            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n+                write!(fmt, \"(\")?;\n+                for (idx, substitution) in substs.interned().iter().enumerate() {\n+                    if idx == *len && *len != 1 {\n+                        // Don't add a trailing comma if the tuple has more than one element\n+                        write!(fmt, \"{:?}\", substitution)?;\n+                    } else {\n+                        write!(fmt, \"{:?},\", substitution)?;\n+                    }\n+                }\n+                write!(fmt, \")\")\n+            })()),\n+            _ => None,\n+        }\n+    }\n+\n     fn debug_alias(\n         alias_ty: &chalk_ir::AliasTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,"}, {"sha": "4dce3c172809852155b86f816c3316ca5d297206", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -12,9 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n-chalk-solve = \"0.32.0\"\n-chalk-engine = \"0.32.0\"\n+chalk-ir = \"0.35.0\"\n+chalk-solve = \"0.35.0\"\n+chalk-engine = \"0.35.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "eba1a525cfeb024d118d97924c8a9706ff5801b7", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -324,19 +324,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     fn impl_provided_for(\n         &self,\n         auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-        app_ty: &chalk_ir::ApplicationTy<RustInterner<'tcx>>,\n+        chalk_ty: &chalk_ir::TyKind<RustInterner<'tcx>>,\n     ) -> bool {\n         use chalk_ir::Scalar::*;\n-        use chalk_ir::TypeName::*;\n+        use chalk_ir::TyKind::*;\n \n         let trait_def_id = auto_trait_id.0;\n         let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n             let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n-            let provides = match (self_ty.kind(), app_ty.name) {\n-                (&ty::Adt(impl_adt_def, ..), Adt(id)) => impl_adt_def.did == id.0.did,\n-                (_, AssociatedType(_ty_id)) => {\n+            let provides = match (self_ty.kind(), chalk_ty) {\n+                (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did == id.0.did,\n+                (_, AssociatedType(_ty_id, ..)) => {\n                     // FIXME(chalk): See https://github.com/rust-lang/rust/pull/77152#discussion_r494484774\n                     false\n                 }\n@@ -365,28 +365,30 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                     (ast::FloatTy::F32, chalk_ir::FloatTy::F32)\n                         | (ast::FloatTy::F64, chalk_ir::FloatTy::F64)\n                 ),\n-                (&ty::Tuple(..), Tuple(..)) => true,\n-                (&ty::Array(..), Array) => true,\n-                (&ty::Slice(..), Slice) => true,\n-                (&ty::RawPtr(type_and_mut), Raw(mutability)) => {\n+                (&ty::Tuple(substs), Tuple(len, _)) => substs.len() == *len,\n+                (&ty::Array(..), Array(..)) => true,\n+                (&ty::Slice(..), Slice(..)) => true,\n+                (&ty::RawPtr(type_and_mut), Raw(mutability, _)) => {\n                     match (type_and_mut.mutbl, mutability) {\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n                     }\n                 }\n-                (&ty::Ref(.., mutability1), Ref(mutability2)) => match (mutability1, mutability2) {\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n-                },\n-                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id)) => def_id == opaque_ty_id.0,\n-                (&ty::FnDef(def_id, ..), FnDef(fn_def_id)) => def_id == fn_def_id.0,\n+                (&ty::Ref(.., mutability1), Ref(mutability2, ..)) => {\n+                    match (mutability1, mutability2) {\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n+                    }\n+                }\n+                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id, ..)) => def_id == opaque_ty_id.0,\n+                (&ty::FnDef(def_id, ..), FnDef(fn_def_id, ..)) => def_id == fn_def_id.0,\n                 (&ty::Str, Str) => true,\n                 (&ty::Never, Never) => true,\n-                (&ty::Closure(def_id, ..), Closure(closure_id)) => def_id == closure_id.0,\n+                (&ty::Closure(def_id, ..), Closure(closure_id, _)) => def_id == closure_id.0,\n                 (&ty::Foreign(def_id), Foreign(foreign_def_id)) => def_id == foreign_def_id.0,\n                 (&ty::Error(..), Error) => false,\n                 _ => false,\n@@ -506,17 +508,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_solve::rust_ir::ClosureKind {\n         let kind = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 3];\n-        match kind.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Apply(apply) => match apply.name {\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n-                        chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n-                        chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n-                        _ => bug!(\"bad closure kind\"),\n-                    },\n-                    _ => bug!(\"bad closure kind\"),\n-                },\n+        match kind.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(int_ty)) => match int_ty {\n+                chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n+                chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n+                chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n                 _ => bug!(\"bad closure kind\"),\n             },\n             _ => bug!(\"bad closure kind\"),\n@@ -530,23 +526,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> chalk_ir::Binders<chalk_solve::rust_ir::FnDefInputsAndOutputDatum<RustInterner<'tcx>>>\n     {\n         let sig = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 2];\n-        match sig.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Function(f) => {\n+        match sig.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Function(f) => {\n                 let substitution = f.substitution.as_slice(&self.interner);\n                 let return_type =\n                     substitution.last().unwrap().assert_ty_ref(&self.interner).clone();\n                 // Closure arguments are tupled\n                 let argument_tuple = substitution[0].assert_ty_ref(&self.interner);\n-                let argument_types = match argument_tuple.data(&self.interner) {\n-                    chalk_ir::TyData::Apply(apply) => match apply.name {\n-                        chalk_ir::TypeName::Tuple(_) => apply\n-                            .substitution\n-                            .iter(&self.interner)\n-                            .map(|arg| arg.assert_ty_ref(&self.interner))\n-                            .cloned()\n-                            .collect(),\n-                        _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n-                    },\n+                let argument_types = match argument_tuple.kind(&self.interner) {\n+                    chalk_ir::TyKind::Tuple(_len, substitution) => substitution\n+                        .iter(&self.interner)\n+                        .map(|arg| arg.assert_ty_ref(&self.interner))\n+                        .cloned()\n+                        .collect(),\n                     _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n                 };\n \n@@ -637,7 +629,7 @@ fn binders_for<'tcx>(\n         bound_vars.iter().map(|arg| match arg.unpack() {\n             ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::VariableKind::Lifetime,\n             ty::subst::GenericArgKind::Type(_ty) => {\n-                chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n             }\n             ty::subst::GenericArgKind::Const(c) => {\n                 chalk_ir::VariableKind::Const(c.ty.lower_into(interner))"}, {"sha": "3fcbfd6187c8fd97394afcdfeb32a5afc6a9945d", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 137, "deletions": 204, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::traits::{ChalkEnvironmentAndGoal, ChalkRustInterner as RustInt\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n+    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n use rustc_span::def_id::DefId;\n \n@@ -239,113 +239,72 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n-        use chalk_ir::TyData;\n         use rustc_ast as ast;\n-        use TyKind::*;\n \n-        let empty = || chalk_ir::Substitution::empty(interner);\n-        let struct_ty =\n-            |def_id| chalk_ir::TypeName::Adt(chalk_ir::AdtId(interner.tcx.adt_def(def_id)));\n-        let apply = |name, substitution| {\n-            TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n-        };\n-        let int = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Int(i)), empty());\n-        let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n-        let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n+        let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n+        let uint = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(i));\n+        let float = |f| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Float(f));\n \n         match *self.kind() {\n-            Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n-            Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n-            Int(ty) => match ty {\n+            ty::Bool => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Bool),\n+            ty::Char => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Char),\n+            ty::Int(ty) => match ty {\n                 ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n                 ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n                 ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n                 ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n                 ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n                 ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n             },\n-            Uint(ty) => match ty {\n+            ty::Uint(ty) => match ty {\n                 ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n                 ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n                 ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n                 ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n                 ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n                 ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n             },\n-            Float(ty) => match ty {\n+            ty::Float(ty) => match ty {\n                 ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n-            Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n-            Foreign(def_id) => apply(chalk_ir::TypeName::Foreign(ForeignDefId(def_id)), empty()),\n-            Str => apply(chalk_ir::TypeName::Str, empty()),\n-            Array(ty, len) => {\n-                let value = match len.val {\n-                    ty::ConstKind::Value(val) => {\n-                        chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n-                    }\n-                    ty::ConstKind::Bound(db, bound) => {\n-                        chalk_ir::ConstValue::BoundVar(chalk_ir::BoundVar::new(\n-                            chalk_ir::DebruijnIndex::new(db.as_u32()),\n-                            bound.index(),\n-                        ))\n-                    }\n-                    _ => unimplemented!(\"Const not implemented. {:?}\", len.val),\n-                };\n-                apply(\n-                    chalk_ir::TypeName::Array,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                            chalk_ir::GenericArgData::Const(\n-                                chalk_ir::ConstData { ty: len.ty.lower_into(interner), value }\n-                                    .intern(interner),\n-                            )\n-                            .intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Adt(def, substs) => {\n+                chalk_ir::TyKind::Adt(chalk_ir::AdtId(def), substs.lower_into(interner))\n             }\n-            Slice(ty) => apply(\n-                chalk_ir::TypeName::Slice,\n-                chalk_ir::Substitution::from1(\n-                    interner,\n-                    chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                ),\n-            ),\n-            RawPtr(ptr) => {\n-                let name = match ptr.mutbl {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Not),\n-                };\n-                apply(name, chalk_ir::Substitution::from1(interner, ptr.ty.lower_into(interner)))\n+            ty::Foreign(def_id) => chalk_ir::TyKind::Foreign(ForeignDefId(def_id)),\n+            ty::Str => chalk_ir::TyKind::Str,\n+            ty::Array(ty, len) => {\n+                chalk_ir::TyKind::Array(ty.lower_into(interner), len.lower_into(interner))\n             }\n-            Ref(region, ty, mutability) => {\n-                let name = match mutability {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Not),\n-                };\n-                apply(\n-                    name,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Lifetime(region.lower_into(interner))\n-                                .intern(interner),\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Slice(ty) => chalk_ir::TyKind::Slice(ty.lower_into(interner)),\n+\n+            ty::RawPtr(ptr) => match ptr.mutbl {\n+                ast::Mutability::Mut => {\n+                    chalk_ir::TyKind::Raw(chalk_ir::Mutability::Mut, ptr.ty.lower_into(interner))\n+                }\n+                ast::Mutability::Not => {\n+                    chalk_ir::TyKind::Raw(chalk_ir::Mutability::Not, ptr.ty.lower_into(interner))\n+                }\n+            },\n+            ty::Ref(region, ty, mutability) => match mutability {\n+                ast::Mutability::Mut => chalk_ir::TyKind::Ref(\n+                    chalk_ir::Mutability::Mut,\n+                    region.lower_into(interner),\n+                    ty.lower_into(interner),\n+                ),\n+                ast::Mutability::Not => chalk_ir::TyKind::Ref(\n+                    chalk_ir::Mutability::Not,\n+                    region.lower_into(interner),\n+                    ty.lower_into(interner),\n+                ),\n+            },\n+            ty::FnDef(def_id, substs) => {\n+                chalk_ir::TyKind::FnDef(chalk_ir::FnDefId(def_id), substs.lower_into(interner))\n             }\n-            FnDef(def_id, substs) => apply(\n-                chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)),\n-                substs.lower_into(interner),\n-            ),\n-            FnPtr(sig) => {\n+            ty::FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n-                TyData::Function(chalk_ir::FnPointer {\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: binders.len(interner),\n                     sig: sig.lower_into(interner),\n                     substitution: chalk_ir::Substitution::from_iter(\n@@ -355,148 +314,122 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                         }),\n                     ),\n                 })\n-                .intern(interner)\n             }\n-            Dynamic(predicates, region) => TyData::Dyn(chalk_ir::DynTy {\n+            ty::Dynamic(predicates, region) => chalk_ir::TyKind::Dyn(chalk_ir::DynTy {\n                 bounds: predicates.lower_into(interner),\n                 lifetime: region.lower_into(interner),\n-            })\n-            .intern(interner),\n-            Closure(def_id, substs) => apply(\n-                chalk_ir::TypeName::Closure(chalk_ir::ClosureId(def_id)),\n-                substs.lower_into(interner),\n-            ),\n-            Generator(_def_id, _substs, _) => unimplemented!(),\n-            GeneratorWitness(_) => unimplemented!(),\n-            Never => apply(chalk_ir::TypeName::Never, empty()),\n-            Tuple(substs) => {\n-                apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n+            }),\n+            ty::Closure(def_id, substs) => {\n+                chalk_ir::TyKind::Closure(chalk_ir::ClosureId(def_id), substs.lower_into(interner))\n             }\n-            Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n-            Opaque(def_id, substs) => {\n-                TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+            ty::Generator(_def_id, _substs, _) => unimplemented!(),\n+            ty::GeneratorWitness(_) => unimplemented!(),\n+            ty::Never => chalk_ir::TyKind::Never,\n+            ty::Tuple(substs) => chalk_ir::TyKind::Tuple(substs.len(), substs.lower_into(interner)),\n+            ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n+            ty::Opaque(def_id, substs) => {\n+                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n                     substitution: substs.lower_into(interner),\n                 }))\n-                .intern(interner)\n             }\n             // This should have been done eagerly prior to this, and all Params\n             // should have been substituted to placeholders\n-            Param(_) => panic!(\"Lowering Param when not expected.\"),\n-            Bound(db, bound) => TyData::BoundVar(chalk_ir::BoundVar::new(\n+            ty::Param(_) => panic!(\"Lowering Param when not expected.\"),\n+            ty::Bound(db, bound) => chalk_ir::TyKind::BoundVar(chalk_ir::BoundVar::new(\n                 chalk_ir::DebruijnIndex::new(db.as_u32()),\n                 bound.var.index(),\n-            ))\n-            .intern(interner),\n-            Placeholder(_placeholder) => TyData::Placeholder(chalk_ir::PlaceholderIndex {\n-                ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n-                idx: _placeholder.name.as_usize(),\n-            })\n-            .intern(interner),\n-            Infer(_infer) => unimplemented!(),\n-            Error(_) => apply(chalk_ir::TypeName::Error, empty()),\n+            )),\n+            ty::Placeholder(_placeholder) => {\n+                chalk_ir::TyKind::Placeholder(chalk_ir::PlaceholderIndex {\n+                    ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n+                    idx: _placeholder.name.as_usize(),\n+                })\n+            }\n+            ty::Infer(_infer) => unimplemented!(),\n+            ty::Error(_) => chalk_ir::TyKind::Error,\n         }\n+        .intern(interner)\n     }\n }\n \n impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> Ty<'tcx> {\n-        use chalk_ir::TyData;\n+        use chalk_ir::TyKind;\n         use rustc_ast::ast;\n \n-        let kind = match self.data(interner) {\n-            TyData::Apply(application_ty) => match application_ty.name {\n-                chalk_ir::TypeName::Adt(struct_id) => {\n-                    ty::Adt(struct_id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Bool => ty::Bool,\n-                    chalk_ir::Scalar::Char => ty::Char,\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                        chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                        chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                        chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                        chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                        chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n-                    },\n-                    chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                        chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                        chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                        chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                        chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                        chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                        chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n-                    },\n-                    chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                        chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                        chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n-                    },\n+        let kind = match self.kind(interner) {\n+            TyKind::Adt(struct_id, substitution) => {\n+                ty::Adt(struct_id.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Scalar(scalar) => match scalar {\n+                chalk_ir::Scalar::Bool => ty::Bool,\n+                chalk_ir::Scalar::Char => ty::Char,\n+                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                },\n+                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                },\n+                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n                 },\n-                chalk_ir::TypeName::Array => {\n-                    let substs = application_ty.substitution.as_slice(interner);\n-                    let ty = substs[0].assert_ty_ref(interner).lower_into(interner);\n-                    let c = substs[1].assert_const_ref(interner).lower_into(interner);\n-                    ty::Array(ty, interner.tcx.mk_const(c))\n-                }\n-                chalk_ir::TypeName::FnDef(id) => {\n-                    ty::FnDef(id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Closure(closure) => {\n-                    ty::Closure(closure.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Generator(_) => unimplemented!(),\n-                chalk_ir::TypeName::GeneratorWitness(_) => unimplemented!(),\n-                chalk_ir::TypeName::Never => ty::Never,\n-                chalk_ir::TypeName::Tuple(_size) => {\n-                    ty::Tuple(application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Slice => ty::Slice(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                ),\n-                chalk_ir::TypeName::Raw(mutbl) => ty::RawPtr(ty::TypeAndMut {\n-                    ty: application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    mutbl: match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                }),\n-                chalk_ir::TypeName::Ref(mutbl) => ty::Ref(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .lifetime(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    application_ty.substitution.as_slice(interner)[1]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                ),\n-                chalk_ir::TypeName::Str => ty::Str,\n-                chalk_ir::TypeName::OpaqueType(opaque_ty) => {\n-                    ty::Opaque(opaque_ty.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::AssociatedType(assoc_ty) => ty::Projection(ty::ProjectionTy {\n-                    substs: application_ty.substitution.lower_into(interner),\n-                    item_def_id: assoc_ty.0,\n-                }),\n-                chalk_ir::TypeName::Foreign(def_id) => ty::Foreign(def_id.0),\n-                chalk_ir::TypeName::Error => unimplemented!(),\n             },\n-            TyData::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+            TyKind::Array(ty, c) => {\n+                let ty = ty.lower_into(interner);\n+                let c = c.lower_into(interner);\n+                ty::Array(ty, interner.tcx.mk_const(c))\n+            }\n+            TyKind::FnDef(id, substitution) => ty::FnDef(id.0, substitution.lower_into(interner)),\n+            TyKind::Closure(closure, substitution) => {\n+                ty::Closure(closure.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Generator(..) => unimplemented!(),\n+            TyKind::GeneratorWitness(..) => unimplemented!(),\n+            TyKind::Never => ty::Never,\n+            TyKind::Tuple(_len, substitution) => ty::Tuple(substitution.lower_into(interner)),\n+            TyKind::Slice(ty) => ty::Slice(ty.lower_into(interner)),\n+            TyKind::Raw(mutbl, ty) => ty::RawPtr(ty::TypeAndMut {\n+                ty: ty.lower_into(interner),\n+                mutbl: match mutbl {\n+                    chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                    chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                },\n+            }),\n+            TyKind::Ref(mutbl, lifetime, ty) => ty::Ref(\n+                lifetime.lower_into(interner),\n+                ty.lower_into(interner),\n+                match mutbl {\n+                    chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                    chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                },\n+            ),\n+            TyKind::Str => ty::Str,\n+            TyKind::OpaqueType(opaque_ty, substitution) => {\n+                ty::Opaque(opaque_ty.0, substitution.lower_into(interner))\n+            }\n+            TyKind::AssociatedType(assoc_ty, substitution) => ty::Projection(ty::ProjectionTy {\n+                substs: substitution.lower_into(interner),\n+                item_def_id: assoc_ty.0,\n+            }),\n+            TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n+            TyKind::Error => return interner.tcx.ty_error(),\n+            TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n                 name: ty::BoundVar::from_usize(placeholder.idx),\n             }),\n-            chalk_ir::TyData::Alias(alias_ty) => match alias_ty {\n+            TyKind::Alias(alias_ty) => match alias_ty {\n                 chalk_ir::AliasTy::Projection(projection) => ty::Projection(ty::ProjectionTy {\n                     item_def_id: projection.associated_ty_id.0,\n                     substs: projection.substitution.lower_into(interner),\n@@ -505,16 +438,16 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                     ty::Opaque(opaque.opaque_ty_id.0, opaque.substitution.lower_into(interner))\n                 }\n             },\n-            TyData::Function(_quantified_ty) => unimplemented!(),\n-            TyData::BoundVar(_bound) => ty::Bound(\n+            TyKind::Function(_quantified_ty) => unimplemented!(),\n+            TyKind::BoundVar(_bound) => ty::Bound(\n                 ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n                 ty::BoundTy {\n                     var: ty::BoundVar::from_usize(_bound.index),\n                     kind: ty::BoundTyKind::Anon,\n                 },\n             ),\n-            TyData::InferenceVar(_, _) => unimplemented!(),\n-            TyData::Dyn(_) => unimplemented!(),\n+            TyKind::InferenceVar(_, _) => unimplemented!(),\n+            TyKind::Dyn(_) => unimplemented!(),\n         };\n         interner.tcx.mk_ty(kind)\n     }\n@@ -909,7 +842,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n-                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General));\n+                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General));\n                     }\n                     Entry::Occupied(entry) => match entry.get() {\n                         chalk_ir::VariableKind::Ty(_) => {}"}, {"sha": "b117e28875e768649238bc790d20a7ebd21b584b", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299a65ff71413de0fc26d880219402ceb7fa1bcb/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=299a65ff71413de0fc26d880219402ceb7fa1bcb", "patch": "@@ -69,15 +69,15 @@ crate fn evaluate_goal<'tcx>(\n                     CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n                     CanonicalVarKind::Ty(ty) => match ty {\n                         CanonicalTyVarKind::General(ui) => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n                             chalk_ir::UniverseIndex { counter: ui.index() },\n                         ),\n                         CanonicalTyVarKind::Int => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Integer),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Integer),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                         CanonicalTyVarKind::Float => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Float),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Float),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                     },\n@@ -97,7 +97,8 @@ crate fn evaluate_goal<'tcx>(\n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n     let db = ChalkRustIrDatabase { interner, reempty_placeholder };\n-    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &lowered_goal));\n+    let solution = solver.solve(&db, &lowered_goal);\n+    debug!(?obligation, ?solution, \"evaluatate goal\");\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't"}]}