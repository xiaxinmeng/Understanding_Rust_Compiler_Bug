{"sha": "007651cd267ee8af88384d968183a1dee0265919", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNzY1MWNkMjY3ZWU4YWY4ODM4NGQ5NjgxODNhMWRlZTAyNjU5MTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-28T21:35:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-30T06:02:55Z"}, "message": "Require documentation by default for libstd\n\nAdds documentation for various things that I understand.\nAdds #[allow(missing_doc)] for lots of things that I don't understand.", "tree": {"sha": "dac8928949cf8c96c6d546f3a0a4b592f0ab9ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac8928949cf8c96c6d546f3a0a4b592f0ab9ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007651cd267ee8af88384d968183a1dee0265919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007651cd267ee8af88384d968183a1dee0265919", "html_url": "https://github.com/rust-lang/rust/commit/007651cd267ee8af88384d968183a1dee0265919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007651cd267ee8af88384d968183a1dee0265919/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a5d887b58ff9833a968e7a0d28282b915e01de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5d887b58ff9833a968e7a0d28282b915e01de8", "html_url": "https://github.com/rust-lang/rust/commit/4a5d887b58ff9833a968e7a0d28282b915e01de8"}], "stats": {"total": 768, "additions": 699, "deletions": 69}, "files": [{"sha": "23f901c23ed2dc11f707518da3feab9080ea1790", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -101,6 +101,9 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n }\n \n // Appending\n+\n+/// Iterates over the `rhs` vector, copying each element and appending it to the\n+/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline(always)]\n pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n@@ -211,6 +214,9 @@ pub mod raw {\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n+    /**\n+     * Pushes a new value onto this vector.\n+     */\n     #[inline(always)]\n     pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n         let repr: **VecRepr = transmute_copy(&v);\n@@ -223,7 +229,7 @@ pub mod raw {\n     }\n \n     #[inline(always)] // really pretty please\n-    pub unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n+    unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n         let repr: **mut VecRepr = ::cast::transmute(v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n@@ -232,7 +238,7 @@ pub mod raw {\n         move_val_init(&mut(*p), initval);\n     }\n \n-    pub unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n+    unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n         reserve_at_least(&mut *v, v.len() + 1u);\n         push_fast(v, initval);\n     }"}, {"sha": "2109568a0a4e03cd871c9cc4bf744299f6185482", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -27,6 +27,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     dest\n }\n \n+/// Casts the value at `src` to U. The two types must have the same length.\n #[cfg(target_word_size = \"32\", not(stage0))]\n #[inline(always)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n@@ -37,6 +38,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     dest\n }\n \n+/// Casts the value at `src` to U. The two types must have the same length.\n #[cfg(target_word_size = \"64\", not(stage0))]\n #[inline(always)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {"}, {"sha": "f6d4e966db9ea956d84cfb248d9949210841bf2c", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -23,6 +23,7 @@ Similar to a mutable option type, but friendlier.\n \n #[mutable]\n #[deriving(Clone, DeepClone, Eq)]\n+#[allow(missing_doc)]\n pub struct Cell<T> {\n     priv value: Option<T>\n }\n@@ -32,6 +33,7 @@ pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(value) }\n }\n \n+/// Creates a new empty cell with no value inside.\n pub fn empty_cell<T>() -> Cell<T> {\n     Cell { value: None }\n }"}, {"sha": "073ced8988adaec2c4ce749cc47813056f5a8312", "filename": "src/libstd/char.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -53,8 +53,12 @@ use cmp::{Eq, Ord};\n     Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n+/// Returns whether the specified character is considered a unicode alphabetic\n+/// character\n pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n+#[allow(missing_doc)]\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n+#[allow(missing_doc)]\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n ///\n@@ -256,6 +260,7 @@ pub fn len_utf8_bytes(c: char) -> uint {\n     )\n }\n \n+#[allow(missing_doc)]\n pub trait Char {\n     fn is_alphabetic(&self) -> bool;\n     fn is_XID_start(&self) -> bool;"}, {"sha": "f74d9abda8b2891971ba56765d225e8da31f7552", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -24,6 +24,7 @@ by convention implementing the `Clone` trait and calling the\n \n use core::kinds::Const;\n \n+/// A common trait for cloning an object.\n pub trait Clone {\n     /// Returns a copy of the value. The contents of owned pointers\n     /// are copied to maintain uniqueness, while the contents of\n@@ -85,6 +86,8 @@ clone_impl!(())\n clone_impl!(bool)\n clone_impl!(char)\n \n+/// A trait distinct from `Clone` which represents \"deep copies\" of things like\n+/// managed boxes which would otherwise not be copied.\n pub trait DeepClone {\n     /// Return a deep copy of the value. Unlike `Clone`, the contents of shared pointer types\n     /// *are* copied. Note that this is currently unimplemented for managed boxes, as"}, {"sha": "55530f181a11b5aa6d69e88780468971a418fe7f", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -20,6 +20,8 @@ and `Eq` to overload the `==` and `!=` operators.\n \n */\n \n+#[allow(missing_doc)];\n+\n /**\n * Trait for values that can be compared for equality and inequality.\n *"}, {"sha": "e044a73b338fe7a1ee054ebd90cd4341667ff79e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -12,6 +12,8 @@\n Message passing\n */\n \n+#[allow(missing_doc)];\n+\n use cast::{transmute, transmute_mut};\n use container::Container;\n use either::{Either, Left, Right};"}, {"sha": "eed61aab5c0bceeb51fcf3ca67893e9260c1c4dc", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,6 +10,8 @@\n \n /*! Condition handling */\n \n+#[allow(missing_doc)];\n+\n use local_data::{local_data_pop, local_data_set};\n use local_data;\n use prelude::*;"}, {"sha": "065582e2e0d2e93e2c091ec1e90d27331d4bc34b", "filename": "src/libstd/container.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -12,6 +12,8 @@\n \n use option::Option;\n \n+/// A trait to represent the abstract idea of a container. The only concrete\n+/// knowledge known is the number of elements contained within.\n pub trait Container {\n     /// Return the number of elements in the container\n     fn len(&const self) -> uint;\n@@ -20,16 +22,19 @@ pub trait Container {\n     fn is_empty(&const self) -> bool;\n }\n \n+/// A trait to represent mutable containers\n pub trait Mutable: Container {\n     /// Clear the container, removing all values.\n     fn clear(&mut self);\n }\n \n+/// A map is a key-value store where values may be looked up by their keys. This\n+/// trait provides basic operations to operate on these stores.\n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n \n-    // Visits all keys and values\n+    /// Visits all keys and values\n     fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool) -> bool;\n \n     /// Visit all keys\n@@ -65,6 +70,9 @@ pub trait Map<K, V>: Mutable {\n     fn pop(&mut self, k: &K) -> Option<V>;\n }\n \n+/// A set is a group of objects which are each distinct from one another. This\n+/// trait represents actions which can be performed on sets to manipulate and\n+/// iterate over them.\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;"}, {"sha": "82e0d4b54d281c8978ca37b01cf0f40c60b3c970", "filename": "src/libstd/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -56,12 +56,15 @@ they contained the following prologue:\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n+// NOTE: remove these two attributes after the next snapshot\n+#[no_core]; // for stage0\n+#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n \n // Don't link to std. We are std.\n-#[no_core]; // for stage0\n #[no_std];\n \n #[deny(non_camel_case_types)];\n+#[deny(missing_doc)];\n \n // Make core testable by not duplicating lang items. See #2912\n #[cfg(test)] extern mod realstd(name = \"std\");"}, {"sha": "d2f1a895e1e2ba6887e92046e9a82f33e5ab41b0", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -12,6 +12,10 @@\n \n use option::Option;\n \n+/// A trait to abstract the idea of creating a new instance of a type from a\n+/// string.\n pub trait FromStr {\n+    /// Parses a string `s` to return an optional value of this type. If the\n+    /// string is ill-formatted, the None is returned.\n     fn from_str(s: &str) -> Option<Self>;\n }"}, {"sha": "e902244578634d8489106cf65da17ad8fed62a98", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -19,6 +19,8 @@\n  * CPRNG like rand::rng.\n  */\n \n+#[allow(missing_doc)];\n+\n use container::Container;\n use old_iter::BaseIter;\n use rt::io::Writer;"}, {"sha": "72f92bc1522e911b33cc2af425e1b86dde5650a8", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -34,6 +34,14 @@ struct Bucket<K,V> {\n     value: V,\n }\n \n+/// A hash map implementation which uses linear probing along with the SipHash\n+/// hash function for internal state. This means that the order of all hash maps\n+/// is randomized by keying each hash map randomly on creation.\n+///\n+/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// this can frequently be achieved by just implementing the `Eq` and\n+/// `IterBytes` traits as `Hash` is automatically implemented for types that\n+/// implement `IterBytes`.\n pub struct HashMap<K,V> {\n     priv k0: u64,\n     priv k1: u64,\n@@ -53,6 +61,7 @@ fn resize_at(capacity: uint) -> uint {\n     ((capacity as float) * 3. / 4.) as uint\n }\n \n+/// Creates a new hash map with the specified capacity.\n pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n     initial_capacity: uint) -> HashMap<K, V> {\n     let mut r = rand::task_rng();\n@@ -539,6 +548,9 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n }\n \n+/// An implementation of a hash set using the underlying representation of a\n+/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n+/// requires that the elements implement the `Eq` and `Hash` traits.\n pub struct HashSet<T> {\n     priv map: HashMap<T, ()>\n }"}, {"sha": "011c56ac7c14ae9f042f0c09dcdeca48581709d3", "filename": "src/libstd/io.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -44,6 +44,8 @@ implement `Reader` and `Writer`, where appropriate.\n \n */\n \n+#[allow(missing_doc)];\n+\n use result::Result;\n \n use container::Container;"}, {"sha": "e5d79d79fcef34c9aa8a015956301fdd4566f621", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -46,6 +46,7 @@ use vec::OwnedVector;\n use num::{One, Zero};\n use ops::{Add, Mul};\n \n+#[allow(missing_doc)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool) -> bool;\n }"}, {"sha": "b13c4ca23e6ccab3bf8ecd21ee2250bacc5f89e1", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 361, "deletions": 5, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -23,6 +23,9 @@ use num::{Zero, One};\n use num;\n use prelude::*;\n \n+/// An interface for dealing with \"external iterators\". These types of iterators\n+/// can be resumed at any time as all state is stored internally as opposed to\n+/// being located on the call stack.\n pub trait Iterator<A> {\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n     fn next(&mut self) -> Option<A>;\n@@ -33,26 +36,307 @@ pub trait Iterator<A> {\n ///\n /// In the future these will be default methods instead of a utility trait.\n pub trait IteratorUtil<A> {\n+    /// Chan this iterator with another, returning a new iterator which will\n+    /// finish iterating over the current iterator, and then it will iterate\n+    /// over the other specified iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [0];\n+    /// let b = [1];\n+    /// let mut it = a.iter().chain(b.iter());\n+    /// assert_eq!(it.next().get(), &0);\n+    /// assert_eq!(it.next().get(), &1);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<Self, U>;\n+\n+    /// Creates an iterator which iterates over both this and the specified\n+    /// iterators simultaneously, yielding the two elements as pairs. When\n+    /// either iterator returns None, all further invocations of next() will\n+    /// return None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [0];\n+    /// let b = [1];\n+    /// let mut it = a.iter().zip(b.iter());\n+    /// assert_eq!(it.next().get(), (&0, &1));\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<Self, U>;\n+\n     // FIXME: #5898: should be called map\n+    /// Creates a new iterator which will apply the specified function to each\n+    /// element returned by the first, yielding the mapped element instead. This\n+    /// similar to the `vec::map` function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2];\n+    /// let mut it = a.iter().transform(|&x| 2 * x);\n+    /// assert_eq!(it.next().get(), 2);\n+    /// assert_eq!(it.next().get(), 4);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn transform<'r, B>(self, f: &'r fn(A) -> B) -> MapIterator<'r, A, B, Self>;\n+\n+    /// Creates an iterator which applies the predicate to each element returned\n+    /// by this iterator. Only elements which have the predicate evaluate to\n+    /// `true` will be yielded.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2];\n+    /// let mut it = a.iter().filter(|&x| *x > 1);\n+    /// assert_eq!(it.next().get(), &2);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> FilterIterator<'r, A, Self>;\n+\n+    /// Creates an iterator which both filters and maps elements at the same\n+    /// If the specified function returns None, the element is skipped.\n+    /// Otherwise the option is unwrapped and the new value is yielded.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2];\n+    /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n+    /// assert_eq!(it.next().get(), 4);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn filter_map<'r,  B>(self, f: &'r fn(A) -> Option<B>) -> FilterMapIterator<'r, A, B, Self>;\n+\n+    /// Creates an iterator which yields a pair of the value returned by this\n+    /// iterator plus the current index of iteration.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [100, 200];\n+    /// let mut it = a.iter().enumerate();\n+    /// assert_eq!(it.next().get(), (0, &100));\n+    /// assert_eq!(it.next().get(), (1, &200));\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn enumerate(self) -> EnumerateIterator<Self>;\n+\n+    /// Creates an iterator which invokes the predicate on elements until it\n+    /// returns true. Once the predicate returns true, all further elements are\n+    /// yielded.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 2, 1];\n+    /// let mut it = a.iter().skip_while(|&a| *a < 3);\n+    /// assert_eq!(it.next().get(), &3);\n+    /// assert_eq!(it.next().get(), &2);\n+    /// assert_eq!(it.next().get(), &1);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhileIterator<'r, A, Self>;\n+\n+    /// Creates an iterator which yields elements so long as the predicate\n+    /// returns true. After the predicate returns false for the first time, no\n+    /// further elements will be yielded.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 2, 1];\n+    /// let mut it = a.iter().take_while(|&a| *a < 3);\n+    /// assert_eq!(it.next().get(), &1);\n+    /// assert_eq!(it.next().get(), &2);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, Self>;\n+\n+    /// Creates an iterator which skips the first `n` elements of this iterator,\n+    /// and then it yields all further items.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter().skip(3);\n+    /// assert_eq!(it.next().get(), &4);\n+    /// assert_eq!(it.next().get(), &5);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn skip(self, n: uint) -> SkipIterator<Self>;\n+\n+    /// Creates an iterator which yields the first `n` elements of this\n+    /// iterator, and then it will always return None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter().take(3);\n+    /// assert_eq!(it.next().get(), &1);\n+    /// assert_eq!(it.next().get(), &2);\n+    /// assert_eq!(it.next().get(), &3);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn take(self, n: uint) -> TakeIterator<Self>;\n+\n+    /// Creates a new iterator which behaves in a similar fashion to foldl.\n+    /// There is a state which is passed between each iteration and can be\n+    /// mutated as necessary. The yielded values from the closure are yielded\n+    /// from the ScanIterator instance when not None.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter().scan(1, |fac, &x| {\n+    ///   *fac = *fac * x;\n+    ///   Some(*fac)\n+    /// });\n+    /// assert_eq!(it.next().get(), 1);\n+    /// assert_eq!(it.next().get(), 2);\n+    /// assert_eq!(it.next().get(), 6);\n+    /// assert_eq!(it.next().get(), 24);\n+    /// assert_eq!(it.next().get(), 120);\n+    /// assert!(it.next().is_none());\n+    /// ~~~\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, Self, St>;\n+\n+    /// An adaptation of an external iterator to the for-loop protocol of rust.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// for Counter::new(0, 10).advance |i| {\n+    ///     io::println(fmt!(\"%d\", i));\n+    /// }\n+    /// ~~~\n     fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n+\n+    /// Loops through the entire iterator, accumulating all of the elements into\n+    /// a vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let b = a.iter().transform(|&x| x).to_vec();\n+    /// assert!(a == b);\n+    /// ~~~\n     fn to_vec(&mut self) -> ~[A];\n+\n+    /// Loops through `n` iterations, returning the `n`th element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.nth(2).get() == &3);\n+    /// assert!(it.nth(2) == None);\n+    /// ~~~\n     fn nth(&mut self, n: uint) -> Option<A>;\n+\n+    /// Loops through the entire iterator, returning the last element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().last().get() == &5);\n+    /// ~~~\n     fn last(&mut self) -> Option<A>;\n+\n+    /// Performs a fold operation over the entire iterator, returning the\n+    /// eventual state at the end of the iteration.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n+    /// ~~~\n     fn fold<B>(&mut self, start: B, f: &fn(B, A) -> B) -> B;\n+\n+    /// Counts the number of elements in this iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.count() == 5);\n+    /// assert!(it.count() == 0);\n+    /// ~~~\n     fn count(&mut self) -> uint;\n+\n+    /// Tests whether the predicate holds true for all elements in the iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().all(|&x| *x > 0));\n+    /// assert!(!a.iter().all(|&x| *x > 2));\n+    /// ~~~\n     fn all(&mut self, f: &fn(&A) -> bool) -> bool;\n+\n+    /// Tests whether any element of an iterator satisfies the specified\n+    /// predicate.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.any(|&x| *x == 3));\n+    /// assert!(!it.any(|&x| *x == 3));\n+    /// ~~~\n     fn any(&mut self, f: &fn(&A) -> bool) -> bool;\n }\n \n@@ -186,7 +470,19 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n }\n \n+/// A trait for iterators over elements which can be added together\n pub trait AdditiveIterator<A> {\n+    /// Iterates over the entire iterator, summing up all the elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter().transform(|&x| x);\n+    /// assert!(it.sum() == 15);\n+    /// ~~~\n     fn sum(&mut self) -> A;\n }\n \n@@ -195,7 +491,23 @@ impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n     fn sum(&mut self) -> A { self.fold(Zero::zero::<A>(), |s, x| s + x) }\n }\n \n+/// A trait for iterators over elements whose elements can be multiplied\n+/// together.\n pub trait MultiplicativeIterator<A> {\n+    /// Iterates over the entire iterator, multiplying all the elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// fn factorial(n: uint) -> uint {\n+    ///     Counter::new(1u, 1).take_while(|&i| i <= n).product()\n+    /// }\n+    /// assert!(factorial(0) == 1);\n+    /// assert!(factorial(1) == 1);\n+    /// assert!(factorial(5) == 120);\n+    /// ~~~\n     fn product(&mut self) -> A;\n }\n \n@@ -204,8 +516,31 @@ impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n     fn product(&mut self) -> A { self.fold(One::one::<A>(), |p, x| p * x) }\n }\n \n+/// A trait for iterators over elements which can be compared to one another.\n+/// The type of each element must ascribe to the `Ord` trait.\n pub trait OrdIterator<A> {\n+    /// Consumes the entire iterator to return the maximum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().max().get() == &5);\n+    /// ~~~\n     fn max(&mut self) -> Option<A>;\n+\n+    /// Consumes the entire iterator to return the minimum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::iterator::*;\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().min().get() == &1);\n+    /// ~~~\n     fn min(&mut self) -> Option<A>;\n }\n \n@@ -231,6 +566,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n     }\n }\n \n+/// An iterator which strings two iterators together\n pub struct ChainIterator<T, U> {\n     priv a: T,\n     priv b: U,\n@@ -253,6 +589,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<T, U> {\n     }\n }\n \n+/// An iterator which iterates two other iterators simultaneously\n pub struct ZipIterator<T, U> {\n     priv a: T,\n     priv b: U\n@@ -268,6 +605,7 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U\n     }\n }\n \n+/// An iterator which maps the values of `iter` with `f`\n pub struct MapIterator<'self, A, B, T> {\n     priv iter: T,\n     priv f: &'self fn(A) -> B\n@@ -283,6 +621,7 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n     }\n }\n \n+/// An iterator which filters the elements of `iter` with `predicate`\n pub struct FilterIterator<'self, A, T> {\n     priv iter: T,\n     priv predicate: &'self fn(&A) -> bool\n@@ -302,6 +641,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n     }\n }\n \n+/// An iterator which uses `f` to both filter and map elements from `iter`\n pub struct FilterMapIterator<'self, A, B, T> {\n     priv iter: T,\n     priv f: &'self fn(A) -> Option<B>\n@@ -320,6 +660,7 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMapIterator<'self, A, B,\n     }\n }\n \n+/// An iterator which yields the current count and the element during iteration\n pub struct EnumerateIterator<T> {\n     priv iter: T,\n     priv count: uint\n@@ -339,6 +680,7 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<T> {\n     }\n }\n \n+/// An iterator which rejects elements while `predicate` is true\n pub struct SkipWhileIterator<'self, A, T> {\n     priv iter: T,\n     priv flag: bool,\n@@ -370,6 +712,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhileIterator<'self, A, T> {\n     }\n }\n \n+/// An iterator which only accepts elements while `predicate` is true\n pub struct TakeWhileIterator<'self, A, T> {\n     priv iter: T,\n     priv flag: bool,\n@@ -397,6 +740,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhileIterator<'self, A, T> {\n     }\n }\n \n+/// An iterator which skips over `n` elements of `iter`\n pub struct SkipIterator<T> {\n     priv iter: T,\n     priv n: uint\n@@ -428,6 +772,7 @@ impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<T> {\n     }\n }\n \n+/// An iterator which only iterates over the first `n` iterations of `iter`.\n pub struct TakeIterator<T> {\n     priv iter: T,\n     priv n: uint\n@@ -446,9 +791,12 @@ impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<T> {\n     }\n }\n \n+/// An iterator to maintain state while iterating another iterator\n pub struct ScanIterator<'self, A, B, T, St> {\n     priv iter: T,\n     priv f: &'self fn(&mut St, A) -> Option<B>,\n+\n+    /// The current internal state to be passed to the closure next.\n     state: St\n }\n \n@@ -459,14 +807,18 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for ScanIterator<'self, A, B,\n     }\n }\n \n+/// An iterator which just modifies the contained state throughout iteration.\n pub struct UnfoldrIterator<'self, A, St> {\n     priv f: &'self fn(&mut St) -> Option<A>,\n+    /// Internal state that will be yielded on the next iteration\n     state: St\n }\n \n-pub impl<'self, A, St> UnfoldrIterator<'self, A, St> {\n+impl<'self, A, St> UnfoldrIterator<'self, A, St> {\n+    /// Creates a new iterator with the specified closure as the \"iterator\n+    /// function\" and an initial state to eventually pass to the iterator\n     #[inline]\n-    fn new(f: &'self fn(&mut St) -> Option<A>, initial_state: St)\n+    pub fn new(f: &'self fn(&mut St) -> Option<A>, initial_state: St)\n         -> UnfoldrIterator<'self, A, St> {\n         UnfoldrIterator {\n             f: f,\n@@ -482,15 +834,19 @@ impl<'self, A, St> Iterator<A> for UnfoldrIterator<'self, A, St> {\n     }\n }\n \n-/// An infinite iterator starting at `start` and advancing by `step` with each iteration\n+/// An infinite iterator starting at `start` and advancing by `step` with each\n+/// iteration\n pub struct Counter<A> {\n+    /// The current state the counter is at (next value to be yielded)\n     state: A,\n+    /// The amount that this iterator is stepping by\n     step: A\n }\n \n-pub impl<A> Counter<A> {\n+impl<A> Counter<A> {\n+    /// Creates a new counter with the specified start/step\n     #[inline(always)]\n-    fn new(start: A, step: A) -> Counter<A> {\n+    pub fn new(start: A, step: A) -> Counter<A> {\n         Counter{state: start, step: step}\n     }\n }"}, {"sha": "b6c22f29c3e5a35e0e7d6533b40fe663a1dd6bac", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -37,6 +37,8 @@ instead implement `Clone`.\n \n */\n \n+#[allow(missing_doc)];\n+\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty."}, {"sha": "142b2f7d6af58c7d84d565fe6af7b83a9d2f9aae", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -64,6 +64,7 @@\n */\n \n #[allow(non_camel_case_types)];\n+#[allow(missing_doc)];\n \n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code."}, {"sha": "c2f854179b8ddca649db224163753f38bc97c6fb", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -36,6 +36,7 @@ pub fn console_off() {\n \n #[cfg(not(test))]\n #[lang=\"log_type\"]\n+#[allow(missing_doc)]\n pub fn log_type<T>(level: u32, object: &T) {\n     use cast;\n     use container::Container;"}, {"sha": "fb6ac7603ca76808560b119fd22fa05da4de80d0", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -21,13 +21,15 @@ pub mod raw {\n     pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n     pub static RC_IMMORTAL : uint = 0x77777777;\n \n+    #[allow(missing_doc)]\n     pub struct BoxHeaderRepr {\n         ref_count: uint,\n         type_desc: *TyDesc,\n         prev: *BoxRepr,\n         next: *BoxRepr,\n     }\n \n+    #[allow(missing_doc)]\n     pub struct BoxRepr {\n         header: BoxHeaderRepr,\n         data: u8"}, {"sha": "96d3b79e338503c18035132bc182b0f3ab7abbf0", "filename": "src/libstd/num/cmath.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n // function names are almost identical to C's libmath, a few have been\n // renamed, grep for \"rename:\"\n "}, {"sha": "62ce5ed65e10cfb9fe5f8021384576df69802841", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! Operations and constants for `f32`\n+#[allow(missing_doc)];\n \n use libc::c_int;\n use num::{Zero, One, strconv};"}, {"sha": "de44d861645b3a5a21955d27fff711477581e136", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for `f64`\n \n+#[allow(missing_doc)];\n+\n use libc::c_int;\n use num::{Zero, One, strconv};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};"}, {"sha": "97d661d8fe2e7387a30887d60c0c9a0c910cc266", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -20,6 +20,8 @@\n \n // PORT this must match in width according to architecture\n \n+#[allow(missing_doc)];\n+\n use f64;\n use libc::c_int;\n use num::{Zero, One, strconv};"}, {"sha": "023f44c433c00f21c3808c77da60c16dcc800d87", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -26,12 +26,17 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n+/// Calculates the sum of two numbers\n #[inline(always)]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n+/// Subtracts the second number from the first\n #[inline(always)]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n+/// Multiplies two numbers together\n #[inline(always)]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n+/// Divides the first argument by the second argument (using integer division)\n+/// Divides the first argument by the second argument (using integer division)\n #[inline(always)]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n \n@@ -58,16 +63,22 @@ pub fn div(x: $T, y: $T) -> $T { x / y }\n #[inline(always)]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n+/// Returns true iff `x < y`\n #[inline(always)]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n+/// Returns true iff `x <= y`\n #[inline(always)]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n+/// Returns true iff `x == y`\n #[inline(always)]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n+/// Returns true iff `x != y`\n #[inline(always)]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n+/// Returns true iff `x >= y`\n #[inline(always)]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n+/// Returns true iff `x > y`\n #[inline(always)]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n "}, {"sha": "91631d3c9b904375b881a70afadb459626f5cfeb", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n //! An interface for numeric types\n+\n+#[allow(missing_doc)];\n+\n use cmp::{Eq, ApproxEq, Ord};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};"}, {"sha": "30efe9a392233f3330b30a773a34ddd2efd72d30", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use container::Container;\n use core::cmp::{Ord, Eq};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};"}, {"sha": "c2e722f9e0eb5d838b539d1afb18027c4b968c56", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -27,27 +27,39 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n+/// Calculates the sum of two numbers\n #[inline(always)]\n pub fn add(x: $T, y: $T) -> $T { x + y }\n+/// Subtracts the second number from the first\n #[inline(always)]\n pub fn sub(x: $T, y: $T) -> $T { x - y }\n+/// Multiplies two numbers together\n #[inline(always)]\n pub fn mul(x: $T, y: $T) -> $T { x * y }\n+/// Divides the first argument by the second argument (using integer division)\n #[inline(always)]\n pub fn div(x: $T, y: $T) -> $T { x / y }\n+/// Calculates the integer remainder when x is divided by y (equivalent to the\n+/// '%' operator)\n #[inline(always)]\n pub fn rem(x: $T, y: $T) -> $T { x % y }\n \n+/// Returns true iff `x < y`\n #[inline(always)]\n pub fn lt(x: $T, y: $T) -> bool { x < y }\n+/// Returns true iff `x <= y`\n #[inline(always)]\n pub fn le(x: $T, y: $T) -> bool { x <= y }\n+/// Returns true iff `x == y`\n #[inline(always)]\n pub fn eq(x: $T, y: $T) -> bool { x == y }\n+/// Returns true iff `x != y`\n #[inline(always)]\n pub fn ne(x: $T, y: $T) -> bool { x != y }\n+/// Returns true iff `x >= y`\n #[inline(always)]\n pub fn ge(x: $T, y: $T) -> bool { x >= y }\n+/// Returns true iff `x > y`\n #[inline(always)]\n pub fn gt(x: $T, y: $T) -> bool { x > y }\n "}, {"sha": "22ca356fa9b18b08f271a14d61f2af67962af6be", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -14,6 +14,8 @@\n \n */\n \n+#[allow(missing_doc)];\n+\n use cmp::{Eq, Ord};\n use kinds::Copy;\n use option::{None, Option, Some};"}, {"sha": "77cfe62e495278249fb750c0da2654a756094c79", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,6 +10,8 @@\n \n //! Traits for the built-in operators\n \n+#[allow(missing_doc)];\n+\n #[lang=\"drop\"]\n pub trait Drop {\n     fn finalize(&self);  // FIXME(#4332): Rename to \"drop\"? --pcwalton"}, {"sha": "cc36dcb92a2d4b4823c2f1ea0625af29b1fcc49f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -26,6 +26,8 @@\n  * to write OS-ignorant code by default.\n  */\n \n+#[allow(missing_doc)];\n+\n use cast;\n use io;\n use libc;\n@@ -45,6 +47,7 @@ use vec;\n pub use libc::fclose;\n pub use os::consts::*;\n \n+/// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: c_int) -> c_int {\n     unsafe {\n         libc::close(fd)\n@@ -171,6 +174,8 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n     }\n }\n \n+/// Returns a vector of (variable, value) pairs for all the environment\n+/// variables of the current process.\n pub fn env() -> ~[(~str,~str)] {\n     unsafe {\n         #[cfg(windows)]\n@@ -236,6 +241,8 @@ pub fn env() -> ~[(~str,~str)] {\n }\n \n #[cfg(unix)]\n+/// Fetches the environment variable `n` from the current process, returning\n+/// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n         do with_env_lock {\n@@ -251,6 +258,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n }\n \n #[cfg(windows)]\n+/// Fetches the environment variable `n` from the current process, returning\n+/// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n         do with_env_lock {\n@@ -266,6 +275,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n \n \n #[cfg(unix)]\n+/// Sets the environment variable `n` to the value `v` for the currently running\n+/// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         do with_env_lock {\n@@ -280,6 +291,8 @@ pub fn setenv(n: &str, v: &str) {\n \n \n #[cfg(windows)]\n+/// Sets the environment variable `n` to the value `v` for the currently running\n+/// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         do with_env_lock {\n@@ -422,13 +435,14 @@ fn dup2(src: c_int, dst: c_int) -> c_int {\n     }\n }\n \n-\n+/// Returns the proper dll filename for the given basename of a file.\n pub fn dll_filename(base: &str) -> ~str {\n     return str::to_owned(DLL_PREFIX) + str::to_owned(base) +\n            str::to_owned(DLL_SUFFIX)\n }\n \n-\n+/// Optionally returns the filesystem path to the current executable which is\n+/// running. If any failure occurs, None is returned.\n pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n@@ -828,6 +842,8 @@ pub fn remove_dir(p: &Path) -> bool {\n     }\n }\n \n+/// Changes the current working directory to the specified path, returning\n+/// whether the change was completed successfully or not.\n pub fn change_dir(p: &Path) -> bool {\n     return chdir(p);\n \n@@ -981,6 +997,7 @@ pub fn remove_file(p: &Path) -> bool {\n }\n \n #[cfg(unix)]\n+/// Returns the platform-specific value of errno\n pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n@@ -1012,6 +1029,7 @@ pub fn errno() -> int {\n }\n \n #[cfg(windows)]\n+/// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n     use libc::types::os::arch::extra::DWORD;\n \n@@ -1211,6 +1229,11 @@ struct OverriddenArgs {\n \n fn overridden_arg_key(_v: @OverriddenArgs) {}\n \n+/// Returns the arguments which this program was started with (normally passed\n+/// via the command line).\n+///\n+/// The return value of the function can be changed by invoking the\n+/// `os::set_args` function.\n pub fn args() -> ~[~str] {\n     unsafe {\n         match local_data::local_data_get(overridden_arg_key) {\n@@ -1220,6 +1243,9 @@ pub fn args() -> ~[~str] {\n     }\n }\n \n+/// For the current task, overrides the task-local cache of the arguments this\n+/// program had when it started. These new arguments are only available to the\n+/// current task via the `os::args` method.\n pub fn set_args(new_args: ~[~str]) {\n     unsafe {\n         let overridden_args = @OverriddenArgs { val: copy new_args };"}, {"sha": "39bd57b3c37930d1d958f66a753fbe83da1e12f8", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -14,6 +14,8 @@ Cross-platform file path handling\n \n */\n \n+#[allow(missing_doc)];\n+\n use container::Container;\n use cmp::Eq;\n use libc;"}, {"sha": "5fbf97dccc8771891ac4d4ada5a0237b1cb97349", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -82,6 +82,8 @@ bounded and unbounded protocols allows for less code duplication.\n \n */\n \n+#[allow(missing_doc)];\n+\n use container::Container;\n use cast::{forget, transmute, transmute_copy};\n use either::{Either, Left, Right};"}, {"sha": "0f7cf3f6bdf43b690122412032f3017ade5f2a6c", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -120,6 +120,12 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n+/**\n+ * Copies data from one location to another\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n #[inline(always)]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n@@ -135,6 +141,13 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n     memmove32(dst as *mut u8, src as *u8, n as u32);\n }\n \n+/**\n+ * Copies data from one location to another. This uses memcpy instead of memmove\n+ * to take advantage of the knowledge that the memory does not overlap.\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n #[inline(always)]\n #[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n@@ -150,6 +163,13 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n     memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n+/**\n+ * Copies data from one location to another. This uses memcpy instead of memmove\n+ * to take advantage of the knowledge that the memory does not overlap.\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n #[inline(always)]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n@@ -164,13 +184,21 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n     libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n \n+/**\n+ * Invokes memset on the specified pointer, setting `count` bytes of memory\n+ * starting at `dst` to `c`.\n+ */\n #[inline(always)]\n #[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset32;\n     memset32(dst, c, count as u32);\n }\n \n+/**\n+ * Invokes memset on the specified pointer, setting `count` bytes of memory\n+ * starting at `dst` to `c`.\n+ */\n #[inline(always)]\n #[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n@@ -268,6 +296,7 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n     array_each_with_len(arr, len, cb);\n }\n \n+#[allow(missing_doc)]\n pub trait Ptr<T> {\n     fn is_null(&const self) -> bool;\n     fn is_not_null(&const self) -> bool;"}, {"sha": "07a5acbdde5579440a80d823a3cae1dc792b3d50", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -58,6 +58,8 @@ pub mod distributions;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n+    /// Generates a random instance of this type using the specified source of\n+    /// randomness\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n@@ -256,10 +258,13 @@ pub trait Rng {\n \n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n+    /// The numerical weight of this item\n     weight: uint,\n+    /// The actual item which is being weighted\n     item: T,\n }\n \n+/// Helper functions attached to the Rng type\n pub trait RngUtil {\n     /// Return a random value of a Rand type\n     fn gen<T:Rand>(&mut self) -> T;"}, {"sha": "cadfa71e7fa9ccb1a8c5dc52af4712dca910d33f", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -14,6 +14,8 @@ Runtime type reflection\n \n */\n \n+#[allow(missing_doc)];\n+\n use intrinsic::{TyDesc, TyVisitor};\n use intrinsic::Opaque;\n use libc::c_void;"}, {"sha": "c50823f471ec12d7a2f1f35b9d403ee74ae965c5", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -14,6 +14,8 @@ More runtime type reflection\n \n */\n \n+#[allow(missing_doc)];\n+\n use cast::transmute;\n use char;\n use intrinsic;"}, {"sha": "4fe92ddb7b6fa516b550eaf11b32e6b25b450101", "filename": "src/libstd/result.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -312,6 +312,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n }\n \n #[inline(always)]\n+#[allow(missing_doc)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n     o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n "}, {"sha": "c3e3ca57a8e74d3e70319e8af073a02686e3bb6a", "filename": "src/libstd/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstackwalk.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use cast::transmute;\n use unstable::intrinsics;\n "}, {"sha": "4d41f10fdfcad626b8ceceb13ccc004dd4e00a15", "filename": "src/libstd/str.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -72,6 +72,16 @@ pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n     return unsafe { raw::from_bytes_with_null(vv) };\n }\n \n+/**\n+ * Converts a vector to a string slice without performing any allocations.\n+ *\n+ * Once the slice has been validated as utf-8, it is transmuted in-place and\n+ * returned as a '&str' instead of a '&[u8]'\n+ *\n+ * # Failure\n+ *\n+ * Fails if invalid UTF-8\n+ */\n pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     unsafe {\n         assert!(is_utf8(vector));\n@@ -741,6 +751,18 @@ pub fn each_split_str<'a,'b>(s: &'a str,\n     return true;\n }\n \n+/**\n+ * Splits the string `s` based on `sep`, yielding all splits to the iterator\n+ * function provide\n+ *\n+ * # Example\n+ *\n+ * ~~~ {.rust}\n+ * let mut v = ~[];\n+ * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n+ * assert!(v == [\"XXX\", \"YYY\"]);\n+ * ~~~\n+ */\n pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n                                       sep: &'b str,\n                                       it: &fn(&'a str) -> bool) -> bool {\n@@ -823,7 +845,7 @@ pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n  *  Fails during iteration if the string contains a non-whitespace\n  *  sequence longer than the limit.\n  */\n-pub fn _each_split_within<'a>(ss: &'a str,\n+pub fn each_split_within<'a>(ss: &'a str,\n                               lim: uint,\n                               it: &fn(&'a str) -> bool) -> bool {\n     // Just for fun, let's write this as an state machine:\n@@ -886,12 +908,6 @@ pub fn _each_split_within<'a>(ss: &'a str,\n     return cont;\n }\n \n-pub fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) -> bool {\n-    _each_split_within(ss, lim, it)\n-}\n-\n /**\n  * Replace all occurrences of one string with another\n  *\n@@ -1236,7 +1252,7 @@ pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) -> bool {\n     each_chari_reverse(s, |_, c| it(c))\n }\n \n-// Iterates over the chars in a string in reverse, with indices\n+/// Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) -> bool {\n     let mut pos = s.len();\n@@ -1814,6 +1830,12 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n     u\n }\n \n+/// Iterates over the utf-16 characters in the specified slice, yielding each\n+/// decoded unicode character to the function provided.\n+///\n+/// # Failures\n+///\n+/// * Fails on invalid utf-16 data\n pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = v.len();\n     let mut i = 0u;\n@@ -1838,13 +1860,20 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     }\n }\n \n+/**\n+ * Allocates a new string from the utf-16 slice provided\n+ */\n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     reserve(&mut buf, v.len());\n     utf16_chars(v, |ch| push_char(&mut buf, ch));\n     buf\n }\n \n+/**\n+ * Allocates a new string with the specified capacity. The string returned is\n+ * the empty string, but has capacity for much more.\n+ */\n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     reserve(&mut buf, capacity);\n@@ -1990,6 +2019,7 @@ pub fn char_at(s: &str, i: uint) -> char {\n     return char_range_at(s, i).ch;\n }\n \n+#[allow(missing_doc)]\n pub struct CharRange {\n     ch: char,\n     next: uint\n@@ -2481,6 +2511,7 @@ pub mod traits {\n #[cfg(test)]\n pub mod traits {}\n \n+#[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn all(&self, it: &fn(char) -> bool) -> bool;\n     fn any(&self, it: &fn(char) -> bool) -> bool;\n@@ -2715,6 +2746,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn to_bytes(&self) -> ~[u8] { to_bytes(*self) }\n }\n \n+#[allow(missing_doc)]\n pub trait OwnedStr {\n     fn push_str(&mut self, v: &str);\n     fn push_char(&mut self, c: char);\n@@ -2738,6 +2770,8 @@ impl Clone for ~str {\n     }\n }\n \n+/// External iterator for a string's characters. Use with the `std::iterator`\n+/// module.\n pub struct StrCharIterator<'self> {\n     priv index: uint,\n     priv string: &'self str,"}, {"sha": "5d020e229e28de7fe25128e585e90ed2db1b9ae3", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,6 +10,8 @@\n \n //! Misc low level stuff\n \n+#[allow(missing_doc)];\n+\n use option::{Some, None};\n use cast;\n use cmp::{Eq, Ord};"}, {"sha": "f6b14a515397038b9b4472fa81122f7610370fcf", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use cast;\n use cmp::Eq;\n use libc;"}, {"sha": "28fb73e6eef52b65e0920611c267db2e39be0892", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -33,6 +33,8 @@\n  * ~~~\n  */\n \n+#[allow(missing_doc)];\n+\n use prelude::*;\n \n use cast;"}, {"sha": "77e7583ebe5326659874bb46a9de3981e3cb0863", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -303,7 +303,11 @@ impl<A> IterBytes for *const A {\n     }\n }\n \n+/// A trait for converting a value to a list of bytes.\n pub trait ToBytes {\n+    /// Converts the current value to a list of bytes. This is equivalent to\n+    /// invoking iter_bytes on a type and collecting all yielded values in an\n+    /// array\n     fn to_bytes(&self, lsb0: bool) -> ~[u8];\n }\n "}, {"sha": "b4298ef069128d758a8736d186419b77bc42dfdb", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -22,13 +22,15 @@ use hash::Hash;\n use cmp::Eq;\n use old_iter::BaseIter;\n \n+/// A generic trait for converting a value to a string\n pub trait ToStr {\n+    /// Converts the value of `self` to an owned string\n     fn to_str(&self) -> ~str;\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n pub trait ToStrConsume {\n-    // Cosume and convert to a string.\n+    /// Cosume and convert to a string.\n     fn to_str_consume(self) -> ~str;\n }\n "}, {"sha": "460f29d597ac4d1793d8b6827f95c1521a340094", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -28,6 +28,7 @@ enum Child<T> {\n     Nothing\n }\n \n+#[allow(missing_doc)]\n pub struct TrieMap<T> {\n     priv root: TrieNode<T>,\n     priv length: uint\n@@ -172,6 +173,7 @@ pub impl<T> TrieMap<T> {\n     }\n }\n \n+#[allow(missing_doc)]\n pub struct TrieSet {\n     priv map: TrieMap<()>\n }"}, {"sha": "da2c52014e8f6c68c1f4ccd246154b50476782fa", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,14 +10,20 @@\n \n //! Operations on tuples\n \n+#[allow(missing_doc)];\n+\n use kinds::Copy;\n use vec;\n \n pub use self::inner::*;\n \n+/// Method extensions to pairs where both types satisfy the `Copy` bound\n pub trait CopyableTuple<T, U> {\n+    /// Return the first element of self\n     fn first(&self) -> T;\n+    /// Return the second element of self\n     fn second(&self) -> U;\n+    /// Return the results of swapping the two elements of self\n     fn swap(&self) -> (U, T);\n }\n \n@@ -47,8 +53,12 @@ impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n     }\n }\n \n+/// Method extensions for pairs where the types don't necessarily satisfy the\n+/// `Copy` bound\n pub trait ImmutableTuple<T, U> {\n+    /// Return a reference to the first element of self\n     fn first_ref<'a>(&'a self) -> &'a T;\n+    /// Return a reference to the second element of self\n     fn second_ref<'a>(&'a self) -> &'a U;\n }\n "}, {"sha": "f8f56c75a295ccd9f279d0fda22096f026c82624", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -10,6 +10,8 @@\n \n // The following code was generated by \"src/etc/unicode.py\"\n \n+#[allow(missing_doc)];\n+\n pub mod general_category {\n \n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {"}, {"sha": "18fc6af3ac66bdae7df6a95ca7619f0f4705598f", "filename": "src/libstd/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -107,13 +107,14 @@ pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n \n /// A non-copyable dummy type.\n pub struct NonCopyable {\n-    i: (),\n+    priv i: (),\n }\n \n impl Drop for NonCopyable {\n     fn finalize(&self) { }\n }\n \n+/// Creates a dummy non-copyable structure and returns it for use.\n pub fn NonCopyable() -> NonCopyable { NonCopyable { i: () } }\n \n "}, {"sha": "c02d87923c04b4b6814ace76f84051f985d42f24", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 89, "deletions": 48, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007651cd267ee8af88384d968183a1dee0265919/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=007651cd267ee8af88384d968183a1dee0265919", "patch": "@@ -129,6 +129,7 @@ pub fn len<T>(v: &const [T]) -> uint {\n }\n \n // A botch to tide us over until core and std are fully demuted.\n+#[allow(missing_doc)]\n pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n     unsafe {\n         let v: &~[T] = transmute(v);\n@@ -543,6 +544,22 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     v.pop()\n }\n \n+/// Consumes all elements, in a vector, moving them out into the / closure\n+/// provided. The vector is traversed from the start to the end.\n+///\n+/// This method does not impose any requirements on the type of the vector being\n+/// consumed, but it prevents any usage of the vector after this function is\n+/// called.\n+///\n+/// # Examples\n+///\n+/// ~~~ {.rust}\n+/// let v = ~[~\"a\", ~\"b\"];\n+/// do vec::consume(v) |i, s| {\n+///   // s has type ~str, not &~str\n+///   io::println(s + fmt!(\" %d\", i));\n+/// }\n+/// ~~~\n pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     unsafe {\n         do as_mut_buf(v) |p, ln| {\n@@ -561,6 +578,12 @@ pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     }\n }\n \n+/// Consumes all elements, in a vector, moving them out into the / closure\n+/// provided. The vectors is traversed in reverse order (from end to start).\n+///\n+/// This method does not impose any requirements on the type of the vector being\n+/// consumed, but it prevents any usage of the vector after this function is\n+/// called.\n pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     unsafe {\n         do as_mut_buf(v) |p, ln| {\n@@ -646,6 +669,16 @@ fn push_slow<T>(v: &mut ~[T], initval: T) {\n     unsafe { push_fast(v, initval) }\n }\n \n+/// Iterates over the slice `rhs`, copies each element, and then appends it to\n+/// the vector provided `v`. The `rhs` vector is traversed in-order.\n+///\n+/// # Example\n+///\n+/// ~~~ {.rust}\n+/// let mut a = ~[1];\n+/// vec::push_all(&mut a, [2, 3, 4]);\n+/// assert!(a == ~[1, 2, 3, 4]);\n+/// ~~~\n #[inline(always)]\n pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n     let new_len = v.len() + rhs.len();\n@@ -656,6 +689,17 @@ pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &const [T]) {\n     }\n }\n \n+/// Takes ownership of the vector `rhs`, moving all elements into the specified\n+/// vector `v`. This does not copy any elements, and it is illegal to use the\n+/// `rhs` vector after calling this method (because it is moved here).\n+///\n+/// # Example\n+///\n+/// ~~~ {.rust}\n+/// let mut a = ~[~1];\n+/// vec::push_all_move(&mut a, ~[~2, ~3, ~4]);\n+/// assert!(a == ~[~1, ~2, ~3, ~4]);\n+/// ~~~\n #[inline(always)]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     let new_len = v.len() + rhs.len();\n@@ -724,13 +768,18 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n }\n \n // Appending\n+\n+/// Iterates over the `rhs` vector, copying each element and appending it to the\n+/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline(always)]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n     v\n }\n \n+/// Appends one element to the vector provided. The vector itself is then\n+/// returned for use again.\n #[inline(always)]\n pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n@@ -806,6 +855,13 @@ pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     result\n }\n \n+/// Consumes a vector, mapping it into a different vector. This function takes\n+/// ownership of the supplied vector `v`, moving each element into the closure\n+/// provided to generate a new element. The vector of new elements is then\n+/// returned.\n+///\n+/// The original vector `v` cannot be used after this function call (it is moved\n+/// inside), but there are no restrictions on the type of the vector.\n pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(v) |_i, x| {\n@@ -1444,8 +1500,8 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub fn _each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n-    //             ^^^^\n+pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n+    //            ^^^^\n     // NB---this CANNOT be &const [T]!  The reason\n     // is that you are passing it to `f()` using\n     // an immutable.\n@@ -1467,13 +1523,11 @@ pub fn _each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     return true;\n }\n \n-pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool { _each(v, f) }\n-\n /// Like `each()`, but for the case where you have\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn _each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n+pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n     let mut broke = false;\n     do as_mut_buf(v) |p, n| {\n         let mut n = n;\n@@ -1491,14 +1545,10 @@ pub fn _each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool\n     return broke;\n }\n \n-pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n-    _each_mut(v, f)\n-}\n-\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub fn _each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n+pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1510,17 +1560,13 @@ pub fn _each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     return true;\n }\n \n-pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) -> bool {\n-    _each_const(v, f)\n-}\n-\n /**\n  * Iterates over a vector's elements and indices\n  *\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn _eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n+pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return false; }\n@@ -1529,18 +1575,14 @@ pub fn _eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     return true;\n }\n \n-pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n-    _eachi(v, f)\n-}\n-\n /**\n  * Iterates over a mutable vector's elements and indices\n  *\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn _eachi_mut<'r,T>(v: &'r mut [T],\n-                        f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n+pub fn eachi_mut<'r,T>(v: &'r mut [T],\n+                       f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n     let mut i = 0;\n     for each_mut(v) |p| {\n         if !f(i, p) {\n@@ -1551,23 +1593,14 @@ pub fn _eachi_mut<'r,T>(v: &'r mut [T],\n     return true;\n }\n \n-pub fn eachi_mut<'r,T>(v: &'r mut [T],\n-                       f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n-    _eachi_mut(v, f)\n-}\n-\n /**\n  * Iterates over a vector's elements in reverse\n  *\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn _each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n-    _eachi_reverse(v, |_i, v| blk(v))\n-}\n-\n pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n-    _each_reverse(v, blk)\n+    eachi_reverse(v, |_i, v| blk(v))\n }\n \n /**\n@@ -1576,7 +1609,7 @@ pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn _eachi_reverse<'r,T>(v: &'r [T],\n+pub fn eachi_reverse<'r,T>(v: &'r [T],\n                             blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n     let mut i = v.len();\n     while i > 0 {\n@@ -1588,11 +1621,6 @@ pub fn _eachi_reverse<'r,T>(v: &'r [T],\n     return true;\n }\n \n-pub fn eachi_reverse<'r,T>(v: &'r [T],\n-                           blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n-    _eachi_reverse(v, blk)\n-}\n-\n /**\n  * Iterates over two vectors simultaneously\n  *\n@@ -1601,7 +1629,7 @@ pub fn eachi_reverse<'r,T>(v: &'r [T],\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     assert_eq!(v1.len(), v2.len());\n     for uint::range(0u, v1.len()) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1611,10 +1639,6 @@ pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     return true;\n }\n \n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n-    _each2(v1, v2, f)\n-}\n-\n /**\n  *\n  * Iterates over two vector with mutable.\n@@ -1624,7 +1648,8 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn _each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T) -> bool) -> bool {\n+pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T],\n+                       f: &fn(u: &mut U, t: &mut T) -> bool) -> bool {\n     assert_eq!(v1.len(), v2.len());\n     for uint::range(0u, v1.len()) |i| {\n         if !f(&mut v1[i], &mut v2[i]) {\n@@ -1634,10 +1659,6 @@ pub fn _each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T)\n     return true;\n }\n \n-pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T) -> bool) -> bool {\n-    _each2_mut(v1, v2, f)\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -1761,6 +1782,9 @@ pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n \n // Equality\n \n+/// Tests whether two slices are equal to one another. This is only true if both\n+/// slices are of the same length, and each of the corresponding elements return\n+/// true when queried via the `eq` function.\n fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n@@ -1773,6 +1797,9 @@ fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     true\n }\n \n+/// Similar to the `vec::eq` function, but this is defined for types which\n+/// implement `TotalEq` as opposed to types which implement `Eq`. Equality\n+/// comparisons are done via the `equals` function instead of `eq`.\n fn equals<T: TotalEq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n@@ -1946,6 +1973,7 @@ impl<'self,T> Container for &'self const [T] {\n     fn len(&const self) -> uint { len(*self) }\n }\n \n+#[allow(missing_doc)]\n pub trait CopyableVector<T> {\n     fn to_owned(&self) -> ~[T];\n }\n@@ -1965,6 +1993,7 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n@@ -2140,6 +2169,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait ImmutableEqVector<T:Eq> {\n     fn position_elem(&self, t: &T) -> Option<uint>;\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n@@ -2159,6 +2189,7 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n@@ -2208,6 +2239,7 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait OwnedVector<T> {\n     fn push(&mut self, t: T);\n     fn push_all_move(&mut self, rhs: ~[T]);\n@@ -2312,6 +2344,7 @@ impl<T> Mutable for ~[T] {\n     fn clear(&mut self) { self.truncate(0) }\n }\n \n+#[allow(missing_doc)]\n pub trait OwnedCopyableVector<T:Copy> {\n     fn push_all(&mut self, rhs: &const [T]);\n     fn grow(&mut self, n: uint, initval: &T);\n@@ -2335,6 +2368,7 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     }\n }\n \n+#[allow(missing_doc)]\n trait OwnedEqVector<T:Eq> {\n     fn dedup(&mut self);\n }\n@@ -2346,6 +2380,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait MutableVector<'self, T> {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n \n@@ -2386,6 +2421,7 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n }\n \n /// The internal 'unboxed' representation of a vector\n+#[allow(missing_doc)]\n pub struct UnboxedVecRepr {\n     fill: uint,\n     alloc: uint,\n@@ -2405,13 +2441,17 @@ pub mod raw {\n     use util;\n \n     /// The internal representation of a (boxed) vector\n+    #[allow(missing_doc)]\n     pub struct VecRepr {\n         box_header: managed::raw::BoxHeaderRepr,\n         unboxed: UnboxedVecRepr\n     }\n \n+    /// The internal representation of a slice\n     pub struct SliceRepr {\n+        /// Pointer to the base of this slice\n         data: *u8,\n+        /// The length of the slice\n         len: uint\n     }\n \n@@ -2855,13 +2895,14 @@ impl<A:Clone> Clone for ~[A] {\n     }\n }\n \n-// could be implemented with &[T] with .slice(), but this avoids bounds checks\n+/// An external iterator for vectors (use with the std::iterator module)\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: &'self T // FIXME: #5922\n }\n \n+// could be implemented with &[T] with .slice(), but this avoids bounds checks\n impl<'self, T> Iterator<&'self T> for VecIterator<'self, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {"}]}