{"sha": "023231a709b88e1a73ac86076aa5e1b4b3001276", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMzIzMWE3MDliODhlMWE3M2FjODYwNzZhYTVlMWI0YjMwMDEyNzY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-04-05T22:07:46Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-05T21:08:27Z"}, "message": "Add links on source types to go to definition", "tree": {"sha": "6d86511e64f04fec7d12ad79edec54853aa342c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d86511e64f04fec7d12ad79edec54853aa342c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/023231a709b88e1a73ac86076aa5e1b4b3001276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/023231a709b88e1a73ac86076aa5e1b4b3001276", "html_url": "https://github.com/rust-lang/rust/commit/023231a709b88e1a73ac86076aa5e1b4b3001276", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/023231a709b88e1a73ac86076aa5e1b4b3001276/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f07ae408fce782bf1058e3de808f1b6f9ab60a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07ae408fce782bf1058e3de808f1b6f9ab60a4", "html_url": "https://github.com/rust-lang/rust/commit/2f07ae408fce782bf1058e3de808f1b6f9ab60a4"}], "stats": {"total": 560, "additions": 454, "deletions": 106}, "files": [{"sha": "85c4731c6bff766f1bdc43ef0c150cd03a8d0344", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -1950,6 +1950,11 @@ impl Span {\n         Self(sp.source_callsite())\n     }\n \n+    /// Unless you know what you're doing, use [`Self::from_rustc_span`] instead!\n+    crate fn wrap(sp: rustc_span::Span) -> Span {\n+        Self(sp)\n+    }\n+\n     crate fn inner(&self) -> rustc_span::Span {\n         self.0\n     }"}, {"sha": "8b5c147b56cae49ff7e0d0a8b4f37daf14c626df", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -494,7 +494,10 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return Err(HrefError::Private);\n     }\n-\n+    // href_with_depth_inner(did, cache, || {\n+    //     let depth = CURRENT_DEPTH.with(|l| l.get());\n+    //     \"../\".repeat(depth)\n+    // })\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n             let module_fqp = to_module_fqp(shortty, fqp);"}, {"sha": "329cb3f8f09d58ae7a1c535d151ca4af2ea54819", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 152, "deletions": 34, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -5,16 +5,19 @@\n //!\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n+use crate::clean;\n use crate::html::escape::Escape;\n+use crate::html::render::Context;\n \n-use std::fmt::Display;\n+use std::fmt::{Display, Write};\n use std::iter::Peekable;\n \n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n \n-use super::format::Buffer;\n+use super::format::{self, Buffer};\n+use super::render::LinkFromSrc;\n \n /// Highlights `src`, returning the HTML output.\n crate fn render_with_highlighting(\n@@ -25,6 +28,9 @@ crate fn render_with_highlighting(\n     tooltip: Option<(Option<Edition>, &str)>,\n     edition: Edition,\n     extra_content: Option<Buffer>,\n+    file_span_lo: u32,\n+    context: Option<&Context<'_>>,\n+    root_path: &str,\n ) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     if let Some((edition_info, class)) = tooltip {\n@@ -41,7 +47,7 @@ crate fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, &src, edition);\n+    write_code(out, &src, edition, file_span_lo, context, root_path);\n     write_footer(out, playground_button);\n }\n \n@@ -57,12 +63,21 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n     }\n }\n \n-fn write_code(out: &mut Buffer, src: &str, edition: Edition) {\n+fn write_code(\n+    out: &mut Buffer,\n+    src: &str,\n+    edition: Edition,\n+    file_span_lo: u32,\n+    context: Option<&Context<'_>>,\n+    root_path: &str,\n+) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    Classifier::new(&src, edition).highlight(&mut |highlight| {\n+    Classifier::new(&src, edition, file_span_lo).highlight(&mut |highlight| {\n         match highlight {\n-            Highlight::Token { text, class } => string(out, Escape(text), class),\n+            Highlight::Token { text, class } => {\n+                string(out, Escape(text), class, context, root_path)\n+            }\n             Highlight::EnterSpan { class } => enter_span(out, class),\n             Highlight::ExitSpan => exit_span(out),\n         };\n@@ -82,14 +97,14 @@ enum Class {\n     KeyWord,\n     // Keywords that do pointer/reference stuff.\n     RefKeyWord,\n-    Self_,\n+    Self_((u32, u32)),\n     Op,\n     Macro,\n     MacroNonTerminal,\n     String,\n     Number,\n     Bool,\n-    Ident,\n+    Ident((u32, u32)),\n     Lifetime,\n     PreludeTy,\n     PreludeVal,\n@@ -105,20 +120,27 @@ impl Class {\n             Class::Attribute => \"attribute\",\n             Class::KeyWord => \"kw\",\n             Class::RefKeyWord => \"kw-2\",\n-            Class::Self_ => \"self\",\n+            Class::Self_(_) => \"self\",\n             Class::Op => \"op\",\n             Class::Macro => \"macro\",\n             Class::MacroNonTerminal => \"macro-nonterminal\",\n             Class::String => \"string\",\n             Class::Number => \"number\",\n             Class::Bool => \"bool-val\",\n-            Class::Ident => \"ident\",\n+            Class::Ident(_) => \"ident\",\n             Class::Lifetime => \"lifetime\",\n             Class::PreludeTy => \"prelude-ty\",\n             Class::PreludeVal => \"prelude-val\",\n             Class::QuestionMark => \"question-mark\",\n         }\n     }\n+\n+    fn get_span(self) -> Option<(u32, u32)> {\n+        match self {\n+            Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n+            _ => None,\n+        }\n+    }\n }\n \n enum Highlight<'a> {\n@@ -144,14 +166,23 @@ impl Iterator for TokenIter<'a> {\n     }\n }\n \n-fn get_real_ident_class(text: &str, edition: Edition) -> Class {\n-    match text {\n+/// Returns `None` if this is a `Class::Ident`.\n+fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool) -> Option<Class> {\n+    let ignore: &[&str] =\n+        if allow_path_keywords { &[\"self\", \"Self\", \"super\", \"crate\"] } else { &[\"self\", \"Self\"] };\n+    if ignore.iter().any(|k| *k == text) {\n+        return None;\n+    }\n+    Some(match text {\n         \"ref\" | \"mut\" => Class::RefKeyWord,\n-        \"self\" | \"Self\" => Class::Self_,\n         \"false\" | \"true\" => Class::Bool,\n         _ if Symbol::intern(text).is_reserved(|| edition) => Class::KeyWord,\n-        _ => Class::Ident,\n-    }\n+        _ => return None,\n+    })\n+}\n+\n+fn move_span(file_span_lo: u32, start: u32, end: u32) -> (u32, u32) {\n+    (start + file_span_lo, end + file_span_lo)\n }\n \n /// Processes program tokens, classifying strings of text by highlighting\n@@ -163,11 +194,12 @@ struct Classifier<'a> {\n     in_macro_nonterminal: bool,\n     edition: Edition,\n     byte_pos: u32,\n+    file_span_lo: u32,\n     src: &'a str,\n }\n \n impl<'a> Classifier<'a> {\n-    fn new(src: &str, edition: Edition) -> Classifier<'_> {\n+    fn new(src: &str, edition: Edition, file_span_lo: u32) -> Classifier<'_> {\n         let tokens = TokenIter { src }.peekable();\n         Classifier {\n             tokens,\n@@ -176,6 +208,7 @@ impl<'a> Classifier<'a> {\n             in_macro_nonterminal: false,\n             edition,\n             byte_pos: 0,\n+            file_span_lo,\n             src,\n         }\n     }\n@@ -201,17 +234,17 @@ impl<'a> Classifier<'a> {\n                 if has_ident {\n                     return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n                 } else {\n-                    return vec![(TokenKind::Colon, pos, pos + nb)];\n+                    return vec![(TokenKind::Colon, start, pos + nb)];\n                 }\n             }\n \n-            if let Some((Class::Ident, text)) = self.tokens.peek().map(|(token, text)| {\n+            if let Some((None, text)) = self.tokens.peek().map(|(token, text)| {\n                 if *token == TokenKind::Ident {\n-                    let class = get_real_ident_class(text, edition);\n+                    let class = get_real_ident_class(text, edition, true);\n                     (class, text)\n                 } else {\n                     // Doesn't matter which Class we put in here...\n-                    (Class::Comment, text)\n+                    (Some(Class::Comment), text)\n                 }\n             }) {\n                 // We only \"add\" the colon if there is an ident behind.\n@@ -221,7 +254,7 @@ impl<'a> Classifier<'a> {\n             } else if nb > 0 && has_ident {\n                 return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n             } else if nb > 0 {\n-                return vec![(TokenKind::Colon, pos, pos + nb)];\n+                return vec![(TokenKind::Colon, start, start + nb)];\n             } else if has_ident {\n                 return vec![(TokenKind::Ident, start, pos)];\n             } else {\n@@ -231,10 +264,11 @@ impl<'a> Classifier<'a> {\n     }\n \n     /// Wraps the tokens iteration to ensure that the byte_pos is always correct.\n-    fn next(&mut self) -> Option<(TokenKind, &'a str)> {\n+    fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n+            let before = self.byte_pos;\n             self.byte_pos += text.len() as u32;\n-            Some((kind, text))\n+            Some((kind, text, before))\n         } else {\n             None\n         }\n@@ -254,14 +288,18 @@ impl<'a> Classifier<'a> {\n                 .unwrap_or(false)\n             {\n                 let tokens = self.get_full_ident_path();\n+                let skip = !tokens.is_empty();\n                 for (token, start, end) in tokens {\n                     let text = &self.src[start..end];\n-                    self.advance(token, text, sink);\n+                    self.advance(token, text, sink, start as u32);\n                     self.byte_pos += text.len() as u32;\n                 }\n+                if skip {\n+                    continue;\n+                }\n             }\n-            if let Some((token, text)) = self.next() {\n-                self.advance(token, text, sink);\n+            if let Some((token, text, before)) = self.next() {\n+                self.advance(token, text, sink, before);\n             } else {\n                 break;\n             }\n@@ -270,7 +308,13 @@ impl<'a> Classifier<'a> {\n \n     /// Single step of highlighting. This will classify `token`, but maybe also\n     /// a couple of following ones as well.\n-    fn advance(&mut self, token: TokenKind, text: &'a str, sink: &mut dyn FnMut(Highlight<'a>)) {\n+    fn advance(\n+        &mut self,\n+        token: TokenKind,\n+        text: &'a str,\n+        sink: &mut dyn FnMut(Highlight<'a>),\n+        before: u32,\n+    ) {\n         let lookahead = self.peek();\n         let no_highlight = |sink: &mut dyn FnMut(_)| sink(Highlight::Token { text, class: None });\n         let class = match token {\n@@ -401,19 +445,30 @@ impl<'a> Classifier<'a> {\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n-            TokenKind::Ident => match get_real_ident_class(text, self.edition) {\n-                Class::Ident => match text {\n+            TokenKind::Ident => match get_real_ident_class(text, self.edition, false) {\n+                None => match text {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n                     _ if self.in_macro_nonterminal => {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n                     }\n-                    _ => Class::Ident,\n+                    \"self\" | \"Self\" => Class::Self_(move_span(\n+                        self.file_span_lo,\n+                        before,\n+                        before + text.len() as u32,\n+                    )),\n+                    _ => Class::Ident(move_span(\n+                        self.file_span_lo,\n+                        before,\n+                        before + text.len() as u32,\n+                    )),\n                 },\n-                c => c,\n+                Some(c) => c,\n             },\n-            TokenKind::RawIdent | TokenKind::UnknownPrefix => Class::Ident,\n+            TokenKind::RawIdent | TokenKind::UnknownPrefix => {\n+                Class::Ident(move_span(self.file_span_lo, before, before + text.len() as u32))\n+            }\n             TokenKind::Lifetime { .. } => Class::Lifetime,\n         };\n         // Anything that didn't return above is the simple case where we the\n@@ -448,11 +503,74 @@ fn exit_span(out: &mut Buffer) {\n /// ```\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n-fn string<T: Display>(out: &mut Buffer, text: T, klass: Option<Class>) {\n+fn string<T: Display>(\n+    out: &mut Buffer,\n+    text: T,\n+    klass: Option<Class>,\n+    context: Option<&Context<'_>>,\n+    root_path: &str,\n+) {\n     match klass {\n         None => write!(out, \"{}\", text),\n-        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text),\n+        Some(klass) => {\n+            if let Some(def_span) = klass.get_span() {\n+                let mut text = text.to_string();\n+                if text.contains(\"::\") {\n+                    text =\n+                        text.split(\"::\").enumerate().fold(String::new(), |mut path, (pos, t)| {\n+                            let pre = if pos != 0 { \"::\" } else { \"\" };\n+                            match t {\n+                                \"self\" | \"Self\" => write!(\n+                                    &mut path,\n+                                    \"{}<span class=\\\"{}\\\">{}</span>\",\n+                                    pre,\n+                                    Class::Self_((0, 0)).as_html(),\n+                                    t\n+                                ),\n+                                \"crate\" | \"super\" => write!(\n+                                    &mut path,\n+                                    \"{}<span class=\\\"{}\\\">{}</span>\",\n+                                    pre,\n+                                    Class::KeyWord.as_html(),\n+                                    t\n+                                ),\n+                                t => write!(&mut path, \"{}{}\", pre, t),\n+                            }\n+                            .expect(\"Failed to build source HTML path\");\n+                            path\n+                        });\n+                }\n+                if let Some(context) = context {\n+                    if let Some(href) =\n+                        context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n+                            match href {\n+                                LinkFromSrc::Local(span) => {\n+                                    eprintln!(\"==> {:?}:{:?}\", span.lo(), span.hi());\n+                                    context\n+                                    .href_from_span(clean::Span::wrap(*span))\n+                                    .map(|s| format!(\"{}{}\", root_path, s))\n+                                },\n+                                LinkFromSrc::External(def_id) => {\n+                                    format::href(*def_id, context).map(|(url, _, _)| url)\n+                                }\n+                            }\n+                        })\n+                    {\n+                        write!(\n+                            out,\n+                            \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\",\n+                            klass.as_html(),\n+                            href,\n+                            text\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+            write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n+        }\n     }\n+    write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n }\n \n #[cfg(test)]"}, {"sha": "5d79ccce8e1a055f0964faf84639717494ba4a7c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -330,6 +330,9 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             tooltip,\n             edition,\n             None,\n+            0,\n+            None,\n+            \"\",\n         );\n         Some(Event::Html(s.into_inner().into()))\n     }"}, {"sha": "33b10db1f881d346b42edd8c076b0a044b3d81b7", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -17,7 +17,10 @@ use rustc_span::symbol::sym;\n use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n-use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n+use super::{\n+    collect_spans_and_sources, print_sidebar, settings, AllTypes, LinkFromSrc, NameDoc, StylePath,\n+    BASIC_KEYWORDS,\n+};\n \n use crate::clean;\n use crate::clean::ExternalCrate;\n@@ -46,7 +49,7 @@ crate struct Context<'tcx> {\n     pub(crate) current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    pub(super) dst: PathBuf,\n+    crate dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -58,7 +61,7 @@ crate struct Context<'tcx> {\n     /// Issue for improving the situation: [#82381][]\n     ///\n     /// [#82381]: https://github.com/rust-lang/rust/issues/82381\n-    pub(super) shared: Rc<SharedContext<'tcx>>,\n+    crate shared: Rc<SharedContext<'tcx>>,\n     /// The [`Cache`] used during rendering.\n     ///\n     /// Ideally the cache would be in [`SharedContext`], but it's mutated\n@@ -68,7 +71,11 @@ crate struct Context<'tcx> {\n     /// It's immutable once in `Context`, so it's not as bad that it's not in\n     /// `SharedContext`.\n     // FIXME: move `cache` to `SharedContext`\n-    pub(super) cache: Rc<Cache>,\n+    crate cache: Rc<Cache>,\n+    /// This flag indicates whether `[src]` links should be generated or not. If\n+    /// the source files are present in the html rendering, then this will be\n+    /// `true`.\n+    crate include_sources: bool,\n }\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n@@ -84,10 +91,6 @@ crate struct SharedContext<'tcx> {\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     crate layout: layout::Layout,\n-    /// This flag indicates whether `[src]` links should be generated or not. If\n-    /// the source files are present in the html rendering, then this will be\n-    /// `true`.\n-    crate include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     crate local_sources: FxHashMap<PathBuf, String>,\n     /// Show the memory layout of types in the docs.\n@@ -125,6 +128,10 @@ crate struct SharedContext<'tcx> {\n     redirections: Option<RefCell<FxHashMap<String, String>>>,\n \n     pub(crate) templates: tera::Tera,\n+\n+    /// Correspondance map used to link types used in the source code pages to allow to click on\n+    /// links to jump to the type's definition.\n+    crate span_correspondance_map: FxHashMap<(u32, u32), LinkFromSrc>,\n }\n \n impl SharedContext<'_> {\n@@ -293,15 +300,19 @@ impl<'tcx> Context<'tcx> {\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n     pub(super) fn src_href(&self, item: &clean::Item) -> Option<String> {\n-        if item.span(self.tcx()).is_dummy() {\n+        self.href_from_span(item.span(self.tcx()))\n+    }\n+\n+    crate fn href_from_span(&self, span: clean::Span) -> Option<String> {\n+        if span.is_dummy() {\n             return None;\n         }\n         let mut root = self.root_path();\n         let mut path = String::new();\n-        let cnum = item.span(self.tcx()).cnum(self.sess());\n+        let cnum = span.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n-        let file = match item.span(self.tcx()).filename(self.sess()) {\n+        let file = match span.filename(self.sess()) {\n             FileName::Real(ref path) => path.local_path_if_available().to_path_buf(),\n             _ => return None,\n         };\n@@ -339,8 +350,8 @@ impl<'tcx> Context<'tcx> {\n             (&*symbol, &path)\n         };\n \n-        let loline = item.span(self.tcx()).lo(self.sess()).line;\n-        let hiline = item.span(self.tcx()).hi(self.sess()).line;\n+        let loline = span.lo(self.sess()).line;\n+        let hiline = span.hi(self.sess()).line;\n         let lines =\n             if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n         Some(format!(\n@@ -362,9 +373,9 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n     const RUN_ON_MODULE: bool = true;\n \n     fn init(\n-        mut krate: clean::Crate,\n+        krate: clean::Crate,\n         options: RenderOptions,\n-        mut cache: Cache,\n+        cache: Cache,\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n@@ -444,13 +455,16 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 _ => {}\n             }\n         }\n+\n+        let (mut krate, local_sources, matches) =\n+            collect_spans_and_sources(tcx, krate, &src_root, include_sources);\n+\n         let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n             tcx,\n             collapsed: krate.collapsed,\n             src_root,\n-            include_sources,\n-            local_sources: Default::default(),\n+            local_sources,\n             issue_tracker_base_url,\n             layout,\n             created_dirs: Default::default(),\n@@ -466,6 +480,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n             show_type_layout,\n             templates,\n+            span_correspondance_map: matches,\n         };\n \n         // Add the default themes to the `Vec` of stylepaths\n@@ -483,12 +498,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         let dst = output;\n         scx.ensure_dir(&dst)?;\n-        if emit_crate {\n-            krate = sources::render(&dst, &mut scx, krate)?;\n-        }\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache, tcx);\n \n         let mut cx = Context {\n             current: Vec::new(),\n@@ -497,8 +506,16 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             id_map: RefCell::new(id_map),\n             shared: Rc::new(scx),\n             cache: Rc::new(cache),\n+            include_sources,\n         };\n \n+        if emit_crate {\n+            krate = sources::render(&mut cx, krate)?;\n+        }\n+\n+        // Build our search index\n+        let index = build_index(&krate, Rc::get_mut(&mut cx.cache).unwrap(), tcx);\n+\n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n         write_shared(&cx, &krate, index, &md_opts)?;\n@@ -514,6 +531,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n             cache: Rc::clone(&self.cache),\n+            include_sources: self.include_sources,\n         }\n     }\n "}, {"sha": "fd2e18a8be77f0d3933d14c4e1174076649ec3d6", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -30,9 +30,11 @@ mod tests;\n \n mod context;\n mod print_item;\n+mod span_map;\n mod write_shared;\n \n crate use context::*;\n+crate use span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;"}, {"sha": "7b6bd4dd597048da4839941ea9c41831c7e7af54", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -119,7 +119,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n     // [src] link in the downstream documentation will actually come back to\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n-    if cx.shared.include_sources && !item.is_primitive() {\n+    if cx.include_sources && !item.is_primitive() {\n         write_srclink(cx, item, buf);\n     }\n \n@@ -1081,6 +1081,9 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n             None,\n             it.span(cx.tcx()).inner().edition(),\n             None,\n+            0,\n+            None,\n+            \"\",\n         );\n     });\n     document(w, cx, it, None)"}, {"sha": "c7c8fa7cc45cd257e2d70a4ab0472683c84331e3", "filename": "src/librustdoc/html/render/span_map.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -0,0 +1,110 @@\n+use crate::clean;\n+use crate::html::sources;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{/*ExprKind, */ GenericParam, GenericParamKind, HirId};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n+\n+#[derive(Debug)]\n+crate enum LinkFromSrc {\n+    Local(Span),\n+    External(DefId),\n+}\n+\n+crate fn collect_spans_and_sources(\n+    tcx: TyCtxt<'_>,\n+    krate: clean::Crate,\n+    src_root: &std::path::Path,\n+    include_sources: bool,\n+) -> (clean::Crate, FxHashMap<std::path::PathBuf, String>, FxHashMap<(u32, u32), LinkFromSrc>) {\n+    let mut visitor = SpanMapVisitor { tcx, matches: FxHashMap::default() };\n+\n+    if include_sources {\n+        intravisit::walk_crate(&mut visitor, tcx.hir().krate());\n+        let (krate, sources) = sources::collect_local_sources(tcx, src_root, krate);\n+        (krate, sources, visitor.matches)\n+    } else {\n+        (krate, Default::default(), Default::default())\n+    }\n+}\n+\n+fn span_to_tuple(span: Span) -> (u32, u32) {\n+    (span.lo().0, span.hi().0)\n+}\n+\n+struct SpanMapVisitor<'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    crate matches: FxHashMap<(u32, u32), LinkFromSrc>,\n+}\n+\n+impl<'tcx> SpanMapVisitor<'tcx> {\n+    fn handle_path(&mut self, path: &rustc_hir::Path<'_>, path_span: Option<Span>) -> bool {\n+        let info = match path.res {\n+            Res::Def(kind, def_id) if kind != DefKind::TyParam => {\n+                if matches!(kind, DefKind::Macro(_)) {\n+                    return false;\n+                }\n+                Some(def_id)\n+            }\n+            Res::Local(_) => None,\n+            _ => return true,\n+        };\n+        if let Some(span) = self.tcx.hir().res_span(path.res) {\n+            self.matches.insert(\n+                path_span.map(span_to_tuple).unwrap_or_else(|| span_to_tuple(path.span)),\n+                LinkFromSrc::Local(span),\n+            );\n+        } else if let Some(def_id) = info {\n+            self.matches.insert(\n+                path_span.map(span_to_tuple).unwrap_or_else(|| span_to_tuple(path.span)),\n+                LinkFromSrc::External(def_id),\n+            );\n+        }\n+        true\n+    }\n+}\n+\n+impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::All(self.tcx.hir())\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx GenericParam<'tcx>) {\n+        if !matches!(p.kind, GenericParamKind::Type { .. }) {\n+            return;\n+        }\n+        for bound in p.bounds {\n+            if let Some(trait_ref) = bound.trait_ref() {\n+                self.handle_path(&trait_ref.path, None);\n+            }\n+        }\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n+        self.handle_path(path, None);\n+        intravisit::walk_path(self, path);\n+    }\n+\n+    // fn visit_expr(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+    //     match expr.kind {\n+    //         ExprKind::MethodCall(segment, method_span, _, _) => {\n+    //             if let Some(hir_id) = segment.hir_id {\n+    //                 // call https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.type_dependent_def_id\n+    //             }\n+    //         }\n+    //         _ => {}\n+    //     }\n+    //     intravisit::walk_expr(self, expr);\n+    // }\n+\n+    fn visit_use(&mut self, path: &'tcx rustc_hir::Path<'tcx>, id: HirId) {\n+        self.handle_path(path, None);\n+        intravisit::walk_use(self, path, id);\n+    }\n+}"}, {"sha": "c16769c474a2124b5abf63d5ddf17d41427f1bbc", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -272,7 +272,7 @@ pub(super) fn write_shared(\n     write_minify(\"search.js\", static_files::SEARCH_JS)?;\n     write_minify(\"settings.js\", static_files::SETTINGS_JS)?;\n \n-    if cx.shared.include_sources {\n+    if cx.include_sources {\n         write_minify(\"source-script.js\", static_files::sidebar::SOURCE_SCRIPT)?;\n     }\n \n@@ -398,7 +398,7 @@ pub(super) fn write_shared(\n         }\n     }\n \n-    if cx.shared.include_sources {\n+    if cx.include_sources {\n         let mut hierarchy = Hierarchy::new(OsString::new());\n         for source in cx\n             .shared"}, {"sha": "24821950869e747faa73d77671474a7982e57adb", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 131, "deletions": 45, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023231a709b88e1a73ac86076aa5e1b4b3001276/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=023231a709b88e1a73ac86076aa5e1b4b3001276", "patch": "@@ -5,61 +5,127 @@ use crate::fold::DocFolder;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n-use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n+use crate::html::render::{Context, BASIC_KEYWORDS};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n \n-crate fn render(\n-    dst: &Path,\n-    scx: &mut SharedContext<'_>,\n-    krate: clean::Crate,\n-) -> Result<clean::Crate, Error> {\n+crate fn render(cx: &mut Context<'_>, krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = dst.join(\"src\").join(&*krate.name.as_str());\n-    scx.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector { dst, scx };\n+    let dst = cx.dst.join(\"src\").join(&*krate.name.as_str());\n+    cx.shared.ensure_dir(&dst)?;\n+    let mut folder = SourceCollector { dst, cx, emitted_local_sources: FxHashSet::default() };\n     Ok(folder.fold_crate(krate))\n }\n \n+crate fn collect_local_sources<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    src_root: &Path,\n+    krate: clean::Crate,\n+) -> (clean::Crate, FxHashMap<PathBuf, String>) {\n+    let mut lsc = LocalSourcesCollector { tcx, local_sources: FxHashMap::default(), src_root };\n+\n+    let krate = lsc.fold_crate(krate);\n+    (krate, lsc.local_sources)\n+}\n+\n+struct LocalSourcesCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    local_sources: FxHashMap<PathBuf, String>,\n+    src_root: &'a Path,\n+}\n+\n+fn is_real_and_local(span: clean::Span, sess: &Session) -> bool {\n+    span.filename(sess).is_real() && span.cnum(sess) == LOCAL_CRATE\n+}\n+\n+impl LocalSourcesCollector<'_, '_> {\n+    fn add_local_source(&mut self, item: &clean::Item) {\n+        let sess = self.tcx.sess;\n+        let span = item.span(self.tcx);\n+        // skip all synthetic \"files\"\n+        if !is_real_and_local(span, sess) {\n+            return;\n+        }\n+        let filename = span.filename(sess);\n+        let p = match filename {\n+            FileName::Real(ref file) => match file.local_path() {\n+                Some(p) => p.to_path_buf(),\n+                _ => return,\n+            },\n+            _ => return,\n+        };\n+        if self.local_sources.contains_key(&*p) {\n+            // We've already emitted this source\n+            return;\n+        }\n+\n+        let mut href = String::new();\n+        clean_path(&self.src_root, &p, false, |component| {\n+            href.push_str(&component.to_string_lossy());\n+            href.push('/');\n+        });\n+\n+        let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n+        let mut fname = src_fname.clone();\n+        fname.push(\".html\");\n+        href.push_str(&fname.to_string_lossy());\n+        self.local_sources.insert(p, href);\n+    }\n+}\n+\n+impl DocFolder for LocalSourcesCollector<'_, '_> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        self.add_local_source(&item);\n+\n+        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n+        // we could return None here without having to walk the rest of the crate.\n+        Some(self.fold_item_recur(item))\n+    }\n+}\n+\n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a, 'tcx> {\n-    scx: &'a mut SharedContext<'tcx>,\n+    cx: &'a mut Context<'tcx>,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n+    emitted_local_sources: FxHashSet<PathBuf>,\n }\n \n impl DocFolder for SourceCollector<'_, '_> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        let tcx = self.cx.tcx();\n+        let span = item.span(tcx);\n+        let sess = tcx.sess;\n+\n         // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n-        if self.scx.include_sources\n-            // skip all synthetic \"files\"\n-            && item.span(self.scx.tcx).filename(self.sess()).is_real()\n-            // skip non-local files\n-            && item.span(self.scx.tcx).cnum(self.sess()) == LOCAL_CRATE\n-        {\n-            let filename = item.span(self.scx.tcx).filename(self.sess());\n+        if self.cx.include_sources && is_real_and_local(span, sess) {\n+            let filename = span.filename(sess);\n+            let span = span.inner();\n+            let start_pos = sess.source_map().lookup_source_file(span.lo()).start_pos;\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.scx.include_sources = match self.emit_source(&filename) {\n+            self.cx.include_sources = match self.emit_source(&filename, start_pos.0) {\n                 Ok(()) => true,\n                 Err(e) => {\n-                    self.scx.tcx.sess.span_err(\n-                        item.span(self.scx.tcx).inner(),\n+                    self.cx.shared.tcx.sess.span_err(\n+                        span,\n                         &format!(\n                             \"failed to render source code for `{}`: {}\",\n                             filename.prefer_local(),\n-                            e\n+                            e,\n                         ),\n                     );\n                     false\n@@ -73,12 +139,8 @@ impl DocFolder for SourceCollector<'_, '_> {\n }\n \n impl SourceCollector<'_, 'tcx> {\n-    fn sess(&self) -> &'tcx Session {\n-        &self.scx.tcx.sess\n-    }\n-\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n+    fn emit_source(&mut self, filename: &FileName, file_span_lo: u32) -> Result<(), Error> {\n         let p = match *filename {\n             FileName::Real(ref file) => {\n                 if let Some(local_path) = file.local_path() {\n@@ -89,7 +151,7 @@ impl SourceCollector<'_, 'tcx> {\n             }\n             _ => return Ok(()),\n         };\n-        if self.scx.local_sources.contains_key(&*p) {\n+        if self.emitted_local_sources.contains(&*p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -107,44 +169,50 @@ impl SourceCollector<'_, 'tcx> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n-        let mut href = String::new();\n-        clean_path(&self.scx.src_root, &p, false, |component| {\n+        clean_path(&self.cx.shared.src_root, &p, false, |component| {\n             cur.push(component);\n             root_path.push_str(\"../\");\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n         });\n-        self.scx.ensure_dir(&cur)?;\n+\n+        self.cx.shared.ensure_dir(&cur)?;\n \n         let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n         let mut fname = src_fname.clone();\n         fname.push(\".html\");\n         cur.push(&fname);\n-        href.push_str(&fname.to_string_lossy());\n \n         let title = format!(\"{} - source\", src_fname.to_string_lossy());\n         let desc = format!(\"Source of the Rust file `{}`.\", filename.prefer_remapped());\n         let page = layout::Page {\n             title: &title,\n             css_class: \"source\",\n             root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.as_deref(),\n+            static_root_path: self.cx.shared.static_root_path.as_deref(),\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n+            resource_suffix: &self.cx.shared.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", self.cx.shared.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", self.cx.shared.resource_suffix)],\n         };\n         let v = layout::render(\n-            &self.scx.templates,\n-            &self.scx.layout,\n+            &self.cx.shared.templates,\n+            &self.cx.shared.layout,\n             &page,\n             \"\",\n-            |buf: &mut _| print_src(buf, contents, self.scx.edition()),\n-            &self.scx.style_files,\n+            |buf: &mut _| {\n+                print_src(\n+                    buf,\n+                    contents,\n+                    self.cx.shared.edition(),\n+                    file_span_lo,\n+                    &self.cx,\n+                    &root_path,\n+                )\n+            },\n+            &self.cx.shared.style_files,\n         );\n-        self.scx.fs.write(&cur, v.as_bytes())?;\n-        self.scx.local_sources.insert(p, href);\n+        self.cx.shared.fs.write(&cur, v.as_bytes())?;\n+        self.emitted_local_sources.insert(p);\n         Ok(())\n     }\n }\n@@ -178,7 +246,14 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-fn print_src(buf: &mut Buffer, s: &str, edition: Edition) {\n+fn print_src(\n+    buf: &mut Buffer,\n+    s: &str,\n+    edition: Edition,\n+    file_span_lo: u32,\n+    context: &Context<'_>,\n+    root_path: &str,\n+) {\n     let lines = s.lines().count();\n     let mut line_numbers = Buffer::empty_from(buf);\n     let mut cols = 0;\n@@ -192,5 +267,16 @@ fn print_src(buf: &mut Buffer, s: &str, edition: Edition) {\n         writeln!(line_numbers, \"<span id=\\\"{0}\\\">{0:1$}</span>\", i, cols);\n     }\n     line_numbers.write_str(\"</pre>\");\n-    highlight::render_with_highlighting(s, buf, None, None, None, edition, Some(line_numbers));\n+    highlight::render_with_highlighting(\n+        s,\n+        buf,\n+        None,\n+        None,\n+        None,\n+        edition,\n+        Some(line_numbers),\n+        file_span_lo,\n+        Some(context),\n+        root_path,\n+    );\n }"}]}