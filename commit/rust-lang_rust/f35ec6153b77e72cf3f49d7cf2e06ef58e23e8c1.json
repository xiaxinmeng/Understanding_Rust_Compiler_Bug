{"sha": "f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNWVjNjE1M2I3N2U3MmNmM2Y0OWQ3Y2YyZTA2ZWY1OGUyM2U4YzE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-28T02:54:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-28T02:54:00Z"}, "message": "Rollup merge of #42207 - Nashenas88:remove_fragment_info, r=eddyb\n\nRemove all instances of fragment_infos and fragment sets\n\nRemove unused fragment structs. This was suggested by @eddyb in IRC: [botbot link](https://botbot.me/mozilla/rustc/2017-05-23/?msg=86016574&page=2).", "tree": {"sha": "b22a5d6272b4cee41ec1ef5f80a2576023f20977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b22a5d6272b4cee41ec1ef5f80a2576023f20977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "html_url": "https://github.com/rust-lang/rust/commit/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d2512ec5b03a1155054df881e40e35fc87d6351", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2512ec5b03a1155054df881e40e35fc87d6351", "html_url": "https://github.com/rust-lang/rust/commit/5d2512ec5b03a1155054df881e40e35fc87d6351"}, {"sha": "a563f350b0122da51a507037956858639b2aa106", "url": "https://api.github.com/repos/rust-lang/rust/commits/a563f350b0122da51a507037956858639b2aa106", "html_url": "https://github.com/rust-lang/rust/commit/a563f350b0122da51a507037956858639b2aa106"}], "stats": {"total": 1144, "additions": 1, "deletions": 1143}, "files": [{"sha": "64e16c41d1132bde1629051f71002cc1c0fbeb67", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -40,7 +40,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n@@ -499,33 +499,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    /// Maps Fn items to a collection of fragment infos.\n-    ///\n-    /// The main goal is to identify data (each of which may be moved\n-    /// or assigned) whose subparts are not moved nor assigned\n-    /// (i.e. their state is *unfragmented*) and corresponding ast\n-    /// nodes where the path to that data is moved or assigned.\n-    ///\n-    /// In the long term, unfragmented values will have their\n-    /// destructor entirely driven by a single stack-local drop-flag,\n-    /// and their parents, the collections of the unfragmented values\n-    /// (or more simply, \"fragmented values\"), are mapped to the\n-    /// corresponding collections of stack-local drop-flags.\n-    ///\n-    /// (However, in the short term that is not the case; e.g. some\n-    /// unfragmented paths still need to be zeroed, namely when they\n-    /// reference parent data from an outer scope that was not\n-    /// entirely moved, and therefore that needs to be zeroed so that\n-    /// we do not get double-drop when we hit the end of the parent\n-    /// scope.)\n-    ///\n-    /// Also: currently the table solely holds keys for node-ids of\n-    /// unfragmented values (see `FragmentInfo` enum definition), but\n-    /// longer-term we will need to also store mappings from\n-    /// fragmented data to the set of unfragmented pieces that\n-    /// constitute it.\n-    pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -730,7 +703,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),"}, {"sha": "aeffd71a0964980e430de3b550c30f9e4e5be233", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -444,17 +444,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Describes the fragment-state associated with a NodeId.\n-///\n-/// Currently only unfragmented paths have entries in the table,\n-/// but longer-term this enum is expected to expand to also\n-/// include data for fragmented paths.\n-#[derive(Copy, Clone, Debug)]\n-pub enum FragmentInfo {\n-    Moved { var: NodeId, move_expr: NodeId },\n-    Assigned { var: NodeId, assign_expr: NodeId, assignee_id: NodeId },\n-}\n-\n // Flags that we track on types. These flags are propagated upwards\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without"}, {"sha": "b728d4d534516672e436312a336f40f627017943", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "removed", "additions": 0, "deletions": 542, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,542 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Helper routines used for fragmenting structural paths due to moves for\n-//! tracking drop obligations. Please see the extensive comments in the\n-//! section \"Structural fragments\" in `README.md`.\n-\n-use self::Fragment::*;\n-\n-use borrowck::InteriorKind::{InteriorField, InteriorElement};\n-use borrowck::{self, LoanPath};\n-use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n-use borrowck::LoanPathElem::{LpDeref, LpInterior};\n-use borrowck::move_data::InvalidMovePathIndex;\n-use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::hir::def_id::{DefId};\n-use rustc::ty::{self, AdtKind, TyCtxt};\n-use rustc::middle::mem_categorization as mc;\n-\n-use std::mem;\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n-\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-enum Fragment {\n-    // This represents the path described by the move path index\n-    Just(MovePathIndex),\n-\n-    // This represents the collection of all but one of the elements\n-    // from an array at the path described by the move path index.\n-    // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `&foo[..]`).\n-    AllButOneFrom(MovePathIndex),\n-}\n-\n-impl Fragment {\n-    fn loan_path_repr(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => format!(\"{:?}\", lp(mpi)),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {:?})\", lp(mpi)),\n-        }\n-    }\n-\n-    fn loan_path_user_string(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => lp(mpi).to_string(),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", lp(mpi)),\n-        }\n-    }\n-}\n-\n-pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n-                              move_data: &MoveData,\n-                              id: ast::NodeId) {\n-    let fr = &move_data.fragments.borrow();\n-\n-    // For now, don't care about other kinds of fragments; the precise\n-    // classfication of all paths for non-zeroing *drop* needs them,\n-    // but the loose approximation used by non-zeroing moves does not.\n-    let moved_leaf_paths = fr.moved_leaf_paths();\n-    let assigned_leaf_paths = fr.assigned_leaf_paths();\n-\n-    let mut fragment_infos = Vec::with_capacity(moved_leaf_paths.len());\n-\n-    let find_var_id = |move_path_index: MovePathIndex| -> Option<ast::NodeId> {\n-        let lp = move_data.path_loan_path(move_path_index);\n-        match lp.kind {\n-            LpVar(var_id) => Some(var_id),\n-            LpUpvar(ty::UpvarId { var_id, closure_expr_id }) => {\n-                // The `var_id` is unique *relative to* the current function.\n-                // (Check that we are indeed talking about the same function.)\n-                assert_eq!(id, closure_expr_id);\n-                Some(var_id)\n-            }\n-            LpDowncast(..) | LpExtend(..) => {\n-                // This simple implementation of non-zeroing move does\n-                // not attempt to deal with tracking substructure\n-                // accurately in the general case.\n-                None\n-            }\n-        }\n-    };\n-\n-    let moves = move_data.moves.borrow();\n-    for &move_path_index in moved_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        move_data.each_applicable_move(move_path_index, |move_index| {\n-            let info = ty::FragmentInfo::Moved {\n-                var: var_id,\n-                move_expr: moves[move_index.get()].id,\n-            };\n-            debug!(\"fragment_infos push({:?} \\\n-                    due to move_path_index: {} move_index: {}\",\n-                   info, move_path_index.get(), move_index.get());\n-            fragment_infos.push(info);\n-            true\n-        });\n-    }\n-\n-    for &move_path_index in assigned_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        let var_assigns = move_data.var_assignments.borrow();\n-        for var_assign in var_assigns.iter()\n-            .filter(|&assign| assign.path == move_path_index)\n-        {\n-            let info = ty::FragmentInfo::Assigned {\n-                var: var_id,\n-                assign_expr: var_assign.id,\n-                assignee_id: var_assign.assignee_id,\n-            };\n-            debug!(\"fragment_infos push({:?} due to var_assignment\", info);\n-            fragment_infos.push(info);\n-        }\n-    }\n-\n-    let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = this.tcx.hir.local_def_id(id);\n-    let prev = fraginfo_map.insert(fn_did, fragment_infos);\n-    assert!(prev.is_none());\n-}\n-\n-pub struct FragmentSets {\n-    /// During move_data construction, `moved_leaf_paths` tracks paths\n-    /// that have been used directly by being moved out of.  When\n-    /// move_data construction has been completed, `moved_leaf_paths`\n-    /// tracks such paths that are *leaf fragments* (e.g. `a.j` if we\n-    /// never move out any child like `a.j.x`); any parent paths\n-    /// (e.g. `a` for the `a.j` example) are moved over to\n-    /// `parents_of_fragments`.\n-    moved_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `assigned_leaf_paths` tracks paths that have been used\n-    /// directly by being overwritten, but is otherwise much like\n-    /// `moved_leaf_paths`.\n-    assigned_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `parents_of_fragments` tracks paths that are definitely\n-    /// parents of paths that have been moved.\n-    ///\n-    /// FIXME(pnkfelix) probably do not want/need\n-    /// `parents_of_fragments` at all, if we can avoid it.\n-    ///\n-    /// Update: I do not see a way to avoid it.  Maybe just remove\n-    /// above fixme, or at least document why doing this may be hard.\n-    parents_of_fragments: Vec<MovePathIndex>,\n-\n-    /// During move_data construction (specifically the\n-    /// fixup_fragment_sets call), `unmoved_fragments` tracks paths\n-    /// that have been \"left behind\" after a sibling has been moved or\n-    /// assigned.  When move_data construction has been completed,\n-    /// `unmoved_fragments` tracks paths that were *only* results of\n-    /// being left-behind, and never directly moved themselves.\n-    unmoved_fragments: Vec<Fragment>,\n-}\n-\n-impl FragmentSets {\n-    pub fn new() -> FragmentSets {\n-        FragmentSets {\n-            unmoved_fragments: Vec::new(),\n-            moved_leaf_paths: Vec::new(),\n-            assigned_leaf_paths: Vec::new(),\n-            parents_of_fragments: Vec::new(),\n-        }\n-    }\n-\n-    pub fn moved_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.moved_leaf_paths\n-    }\n-\n-    pub fn assigned_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.assigned_leaf_paths\n-    }\n-\n-    pub fn add_move(&mut self, path_index: MovePathIndex) {\n-        self.moved_leaf_paths.push(path_index);\n-    }\n-\n-    pub fn add_assignment(&mut self, path_index: MovePathIndex) {\n-        self.assigned_leaf_paths.push(path_index);\n-    }\n-}\n-\n-pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           id: ast::NodeId) {\n-    let span_err = tcx.hir.attrs(id).iter()\n-                          .any(|a| a.check_name(\"rustc_move_fragments\"));\n-    let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n-\n-    if !span_err && !print { return; }\n-\n-    let sp = tcx.hir.span(id);\n-\n-    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n-        for (i, mpi) in vec_rc.iter().enumerate() {\n-            let lp = || this.path_loan_path(*mpi);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, lp()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, lp());\n-            }\n-        }\n-    };\n-\n-    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n-        for (i, f) in vec_rc.iter().enumerate() {\n-            let render = || f.loan_path_user_string(this);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n-            }\n-        }\n-    };\n-\n-    let fragments = this.fragments.borrow();\n-    instrument_all_paths(\"moved_leaf_path\", &fragments.moved_leaf_paths);\n-    instrument_all_fragments(\"unmoved_fragment\", &fragments.unmoved_fragments);\n-    instrument_all_paths(\"parent_of_fragments\", &fragments.parents_of_fragments);\n-    instrument_all_paths(\"assigned_leaf_path\", &fragments.assigned_leaf_paths);\n-}\n-\n-/// Normalizes the fragment sets in `this`; i.e., removes duplicate entries, constructs the set of\n-/// parents, and constructs the left-over fragments.\n-///\n-/// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n-/// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-\n-    let mut fragments = this.fragments.borrow_mut();\n-\n-    // Swap out contents of fragments so that we can modify the fields\n-    // without borrowing the common fragments.\n-    let mut unmoved = mem::replace(&mut fragments.unmoved_fragments, vec![]);\n-    let mut parents = mem::replace(&mut fragments.parents_of_fragments, vec![]);\n-    let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n-    let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n-\n-    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| format!(\"{:?}\", this.path_loan_path(*mpi))).collect()\n-    };\n-\n-    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n-        fs.iter().map(|f| f.loan_path_repr(this)).collect()\n-    };\n-\n-    // First, filter out duplicates\n-    moved.sort();\n-    moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.sort();\n-    assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Second, build parents from the moved and assigned.\n-    for m in &moved {\n-        let mut p = this.path_parent(*m);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-    for a in &assigned {\n-        let mut p = this.path_parent(*a);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-\n-    parents.sort();\n-    parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents));\n-\n-    // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in &moved {\n-        let lp = this.path_loan_path(*m);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for a in &assigned {\n-        let lp = this.path_loan_path(*a);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for p in &parents {\n-        let lp = this.path_loan_path(*p);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-\n-    unmoved.sort();\n-    unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Fifth, filter the leftover fragments down to its core.\n-    unmoved.retain(|f| match *f {\n-        AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents) &&\n-            non_member(mpi, &moved) &&\n-            non_member(mpi, &assigned)\n-    });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Swap contents back in.\n-    fragments.unmoved_fragments = unmoved;\n-    fragments.parents_of_fragments = parents;\n-    fragments.moved_leaf_paths = moved;\n-    fragments.assigned_leaf_paths = assigned;\n-\n-    return;\n-\n-    fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search(&elem) {\n-            Ok(_) => false,\n-            Err(_) => true,\n-        }\n-    }\n-}\n-\n-/// Adds all of the precisely-tracked siblings of `lp` as potential move paths of interest. For\n-/// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n-/// siblings of `s.x.j`.\n-fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   gathered_fragments: &mut Vec<Fragment>,\n-                                   lp: Rc<LoanPath<'tcx>>,\n-                                   origin_id: Option<ast::NodeId>) {\n-    match lp.kind {\n-        LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n-\n-        // Consuming a downcast is like consuming the original value, so propage inward.\n-        LpDowncast(ref loan_parent, _) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for Unique consumes the contents of the box (at\n-        // least when it is non-copy...), so propagate inward.\n-        LpExtend(ref loan_parent, _, LpDeref(mc::Unique)) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n-        LpExtend(.., LpDeref(mc::UnsafePtr(..)))   |\n-        LpExtend(.., LpDeref(mc::Implicit(..)))    |\n-        LpExtend(.., LpDeref(mc::BorrowedPtr(..))) => {}\n-\n-        // FIXME (pnkfelix): LV[j] should be tracked, at least in the\n-        // sense of we will track the remaining drop obligation of the\n-        // rest of the array.\n-        //\n-        // Well, either that or LV[j] should be made illegal.\n-        // But even then, we will need to deal with destructuring\n-        // bind.\n-        //\n-        // Anyway, for now: LV[j] is not tracked precisely\n-        LpExtend(.., LpInterior(_, InteriorElement(..))) => {\n-            let mp = this.move_path(tcx, lp.clone());\n-            gathered_fragments.push(AllButOneFrom(mp));\n-        }\n-\n-        // field access LV.x and tuple access LV#k are the cases\n-        // we are interested in\n-        LpExtend(ref loan_parent, mc,\n-                 LpInterior(_, InteriorField(ref field_name))) => {\n-            let enum_variant_info = match loan_parent.kind {\n-                LpDowncast(ref loan_parent_2, variant_def_id) =>\n-                    Some((variant_def_id, loan_parent_2.clone())),\n-                LpExtend(..) | LpVar(..) | LpUpvar(..) =>\n-                    None,\n-            };\n-            add_fragment_siblings_for_extension(\n-                this,\n-                tcx,\n-                gathered_fragments,\n-                loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);\n-        }\n-    }\n-}\n-\n-/// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n-/// Based on this, add move paths for all of the siblings of `origin_lp`.\n-fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 gathered_fragments: &mut Vec<Fragment>,\n-                                                 parent_lp: &Rc<LoanPath<'tcx>>,\n-                                                 mc: mc::MutabilityCategory,\n-                                                 origin_field_name: &mc::FieldName,\n-                                                 origin_lp: &Rc<LoanPath<'tcx>>,\n-                                                 origin_id: Option<ast::NodeId>,\n-                                                 enum_variant_info: Option<(DefId,\n-                                                    Rc<LoanPath<'tcx>>)>) {\n-    let parent_ty = parent_lp.to_type();\n-\n-    let mut add_fragment_sibling_local = |field_name, variant_did| {\n-        add_fragment_sibling_core(\n-            this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp,\n-            variant_did);\n-    };\n-\n-    match parent_ty.sty {\n-        ty::TyTuple(ref v, _) => {\n-            let tuple_idx = match *origin_field_name {\n-                mc::PositionalField(tuple_idx) => tuple_idx,\n-                mc::NamedField(_) =>\n-                    bug!(\"tuple type {:?} should not have named fields.\",\n-                         parent_ty),\n-            };\n-            let tuple_len = v.len();\n-            for i in 0..tuple_len {\n-                if i == tuple_idx { continue }\n-                let field_name = mc::PositionalField(i);\n-                add_fragment_sibling_local(field_name, None);\n-            }\n-        }\n-\n-        ty::TyAdt(def, ..) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for f in &def.struct_variant().fields {\n-                            if f.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(f.name);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n-                            if i == tuple_idx {\n-                                continue\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-            AdtKind::Union => {\n-                // Do nothing, all union fields are moved/assigned together.\n-            }\n-            AdtKind::Enum => {\n-                let variant = match enum_variant_info {\n-                    Some((vid, ref _lp2)) => def.variant_with_id(vid),\n-                    None => {\n-                        assert!(def.is_univariant());\n-                        &def.variants[0]\n-                    }\n-                };\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for field in &variant.fields {\n-                            if field.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(field.name);\n-                            add_fragment_sibling_local(field_name, Some(variant.did));\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in variant.fields.iter().enumerate() {\n-                            if tuple_idx == i {\n-                                continue;\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-\n-        ref ty => {\n-            let span = origin_id.map_or(DUMMY_SP, |id| tcx.hir.span(id));\n-            span_bug!(span,\n-                      \"type {:?} ({:?}) is not fragmentable\",\n-                      parent_ty, ty);\n-        }\n-    }\n-}\n-\n-/// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n-/// loan-path).\n-fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       gathered_fragments: &mut Vec<Fragment>,\n-                                       parent: Rc<LoanPath<'tcx>>,\n-                                       mc: mc::MutabilityCategory,\n-                                       new_field_name: mc::FieldName,\n-                                       origin_lp: &Rc<LoanPath<'tcx>>,\n-                                       enum_variant_did: Option<DefId>)\n-                                       -> MovePathIndex {\n-    let opt_variant_did = match parent.kind {\n-        LpDowncast(_, variant_did) => Some(variant_did),\n-        LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,\n-    };\n-\n-    let loan_path_elem = LpInterior(opt_variant_did, InteriorField(new_field_name));\n-    let new_lp_type = match new_field_name {\n-        mc::NamedField(ast_name) =>\n-            tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),\n-        mc::PositionalField(idx) =>\n-            tcx.positional_element_ty(parent.to_type(), idx, opt_variant_did),\n-    };\n-    let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n-    let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n-    debug!(\"add_fragment_sibling_core(new_lp={:?}, origin_lp={:?})\",\n-           new_lp, origin_lp);\n-    let mp = this.move_path(tcx, Rc::new(new_lp));\n-\n-    // Do not worry about checking for duplicates here; we will sort\n-    // and dedup after all are added.\n-    gathered_fragments.push(Just(mp));\n-\n-    mp\n-}"}, {"sha": "ff5ebb9c1dc5d1aee2ce4fa94a03e37dfb24db22", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -129,13 +129,6 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n                        move_data: flowed_moves } =\n         build_borrowck_dataflow_data(bccx, &cfg, body_id);\n \n-    move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n-                                                    bccx.tcx,\n-                                                    owner_id);\n-    move_data::fragments::build_unfragmented_map(bccx,\n-                                                 &flowed_moves.move_data,\n-                                                 owner_id);\n-\n     check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n }\n "}, {"sha": "1b364596a23f7fd518de0871ebb808afa4778592", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -33,9 +33,6 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-#[path=\"fragments.rs\"]\n-pub mod fragments;\n-\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -62,9 +59,6 @@ pub struct MoveData<'tcx> {\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n-\n-    /// Path-fragments from moves in to or out of parts of structured data.\n-    pub fragments: RefCell<fragments::FragmentSets>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -223,7 +217,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             var_assignments: RefCell::new(Vec::new()),\n             variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n-            fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }\n \n@@ -401,8 +394,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let move_index = MoveIndex(self.moves.borrow().len());\n \n-        self.fragments.borrow_mut().add_move(path_index);\n-\n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n@@ -458,8 +449,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         match mode {\n             MutateMode::Init | MutateMode::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -502,8 +491,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         let variant_match = VariantMatch {\n             path: path_index,\n             base_path: base_path_index,\n@@ -514,10 +501,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        fragments::fixup_fragment_sets(self, tcx)\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n@@ -677,8 +660,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n \n-        move_data.fixup_fragment_sets(tcx);\n-\n         move_data.add_gen_kills(bccx,\n                                 &mut dfcx_moves,\n                                 &mut dfcx_assign);"}, {"sha": "b2f52d11db2b111b82f6073ec5e17fd5527a4745", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -664,12 +664,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                            \"rustc_attrs\",\n                                            \"internal rustc attributes will never be stable\",\n                                            cfg_fn!(rustc_attrs))),\n-    (\"rustc_move_fragments\", Normal, Gated(Stability::Unstable,\n-                                           \"rustc_attrs\",\n-                                           \"the `#[rustc_move_fragments]` attribute \\\n-                                            is just used for rustc unit tests \\\n-                                            and will never be stable\",\n-                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_mir\", Whitelisted, Gated(Stability::Unstable,\n                                      \"rustc_attrs\",\n                                      \"the `#[rustc_mir]` attribute \\"}, {"sha": "8cfd3e020c69a47da7d3eeb1cf1eb8be261a62fa", "filename": "src/test/compile-fail/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs?ref=f35ec6153b77e72cf3f49d7cf2e06ef58e23e8c1", "patch": "@@ -14,7 +14,6 @@\n \n #[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_error] //~ ERROR the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n-#[rustc_move_fragments] //~ ERROR the `#[rustc_move_fragments]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_foo]\n //~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n "}, {"sha": "0219f5b6becb3bae271892a3cc559bebacc8ae56", "filename": "src/test/compile-fail/move-fragments-1.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// These are all fairly trivial cases: unused variables or direct\n-// drops of substructure.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-#[rustc_move_fragments]\n-pub fn test_noop() {\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_take(_x: D) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _x)`\n-}\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_take_struct(_p: Pair<D, D>) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_drop_struct_part(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    drop(p.x);\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_drop_tuple_part(p: (D, D)) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).#0`\n-    //~| ERROR                    unmoved_fragment: `$(local p).#1`\n-    drop(p.0);\n-}\n-\n-pub fn main() { }"}, {"sha": "15c28ec2713e967d160e67bd20c1f047407afd53", "filename": "src/test/compile-fail/move-fragments-2.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// These are checking that enums are tracked; note that their output\n-// paths include \"downcasts\" of the path to a particular enum.\n-\n-#![feature(rustc_attrs)]\n-\n-use self::Lonely::{Zero, One, Two};\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n-\n-#[rustc_move_fragments]\n-pub fn test_match_partial(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    match p {\n-        Zero => {}\n-        _ => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_full(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::One)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Two)`\n-    match p {\n-        Zero => {}\n-        One(..) => {}\n-        Two(..) => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_one(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::One)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::One).#0`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Two)`\n-    //~| ERROR                  assigned_leaf_path: `$(local data)`\n-    match p {\n-        Zero => {}\n-        One(data) => {}\n-        Two(..) => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_many(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::One)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::One).#0`\n-    //~| ERROR                  assigned_leaf_path: `$(local data)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::Two)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#0`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#1`\n-    //~| ERROR                  assigned_leaf_path: `$(local left)`\n-    //~| ERROR                  assigned_leaf_path: `$(local right)`\n-    match p {\n-        Zero => {}\n-        One(data) => {}\n-        Two(left, right) => {}\n-    }\n-}\n-\n-pub fn main() { }"}, {"sha": "a1152333900a0f455b4d096acf7b3b4b6e5a69a1", "filename": "src/test/compile-fail/move-fragments-3.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This checks the handling of `_` within variants, especially when mixed\n-// with bindings.\n-\n-#![feature(rustc_attrs)]\n-\n-use self::Lonely::{Zero, One, Two};\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_and_underscore(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::One)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::Two)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#0`\n-    //~| ERROR                    unmoved_fragment: `($(local p) as Lonely::Two).#1`\n-    //~| ERROR                  assigned_leaf_path: `$(local left)`\n-\n-    match p {\n-        Zero => {}\n-\n-        One(_) => {}       // <-- does not fragment `($(local p) as One)` ...\n-\n-        Two(left, _) => {} // <-- ... *does* fragment `($(local p) as Two)`.\n-    }\n-}\n-\n-pub fn main() { }"}, {"sha": "191e23a28638b59c8119386ae18525d6f172cc36", "filename": "src/test/compile-fail/move-fragments-4.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This checks that a move of deep structure is properly tracked. (An\n-// early draft of the code did not properly traverse up through all of\n-// the parents of the leaf fragment.)\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_substructure(pppp: Pair<Pair<Pair<Pair<D,D>, D>, D>, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local pppp)`\n-    //~| ERROR                 parent_of_fragments: `$(local pppp).x`\n-    //~| ERROR                 parent_of_fragments: `$(local pppp).x.x`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).x.x.x`\n-    //~| ERROR                     moved_leaf_path: `$(local pppp).x.x.y`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).x.y`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).y`\n-    drop(pppp.x.x.y);\n-}\n-\n-pub fn main() { }"}, {"sha": "38a385eacac5c07795c9a19e49c5d9288b3b7e63", "filename": "src/test/compile-fail/move-fragments-5.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This is the first test that checks moving into local variables.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    let _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_to_local(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n-    let _x = p.x;\n-    let _y = _x;\n-}\n-\n-// In the following fn's `test_move_field_to_local_delayed` and\n-// `test_uninitialized_local` , the instrumentation reports that `_x`\n-// is moved. This is unlike `test_move_field_to_local`, where `_x` is\n-// just reported as an assigned_leaf_path. Presumably because this is\n-// how we represent that it did not have an initializing expression at\n-// the binding site.\n-\n-#[rustc_move_fragments]\n-pub fn test_uninitialized_local(_p: Pair<D, D>) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    let _x: D;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_delayed(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    let _x;\n-    _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_mut_to_local(mut p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    let _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_to_local_mut(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut _x)`\n-    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n-    let mut _x = p.x;\n-    let _y = _x;\n-}\n-\n-pub fn main() {}"}, {"sha": "122727c3f6b64a0c1cf75e4ca4a216cf51df98b3", "filename": "src/test/compile-fail/move-fragments-6.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that moving into a field (i.e. overwriting it) fragments the\n-// receiver.\n-\n-#![feature(rustc_attrs)]\n-\n-use std::mem::drop;\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_uninit_field<Z>(z: Z) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                  assigned_leaf_path: `$(local z)`\n-    //~| ERROR                     moved_leaf_path: `$(local z)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-\n-    let mut p: Pair<Z,Z>;\n-    p.x = z;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_moved_field<Z>(mut p: Pair<Z,Z>, z: Z) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                  assigned_leaf_path: `$(local z)`\n-    //~| ERROR                     moved_leaf_path: `$(local z)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).y`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).x`\n-\n-    drop(p);\n-    p.y = z;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_same_field<Z>(mut p: Pair<Z,Z>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-\n-    p.x = p.x;\n-}\n-\n-pub fn main() { }"}, {"sha": "a2a37208cd6168b61f4dcbdce75f59cf93e4b65d", "filename": "src/test/compile-fail/move-fragments-7.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that moving a Box<T> fragments its containing structure, for\n-// both moving out of the structure (i.e. reading `*p.x`) and writing\n-// into the container (i.e. writing `*p.x`).\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_deref_box_field(p: Pair<Box<D>, Box<D>>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                 parent_of_fragments: `$(local p).x`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    let i : D = *p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_deref_box_field(mut p: Pair<Box<D>, Box<D>>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                 parent_of_fragments: `$(local mut p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-    *p.x = D { d: 3 };\n-}\n-\n-pub fn main() { }"}, {"sha": "e57268dbfa32aa985afb154168824b5916186a22", "filename": "src/test/compile-fail/move-fragments-8.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that assigning into a `&T` within structured container does\n-// *not* fragment its containing structure.\n-//\n-// Compare against the `Box<T>` handling in move-fragments-7.rs. Note\n-// also that in this case we cannot do a move out of `&T`, so we only\n-// test writing `*p.x` here.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_deref_ampersand_field<'a>(p: Pair<&'a mut D, &'a D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                 parent_of_fragments: `$(local p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    *p.x = D { d: 3 };\n-}\n-\n-pub fn main() { }"}, {"sha": "350f4169034004620cae6bf2cb6367532dfb27b2", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test moving array structures, e.g. `[T; 3]` as well as moving\n-// elements in and out of such arrays.\n-//\n-// Note also that the `test_move_array_then_overwrite` tests represent\n-// cases that we probably should make illegal.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_via_return(a: [D; 3]) -> [D; 3] {\n-    //~^ ERROR                  assigned_leaf_path: `$(local a)`\n-    //~| ERROR                     moved_leaf_path: `$(local a)`\n-    return a;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_into_recv(a: [D; 3], recv: &mut [D; 3]) {\n-    //~^ ERROR                 parent_of_fragments: `$(local recv)`\n-    //~| ERROR                  assigned_leaf_path: `$(local a)`\n-    //~| ERROR                     moved_leaf_path: `$(local a)`\n-    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n-    *recv = a;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_array_elem(mut a: [D; 3], i: usize, d: D) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    //~| ERROR                  assigned_leaf_path: `$(local d)`\n-    //~| ERROR                     moved_leaf_path: `$(local d)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n-    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n-    a[i] = d;\n-}\n-\n-pub fn main() { }"}]}