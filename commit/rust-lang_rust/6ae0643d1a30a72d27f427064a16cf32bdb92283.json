{"sha": "6ae0643d1a30a72d27f427064a16cf32bdb92283", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZTA2NDNkMWEzMGE3MmQyN2Y0MjcwNjRhMTZjZjMyYmRiOTIyODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-17T10:58:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-17T10:58:56Z"}, "message": "Auto merge of #5529 - alex-700:improve-option-and-then-some-lint, r=phansch\n\nImprove `option_and_then_some` lint\n\nfixed #5492\n\nchangelog: Improve and generalize `option_and_then_some` and rename it to `bind_instead_of_map`.", "tree": {"sha": "243f82f194e140d255fdef668ae28575213315cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/243f82f194e140d255fdef668ae28575213315cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae0643d1a30a72d27f427064a16cf32bdb92283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae0643d1a30a72d27f427064a16cf32bdb92283", "html_url": "https://github.com/rust-lang/rust/commit/6ae0643d1a30a72d27f427064a16cf32bdb92283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae0643d1a30a72d27f427064a16cf32bdb92283/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "440a46dd2007a32fd31436df5735c389720ec1e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/440a46dd2007a32fd31436df5735c389720ec1e7", "html_url": "https://github.com/rust-lang/rust/commit/440a46dd2007a32fd31436df5735c389720ec1e7"}, {"sha": "07f1edf2d43efa0ef53e5b6c56c895bc9738ab94", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f1edf2d43efa0ef53e5b6c56c895bc9738ab94", "html_url": "https://github.com/rust-lang/rust/commit/07f1edf2d43efa0ef53e5b6c56c895bc9738ab94"}], "stats": {"total": 648, "additions": 523, "deletions": 125}, "files": [{"sha": "7abefe654241ae1bf619798f9e880ffd167ab3d3", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -315,7 +315,7 @@ Released 2019-11-07\n   * [`missing_safety_doc`] [#4535](https://github.com/rust-lang/rust-clippy/pull/4535)\n   * [`mem_replace_with_uninit`] [#4511](https://github.com/rust-lang/rust-clippy/pull/4511)\n   * [`suspicious_map`] [#4394](https://github.com/rust-lang/rust-clippy/pull/4394)\n-  * [`option_and_then_some`] [#4386](https://github.com/rust-lang/rust-clippy/pull/4386)\n+  * `option_and_then_some` [#4386](https://github.com/rust-lang/rust-clippy/pull/4386)\n   * [`manual_saturating_arithmetic`] [#4498](https://github.com/rust-lang/rust-clippy/pull/4498)\n * Deprecate `unused_collect` lint. This is fully covered by rustc's `#[must_use]` on `collect` [#4348](https://github.com/rust-lang/rust-clippy/pull/4348)\n * Move `type_repetition_in_bounds` to pedantic group [#4403](https://github.com/rust-lang/rust-clippy/pull/4403)\n@@ -1273,6 +1273,7 @@ Released 2018-09-13\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n+[`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n@@ -1494,7 +1495,6 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n-[`option_and_then_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_and_then_some\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none"}, {"sha": "4e1c1f131405f39011b78660d6551e24b521718f", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                     let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                     multispan_sugg(\n                                         diag,\n-                                        \"use the values directly\".to_string(),\n+                                        \"use the values directly\",\n                                         vec![(left.span, lsnip), (right.span, rsnip)],\n                                     );\n                                 },"}, {"sha": "ec198b684b6ff7c027a3b54a5450c6974dfe574f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -650,6 +650,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         &mem_replace::MEM_REPLACE_WITH_DEFAULT,\n         &mem_replace::MEM_REPLACE_WITH_UNINIT,\n+        &methods::BIND_INSTEAD_OF_MAP,\n         &methods::CHARS_LAST_CMP,\n         &methods::CHARS_NEXT_CMP,\n         &methods::CLONE_DOUBLE_REF,\n@@ -676,7 +677,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::MAP_UNWRAP_OR,\n         &methods::NEW_RET_NO_SELF,\n         &methods::OK_EXPECT,\n-        &methods::OPTION_AND_THEN_SOME,\n         &methods::OPTION_AS_REF_DEREF,\n         &methods::OPTION_MAP_OR_NONE,\n         &methods::OR_FUN_CALL,\n@@ -1291,6 +1291,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_UNINIT),\n+        LintId::of(&methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(&methods::CHARS_LAST_CMP),\n         LintId::of(&methods::CHARS_NEXT_CMP),\n         LintId::of(&methods::CLONE_DOUBLE_REF),\n@@ -1307,7 +1308,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::MANUAL_SATURATING_ARITHMETIC),\n         LintId::of(&methods::NEW_RET_NO_SELF),\n         LintId::of(&methods::OK_EXPECT),\n-        LintId::of(&methods::OPTION_AND_THEN_SOME),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::OR_FUN_CALL),\n@@ -1559,10 +1559,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::MATCH_AS_REF),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n+        LintId::of(&methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(&methods::CLONE_ON_COPY),\n         LintId::of(&methods::FILTER_NEXT),\n         LintId::of(&methods::FLAT_MAP_IDENTITY),\n-        LintId::of(&methods::OPTION_AND_THEN_SOME),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n@@ -1784,6 +1784,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::new_without_default_derive\", \"clippy::new_without_default\");\n     ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n     ls.register_renamed(\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\");\n+    ls.register_renamed(\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\");\n     ls.register_renamed(\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\");\n     ls.register_renamed(\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\");\n     ls.register_renamed(\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\");"}, {"sha": "84e8a010738cfb9cf9f3307667aadefac106a668", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1134,7 +1134,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n-                                \"consider using an iterator\".to_string(),\n+                                \"consider using an iterator\",\n                                 vec![\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (\n@@ -1163,7 +1163,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n-                                \"consider using an iterator\".to_string(),\n+                                \"consider using an iterator\",\n                                 vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n                             );\n                         },\n@@ -1462,7 +1462,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                         let map = sugg::Sugg::hir(cx, arg, \"map\");\n                         multispan_sugg(\n                             diag,\n-                            \"use the corresponding method\".into(),\n+                            \"use the corresponding method\",\n                             vec![\n                                 (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n                                 (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),"}, {"sha": "bbf14374a1f7f0c741fd2336e20900be5e386cf1", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -820,7 +820,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>\n \n         span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n             if !expr.span.from_expansion() {\n-                multispan_sugg(diag, msg.to_owned(), suggs);\n+                multispan_sugg(diag, msg, suggs);\n             }\n         });\n     }"}, {"sha": "32e86637569ed3c642be6d766abcefe1e3fc9bb4", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -0,0 +1,309 @@\n+use super::{contains_return, BIND_INSTEAD_OF_MAP};\n+use crate::utils::{\n+    in_macro, match_qpath, match_type, method_calls, multispan_sugg_with_applicability, paths, remove_blocks, snippet,\n+    snippet_with_macro_callsite, span_lint_and_sugg, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::Span;\n+\n+pub(crate) struct OptionAndThenSome;\n+impl BindInsteadOfMap for OptionAndThenSome {\n+    const TYPE_NAME: &'static str = \"Option\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n+\n+    const BAD_METHOD_NAME: &'static str = \"and_then\";\n+    const BAD_VARIANT_NAME: &'static str = \"Some\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::OPTION_SOME;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map\";\n+}\n+\n+pub(crate) struct ResultAndThenOk;\n+impl BindInsteadOfMap for ResultAndThenOk {\n+    const TYPE_NAME: &'static str = \"Result\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n+\n+    const BAD_METHOD_NAME: &'static str = \"and_then\";\n+    const BAD_VARIANT_NAME: &'static str = \"Ok\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_OK;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map\";\n+}\n+\n+pub(crate) struct ResultOrElseErrInfo;\n+impl BindInsteadOfMap for ResultOrElseErrInfo {\n+    const TYPE_NAME: &'static str = \"Result\";\n+    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n+\n+    const BAD_METHOD_NAME: &'static str = \"or_else\";\n+    const BAD_VARIANT_NAME: &'static str = \"Err\";\n+    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_ERR;\n+\n+    const GOOD_METHOD_NAME: &'static str = \"map_err\";\n+}\n+\n+pub(crate) trait BindInsteadOfMap {\n+    const TYPE_NAME: &'static str;\n+    const TYPE_QPATH: &'static [&'static str];\n+\n+    const BAD_METHOD_NAME: &'static str;\n+    const BAD_VARIANT_NAME: &'static str;\n+    const BAD_VARIANT_QPATH: &'static [&'static str];\n+\n+    const GOOD_METHOD_NAME: &'static str;\n+\n+    fn no_op_msg() -> String {\n+        format!(\n+            \"using `{}.{}({})`, which is a no-op\",\n+            Self::TYPE_NAME,\n+            Self::BAD_METHOD_NAME,\n+            Self::BAD_VARIANT_NAME\n+        )\n+    }\n+\n+    fn lint_msg() -> String {\n+        format!(\n+            \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n+            Self::TYPE_NAME,\n+            Self::BAD_METHOD_NAME,\n+            Self::BAD_VARIANT_NAME,\n+            Self::GOOD_METHOD_NAME\n+        )\n+    }\n+\n+    fn lint_closure_autofixable(\n+        cx: &LateContext<'_, '_>,\n+        expr: &hir::Expr<'_>,\n+        args: &[hir::Expr<'_>],\n+        closure_expr: &hir::Expr<'_>,\n+        closure_args_span: Span,\n+    ) -> bool {\n+        if_chain! {\n+            if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n+            if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n+            if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n+            if some_args.len() == 1;\n+            then {\n+                let inner_expr = &some_args[0];\n+\n+                if contains_return(inner_expr) {\n+                    return false;\n+                }\n+\n+                let some_inner_snip = if inner_expr.span.from_expansion() {\n+                    snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n+                } else {\n+                    snippet(cx, inner_expr.span, \"_\")\n+                };\n+\n+                let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n+                let option_snip = snippet(cx, args[0].span, \"..\");\n+                let note = format!(\"{}.{}({} {})\", option_snip, Self::GOOD_METHOD_NAME, closure_args_snip, some_inner_snip);\n+                span_lint_and_sugg(\n+                    cx,\n+                    BIND_INSTEAD_OF_MAP,\n+                    expr.span,\n+                    Self::lint_msg().as_ref(),\n+                    \"try this\",\n+                    note,\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    fn lint_closure(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n+        let mut suggs = Vec::new();\n+        let can_sugg = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n+            if_chain! {\n+                if !in_macro(ret_expr.span);\n+                if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n+                if let hir::ExprKind::Path(ref qpath) = func_path.kind;\n+                if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n+                if args.len() == 1;\n+                if !contains_return(&args[0]);\n+                then {\n+                    suggs.push((ret_expr.span, args[0].span.source_callsite()));\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        });\n+\n+        if can_sugg {\n+            span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, Self::lint_msg().as_ref(), |diag| {\n+                multispan_sugg_with_applicability(\n+                    diag,\n+                    \"try this\",\n+                    Applicability::MachineApplicable,\n+                    std::iter::once((*method_calls(expr, 1).2.get(0).unwrap(), Self::GOOD_METHOD_NAME.into())).chain(\n+                        suggs\n+                            .into_iter()\n+                            .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n+                    ),\n+                )\n+            });\n+        }\n+    }\n+\n+    /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n+    fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+        if !match_type(cx, cx.tables.expr_ty(&args[0]), Self::TYPE_QPATH) {\n+            return;\n+        }\n+\n+        match args[1].kind {\n+            hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                let closure_expr = remove_blocks(&closure_body.value);\n+\n+                if !Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                    Self::lint_closure(cx, expr, closure_expr);\n+                }\n+            },\n+            // `_.and_then(Some)` case, which is no-op.\n+            hir::ExprKind::Path(ref qpath) if match_qpath(qpath, Self::BAD_VARIANT_QPATH) => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    BIND_INSTEAD_OF_MAP,\n+                    expr.span,\n+                    Self::no_op_msg().as_ref(),\n+                    \"use the expression directly\",\n+                    snippet(cx, args[0].span, \"..\").into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+/// returns `true` if expr contains match expr desugared from try\n+fn contains_try(expr: &hir::Expr<'_>) -> bool {\n+    struct TryFinder {\n+        found: bool,\n+    }\n+\n+    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+            if self.found {\n+                return;\n+            }\n+            match expr.kind {\n+                hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar) => self.found = true,\n+                _ => intravisit::walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut visitor = TryFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_, '_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n+where\n+    F: FnMut(&'hir hir::Expr<'hir>) -> bool,\n+{\n+    struct RetFinder<F> {\n+        in_stmt: bool,\n+        failed: bool,\n+        cb: F,\n+    }\n+\n+    struct WithStmtGuarg<'a, F> {\n+        val: &'a mut RetFinder<F>,\n+        prev_in_stmt: bool,\n+    }\n+\n+    impl<F> RetFinder<F> {\n+        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n+            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n+            WithStmtGuarg {\n+                val: self,\n+                prev_in_stmt,\n+            }\n+        }\n+    }\n+\n+    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n+        type Target = RetFinder<F>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> Drop for WithStmtGuarg<'_, F> {\n+        fn drop(&mut self) {\n+            self.val.in_stmt = self.prev_in_stmt;\n+        }\n+    }\n+\n+    impl<'hir, F: FnMut(&'hir hir::Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'_>) {\n+            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'_>) {\n+            if self.failed {\n+                return;\n+            }\n+            if self.in_stmt {\n+                match expr.kind {\n+                    hir::ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n+                    _ => intravisit::walk_expr(self, expr),\n+                }\n+            } else {\n+                match expr.kind {\n+                    hir::ExprKind::Match(cond, arms, _) => {\n+                        self.inside_stmt(true).visit_expr(cond);\n+                        for arm in arms {\n+                            self.visit_expr(arm.body);\n+                        }\n+                    },\n+                    hir::ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n+                    hir::ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n+                    _ => self.failed |= !(self.cb)(expr),\n+                }\n+            }\n+        }\n+    }\n+\n+    !contains_try(expr) && {\n+        let mut ret_finder = RetFinder {\n+            in_stmt: false,\n+            failed: false,\n+            cb: callback,\n+        };\n+        ret_finder.visit_expr(expr);\n+        !ret_finder.failed\n+    }\n+}"}, {"sha": "626427c15ecf52b2e47c7c3f77ccada601afbc7b", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 24, "deletions": 76, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,3 +1,4 @@\n+mod bind_instead_of_map;\n mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n@@ -7,6 +8,7 @@ use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n \n+use bind_instead_of_map::BindInsteadOfMap;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -306,27 +308,34 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `_.and_then(|x| Some(y))`.\n+    /// **What it does:** Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n+    /// `_.or_else(|x| Err(y))`.\n     ///\n     /// **Why is this bad?** Readability, this can be written more concisely as\n-    /// `_.map(|x| y)`.\n+    /// `_.map(|x| y)` or `_.map_err(|x| y)`.\n     ///\n     /// **Known problems:** None\n     ///\n     /// **Example:**\n     ///\n     /// ```rust\n-    /// let x = Some(\"foo\");\n-    /// let _ = x.and_then(|s| Some(s.len()));\n+    /// # fn opt() -> Option<&'static str> { Some(\"42\") }\n+    /// # fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\n+    /// let _ = opt().and_then(|s| Some(s.len()));\n+    /// let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\n+    /// let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n     /// ```\n     ///\n     /// The correct use would be:\n     ///\n     /// ```rust\n-    /// let x = Some(\"foo\");\n-    /// let _ = x.map(|s| s.len());\n+    /// # fn opt() -> Option<&'static str> { Some(\"42\") }\n+    /// # fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\n+    /// let _ = opt().map(|s| s.len());\n+    /// let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n+    /// let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n     /// ```\n-    pub OPTION_AND_THEN_SOME,\n+    pub BIND_INSTEAD_OF_MAP,\n     complexity,\n     \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\"\n }\n@@ -1243,7 +1252,7 @@ declare_lint_pass!(Methods => [\n     MAP_UNWRAP_OR,\n     RESULT_MAP_OR_INTO_OPTION,\n     OPTION_MAP_OR_NONE,\n-    OPTION_AND_THEN_SOME,\n+    BIND_INSTEAD_OF_MAP,\n     OR_FUN_CALL,\n     EXPECT_FUN_CALL,\n     CHARS_NEXT_CMP,\n@@ -1302,7 +1311,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n-            [\"and_then\", ..] => lint_option_and_then_some(cx, expr, arg_lists[0]),\n+            [\"and_then\", ..] => {\n+                bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n+                bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n+            },\n+            [\"or_else\", ..] => {\n+                bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n+            },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n@@ -2601,73 +2616,6 @@ fn lint_map_or_none<'a, 'tcx>(\n     );\n }\n \n-/// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    const LINT_MSG: &str = \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\";\n-    const NO_OP_MSG: &str = \"using `Option.and_then(Some)`, which is a no-op\";\n-\n-    let ty = cx.tables.expr_ty(&args[0]);\n-    if !is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n-        return;\n-    }\n-\n-    match args[1].kind {\n-        hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n-            if_chain! {\n-                if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n-                if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n-                if match_qpath(qpath, &paths::OPTION_SOME);\n-                if some_args.len() == 1;\n-                then {\n-                    let inner_expr = &some_args[0];\n-\n-                    if contains_return(inner_expr) {\n-                        return;\n-                    }\n-\n-                    let some_inner_snip = if inner_expr.span.from_expansion() {\n-                        snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n-                    } else {\n-                        snippet(cx, inner_expr.span, \"_\")\n-                    };\n-\n-                    let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n-                    let option_snip = snippet(cx, args[0].span, \"..\");\n-                    let note = format!(\"{}.map({} {})\", option_snip, closure_args_snip, some_inner_snip);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        OPTION_AND_THEN_SOME,\n-                        expr.span,\n-                        LINT_MSG,\n-                        \"try this\",\n-                        note,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        },\n-        // `_.and_then(Some)` case, which is no-op.\n-        hir::ExprKind::Path(ref qpath) => {\n-            if match_qpath(qpath, &paths::OPTION_SOME) {\n-                let option_snip = snippet(cx, args[0].span, \"..\");\n-                let note = format!(\"{}\", option_snip);\n-                span_lint_and_sugg(\n-                    cx,\n-                    OPTION_AND_THEN_SOME,\n-                    expr.span,\n-                    NO_OP_MSG,\n-                    \"use the expression directly\",\n-                    note,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => {},\n-    }\n-}\n-\n /// lint use of `filter().next()` for `Iterators`\n fn lint_filter_next<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,"}, {"sha": "ed48ab548978c67811c7056c949e38007ca41743", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             );\n                             spans.sort_by_key(|&(span, _)| span);\n                         }\n-                        multispan_sugg(diag, \"consider taking a reference instead\".to_string(), spans);\n+                        multispan_sugg(diag, \"consider taking a reference instead\", spans);\n                     };\n \n                     span_lint_and_then("}, {"sha": "6ed9ff22e466482bd7d473cea7f40992e3d3ad02", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -2206,7 +2206,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n \n             multispan_sugg(\n                 diag,\n-                \"consider adding a type parameter\".to_string(),\n+                \"consider adding a type parameter\",\n                 vec![\n                     (\n                         generics_suggestion_span,\n@@ -2230,7 +2230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             );\n \n             if !vis.suggestions.is_empty() {\n-                multispan_sugg(diag, \"...and use generic constructor\".into(), vis.suggestions);\n+                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n             }\n         }\n "}, {"sha": "f6d87c8532e430357b22a54b825c580fe1f0dc31", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,6 +1,6 @@\n //! Clippy wrappers around rustc's diagnostic functions.\n \n-use rustc_errors::{Applicability, CodeSuggestion, DiagnosticBuilder, Substitution, SubstitutionPart, SuggestionStyle};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n use rustc_span::source_map::{MultiSpan, Span};\n@@ -198,20 +198,20 @@ pub fn span_lint_and_sugg<'a, T: LintContext>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n+pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: &str, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n-    let sugg = CodeSuggestion {\n-        substitutions: vec![Substitution {\n-            parts: sugg\n-                .into_iter()\n-                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                .collect(),\n-        }],\n-        msg: help_msg,\n-        style: SuggestionStyle::ShowCode,\n-        applicability: Applicability::Unspecified,\n-    };\n-    diag.suggestions.push(sugg);\n+    multispan_sugg_with_applicability(diag, help_msg, Applicability::Unspecified, sugg)\n+}\n+\n+pub fn multispan_sugg_with_applicability<I>(\n+    diag: &mut DiagnosticBuilder<'_>,\n+    help_msg: &str,\n+    applicability: Applicability,\n+    sugg: I,\n+) where\n+    I: IntoIterator<Item = (Span, String)>,\n+{\n+    diag.multipart_suggestion(help_msg, sugg.into_iter().collect(), applicability);\n }"}, {"sha": "5b4e2906b5f677fedea24c8df61fb12201b83645", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -66,6 +66,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"bit_mask\",\n     },\n+    Lint {\n+        name: \"bind_instead_of_map\",\n+        group: \"complexity\",\n+        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"blacklisted_name\",\n         group: \"style\",\n@@ -1578,13 +1585,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"eq_op\",\n     },\n-    Lint {\n-        name: \"option_and_then_some\",\n-        group: \"complexity\",\n-        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n     Lint {\n         name: \"option_as_ref_deref\",\n         group: \"complexity\","}, {"sha": "5815550d7a6a1e04d4f4ba489693ca849dacb1b9", "filename": "tests/ui/bind_instead_of_map.fixed", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.fixed?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(clippy::option_and_then_some)]\n+#![deny(clippy::bind_instead_of_map)]\n \n // need a main anyway, use it get rid of unused warnings too\n pub fn main() {\n@@ -12,7 +12,7 @@ pub fn main() {\n \n     // Different type\n     let x: Result<u32, &str> = Ok(1);\n-    let _ = x.and_then(Ok);\n+    let _ = x;\n }\n \n pub fn foo() -> Option<String> {", "previous_filename": "tests/ui/option_and_then_some.fixed"}, {"sha": "623b100a4ce7ea14ab2249f94b64b159e947e536", "filename": "tests/ui/bind_instead_of_map.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![deny(clippy::option_and_then_some)]\n+#![deny(clippy::bind_instead_of_map)]\n \n // need a main anyway, use it get rid of unused warnings too\n pub fn main() {", "previous_filename": "tests/ui/option_and_then_some.rs"}, {"sha": "24c6b7f9ef32b08a2f660bcf7e20b6922b530ab8", "filename": "tests/ui/bind_instead_of_map.stderr", "status": "renamed", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map.stderr?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,20 +1,26 @@\n error: using `Option.and_then(Some)`, which is a no-op\n-  --> $DIR/option_and_then_some.rs:8:13\n+  --> $DIR/bind_instead_of_map.rs:8:13\n    |\n LL |     let _ = x.and_then(Some);\n    |             ^^^^^^^^^^^^^^^^ help: use the expression directly: `x`\n    |\n note: the lint level is defined here\n-  --> $DIR/option_and_then_some.rs:2:9\n+  --> $DIR/bind_instead_of_map.rs:2:9\n    |\n-LL | #![deny(clippy::option_and_then_some)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(clippy::bind_instead_of_map)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n-  --> $DIR/option_and_then_some.rs:9:13\n+  --> $DIR/bind_instead_of_map.rs:9:13\n    |\n LL |     let _ = x.and_then(|o| Some(o + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.map(|o| o + 1)`\n \n-error: aborting due to 2 previous errors\n+error: using `Result.and_then(Ok)`, which is a no-op\n+  --> $DIR/bind_instead_of_map.rs:15:13\n+   |\n+LL |     let _ = x.and_then(Ok);\n+   |             ^^^^^^^^^^^^^^ help: use the expression directly: `x`\n+\n+error: aborting due to 3 previous errors\n ", "previous_filename": "tests/ui/option_and_then_some.stderr"}, {"sha": "91d9d11e3c11056ced998350542ce7e9cf745a74", "filename": "tests/ui/bind_instead_of_map_multipart.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map_multipart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map_multipart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map_multipart.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -0,0 +1,61 @@\n+#![deny(clippy::bind_instead_of_map)]\n+#![allow(clippy::blocks_in_if_conditions)]\n+\n+pub fn main() {\n+    let _ = Some(\"42\").and_then(|s| if s.len() < 42 { Some(0) } else { Some(s.len()) });\n+    let _ = Some(\"42\").and_then(|s| if s.len() < 42 { None } else { Some(s.len()) });\n+\n+    let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Ok(0) } else { Ok(s.len()) });\n+    let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Err(()) } else { Ok(s.len()) });\n+\n+    let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Err(s.len() + 20) } else { Err(s.len()) });\n+    let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Ok(()) } else { Err(s.len()) });\n+\n+    hard_example();\n+    macro_example();\n+}\n+\n+fn hard_example() {\n+    Some(\"42\").and_then(|s| {\n+        if {\n+            if s == \"43\" {\n+                return Some(43);\n+            }\n+            s == \"42\"\n+        } {\n+            return Some(45);\n+        }\n+        match s.len() {\n+            10 => Some(2),\n+            20 => {\n+                if foo() {\n+                    return {\n+                        if foo() {\n+                            return Some(20);\n+                        }\n+                        println!(\"foo\");\n+                        Some(3)\n+                    };\n+                }\n+                Some(20)\n+            },\n+            40 => Some(30),\n+            _ => Some(1),\n+        }\n+    });\n+}\n+\n+fn foo() -> bool {\n+    true\n+}\n+\n+macro_rules! m {\n+    () => {\n+        Some(10)\n+    };\n+}\n+\n+fn macro_example() {\n+    let _ = Some(\"\").and_then(|s| if s.len() == 20 { m!() } else { Some(20) });\n+    let _ = Some(\"\").and_then(|s| if s.len() == 20 { Some(m!()) } else { Some(Some(20)) });\n+}"}, {"sha": "50ce2f4051e008df976e2ed16b743f2d4d174d40", "filename": "tests/ui/bind_instead_of_map_multipart.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map_multipart.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fbind_instead_of_map_multipart.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbind_instead_of_map_multipart.stderr?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -0,0 +1,73 @@\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:5:13\n+   |\n+LL |     let _ = Some(\"42\").and_then(|s| if s.len() < 42 { Some(0) } else { Some(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/bind_instead_of_map_multipart.rs:1:9\n+   |\n+LL | #![deny(clippy::bind_instead_of_map)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try this\n+   |\n+LL |     let _ = Some(\"42\").map(|s| if s.len() < 42 { 0 } else { s.len() });\n+   |                        ^^^                       ^          ^^^^^^^\n+\n+error: using `Result.and_then(|x| Ok(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:8:13\n+   |\n+LL |     let _ = Ok::<_, ()>(\"42\").and_then(|s| if s.len() < 42 { Ok(0) } else { Ok(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Ok::<_, ()>(\"42\").map(|s| if s.len() < 42 { 0 } else { s.len() });\n+   |                               ^^^                       ^          ^^^^^^^\n+\n+error: using `Result.or_else(|x| Err(y))`, which is more succinctly expressed as `map_err(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:11:13\n+   |\n+LL |     let _ = Err::<(), _>(\"42\").or_else(|s| if s.len() < 42 { Err(s.len() + 20) } else { Err(s.len()) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Err::<(), _>(\"42\").map_err(|s| if s.len() < 42 { s.len() + 20 } else { s.len() });\n+   |                                ^^^^^^^                       ^^^^^^^^^^^^          ^^^^^^^\n+\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:19:5\n+   |\n+LL | /     Some(\"42\").and_then(|s| {\n+LL | |         if {\n+LL | |             if s == \"43\" {\n+LL | |                 return Some(43);\n+...  |\n+LL | |         }\n+LL | |     });\n+   | |______^\n+   |\n+help: try this\n+   |\n+LL |     Some(\"42\").map(|s| {\n+LL |         if {\n+LL |             if s == \"43\" {\n+LL |                 return 43;\n+LL |             }\n+LL |             s == \"42\"\n+ ...\n+\n+error: using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n+  --> $DIR/bind_instead_of_map_multipart.rs:60:13\n+   |\n+LL |     let _ = Some(\"\").and_then(|s| if s.len() == 20 { Some(m!()) } else { Some(Some(20)) });\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = Some(\"\").map(|s| if s.len() == 20 { m!() } else { Some(20) });\n+   |                      ^^^                        ^^^^          ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "14562c4d32c12996c3b56073ed602e0ed7dd0ba3", "filename": "tests/ui/blocks_in_if_conditions.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fblocks_in_if_conditions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fblocks_in_if_conditions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.fixed?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -63,10 +63,10 @@ fn block_in_assert() {\n     let opt = Some(42);\n     assert!(opt\n         .as_ref()\n-        .and_then(|val| {\n+        .map(|val| {\n             let mut v = val * 2;\n             v -= 1;\n-            Some(v * 3)\n+            v * 3\n         })\n         .is_some());\n }"}, {"sha": "bda87650f6da2c4c2537169099da12c13a220e3e", "filename": "tests/ui/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -63,10 +63,10 @@ fn block_in_assert() {\n     let opt = Some(42);\n     assert!(opt\n         .as_ref()\n-        .and_then(|val| {\n+        .map(|val| {\n             let mut v = val * 2;\n             v -= 1;\n-            Some(v * 3)\n+            v * 3\n         })\n         .is_some());\n }"}, {"sha": "d80c3c7c1b7225664a91e95254005e748d919c9a", "filename": "tests/ui/option_map_or_none.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Foption_map_or_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Foption_map_or_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.fixed?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::option_and_then_some)]\n+#![allow(clippy::bind_instead_of_map)]\n \n fn main() {\n     let opt = Some(1);"}, {"sha": "629842419e546d1af1e57ffe1c8062797a46f04d", "filename": "tests/ui/option_map_or_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae0643d1a30a72d27f427064a16cf32bdb92283/tests%2Fui%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.rs?ref=6ae0643d1a30a72d27f427064a16cf32bdb92283", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::option_and_then_some)]\n+#![allow(clippy::bind_instead_of_map)]\n \n fn main() {\n     let opt = Some(1);"}]}