{"sha": "41f5907fa6b04614821277dd63172c5c8f11b6cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZjU5MDdmYTZiMDQ2MTQ4MjEyNzdkZDYzMTcyYzVjOGYxMWI2Y2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-16T08:42:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-16T08:42:40Z"}, "message": "auto merge of #19777 : nikomatsakis/rust/warn-on-shadowing, r=acrichto\n\nper rfc 459\r\ncc https://github.com/rust-lang/rust/issues/19390\r\n\r\nOne question is: should we start by warning, and only switch to hard error later? I think we discussed something like this in the meeting. \r\n\r\nr? @alexcrichton", "tree": {"sha": "0d01fe703bde512c2174b650808fbdccf0562f51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d01fe703bde512c2174b650808fbdccf0562f51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f5907fa6b04614821277dd63172c5c8f11b6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f5907fa6b04614821277dd63172c5c8f11b6cd", "html_url": "https://github.com/rust-lang/rust/commit/41f5907fa6b04614821277dd63172c5c8f11b6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f5907fa6b04614821277dd63172c5c8f11b6cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd8b5b5eac3551dcf17ab04888d5052bf870804", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd8b5b5eac3551dcf17ab04888d5052bf870804", "html_url": "https://github.com/rust-lang/rust/commit/cdd8b5b5eac3551dcf17ab04888d5052bf870804"}, {"sha": "1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "html_url": "https://github.com/rust-lang/rust/commit/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb"}], "stats": {"total": 446, "additions": 268, "deletions": 178}, "files": [{"sha": "6113e2323c1f719b49430696cef9267311ab70e5", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -154,7 +154,7 @@ struct MaskWords<'a> {\n impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n     /// Returns (offset, word)\n     #[inline]\n-    fn next<'a>(&'a mut self) -> Option<(uint, u32)> {\n+    fn next(&mut self) -> Option<(uint, u32)> {\n         let ret = self.next_word;\n         match ret {\n             Some(&w) => {"}, {"sha": "00f4eac2858e21204c90eeeb76d36fbf3fe52425", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -561,7 +561,7 @@ mod stack {\n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n         /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n         /// root of the tree.\n-        pub fn new<'a>(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n+        pub fn new(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n             let depth = map.depth;\n \n             PartialSearchStack {"}, {"sha": "3ae66954e9c9714af081b3ae99ab59ff0751452c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -692,7 +692,7 @@ impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     }\n \n     #[inline]\n-    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n+    fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n         }"}, {"sha": "6ece6264d8c291a6044df8a612868b1908f9f815", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -115,7 +115,7 @@ impl<'a> Argument<'a> {\n         Show::fmt(x, f)\n     }\n \n-    fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'a> {\n+    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n         unsafe {\n             Argument {\n                 formatter: mem::transmute(f),\n@@ -124,7 +124,7 @@ impl<'a> Argument<'a> {\n         }\n     }\n \n-    fn from_uint<'a>(x: &'a uint) -> Argument<'a> {\n+    fn from_uint(x: &uint) -> Argument {\n         Argument::new(x, Argument::show_uint)\n     }\n \n@@ -144,8 +144,8 @@ impl<'a> Arguments<'a> {\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub fn new<'a>(pieces: &'a [&'a str],\n-                   args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn new(pieces: &'a [&'a str],\n+               args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: None,\n@@ -161,9 +161,9 @@ impl<'a> Arguments<'a> {\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub fn with_placeholders<'a>(pieces: &'a [&'a str],\n-                                 fmt: &'a [rt::Argument<'a>],\n-                                 args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn with_placeholders(pieces: &'a [&'a str],\n+                             fmt: &'a [rt::Argument<'a>],\n+                             args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: Some(fmt),"}, {"sha": "a186d0a6fa577aad63fe0fe5b427879a2f5f9e01", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -639,12 +639,12 @@ impl<T> AsSlice<T> for [T] {\n \n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { AsSlice::as_slice(*self) }\n+    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { AsSlice::as_slice(*self) }\n+    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[unstable = \"waiting for DST\"]"}, {"sha": "444806e78c129f4b3f68e51a697549cd1446c7d8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -185,7 +185,7 @@ impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n \n impl<'a> Parser<'a> {\n     /// Creates a new parser for the given format string\n-    pub fn new<'a>(s: &'a str) -> Parser<'a> {\n+    pub fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n             input: s,\n             cur: s.char_indices(),"}, {"sha": "8ce761580b762abf3c076521e07012f7a3716819", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -165,10 +165,10 @@\n //!     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n)).unwrap()\n //!     }\n-//!     fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n+//!     fn node_label<'b>(&'b self, n: &Nd) -> dot::LabelText<'b> {\n //!         dot::LabelStr(self.nodes[*n].as_slice().into_cow())\n //!     }\n-//!     fn edge_label<'a>(&'a self, _: &Ed) -> dot::LabelText<'a> {\n+//!     fn edge_label<'b>(&'b self, _: &Ed) -> dot::LabelText<'b> {\n //!         dot::LabelStr(\"&sube;\".into_cow())\n //!     }\n //! }\n@@ -220,11 +220,11 @@\n //!     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n.0)).unwrap()\n //!     }\n-//!     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n+//!     fn node_label<'b>(&'b self, n: &Nd<'b>) -> dot::LabelText<'b> {\n //!         let &(i, _) = n;\n //!         dot::LabelStr(self.nodes[i].as_slice().into_cow())\n //!     }\n-//!     fn edge_label<'a>(&'a self, _: &Ed<'a>) -> dot::LabelText<'a> {\n+//!     fn edge_label<'b>(&'b self, _: &Ed<'b>) -> dot::LabelText<'b> {\n //!         dot::LabelStr(\"&sube;\".into_cow())\n //!     }\n //! }"}, {"sha": "be8761043c0c77715720f513e05e4bc1d5ece26d", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -154,7 +154,7 @@ impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n }\n \n impl<'a> BytesContainer for MaybeOwnedVector<'a, u8> {\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+    fn container_as_bytes(&self) -> &[u8] {\n         self.as_slice()\n     }\n }"}, {"sha": "58125c67fdae9edef566e871a5a96de8d1ff453a", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -114,7 +114,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// - `v` is empty\n     /// - the total weight is 0\n     /// - the total weight is larger than a `uint` can contain.\n-    pub fn new<'a>(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n+    pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n "}, {"sha": "8fad90adc9db090bd85325474fd5782845d0707a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -601,7 +601,7 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n-    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n         -> (ty::ExprAdjustment, MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n@@ -810,7 +810,7 @@ trait get_ty_str_ctxt<'tcx> {\n }\n \n impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx> {\n+    fn ty_str_ctxt<'b>(&'b self) -> tyencode::ctxt<'b, 'tcx> {\n         tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_string,\n@@ -851,16 +851,16 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_closure_type<'a>(&mut self,\n-                             ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_closure_type<'b>(&mut self,\n+                             ecx: &e::EncodeContext<'b, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(e::write_closure_type(ecx, this, closure_type))\n         });\n     }\n \n-    fn emit_method_origin<'a>(&mut self,\n-                              ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_method_origin<'b>(&mut self,\n+                              ecx: &e::EncodeContext<'b, 'tcx>,\n                               method_origin: &ty::MethodOrigin<'tcx>)\n     {\n         use serialize::Encoder;\n@@ -916,20 +916,20 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>) {\n+    fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]) {\n+    fn emit_tys<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, tys: &[Ty<'tcx>]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n-    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_trait_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           trait_ref: &ty::TraitRef<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n     }\n \n-    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_type_param_def<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_type_param_def(this.writer,\n@@ -938,7 +938,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_predicate(this.writer,\n@@ -947,8 +947,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_polytype<'a>(&mut self,\n-                         ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_polytype<'b>(&mut self,\n+                         ecx: &e::EncodeContext<'b, 'tcx>,\n                          pty: ty::Polytype<'tcx>) {\n         use serialize::Encoder;\n \n@@ -990,14 +990,14 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n-    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n \n-    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1019,7 +1019,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                         autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1069,7 +1069,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1086,7 +1086,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_unsize_kind<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                             uk: &ty::UnsizeKind<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1427,7 +1427,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_method_origin<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                   -> ty::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n@@ -1498,7 +1498,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n \n-    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx> {\n+    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1526,12 +1526,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_tys<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                         -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n-    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n@@ -1544,7 +1544,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n-    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n         self.read_opaque(|this, doc| {\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_polytype<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                              -> ty::Polytype<'tcx> {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n@@ -1599,7 +1599,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                        -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n@@ -1611,7 +1611,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n@@ -1622,7 +1622,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_auto_deref_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n@@ -1667,7 +1667,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> ty::AutoRef<'tcx> {\n+    fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> ty::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1725,7 +1725,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_unsize_kind<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                 -> ty::UnsizeKind<'tcx> {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n@@ -1768,7 +1768,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_unboxed_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::UnboxedClosure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data("}, {"sha": "5c39c9fa74d0a43e4b90fe0a21cb9ff16f236fe8", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'a, I: Iterator<&'a P<ast::Pat>>>(&mut self,\n+    fn pats_all<'b, I: Iterator<&'b P<ast::Pat>>>(&mut self,\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn call<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn call<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n             call_expr: &ast::Expr,\n             pred: CFGIndex,\n             func_or_rcvr: &ast::Expr,\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn exprs<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n                                              exprs: I,\n                                              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn straightline<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n                     expr: &ast::Expr,\n                     pred: CFGIndex,\n                     subexprs: I) -> CFGIndex {"}, {"sha": "034bf3e840a896f4ba8d223ed2e9d97b0623e1f1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -392,7 +392,7 @@ pub struct StaticInliner<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'a>(tcx: &'a ty::ctxt<'tcx>) -> StaticInliner<'a, 'tcx> {\n+    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>) -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n             failed: false"}, {"sha": "3cd981b57844c3682ff963d70af5022471067179", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -539,29 +539,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n+    pub fn skolemizer<'b>(&'b self) -> TypeSkolemizer<'b, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n \n-    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                              -> CombineFields<'a, 'tcx> {\n+    pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                              -> CombineFields<'b, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> Equate<'a, 'tcx> {\n+    pub fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> Equate<'b, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Sub<'a, 'tcx> {\n+    pub fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Sub<'b, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Lub<'a, 'tcx> {\n+    pub fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Lub<'b, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n "}, {"sha": "e855511e26f80e410b487873caad0fc410b9b2cb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -561,8 +561,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn combine_map<'a>(&'a self, t: CombineMapType)\n-                   -> &'a RefCell<CombineMap> {\n+    fn combine_map(&self, t: CombineMapType)\n+                   -> &RefCell<CombineMap> {\n         match t {\n             Glb => &self.glbs,\n             Lub => &self.lubs,"}, {"sha": "8336131c54acc223ef977f2d3670c45a7b8568d2", "filename": "src/librustc/middle/infer/skolemize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -46,7 +46,7 @@ pub struct TypeSkolemizer<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n-    pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n         TypeSkolemizer {\n             infcx: infcx,\n             skolemization_count: 0,"}, {"sha": "1923142be9e3fcb9b9de509dc50d7bb85d5ea3a1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 101, "deletions": 53, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -90,48 +90,51 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemFn(..) => {\n-                // Fn lifetimes get added in visit_fn below:\n-                self.with(RootScope, |this| visit::walk_item(this, item));\n-            }\n-            ast::ItemMod(..) |\n-            ast::ItemMac(..) |\n-            ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) |\n-            ast::ItemConst(..) => {\n-                // These sorts of items have no lifetime parameters at all.\n-                self.with(RootScope, |this| visit::walk_item(this, item));\n-            }\n-            ast::ItemTy(_, ref generics) |\n-            ast::ItemEnum(_, ref generics) |\n-            ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(_, ref generics, _, _, _) => {\n-                // These kinds of items have only early bound lifetime parameters.\n-                let lifetimes = &generics.lifetimes;\n-                self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n-                    this.check_lifetime_defs(lifetimes);\n+        // Items always introduce a new root scope\n+        self.with(RootScope, |_, this| {\n+            match item.node {\n+                ast::ItemFn(..) => {\n+                    // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n-                });\n-            }\n-            ast::ItemImpl(_, ref generics, _, _, _) => {\n-                // Impls have both early- and late-bound lifetimes.\n-                self.visit_early_late(subst::TypeSpace, generics, |this| {\n-                    this.check_lifetime_defs(&generics.lifetimes);\n+                }\n+                ast::ItemMod(..) |\n+                ast::ItemMac(..) |\n+                ast::ItemForeignMod(..) |\n+                ast::ItemStatic(..) |\n+                ast::ItemConst(..) => {\n+                    // These sorts of items have no lifetime parameters at all.\n                     visit::walk_item(this, item);\n-                })\n+                }\n+                ast::ItemTy(_, ref generics) |\n+                ast::ItemEnum(_, ref generics) |\n+                ast::ItemStruct(_, ref generics) |\n+                ast::ItemTrait(_, ref generics, _, _, _) => {\n+                    // These kinds of items have only early bound lifetime parameters.\n+                    let lifetimes = &generics.lifetimes;\n+                    let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n+                    this.with(early_scope, |old_scope, this| {\n+                        this.check_lifetime_defs(old_scope, lifetimes);\n+                        visit::walk_item(this, item);\n+                    });\n+                }\n+                ast::ItemImpl(_, ref generics, _, _, _) => {\n+                    // Impls have both early- and late-bound lifetimes.\n+                    this.visit_early_late(subst::TypeSpace, generics, |this| {\n+                        visit::walk_item(this, item);\n+                    })\n+                }\n             }\n-        }\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                self.visit_early_late(\n-                    subst::FnSpace, generics,\n-                    |this| visit::walk_fn(this, fk, fd, b, s))\n+                self.visit_early_late(subst::FnSpace, generics, |this| {\n+                    visit::walk_fn(this, fk, fd, b, s)\n+                })\n             }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n@@ -145,8 +148,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // Careful, the bounds on a closure/proc are *not* within its binder.\n                 visit::walk_ty_param_bounds_helper(self, &c.bounds);\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n-                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n-                    this.check_lifetime_defs(&c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n+                    this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     for argument in c.decl.inputs.iter() {\n                         this.visit_ty(&*argument.ty)\n                     }\n@@ -155,10 +158,10 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             }\n             ast::TyBareFn(ref c) => {\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n-                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n-                    this.check_lifetime_defs(&c.lifetimes);\n+                    this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     visit::walk_ty(this, ty);\n                 });\n             }\n@@ -167,7 +170,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&id) {\n                     Some(&def::DefTrait(..)) => {\n-                        self.with(LateScope(&Vec::new(), self.scope), |this| {\n+                        self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n                             this.visit_path(path, id);\n                         });\n                     }\n@@ -190,7 +193,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_block(&mut self, b: &ast::Block) {\n         self.with(BlockScope(region::CodeExtent::from_node_id(b.id), self.scope),\n-                  |this| visit::walk_block(this, b));\n+                  |_, this| visit::walk_block(this, b));\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -232,8 +235,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n         debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n \n-        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |this| {\n-            this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n+        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+            this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n             for lifetime in trait_ref.bound_lifetimes.iter() {\n                 this.visit_lifetime_def(lifetime);\n             }\n@@ -248,7 +251,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n impl<'a> LifetimeContext<'a> {\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: FnOnce(&mut LifetimeContext),\n+        F: FnOnce(Scope, &mut LifetimeContext),\n     {\n         let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -258,7 +261,7 @@ impl<'a> LifetimeContext<'a> {\n             def_map: self.def_map,\n         };\n         debug!(\"entering scope {}\", this.scope);\n-        f(&mut this);\n+        f(self.scope, &mut this);\n         debug!(\"exiting scope {}\", this.scope);\n     }\n \n@@ -294,9 +297,9 @@ impl<'a> LifetimeContext<'a> {\n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n-        self.with(EarlyScope(early_space, &early, self.scope), move |this| {\n-            this.with(LateScope(&late, this.scope), move |this| {\n-                this.check_lifetime_defs(&generics.lifetimes);\n+        self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {\n+            this.with(LateScope(&late, this.scope), move |_, this| {\n+                this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n             });\n         });\n@@ -323,7 +326,8 @@ impl<'a> LifetimeContext<'a> {\n \n                 EarlyScope(space, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, decl_id)) => {\n+                        Some((index, lifetime_def)) => {\n+                            let decl_id = lifetime_def.id;\n                             let def = DefEarlyBoundRegion(space, index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n@@ -336,7 +340,8 @@ impl<'a> LifetimeContext<'a> {\n \n                 LateScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((_index, decl_id)) => {\n+                        Some((_index, lifetime_def)) => {\n+                            let decl_id = lifetime_def.id;\n                             let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n                             let def = DefLateBoundRegion(debruijn, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n@@ -388,8 +393,8 @@ impl<'a> LifetimeContext<'a> {\n         }\n \n         match search_result {\n-            Some((_depth, decl_id)) => {\n-                let def = DefFreeRegion(scope_data, decl_id);\n+            Some((_depth, lifetime)) => {\n+                let def = DefFreeRegion(scope_data, lifetime.id);\n                 self.insert_lifetime(lifetime_ref, def);\n             }\n \n@@ -407,7 +412,7 @@ impl<'a> LifetimeContext<'a> {\n                     token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n-    fn check_lifetime_defs(&mut self, lifetimes: &Vec<ast::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = &lifetimes[i];\n \n@@ -422,6 +427,7 @@ impl<'a> LifetimeContext<'a> {\n                 }\n             }\n \n+            // It is a hard error to shadow a lifetime within the same scope.\n             for j in range(i + 1, lifetimes.len()) {\n                 let lifetime_j = &lifetimes[j];\n \n@@ -435,12 +441,54 @@ impl<'a> LifetimeContext<'a> {\n                 }\n             }\n \n+            // It is a soft error to shadow a lifetime within a parent scope.\n+            self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n+\n             for bound in lifetime_i.bounds.iter() {\n                 self.resolve_lifetime_ref(bound);\n             }\n         }\n     }\n \n+    fn check_lifetime_def_for_shadowing(&self,\n+                                        mut old_scope: Scope,\n+                                        lifetime: &ast::Lifetime)\n+    {\n+        loop {\n+            match *old_scope {\n+                BlockScope(_, s) => {\n+                    old_scope = s;\n+                }\n+\n+                RootScope => {\n+                    return;\n+                }\n+\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(lifetimes, s) => {\n+                    if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n+                        self.sess.span_warn(\n+                            lifetime.span,\n+                            format!(\"lifetime name `{}` shadows another \\\n+                                    lifetime name that is already in scope\",\n+                                    token::get_name(lifetime.name)).as_slice());\n+                        self.sess.span_help(\n+                            lifetime_def.span,\n+                            format!(\"shadowed lifetime `{}` declared here\",\n+                                    token::get_name(lifetime.name)).as_slice());\n+                        self.sess.span_help(\n+                            lifetime.span,\n+                            \"shadowed lifetimes are deprecated \\\n+                             and will become a hard error before 1.0\");\n+                        return;\n+                    }\n+\n+                    old_scope = s;\n+                }\n+            }\n+        }\n+    }\n+\n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &ast::Lifetime,\n                        def: DefRegion) {\n@@ -458,12 +506,12 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes(lifetimes: &Vec<ast::LifetimeDef>,\n+fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n                     lifetime_ref: &ast::Lifetime)\n-                    -> Option<(uint, ast::NodeId)> {\n+                    -> Option<(uint, &'a ast::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n         if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i, lifetime_decl.lifetime.id));\n+            return Some((i, &lifetime_decl.lifetime));\n         }\n     }\n     return None;"}, {"sha": "1cf25cd1dc8667327ddc1f658a56afc8212bb30d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -588,7 +588,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn enter_region_binder(&mut self) {\n         self.region_binders_passed += 1;"}, {"sha": "4877512ce58165ea4dc1d0f9ebaf9583d39b5440", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -834,7 +834,7 @@ pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) ->\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {"}, {"sha": "e8857de7b73bcc97bc47bbd05f3cf65da6f1fbd3", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -979,10 +979,10 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n \n         match self.heap {\n@@ -1012,10 +1012,10 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n         true\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx"}, {"sha": "80e0de8e001a0b552d264bebcf0668dc4add3fe6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -394,7 +394,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         &mut self,\n         bounds: &[Rc<ty::TraitRef<'tcx>>],\n         num_includes_types: bool,\n-        mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n+        mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n                           tr: Rc<ty::TraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)"}, {"sha": "482284c07dc02093cb5c59c9ae1d6bab5f5937f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -245,7 +245,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                       -> Option<Ty<'tcx>> {\n         self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n@@ -271,8 +271,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n+    fn unboxed_closures(&self) -> &RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.inh.unboxed_closures\n     }\n }\n@@ -1525,7 +1524,7 @@ fn check_cast(fcx: &FnCtxt,\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -1556,7 +1555,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n     pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n@@ -1878,7 +1877,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts<'tcx>>> {\n+    pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n         self.inh.item_substs.borrow()\n     }\n "}, {"sha": "08b465dfa80f70922d6bd53c0f5a9075f1e76336", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -153,7 +153,7 @@ impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n@@ -719,7 +719,7 @@ struct ImplCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -808,7 +808,7 @@ struct FnCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -857,7 +857,7 @@ struct ImplMethodCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -906,7 +906,7 @@ struct TraitMethodCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -986,7 +986,7 @@ struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n }\n \n impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.chain.tcx()\n     }\n "}, {"sha": "d640f055388cbd692dff0470ea4e737fcaa9b3c6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -459,7 +459,7 @@ impl attr::AttrMetaMethods for Attribute {\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+    fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]"}, {"sha": "1d8ea2202bf0d4e4da43cc2e1107d1d72825ea2b", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -71,10 +71,10 @@ impl<'a, T: Send> ExclusiveGuard<'a, T> {\n }\n \n impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n+    fn deref(&self) -> &T { &*self._data }\n }\n impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n+    fn deref_mut(&mut self) -> &mut T { &mut *self._data }\n }\n \n #[cfg(test)]"}, {"sha": "d17f293b4432b655f36b0908fa0d739d589673a8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -627,13 +627,13 @@ pub struct PrettyEncoder<'a> {\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n     }\n \n     /// Set the number of spaces to indent for each level.\n     /// This is safe to set during encoding.\n-    pub fn set_indent<'a>(&mut self, indent: uint) {\n+    pub fn set_indent(&mut self, indent: uint) {\n         // self.indent very well could be 0 so we need to use checked division.\n         let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n@@ -1103,7 +1103,7 @@ impl Json {\n }\n \n impl<'a> ops::Index<&'a str, Json>  for Json {\n-    fn index<'a>(&'a self, idx: & &str) -> &'a Json {\n+    fn index(&self, idx: & &str) -> &Json {\n         self.find(*idx).unwrap()\n     }\n }"}, {"sha": "71e8cb4b5ec1dee918843445be2843a06769bcbf", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -226,7 +226,7 @@ impl<'a> Reader for &'a [u8] {\n \n impl<'a> Buffer for &'a [u8] {\n     #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.is_empty() {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -268,7 +268,7 @@ impl<'a> BufWriter<'a> {\n     /// Creates a new `BufWriter` which will wrap the specified buffer. The\n     /// writer initially starts at position 0.\n     #[inline]\n-    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n+    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> {\n         BufWriter {\n             buf: buf,\n             pos: 0\n@@ -337,7 +337,7 @@ pub struct BufReader<'a> {\n impl<'a> BufReader<'a> {\n     /// Creates a new buffered reader which will read the specified buffer\n     #[inline]\n-    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n+    pub fn new(buf: &'a [u8]) -> BufReader<'a> {\n         BufReader {\n             buf: buf,\n             pos: 0\n@@ -384,7 +384,7 @@ impl<'a> Seek for BufReader<'a> {\n \n impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf[self.pos..])\n         } else {"}, {"sha": "6fc9d0bd17289be835921c02c3699b0083a30ef9", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -981,7 +981,7 @@ impl<'a, R: Reader> Reader for RefReader<'a, R> {\n }\n \n impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n "}, {"sha": "354b53bfc01d0dde151d5b3598e52411a1d5a2a9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -468,8 +468,8 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new<'a>(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-                   ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n+    pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n+               ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,"}, {"sha": "da908f46ff61f67265945578515a9f5f3d747aed", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -275,8 +275,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'a>(&self, start: BytePos,\n-                          s: &'a str, errmsg: &'a str) -> str::CowString<'a> {\n+    fn translate_crlf<'b>(&self, start: BytePos,\n+                          s: &'b str, errmsg: &'b str) -> str::CowString<'b> {\n         let mut i = 0u;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);"}, {"sha": "fc54002820e012081807c43c78a6654c4284f6a1", "filename": "src/test/compile-fail/generic-lifetime-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -19,7 +19,7 @@\n trait Bar<'a> {}\n \n trait Foo<'a> {\n-    fn bar<'a, T: Bar<'a>>(self) -> &'a str;\n+    fn bar<'b, T: Bar<'b>>(self) -> &'b str;\n }\n \n impl<'a> Foo<'a> for &'a str {"}, {"sha": "ff8ce7769d77e434eca3b8a88c2e8f4809e5b4c4", "filename": "src/test/compile-fail/shadowed-lifetime.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that shadowed lifetimes generate an error.\n+\n+struct Foo<'a>(&'a int);\n+\n+impl<'a> Foo<'a> {\n+    //~^ HELP shadowed lifetime `'a` declared here\n+    fn shadow_in_method<'a>(&'a self) -> &'a int {\n+        //~^ WARNING lifetime name `'a` shadows another lifetime name that is already in scope\n+        //~| HELP deprecated\n+        self.0\n+    }\n+\n+    fn shadow_in_type<'b>(&'b self) -> &'b int {\n+        //~^ HELP shadowed lifetime `'b` declared here\n+        let x: for<'b> fn(&'b int) = panic!();\n+        //~^ WARNING lifetime name `'b` shadows another lifetime name that is already in scope\n+        //~| HELP deprecated\n+        self.0\n+    }\n+\n+    fn not_shadow_in_item<'b>(&'b self) {\n+        struct Bar<'a, 'b>(&'a int, &'b int); // not a shadow, separate item\n+        fn foo<'a, 'b>(x: &'a int, y: &'b int) { } // same\n+    }\n+}\n+\n+fn main() {\n+    // intentional error that occurs after `resolve_lifetime` runs,\n+    // just to ensure that this test fails to compile; when shadowed\n+    // lifetimes become either an error or a proper lint, this will\n+    // not be needed.\n+    let x: int = 3u; //~ ERROR mismatched types\n+}"}, {"sha": "16d6b217872ae8b2403396115e7394a4ba0d2932", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -35,17 +35,17 @@ fn test<'a,'b>() {\n     // Test that anonymous regions in `()` form are equivalent\n     // to fresh bound regions, and that we can intermingle\n     // named and anonymous as we choose:\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'a,'b> Foo(&'a int,&'b uint) -> uint            >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'a> Foo(&'a int,&uint) -> uint                  >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'b> Foo(&int,&'b uint) -> uint                  >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'x,'y> Foo(&'x int,&'y uint) -> uint            >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'x> Foo(&'x int,&uint) -> uint                  >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'y> Foo(&int,&'y uint) -> uint                  >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n           Foo(&int,&uint) -> uint                             >();\n \n     // lifetime elision\n-    eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n+    eq::< for<'x> Foo<(&'x int,), &'x int>,\n           Foo(&int) -> &int                                   >();\n \n     // Errors expected:"}, {"sha": "b5ea9bd4b89c6a9ae3af71d9849cd398a848d4d3", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -52,14 +52,14 @@\n              ((::std::fmt::format as\n                   fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&((::std::fmt::Arguments::new\n                                                                                        as\n-                                                                                       fn(&'a [&'a str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n-                                                                                                                                                                         as\n-                                                                                                                                                                         &'static [&'static str]),\n-                                                                                                                                                                     (&([]\n-                                                                                                                                                                           as\n-                                                                                                                                                                           [core::fmt::Argument<'_>, ..0])\n-                                                                                                                                                                         as\n-                                                                                                                                                                         &[core::fmt::Argument<'_>, ..0]))\n+                                                                                       fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_>)((__STATIC_FMTSTR\n+                                                                                                                                                                as\n+                                                                                                                                                                &'static [&'static str]),\n+                                                                                                                                                            (&([]\n+                                                                                                                                                                  as\n+                                                                                                                                                                  [core::fmt::Argument<'_>, ..0])\n+                                                                                                                                                                as\n+                                                                                                                                                                &[core::fmt::Argument<'_>, ..0]))\n                                                                                       as\n                                                                                       core::fmt::Arguments<'_>)\n                                                                                     as"}, {"sha": "23e700855040c4a4f680ce7811824f11ad67a775", "filename": "src/test/run-pass/issue-6157.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f5907fa6b04614821277dd63172c5c8f11b6cd/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6157.rs?ref=41f5907fa6b04614821277dd63172c5c8f11b6cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait OpInt<'a> { fn call<'a>(&'a mut self, int, int) -> int; }\n+pub trait OpInt<'a> { fn call(&mut self, int, int) -> int; }\n \n impl<'a> OpInt<'a> for |int, int|: 'a -> int {\n     fn call(&mut self, a:int, b:int) -> int {"}]}