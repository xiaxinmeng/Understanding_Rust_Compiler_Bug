{"sha": "7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYmVkYzU4ZTNiMGUxMDJlY2U5MjZhN2Y5OTA0MWZjM2FkMzAzN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T03:50:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T03:50:30Z"}, "message": "Auto merge of #24422 - pnkfelix:typeck-highlevel-before-bodies, r=nikomatsakis\n\ntypeck: Do high-level structural/signature checks before function body checks.\r\n\r\nThis avoids various ICEs, e.g. premature calls to cat_expr that yield the dreaded \"cat_expr Errd\" ICE.\r\n\r\nHowever, it also means that some early error feedback is now not provided.  This may be for the best, because the error feedback were were providing in some of those cases were false positives -- it was spurious feedback and a distraction from the real problem.\r\n\r\nSo it is not 100% clear whether we actually want to put this change in or not.  I think its a net win, but others might disagree.\r\n\r\n(Kudos to @arielb1 for suggesting this modification.)", "tree": {"sha": "3272679fd3236e2ba8e6d97ea36b83c3e7879e84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3272679fd3236e2ba8e6d97ea36b83c3e7879e84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "html_url": "https://github.com/rust-lang/rust/commit/7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "html_url": "https://github.com/rust-lang/rust/commit/a52182ffdedaabb3b72a11e8a67a411124ecb9ac"}, {"sha": "d82f9123b25ac9cf1b4b634f5b60358517d8998d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d82f9123b25ac9cf1b4b634f5b60358517d8998d", "html_url": "https://github.com/rust-lang/rust/commit/d82f9123b25ac9cf1b4b634f5b60358517d8998d"}], "stats": {"total": 515, "additions": 417, "deletions": 98}, "files": [{"sha": "bff8e002a0af7c9beff31952621e188f550e8cce", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 71, "deletions": 44, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -441,10 +441,11 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx ast::Item) {\n-        check_item(self.ccx, i);\n+        check_item_type(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n \n@@ -460,6 +461,13 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &'tcx ast::Item) {\n+        check_item_body(self.ccx, i);\n+        visit::walk_item(self, i);\n+    }\n+}\n+\n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n@@ -474,6 +482,11 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n \n     ccx.tcx.sess.abort_if_errors();\n \n+    let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate);\n+\n+    ccx.tcx.sess.abort_if_errors();\n+\n     for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n         if drop_method_did.krate == ast::LOCAL_CRATE {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n@@ -713,13 +726,13 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n-    debug!(\"check_item(it.id={}, it.ident={})\",\n+pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n+    debug!(\"check_item_type(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n-\n     match it.node {\n+      // Consts can play a role in type-checking, so they are included here.\n       ast::ItemStatic(_, _, ref e) |\n       ast::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n@@ -728,16 +741,9 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n                             &enum_definition.variants,\n                             it.id);\n       }\n-      ast::ItemFn(ref decl, _, _, _, ref body) => {\n-        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n-      }\n+      ast::ItemFn(_, _, _, _, _) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n-\n-        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-\n+          debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n           match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n@@ -747,39 +753,9 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               }\n               None => { }\n           }\n-\n-        for impl_item in impl_items {\n-            match impl_item.node {\n-                ast::MethodImplItem(ref sig, ref body) => {\n-                    check_method_body(ccx, &impl_pty.generics, sig, body,\n-                                      impl_item.id, impl_item.span);\n-                }\n-                ast::TypeImplItem(_) |\n-                ast::MacImplItem(_) => {\n-                    // Nothing to do here.\n-                }\n-            }\n-        }\n-\n       }\n-      ast::ItemTrait(_, ref generics, _, ref trait_items) => {\n+      ast::ItemTrait(_, ref generics, _, _) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n-        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_item in trait_items {\n-            match trait_item.node {\n-                ast::MethodTraitItem(_, None) => {\n-                    // Nothing to do, since required methods don't have\n-                    // bodies to check.\n-                }\n-                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    check_method_body(ccx, &trait_def.generics, sig, body,\n-                                      trait_item.id, trait_item.span);\n-                }\n-                ast::TypeTraitItem(..) => {\n-                    // Nothing to do.\n-                }\n-            }\n-        }\n       }\n       ast::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n@@ -814,6 +790,57 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     }\n }\n \n+pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n+    debug!(\"check_item_body(it.id={}, it.ident={})\",\n+           it.id,\n+           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+    let _indenter = indenter();\n+    match it.node {\n+      ast::ItemFn(ref decl, _, _, _, ref body) => {\n+        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n+      }\n+      ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n+        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n+\n+        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+\n+        for impl_item in impl_items {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    check_method_body(ccx, &impl_pty.generics, sig, body,\n+                                      impl_item.id, impl_item.span);\n+                }\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {\n+                    // Nothing to do here.\n+                }\n+            }\n+        }\n+      }\n+      ast::ItemTrait(_, _, _, ref trait_items) => {\n+        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n+        for trait_item in trait_items {\n+            match trait_item.node {\n+                ast::MethodTraitItem(_, None) => {\n+                    // Nothing to do, since required methods don't have\n+                    // bodies to check.\n+                }\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    check_method_body(ccx, &trait_def.generics, sig, body,\n+                                      trait_item.id, trait_item.span);\n+                }\n+                ast::TypeTraitItem(..) => {\n+                    // Nothing to do.\n+                }\n+            }\n+        }\n+      }\n+      _ => {/* nothing to do */ }\n+    }\n+}\n+\n fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                generics: &ast::Generics,\n                                item: &ast::Item) {"}, {"sha": "5f1cd2444d3c4870ad7295fc0df47162a576e307", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we get an error when you use `<Self as Get>::Value` in\n+// the trait definition but `Self` does not, in fact, implement `Get`.\n+//\n+// See also associated-types-no-suitable-supertrait.rs, which checks\n+// that we see the same error when making this mistake on an impl\n+// rather than the default method impl.\n+//\n+// See also run-pass/associated-types-projection-to-unrelated-trait.rs,\n+// which checks that the trait interface itself is not considered an\n+// error as long as all impls satisfy the constraint.\n+\n+trait Get : ::std::marker::MarkerTrait {\n+    type Value;\n+}\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n+    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n+}\n+\n+fn main() { }"}, {"sha": "24429a482057c7e71067a70137f1457f58dbf570", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -10,20 +10,30 @@\n \n // Check that we get an error when you use `<Self as Get>::Value` in\n // the trait definition but `Self` does not, in fact, implement `Get`.\n+//\n+// See also associated-types-no-suitable-supertrait-2.rs, which checks\n+// that we see the same error if we get around to checking the default\n+// method body.\n+//\n+// See also run-pass/associated-types-projection-to-unrelated-trait.rs,\n+// which checks that the trait interface itself is not considered an\n+// error as long as all impls satisfy the constraint.\n \n trait Get : ::std::marker::MarkerTrait {\n     type Value;\n }\n \n trait Other {\n     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n+    // (note that we no longer catch the error here, since the\n+    //  error below aborts compilation.\n+    //  See also associated-types-no-suitable-supertrait-2.rs\n+    //  which checks that this error would be caught eventually.)\n }\n \n impl<T:Get> Other for T {\n     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n     //~^ ERROR the trait `Get` is not implemented for the type `(T, U)`\n-    //~| ERROR the trait `Get` is not implemented for the type `(T, U)`\n }\n \n fn main() { }"}, {"sha": "7ee671317559b5230be724bf4d50ae7e0a1df25f", "filename": "src/test/compile-fail/enum-to-float-cast-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast-2.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that enum-to-float casts are disallowed.\n+\n+enum E {\n+    L0 = -1,\n+    H0 = 1\n+}\n+\n+enum F {\n+    L1 = 1,\n+    H1 = 0xFFFFFFFFFFFFFFFF\n+}\n+\n+pub fn main() {\n+    let a = E::L0 as f32;  //~ ERROR illegal cast\n+    let c = F::H1 as f32;  //~ ERROR illegal cast\n+    assert_eq!(a, -1.0f32);\n+    assert_eq!(c, -1.0f32);\n+}"}, {"sha": "225b8702302a8a583f0da61be02adaa2cec10b71", "filename": "src/test/compile-fail/enum-to-float-cast.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-to-float-cast.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -24,12 +24,8 @@ static C0: f32 = E::L0 as f32; //~ ERROR illegal cast\n static C1: f32 = F::H1 as f32; //~ ERROR illegal cast\n \n pub fn main() {\n-    let a = E::L0 as f32;  //~ ERROR illegal cast\n     let b = C0;\n-    let c = F::H1 as f32;  //~ ERROR illegal cast\n     let d = C1;\n-    assert_eq!(a, -1.0f32);\n     assert_eq!(b, -1.0f32);\n-    assert_eq!(c, -1.0f32);\n     assert_eq!(d, -1.0f32);\n }"}, {"sha": "46b7b933d8796fd38ababd396a2a3a833f30827f", "filename": "src/test/compile-fail/issue-16048.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -29,7 +29,7 @@ impl<'a> Test<'a> for Foo<'a> {\n impl<'a> NoLifetime for Foo<'a> {\n     fn get<'p, T : Test<'a>>(&self) -> T {\n //~^ ERROR lifetime parameters or bounds on method `get` do not match the trait declaration\n-        return *self as T; //~ ERROR non-scalar cast: `Foo<'a>` as `T`\n+        return *self as T;\n     }\n }\n "}, {"sha": "0fa1a1547720927b3e91d2529cd81ec4b5e5c287", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -12,7 +12,5 @@ const TUP: (usize,) = (42,);\n \n fn main() {\n     let a: [isize; TUP.1];\n-    //~^ ERROR array length constant evaluation error: tuple index out of bounds\n-    //~| ERROR attempted out-of-bounds tuple index\n-    //~| ERROR attempted out-of-bounds tuple index\n+    //~^ ERROR attempted out-of-bounds tuple index\n }"}, {"sha": "7d7d7d7c8ce4d0985e406ec8a307e0939e8a617f", "filename": "src/test/compile-fail/issue-19244-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -13,7 +13,5 @@ const STRUCT: MyStruct = MyStruct { field: 42 };\n \n fn main() {\n     let a: [isize; STRUCT.nonexistent_field];\n-    //~^ ERROR array length constant evaluation error: nonexistent struct field\n-    //~| ERROR attempted access of field `nonexistent_field`\n-    //~| ERROR attempted access of field `nonexistent_field`\n+    //~^ ERROR attempted access of field `nonexistent_field`\n }"}, {"sha": "9e63cc203f4d5951a024d3cfe350d1f7f26bb9de", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -28,7 +28,10 @@ impl to_str_2 for t {\n }\n \n fn new_t(x: t) {\n-    x.my_to_string(); //~ ERROR does not implement\n+    x.my_to_string();\n+    // (there used to be an error emitted right here as well. It was\n+    // spurious, at best; if `t` did exist as a type, it clearly would\n+    // have an impl of the `to_str_2` trait.)\n }\n \n fn main() {"}, {"sha": "3d77d171acebf871915c4c2548b80b9979f505ac", "filename": "src/test/compile-fail/issue-23729.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23729.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #23729\n+\n+fn main() {\n+    let fib = {\n+        struct Recurrence {\n+            mem: [u64; 2],\n+            pos: usize,\n+        }\n+\n+        impl Iterator for Recurrence {\n+            //~^ ERROR not all trait items implemented, missing: `Item` [E0046]\n+            #[inline]\n+            fn next(&mut self) -> Option<u64> {\n+                if self.pos < 2 {\n+                    let next_val = self.mem[self.pos];\n+                    self.pos += 1;\n+                    Some(next_val)\n+                } else {\n+                    let next_val = (self.mem[0] + self.mem[1]);\n+                    self.mem[0] = self.mem[1];\n+                    self.mem[1] = next_val;\n+                    Some(next_val)\n+                }\n+            }\n+        }\n+\n+        Recurrence { mem: [0, 1], pos: 0 }\n+    };\n+\n+    for e in fib.take(10) {\n+        println!(\"{}\", e)\n+    }\n+}"}, {"sha": "6c42c88bee6d09ee72a5e3870dd28faa54f3882a", "filename": "src/test/compile-fail/issue-23827.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-23827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-23827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23827.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #23827\n+\n+#![feature(core, unboxed_closures)]\n+\n+pub struct Prototype {\n+    pub target: u32\n+}\n+\n+trait Component {\n+    fn apply(self, e: u32);\n+}\n+\n+impl<C: Component> Fn<(C,)> for Prototype {\n+    extern \"rust-call\" fn call(&self, (comp,): (C,)) -> Prototype {\n+        comp.apply(self.target);\n+        *self\n+    }\n+}\n+\n+impl<C: Component> FnMut<(C,)> for Prototype {\n+    extern \"rust-call\" fn call_mut(&mut self, (comp,): (C,)) -> Prototype {\n+        Fn::call(*&self, (comp,))\n+    }\n+}\n+\n+impl<C: Component> FnOnce<(C,)> for Prototype {\n+    //~^ ERROR not all trait items implemented, missing: `Output` [E0046]\n+    extern \"rust-call\" fn call_once(self, (comp,): (C,)) -> Prototype {\n+        Fn::call(&self, (comp,))\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "22f71835336faed30adaf77cdcf43a1535ec5eb4", "filename": "src/test/compile-fail/issue-24356.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #24356\n+\n+// ignore-tidy-linelength\n+\n+fn main() {\n+    {\n+        use std::ops::Deref;\n+\n+        struct Thing(i8);\n+\n+        /*\n+        // Correct impl\n+        impl Deref for Thing {\n+            type Target = i8;\n+            fn deref(&self) -> &i8 { &self.0 }\n+        }\n+        */\n+\n+        // Causes ICE\n+        impl Deref for Thing {\n+            //~^ ERROR not all trait items implemented, missing: `Target` [E0046]\n+            fn deref(&self) -> i8 { self.0 }\n+            //~^ ERROR method `deref` has an incompatible type for trait: expected &-ptr, found i8 [E0053]\n+        }\n+\n+        let thing = Thing(72);\n+\n+        *thing\n+    };\n+}"}, {"sha": "b5401f7d124e24e1d2c29aea4a44fdeef9dd386d", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -12,8 +12,8 @@\n \n fn main() {\n     fn bar(n: isize) {\n+        // FIXME (#24414): This error message needs improvement.\n         let _x: [isize; n];\n         //~^ ERROR no type for local variable\n-        //~| ERROR array length constant evaluation error: non-constant path in constant expr\n     }\n }"}, {"sha": "83e73b6bc3ef47d08f894c654dc4207c0e95af9b", "filename": "src/test/compile-fail/struct-base-wrong-type-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `base` in `Fru { field: expr, ..base }` must have right type.\n+//\n+// See also struct-base-wrong-type.rs, which tests same condition\n+// within a const expression.\n+\n+struct Foo { a: isize, b: isize }\n+struct Bar { x: isize }\n+\n+fn main() {\n+    let b = Bar { x: 5 };\n+    let f = Foo { a: 2, ..b }; //~  ERROR mismatched types\n+                               //~| expected `Foo`\n+                               //~| found `Bar`\n+                               //~| expected struct `Foo`\n+                               //~| found struct `Bar`\n+    let f__isize = Foo { a: 2, ..4 }; //~  ERROR mismatched types\n+                                 //~| expected `Foo`\n+                                 //~| found `_`\n+                                 //~| expected struct `Foo`\n+                                 //~| found integral variable\n+}"}, {"sha": "c98131560d486f3124b60084ce5c15717e78c6dc", "filename": "src/test/compile-fail/struct-base-wrong-type.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that `base` in `Fru { field: expr, ..base }` must have right type.\n+//\n+// See also struct-base-wrong-type-2.rs, which tests same condition\n+// within a function body.\n+\n struct Foo { a: isize, b: isize }\n struct Bar { x: isize }\n \n@@ -25,14 +30,10 @@ static foo_i: Foo = Foo { a: 2, ..4 }; //~  ERROR mismatched types\n \n fn main() {\n     let b = Bar { x: 5 };\n-    let f = Foo { a: 2, ..b }; //~  ERROR mismatched types\n-                               //~| expected `Foo`\n-                               //~| found `Bar`\n-                               //~| expected struct `Foo`\n-                               //~| found struct `Bar`\n-    let f__isize = Foo { a: 2, ..4 }; //~  ERROR mismatched types\n-                                 //~| expected `Foo`\n-                                 //~| found `_`\n-                                 //~| expected struct `Foo`\n-                                 //~| found integral variable\n+    // errors below are no longer caught since error above causes\n+    // compilation to abort before we bother checking function bodies.\n+    // See also struct-base-wrong-type-2.rs, which checks that we\n+    // would catch these errors eventually.\n+    let f = Foo { a: 2, ..b };\n+    let f__isize = Foo { a: 2, ..4 };\n }"}, {"sha": "94055450bc6bb7854f743eb77e0387a49cb1b136", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    fn foo(f: isize, x: u8, ...);\n+}\n+\n+extern \"C\" fn bar(f: isize, x: u8) {}\n+\n+fn main() {\n+    unsafe {\n+        foo(); //~ ERROR: this function takes at least 2 parameters but 0 parameters were supplied\n+        foo(1); //~ ERROR: this function takes at least 2 parameters but 1 parameter was supplied\n+\n+        let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n+        //~^ ERROR: mismatched types\n+        //~| expected `unsafe extern \"C\" fn(isize, u8)`\n+        //~| found `unsafe extern \"C\" fn(isize, u8, ...)`\n+        //~| expected non-variadic fn\n+        //~| found variadic function\n+\n+        let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n+        //~^ ERROR: mismatched types\n+        //~| expected `extern \"C\" fn(isize, u8, ...)`\n+        //~| found `extern \"C\" fn(isize, u8) {bar}`\n+        //~| expected variadic fn\n+        //~| found non-variadic function\n+\n+        foo(1, 2, 3f32); //~ ERROR: can't pass an f32 to variadic function, cast to c_double\n+        foo(1, 2, true); //~ ERROR: can't pass bool to variadic function, cast to c_int\n+        foo(1, 2, 1i8); //~ ERROR: can't pass i8 to variadic function, cast to c_int\n+        foo(1, 2, 1u8); //~ ERROR: can't pass u8 to variadic function, cast to c_uint\n+        foo(1, 2, 1i16); //~ ERROR: can't pass i16 to variadic function, cast to c_int\n+        foo(1, 2, 1u16); //~ ERROR: can't pass u16 to variadic function, cast to c_uint\n+    }\n+}"}, {"sha": "129421784930b47feabb627757903dd83123bb3b", "filename": "src/test/compile-fail/variadic-ffi.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -19,29 +19,20 @@ extern {\n extern \"C\" fn bar(f: isize, x: u8) {}\n \n fn main() {\n+    // errors below are no longer checked because error above aborts\n+    // compilation; see variadic-ffi-3.rs for corresponding test.\n     unsafe {\n-        foo(); //~ ERROR: this function takes at least 2 parameters but 0 parameters were supplied\n-        foo(1); //~ ERROR: this function takes at least 2 parameters but 1 parameter was supplied\n+        foo();\n+        foo(1);\n \n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n-        //~^ ERROR: mismatched types\n-        //~| expected `unsafe extern \"C\" fn(isize, u8)`\n-        //~| found `unsafe extern \"C\" fn(isize, u8, ...)`\n-        //~| expected non-variadic fn\n-        //~| found variadic function\n-\n         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n-        //~^ ERROR: mismatched types\n-        //~| expected `extern \"C\" fn(isize, u8, ...)`\n-        //~| found `extern \"C\" fn(isize, u8) {bar}`\n-        //~| expected variadic fn\n-        //~| found non-variadic function\n \n-        foo(1, 2, 3f32); //~ ERROR: can't pass an f32 to variadic function, cast to c_double\n-        foo(1, 2, true); //~ ERROR: can't pass bool to variadic function, cast to c_int\n-        foo(1, 2, 1i8); //~ ERROR: can't pass i8 to variadic function, cast to c_int\n-        foo(1, 2, 1u8); //~ ERROR: can't pass u8 to variadic function, cast to c_uint\n-        foo(1, 2, 1i16); //~ ERROR: can't pass i16 to variadic function, cast to c_int\n-        foo(1, 2, 1u16); //~ ERROR: can't pass u16 to variadic function, cast to c_uint\n+        foo(1, 2, 3f32);\n+        foo(1, 2, true);\n+        foo(1, 2, 1i8);\n+        foo(1, 2, 1u8);\n+        foo(1, 2, 1i16);\n+        foo(1, 2, 1u16);\n     }\n }"}, {"sha": "069fd2dec990ffdd0025fe5383644af0a64a49bf", "filename": "src/test/compile-fail/wrong-mul-method-signature.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -71,16 +71,9 @@ pub fn main() {\n     let x: Vec1 = Vec1 { x: 1.0 } * 2.0; // this is OK\n \n     let x: Vec2 = Vec2 { x: 1.0, y: 2.0 } * 2.0; // trait had reversed order\n-    //~^ ERROR mismatched types\n-    //~| expected `Vec2`\n-    //~| found `_`\n-    //~| expected struct `Vec2`\n-    //~| found floating-point variable\n-    //~| ERROR mismatched types\n-    //~| expected `Vec2`\n-    //~| found `f64`\n-    //~| expected struct `Vec2`\n-    //~| found f64\n+    // (we no longer signal a compile error here, since the\n+    //  error in the trait signature will cause compilation to\n+    //  abort before we bother looking at function bodies.)\n \n     let x: i32 = Vec3 { x: 1.0, y: 2.0, z: 3.0 } * 2.0;\n }"}, {"sha": "6070cff9a29524eb2ca3db8cc276a4e0e86dcbfa", "filename": "src/test/run-pass/associated-types-projection-to-unrelated-trait.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbedc58e3b0e102ece926a7f99041fc3ad3037a/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-to-unrelated-trait.rs?ref=7fbedc58e3b0e102ece926a7f99041fc3ad3037a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we do not get an error when you use `<Self as Get>::Value` in\n+// the trait definition if there is no default method and for every impl,\n+// `Self` does implement `Get`.\n+//\n+// See also compile-fail tests associated-types-no-suitable-supertrait\n+// and associated-types-no-suitable-supertrait-2, which show how small\n+// variants of the code below can fail.\n+\n+trait Get {\n+    type Value;\n+}\n+\n+trait Other {\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n+}\n+\n+impl Get for () {\n+    type Value = f32;\n+}\n+\n+impl Get for f64 {\n+    type Value = u32;\n+}\n+\n+impl Other for () {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+impl Other for f64 {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+fn main() { }"}]}