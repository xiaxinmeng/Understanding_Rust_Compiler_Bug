{"sha": "62cb7510ac6285c93ec691198a92f910582d31a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyY2I3NTEwYWM2Mjg1YzkzZWM2OTExOThhOTJmOTEwNTgyZDMxYTI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-26T16:23:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-10T19:37:06Z"}, "message": "Improve `Eq` deriving", "tree": {"sha": "c5eac82e2a7293c3b75dec9b4e9feb3ddd333846", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5eac82e2a7293c3b75dec9b4e9feb3ddd333846"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62cb7510ac6285c93ec691198a92f910582d31a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62cb7510ac6285c93ec691198a92f910582d31a2", "html_url": "https://github.com/rust-lang/rust/commit/62cb7510ac6285c93ec691198a92f910582d31a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62cb7510ac6285c93ec691198a92f910582d31a2/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a2c9d38c78ece0a6c5de80e382a136173e64b14", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a2c9d38c78ece0a6c5de80e382a136173e64b14", "html_url": "https://github.com/rust-lang/rust/commit/2a2c9d38c78ece0a6c5de80e382a136173e64b14"}], "stats": {"total": 145, "additions": 109, "deletions": 36}, "files": [{"sha": "f990a27e52b3190b8a00fd6840b7ad75ee546f62", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -129,7 +129,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n /// no extra methods, it is only informing the compiler that this is an\n /// equivalence relation rather than a partial equivalence relation. Note that\n-/// the `derive` strategy requires all fields are `PartialEq`, which isn't\n+/// the `derive` strategy requires all fields are `Eq`, which isn't\n /// always desired.\n ///\n /// ## How can I implement `Eq`?\n@@ -165,6 +165,17 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+// FIXME: this struct is used solely by #[derive] to\n+// assert that every component of a type implements Eq.\n+//\n+// This struct should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_eq\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n /// An `Ordering` is the result of a comparison between two values.\n ///\n /// # Examples"}, {"sha": "b81d95a6998c310e01006df4c6733d0f81d28684", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -97,6 +97,7 @@ pub trait AstBuilder {\n                       typ: P<ast::Ty>,\n                       ex: P<ast::Expr>)\n                       -> P<ast::Stmt>;\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n@@ -577,6 +578,23 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n+    // Generate `let _: Type;`, usually used for type assertions.\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n+        let local = P(ast::Local {\n+            pat: self.pat_wild(span),\n+            ty: Some(ty),\n+            init: None,\n+            id: ast::DUMMY_NODE_ID,\n+            span: span,\n+            attrs: ast::ThinVec::new(),\n+        });\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: span,\n+        }\n+    }\n+\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "d7bc2a6faeeb993f29f60007b80e88e07815bdb4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -115,20 +115,7 @@ fn cs_clone_shallow(name: &str,\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n                                         vec![], vec![ty], vec![]);\n-        let local = P(ast::Local {\n-            pat: cx.pat_wild(span),\n-            ty: Some(cx.ty_path(assert_path)),\n-            init: None,\n-            id: ast::DUMMY_NODE_ID,\n-            span: span,\n-            attrs: ast::ThinVec::new(),\n-        });\n-        let stmt = ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n-            span: span,\n-        };\n-        stmts.push(stmt);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n         for field in variant.fields() {"}, {"sha": "fa0fb2492c551c439287a6be89795bbe1cbc758d", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, MetaItem};\n+use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n@@ -23,22 +23,6 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(|cx, span, exprs| {\n-            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-            // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-            let block = cx.block(span, stmts);\n-            cx.expr_block(block)\n-        },\n-                       Box::new(|cx, sp, _, _| {\n-                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\")\n-                       }),\n-                       cx,\n-                       span,\n-                       substr)\n-    }\n-\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n     let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n@@ -50,7 +34,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"assert_receiver_is_total_eq\",\n                           generics: LifetimeBounds::empty(),\n@@ -66,5 +50,38 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                       }],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, true)\n+}\n+\n+fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Eq)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"cmp\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsEq<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsEq\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    match *substr.fields {\n+        StaticStruct(vdata, ..) => {\n+            process_variant(cx, &mut stmts, vdata);\n+        }\n+        StaticEnum(enum_def, ..) => {\n+            for variant in &enum_def.variants {\n+                process_variant(cx, &mut stmts, &variant.node.data);\n+            }\n+        }\n+        _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\")\n+    }\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "9dfec288c157208697e8160d364ddf149aea8d51", "filename": "src/test/compile-fail/union/union-derive-eq.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Eq)] // OK\n+union U1 {\n+    a: u8,\n+}\n+\n+impl PartialEq for U1 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(PartialEq)]\n+struct PartialEqNotEq;\n+\n+#[derive(Eq)]\n+union U2 {\n+    a: PartialEqNotEq, //~ ERROR the trait bound `PartialEqNotEq: std::cmp::Eq` is not satisfied\n+}\n+\n+impl PartialEq for U2 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+fn main() {}"}, {"sha": "26dbdfd0b411847a26b1855813b7119a1568d0fa", "filename": "src/test/compile-fail/union/union-derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -14,7 +14,6 @@\n \n #[derive(\n     PartialEq, //~ ERROR this trait cannot be derived for unions\n-    Eq, //~ ERROR this trait cannot be derived for unions\n     PartialOrd, //~ ERROR this trait cannot be derived for unions\n     Ord, //~ ERROR this trait cannot be derived for unions\n     Hash, //~ ERROR this trait cannot be derived for unions"}, {"sha": "8ff6f17394f9e91ba7ca8eae612f48c25455f971", "filename": "src/test/run-pass/union/union-derive.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cb7510ac6285c93ec691198a92f910582d31a2/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs?ref=62cb7510ac6285c93ec691198a92f910582d31a2", "patch": "@@ -15,22 +15,33 @@\n #[derive(\n     Copy,\n     Clone,\n+    Eq,\n )]\n union U {\n     a: u8,\n     b: u16,\n }\n \n-#[derive(Clone, Copy)]\n+impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(\n+    Clone,\n+    Copy,\n+    Eq\n+)]\n union W<T> {\n     a: T,\n }\n \n+impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n fn main() {\n     let u = U { b: 0 };\n     let u1 = u;\n     let u2 = u.clone();\n+    assert!(u1 == u2);\n \n     let w = W { a: 0 };\n     let w1 = w.clone();\n+    assert!(w == w1);\n }"}]}