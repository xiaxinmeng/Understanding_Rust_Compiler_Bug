{"sha": "68cbd6c9294cadd7ff868be0bd756fcde84d757d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Y2JkNmM5Mjk0Y2FkZDdmZjg2OGJlMGJkNzU2ZmNkZTg0ZDc1N2Q=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-29T19:25:06Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-12T02:20:10Z"}, "message": "librustc: Use separate stack slot for each return.", "tree": {"sha": "c51591a2066c0c7c3a6f4832e07c063796a0791e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c51591a2066c0c7c3a6f4832e07c063796a0791e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68cbd6c9294cadd7ff868be0bd756fcde84d757d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68cbd6c9294cadd7ff868be0bd756fcde84d757d", "html_url": "https://github.com/rust-lang/rust/commit/68cbd6c9294cadd7ff868be0bd756fcde84d757d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68cbd6c9294cadd7ff868be0bd756fcde84d757d/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dcf89567ebfb97c1a3b44d0a800f97935eb948e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dcf89567ebfb97c1a3b44d0a800f97935eb948e", "html_url": "https://github.com/rust-lang/rust/commit/9dcf89567ebfb97c1a3b44d0a800f97935eb948e"}], "stats": {"total": 122, "additions": 81, "deletions": 41}, "files": [{"sha": "9c304f839dbeeb048be51e89c841ef563e8cb2ec", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -1210,16 +1210,23 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n     p\n }\n \n-// Creates and returns space for, or returns the argument representing, the\n-// slot where the return value of the function must go.\n-pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n-                           -> ValueRef {\n+// Creates the alloca slot which holds the pointer to the slot for the final return value\n+pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> ValueRef {\n+    let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n+\n+    // Let's create the stack slot\n+    let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n+\n+    // and if we're using an out pointer, then store that in our newly made slot\n     if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-        get_param(fcx.llfn, 0)\n-    } else {\n-        let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-        AllocaFcx(fcx, lloutputtype, \"__make_return_pointer\")\n+        let outptr = get_param(fcx.llfn, 0);\n+\n+        let b = fcx.ccx.builder();\n+        b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+        b.store(outptr, slot);\n     }\n+\n+    slot\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1258,7 +1265,7 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n           llenv: None,\n-          llretptr: Cell::new(None),\n+          llretslotptr: Cell::new(None),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n           personality: Cell::new(None),\n@@ -1303,12 +1310,12 @@ pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n \n     if !return_type_is_void(fcx.ccx, substd_output_type) {\n         // If the function returns nil/bot, there is no real return\n-        // value, so do not set `llretptr`.\n+        // value, so do not set `llretslotptr`.\n         if !skip_retptr || fcx.caller_expects_out_pointer {\n-            // Otherwise, we normally allocate the llretptr, unless we\n+            // Otherwise, we normally allocate the llretslotptr, unless we\n             // have been instructed to skip it for immediate return\n             // values.\n-            fcx.llretptr.set(Some(make_return_pointer(fcx, substd_output_type)));\n+            fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n         }\n     }\n \n@@ -1533,12 +1540,12 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n \n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n-    // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n+    if fcx.llretslotptr.get().is_none() {\n         return RetVoid(ret_cx);\n     }\n \n-    let retptr = Value(fcx.llretptr.get().unwrap());\n+    let retslot = Load(ret_cx, fcx.llretslotptr.get().unwrap());\n+    let retptr = Value(retslot);\n     let retval = match retptr.get_dominating_store(ret_cx) {\n         // If there's only a single store to the ret slot, we can directly return\n         // the value that was stored and omit the store and the alloca\n@@ -1557,10 +1564,15 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n             }\n         }\n         // Otherwise, load the return value from the ret slot\n-        None => load_ty(ret_cx, fcx.llretptr.get().unwrap(), retty)\n+        None => load_ty(ret_cx, retslot, retty)\n     };\n \n-    Ret(ret_cx, retval);\n+    if fcx.caller_expects_out_pointer {\n+        store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n+        RetVoid(ret_cx);\n+    } else {\n+        Ret(ret_cx, retval);\n+    }\n }\n \n #[deriving(Clone, Eq, PartialEq)]\n@@ -1658,10 +1670,10 @@ pub fn trans_closure(ccx: &CrateContext,\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&fcx);\n \n-    let dest = match fcx.llretptr.get() {\n-        Some(e) => {expr::SaveIn(e)}\n+    let dest = match fcx.llretslotptr.get() {\n+        Some(_) => expr::SaveIn(alloca(bcx, type_of::type_of(bcx.ccx(), block_ty), \"iret_slot\")),\n         None => {\n-            assert!(type_is_zero_size(bcx.ccx(), block_ty))\n+            assert!(type_is_zero_size(bcx.ccx(), block_ty));\n             expr::Ignore\n         }\n     };\n@@ -1672,6 +1684,13 @@ pub fn trans_closure(ccx: &CrateContext,\n     // (trans_block, trans_expr, et cetera).\n     bcx = controlflow::trans_block(bcx, body, dest);\n \n+    match dest {\n+        expr::SaveIn(slot) => {\n+            Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n+        }\n+        _ => {}\n+    }\n+\n     match fcx.llreturn.get() {\n         Some(_) => {\n             Br(bcx, fcx.return_exit_block());\n@@ -1841,16 +1860,18 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n+        let dest = alloca(bcx, type_of::type_of(bcx.ccx(), result_ty), \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n-                                                 fcx.llretptr.get().unwrap(),\n+                                                 dest,\n                                                  disr,\n                                                  i);\n             arg_datum.store_to(bcx, lldestptr);\n         }\n-        adt::trans_set_discr(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n+        adt::trans_set_discr(bcx, &*repr, dest, disr);\n+        Store(bcx, dest, fcx.llretslotptr.get().unwrap());\n     }\n \n     finish_fn(&fcx, bcx, result_ty);"}, {"sha": "3bea9d644625331ad62c1d49c8e62d5cd1ebf73c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -389,6 +389,10 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     for i in range(1, arg_types.len()) {\n         llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n     }\n+    let dest = match fcx.llretslotptr.get() {\n+        Some(_) => Some(expr::SaveIn(alloca(bcx, type_of::type_of(ccx, return_type), \"ret_slot\"))),\n+        None => None\n+    };\n     bcx = trans_call_inner(bcx,\n                            None,\n                            function_type,\n@@ -399,10 +403,13 @@ pub fn trans_unboxing_shim(bcx: &Block,\n                                }\n                            },\n                            ArgVals(llshimmedargs.as_slice()),\n-                           match fcx.llretptr.get() {\n-                               None => None,\n-                               Some(llretptr) => Some(expr::SaveIn(llretptr)),\n-                           }).bcx;\n+                           dest).bcx;\n+    match dest {\n+        Some(expr::SaveIn(slot)) => {\n+            Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n+        }\n+        _ => {}\n+    }\n \n     bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n     finish_fn(&fcx, bcx, return_type);"}, {"sha": "dc77edf2706383e24d748e7983acbc642b4fc25c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -582,16 +582,16 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                          ty::ty_fn_args(closure_ty)\n                                             .as_slice());\n     let mut llargs = Vec::new();\n-    match fcx.llretptr.get() {\n-        Some(llretptr) => {\n-            llargs.push(llretptr);\n+    match fcx.llretslotptr.get() {\n+        Some(llretslotptr) => {\n+            llargs.push(Load(bcx, llretslotptr));\n         }\n         None => {}\n     }\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n-    if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n+    if type_is_zero_size(ccx, f.sig.output) || fcx.llretslotptr.get().is_some() {\n         RetVoid(bcx);\n     } else {\n         Ret(bcx, retval);"}, {"sha": "6aca8fe8e41115f4c9f0e11c8b1e1e1d74b0cdf6", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -240,11 +240,11 @@ pub struct FunctionContext<'a> {\n     // The environment argument in a closure.\n     pub llenv: Option<ValueRef>,\n \n-    // The place to store the return value. If the return type is immediate,\n-    // this is an alloca in the function. Otherwise, it's the hidden first\n-    // parameter to the function. After function construction, this should\n-    // always be Some.\n-    pub llretptr: Cell<Option<ValueRef>>,\n+    // A pointer to where to store the return value. If the return type is\n+    // immediate, this points to an alloca in the function. Otherwise, it's a\n+    // pointer to the hidden first parameter of the function. After function\n+    // construction, this should always be Some.\n+    pub llretslotptr: Cell<Option<ValueRef>>,\n \n     // These pub elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -259,8 +259,8 @@ pub struct FunctionContext<'a> {\n     pub personality: Cell<Option<ValueRef>>,\n \n     // True if the caller expects this fn to use the out pointer to\n-    // return. Either way, your code should write into llretptr, but if\n-    // this value is false, llretptr will be a local alloca.\n+    // return. Either way, your code should write into the slot llretslotptr\n+    // points to, but if this value is false, that slot will be a local alloca.\n     pub caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas."}, {"sha": "b9644b1145327857152ad8a2cfa880b64b46d62f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -26,6 +26,7 @@ use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::meth;\n use middle::trans::type_::Type;\n+use middle::trans::type_of;\n use middle::ty;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -462,13 +463,22 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match bcx.fcx.llretptr.get() {\n-        None => expr::Ignore,\n-        Some(retptr) => expr::SaveIn(retptr),\n+    let dest = match (fcx.llretslotptr.get(), e) {\n+        (Some(_), Some(e)) => {\n+            let ret_ty = expr_ty(bcx, &*e);\n+            expr::SaveIn(alloca(bcx, type_of::type_of(bcx.ccx(), ret_ty), \"ret_slot\"))\n+        }\n+        _ => expr::Ignore,\n     };\n     match e {\n         Some(x) => {\n             bcx = expr::trans_into(bcx, &*x, dest);\n+            match dest {\n+                expr::SaveIn(slot) => {\n+                    Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n+                }\n+                _ => {}\n+            }\n         }\n         _ => {}\n     }"}, {"sha": "35ac0b270719571a72bfaa1429df45d46348b0da", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cbd6c9294cadd7ff868be0bd756fcde84d757d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=68cbd6c9294cadd7ff868be0bd756fcde84d757d", "patch": "@@ -321,7 +321,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n-                Store(bcx, ret, fcx.llretptr.get().unwrap());\n+                let ret_alloca = alloca(bcx, Type::i64(ccx), \"ret_slot\");\n+                Store(bcx, ret, ret_alloca);\n+                Store(bcx, ret_alloca, fcx.llretslotptr.get().unwrap());\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n                     None => {}"}]}