{"sha": "ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNmY2MDc5Y2E2OTU4YzFiNzRmODI1NWI1NWMyZDc2ZTljMTIxZDg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-20T12:26:50Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-20T12:28:19Z"}, "message": "Use PrimVal instead of Pointer where applicable", "tree": {"sha": "8850ad99882f231e5d56573534d71d1229209da1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8850ad99882f231e5d56573534d71d1229209da1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAllJFOMACgkQpp+NIls6\n19l4pQ/9GeSXCjkGG3lkCHhNuv7Bu/BauDNWyK7hJkZXijHtyHfy9unA4UahmCx+\n2holuZ/Wqfa5XXDw4iyo20HyXqKL7vfXV2W8oPQmchioOWdARl3cIl8PHJSbq2qe\nLX25iEqVj/LOA2Oow8RlFOXKZb06syaoI/3P+5PmOlQDFl3A3AM+si5C9NzlT/Nn\nCv++JoLyRv9Nctr9h9HZ1cUkhh3vpxgsL0GyV9RuGSgzxraMdc+3QKizOBaC8dTq\npxyEmBDQlg5oqeup6hYgyalqONo8xTmbCkVL9j9MYOXXn8/HxuK6m3shbigINI62\nliySTb9KP/EeCWGVUKkpcC+VjLXizAJysA4pTJe8yueuvRv8nzWeLHSfZjuWVucN\nOQS1eZL8bZusmWXurZQdQz1658KEZhk8Sr+eVQHjfMxe0IVDefDPNL1i9NamWmsl\nQwEZYjRJai3Y+qiRaVDqLJ+E/um3HSmuJhJIu4zm9FC+NRTGARkiBlQoCwJfOG2h\nAa/4IhEsMhZCPkhk18evxVAFLvjn3CnJtTPZp5Aw6iVNfmDZfL3waVI7oSR4fng8\n6xL3esrsH9IIbYIXM0tv5x/1xkvsHDXSqOynVyVzlR6a13cbXUezuMTAgatdGRao\nVFcyG9CO8uQ77Q8tZqARvGuOUPXiDqrbmt4PJgDOUpHelYF+rlc=\n=2ohR\n-----END PGP SIGNATURE-----", "payload": "tree 8850ad99882f231e5d56573534d71d1229209da1\nparent a6734cd89030b352f7cfcd765e451af5f1961985\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1497961610 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1497961699 +0200\n\nUse PrimVal instead of Pointer where applicable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "html_url": "https://github.com/rust-lang/rust/commit/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6734cd89030b352f7cfcd765e451af5f1961985", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6734cd89030b352f7cfcd765e451af5f1961985", "html_url": "https://github.com/rust-lang/rust/commit/a6734cd89030b352f7cfcd765e451af5f1961985"}], "stats": {"total": 156, "additions": 125, "deletions": 31}, "files": [{"sha": "30a4be7b4b8663dec958cc22530ea9d555547600", "filename": "src/eval_context.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -637,7 +637,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr()?;\n+                let dest = PrimVal::Ptr(self.force_allocation(dest)?.to_ptr()?);\n \n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n@@ -893,6 +893,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        if pointee_size == 0 {\n+            // rustc relies on offsetting pointers to zsts to be a nop\n+            return Ok(ptr);\n+        }\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n             self.memory.check_bounds(ptr.to_ptr()?, false)?;\n@@ -943,7 +947,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n-    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn copy(&mut self, src: PrimVal, dest: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align)?;\n@@ -969,7 +973,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr)); // it stays live\n-                        self.write_value_to_ptr(val, ptr, ty)?;\n+                        self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n                         let lval = Lvalue::from_ptr(ptr);\n                         if let Some((field, field_ty)) = field {\n                             self.lvalue_field(lval, field, ty, field_ty)?\n@@ -987,7 +991,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n+                        self.write_value_to_ptr(global_val.value, PrimVal::Ptr(ptr), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n                             self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n@@ -1059,7 +1063,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_value_to_ptr(src_val, ptr.to_ptr()?, dest_ty)\n+                self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n             Lvalue::Local { frame, local, field } => {\n@@ -1090,7 +1094,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+            self.write_value_to_ptr(src_val, PrimVal::Ptr(dest_ptr), dest_ty)?;\n \n         } else if let Value::ByRef(src_ptr) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n@@ -1108,7 +1112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 write_dest(self, src_val)?;\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                self.copy(PrimVal::Ptr(src_ptr), PrimVal::Ptr(dest_ptr), dest_ty)?;\n                 write_dest(self, Value::ByRef(dest_ptr))?;\n             }\n \n@@ -1123,16 +1127,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: Pointer,\n+        dest: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n+            Value::ByRef(ptr) => self.copy(PrimVal::Ptr(ptr), dest, dest_ty),\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(dest, primval, size)\n             }\n-            Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest, dest_ty),\n+            Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest.to_ptr()?, dest_ty),\n         }\n     }\n \n@@ -1153,8 +1157,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?, a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?, b, field_1_size)?;\n+        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_0, self.memory.layout)?), a, field_0_size)?;\n+        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_1, self.memory.layout)?), b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1457,7 +1461,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n                     let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n-                        self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n+                        self.copy(PrimVal::Ptr(src_f_ptr), PrimVal::Ptr(dst_f_ptr), src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }"}, {"sha": "f409f3734848a514f74dcbc9d6b2851a9251a0ad", "filename": "src/lvalue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -66,18 +66,19 @@ pub struct Global<'tcx> {\n impl<'tcx> Lvalue<'tcx> {\n     /// Produces an Lvalue that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Lvalue::Ptr {\n-            ptr: PrimVal::Undef,\n-            extra: LvalueExtra::None,\n-        }\n+        Self::from_primval_ptr(PrimVal::Undef)\n+    }\n+\n+    fn from_primval_ptr(ptr: PrimVal) -> Self {\n+        Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n     pub fn zst() -> Self {\n         Self::from_ptr(Pointer::zst_ptr())\n     }\n \n     pub fn from_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr: PrimVal::Ptr(ptr), extra: LvalueExtra::None }\n+        Self::from_primval_ptr(PrimVal::Ptr(ptr))\n     }\n \n     pub(super) fn to_ptr_and_extra(self) -> (PrimVal, LvalueExtra) {"}, {"sha": "8aab55e02394c020629e4f450c4ebc0abe26f637", "filename": "src/memory.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&mut []);\n         }\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr, size, true)?;\n+        self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -671,10 +671,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64) -> EvalResult<'tcx> {\n+    pub fn copy(&mut self, src: PrimVal, dest: PrimVal, size: u64, align: u64) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(());\n         }\n+        let src = src.to_ptr()?;\n+        let dest = dest.to_ptr()?;\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked(src, size, align)?.as_ptr();\n@@ -755,14 +757,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_primval(\n         &mut self,\n-        dest: Pointer,\n+        dest: PrimVal,\n         val: PrimVal,\n         size: u64,\n     ) -> EvalResult<'tcx> {\n         match val {\n             PrimVal::Ptr(ptr) => {\n                 assert_eq!(size, self.pointer_size());\n-                self.write_ptr(dest, ptr)\n+                self.write_ptr(dest.to_ptr()?, ptr)\n             }\n \n             PrimVal::Bytes(bytes) => {\n@@ -776,7 +778,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     16 => !0,\n                     _ => bug!(\"unexpected PrimVal::Bytes size\"),\n                 };\n-                self.write_uint(dest, bytes & mask, size)\n+                self.write_uint(dest.to_ptr()?, bytes & mask, size)\n             }\n \n             PrimVal::Undef => self.mark_definedness(dest, size, false),\n@@ -962,13 +964,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: PrimVal,\n         size: u64,\n         new_state: bool\n     ) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(())\n         }\n+        let ptr = ptr.to_ptr()?;\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n         Ok(())"}, {"sha": "f6ef46ecbfb8e774b27da73a38207d62a5e899fd", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let dest = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n@@ -145,8 +145,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n                 if elem_size != 0 {\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n-                    let dest = arg_vals[1].read_ptr(&self.memory)?.to_ptr()?;\n+                    let src = arg_vals[0].read_ptr(&self.memory)?;\n+                    let dest = arg_vals[1].read_ptr(&self.memory)?;\n                     let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align)?;\n                 }\n@@ -284,7 +284,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n@@ -392,7 +392,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if dest_align < src_align {\n                     let ptr = self.force_allocation(dest)?.to_ptr()?;\n                     self.memory.mark_packed(ptr, size);\n-                    self.write_value_to_ptr(arg_vals[0], ptr, dest_ty)?;\n+                    self.write_value_to_ptr(arg_vals[0], PrimVal::Ptr(ptr), dest_ty)?;\n                 } else {\n                     self.write_value(arg_vals[0], dest, dest_ty)?;\n                 }\n@@ -403,7 +403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n                         Value::ByRef(ptr) => {\n-                            this.memory.mark_definedness(ptr, size, false)?;\n+                            this.memory.mark_definedness(PrimVal::Ptr(ptr), size, false)?;\n                             Ok(Value::ByRef(ptr))\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match dest {\n                     Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), uninit)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } =>\n-                        self.memory.mark_definedness(ptr.to_ptr()?, size, false)?,\n+                        self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, uninit)?,\n                 }"}, {"sha": "dbe8ec9addacc5f88ac0b269c0ead95a54b038da", "filename": "tests/run-pass/slice-of-zero-size-elements.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+use std::slice;\n+\n+fn foo<T>(v: &[T]) -> Option<&[T]> {\n+    let mut it = v.iter();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.as_slice())\n+}\n+\n+fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+    let mut it = v.iter_mut();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.into_slice())\n+}\n+\n+pub fn main() {\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}"}, {"sha": "63a0d65f017def8d603d05654eb20e97b97a1a87", "filename": "tests/run-pass/zero-sized-binary-heap-push.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6f6079ca6958c1b74f8255b55c2d76e9c121d8/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs?ref=ea6f6079ca6958c1b74f8255b55c2d76e9c121d8", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BinaryHeap;\n+use std::iter::Iterator;\n+\n+fn main() {\n+    const N: usize = 8;\n+\n+    for len in 0..N {\n+        let mut tester = BinaryHeap::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for _ in 0..len {\n+            tester.push(());\n+        }\n+        assert_eq!(tester.len(), len);\n+        assert_eq!(tester.iter().count(), len);\n+        tester.clear();\n+    }\n+}"}]}