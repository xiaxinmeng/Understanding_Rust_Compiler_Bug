{"sha": "0918dc4e5990592c28484d1d64bec41cb9a4a301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MThkYzRlNTk5MDU5MmMyODQ4NGQxZDY0YmVjNDFjYjlhNGEzMDE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-21T13:49:15Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-21T13:49:15Z"}, "message": "or-patterns: middle/dead: remove `top_pats_hack`.\n\nAlso tweak walkers on `Pat`.", "tree": {"sha": "b6d750f072f722e5c28deb903b6b57da6406c448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6d750f072f722e5c28deb903b6b57da6406c448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0918dc4e5990592c28484d1d64bec41cb9a4a301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0918dc4e5990592c28484d1d64bec41cb9a4a301", "html_url": "https://github.com/rust-lang/rust/commit/0918dc4e5990592c28484d1d64bec41cb9a4a301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0918dc4e5990592c28484d1d64bec41cb9a4a301/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "370fbcc0225a226096773fc8641c59eb5e635f7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/370fbcc0225a226096773fc8641c59eb5e635f7a", "html_url": "https://github.com/rust-lang/rust/commit/370fbcc0225a226096773fc8641c59eb5e635f7a"}], "stats": {"total": 195, "additions": 100, "deletions": 95}, "files": [{"sha": "87fc385acd64d89b4796bed57a9e45d08a12b8fc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0918dc4e5990592c28484d1d64bec41cb9a4a301", "patch": "@@ -882,39 +882,61 @@ impl fmt::Debug for Pat {\n \n impl Pat {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_<G>(&self, it: &mut G) -> bool\n-        where G: FnMut(&Pat) -> bool\n-    {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n \n+        use PatKind::*;\n         match &self.node {\n-            PatKind::Binding(.., Some(p)) => p.walk_(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_(it)),\n-            PatKind::TupleStruct(_, s, _) | PatKind::Tuple(s, _) | PatKind::Or(s) => {\n-                s.iter().all(|p| p.walk_(it))\n-            }\n-            PatKind::Box(s) | PatKind::Ref(s, _) => s.walk_(it),\n-            PatKind::Slice(before, slice, after) => {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => true,\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_short_(it),\n+            Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_short_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().all(|p| p.walk_short_(it)),\n+            Slice(before, slice, after) => {\n                 before.iter()\n                       .chain(slice.iter())\n                       .chain(after.iter())\n-                      .all(|p| p.walk_(it))\n+                      .all(|p| p.walk_short_(it))\n             }\n-            PatKind::Wild |\n-            PatKind::Lit(_) |\n-            PatKind::Range(..) |\n-            PatKind::Binding(..) |\n-            PatKind::Path(_) => {\n-                true\n+        }\n+    }\n+\n+    /// Walk the pattern in left-to-right order,\n+    /// short circuiting (with `.all(..)`) if `false` is returned.\n+    ///\n+    /// Note that when visiting e.g. `Tuple(ps)`,\n+    /// if visiting `ps[0]` returns `false`,\n+    /// then `ps[1]` will not be visited.\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat) -> bool) -> bool {\n+        self.walk_short_(&mut it)\n+    }\n+\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_(&self, it: &mut impl FnMut(&Pat) -> bool) {\n+        if !it(self) {\n+            return;\n+        }\n+\n+        use PatKind::*;\n+        match &self.node {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => {},\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_(it),\n+            Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().for_each(|p| p.walk_(it)),\n+            Slice(before, slice, after) => {\n+                before.iter()\n+                      .chain(slice.iter())\n+                      .chain(after.iter())\n+                      .for_each(|p| p.walk_(it))\n             }\n         }\n     }\n \n-    pub fn walk<F>(&self, mut it: F) -> bool\n-        where F: FnMut(&Pat) -> bool\n-    {\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If `it(pat)` returns `false`, the children are not visited.\n+    pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n         self.walk_(&mut it)\n     }\n }"}, {"sha": "118e168f877678eb519d6f5b380429f2809c7a28", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=0918dc4e5990592c28484d1d64bec41cb9a4a301", "patch": "@@ -66,9 +66,7 @@ impl hir::Pat {\n \n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n-    pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n-    {\n+    pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n                 f(binding_mode, p.hir_id, p.span, ident);\n@@ -81,59 +79,53 @@ impl hir::Pat {\n     /// `match foo() { Some(a) => (), None => () }`.\n     ///\n     /// When encountering an or-pattern `p_0 | ... | p_n` only `p_0` will be visited.\n-    pub fn each_binding_or_first<F>(&self, c: &mut F)\n-        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n-    {\n-        match &self.node {\n-            PatKind::Binding(bm,  _, ident, sub) => {\n-                c(*bm, self.hir_id, self.span, *ident);\n-                sub.iter().for_each(|p| p.each_binding_or_first(c));\n-            }\n-            PatKind::Or(ps) => ps[0].each_binding_or_first(c),\n-            PatKind::Struct(_, fs, _) => fs.iter().for_each(|f| f.pat.each_binding_or_first(c)),\n-            PatKind::TupleStruct(_, ps, _) | PatKind::Tuple(ps, _) => {\n-                ps.iter().for_each(|p| p.each_binding_or_first(c));\n-            }\n-            PatKind::Box(p) | PatKind::Ref(p, _) => p.each_binding_or_first(c),\n-            PatKind::Slice(before, slice, after) => {\n-                before.iter()\n-                      .chain(slice.iter())\n-                      .chain(after.iter())\n-                      .for_each(|p| p.each_binding_or_first(c));\n+    pub fn each_binding_or_first(\n+        &self,\n+        f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n+    ) {\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(ps) => {\n+                ps[0].each_binding_or_first(f);\n+                false\n+            },\n+            PatKind::Binding(bm,  _, ident, _) => {\n+                f(*bm, p.hir_id, p.span, *ident);\n+                true\n             }\n-            PatKind::Wild | PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(_) => {}\n-        }\n+            _ => true,\n+        })\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            if let PatKind::Binding(..) = p.node {\n-                contains_bindings = true;\n-                false // there's at least one binding, can short circuit now.\n-            } else {\n-                true\n-            }\n-        });\n-        contains_bindings\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Binding(..) | PatKind::Wild => {\n-                    contains_bindings = true;\n-                    false // there's at least one binding/wildcard, can short circuit now.\n-                }\n-                _ => true\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) | PatKind::Wild => true,\n+            _ => false,\n+        })\n+    }\n+\n+    /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n+    fn satisfies(&self, pred: impl Fn(&Self) -> bool) -> bool {\n+        let mut satisfies = false;\n+        self.walk_short(|p| {\n+            if pred(p) {\n+                satisfies = true;\n+                false // Found one, can short circuit now.\n+            } else {\n+                true\n             }\n         });\n-        contains_bindings\n+        satisfies\n     }\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n@@ -147,20 +139,20 @@ impl hir::Pat {\n     /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n-                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n-                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                    match path.res {\n-                        Res::Def(DefKind::Variant, id) => variants.push(id),\n-                        Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id) => variants.push(id),\n-                        _ => ()\n-                    }\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(_) => false,\n+            PatKind::Path(hir::QPath::Resolved(_, path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, path), ..) => {\n+                if let Res::Def(DefKind::Variant, id)\n+                    | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id)\n+                    = path.res\n+                {\n+                    variants.push(id);\n                 }\n-                _ => ()\n+                true\n             }\n-            true\n+            _ => true,\n         });\n         variants.sort();\n         variants.dedup();\n@@ -176,14 +168,12 @@ impl hir::Pat {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n-                hir::BindingAnnotation::Ref => {\n-                    match result {\n-                        None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n-                        _ => (),\n-                    }\n+                hir::BindingAnnotation::Ref => match result {\n+                    None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                    _ => {}\n                 }\n                 hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n-                _ => (),\n+                _ => {}\n             }\n         });\n         result"}, {"sha": "2746794e2a2c1f78508e58ef275d1b3e63e8c185", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0918dc4e5990592c28484d1d64bec41cb9a4a301/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0918dc4e5990592c28484d1d64bec41cb9a4a301", "patch": "@@ -259,20 +259,13 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n-        let pats = arm.top_pats_hack();\n-        if let [pat] = pats {\n-            let variants = pat.necessary_variants();\n-\n-            // Inside the body, ignore constructions of variants\n-            // necessary for the pattern to match. Those construction sites\n-            // can't be reached unless the variant is constructed elsewhere.\n-            let len = self.ignore_variant_stack.len();\n-            self.ignore_variant_stack.extend_from_slice(&variants);\n-            intravisit::walk_arm(self, arm);\n-            self.ignore_variant_stack.truncate(len);\n-        } else {\n-            intravisit::walk_arm(self, arm);\n-        }\n+        // Inside the body, ignore constructions of variants\n+        // necessary for the pattern to match. Those construction sites\n+        // can't be reached unless the variant is constructed elsewhere.\n+        let len = self.ignore_variant_stack.len();\n+        self.ignore_variant_stack.extend(arm.pat.necessary_variants());\n+        intravisit::walk_arm(self, arm);\n+        self.ignore_variant_stack.truncate(len);\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {"}]}