{"sha": "3c030e2425bb1fdb165ac87797076072ec991970", "node_id": "C_kwDOAAsO6NoAKDNjMDMwZTI0MjViYjFmZGIxNjVhYzg3Nzk3MDc2MDcyZWM5OTE5NzA", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-25T19:24:47Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-25T19:25:11Z"}, "message": "Fix NaN handling of simd float min and max operations", "tree": {"sha": "886f139db21d2f436586812bf834f2d72b4a7185", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/886f139db21d2f436586812bf834f2d72b4a7185"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c030e2425bb1fdb165ac87797076072ec991970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c030e2425bb1fdb165ac87797076072ec991970", "html_url": "https://github.com/rust-lang/rust/commit/3c030e2425bb1fdb165ac87797076072ec991970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c030e2425bb1fdb165ac87797076072ec991970/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d97cce279fd2372aafec3761791b4110d70bf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d97cce279fd2372aafec3761791b4110d70bf5", "html_url": "https://github.com/rust-lang/rust/commit/f3d97cce279fd2372aafec3761791b4110d70bf5"}], "stats": {"total": 124, "additions": 83, "deletions": 41}, "files": [{"sha": "b8f901d1ba176274185f3f6b6ea0ce427110c673", "filename": "example/float-minmax-pass.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/example%2Ffloat-minmax-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/example%2Ffloat-minmax-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Ffloat-minmax-pass.rs?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -0,0 +1,53 @@\n+// Copied from https://github.com/rust-lang/rust/blob/3fe3b89cd57229343eeca753fdd8c63d9b03c65c/src/test/ui/simd/intrinsic/float-minmax-pass.rs\n+// run-pass\n+// ignore-emscripten\n+\n+// Test that the simd_f{min,max} intrinsics produce the correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fmin<T>(x: T, y: T) -> T;\n+    fn simd_fmax<T>(x: T, y: T) -> T;\n+}\n+\n+fn main() {\n+    let x = f32x4(1.0, 2.0, 3.0, 4.0);\n+    let y = f32x4(2.0, 1.0, 4.0, 3.0);\n+\n+    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\")))]\n+    let nan = f32::NAN;\n+    // MIPS hardware treats f32::NAN as SNAN. Clear the signaling bit.\n+    // See https://github.com/rust-lang/rust/issues/52746.\n+    #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n+    let nan = f32::from_bits(f32::NAN.to_bits() - 1);\n+\n+    let n = f32x4(nan, nan, nan, nan);\n+\n+    unsafe {\n+        let min0 = simd_fmin(x, y);\n+        let min1 = simd_fmin(y, x);\n+        assert_eq!(min0, min1);\n+        let e = f32x4(1.0, 1.0, 3.0, 3.0);\n+        assert_eq!(min0, e);\n+        let minn = simd_fmin(x, n);\n+        assert_eq!(minn, x);\n+        let minn = simd_fmin(y, n);\n+        assert_eq!(minn, y);\n+\n+        let max0 = simd_fmax(x, y);\n+        let max1 = simd_fmax(y, x);\n+        assert_eq!(max0, max1);\n+        let e = f32x4(2.0, 2.0, 4.0, 4.0);\n+        assert_eq!(max0, e);\n+        let maxn = simd_fmax(x, n);\n+        assert_eq!(maxn, x);\n+        let maxn = simd_fmax(y, n);\n+        assert_eq!(maxn, y);\n+    }\n+}"}, {"sha": "b952b21e6e694692b4dfd51790ae68a1de97dab8", "filename": "patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -106,22 +106,6 @@ diff --git a/crates/core_simd/tests/ops_macros.rs b/crates/core_simd/tests/ops_m\n index 31b7ee2..bd04b3c 100644\n --- a/crates/core_simd/tests/ops_macros.rs\n +++ b/crates/core_simd/tests/ops_macros.rs\n-@@ -567,6 +567,7 @@ macro_rules! impl_float_tests {\n-                     });\n-                 }\n- \n-+                /*\n-                 fn horizontal_max<const LANES: usize>() {\n-                     test_helpers::test_1(&|x| {\n-                         let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n-@@ -590,6 +591,7 @@ macro_rules! impl_float_tests {\n-                         Ok(())\n-                     });\n-                 }\n-+                */\n-             }\n- \n-             #[cfg(feature = \"std\")]\n @@ -604,6 +606,7 @@ macro_rules! impl_float_tests {\n                          )\n                      }"}, {"sha": "3d6bd88745923aedf18d5340744627360d26fcfc", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -79,7 +79,6 @@ rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n \n # giving different but possibly correct results\n # =============================================\n-rm src/test/ui/simd/intrinsic/float-minmax-pass.rs # same\n rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n rm src/test/ui/consts/issue-33537.rs # same"}, {"sha": "aae626081f62be5c93b3e7d92c08c811105c4d8f", "filename": "scripts/tests.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -72,6 +72,10 @@ function base_sysroot_tests() {\n     $MY_RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/track-caller-attribute\n \n+    echo \"[AOT] float-minmax-pass\"\n+    $MY_RUSTC example/float-minmax-pass.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n+    $RUN_WRAPPER ./target/out/float-minmax-pass\n+\n     echo \"[AOT] mod_bench\"\n     $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mod_bench"}, {"sha": "d76dfca7960c4a220871c57b8fc1f020f5cab588", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -1019,39 +1019,23 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, old);\n         };\n \n-        // In Rust floating point min and max don't propagate NaN. In Cranelift they do however.\n-        // For this reason it is necessary to use `a.is_nan() ? b : (a >= b ? b : a)` for `minnumf*`\n-        // and `a.is_nan() ? b : (a <= b ? b : a)` for `maxnumf*`. NaN checks are done by comparing\n-        // a float against itself. Only in case of NaN is it not equal to itself.\n         minnumf32, (v a, v b) {\n-            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n-            let a_ge_b = fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, a, b);\n-            let temp = fx.bcx.ins().select(a_ge_b, b, a);\n-            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n+            let val = crate::num::codegen_float_min(fx, a, b);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         minnumf64, (v a, v b) {\n-            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n-            let a_ge_b = fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, a, b);\n-            let temp = fx.bcx.ins().select(a_ge_b, b, a);\n-            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n+            let val = crate::num::codegen_float_min(fx, a, b);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf32, (v a, v b) {\n-            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n-            let a_le_b = fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, a, b);\n-            let temp = fx.bcx.ins().select(a_le_b, b, a);\n-            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n+            let val = crate::num::codegen_float_max(fx, a, b);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n             ret.write_cvalue(fx, val);\n         };\n         maxnumf64, (v a, v b) {\n-            let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n-            let a_le_b = fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, a, b);\n-            let temp = fx.bcx.ins().select(a_le_b, b, a);\n-            let val = fx.bcx.ins().select(a_is_nan, b, temp);\n+            let val = crate::num::codegen_float_max(fx, a, b);\n             let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n             ret.write_cvalue(fx, val);\n         };"}, {"sha": "25755f8c7ec8b60daf37269c95861d0cb4de155a", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -354,8 +354,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     _ => unreachable!(\"{:?}\", lane_ty),\n                 }\n                 match intrinsic {\n-                    sym::simd_fmin => fx.bcx.ins().fmin(x_lane, y_lane),\n-                    sym::simd_fmax => fx.bcx.ins().fmax(x_lane, y_lane),\n+                    sym::simd_fmin => crate::num::codegen_float_min(fx, x_lane, y_lane),\n+                    sym::simd_fmax => crate::num::codegen_float_max(fx, x_lane, y_lane),\n                     _ => unreachable!(),\n                 }\n             });\n@@ -495,7 +495,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let lt = match ty.kind() {\n                     ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedLessThan, a, b),\n                     ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedLessThan, a, b),\n-                    ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::LessThan, a, b),\n+                    ty::Float(_) => return crate::num::codegen_float_min(fx, a, b),\n                     _ => unreachable!(),\n                 };\n                 fx.bcx.ins().select(lt, a, b)\n@@ -512,7 +512,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let gt = match ty.kind() {\n                     ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedGreaterThan, a, b),\n                     ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, a, b),\n-                    ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::GreaterThan, a, b),\n+                    ty::Float(_) => return crate::num::codegen_float_max(fx, a, b),\n                     _ => unreachable!(),\n                 };\n                 fx.bcx.ins().select(gt, a, b)"}, {"sha": "4ce8adb182e0fab68756d06f3fad196f1bf5a770", "filename": "src/num.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c030e2425bb1fdb165ac87797076072ec991970/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=3c030e2425bb1fdb165ac87797076072ec991970", "patch": "@@ -420,3 +420,21 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n         CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }\n+\n+// In Rust floating point min and max don't propagate NaN. In Cranelift they do however.\n+// For this reason it is necessary to use `a.is_nan() ? b : (a >= b ? b : a)` for `minnumf*`\n+// and `a.is_nan() ? b : (a <= b ? b : a)` for `maxnumf*`. NaN checks are done by comparing\n+// a float against itself. Only in case of NaN is it not equal to itself.\n+pub(crate) fn codegen_float_min(fx: &mut FunctionCx<'_, '_, '_>, a: Value, b: Value) -> Value {\n+    let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+    let a_ge_b = fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, a, b);\n+    let temp = fx.bcx.ins().select(a_ge_b, b, a);\n+    fx.bcx.ins().select(a_is_nan, b, temp)\n+}\n+\n+pub(crate) fn codegen_float_max(fx: &mut FunctionCx<'_, '_, '_>, a: Value, b: Value) -> Value {\n+    let a_is_nan = fx.bcx.ins().fcmp(FloatCC::NotEqual, a, a);\n+    let a_le_b = fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, a, b);\n+    let temp = fx.bcx.ins().select(a_le_b, b, a);\n+    fx.bcx.ins().select(a_is_nan, b, temp)\n+}"}]}