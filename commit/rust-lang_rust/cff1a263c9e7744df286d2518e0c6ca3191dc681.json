{"sha": "cff1a263c9e7744df286d2518e0c6ca3191dc681", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjFhMjYzYzllNzc0NGRmMjg2ZDI1MThlMGM2Y2EzMTkxZGM2ODE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-05-10T16:35:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-10T16:35:17Z"}, "message": "Rollup merge of #50010 - ExpHP:slice-bounds, r=alexcrichton\n\nGive SliceIndex impls a test suite of girth befitting the implementation (and fix a UTF8 boundary check)\n\nSo one day I was writing something in my codebase that basically amounted to `impl SliceIndex for (Bound<usize>, Bound<usize>)`, and I said to myself:\n\n*Boy, gee, golly!  I never realized bounds checking was so tricky!*\n\nAt some point when I had around 60 lines of tests for it, I decided to go see how the standard library does it to see if I missed any edge cases. ...That's when I discovered that libcore only had about 40 lines of tests for slicing altogether, and none of them even used `..=`.\n\n---\n\nThis PR includes:\n\n* **Literally the first appearance of the word `get_unchecked_mut` in any directory named `test` or `tests`.**\n* Likewise the first appearance of `get_mut` used with _any type of range argument_ in these directories.\n* Tests for the panics on overflow with `..=`.\n    * I wanted to test on `[(); usize::MAX]` as well but that takes linear time in debug mode </3\n* A horrible and ugly test-generating macro for the `should_panic` tests that increases the DRYness by a single order of magnitude (which IMO wasn't enough, but I didn't want to go any further and risk making the tests inaccessible to next guy).\n* Same stuff for str!\n    * Actually, the existing `str` tests were pretty good. I just helped filled in the holes.\n* [A fix for the bug it caught](https://github.com/rust-lang/rust/issues/50002).  (only one ~~sadly~~)", "tree": {"sha": "2d39f779a1fba6ca894db351eac6242edae37f92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d39f779a1fba6ca894db351eac6242edae37f92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff1a263c9e7744df286d2518e0c6ca3191dc681", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa9HTFCRBK7hj4Ov3rIwAAdHIIAAzduoSyIlQiF7PDfSRleYw7\nk3dlhSSayukmzBCrT0Qx+KI80gQZCJDp6UdITaMM03HP8CVMCzX5Wu6vvhR+FXl6\njI/y/d5W0CyqEgfaWUn54qOibM1SCByphIUCwKDNhc62YWMWKfGfANJqXzDtCbzA\nxcyk4nAlrhZlZWSTJMTlhWzvjFzqS2fPTS9RhRtW6kyT/h5sXAsVpHXfLr5GB7Or\nsUDtap3EKnN6tzuR5SQw4BaDh0prlkC9HDuFpr+dWX5nRmoWxhBZTejVHt2L+BLz\nlK4E1aFwsYdM0j0hL5c4lvK/fRObeDXkL4EBal+r+s76wxOPpS0FMKCYnWcHn3Q=\n=6TKm\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d39f779a1fba6ca894db351eac6242edae37f92\nparent ecd9898b60b601f69113c64b77650a09d7678edf\nparent f1d7b453fed6acefc68f90752922b37c6e3ac7a4\nauthor Alex Crichton <alex@alexcrichton.com> 1525970117 -0500\ncommitter GitHub <noreply@github.com> 1525970117 -0500\n\nRollup merge of #50010 - ExpHP:slice-bounds, r=alexcrichton\n\nGive SliceIndex impls a test suite of girth befitting the implementation (and fix a UTF8 boundary check)\n\nSo one day I was writing something in my codebase that basically amounted to `impl SliceIndex for (Bound<usize>, Bound<usize>)`, and I said to myself:\n\n*Boy, gee, golly!  I never realized bounds checking was so tricky!*\n\nAt some point when I had around 60 lines of tests for it, I decided to go see how the standard library does it to see if I missed any edge cases. ...That's when I discovered that libcore only had about 40 lines of tests for slicing altogether, and none of them even used `..=`.\n\n---\n\nThis PR includes:\n\n* **Literally the first appearance of the word `get_unchecked_mut` in any directory named `test` or `tests`.**\n* Likewise the first appearance of `get_mut` used with _any type of range argument_ in these directories.\n* Tests for the panics on overflow with `..=`.\n    * I wanted to test on `[(); usize::MAX]` as well but that takes linear time in debug mode </3\n* A horrible and ugly test-generating macro for the `should_panic` tests that increases the DRYness by a single order of magnitude (which IMO wasn't enough, but I didn't want to go any further and risk making the tests inaccessible to next guy).\n* Same stuff for str!\n    * Actually, the existing `str` tests were pretty good. I just helped filled in the holes.\n* [A fix for the bug it caught](https://github.com/rust-lang/rust/issues/50002).  (only one ~~sadly~~)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff1a263c9e7744df286d2518e0c6ca3191dc681", "html_url": "https://github.com/rust-lang/rust/commit/cff1a263c9e7744df286d2518e0c6ca3191dc681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff1a263c9e7744df286d2518e0c6ca3191dc681/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecd9898b60b601f69113c64b77650a09d7678edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd9898b60b601f69113c64b77650a09d7678edf", "html_url": "https://github.com/rust-lang/rust/commit/ecd9898b60b601f69113c64b77650a09d7678edf"}, {"sha": "f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "html_url": "https://github.com/rust-lang/rust/commit/f1d7b453fed6acefc68f90752922b37c6e3ac7a4"}], "stats": {"total": 805, "additions": 597, "deletions": 208}, "files": [{"sha": "2edd41a70b945af71db27b33d5053ecc4c33900d", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 355, "deletions": 134, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=cff1a263c9e7744df286d2518e0c6ca3191dc681", "patch": "@@ -291,113 +291,378 @@ fn test_replace_pattern() {\n     assert_eq!(data.replace(|c| c == '\u03b3', \"\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\"), \"abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4\");\n }\n \n-#[test]\n-fn test_slice() {\n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n-    assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n+mod slice_index {\n+    // Test a slicing operation **that should succeed,**\n+    // testing it on all of the indexing methods.\n+    //\n+    // This is not suitable for testing failure on invalid inputs.\n+    macro_rules! assert_range_eq {\n+        ($s:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut s: String = $s.to_owned();\n+            let mut expected: String = $expected.to_owned();\n+            {\n+                let s: &str = &s;\n+                let expected: &str = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut str = &mut s;\n+                let expected: &mut str = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert_eq!(\"\u0e1b\", &data[0..3]);\n-    assert_eq!(\"\u0e23\", &data[3..6]);\n-    assert_eq!(\"\", &data[3..3]);\n-    assert_eq!(\"\u534e\", &data[30..33]);\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method that panics, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of bounds\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!(\"abc\", 0..5, \"abc\");\n+    }\n \n-    fn a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!(\"abc\", 0..2, \"abc\");\n+    }\n+\n+    // Generates test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            in mod $case_name:ident {\n+                data: $data:expr;\n+\n+                // optional:\n+                //\n+                // a similar input for which DATA[input] succeeds, and the corresponding\n+                // output str. This helps validate \"critical points\" where an input range\n+                // straddles the boundary between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    good: data[$good:expr] == $output:expr;\n+                )*\n+\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr; // must be a literal\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v: String = $data.into();\n+\n+                    $( assert_range_eq!(v, $good, $output); )*\n+\n+                    {\n+                        let v: &str = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut str = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v: String = $data.into();\n+                    let v: &str = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v: String = $data.into();\n+                    let v: &mut str = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n+    }\n+\n+    #[test]\n+    fn simple_ascii() {\n+        assert_range_eq!(\"abc\", .., \"abc\");\n+\n+        assert_range_eq!(\"abc\", 0..2, \"ab\");\n+        assert_range_eq!(\"abc\", 0..=1, \"ab\");\n+        assert_range_eq!(\"abc\", ..2, \"ab\");\n+        assert_range_eq!(\"abc\", ..=1, \"ab\");\n+\n+        assert_range_eq!(\"abc\", 1..3, \"bc\");\n+        assert_range_eq!(\"abc\", 1..=2, \"bc\");\n+        assert_range_eq!(\"abc\", 1..1, \"\");\n+        assert_range_eq!(\"abc\", 1..=0, \"\");\n+    }\n+\n+    #[test]\n+    fn simple_unicode() {\n+        // \u65e5\u672c\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", .., \"\\u{65e5}\\u{672c}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..=2, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..=2, \"\\u{65e5}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..6, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..=5, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3.., \"\\u{672c}\");\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_range_eq!(data, 0..3, \"\u0e1b\");\n+        assert_range_eq!(data, 3..6, \"\u0e23\");\n+        assert_range_eq!(data, 3..3, \"\");\n+        assert_range_eq!(data, 30..33, \"\u534e\");\n+\n+        /*0: \u4e2d\n+          3: \u534e\n+          6: V\n+          7: i\n+          8: \u1ec7\n+         11: t\n+         12:\n+         13: N\n+         14: a\n+         15: m */\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_range_eq!(ss, 3..6, \"\u534e\");\n+        assert_range_eq!(ss, 6..16, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6..=15, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6.., \"Vi\u1ec7t Nam\");\n+\n+        assert_range_eq!(ss, 0..3, \"\u4e2d\");\n+        assert_range_eq!(ss, 3..7, \"\u534eV\");\n+        assert_range_eq!(ss, 3..=6, \"\u534eV\");\n+        assert_range_eq!(ss, 3..3, \"\");\n+        assert_range_eq!(ss, 3..=2, \"\");\n+    }\n+\n+    #[test]\n+    fn simple_big() {\n+        fn a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n         }\n-        rs\n+        fn half_a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n+        }\n+        let letters = a_million_letter_x();\n+        assert_range_eq!(letters, 0..3 * 500000, half_a_million_letter_x());\n     }\n-    fn half_a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_slice_fail() {\n+        &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n+    }\n+\n+    panic_cases! {\n+        in mod rangefrom_len {\n+            data: \"abcdef\";\n+            good: data[6..] == \"\";\n+            bad: data[7..];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeto_len {\n+            data: \"abcdef\";\n+            good: data[..6] == \"abcdef\";\n+            bad: data[..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangetoinclusive_len {\n+            data: \"abcdef\";\n+            good: data[..=5] == \"abcdef\";\n+            bad: data[..=6];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod range_len_len {\n+            data: \"abcdef\";\n+            good: data[6..6] == \"\";\n+            bad: data[7..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeinclusive_len_len {\n+            data: \"abcdef\";\n+            good: data[6..=5] == \"\";\n+            bad: data[7..=6];\n+            message: \"out of bounds\";\n         }\n-        rs\n     }\n-    let letters = a_million_letter_x();\n-    assert_eq!(half_a_million_letter_x(), &letters[0..3 * 500000]);\n-}\n \n-#[test]\n-fn test_slice_2() {\n-    let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    panic_cases! {\n+        in mod range_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..4] == \"\";\n+            bad: data[4..3];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n \n-    assert_eq!(\"\u534e\", &ss[3..6]);\n-    assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n+        in mod rangeinclusive_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..=3] == \"\";\n+            bad: data[4..=2];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n+    }\n \n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n+    mod overflow {\n+        panic_cases! {\n+            in mod rangeinclusive {\n+                data: \"hello\";\n+                // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+                //       so that `get` doesn't simply return None for the wrong reason.\n+                bad: data[0..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n \n-    assert_eq!(\"\u4e2d\", &ss[0..3]);\n-    assert_eq!(\"\u534eV\", &ss[3..7]);\n-    assert_eq!(\"\", &ss[3..3]);\n-    /*0: \u4e2d\n-      3: \u534e\n-      6: V\n-      7: i\n-      8: \u1ec7\n-     11: t\n-     12:\n-     13: N\n-     14: a\n-     15: m */\n-}\n+            in mod rangetoinclusive {\n+                data: \"hello\";\n+                bad: data[..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n+        }\n+    }\n \n-#[test]\n-#[should_panic]\n-fn test_slice_fail() {\n-    &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n-}\n+    mod boundary {\n+        const DATA: &'static str = \"abc\u03b1\u03b2\u03b3\";\n+\n+        const BAD_START: usize = 4;\n+        const GOOD_START: usize = 3;\n+        const BAD_END: usize = 6;\n+        const GOOD_END: usize = 7;\n+        const BAD_END_INCL: usize = BAD_END - 1;\n+        const GOOD_END_INCL: usize = GOOD_END - 1;\n+\n+        // it is especially important to test all of the different range types here\n+        // because some of the logic may be duplicated as part of micro-optimizations\n+        // to dodge unicode boundary checks on half-ranges.\n+        panic_cases! {\n+            in mod range_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..super::GOOD_END];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangetoinclusive_max_panics() {\n-    &\"hello\"[..=usize::max_value()];\n-}\n+            in mod range_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangeinclusive_max_panics() {\n-    &\"hello\"[1..=usize::max_value()];\n-}\n+            in mod rangefrom {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangetoinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[..=usize::max_value()];\n-}\n+            in mod rangeto {\n+                data: super::DATA;\n+                bad: data[..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangeinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[1..=usize::max_value()];\n-}\n+            in mod rangeinclusive_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..=super::GOOD_END_INCL];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-fn test_str_get_maxinclusive() {\n-    let mut s = \"hello\".to_owned();\n-    {\n-        let s: &str = &s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+            in mod rangeinclusive_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+\n+            in mod rangetoinclusive {\n+                data: super::DATA;\n+                bad: data[..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+        }\n     }\n-    {\n-        let s: &mut str = &mut s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+\n+    const LOREM_PARAGRAPH: &'static str = \"\\\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem \\\n+    sit amet dolor ultricies condimentum. Praesent iaculis purus elit, ac malesuada \\\n+    quam malesuada in. Duis sed orci eros. Suspendisse sit amet magna mollis, mollis \\\n+    nunc luctus, imperdiet mi. Integer fringilla non sem ut lacinia. Fusce varius \\\n+    tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec tempus vel, \\\n+    gravida nec quam.\";\n+\n+    // check the panic includes the prefix of the sliced string\n+    #[test]\n+    #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    fn test_slice_fail_truncated_1() {\n+        &LOREM_PARAGRAPH[..1024];\n+    }\n+    // check the truncation in the panic message\n+    #[test]\n+    #[should_panic(expected=\"luctus, im`[...]\")]\n+    fn test_slice_fail_truncated_2() {\n+        &LOREM_PARAGRAPH[..1024];\n     }\n }\n \n@@ -446,50 +711,6 @@ fn test_is_char_boundary() {\n         }\n     }\n }\n-const LOREM_PARAGRAPH: &'static str = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\";\n-\n-// check the panic includes the prefix of the sliced string\n-#[test]\n-#[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n-fn test_slice_fail_truncated_1() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-// check the truncation in the panic message\n-#[test]\n-#[should_panic(expected=\"luctus, im`[...]\")]\n-fn test_slice_fail_truncated_2() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\")]\n-fn test_slice_fail_boundary_1() {\n-    &\"abc\u03b1\u03b2\u03b3\"[4..];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\")]\n-fn test_slice_fail_boundary_2() {\n-    &\"abc\u03b1\u03b2\u03b3\"[2..6];\n-}\n-\n-#[test]\n-fn test_slice_from() {\n-    assert_eq!(&\"abcd\"[0..], \"abcd\");\n-    assert_eq!(&\"abcd\"[2..], \"cd\");\n-    assert_eq!(&\"abcd\"[4..], \"\");\n-}\n-#[test]\n-fn test_slice_to() {\n-    assert_eq!(&\"abcd\"[..0], \"\");\n-    assert_eq!(&\"abcd\"[..2], \"ab\");\n-    assert_eq!(&\"abcd\"[..4], \"abcd\");\n-}\n \n #[test]\n fn test_trim_left_matches() {"}, {"sha": "93ebc23ac0b0e33f45d3e6ed87519a57902be728", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=cff1a263c9e7744df286d2518e0c6ca3191dc681", "patch": "@@ -2262,6 +2262,12 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n+#[inline(never)]\n+#[cold]\n+fn slice_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice up to maximum usize\");\n+}\n+\n /// A helper trait used for indexing operations.\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n@@ -2538,15 +2544,13 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        assert!(self.end != usize::max_value(),\n-            \"attempted to index slice up to maximum usize\");\n+        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n         (self.start..self.end + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        assert!(self.end != usize::max_value(),\n-            \"attempted to index slice up to maximum usize\");\n+        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n         (self.start..self.end + 1).index_mut(slice)\n     }\n }"}, {"sha": "df7b2f25a86df19820db40788ec3b27f53e4e33a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=cff1a263c9e7744df286d2518e0c6ca3191dc681", "patch": "@@ -1849,6 +1849,12 @@ mod traits {\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n+    fn str_index_overflow_fail() -> ! {\n+        panic!(\"attempted to index str up to maximum usize\");\n+    }\n+\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n@@ -2029,19 +2035,13 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if let Some(end) = self.end.checked_add(1) {\n-                (self.start..end).get(slice)\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (self.start..self.end+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if let Some(end) = self.end.checked_add(1) {\n-                (self.start..end).get_mut(slice)\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (self.start..self.end+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -2053,14 +2053,12 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (self.start..self.end+1).index_mut(slice)\n         }\n     }\n@@ -2072,40 +2070,30 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n-                Some(unsafe { self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (..self.end+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (..self.end+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end + 1))\n+            (..self.end+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, self.end + 1))\n+            (..self.end+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (..self.end+1).index_mut(slice)\n         }\n     }"}, {"sha": "19b5c86c4740627b90b953dfb4c51801a690f997", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 213, "deletions": 37, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=cff1a263c9e7744df286d2518e0c6ca3191dc681", "patch": "@@ -376,48 +376,224 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n-#[test]\n-fn get_range() {\n-    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get(..), Some(&[0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get(..2), Some(&[0, 1][..]));\n-    assert_eq!(v.get(2..), Some(&[2, 3, 4, 5][..]));\n-    assert_eq!(v.get(1..4), Some(&[1, 2, 3][..]));\n-    assert_eq!(v.get(7..), None);\n-    assert_eq!(v.get(7..10), None);\n-}\n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n+mod slice_index {\n+    // This checks all six indexing methods, given an input range that\n+    // should succeed. (it is NOT suitable for testing invalid inputs)\n+    macro_rules! assert_range_eq {\n+        ($arr:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut arr = $arr;\n+            let mut expected = $expected;\n+            {\n+                let s: &[_] = &arr;\n+                let expected: &[_] = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut [_] = &mut arr;\n+                let expected: &mut [_] = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-#[test]\n-fn get_mut_range() {\n-    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n-    assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(1..4), Some(&mut [1, 2, 3][..]));\n-    assert_eq!(v.get_mut(7..), None);\n-    assert_eq!(v.get_mut(7..10), None);\n-}\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method that panics, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of range\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n+    }\n \n-#[test]\n-fn get_unchecked_range() {\n-    unsafe {\n-        let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked(..), &[0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(..2), &[0, 1][..]);\n-        assert_eq!(v.get_unchecked(2..), &[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(1..4), &[1, 2, 3][..]);\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n-}\n \n-#[test]\n-fn get_unchecked_mut_range() {\n-    unsafe {\n-        let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked_mut(..), &mut [0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(..2), &mut [0, 1][..]);\n-        assert_eq!(v.get_unchecked_mut(2..), &mut[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(1..4), &mut [1, 2, 3][..]);\n+    // Test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            // each test case needs a unique name to namespace the tests\n+            in mod $case_name:ident {\n+                data: $data:expr;\n+\n+                // optional:\n+                //\n+                // one or more similar inputs for which data[input] succeeds,\n+                // and the corresponding output as an array.  This helps validate\n+                // \"critical points\" where an input range straddles the boundary\n+                // between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    good: data[$good:expr] == $output:expr;\n+                )*\n+\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr;\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v = $data;\n+\n+                    $( assert_range_eq!($data, $good, $output); )*\n+\n+                    {\n+                        let v: &[_] = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut [_] = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v = $data;\n+                    let v: &[_] = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v = $data;\n+                    let v: &mut [_] = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n     }\n+\n+    #[test]\n+    fn simple() {\n+        let v = [0, 1, 2, 3, 4, 5];\n+\n+        assert_range_eq!(v, .., [0, 1, 2, 3, 4, 5]);\n+        assert_range_eq!(v, ..2, [0, 1]);\n+        assert_range_eq!(v, ..=1, [0, 1]);\n+        assert_range_eq!(v, 2.., [2, 3, 4, 5]);\n+        assert_range_eq!(v, 1..4, [1, 2, 3]);\n+        assert_range_eq!(v, 1..=3, [1, 2, 3]);\n+    }\n+\n+    panic_cases! {\n+        in mod rangefrom_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..] == [];\n+            bad: data[7..];\n+            message: \"but ends at\"; // perhaps not ideal\n+        }\n+\n+        in mod rangeto_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[..6] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..7];\n+            message: \"out of range\";\n+        }\n+\n+        in mod rangetoinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..=6];\n+            message: \"out of range\";\n+        }\n+\n+        in mod range_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..6] == [];\n+            bad: data[7..7];\n+            message: \"out of range\";\n+        }\n+\n+        in mod rangeinclusive_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..=5] == [];\n+            bad: data[7..=6];\n+            message: \"out of range\";\n+        }\n+    }\n+\n+    panic_cases! {\n+        in mod range_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[4..4] == [];\n+            bad: data[4..3];\n+            message: \"but ends at\";\n+        }\n+\n+        in mod rangeinclusive_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[4..=3] == [];\n+            bad: data[4..=2];\n+            message: \"but ends at\";\n+        }\n+    }\n+\n+    panic_cases! {\n+        in mod rangeinclusive_overflow {\n+            data: [0, 1];\n+\n+            // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+            //       so that `get` doesn't simply return None for the wrong reason.\n+            bad: data[0 ..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n+        }\n+\n+        in mod rangetoinclusive_overflow {\n+            data: [0, 1];\n+\n+            bad: data[..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n+        }\n+    } // panic_cases!\n }\n \n #[test]"}, {"sha": "343c9596c538321395d4d90a33b54301c255bedf", "filename": "src/libcore/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff1a263c9e7744df286d2518e0c6ca3191dc681/src%2Flibcore%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr.rs?ref=cff1a263c9e7744df286d2518e0c6ca3191dc681", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// All `str` tests live in collectionstests::str\n+// All `str` tests live in liballoc/tests"}]}