{"sha": "cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYzY3ODk0NWZlYzIxMWIwNmI2ZWM0YmEwNTliODI1OWRmZWIyYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-04T12:31:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-04T12:31:34Z"}, "message": "auto merge of #11951 : dmanescu/rust/reserve-rename, r=huonw\n\nChanges in std::{str,vec,hashmap} and extra::{priority_queue,ringbuf}.\r\nFixes #11949", "tree": {"sha": "477355751716088e11b4425eaabf21eb7925c81a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477355751716088e11b4425eaabf21eb7925c81a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "html_url": "https://github.com/rust-lang/rust/commit/cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10de762f6cf87a1c41cd047ec6b9970688f48873", "url": "https://api.github.com/repos/rust-lang/rust/commits/10de762f6cf87a1c41cd047ec6b9970688f48873", "html_url": "https://github.com/rust-lang/rust/commit/10de762f6cf87a1c41cd047ec6b9970688f48873"}, {"sha": "65f35781489ccaa66585b91f215308f3091bf404", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f35781489ccaa66585b91f215308f3091bf404", "html_url": "https://github.com/rust-lang/rust/commit/65f35781489ccaa66585b91f215308f3091bf404"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "3ae3dae9ea30703b250162f30cedbe06c05e70f9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "patch": "@@ -51,10 +51,14 @@ impl<T:Ord> PriorityQueue<T> {\n     /// Returns the number of elements the queue can hold without reallocating\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    pub fn reserve(&mut self, n: uint) { self.data.reserve(n) }\n-\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.data.reserve_at_least(n)\n+    /// Reserve capacity for exactly n elements in the PriorityQueue.\n+    /// Do nothing if the capacity is already sufficient.\n+    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n+\n+    /// Reserve capacity for at least n elements in the PriorityQueue.\n+    /// Do nothing if the capacity is already sufficient.\n+    pub fn reserve(&mut self, n: uint) {\n+        self.data.reserve(n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty\n@@ -203,7 +207,7 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n         let (lower, _) = iter.size_hint();\n \n         let len = self.capacity();\n-        self.reserve_at_least(len + lower);\n+        self.reserve(len + lower);\n \n         for elem in *iter {\n             self.push(elem);"}, {"sha": "4da35942935f15012ff84eaab15ebd3affde04fb", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "patch": "@@ -168,8 +168,8 @@ impl<T> RingBuf<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    pub fn reserve(&mut self, n: uint) {\n-        self.elts.reserve(n);\n+    pub fn reserve_exact(&mut self, n: uint) {\n+        self.elts.reserve_exact(n);\n     }\n \n     /// Reserve capacity for at least `n` elements in the given RingBuf,\n@@ -182,8 +182,8 @@ impl<T> RingBuf<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.elts.reserve_at_least(n);\n+    pub fn reserve(&mut self, n: uint) {\n+        self.elts.reserve(n);\n     }\n \n     /// Front-to-back iterator.\n@@ -641,26 +641,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reserve() {\n+    fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n-        d.reserve(50);\n+        d.reserve_exact(50);\n         assert_eq!(d.elts.capacity(), 50);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n-        d.reserve(50);\n+        d.reserve_exact(50);\n         assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n-    fn test_reserve_at_least() {\n+    fn test_reserve() {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n-        d.reserve_at_least(50);\n+        d.reserve(50);\n         assert_eq!(d.elts.capacity(), 64);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n-        d.reserve_at_least(50);\n+        d.reserve(50);\n         assert_eq!(d.elts.capacity(), 64);\n     }\n "}, {"sha": "7669467d4bbe8a46457b7c8c77d82a67ed9b2987", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "patch": "@@ -384,7 +384,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve(&mut self, n: uint) {\n         if n > self.buckets.len() {\n             let buckets = n * 4 / 3 + 1;\n             self.resize(num::next_power_of_two(buckets));\n@@ -793,8 +793,8 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.map.reserve_at_least(n)\n+    pub fn reserve(&mut self, n: uint) {\n+        self.map.reserve(n)\n     }\n \n     /// Returns true if the hash set contains a value equivalent to the"}, {"sha": "e33e2c31c6d49fabb2738402161b6019b4d1fb62", "filename": "src/libstd/str.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "patch": "@@ -91,7 +91,7 @@ use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n use libc;\n-use num::{Saturating, checked_next_power_of_two};\n+use num::Saturating;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -163,12 +163,7 @@ pub fn from_char(ch: char) -> ~str {\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n-    let mut buf = ~\"\";\n-    buf.reserve(chs.len());\n-    for ch in chs.iter() {\n-        buf.push_char(*ch)\n-    }\n-    buf\n+    chs.iter().map(|c| *c).collect()\n }\n \n #[doc(hidden)]\n@@ -852,8 +847,7 @@ pub fn utf16_chars(v: &[u16], f: |char|) {\n \n /// Allocates a new string from the utf-16 slice provided\n pub fn from_utf16(v: &[u16]) -> ~str {\n-    let mut buf = ~\"\";\n-    buf.reserve(v.len());\n+    let mut buf = with_capacity(v.len());\n     utf16_chars(v, |ch| buf.push_char(ch));\n     buf\n }\n@@ -2096,17 +2090,15 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn escape_default(&self) -> ~str {\n-        let mut out: ~str = ~\"\";\n-        out.reserve_at_least(self.len());\n+        let mut out = with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n         out\n     }\n \n     fn escape_unicode(&self) -> ~str {\n-        let mut out: ~str = ~\"\";\n-        out.reserve_at_least(self.len());\n+        let mut out = with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n@@ -2430,7 +2422,7 @@ pub trait OwnedStr {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    fn reserve(&mut self, n: uint);\n+    fn reserve_exact(&mut self, n: uint);\n \n     /// Reserves capacity for at least `n` bytes in the given string.\n     ///\n@@ -2448,7 +2440,7 @@ pub trait OwnedStr {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    fn reserve_at_least(&mut self, n: uint);\n+    fn reserve(&mut self, n: uint);\n \n     /// Returns the number of single-byte characters the string can hold without\n     /// reallocating\n@@ -2474,7 +2466,7 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n         let new_cap = self.len() + rhs.len();\n-        self.reserve(new_cap);\n+        self.reserve_exact(new_cap);\n         self.push_str(rhs);\n     }\n \n@@ -2553,15 +2545,17 @@ impl OwnedStr for ~str {\n     }\n \n     #[inline]\n-    fn reserve(&mut self, n: uint) {\n+    fn reserve_exact(&mut self, n: uint) {\n         unsafe {\n-            raw::as_owned_vec(self).reserve(n)\n+            raw::as_owned_vec(self).reserve_exact(n)\n         }\n     }\n \n     #[inline]\n-    fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(checked_next_power_of_two(n).unwrap_or(n))\n+    fn reserve(&mut self, n: uint) {\n+        unsafe {\n+            raw::as_owned_vec(self).reserve(n)\n+        }\n     }\n \n     #[inline]\n@@ -2619,7 +2613,7 @@ impl Extendable<char> for ~str {\n     fn extend<T: Iterator<char>>(&mut self, iterator: &mut T) {\n         let (lower, _) = iterator.size_hint();\n         let reserve = lower + self.len();\n-        self.reserve_at_least(reserve);\n+        self.reserve(reserve);\n         for ch in *iterator {\n             self.push_char(ch)\n         }"}, {"sha": "4a6a4d54ae3e43129f328621a9e3258c3a6c05be", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc678945fec211b06b6ec4ba059b8259dfeb2c2/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=cdc678945fec211b06b6ec4ba059b8259dfeb2c2", "patch": "@@ -1292,7 +1292,7 @@ pub trait OwnedVector<T> {\n      * This method always succeeds in reserving space for `n` elements, or it does\n      * not return.\n      */\n-    fn reserve(&mut self, n: uint);\n+    fn reserve_exact(&mut self, n: uint);\n     /**\n      * Reserves capacity for at least `n` elements in the given vector.\n      *\n@@ -1307,7 +1307,7 @@ pub trait OwnedVector<T> {\n      *\n      * * n - The number of elements to reserve space for\n      */\n-    fn reserve_at_least(&mut self, n: uint);\n+    fn reserve(&mut self, n: uint);\n     /**\n      * Reserves capacity for at least `n` additional elements in the given vector.\n      *\n@@ -1425,7 +1425,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().rev()\n     }\n \n-    fn reserve(&mut self, n: uint) {\n+    fn reserve_exact(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n             unsafe {\n@@ -1443,16 +1443,16 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(checked_next_power_of_two(n).unwrap_or(n));\n+    fn reserve(&mut self, n: uint) {\n+        self.reserve_exact(checked_next_power_of_two(n).unwrap_or(n));\n     }\n \n     #[inline]\n     fn reserve_additional(&mut self, n: uint) {\n         if self.capacity() - self.len() < n {\n             match self.len().checked_add(&n) {\n                 None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve_at_least(new_cap)\n+                Some(new_cap) => self.reserve(new_cap)\n             }\n         }\n     }\n@@ -1635,7 +1635,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n     fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n         let new_len = self.len() + n;\n-        self.reserve_at_least(new_len);\n+        self.reserve(new_len);\n         let mut i: uint = 0u;\n         while i < n {\n             self.push(op(i));\n@@ -1694,15 +1694,15 @@ impl<T:Clone> OwnedCloneableVector<T> for ~[T] {\n     #[inline]\n     fn push_all(&mut self, rhs: &[T]) {\n         let new_len = self.len() + rhs.len();\n-        self.reserve(new_len);\n+        self.reserve_exact(new_len);\n \n         for elt in rhs.iter() {\n             self.push((*elt).clone())\n         }\n     }\n     fn grow(&mut self, n: uint, initval: &T) {\n         let new_len = self.len() + n;\n-        self.reserve_at_least(new_len);\n+        self.reserve(new_len);\n         let mut i: uint = 0u;\n \n         while i < n {\n@@ -2857,7 +2857,7 @@ impl<A> Extendable<A> for ~[A] {\n     fn extend<T: Iterator<A>>(&mut self, iterator: &mut T) {\n         let (lower, _) = iterator.size_hint();\n         let len = self.len();\n-        self.reserve(len + lower);\n+        self.reserve_exact(len + lower);\n         for x in *iterator {\n             self.push(x);\n         }\n@@ -3579,10 +3579,10 @@ mod tests {\n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n-        v.reserve(10u);\n+        v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n         let mut v = ~[0u32];\n-        v.reserve(10u);\n+        v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n     }\n \n@@ -4018,7 +4018,7 @@ mod tests {\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault() {\n         let mut v = ~[];\n-        v.reserve(-1);\n+        v.reserve_exact(-1);\n         v.push(1);\n         v.push(2);\n     }\n@@ -4028,7 +4028,7 @@ mod tests {\n     fn test_overflow_does_not_cause_segfault_managed() {\n         use rc::Rc;\n         let mut v = ~[Rc::new(1)];\n-        v.reserve(-1);\n+        v.reserve_exact(-1);\n         v.push(Rc::new(2));\n     }\n "}]}