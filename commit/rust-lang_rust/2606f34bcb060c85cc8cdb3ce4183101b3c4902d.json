{"sha": "2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MDZmMzRiY2IwNjBjODVjYzhjZGIzY2U0MTgzMTAxYjNjNDkwMmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-27T20:13:53Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-27T20:13:53Z"}, "message": "Merge pull request #247 from Manishearth/links\n\nadded the rest of the link help messages", "tree": {"sha": "1e2fc2f70166b56c6a26dfbe2eb71bcba7fdd7e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2fc2f70166b56c6a26dfbe2eb71bcba7fdd7e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "html_url": "https://github.com/rust-lang/rust/commit/2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "html_url": "https://github.com/rust-lang/rust/commit/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6"}, {"sha": "e0816e7959ab1209cc0d1a8372bc09ee8212a949", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0816e7959ab1209cc0d1a8372bc09ee8212a949", "html_url": "https://github.com/rust-lang/rust/commit/e0816e7959ab1209cc0d1a8372bc09ee8212a949"}], "stats": {"total": 231, "additions": 90, "deletions": 141}, "files": [{"sha": "d307c7dd0563d648891268ea87d1051b42359cbe", "filename": "src/approx_const.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -3,7 +3,7 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use std::f64::consts as f64;\n \n-use utils::span_help_and_lint;\n+use utils::span_lint;\n \n declare_lint! {\n     pub APPROX_CONSTANT,\n@@ -40,7 +40,7 @@ fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n     match lit.node {\n         LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n         LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        LitFloatUnsuffixed(ref str) => \n+        LitFloatUnsuffixed(ref str) =>\n             check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n@@ -50,18 +50,16 @@ fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n     if let Ok(value) = str.parse::<f64>() {\n         for &(constant, name) in KNOWN_CONSTS {\n             if within_epsilon(constant, value) {\n-                span_help_and_lint(cx, APPROX_CONSTANT, span, &format!(\n+                span_lint(cx, APPROX_CONSTANT, span, &format!(\n                     \"approximate value of `{}::{}` found. \\\n-                    Consider using it directly\", module, &name),\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#approx_constant\");\n+                    Consider using it directly\", module, &name));\n             }\n         }\n     }\n }\n \n fn within_epsilon(target: f64, value: f64) -> bool {\n-    f64::abs(value - target) < f64::abs(if target > value { \n-                                            target \n+    f64::abs(value - target) < f64::abs(if target > value {\n+                                            target\n                                         } else { value }) / EPSILON_DIVISOR\n }"}, {"sha": "ad021f28a4d67ef45f43044c76ea6dab12b7ba2c", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -4,7 +4,7 @@ use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, match_path, span_help_and_lint};\n+use utils::{in_macro, match_path, span_lint};\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"`#[inline(always)]` is a bad idea in most cases\" }\n@@ -98,12 +98,10 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n             if values.len() != 1 || inline != &\"inline\" { continue; }\n             if let MetaWord(ref always) = values[0].node {\n                 if always != &\"always\" { continue; }\n-                span_help_and_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n+                span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n                     \"you have declared `#[inline(always)]` on `{}`. This \\\n                      is usually a bad idea. Are you sure?\",\n-                    ident.name),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#inline_always\");\n+                    ident.name));\n             }\n         }\n     }"}, {"sha": "465b772da5cee43eb126f92382ade403023761fe", "filename": "src/bit_mask.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -5,7 +5,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_comparison_binop;\n use syntax::codemap::Span;\n \n-use utils::span_help_and_lint;\n+use utils::span_lint;\n \n declare_lint! {\n     pub BAD_BIT_MASK,\n@@ -100,50 +100,36 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         BiEq | BiNe => match bit_op {\n             BiBitAnd => if mask_value & cmp_value != mask_value {\n                 if cmp_value != 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                         \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                        mask_value, cmp_value),\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                        mask_value, cmp_value));\n                 }\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             },\n             _ => ()\n         },\n         BiLt | BiGe => match bit_op {\n             BiBitAnd => if mask_value < cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span,\n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value >= cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -153,25 +139,18 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         },\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 if mask_value == 0 {\n-                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n-                        \"&-masking with zero\",\n-                        \"for further information see https://github.com/\\\n-                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                 }\n             },\n             BiBitOr => if mask_value > cmp_value {\n-                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                    mask_value, cmp_value),\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n+                    mask_value, cmp_value));\n             } else {\n                 check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -185,21 +164,17 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n \n fn check_ineffective_lt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if c.is_power_of_two() && m < c {\n-        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+            op, m, c));\n     }\n }\n \n fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n-        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+            op, m, c));\n     }\n }\n "}, {"sha": "6e4384072169b2639ff210161c0b29f12e75f85a", "filename": "src/misc.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n \n-use utils::{match_path, snippet, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n@@ -65,10 +65,8 @@ impl LintPass for CmpNan {\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n     path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n-        span_help_and_lint(cx, CMP_NAN, span,\n-            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cmp_nan\");\n+        span_lint(cx, CMP_NAN, span,\n+            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n     });\n }\n \n@@ -126,11 +124,9 @@ impl LintPass for Precedence {\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-                span_help_and_lint(cx, PRECEDENCE, expr.span,\n+                span_lint(cx, PRECEDENCE, expr.span,\n                     \"operator precedence can trip the unwary. Consider adding parentheses \\\n-                     to the subexpression\",\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#precedence\");\n+                     to the subexpression\");\n             }\n         }\n     }"}, {"sha": "eba7a9da1875888b087c7fe3531c72a0a807a9e8", "filename": "src/shadow.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -6,7 +6,7 @@ use syntax::visit::FnKind;\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{in_external_macro, snippet, span_help_and_lint};\n+use utils::{in_external_macro, snippet, span_lint};\n \n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n@@ -72,7 +72,7 @@ fn is_binding(cx: &Context, pat: &Pat) -> bool {\n     }\n }\n \n-fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,  \n+fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n         bindings: &mut Vec<Name>) where T: Deref<Target=Expr> {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n@@ -94,7 +94,7 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n         PatBox(ref inner) => {\n             if let Some(ref initp) = *init {\n                 match initp.node {\n-                    ExprBox(_, ref inner_init) => \n+                    ExprBox(_, ref inner_init) =>\n                         check_pat(cx, inner, &Some(&**inner_init), span, bindings),\n                     //TODO: ExprCall on Box::new\n                     _ => check_pat(cx, inner, init, span, bindings),\n@@ -110,38 +110,30 @@ fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,\n     }\n }\n \n-fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init: \n+fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n         &Option<T>) where T: Deref<Target=Expr> {\n     if let &Some(ref expr) = init {\n         if is_self_shadow(name, expr) {\n-            span_help_and_lint(cx, SHADOW_SAME, span, &format!(\n+            span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n-                snippet(cx, expr.span, \"..\")),\n-                \"for further information see \\\n-                https://github.com/Manishearth/rust-clippy/wiki#shadow_same\");\n+                snippet(cx, expr.span, \"..\")));\n         } else {\n             if contains_self(name, expr) {\n-                span_help_and_lint(cx, SHADOW_REUSE, span, &format!(\n+                span_lint(cx, SHADOW_REUSE, span, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    \"for further information see https://\\\n-                    github.com/Manishearth/rust-clippy/wiki#shadow_reuse\");\n+                    snippet(cx, expr.span, \"..\")));\n             } else {\n-                span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n+                span_lint(cx, SHADOW_UNRELATED, span, &format!(\n                     \"{} is shadowed by {} in this declaration\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")),\n-                    \"for further information see https://github.com\\\n-                    /Manishearth/rust-clippy/wiki#shadow_unrelated\");\n+                    snippet(cx, expr.span, \"..\")));\n             }\n         }\n     } else {\n-        span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n-            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")),\n-            \"for further information see \\\n-            https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated\");\n+        span_lint(cx, SHADOW_UNRELATED, span, &format!(\n+            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")));\n     }\n }\n \n@@ -218,7 +210,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && \n+    !path.global && path.segments.len() == 1 &&\n         path.segments[0].identifier.name == name\n }\n \n@@ -242,8 +234,8 @@ fn contains_self(name: Name, expr: &Expr) -> bool {\n             otherwise.as_ref().map_or(false, |ref e| contains_self(name, e)),\n         ExprWhile(ref e, ref block, _)  =>\n             contains_self(name, e) || contains_block_self(name, block),\n-        ExprMatch(ref e, ref arms, _) => \n-            arms.iter().any(|ref arm| arm.pats.iter().any(|ref pat| \n+        ExprMatch(ref e, ref arms, _) =>\n+            arms.iter().any(|ref arm| arm.pats.iter().any(|ref pat|\n                 contains_pat_self(name, pat))) || contains_self(name, e),\n         ExprPath(_, ref path) => path_eq_name(name, path),\n         _ => false\n@@ -274,18 +266,18 @@ fn contains_pat_self(name: Name, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => name == ident.node.name ||\n             inner.as_ref().map_or(false, |ref p| contains_pat_self(name, p)),\n-        PatEnum(_, ref opats) => opats.as_ref().map_or(false, \n+        PatEnum(_, ref opats) => opats.as_ref().map_or(false,\n             |pats| pats.iter().any(|p| contains_pat_self(name, p))),\n         PatQPath(_, ref path) => path_eq_name(name, path),\n         PatStruct(_, ref fieldpats, _) => fieldpats.iter().any(\n             |ref fp| contains_pat_self(name, &fp.node.pat)),\n         PatTup(ref ps) => ps.iter().any(|ref p| contains_pat_self(name, p)),\n         PatBox(ref p) |\n         PatRegion(ref p, _) => contains_pat_self(name, p),\n-        PatRange(ref from, ref until) => \n+        PatRange(ref from, ref until) =>\n             contains_self(name, from) || contains_self(name, until),\n         PatVec(ref pre, ref opt, ref post) =>\n-            pre.iter().any(|ref p| contains_pat_self(name, p)) || \n+            pre.iter().any(|ref p| contains_pat_self(name, p)) ||\n                 opt.as_ref().map_or(false, |ref p| contains_pat_self(name, p)) ||\n                 post.iter().any(|ref p| contains_pat_self(name, p)),\n         _ => false,"}, {"sha": "fc8a2d238bb3d0f5987ae293242c38b6131bb293", "filename": "src/strings.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_type, span_help_and_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n declare_lint! {\n@@ -45,19 +45,15 @@ impl LintPass for StringAdd {\n                         }\n                     }\n                 }\n-                span_help_and_lint(cx, STRING_ADD, e.span,\n+                span_lint(cx, STRING_ADD, e.span,\n                     \"you added something to a string. \\\n-                     Consider using `String::push_str()` instead\",\n-                    \"for further information see https://github.com/\\\n-                     Manishearth/rust-clippy/wiki#string_add\")\n+                     Consider using `String::push_str()` instead\")\n             }\n         } else if let &ExprAssign(ref target, ref  src) = &e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n-                span_help_and_lint(cx, STRING_ADD_ASSIGN, e.span,\n+                span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\",\n-                    \"for further information see https://github.com/\\\n-                    Manishearth/rust-clippy/wiki#string_add_assign\")\n+                     Consider using `String::push_str()` instead\")\n             }\n         }\n     }"}, {"sha": "3c4d1441f177e1fb4aa2a8ce1b76a77607963c17", "filename": "src/types.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -31,17 +31,14 @@ impl LintPass for TypePass {\n                     span_help_and_lint(\n                         cx, BOX_VEC, ast_ty.span,\n                         \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation. \\\n-                         for further information see https://github.com/\\\n-                         Manishearth/rust-clippy/wiki#box_vec\");\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                 }\n             }\n             else if match_type(cx, ty, &LL_PATH) {\n                 span_help_and_lint(\n                     cx, LINKEDLIST, ast_ty.span,\n                     \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                    \"a RingBuf might work; for further information see \\\n-                     https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n+                    \"a RingBuf might work\");\n             }\n         }\n     }\n@@ -141,15 +138,12 @@ fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast\n     let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n                          else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n                          else {int_ty_to_nbits(cast_from).to_string()};\n-    span_help_and_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n         &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n             ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n             cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n             if arch_dependent {arch_dependent_str} else {\"\"},\n-            from_nbits_str,\n-            mantissa_nbits),\n-        \"for further information see https://github.com/\\\n-        Manishearth/rust-clippy/wiki#cast_precision_loss\");\n+            from_nbits_str, mantissa_nbits));\n }\n \n enum ArchSuffix {\n@@ -183,26 +177,22 @@ fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS,\n                 ),\n         };\n     if span_truncation {\n-        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n             &format!(\"casting {} to {} may truncate the value{}\",\n                cast_from, cast_to,\n                match suffix_truncation {\n                    ArchSuffix::_32 => arch_32_suffix,\n                    ArchSuffix::_64 => arch_64_suffix,\n-                   ArchSuffix::None => \"\" }),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                   ArchSuffix::None => \"\" }));\n     }\n     if span_wrap {\n-        span_help_and_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n             &format!(\"casting {} to {} may wrap around the value{}\",\n                 cast_from, cast_to,\n                 match suffix_wrap {\n                     ArchSuffix::_32 => arch_32_suffix,\n                     ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\" }),\n-            \"for further information see https://github.com/\\\n-            Manishearth/rust-clippy/wiki#cast_possible_wrap\");\n+                    ArchSuffix::None => \"\" }));\n     }\n }\n \n@@ -227,37 +217,29 @@ impl LintPass for CastPass {\n                         }\n                     },\n                     (false, true) => {\n-                        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                            &format!(\"casting {} to {} may truncate the value\", \n-                                  cast_from, cast_to),\n-                            \"for further information see https://github.com/\\\n-                            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                            &format!(\"casting {} to {} may truncate the value\",\n+                                  cast_from, cast_to));\n                         if !cast_to.is_signed() {\n-                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\", \n-                                    cast_from, cast_to),\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\",\n+                                    cast_from, cast_to));\n                         }\n                     },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n-                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\", \n-                                    cast_from, cast_to),\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\",\n+                                    cast_from, cast_to));\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),\n                                 &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, \n-                                expr.span, \n-                                \"casting f64 to f32 may truncate the value\",\n-                                \"for further information see https://github.com/\\\n-                                Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n+                            span_lint(cx, CAST_POSSIBLE_TRUNCATION,\n+                                expr.span,\n+                                \"casting f64 to f32 may truncate the value\");\n                         }\n                     }\n                 }"}, {"sha": "69f5e22c48feaf2ecb5f83eadf6044ba045e0279", "filename": "src/utils.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2606f34bcb060c85cc8cdb3ce4183101b3c4902d/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=2606f34bcb060c85cc8cdb3ce4183101b3c4902d", "patch": "@@ -141,6 +141,11 @@ pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n #[cfg(not(feature=\"structured_logging\"))]\n pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            lint.name_lower()))\n+    }\n }\n \n #[cfg(feature=\"structured_logging\")]\n@@ -149,13 +154,20 @@ pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n     cx.span_lint(lint, sp, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+            https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            lint.name_lower()))\n+    }\n }\n \n pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n         msg: &str, help: &str) {\n     span_lint(cx, lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(span, help);\n+        cx.sess().fileline_help(span, &format!(\"{}\\nfor further information \\\n+            visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+            help, lint.name_lower()))\n     }\n }\n "}]}