{"sha": "9bc003da11ce9eb227514b26384f3dd8273c4b90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYzAwM2RhMTFjZTllYjIyNzUxNGIyNjM4NGYzZGQ4MjczYzRiOTA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-12T09:55:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-12T09:55:44Z"}, "message": "Rollup merge of #69026 - TimDiekmann:common-usage, r=Amanieu\n\nRemove common usage pattern from `AllocRef`\n\nThis removes the common usage patterns from `AllocRef`:\n- `alloc_one`\n- `dealloc_one`\n- `alloc_array`\n- `realloc_array`\n- `dealloc_array`\n\nActually, they add nothing to `AllocRef` except a [convenience wrapper around `Layout` and other methods in this trait](https://doc.rust-lang.org/1.41.0/src/core/alloc.rs.html#1076-1240) but have a major flaw: The documentation of `AllocRefs` notes, that\n\n> some higher-level allocation methods (`alloc_one`, `alloc_array`) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return `Err`, or to return `Ok` with some pointer.\n\nWith the current API, `GlobalAlloc` does not have those methods, so they cannot be overridden for `liballoc::Global`, which means that even if the global allocator would support zero-sized allocations, `alloc_one`, `alloc_array`, and `realloc_array` for `liballoc::Global` will error, while calling `alloc` with a zeroed-size `Layout` could succeed. Even worse: allocating with `alloc` and deallocating with `dealloc_{one,array}` could end up with not calling `dealloc` at all!\n\nFor the full discussion please see https://github.com/rust-lang/wg-allocators/issues/18\n\nr? @Amanieu", "tree": {"sha": "c1e3b99fbe19a2eebfdda3bb72f52801ed078fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1e3b99fbe19a2eebfdda3bb72f52801ed078fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc003da11ce9eb227514b26384f3dd8273c4b90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeQ8ugCRBK7hj4Ov3rIwAAdHIIAER61OOjHu7U9WcxXV3wYWtD\nai5MhTRFbG1zWbhVIo4l8mvGf5UyOMuMxckG+FXX+al7C7BdMn3Vv6s8BhBsl9aa\nTskapZ0qk2r+TXOxUcf1xdRtKvJ5vAUHUyxgsKeLWtzz8ezcJgiZ3GVb6mB1BJ+E\nMRHRuXsXfnhJf0XgUidx5aQZVUILFFYYVlpdapCypQ5N8jFC2Bk0Fq+KuIAi/LPc\naAxhqoguS0tk+7yQiEbMDeRaw+G+BrXKsbeTeEZOKENhU/yaTl8nDv1keGE9VQpQ\nHkQH39tHyJkZTcIbddr6zbeeshlwWq2opxaWs89CRqquPnrZzlrg4UM1eSehnQU=\n=MQJ2\n-----END PGP SIGNATURE-----\n", "payload": "tree c1e3b99fbe19a2eebfdda3bb72f52801ed078fc1\nparent 9b51a52084933656947f04e31d2d8c083a7cb6ee\nparent 25de80ad232b84ce581fe67cc08b43e9db6b0b1f\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581501344 +0900\ncommitter GitHub <noreply@github.com> 1581501344 +0900\n\nRollup merge of #69026 - TimDiekmann:common-usage, r=Amanieu\n\nRemove common usage pattern from `AllocRef`\n\nThis removes the common usage patterns from `AllocRef`:\n- `alloc_one`\n- `dealloc_one`\n- `alloc_array`\n- `realloc_array`\n- `dealloc_array`\n\nActually, they add nothing to `AllocRef` except a [convenience wrapper around `Layout` and other methods in this trait](https://doc.rust-lang.org/1.41.0/src/core/alloc.rs.html#1076-1240) but have a major flaw: The documentation of `AllocRefs` notes, that\n\n> some higher-level allocation methods (`alloc_one`, `alloc_array`) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return `Err`, or to return `Ok` with some pointer.\n\nWith the current API, `GlobalAlloc` does not have those methods, so they cannot be overridden for `liballoc::Global`, which means that even if the global allocator would support zero-sized allocations, `alloc_one`, `alloc_array`, and `realloc_array` for `liballoc::Global` will error, while calling `alloc` with a zeroed-size `Layout` could succeed. Even worse: allocating with `alloc` and deallocating with `dealloc_{one,array}` could end up with not calling `dealloc` at all!\n\nFor the full discussion please see https://github.com/rust-lang/wg-allocators/issues/18\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc003da11ce9eb227514b26384f3dd8273c4b90", "html_url": "https://github.com/rust-lang/rust/commit/9bc003da11ce9eb227514b26384f3dd8273c4b90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc003da11ce9eb227514b26384f3dd8273c4b90/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b51a52084933656947f04e31d2d8c083a7cb6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b51a52084933656947f04e31d2d8c083a7cb6ee", "html_url": "https://github.com/rust-lang/rust/commit/9b51a52084933656947f04e31d2d8c083a7cb6ee"}, {"sha": "25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/25de80ad232b84ce581fe67cc08b43e9db6b0b1f", "html_url": "https://github.com/rust-lang/rust/commit/25de80ad232b84ce581fe67cc08b43e9db6b0b1f"}], "stats": {"total": 232, "additions": 9, "deletions": 223}, "files": [{"sha": "144654946a2acb53225ac5dedb413f4a2aa95dd4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9bc003da11ce9eb227514b26384f3dd8273c4b90/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc003da11ce9eb227514b26384f3dd8273c4b90/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9bc003da11ce9eb227514b26384f3dd8273c4b90", "patch": "@@ -280,7 +280,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, uniq) = match self.current_layout() {\n+            let (new_cap, ptr) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +297,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Ok(ptr) => (new_cap, ptr),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -308,13 +308,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n                     // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n+                    let layout = Layout::array::<T>(new_cap).unwrap();\n+                    match self.a.alloc(layout) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n             };\n-            self.ptr = uniq;\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n         }\n     }"}, {"sha": "c75ef44655f9591bd2809c57ee54131dcf1b2e28", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 199, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9bc003da11ce9eb227514b26384f3dd8273c4b90/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc003da11ce9eb227514b26384f3dd8273c4b90/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=9bc003da11ce9eb227514b26384f3dd8273c4b90", "patch": "@@ -593,9 +593,8 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n-///   reallocation method (`realloc`, `realloc_excess`, or\n-///   `realloc_array`), and\n+///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n+///   (`realloc`, `realloc_excess`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n@@ -606,11 +605,6 @@ pub unsafe trait GlobalAlloc {\n /// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n-/// * However, some higher-level allocation methods (`alloc_one`,\n-///   `alloc_array`) are well-defined on zero-sized types and can\n-///   optionally support them: it is left up to the implementor\n-///   whether to return `Err`, or to return `Ok` with some pointer.\n-///\n /// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n@@ -1035,195 +1029,4 @@ pub unsafe trait AllocRef {\n         // new_layout.size() <= layout.size()        [required by this method]\n         if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-\n-    // == COMMON USAGE PATTERNS ==\n-    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n-\n-    /// Allocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `T` does not meet allocator's size or alignment constraints.\n-    ///\n-    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n-    /// will *not* yield undefined behavior.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n-    }\n-\n-    /// Deallocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// The given block must have been produced by this allocator,\n-    /// and must be suitable for storing a `T` (in terms of alignment\n-    /// as well as minimum and maximum size); otherwise yields\n-    /// undefined behavior.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            self.dealloc(ptr.cast(), k);\n-        }\n-    }\n-\n-    /// Allocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Reallocates a block previously suitable for holding `n_old`\n-    /// instances of `T`, returning a block suitable for holding\n-    /// `n_new` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n_new]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(\n-        &mut self,\n-        ptr: NonNull<T>,\n-        n_old: usize,\n-        n_new: usize,\n-    ) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n-                debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n-            }\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Deallocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `[T; n]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either `[T; n]` or the given\n-    /// memory block does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n-            _ => Err(AllocErr),\n-        }\n-    }\n }"}, {"sha": "b821a2c59396282462026cd60f03bee3b112cc00", "filename": "src/test/ui/allocator-alloc-one.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b51a52084933656947f04e31d2d8c083a7cb6ee/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b51a52084933656947f04e31d2d8c083a7cb6ee/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-alloc-one.rs?ref=9b51a52084933656947f04e31d2d8c083a7cb6ee", "patch": "@@ -1,18 +0,0 @@\n-// run-pass\n-\n-#![allow(stable_features)]\n-\n-#![feature(allocator_api, nonnull)]\n-\n-use std::alloc::{AllocRef, Global, Layout, handle_alloc_error};\n-\n-fn main() {\n-    unsafe {\n-        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| {\n-            handle_alloc_error(Layout::new::<i32>())\n-        });\n-        *ptr.as_ptr() = 4;\n-        assert_eq!(*ptr.as_ptr(), 4);\n-        Global.dealloc_one(ptr);\n-    }\n-}"}]}