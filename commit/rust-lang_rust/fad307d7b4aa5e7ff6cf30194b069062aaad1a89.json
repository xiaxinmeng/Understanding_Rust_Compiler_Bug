{"sha": "fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDMwN2Q3YjRhYTVlN2ZmNmNmMzAxOTRiMDY5MDYyYWFhZDFhODk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-25T03:18:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-25T19:48:39Z"}, "message": "core: Convert declarations to not use the trailing 'unsafe' notation", "tree": {"sha": "0742208560aea9aad32391f4399d5a401a9a1c8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0742208560aea9aad32391f4399d5a401a9a1c8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "html_url": "https://github.com/rust-lang/rust/commit/fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ba7ca5c9f103e17d98b4bd0d6d86e7a7c43366d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba7ca5c9f103e17d98b4bd0d6d86e7a7c43366d", "html_url": "https://github.com/rust-lang/rust/commit/3ba7ca5c9f103e17d98b4bd0d6d86e7a7c43366d"}], "stats": {"total": 1024, "additions": 569, "deletions": 455}, "files": [{"sha": "881d736d2ba8f7e5270bffe26a8a39f713828943", "filename": "src/libcore/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -2,9 +2,9 @@\n \n export ptr_eq;\n \n-pure fn ptr_eq<T>(a: @T, b: @T) -> bool unchecked {\n+pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     #[doc = \"Determine if two shared boxes point to the same object\"];\n-    ptr::addr_of(*a) == ptr::addr_of(*b)\n+    unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n \n #[test]"}, {"sha": "9aa1614114b635edfb64b968af424012da07f79b", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -231,7 +231,7 @@ fn test_to_digit() {\n }\n \n #[test]\n-fn test_is_ascii() unsafe {\n+fn test_is_ascii() {\n    assert str::all(\"banana\", char::is_ascii);\n    assert ! str::all(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", char::is_ascii);\n }"}, {"sha": "8cc82e56b8f109fbe25ca1794103833ea4355fcf", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -210,13 +210,13 @@ fn recv_<T: send>(p: *rust_port) -> T {\n     ret res;\n }\n \n-fn peek_(p: *rust_port) -> bool unsafe {\n+fn peek_(p: *rust_port) -> bool {\n     rustrt::rust_port_size(p) != 0u as libc::size_t\n }\n \n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n-    -> either<A, B> unsafe {\n+    -> either<A, B> {\n     let ports = [(**p_a).po, (**p_b).po];\n     let n_ports = 2 as libc::size_t;\n     let yield = 0u, yieldp = ptr::addr_of(yield);"}, {"sha": "175974f09cb1b1ba1382ec9e572180479bdaa61c", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -81,7 +81,7 @@ mod ct {\n     enum piece { piece_string(str), piece_conv(conv), }\n     type error_fn = fn@(str) -> ! ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n         let mut pieces: [piece] = [];\n         let lim = str::len(s);\n         let mut buf = \"\";\n@@ -225,7 +225,7 @@ mod ct {\n             } else { {count: count_implied, next: i} };\n     }\n     fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} unsafe {\n+       {ty: ty, next: uint} {\n         if i >= lim { error(\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // TODO: Do we really want two signed types here?\n@@ -314,7 +314,7 @@ mod rt {\n         let mut s = str::from_char(c);\n         ret pad(cv, s, pad_nozero);\n     }\n-    fn conv_str(cv: conv, s: str) -> str unsafe {\n+    fn conv_str(cv: conv, s: str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = alt cv.precision {\n@@ -378,7 +378,7 @@ mod rt {\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n-    fn pad(cv: conv, &s: str, mode: pad_mode) -> str unsafe {\n+    fn pad(cv: conv, &s: str, mode: pad_mode) -> str {\n         let uwidth : uint = alt cv.width {\n           count_implied { ret s; }\n           count_is(width) {"}, {"sha": "f1017488ee743ac46ad18ea7661806a48d12a445", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -93,10 +93,10 @@ fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n #[doc = \"Convert to a string in a given base\"]\n-fn to_str(n: T, radix: uint) -> str unsafe {\n+fn to_str(n: T, radix: uint) -> str {\n     to_str_bytes(n, radix) {|slice|\n         vec::unpack_slice(slice) {|p, len|\n-            str::unsafe::from_buf_len(p, len)\n+            unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n }"}, {"sha": "6a234aeef74d0aac13c1ea8693c852cd8ec72552", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -192,13 +192,13 @@ fn convert_whence(whence: seek_style) -> i32 {\n }\n \n impl of reader for *libc::FILE {\n-    fn read_bytes(len: uint) -> [u8] unsafe {\n+    fn read_bytes(len: uint) -> [u8] {\n         let mut buf : [mut u8] = [mut];\n         vec::reserve(buf, len);\n         vec::as_mut_buf(buf) {|b|\n             let read = libc::fread(b as *mut c_void, 1u as size_t,\n                                    len as size_t, self);\n-            vec::unsafe::set_len(buf, read as uint);\n+            unsafe { vec::unsafe::set_len(buf, read as uint) };\n         }\n         ret vec::from_mut(buf);\n     }\n@@ -329,7 +329,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n }\n \n impl of writer for *libc::FILE {\n-    fn write(v: [const u8]/&) unsafe {\n+    fn write(v: [const u8]/&) {\n         vec::unpack_const_slice(v) {|vbuf, len|\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n@@ -357,7 +357,7 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n }\n \n impl of writer for fd_t {\n-    fn write(v: [const u8]/&) unsafe {\n+    fn write(v: [const u8]/&) {\n         let mut count = 0u;\n         vec::unpack_const_slice(v) {|vbuf, len|\n             while count < len {"}, {"sha": "3394432137bad800cacd9993ed44542272712f7a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -70,21 +70,23 @@ pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     alt opt { none { } some(t) { f(t); } }\n }\n \n-pure fn unwrap<T>(-opt: option<T>) -> T unsafe {\n+pure fn unwrap<T>(-opt: option<T>) -> T {\n     #[doc = \"\n     Moves a value out of an option type and returns it.\n \n     Useful primarily for getting strings, vectors and unique pointers out of\n     option types without copying them.\n     \"];\n \n-    let addr = alt opt {\n-      some(x) { ptr::addr_of(x) }\n-      none { fail \"option none\" }\n-    };\n-    let liberated_value = unsafe::reinterpret_cast(*addr);\n-    unsafe::forget(opt);\n-    ret liberated_value;\n+    unsafe {\n+        let addr = alt opt {\n+          some(x) { ptr::addr_of(x) }\n+          none { fail \"option none\" }\n+        };\n+        let liberated_value = unsafe::reinterpret_cast(*addr);\n+        unsafe::forget(opt);\n+        ret liberated_value;\n+    }\n }\n \n impl extensions<T> for option<T> {"}, {"sha": "ee26bfc54960d5eb5dd5c260a6f3b99ae7c628fd", "filename": "src/libcore/os.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -180,19 +180,21 @@ mod global_env {\n         }\n     }\n \n-    fn global_env_task(msg_po: comm::port<msg>) unsafe {\n-        priv::weaken_task {|weak_po|\n-            loop {\n-                alt comm::select2(msg_po, weak_po) {\n-                  either::left(msg_getenv(n, resp_ch)) {\n-                    comm::send(resp_ch, impl::getenv(n))\n-                  }\n-                  either::left(msg_setenv(n, v, resp_ch)) {\n-                    comm::send(resp_ch, impl::setenv(n, v))\n-                  }\n-                  either::right(_) {\n-                    break;\n-                  }\n+    fn global_env_task(msg_po: comm::port<msg>) {\n+        unsafe {\n+            priv::weaken_task {|weak_po|\n+                loop {\n+                    alt comm::select2(msg_po, weak_po) {\n+                      either::left(msg_getenv(n, resp_ch)) {\n+                        comm::send(resp_ch, impl::getenv(n))\n+                      }\n+                      either::left(msg_setenv(n, v, resp_ch)) {\n+                        comm::send(resp_ch, impl::setenv(n, v))\n+                      }\n+                      either::right(_) {\n+                        break;\n+                      }\n+                    }\n                 }\n             }\n         }\n@@ -201,18 +203,20 @@ mod global_env {\n     mod impl {\n \n         #[cfg(unix)]\n-        fn getenv(n: str) -> option<str> unsafe {\n-            let s = str::as_c_str(n, libc::getenv);\n-            ret if unsafe::reinterpret_cast(s) == 0 {\n-                option::none::<str>\n-            } else {\n-                let s = unsafe::reinterpret_cast(s);\n-                option::some::<str>(str::unsafe::from_buf(s))\n-            };\n+        fn getenv(n: str) -> option<str> {\n+            unsafe {\n+                let s = str::as_c_str(n, libc::getenv);\n+                ret if unsafe::reinterpret_cast(s) == 0 {\n+                    option::none::<str>\n+                } else {\n+                    let s = unsafe::reinterpret_cast(s);\n+                    option::some::<str>(str::unsafe::from_buf(s))\n+                };\n+            }\n         }\n \n         #[cfg(windows)]\n-        fn getenv(n: str) -> option<str> unsafe {\n+        fn getenv(n: str) -> option<str> {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n@@ -362,21 +366,23 @@ fn dll_filename(base: str) -> str {\n fn self_exe_path() -> option<path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> option<path> unsafe {\n-        import libc::funcs::bsd44::*;\n-        import libc::consts::os::extra::*;\n-        fill_charp_buf() {|buf, sz|\n-            let mib = [CTL_KERN as c_int,\n-                       KERN_PROC as c_int,\n-                       KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-            sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n-                   buf as *mut c_void, ptr::mut_addr_of(sz),\n-                   ptr::null(), 0u as size_t) == (0 as c_int)\n+    fn load_self() -> option<path> {\n+        unsafe {\n+            import libc::funcs::bsd44::*;\n+            import libc::consts::os::extra::*;\n+            fill_charp_buf() {|buf, sz|\n+                let mib = [CTL_KERN as c_int,\n+                           KERN_PROC as c_int,\n+                           KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+                sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n+                       buf as *mut c_void, ptr::mut_addr_of(sz),\n+                       ptr::null(), 0u as size_t) == (0 as c_int)\n+            }\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         import libc::funcs::posix01::unistd::readlink;\n         fill_charp_buf() {|buf, sz|\n             as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n@@ -386,17 +392,18 @@ fn self_exe_path() -> option<path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n+\n         fill_charp_buf() {|buf, sz|\n             _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n                 == (0 as c_int)\n         }\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -525,14 +532,14 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     ret mkdir(p, mode);\n \n     #[cfg(windows)]\n-    fn mkdir(p: path, _mode: c_int) -> bool unsafe {\n+    fn mkdir(p: path, _mode: c_int) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         // FIXME: turn mode into something useful? #2623\n         as_utf16_p(p) {|buf|\n-            CreateDirectoryW(buf, unsafe::reinterpret_cast(0))\n+            CreateDirectoryW(buf, unsafe { unsafe::reinterpret_cast(0) })\n                 != (0 as BOOL)\n         }\n     }\n@@ -645,7 +652,7 @@ fn copy_file(from: path, to: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn do_copy_file(from: path, to: path) -> bool unsafe {\n+    fn do_copy_file(from: path, to: path) -> bool {\n         let istream = as_c_charp(from) {|fromp|\n             as_c_charp(\"rb\") {|modebuf|\n                 libc::fopen(fromp, modebuf)"}, {"sha": "93b32b6b8bdbb67b1e9b8cc32c6aaa59462d7bf1", "filename": "src/libcore/path.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -105,14 +105,20 @@ Given paths `pre` and `post, removes any trailing path separator on `pre` and\n any leading path separator on `post`, and returns the concatenation of the two\n with a single path separator between them.\n \"]\n-fn connect(pre: path, post: path) -> path unsafe {\n+fn connect(pre: path, post: path) -> path {\n     let mut pre_ = pre;\n     let mut post_ = post;\n     let sep = consts::path_sep as u8;\n     let pre_len  = str::len(pre);\n     let post_len = str::len(post);\n-    if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n-    if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n+    unsafe {\n+        if pre_len > 1u && pre[pre_len-1u] == sep {\n+            str::unsafe::pop_byte(pre_);\n+        }\n+        if post_len > 1u && post[0] == sep {\n+            str::unsafe::shift_byte(post_);\n+        }\n+    }\n     ret pre_ + path_sep() + post_;\n }\n "}, {"sha": "c0da0eb4528e3e37d8799e45c8ad4b39e91ce937", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -82,7 +82,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n }\n \n #[test]\n-fn test_from_global_chan1() unsafe {\n+fn test_from_global_chan1() {\n \n     // This is unreadable, right?\n \n@@ -91,21 +91,25 @@ fn test_from_global_chan1() unsafe {\n     let globchanp = ptr::addr_of(globchan);\n \n     // Create the global channel, attached to a new task\n-    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n-        let ch = comm::recv(po);\n-        comm::send(ch, true);\n-        let ch = comm::recv(po);\n-        comm::send(ch, true);\n+    let ch = unsafe {\n+        chan_from_global_ptr(globchanp, task::builder) {|po|\n+            let ch = comm::recv(po);\n+            comm::send(ch, true);\n+            let ch = comm::recv(po);\n+            comm::send(ch, true);\n+        }\n     };\n     // Talk to it\n     let po = comm::port();\n     comm::send(ch, comm::chan(po));\n     assert comm::recv(po) == true;\n \n     // This one just reuses the previous channel\n-    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n-        let ch = comm::recv(po);\n-        comm::send(ch, false);\n+    let ch = unsafe {\n+        chan_from_global_ptr(globchanp, task::builder) {|po|\n+            let ch = comm::recv(po);\n+            comm::send(ch, false);\n+        }\n     };\n \n     // Talk to the original global task\n@@ -115,7 +119,7 @@ fn test_from_global_chan1() unsafe {\n }\n \n #[test]\n-fn test_from_global_chan2() unsafe {\n+fn test_from_global_chan2() {\n \n     iter::repeat(100u) {||\n         // The global channel\n@@ -129,12 +133,14 @@ fn test_from_global_chan2() unsafe {\n         // create the global channel\n         for uint::range(0u, 10u) {|i|\n             task::spawn() {||\n-                let ch = chan_from_global_ptr(\n-                    globchanp, task::builder) {|po|\n-\n-                    for uint::range(0u, 10u) {|_j|\n-                        let ch = comm::recv(po);\n-                        comm::send(ch, {i});\n+                let ch = unsafe {\n+                    chan_from_global_ptr(\n+                        globchanp, task::builder) {|po|\n+\n+                        for uint::range(0u, 10u) {|_j|\n+                            let ch = comm::recv(po);\n+                            comm::send(ch, {i});\n+                        }\n                     }\n                 };\n                 let po = comm::port();\n@@ -174,62 +180,76 @@ This function is super-unsafe. Do not use.\n * Weak tasks must not be supervised. A supervised task keeps\n   a reference to its parent, so the parent will not die.\n \"]\n-unsafe fn weaken_task(f: fn(comm::port<()>)) unsafe {\n+unsafe fn weaken_task(f: fn(comm::port<()>)) {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    rustrt::rust_task_weaken(unsafe::reinterpret_cast(ch));\n+    unsafe {\n+        rustrt::rust_task_weaken(unsafe::reinterpret_cast(ch));\n+    }\n     let _unweaken = unweaken(ch);\n     f(po);\n \n-    resource unweaken(ch: comm::chan<()>) unsafe {\n-        rustrt::rust_task_unweaken(unsafe::reinterpret_cast(ch));\n+    resource unweaken(ch: comm::chan<()>) {\n+        unsafe {\n+            rustrt::rust_task_unweaken(unsafe::reinterpret_cast(ch));\n+        }\n     }\n }\n \n #[test]\n-fn test_weaken_task_then_unweaken() unsafe {\n+fn test_weaken_task_then_unweaken() {\n     task::try {||\n-        weaken_task {|_po|\n+        unsafe {\n+            weaken_task {|_po|\n+            }\n         }\n     };\n }\n \n #[test]\n-fn test_weaken_task_wait() unsafe {\n+fn test_weaken_task_wait() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n     task::run(builder) {||\n-        weaken_task {|po|\n-            comm::recv(po);\n+        unsafe {\n+            weaken_task {|po|\n+                comm::recv(po);\n+            }\n         }\n     }\n }\n \n #[test]\n-fn test_weaken_task_stress() unsafe {\n+fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n     iter::repeat(100u) {||\n         task::spawn {||\n-            weaken_task {|_po|\n+            unsafe {\n+                weaken_task {|_po|\n+                }\n             }\n         }\n         let builder = task::builder();\n         task::unsupervise(builder);\n         task::run(builder) {||\n-            weaken_task {|po|\n-                // Wait for it to tell us to die\n-                comm::recv(po);\n+            unsafe {\n+                weaken_task {|po|\n+                    // Wait for it to tell us to die\n+                    comm::recv(po);\n+                }\n             }\n         }\n     }\n }\n \n #[test]\n #[ignore(cfg(windows))]\n-fn test_weaken_task_fail() unsafe {\n+fn test_weaken_task_fail() {\n     let res = task::try {||\n-        weaken_task {|_po|\n-            fail;\n+        unsafe {\n+            weaken_task {|_po|\n+                fail;\n+            }\n         }\n     };\n     assert result::is_err(res);"}, {"sha": "d6288ea21268cf8c512cdddd24992a09d134136e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -39,20 +39,26 @@ pure fn addr_of<T>(val: T) -> *T { unchecked { rusti::addr_of(val) } }\n \n #[doc = \"Get an unsafe mut pointer to a value\"]\n #[inline(always)]\n-pure fn mut_addr_of<T>(val: T) -> *mut T unsafe {\n-    unsafe::reinterpret_cast(rusti::addr_of(val))\n+pure fn mut_addr_of<T>(val: T) -> *mut T {\n+    unsafe {\n+        unsafe::reinterpret_cast(rusti::addr_of(val))\n+    }\n }\n \n #[doc = \"Calculate the offset from a pointer\"]\n #[inline(always)]\n-fn offset<T>(ptr: *T, count: uint) -> *T unsafe {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+fn offset<T>(ptr: *T, count: uint) -> *T {\n+    unsafe {\n+        (ptr as uint + count * sys::size_of::<T>()) as *T\n+    }\n }\n \n #[doc = \"Calculate the offset from a const pointer\"]\n #[inline(always)]\n-fn const_offset<T>(ptr: *const T, count: uint) -> *const T unsafe {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+    unsafe {\n+        (ptr as uint + count * sys::size_of::<T>()) as *T\n+    }\n }\n \n #[doc = \"Calculate the offset from a mut pointer\"]\n@@ -79,7 +85,7 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n \n #[doc = \"Create an unsafe null pointer\"]\n #[inline(always)]\n-pure fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }\n+pure fn null<T>() -> *T { unsafe { unsafe::reinterpret_cast(0u) } }\n \n #[doc = \"Returns true if the pointer is equal to the null pointer.\"]\n pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n@@ -127,48 +133,52 @@ impl extensions<T> for *T {\n }\n \n #[test]\n-fn test() unsafe {\n-    type pair = {mut fst: int, mut snd: int};\n-    let p = {mut fst: 10, mut snd: 20};\n-    let pptr: *mut pair = mut_addr_of(p);\n-    let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n-    assert (*iptr == 10);;\n-    *iptr = 30;\n-    assert (*iptr == 30);\n-    assert (p.fst == 30);;\n-\n-    *pptr = {mut fst: 50, mut snd: 60};\n-    assert (*iptr == 50);\n-    assert (p.fst == 50);\n-    assert (p.snd == 60);\n-\n-    let v0 = [32000u16, 32001u16, 32002u16];\n-    let v1 = [0u16, 0u16, 0u16];\n-\n-    ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n-                ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n-    assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-    ptr::memcpy(vec::unsafe::to_ptr(v1),\n-                ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n-    assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-    ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 2u),\n-                vec::unsafe::to_ptr(v0), 1u);\n-    assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+fn test() {\n+    unsafe {\n+        type pair = {mut fst: int, mut snd: int};\n+        let p = {mut fst: 10, mut snd: 20};\n+        let pptr: *mut pair = mut_addr_of(p);\n+        let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n+        assert (*iptr == 10);;\n+        *iptr = 30;\n+        assert (*iptr == 30);\n+        assert (p.fst == 30);;\n+\n+        *pptr = {mut fst: 50, mut snd: 60};\n+        assert (*iptr == 50);\n+        assert (p.fst == 50);\n+        assert (p.snd == 60);\n+\n+        let v0 = [32000u16, 32001u16, 32002u16];\n+        let v1 = [0u16, 0u16, 0u16];\n+\n+        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n+                    ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n+        assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        ptr::memcpy(vec::unsafe::to_ptr(v1),\n+                    ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n+        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 2u),\n+                    vec::unsafe::to_ptr(v0), 1u);\n+        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+    }\n }\n \n #[test]\n-fn test_position() unsafe {\n+fn test_position() {\n     import str::as_c_str;\n     import libc::c_char;\n \n     let s = \"hello\";\n-    assert 2u == as_c_str(s) {|p| position(p) {|c| c == 'l' as c_char} };\n-    assert 4u == as_c_str(s) {|p| position(p) {|c| c == 'o' as c_char} };\n-    assert 5u == as_c_str(s) {|p| position(p) {|c| c == 0 as c_char } };\n+    unsafe {\n+        assert 2u == as_c_str(s) {|p| position(p) {|c| c == 'l' as c_char} };\n+        assert 4u == as_c_str(s) {|p| position(p) {|c| c == 'o' as c_char} };\n+        assert 5u == as_c_str(s) {|p| position(p) {|c| c == 0 as c_char } };\n+    }\n }\n \n #[test]\n-fn test_buf_len() unsafe {\n+fn test_buf_len() {\n     let s0 = \"hello\";\n     let s1 = \"there\";\n     let s2 = \"thing\";\n@@ -177,7 +187,7 @@ fn test_buf_len() unsafe {\n             str::as_c_str(s2) {|p2|\n                 let v = [p0, p1, p2, null()];\n                 vec::as_buf(v) {|vp|\n-                    assert buf_len(vp) == 3u;\n+                    assert unsafe { buf_len(vp) } == 3u;\n                 }\n             }\n         }"}, {"sha": "5c65971f2ea7141636274155c480d52fc7489a36", "filename": "src/libcore/result.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -326,14 +326,16 @@ fn iter_vec2<S,T,U:copy>(ss: [S], ts: [T],\n #[doc=\"\n Unwraps a result, assuming it is an `ok(T)`\n \"]\n-fn unwrap<T, U>(-res: result<T, U>) -> T unsafe {\n-    let addr = alt res {\n-      ok(x) { ptr::addr_of(x) }\n-      err(_) { fail \"error result\" }\n-    };\n-    let liberated_value = unsafe::reinterpret_cast(*addr);\n-    unsafe::forget(res);\n-    ret liberated_value;\n+fn unwrap<T, U>(-res: result<T, U>) -> T {\n+    unsafe {\n+        let addr = alt res {\n+          ok(x) { ptr::addr_of(x) }\n+          err(_) { fail \"error result\" }\n+        };\n+        let liberated_value = unsafe::reinterpret_cast(*addr);\n+        unsafe::forget(res);\n+        ret liberated_value;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "9e44a049ebe6fd29c4a8924a3f0e9048666a8804", "filename": "src/libcore/run.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -66,7 +66,7 @@ fn spawn_process(prog: str, args: [str],\n                  env: option<[(str,str)]>,\n                  dir: option<str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-   -> pid_t unsafe {\n+   -> pid_t {\n     with_argv(prog, args) {|argv|\n         with_envp(env) { |envp|\n             with_dirp(dir) { |dirp|\n@@ -78,7 +78,7 @@ fn spawn_process(prog: str, args: [str],\n }\n \n fn with_argv<T>(prog: str, args: [str],\n-                cb: fn(**libc::c_char) -> T) -> T unsafe {\n+                cb: fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog) {|b| [b] };\n     let mut tmps = [];\n     for vec::each(args) {|arg|\n@@ -92,7 +92,7 @@ fn with_argv<T>(prog: str, args: [str],\n \n #[cfg(unix)]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*c_void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     alt env {\n@@ -107,7 +107,9 @@ fn with_envp<T>(env: option<[(str,str)]>,\n             ptrs += str::as_c_str(*t) {|b| [b]};\n         }\n         ptrs += [ptr::null()];\n-        vec::as_buf(ptrs) { |p| cb(::unsafe::reinterpret_cast(p)) }\n+        vec::as_buf(ptrs) { |p|\n+            unsafe { cb(::unsafe::reinterpret_cast(p)) }\n+        }\n       }\n       _ {\n         cb(ptr::null())\n@@ -117,31 +119,33 @@ fn with_envp<T>(env: option<[(str,str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*c_void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n-    alt env {\n-      some(es) if !vec::is_empty(es) {\n-        let mut blk : [u8] = [];\n-        for vec::each(es) {|e|\n-            let (k,v) = e;\n-            let t = #fmt(\"%s=%s\", k, v);\n-            let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n-            blk += v;\n-            ::unsafe::forget(v);\n+    unsafe {\n+        alt env {\n+          some(es) if !vec::is_empty(es) {\n+            let mut blk : [u8] = [];\n+            for vec::each(es) {|e|\n+                let (k,v) = e;\n+                let t = #fmt(\"%s=%s\", k, v);\n+                let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n+                blk += v;\n+                ::unsafe::forget(v);\n+            }\n+            blk += [0_u8];\n+            vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n+          }\n+          _ {\n+            cb(ptr::null())\n+          }\n         }\n-        blk += [0_u8];\n-        vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n-      }\n-      _ {\n-        cb(ptr::null())\n-      }\n     }\n }\n \n fn with_dirp<T>(d: option<str>,\n-                cb: fn(*libc::c_char) -> T) -> T unsafe {\n+                cb: fn(*libc::c_char) -> T) -> T {\n     alt d {\n       some(dir) { str::as_c_str(dir, cb) }\n       none { cb(ptr::null()) }"}, {"sha": "90138468fa8c69978dff8a27fd3cc84a7e3613a4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 192, "deletions": 163, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -122,9 +122,9 @@ Convert a vector of bytes to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-pure fn from_bytes(vv: [u8]) -> str unsafe {\n-   assert is_utf8(vv);\n-   ret unsafe::from_bytes(vv);\n+pure fn from_bytes(vv: [u8]) -> str {\n+    assert is_utf8(vv);\n+    ret unsafe { unsafe::from_bytes(vv) };\n }\n \n #[doc = \"\n@@ -134,83 +134,85 @@ Convert a byte to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-pure fn from_byte(b: u8) -> str unsafe {\n+pure fn from_byte(b: u8) -> str {\n     assert b < 128u8;\n     let mut v = [b, 0u8];\n-    ::unsafe::transmute(v)\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n #[doc = \"Appends a character at the end of a string\"]\n-fn push_char(&s: str, ch: char) unsafe {\n-    let code = ch as uint;\n-    let nb = if code < max_one_b { 1u }\n+fn push_char(&s: str, ch: char) {\n+    unsafe {\n+        let code = ch as uint;\n+        let nb = if code < max_one_b { 1u }\n         else if code < max_two_b { 2u }\n         else if code < max_three_b { 3u }\n         else if code < max_four_b { 4u }\n         else if code < max_five_b { 5u }\n         else { 6u };\n-    let len = len(s);\n-    let new_len = len + nb;\n-    reserve_at_least(s, new_len);\n-    let off = len;\n-    as_buf(s) {|buf|\n-        let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n-        if nb == 1u {\n-            *ptr::mut_offset(buf, off) =\n-                code as u8;\n-        } else if nb == 2u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 6u & 31u | tag_two_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 3u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 12u & 15u | tag_three_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 4u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 18u & 7u | tag_four_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 5u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 24u & 3u | tag_five_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 18u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 4u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 6u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 30u & 1u | tag_six_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 24u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 18u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 4u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 5u) =\n-                (code & 63u | tag_cont) as u8;\n+        let len = len(s);\n+        let new_len = len + nb;\n+        reserve_at_least(s, new_len);\n+        let off = len;\n+        as_buf(s) {|buf|\n+            let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n+            if nb == 1u {\n+                *ptr::mut_offset(buf, off) =\n+                    code as u8;\n+            } else if nb == 2u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 6u & 31u | tag_two_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 3u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 12u & 15u | tag_three_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 4u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 18u & 7u | tag_four_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 5u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 24u & 3u | tag_five_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 18u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 4u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 6u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 30u & 1u | tag_six_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 24u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 18u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 4u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 5u) =\n+                    (code & 63u | tag_cont) as u8;\n+            }\n+            *ptr::mut_offset(buf, off + nb) = 0u8;\n         }\n-        *ptr::mut_offset(buf, off + nb) = 0u8;\n-    }\n \n-    as_bytes(s) {|bytes|\n-        let mut mut_bytes: [u8] = ::unsafe::reinterpret_cast(bytes);\n-        vec::unsafe::set_len(mut_bytes, new_len + 1u);\n-        ::unsafe::forget(mut_bytes);\n+        as_bytes(s) {|bytes|\n+            let mut mut_bytes: [u8] = ::unsafe::reinterpret_cast(bytes);\n+            vec::unsafe::set_len(mut_bytes, new_len + 1u);\n+            ::unsafe::forget(mut_bytes);\n+        }\n     }\n }\n \n@@ -276,9 +278,9 @@ Remove the first character from a string and return it\n \n If the string does not contain any characters\n \"]\n-fn shift_char(&s: str) -> char unsafe {\n+fn shift_char(&s: str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n-    s = unsafe::slice_bytes(s, next, len(s));\n+    s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n     ret ch;\n }\n \n@@ -320,20 +322,22 @@ Converts a string to a vector of bytes\n \n The result vector is not null-terminated.\n \"]\n-pure fn bytes(s: str) -> [u8] unsafe {\n-    let mut s_copy = s;\n-    let mut v: [u8] = ::unsafe::transmute(s_copy);\n-    vec::unsafe::set_len(v, len(s));\n-    ret v;\n+pure fn bytes(s: str) -> [u8] {\n+    unsafe {\n+        let mut s_copy = s;\n+        let mut v: [u8] = ::unsafe::transmute(s_copy);\n+        vec::unsafe::set_len(v, len(s));\n+        ret v;\n+    }\n }\n \n #[doc = \"\n Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n-pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n+pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T {\n     unpack_slice(s) {|p,n|\n-        vec::unsafe::form_slice(p, n-1u, f)\n+        unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n \n@@ -365,10 +369,10 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-pure fn slice(s: str/&, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str/&, begin: uint, end: uint) -> str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n-    unsafe::slice_bytes(s, begin, end)\n+    unsafe { unsafe::slice_bytes(s, begin, end) }\n }\n \n #[doc = \"\n@@ -396,23 +400,23 @@ pure fn split_char_nonempty(s: str/&, sep: char) -> [str] {\n }\n \n pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n-    -> [str] unsafe {\n+    -> [str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = [], done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    result += [unsafe::slice_bytes(s, start, i)];\n+                    result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            result += [unsafe::slice_bytes(s, start, l)];\n+            result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n         }\n         result\n     } else {\n@@ -440,22 +444,22 @@ pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n }\n \n pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> [str] unsafe {\n+               allow_empty: bool) -> [str] {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                result += [unsafe::slice_bytes(s, start, i)];\n+                result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l {\n-        result += [unsafe::slice_bytes(s, start, l)];\n+        result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n     }\n     result\n }\n@@ -578,7 +582,7 @@ Replace all occurrences of one string with another\n \n The original string with all occurances of `from` replaced with `to`\n \"]\n-pure fn replace(s: str, from: str, to: str) -> str unsafe {\n+pure fn replace(s: str, from: str, to: str) -> str {\n     let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n@@ -709,7 +713,7 @@ Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n-                         ff: fn(&&str)) unsafe {\n+                         ff: fn(&&str)) {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n@@ -1149,7 +1153,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool unsafe {\n+pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1564,9 +1568,11 @@ interop.\n let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n ~~~\n \"]\n-pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n-    let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    f(*v)\n+pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T {\n+    unsafe {\n+        let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        f(*v)\n+    }\n }\n \n #[doc = \"\n@@ -1575,8 +1581,8 @@ Work with the byte buffer of a string.\n Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n-pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n-    as_bytes(s) { |v| vec::as_buf(v, f) }\n+pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n+    as_bytes(s) { |v| unsafe { vec::as_buf(v, f) } }\n }\n \n #[doc = \"\n@@ -1591,7 +1597,7 @@ interop, without copying the original string.\n let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n-pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n+pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n     as_buf(s) {|buf| f(buf as *libc::c_char) }\n }\n \n@@ -1605,10 +1611,12 @@ indexable area for a null byte, as is the case in slices pointing\n to full strings, or suffixes of them.\n \"]\n #[inline(always)]\n-pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n-    let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len)\n+pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n+    unsafe {\n+        let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len)\n+    }\n }\n \n #[doc = \"\n@@ -1653,15 +1661,15 @@ capacity, then no action is taken.\n * s - A string\n * n - The number of bytes to reserve space for\n \"]\n-fn reserve_at_least(&s: str, n: uint) unsafe {\n+fn reserve_at_least(&s: str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n #[doc = \"\n Returns the number of single-byte characters the string can hold without\n reallocating\n \"]\n-pure fn capacity(&&s: str) -> uint unsafe {\n+pure fn capacity(&&s: str) -> uint {\n     as_bytes(s) {|buf|\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -1742,10 +1750,12 @@ mod unsafe {\n \n    Does not verify that the vector contains valid UTF-8.\n    \"]\n-   unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n-       vec::push(vcopy, 0u8);\n-       ::unsafe::transmute(vcopy)\n+   unsafe fn from_bytes(v: [const u8]) -> str {\n+       unsafe {\n+           let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n+           vec::push(vcopy, 0u8);\n+           ::unsafe::transmute(vcopy)\n+       }\n    }\n \n    #[doc = \"\n@@ -1765,20 +1775,22 @@ mod unsafe {\n    If begin is greater than end.\n    If end is greater than the length of the string.\n    \"]\n-   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str unsafe {\n+   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n        unpack_slice(s) { |sbuf, n|\n            assert (begin <= end);\n            assert (end <= n);\n \n            let mut v = [];\n            vec::reserve(v, end - begin + 1u);\n-           vec::as_buf(v) { |vbuf|\n-               let src = ptr::offset(sbuf, begin);\n-               ptr::memcpy(vbuf, src, end - begin);\n+           unsafe {\n+               vec::as_buf(v) { |vbuf|\n+                   let src = ptr::offset(sbuf, begin);\n+                   ptr::memcpy(vbuf, src, end - begin);\n+               }\n+               vec::unsafe::set_len(v, end - begin);\n+               v += [0u8];\n+               ::unsafe::transmute(v)\n            }\n-           vec::unsafe::set_len(v, end - begin);\n-           v += [0u8];\n-           ::unsafe::transmute(v)\n        }\n    }\n \n@@ -1795,22 +1807,22 @@ mod unsafe {\n    #[doc = \"\n    Removes the last byte from a string and returns it. (Not UTF-8 safe).\n    \"]\n-   unsafe fn pop_byte(&s: str) -> u8 unsafe {\n+   unsafe fn pop_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[len - 1u];\n-       set_len(s, len - 1u);\n+       unsafe { set_len(s, len - 1u) };\n        ret b;\n    }\n \n    #[doc = \"\n    Removes the first byte from a string and returns it. (Not UTF-8 safe).\n    \"]\n-   unsafe fn shift_byte(&s: str) -> u8 unsafe {\n+   unsafe fn shift_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[0];\n-       s = unsafe::slice_bytes(s, 1u, len);\n+       s = unsafe { unsafe::slice_bytes(s, 1u, len) };\n        ret b;\n    }\n \n@@ -1825,11 +1837,13 @@ mod unsafe {\n     }\n \n     #[test]\n-    fn test_from_buf_len() unsafe {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-        let b = vec::unsafe::to_ptr(a);\n-        let c = from_buf_len(b, 3u);\n-        assert (c == \"AAA\");\n+    fn test_from_buf_len() {\n+        unsafe {\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = vec::unsafe::to_ptr(a);\n+            let c = from_buf_len(b, 3u);\n+            assert (c == \"AAA\");\n+        }\n     }\n \n }\n@@ -2274,24 +2288,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unsafe_slice() unsafe {\n-        assert (eq(\"ab\", unsafe::slice_bytes(\"abc\", 0u, 2u)));\n-        assert (eq(\"bc\", unsafe::slice_bytes(\"abc\", 1u, 3u)));\n-        assert (eq(\"\", unsafe::slice_bytes(\"abc\", 1u, 1u)));\n-        fn a_million_letter_a() -> str {\n-            let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n-            ret rs;\n-        }\n-        fn half_a_million_letter_a() -> str {\n-            let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { rs += \"aaaaa\"; i += 1; }\n-            ret rs;\n+    fn test_unsafe_slice() {\n+        unsafe {\n+            assert (eq(\"ab\", unsafe::slice_bytes(\"abc\", 0u, 2u)));\n+            assert (eq(\"bc\", unsafe::slice_bytes(\"abc\", 1u, 3u)));\n+            assert (eq(\"\", unsafe::slice_bytes(\"abc\", 1u, 1u)));\n+            fn a_million_letter_a() -> str {\n+                let mut i = 0;\n+                let mut rs = \"\";\n+                while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n+                ret rs;\n+            }\n+            fn half_a_million_letter_a() -> str {\n+                let mut i = 0;\n+                let mut rs = \"\";\n+                while i < 100000 { rs += \"aaaaa\"; i += 1; }\n+                ret rs;\n+            }\n+            assert eq(half_a_million_letter_a(),\n+                      unsafe::slice_bytes(a_million_letter_a(),\n+                                          0u, 500000u));\n         }\n-        assert (eq(half_a_million_letter_a(),\n-               unsafe::slice_bytes(a_million_letter_a(), 0u, 500000u)));\n     }\n \n     #[test]\n@@ -2483,25 +2500,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_shift_byte() unsafe {\n+    fn test_shift_byte() {\n         let mut s = \"ABC\";\n-        let b = unsafe::shift_byte(s);\n+        let b = unsafe { unsafe::shift_byte(s) };\n         assert (s == \"BC\");\n         assert (b == 65u8);\n     }\n \n     #[test]\n-    fn test_pop_byte() unsafe {\n+    fn test_pop_byte() {\n         let mut s = \"ABC\";\n-        let b = unsafe::pop_byte(s);\n+        let b = unsafe { unsafe::pop_byte(s) };\n         assert (s == \"AB\");\n         assert (b == 67u8);\n     }\n \n     #[test]\n-    fn test_unsafe_from_bytes() unsafe {\n+    fn test_unsafe_from_bytes() {\n         let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe::from_bytes(a);\n+        let b = unsafe { unsafe::from_bytes(a) };\n         assert (b == \"AAAAAAA\");\n     }\n \n@@ -2541,11 +2558,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_buf() unsafe {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-        let b = vec::unsafe::to_ptr(a);\n-        let c = unsafe::from_buf(b);\n-        assert (c == \"AAAAAAA\");\n+    fn test_from_buf() {\n+        unsafe {\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = vec::unsafe::to_ptr(a);\n+            let c = unsafe::from_buf(b);\n+            assert (c == \"AAAAAAA\");\n+        }\n     }\n \n     #[test]\n@@ -2557,25 +2576,33 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_buf() unsafe {\n+    fn test_as_buf() {\n         let a = \"Abcdefg\";\n-        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        let b = as_buf(a, {|buf|\n+            assert unsafe { *buf } == 65u8;\n+            100\n+        });\n         assert (b == 100);\n     }\n \n     #[test]\n-    fn test_as_buf_small() unsafe {\n+    fn test_as_buf_small() {\n         let a = \"A\";\n-        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        let b = as_buf(a, {|buf|\n+            assert unsafe { *buf } == 65u8;\n+            100\n+        });\n         assert (b == 100);\n     }\n \n     #[test]\n-    fn test_as_buf2() unsafe {\n-        let s = \"hello\";\n-        let sb = as_buf(s, {|b| b });\n-        let s_cstr = unsafe::from_buf(sb);\n-        assert (eq(s_cstr, s));\n+    fn test_as_buf2() {\n+        unsafe {\n+            let s = \"hello\";\n+            let sb = as_buf(s, {|b| b });\n+            let s_cstr = unsafe::from_buf(sb);\n+            assert (eq(s_cstr, s));\n+        }\n     }\n \n     #[test]\n@@ -2813,14 +2840,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unpack_slice() unsafe {\n+    fn test_unpack_slice() {\n         let a = \"hello\";\n         unpack_slice(a) {|buf, len|\n-            assert a[0] == 'h' as u8;\n-            assert *buf == 'h' as u8;\n-            assert len == 6u;\n-            assert *ptr::offset(buf,4u) == 'o' as u8;\n-            assert *ptr::offset(buf,5u) == 0u8;\n+            unsafe {\n+                assert a[0] == 'h' as u8;\n+                assert *buf == 'h' as u8;\n+                assert len == 6u;\n+                assert *ptr::offset(buf,4u) == 'o' as u8;\n+                assert *ptr::offset(buf,5u) == 0u8;\n+            }\n         }\n     }\n "}, {"sha": "dafd92594edbfedf7a15577a9afc0cd1d0c0b6d7", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -52,7 +52,7 @@ pure fn get_type_desc<T>() -> *type_desc {\n \n #[doc = \"Returns the size of a type\"]\n #[inline(always)]\n-pure fn size_of<T>() -> uint unsafe {\n+pure fn size_of<T>() -> uint {\n     unchecked { rusti::size_of::<T>() }\n }\n \n@@ -62,12 +62,12 @@ Returns the ABI-required minimum alignment of a type\n This is the alignment used for struct fields. It may be smaller\n than the preferred alignment.\n \"]\n-pure fn min_align_of<T>() -> uint unsafe {\n+pure fn min_align_of<T>() -> uint {\n     unchecked { rusti::min_align_of::<T>() }\n }\n \n #[doc = \"Returns the preferred alignment of a type\"]\n-pure fn pref_align_of<T>() -> uint unsafe {\n+pure fn pref_align_of<T>() -> uint {\n     unchecked { rusti::pref_align_of::<T>() }\n }\n "}, {"sha": "73684e7c267c38b97e7c2d4acad1f9b160cd3343", "filename": "src/libcore/task.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -501,7 +501,7 @@ type task_id = int;\n type rust_task = libc::c_void;\n type rust_closure = libc::c_void;\n \n-fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n+fn spawn_raw(opts: task_opts, +f: fn~()) {\n \n     let mut f = if opts.supervise {\n         f\n@@ -516,25 +516,27 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n         }\n     };\n \n-    let fptr = ptr::addr_of(f);\n-    let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n+    unsafe {\n+        let fptr = ptr::addr_of(f);\n+        let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n-    let new_task = alt opts.sched {\n-      none {\n-        rustrt::new_task()\n-      }\n-      some(sched_opts) {\n-        new_task_in_new_sched(sched_opts)\n-      }\n-    };\n+        let new_task = alt opts.sched {\n+          none {\n+            rustrt::new_task()\n+          }\n+          some(sched_opts) {\n+            new_task_in_new_sched(sched_opts)\n+          }\n+        };\n \n-    option::iter(opts.notify_chan) {|c|\n-        // FIXME (#1087): Would like to do notification in Rust\n-        rustrt::rust_task_config_notify(new_task, c);\n-    }\n+        option::iter(opts.notify_chan) {|c|\n+            // FIXME (#1087): Would like to do notification in Rust\n+            rustrt::rust_task_config_notify(new_task, c);\n+        }\n \n-    rustrt::start_task(new_task, closure);\n-    unsafe::forget(f);\n+        rustrt::start_task(new_task, closure);\n+        unsafe::forget(f);\n+    }\n \n     fn new_task_in_new_sched(opts: sched_opts) -> *rust_task {\n         if opts.native_stack_size != none {\n@@ -959,7 +961,7 @@ fn test_osmain() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_unkillable() unsafe {\n+fn test_unkillable() {\n     import comm::methods;\n     let po = comm::port();\n     let ch = po.chan();\n@@ -977,14 +979,16 @@ fn test_unkillable() unsafe {\n         fail;\n     }\n \n-    unkillable {||\n-        let p = ~0;\n-        let pp: *uint = unsafe::transmute(p);\n+    unsafe {\n+        unkillable {||\n+            let p = ~0;\n+            let pp: *uint = unsafe::transmute(p);\n \n-        // If we are killed here then the box will leak\n-        po.recv();\n+            // If we are killed here then the box will leak\n+            po.recv();\n \n-        let _p: ~int = unsafe::transmute(pp);\n+            let _p: ~int = unsafe::transmute(pp);\n+        }\n     }\n \n     // Now we can be killed"}, {"sha": "d5f0cc465c7eb2ce8ed43d6eedd2d47e3f8e1d57", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -131,17 +131,17 @@ Convert to a string in a given base\n \n Fails if `radix` < 2 or `radix` > 16\n \"]\n-fn to_str(num: T, radix: uint) -> str unsafe {\n+fn to_str(num: T, radix: uint) -> str {\n     to_str_bytes(false, num, radix) {|slice|\n         vec::unpack_slice(slice) {|p, len|\n-            str::unsafe::from_buf_len(p, len)\n+            unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n }\n \n #[doc = \"Low-level helper routine for string conversion.\"]\n fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n-                   f: fn([u8]/&) -> U) -> U unsafe {\n+                   f: fn([u8]/&) -> U) -> U {\n \n     #[inline(always)]\n     fn digit(n: T) -> u8 {\n@@ -177,28 +177,30 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // pointers and unsafe bits, and the codegen will prove it's all\n     // in-bounds, no extra cost.\n \n-    vec::unpack_slice(buf) {|p, len|\n-        let mp = p as *mut u8;\n-        let mut i = len;\n-        let mut n = num;\n-        let radix = radix as T;\n-        loop {\n-            i -= 1u;\n+    unsafe {\n+        vec::unpack_slice(buf) {|p, len|\n+            let mp = p as *mut u8;\n+            let mut i = len;\n+            let mut n = num;\n+            let radix = radix as T;\n+            loop {\n+                i -= 1u;\n+                assert 0u < i && i < len;\n+                *ptr::mut_offset(mp, i) = digit(n % radix);\n+                n /= radix;\n+                if n == 0 as T { break; }\n+            }\n+\n             assert 0u < i && i < len;\n-            *ptr::mut_offset(mp, i) = digit(n % radix);\n-            n /= radix;\n-            if n == 0 as T { break; }\n-        }\n \n-        assert 0u < i && i < len;\n+            if neg {\n+                i -= 1u;\n+                *ptr::mut_offset(mp, i) = '-' as u8;\n+            }\n \n-        if neg {\n-            i -= 1u;\n-            *ptr::mut_offset(mp, i) = '-' as u8;\n+            vec::unsafe::form_slice(ptr::offset(p, i),\n+                                    len - i, f)\n         }\n-\n-        vec::unsafe::form_slice(ptr::offset(p, i),\n-                                len - i, f)\n     }\n }\n "}, {"sha": "85e2f8d8934e9c56b0e61cc9e938f57e00a98e36", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -45,20 +45,24 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n mod tests {\n \n     #[test]\n-    fn test_reinterpret_cast() unsafe {\n-        assert reinterpret_cast(1) == 1u;\n+    fn test_reinterpret_cast() {\n+        assert unsafe { reinterpret_cast(1) } == 1u;\n     }\n \n     #[test]\n-    fn test_transmute() unsafe {\n-        let x = @1;\n-        let x: *int = transmute(x);\n-        assert *x == 1;\n-        let _x: @int = transmute(x);\n+    fn test_transmute() {\n+        unsafe {\n+            let x = @1;\n+            let x: *int = transmute(x);\n+            assert *x == 1;\n+            let _x: @int = transmute(x);\n+        }\n     }\n \n     #[test]\n-    fn test_transmute2() unsafe {\n-        assert transmute(\"L\") == [76u8, 0u8];\n+    fn test_transmute2() {\n+        unsafe {\n+            assert transmute(\"L\") == [76u8, 0u8];\n+        }\n     }\n }"}, {"sha": "b81073c729f747f1276ff67145c15052f0b6fa68", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 93, "deletions": 69, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad307d7b4aa5e7ff6cf30194b069062aaad1a89/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "patch": "@@ -158,14 +158,16 @@ fn reserve_at_least<T>(&v: [const T], n: uint) {\n Returns the number of elements the vector can hold without reallocating\n \"]\n #[inline(always)]\n-pure fn capacity<T>(&&v: [const T]) -> uint unsafe {\n-    let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-    (**repr).alloc / sys::size_of::<T>()\n+pure fn capacity<T>(&&v: [const T]) -> uint {\n+    unsafe {\n+        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).alloc / sys::size_of::<T>()\n+    }\n }\n \n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n-pure fn len<T>(&&v: [const T]/&) -> uint unsafe {\n+pure fn len<T>(&&v: [const T]/&) -> uint {\n     unpack_const_slice(v) {|_p, len| len}\n }\n \n@@ -200,13 +202,13 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n }\n \n #[doc = \"Produces a mut vector from an immutable vector.\"]\n-fn to_mut<T>(+v: [T]) -> [mut T] unsafe {\n-    ::unsafe::transmute(v)\n+fn to_mut<T>(+v: [T]) -> [mut T] {\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n #[doc = \"Produces an immutable vector from a mut vector.\"]\n-fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n-    ::unsafe::transmute(v)\n+fn from_mut<T>(+v: [mut T]) -> [T] {\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n // Accessors\n@@ -406,13 +408,15 @@ fn unshift<T>(&v: [T], +x: T) {\n }\n \n #[doc = \"Remove the last element from a vector and return it\"]\n-fn pop<T>(&v: [const T]) -> T unsafe {\n+fn pop<T>(&v: [const T]) -> T {\n     let ln = len(v);\n     assert ln > 0u;\n     let valptr = ptr::mut_addr_of(v[ln - 1u]);\n-    let val <- *valptr;\n-    unsafe::set_len(v, ln - 1u);\n-    val\n+    unsafe {\n+        let val <- *valptr;\n+        unsafe::set_len(v, ln - 1u);\n+        val\n+    }\n }\n \n #[doc = \"Append an element to a vector\"]\n@@ -963,13 +967,15 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n-            if !f(*p) { break; }\n-            p = ptr::offset(p, 1u);\n+            unsafe {\n+                if !f(*p) { break; }\n+                p = ptr::offset(p, 1u);\n+            }\n             n -= 1u;\n         }\n     }\n@@ -981,13 +987,15 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n         while i < n {\n-            if !f(i, *p) { break; }\n-            p = ptr::offset(p, 1u);\n+            unsafe {\n+                if !f(i, *p) { break; }\n+                p = ptr::offset(p, 1u);\n+            }\n             i += 1u;\n         }\n     }\n@@ -1088,11 +1096,11 @@ Work with the buffer of a vector.\n Allows for unsafe manipulation of vector contents, which is useful for native\n interop.\n \"]\n-fn as_buf<E,T>(v: [E]/&, f: fn(*E) -> T) -> T unsafe {\n+fn as_buf<E,T>(v: [E]/&, f: fn(*E) -> T) -> T {\n     unpack_slice(v) { |buf, _len| f(buf) }\n }\n \n-fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T unsafe {\n+fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T {\n     unpack_mut_slice(v) { |buf, _len| f(buf) }\n }\n \n@@ -1101,32 +1109,40 @@ Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_slice<T,U>(s: [const T]/&,\n-                          f: fn(*T, uint) -> U) -> U unsafe {\n-    let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                          f: fn(*T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_const_slice<T,U>(s: [const T]/&,\n-                                f: fn(*const T, uint) -> U) -> U unsafe {\n-    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                                f: fn(*const T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*const T,uint) =\n+            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n-                              f: fn(*mut T, uint) -> U) -> U unsafe {\n-    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                              f: fn(*mut T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*const T,uint) =\n+            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n impl extensions<T: copy> for [T] {\n@@ -1380,12 +1396,14 @@ mod u8 {\n     export hash;\n \n     #[doc = \"Bytewise string comparison\"]\n-    pure fn cmp(&&a: [u8], &&b: [u8]) -> int unsafe {\n+    pure fn cmp(&&a: [u8], &&b: [u8]) -> int {\n         let a_len = len(a);\n         let b_len = len(b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n-        let r = libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n-                             unsafe::to_ptr(b) as *libc::c_void, n) as int;\n+        let r = unsafe {\n+            libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n+                         unsafe::to_ptr(b) as *libc::c_void, n) as int\n+        };\n \n         if r != 0 { r } else {\n             if a_len == b_len {\n@@ -1405,10 +1423,10 @@ mod u8 {\n     pure fn le(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) <= 0 }\n \n     #[doc = \"Bytewise equality\"]\n-    pure fn eq(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) == 0 }\n+    pure fn eq(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) == 0 } }\n \n     #[doc = \"Bytewise inequality\"]\n-    pure fn ne(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) != 0 }\n+    pure fn ne(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) != 0 } }\n \n     #[doc =\"Bytewise greater than or equal\"]\n     pure fn ge(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) >= 0 }\n@@ -1482,26 +1500,28 @@ mod tests {\n     fn add(&&x: uint, &&y: uint) -> uint { ret x + y; }\n \n     #[test]\n-    fn test_unsafe_ptrs() unsafe {\n-        // Test on-stack copy-from-buf.\n-        let a = [1, 2, 3];\n-        let mut ptr = unsafe::to_ptr(a);\n-        let b = unsafe::from_buf(ptr, 3u);\n-        assert (len(b) == 3u);\n-        assert (b[0] == 1);\n-        assert (b[1] == 2);\n-        assert (b[2] == 3);\n-\n-        // Test on-heap copy-from-buf.\n-        let c = [1, 2, 3, 4, 5];\n-        ptr = unsafe::to_ptr(c);\n-        let d = unsafe::from_buf(ptr, 5u);\n-        assert (len(d) == 5u);\n-        assert (d[0] == 1);\n-        assert (d[1] == 2);\n-        assert (d[2] == 3);\n-        assert (d[3] == 4);\n-        assert (d[4] == 5);\n+    fn test_unsafe_ptrs() {\n+        unsafe {\n+            // Test on-stack copy-from-buf.\n+            let a = [1, 2, 3];\n+            let mut ptr = unsafe::to_ptr(a);\n+            let b = unsafe::from_buf(ptr, 3u);\n+            assert (len(b) == 3u);\n+            assert (b[0] == 1);\n+            assert (b[1] == 2);\n+            assert (b[2] == 3);\n+\n+            // Test on-heap copy-from-buf.\n+            let c = [1, 2, 3, 4, 5];\n+            ptr = unsafe::to_ptr(c);\n+            let d = unsafe::from_buf(ptr, 5u);\n+            assert (len(d) == 5u);\n+            assert (d[0] == 1);\n+            assert (d[1] == 2);\n+            assert (d[2] == 3);\n+            assert (d[3] == 4);\n+            assert (d[4] == 5);\n+        }\n     }\n \n     #[test]\n@@ -2189,21 +2209,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn to_mut_no_copy() unsafe {\n-        let x = [1, 2, 3];\n-        let addr = unsafe::to_ptr(x);\n-        let x_mut = to_mut(x);\n-        let addr_mut = unsafe::to_ptr(x_mut);\n-        assert addr == addr_mut;\n+    fn to_mut_no_copy() {\n+        unsafe {\n+            let x = [1, 2, 3];\n+            let addr = unsafe::to_ptr(x);\n+            let x_mut = to_mut(x);\n+            let addr_mut = unsafe::to_ptr(x_mut);\n+            assert addr == addr_mut;\n+        }\n     }\n \n     #[test]\n-    fn from_mut_no_copy() unsafe {\n-        let x = [mut 1, 2, 3];\n-        let addr = unsafe::to_ptr(x);\n-        let x_imm = from_mut(x);\n-        let addr_imm = unsafe::to_ptr(x_imm);\n-        assert addr == addr_imm;\n+    fn from_mut_no_copy() {\n+        unsafe {\n+            let x = [mut 1, 2, 3];\n+            let addr = unsafe::to_ptr(x);\n+            let x_imm = from_mut(x);\n+            let addr_imm = unsafe::to_ptr(x_imm);\n+            assert addr == addr_imm;\n+        }\n     }\n \n     #[test]"}]}