{"sha": "9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMmMwNTY0NzgzYWE5MWY2NDQwZTdjYWRjYzFhNGRmZGE3ODVkZTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-11T13:53:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-11T13:53:57Z"}, "message": "Separate parser API from implementation", "tree": {"sha": "4a6ef12405bf0562f4875b48cc1c834195ce7920", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a6ef12405bf0562f4875b48cc1c834195ce7920"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "html_url": "https://github.com/rust-lang/rust/commit/9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0ada860b57acd44b1d53e944ae621e438652da", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0ada860b57acd44b1d53e944ae621e438652da", "html_url": "https://github.com/rust-lang/rust/commit/7a0ada860b57acd44b1d53e944ae621e438652da"}], "stats": {"total": 486, "additions": 254, "deletions": 232}, "files": [{"sha": "30fe5c6d71fb7b8a322781ed259e5d8b816504db", "filename": "src/parser/event.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -61,7 +61,7 @@ pub(crate) enum Event {\n     },\n \n     Error {\n-        message: String,\n+        msg: String,\n     },\n }\n \n@@ -140,8 +140,8 @@ pub(super) fn to_file(text: String, tokens: &[Token], events: Vec<Event>) -> Fil\n                 }\n                 builder.leaf(kind, len);\n             }\n-            &Event::Error { ref message } => builder.error(ErrorMsg {\n-                message: message.clone(),\n+            &Event::Error { ref msg } => builder.error(ErrorMsg {\n+                msg: msg.clone(),\n             }),\n         }\n     }"}, {"sha": "e29cf9b02b8cab07ac9324381624da90c9f6c19e", "filename": "src/parser/grammar/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fmod.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -1,4 +1,5 @@\n-use super::parser::{Parser, TokenSet};\n+use parser::parser::{Parser};\n+use parser::token_set::TokenSet;\n use SyntaxKind;\n use syntax_kinds::*;\n "}, {"sha": "3814837e11a214e2d68108fe2d619e277dfdb6f5", "filename": "src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -3,19 +3,20 @@ use {File, SyntaxKind, Token};\n use syntax_kinds::*;\n \n #[macro_use]\n+mod token_set;\n mod parser;\n mod input;\n mod event;\n mod grammar;\n-use self::event::Event;\n \n /// Parse a sequence of tokens into the representative node tree\n pub fn parse(text: String, tokens: &[Token]) -> File {\n     let events = {\n         let input = input::ParserInput::new(&text, tokens);\n-        let mut parser = parser::Parser::new(&input);\n+        let parser_impl = parser::imp::ParserImpl::new(&input);\n+        let mut parser = parser::Parser(parser_impl);\n         grammar::file(&mut parser);\n-        parser.into_events()\n+        parser.0.into_events()\n     };\n     event::to_file(text, tokens, events)\n }\n@@ -26,33 +27,3 @@ fn is_insignificant(kind: SyntaxKind) -> bool {\n         _ => false,\n     }\n }\n-\n-impl<'p> parser::Parser<'p> {\n-    fn at(&self, kind: SyntaxKind) -> bool {\n-        self.current() == kind\n-    }\n-\n-    fn err_and_bump(&mut self, message: &str) {\n-        let err = self.start();\n-        self.error(message);\n-        self.bump();\n-        err.complete(self, ERROR);\n-    }\n-\n-    fn expect(&mut self, kind: SyntaxKind) -> bool {\n-        if self.at(kind) {\n-            self.bump();\n-            true\n-        } else {\n-            self.error(format!(\"expected {:?}\", kind));\n-            false\n-        }\n-    }\n-\n-    fn eat(&mut self, kind: SyntaxKind) -> bool {\n-        self.at(kind) && {\n-            self.bump();\n-            true\n-        }\n-    }\n-}"}, {"sha": "7c8e47cb6f693a09729b4f3b527330869e921e0e", "filename": "src/parser/parser.rs", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ada860b57acd44b1d53e944ae621e438652da/src%2Fparser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ada860b57acd44b1d53e944ae621e438652da/src%2Fparser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser.rs?ref=7a0ada860b57acd44b1d53e944ae621e438652da", "patch": "@@ -1,193 +0,0 @@\n-use super::Event;\n-use super::input::{InputPosition, ParserInput};\n-use SyntaxKind::{self, EOF, TOMBSTONE};\n-\n-pub(crate) struct Marker {\n-    pos: u32,\n-}\n-\n-impl Marker {\n-    pub fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompleteMarker {\n-        match self.event(p) {\n-            &mut Event::Start {\n-                kind: ref mut slot, ..\n-            } => {\n-                *slot = kind;\n-            }\n-            _ => unreachable!(),\n-        }\n-        p.event(Event::Finish);\n-        let result = CompleteMarker { pos: self.pos };\n-        ::std::mem::forget(self);\n-        result\n-    }\n-\n-    pub fn abandon(self, p: &mut Parser) {\n-        let idx = self.pos as usize;\n-        if idx == p.events.len() - 1 {\n-            match p.events.pop() {\n-                Some(Event::Start {\n-                    kind: TOMBSTONE,\n-                    forward_parent: None,\n-                }) => (),\n-                _ => unreachable!(),\n-            }\n-        }\n-        ::std::mem::forget(self);\n-    }\n-\n-    fn event<'p>(&self, p: &'p mut Parser) -> &'p mut Event {\n-        &mut p.events[self.idx()]\n-    }\n-\n-    fn idx(&self) -> usize {\n-        self.pos as usize\n-    }\n-}\n-\n-impl Drop for Marker {\n-    fn drop(&mut self) {\n-        if !::std::thread::panicking() {\n-            panic!(\"Each marker should be eithe completed or abandoned\");\n-        }\n-    }\n-}\n-\n-pub(crate) struct CompleteMarker {\n-    pos: u32,\n-}\n-\n-impl CompleteMarker {\n-    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n-        let m = p.start();\n-        match p.events[self.pos as usize] {\n-            Event::Start {\n-                ref mut forward_parent,\n-                ..\n-            } => {\n-                *forward_parent = Some(m.pos - self.pos);\n-            }\n-            _ => unreachable!(),\n-        }\n-        m\n-    }\n-}\n-\n-pub(crate) struct TokenSet {\n-    pub tokens: &'static [SyntaxKind],\n-}\n-\n-impl TokenSet {\n-    pub fn contains(&self, kind: SyntaxKind) -> bool {\n-        self.tokens.contains(&kind)\n-    }\n-}\n-\n-#[macro_export]\n-macro_rules! token_set {\n-    ($($t:ident),*) => {\n-        TokenSet {\n-            tokens: &[$($t),*],\n-        }\n-    };\n-\n-    ($($t:ident),* ,) => {\n-        token_set!($($t),*)\n-    };\n-}\n-\n-pub(crate) struct Parser<'t> {\n-    inp: &'t ParserInput<'t>,\n-\n-    pos: InputPosition,\n-    events: Vec<Event>,\n-}\n-\n-impl<'t> Parser<'t> {\n-    pub(crate) fn new(inp: &'t ParserInput<'t>) -> Parser<'t> {\n-        Parser {\n-            inp,\n-\n-            pos: InputPosition::new(),\n-            events: Vec::new(),\n-        }\n-    }\n-\n-    pub(crate) fn into_events(self) -> Vec<Event> {\n-        assert_eq!(self.current(), EOF);\n-        self.events\n-    }\n-\n-    pub(crate) fn start(&mut self) -> Marker {\n-        let m = Marker {\n-            pos: self.events.len() as u32,\n-        };\n-        self.event(Event::Start {\n-            kind: TOMBSTONE,\n-            forward_parent: None,\n-        });\n-        m\n-    }\n-\n-    pub(crate) fn error<'p, T: Into<String>>(&'p mut self, msg: T) -> ErrorBuilder<'p, 't> {\n-        ErrorBuilder::new(self, msg.into())\n-    }\n-\n-    pub(crate) fn bump(&mut self) {\n-        let kind = self.current();\n-        if kind == EOF {\n-            return;\n-        }\n-        self.pos += 1;\n-        self.event(Event::Token {\n-            kind,\n-            n_raw_tokens: 1,\n-        });\n-    }\n-\n-    pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n-        if self.current() == EOF {\n-            // TODO: panic!?\n-            return;\n-        }\n-        self.pos += 1;\n-        self.event(Event::Token {\n-            kind,\n-            n_raw_tokens: 1,\n-        });\n-    }\n-\n-    pub(crate) fn nth(&self, n: u32) -> SyntaxKind {\n-        self.inp.kind(self.pos + n)\n-    }\n-\n-    pub(crate) fn at_kw(&self, t: &str) -> bool {\n-        self.inp.text(self.pos) == t\n-    }\n-\n-    pub(crate) fn current(&self) -> SyntaxKind {\n-        self.nth(0)\n-    }\n-\n-    fn event(&mut self, event: Event) {\n-        self.events.push(event)\n-    }\n-}\n-\n-pub(crate) struct ErrorBuilder<'p, 't: 'p> {\n-    message: String,\n-    parser: &'p mut Parser<'t>,\n-}\n-\n-impl<'p, 't: 'p> Drop for ErrorBuilder<'p, 't> {\n-    fn drop(&mut self) {\n-        let message = ::std::mem::replace(&mut self.message, String::new());\n-        self.parser.event(Event::Error { message });\n-    }\n-}\n-\n-impl<'t, 'p> ErrorBuilder<'p, 't> {\n-    fn new(parser: &'p mut Parser<'t>, message: String) -> Self {\n-        ErrorBuilder { message, parser }\n-    }\n-}"}, {"sha": "2b16e11b93f45a9b5c73b8dfde7be490e43b1a4b", "filename": "src/parser/parser/imp.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fparser%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fparser%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fimp.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -0,0 +1,118 @@\n+use parser::input::{ParserInput, InputPosition};\n+use parser::event::Event;\n+\n+use SyntaxKind;\n+use syntax_kinds::{TOMBSTONE, EOF};\n+\n+pub(crate) struct ParserImpl<'t> {\n+    inp: &'t ParserInput<'t>,\n+\n+    pos: InputPosition,\n+    events: Vec<Event>,\n+}\n+\n+impl<'t> ParserImpl<'t> {\n+    pub(crate) fn new(inp: &'t ParserInput<'t>) -> ParserImpl<'t> {\n+        ParserImpl {\n+            inp,\n+\n+            pos: InputPosition::new(),\n+            events: Vec::new(),\n+        }\n+    }\n+\n+    pub(crate) fn into_events(self) -> Vec<Event> {\n+        assert_eq!(self.nth(0), EOF);\n+        self.events\n+    }\n+\n+\n+    pub(super) fn nth(&self, n: u32) -> SyntaxKind {\n+        self.inp.kind(self.pos + n)\n+    }\n+\n+    pub(super) fn at_kw(&self, t: &str) -> bool {\n+        self.inp.text(self.pos) == t\n+    }\n+\n+    pub(super) fn start(&mut self) -> u32 {\n+        let pos = self.events.len() as u32;\n+        self.event(Event::Start {\n+            kind: TOMBSTONE,\n+            forward_parent: None,\n+        });\n+        pos\n+    }\n+\n+    pub(super) fn bump(&mut self) {\n+        let kind = self.nth(0);\n+        if kind == EOF {\n+            return;\n+        }\n+        self.do_bump(kind);\n+    }\n+\n+    pub(super) fn bump_remap(&mut self, kind: SyntaxKind) {\n+        if self.nth(0) == EOF {\n+            // TODO: panic!?\n+            return;\n+        }\n+        self.do_bump(kind);\n+    }\n+\n+    fn do_bump(&mut self, kind: SyntaxKind) {\n+        self.pos += 1;\n+        self.event(Event::Token {\n+            kind,\n+            n_raw_tokens: 1,\n+        });\n+    }\n+\n+    pub(super) fn error(&mut self, msg: String) {\n+        self.event(Event::Error { msg })\n+    }\n+\n+    pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n+        match self.events[pos as usize] {\n+            Event::Start {\n+                kind: ref mut slot, ..\n+            } => {\n+                *slot = kind;\n+            }\n+            _ => unreachable!(),\n+        }\n+        self.event(Event::Finish);\n+    }\n+\n+    pub(super) fn abandon(&mut self, pos: u32) {\n+        let idx = pos as usize;\n+        if idx == self.events.len() - 1 {\n+            match self.events.pop() {\n+                Some(Event::Start {\n+                         kind: TOMBSTONE,\n+                         forward_parent: None,\n+                     }) => (),\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    pub(super) fn precede(&mut self, pos: u32) -> u32 {\n+        let new_pos = self.start();\n+        match self.events[pos as usize] {\n+            Event::Start {\n+                ref mut forward_parent,\n+                ..\n+            } => {\n+                *forward_parent = Some(new_pos - pos);\n+            }\n+            _ => unreachable!(),\n+        }\n+        new_pos\n+    }\n+\n+\n+    fn event(&mut self, event: Event) {\n+        self.events.push(event)\n+    }\n+}"}, {"sha": "c8db20918172874d61050b6f6f9a0bb2570b76a8", "filename": "src/parser/parser/mod.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fmod.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -0,0 +1,100 @@\n+use SyntaxKind;\n+use syntax_kinds::ERROR;\n+\n+pub(super) mod imp;\n+use self::imp::ParserImpl;\n+\n+pub(crate) struct Parser<'t>(pub(super) ParserImpl<'t>);\n+\n+\n+impl<'t> Parser<'t> {\n+    pub(crate) fn current(&self) -> SyntaxKind {\n+        self.nth(0)\n+    }\n+\n+    pub(crate) fn nth(&self, n: u32) -> SyntaxKind {\n+        self.0.nth(n)\n+    }\n+\n+    pub(crate) fn at(&self, kind: SyntaxKind) -> bool {\n+        self.current() == kind\n+    }\n+\n+    pub(crate) fn at_kw(&self, t: &str) -> bool {\n+        self.0.at_kw(t)\n+    }\n+\n+    pub(crate) fn start(&mut self) -> Marker {\n+        Marker(self.0.start())\n+    }\n+\n+    pub(crate) fn bump(&mut self) {\n+        self.0.bump();\n+    }\n+\n+    pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n+        self.0.bump_remap(kind);\n+    }\n+\n+    pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n+        self.0.error(message.into())\n+    }\n+\n+    pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n+        if self.at(kind) {\n+            self.bump();\n+            return true;\n+        }\n+        self.error(format!(\"expected {:?}\", kind));\n+        false\n+    }\n+\n+    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n+        if !self.at(kind) {\n+            return false;\n+        }\n+        self.bump();\n+        true\n+    }\n+\n+    pub(crate) fn err_and_bump(&mut self, message: &str) {\n+        let m = self.start();\n+        self.error(message);\n+        self.bump();\n+        m.complete(self, ERROR);\n+    }\n+}\n+\n+pub(crate) struct Marker(u32);\n+\n+impl Marker {\n+    pub(crate) fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n+        let pos = self.0;\n+        ::std::mem::forget(self);\n+        p.0.complete(pos, kind);\n+        CompletedMarker(pos)\n+    }\n+\n+    pub(crate) fn abandon(self, p: &mut Parser) {\n+        let pos = self.0;\n+        ::std::mem::forget(self);\n+        p.0.abandon(pos);\n+    }\n+}\n+\n+impl Drop for Marker {\n+    fn drop(&mut self) {\n+        if !::std::thread::panicking() {\n+            panic!(\"Marker must be either completed or abandoned\");\n+        }\n+    }\n+}\n+\n+\n+pub(crate) struct CompletedMarker(u32);\n+\n+impl CompletedMarker {\n+    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n+        Marker(p.0.precede(self.0))\n+    }\n+}"}, {"sha": "82558fa2e759d542485b972ddeab9e9bd6bdc3cd", "filename": "src/parser/token_set.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Fparser%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Ftoken_set.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -0,0 +1,25 @@\n+use SyntaxKind;\n+\n+pub(crate) struct TokenSet {\n+    pub tokens: &'static [SyntaxKind],\n+}\n+\n+impl TokenSet {\n+    pub fn contains(&self, kind: SyntaxKind) -> bool {\n+        self.tokens.contains(&kind)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! token_set {\n+    ($($t:ident),*) => {\n+        TokenSet {\n+            tokens: &[$($t),*],\n+        }\n+    };\n+\n+    ($($t:ident),* ,) => {\n+        token_set!($($t),*)\n+    };\n+}\n+"}, {"sha": "f831676c739ccf2fcb9007bed1a3ef102e689378", "filename": "src/tree/file_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Ftree%2Ffile_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e2c0564783aa91f6440e7cadcc1a4dfda785de0/src%2Ftree%2Ffile_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Ffile_builder.rs?ref=9e2c0564783aa91f6440e7cadcc1a4dfda785de0", "patch": "@@ -70,7 +70,7 @@ impl Sink for FileBuilder {\n         let &(node, after_child) = self.in_progress.last().unwrap();\n         self.errors.push(SyntaxErrorData {\n             node,\n-            message: err.message,\n+            message: err.msg,\n             after_child,\n         })\n     }\n@@ -157,5 +157,5 @@ fn grow(left: &mut TextRange, right: TextRange) {\n \n #[derive(Default)]\n pub(crate) struct ErrorMsg {\n-    pub(crate) message: String,\n+    pub(crate) msg: String,\n }"}]}