{"sha": "af2e03998d4d06f2781ca72ec005f6913148f8bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMmUwMzk5OGQ0ZDA2ZjI3ODFjYTcyZWMwMDVmNjkxMzE0OGY4YmI=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-05T20:06:24Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-08T21:13:41Z"}, "message": "Enabled workstealing in the scheduler. Previously we had one global work queue shared by each scheduler. Now there is a separate work queue for each scheduler, and work is \"stolen\" from other queues when it is exhausted locally.", "tree": {"sha": "fc65de2220eb4735ef6fdf554b5c7204ec41d6b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc65de2220eb4735ef6fdf554b5c7204ec41d6b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af2e03998d4d06f2781ca72ec005f6913148f8bb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af2e03998d4d06f2781ca72ec005f6913148f8bb", "html_url": "https://github.com/rust-lang/rust/commit/af2e03998d4d06f2781ca72ec005f6913148f8bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af2e03998d4d06f2781ca72ec005f6913148f8bb/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0080f4e07891c89aa1f9851f8b0a3c754734fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0080f4e07891c89aa1f9851f8b0a3c754734fe8", "html_url": "https://github.com/rust-lang/rust/commit/a0080f4e07891c89aa1f9851f8b0a3c754734fe8"}], "stats": {"total": 391, "additions": 328, "deletions": 63}, "files": [{"sha": "33b4b307af846b3c393105f78ea80c5d4ace1016", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -225,9 +225,10 @@ impl<T> Select for PortOne<T> {\n     fn optimistic_check(&mut self) -> bool {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n-        use rand::{Rand, rng};\n-        let mut rng = rng();\n-        let actually_check = Rand::rand(&mut rng);\n+        use rand::{Rand};\n+        let actually_check = do Local::borrow::<Scheduler, bool> |sched| {\n+            Rand::rand(&mut sched.rng)\n+        };\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {"}, {"sha": "01a52892f633b95eb71484d218fbf18f43dab314", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -63,8 +63,7 @@ Several modules in `core` are clients of `rt`:\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use iter::Times;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, range};\n use option::{Some, None};\n use ptr::RawPtr;\n use rt::local::Local;\n@@ -247,24 +246,32 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     let main = Cell::new(main);\n \n-    // The shared list of sleeping schedulers. Schedulers wake each other\n-    // occassionally to do new work.\n+    // The shared list of sleeping schedulers.\n     let sleepers = SleeperList::new();\n-    // The shared work queue. Temporary until work stealing is implemented.\n-    let work_queue = WorkQueue::new();\n+\n+    // Create a work queue for each scheduler, ntimes. Create an extra\n+    // for the main thread if that flag is set. We won't steal from it.\n+    let mut work_queues = ~[];\n+    for _ in range(0u, nscheds) {\n+        let work_queue: WorkQueue<~Task> = WorkQueue::new();\n+        work_queues.push(work_queue);\n+    }\n \n     // The schedulers.\n     let mut scheds = ~[];\n     // Handles to the schedulers. When the main task ends these will be\n     // sent the Shutdown message to terminate the schedulers.\n     let mut handles = ~[];\n \n-    do nscheds.times {\n+    for i in range(0u, nscheds) {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n-        let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n+        let mut sched = ~Scheduler::new(loop_,\n+                                        work_queues[i].clone(),\n+                                        work_queues.clone(),\n+                                        sleepers.clone());\n         let handle = sched.make_handle();\n \n         scheds.push(sched);\n@@ -280,9 +287,14 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         let friend_handle = friend_sched.make_handle();\n         scheds.push(friend_sched);\n \n+        // This scheduler needs a queue that isn't part of the stealee\n+        // set.\n+        let work_queue = WorkQueue::new();\n+\n         let main_loop = ~UvEventLoop::new();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n-                                                     work_queue.clone(),\n+                                                     work_queue,\n+                                                     work_queues.clone(),\n                                                      sleepers.clone(),\n                                                      false,\n                                                      Some(friend_handle));\n@@ -371,7 +383,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool, None,\n                                                   home, main.take());\n         main_task.death.on_exit = Some(on_exit.take());\n-        rtdebug!(\"boostrapping main_task\");\n+        rtdebug!(\"bootstrapping main_task\");\n \n         main_sched.bootstrap(main_task);\n     }"}, {"sha": "ce4e64c47d2ef5cb3faefd7cd5ead4bf9400d9e3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 114, "deletions": 45, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -13,7 +13,6 @@ use option::{Option, Some, None};\n use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n use unstable::raw;\n-\n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n use super::stack::{StackPool};\n@@ -28,6 +27,9 @@ use rt::rtio::RemoteCallback;\n use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n use cell::Cell;\n+use rand::{XorShiftRng, RngUtil};\n+use iterator::{range};\n+use vec::{OwnedVector};\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -37,9 +39,11 @@ use cell::Cell;\n /// XXX: This creates too many callbacks to run_sched_once, resulting\n /// in too much allocation and too many events.\n pub struct Scheduler {\n-    /// A queue of available work. Under a work-stealing policy there\n-    /// is one per Scheduler.\n-    work_queue: WorkQueue<~Task>,\n+    /// There are N work queues, one per scheduler.\n+    priv work_queue: WorkQueue<~Task>,\n+    /// Work queues for the other schedulers. These are created by\n+    /// cloning the core work queues.\n+    work_queues: ~[WorkQueue<~Task>],\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n@@ -70,7 +74,10 @@ pub struct Scheduler {\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n-    friend_handle: Option<SchedHandle>\n+    friend_handle: Option<SchedHandle>,\n+    /// A fast XorShift rng for scheduler use\n+    rng: XorShiftRng\n+\n }\n \n pub struct SchedHandle {\n@@ -97,17 +104,21 @@ impl Scheduler {\n \n     pub fn new(event_loop: ~EventLoopObject,\n                work_queue: WorkQueue<~Task>,\n+               work_queues: ~[WorkQueue<~Task>],\n                sleeper_list: SleeperList)\n         -> Scheduler {\n \n-        Scheduler::new_special(event_loop, work_queue, sleeper_list, true, None)\n+        Scheduler::new_special(event_loop, work_queue,\n+                               work_queues,\n+                               sleeper_list, true, None)\n \n     }\n \n     // When you create a scheduler it isn't yet \"in\" a task, so the\n     // task field is None.\n     pub fn new_special(event_loop: ~EventLoopObject,\n                        work_queue: WorkQueue<~Task>,\n+                       work_queues: ~[WorkQueue<~Task>],\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>)\n@@ -120,12 +131,14 @@ impl Scheduler {\n             no_sleep: false,\n             event_loop: event_loop,\n             work_queue: work_queue,\n+            work_queues: work_queues,\n             stack_pool: StackPool::new(),\n             sched_task: None,\n             cleanup_job: None,\n             metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n-            friend_handle: friend\n+            friend_handle: friend,\n+            rng: XorShiftRng::new()\n         }\n     }\n \n@@ -248,7 +261,7 @@ impl Scheduler {\n \n         // Second activity is to try resuming a task from the queue.\n \n-        let result = sched.resume_task_from_queue();\n+        let result = sched.do_work();\n         let mut sched = match result {\n             Some(sched) => {\n                 // Failed to dequeue a task, so we return.\n@@ -415,47 +428,98 @@ impl Scheduler {\n         }\n     }\n \n-    // Resume a task from the queue - but also take into account that\n-    // it might not belong here.\n+    // Workstealing: In this iteration of the runtime each scheduler\n+    // thread has a distinct work queue. When no work is available\n+    // locally, make a few attempts to steal work from the queues of\n+    // other scheduler threads. If a few steals fail we end up in the\n+    // old \"no work\" path which is fine.\n+\n+    // First step in the process is to find a task. This function does\n+    // that by first checking the local queue, and if there is no work\n+    // there, trying to steal from the remote work queues.\n+    fn find_work(&mut self) -> Option<~Task> {\n+        rtdebug!(\"scheduler looking for work\");\n+        match self.work_queue.pop() {\n+            Some(task) => {\n+                rtdebug!(\"found a task locally\");\n+                return Some(task)\n+            }\n+            None => {\n+                // Our naive stealing, try kinda hard.\n+                rtdebug!(\"scheduler trying to steal\");\n+                let _len = self.work_queues.len();\n+                return self.try_steals(2);\n+            }\n+        }\n+    }\n+\n+    // With no backoff try stealing n times from the queues the\n+    // scheduler knows about. This naive implementation can steal from\n+    // our own queue or from other special schedulers.\n+    fn try_steals(&mut self, n: uint) -> Option<~Task> {\n+        for _ in range(0, n) {\n+            let index = self.rng.gen_uint_range(0, self.work_queues.len());\n+            let work_queues = &mut self.work_queues;\n+            match work_queues[index].steal() {\n+                Some(task) => {\n+                    rtdebug!(\"found task by stealing\"); return Some(task)\n+                }\n+                None => ()\n+            }\n+        };\n+        rtdebug!(\"giving up on stealing\");\n+        return None;\n+    }\n \n-    // If we perform a scheduler action we give away the scheduler ~\n-    // pointer, if it is still available we return it.\n+    // Given a task, execute it correctly.\n+    fn process_task(~self, task: ~Task) -> Option<~Scheduler> {\n+        let mut this = self;\n+        let mut task = task;\n \n-    fn resume_task_from_queue(~self) -> Option<~Scheduler> {\n+        rtdebug!(\"processing a task\");\n \n+        let home = task.take_unwrap_home();\n+        match home {\n+            Sched(home_handle) => {\n+                if home_handle.sched_id != this.sched_id() {\n+                    rtdebug!(\"sending task home\");\n+                    task.give_home(Sched(home_handle));\n+                    Scheduler::send_task_home(task);\n+                    return Some(this);\n+                } else {\n+                    rtdebug!(\"running task here\");\n+                    task.give_home(Sched(home_handle));\n+                    this.resume_task_immediately(task);\n+                    return None;\n+                }\n+            }\n+            AnySched if this.run_anything => {\n+                rtdebug!(\"running anysched task here\");\n+                task.give_home(AnySched);\n+                this.resume_task_immediately(task);\n+                return None;\n+            }\n+            AnySched => {\n+                rtdebug!(\"sending task to friend\");\n+                task.give_home(AnySched);\n+                this.send_to_friend(task);\n+                return Some(this);\n+            }\n+        }\n+    }\n+\n+    // Bundle the helpers together.\n+    fn do_work(~self) -> Option<~Scheduler> {\n         let mut this = self;\n \n-        match this.work_queue.pop() {\n+        rtdebug!(\"scheduler calling do work\");\n+        match this.find_work() {\n             Some(task) => {\n-                let mut task = task;\n-                let home = task.take_unwrap_home();\n-                match home {\n-                    Sched(home_handle) => {\n-                        if home_handle.sched_id != this.sched_id() {\n-                            task.give_home(Sched(home_handle));\n-                            Scheduler::send_task_home(task);\n-                            return Some(this);\n-                        } else {\n-                            this.event_loop.callback(Scheduler::run_sched_once);\n-                            task.give_home(Sched(home_handle));\n-                            this.resume_task_immediately(task);\n-                            return None;\n-                        }\n-                    }\n-                    AnySched if this.run_anything => {\n-                        this.event_loop.callback(Scheduler::run_sched_once);\n-                        task.give_home(AnySched);\n-                        this.resume_task_immediately(task);\n-                        return None;\n-                    }\n-                    AnySched => {\n-                        task.give_home(AnySched);\n-                        this.send_to_friend(task);\n-                        return Some(this);\n-                    }\n-                }\n+                rtdebug!(\"found some work! processing the task\");\n+                return this.process_task(task);\n             }\n             None => {\n+                rtdebug!(\"no work was found, returning the scheduler struct\");\n                 return Some(this);\n             }\n         }\n@@ -711,7 +775,6 @@ impl Scheduler {\n             GiveTask(task, f) => f.to_fn()(self, task)\n         }\n     }\n-\n }\n \n // The cases for the below function.\n@@ -745,6 +808,8 @@ impl ClosureConverter for UnsafeTaskReceiver {\n \n #[cfg(test)]\n mod test {\n+    extern mod extra;\n+\n     use prelude::*;\n     use rt::test::*;\n     use unstable::run_in_bare_thread;\n@@ -862,12 +927,15 @@ mod test {\n         do run_in_bare_thread {\n \n             let sleepers = SleeperList::new();\n-            let work_queue = WorkQueue::new();\n+            let normal_queue = WorkQueue::new();\n+            let special_queue = WorkQueue::new();\n+            let queues = ~[normal_queue.clone(), special_queue.clone()];\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n                 ~UvEventLoop::new(),\n-                work_queue.clone(),\n+                normal_queue,\n+                queues.clone(),\n                 sleepers.clone());\n \n             let normal_handle = Cell::new(normal_sched.make_handle());\n@@ -877,7 +945,8 @@ mod test {\n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n                 ~UvEventLoop::new(),\n-                work_queue.clone(),\n+                special_queue.clone(),\n+                queues.clone(),\n                 sleepers.clone(),\n                 false,\n                 Some(friend_handle));"}, {"sha": "07f8ca77d9db4664115baea2cc6f137aad914747", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -182,6 +182,7 @@ mod test {\n     fn select_stream() {\n         use util;\n         use comm::GenericChan;\n+        use iter::Times;\n \n         // Sends 10 buffered packets, and uses select to retrieve them all.\n         // Puts the port in a different spot in the vector each time.\n@@ -265,6 +266,7 @@ mod test {\n \n         fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n             use rt::test::spawntask_random;\n+            use iter::Times;\n \n             do run_in_newsched_task {\n                 // A bit of stress, since ordinarily this is just smoke and mirrors."}, {"sha": "92366d5187fe23cae6bc7aa3126d2bda464af8e5", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -15,8 +15,8 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iterator::{Iterator, range};\n-use vec::{OwnedVector, MutableVector};\n use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use vec::{OwnedVector, MutableVector, ImmutableVector};\n use rt::sched::Scheduler;\n use unstable::run_in_bare_thread;\n use rt::thread::Thread;\n@@ -29,8 +29,12 @@ use result::{Result, Ok, Err};\n \n pub fn new_test_uv_sched() -> Scheduler {\n \n+    let queue = WorkQueue::new();\n+    let queues = ~[queue.clone()];\n+\n     let mut sched = Scheduler::new(~UvEventLoop::new(),\n-                                   WorkQueue::new(),\n+                                   queue,\n+                                   queues,\n                                    SleeperList::new());\n \n     // Don't wait for the Shutdown message\n@@ -164,15 +168,21 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         };\n \n         let sleepers = SleeperList::new();\n-        let work_queue = WorkQueue::new();\n \n         let mut handles = ~[];\n         let mut scheds = ~[];\n+        let mut work_queues = ~[];\n \n         for _ in range(0u, nthreads) {\n+            let work_queue = WorkQueue::new();\n+            work_queues.push(work_queue);\n+        }\n+\n+        for i in range(0u, nthreads) {\n             let loop_ = ~UvEventLoop::new();\n             let mut sched = ~Scheduler::new(loop_,\n-                                            work_queue.clone(),\n+                                            work_queues[i].clone(),\n+                                            work_queues.clone(),\n                                             sleepers.clone());\n             let handle = sched.make_handle();\n "}, {"sha": "05a17f8539c216b93dce541651ceffa47b62cbb8", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -98,6 +98,7 @@ use rt::kill::KillHandle;\n use rt::sched::Scheduler;\n use rt::uv::uvio::UvEventLoop;\n use rt::thread::Thread;\n+use rt::work_queue::WorkQueue;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -722,10 +723,16 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n             let sched = Local::unsafe_borrow::<Scheduler>();\n             let sched_handle = (*sched).make_handle();\n \n+            // Since this is a 1:1 scheduler we create a queue not in\n+            // the stealee set. The run_anything flag is set false\n+            // which will disable stealing.\n+            let work_queue = WorkQueue::new();\n+\n             // Create a new scheduler to hold the new task\n             let new_loop = ~UvEventLoop::new();\n             let mut new_sched = ~Scheduler::new_special(new_loop,\n-                                                        (*sched).work_queue.clone(),\n+                                                        work_queue,\n+                                                        (*sched).work_queues.clone(),\n                                                         (*sched).sleeper_list.clone(),\n                                                         false,\n                                                         Some(sched_handle));"}, {"sha": "3d38d61bc2eb6b6337705efd6396f6c8b4f31cfc", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+use std::rt::test::spawntask_later;\n+use std::cell::Cell;\n+\n+// This is a simple bench that creates M pairs of of tasks. These\n+// tasks ping-pong back and forth over a pair of streams. This is a\n+// cannonical message-passing benchmark as it heavily strains message\n+// passing and almost nothing else.\n+\n+fn ping_pong_bench(n: uint, m: uint) {\n+\n+    // Create pairs of tasks that pingpong back and forth.\n+    fn run_pair(n: uint) {\n+            // Create a stream A->B\n+            let (pa,ca) = stream::<()>();\n+            // Create a stream B->A\n+            let (pb,cb) = stream::<()>();\n+\n+            let pa = Cell::new(pa);\n+            let ca = Cell::new(ca);\n+            let pb = Cell::new(pb);\n+            let cb = Cell::new(cb);\n+\n+        do spawntask_later() || {\n+            let chan = ca.take();\n+            let port = pb.take();\n+            do n.times {\n+                chan.send(());\n+                port.recv();\n+            }\n+        }\n+\n+        do spawntask_later() || {\n+            let chan = cb.take();\n+            let port = pa.take();\n+            do n.times {\n+                port.recv();\n+                chan.send(());\n+            }\n+        }\n+    }\n+\n+    do m.times {\n+        run_pair(n)\n+    }\n+\n+}\n+\n+\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 3 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        10000\n+    };\n+\n+    let m = if args.len() == 3 {\n+        uint::from_str(args[2]).unwrap()\n+    } else {\n+        4\n+    };\n+\n+    ping_pong_bench(n, m);\n+\n+}"}, {"sha": "6669342f511a83944454c67cf5c942dcb9a4d970", "filename": "src/test/bench/rt-parfib.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+use std::rt::test::spawntask_later;\n+use std::cell::Cell;\n+use std::comm::*;\n+\n+// A simple implementation of parfib. One subtree is found in a new\n+// task and communicated over a oneshot pipe, the other is found\n+// locally. There is no sequential-mode threshold.\n+\n+fn parfib(n: uint) -> uint {\n+    if(n == 0 || n == 1) {\n+        return 1;\n+    }\n+\n+    let (port,chan) = oneshot::<uint>();\n+    let chan = Cell::new(chan);\n+    do spawntask_later {\n+        chan.take().send(parfib(n-1));\n+    };\n+    let m2 = parfib(n-2);\n+    return (port.recv() + m2);\n+}\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 2 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        10\n+    };\n+\n+    parfib(n);\n+\n+}"}, {"sha": "ff578ed70b9c1c8c26d6c2da65a561176b1bb947", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2e03998d4d06f2781ca72ec005f6913148f8bb/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=af2e03998d4d06f2781ca72ec005f6913148f8bb", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+\n+// Very simple spawn rate test. Spawn N tasks that do nothing and\n+// return.\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 2 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        100000\n+    };\n+\n+    do n.times {\n+        do spawn || {};\n+    }\n+\n+}"}]}