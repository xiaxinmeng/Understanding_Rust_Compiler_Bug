{"sha": "5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "node_id": "C_kwDOAAsO6NoAKDVlYmI2YThmZDkzZWI1NTllYjhlMDBhNzk0N2ZiYzRhZDdlNjM1ODA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-09T09:56:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-09T09:56:00Z"}, "message": "Rollup merge of #89641 - asquared31415:asm-feature-attr-regs, r=oli-obk\n\nmake #[target_feature] work with `asm` register classes\n\nFixes #89289", "tree": {"sha": "e3ded26518dd7525d457220464c84b019eee3350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ded26518dd7525d457220464c84b019eee3350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYWcwCRBK7hj4Ov3rIwAAsY0IAFZUDQPZmigK2LFO139HdJ6V\nhm4GRbYurDjj44anyen+oMPWw5kAneqDTLHmpl5u2V+5Rcbrybxx1HSTEzk3uPUe\n8SNsldWEe8PuL1yqWTQnDepz3ialSEwUptD1+6agBSpZ8QrJCG7SDBCIMZXtxDbv\nD6o/+urG10PyzpEXe34urMjvrEeQkJGi28EDzQD/cnPK08l+yyFNaj/g4Xx+kCWV\nPro/cnw7cwX4TleIMrbg3gVlfDFNmipI3gARlfxqZFs4w+9LljsM64ELcQwAdN/4\nB+wPXJDzl7SeVzznJpXwJcMpMPbAMnky6HJ/qwc4ChKMg0EJ49Zb3/+fgje15AY=\n=8BHt\n-----END PGP SIGNATURE-----\n", "payload": "tree e3ded26518dd7525d457220464c84b019eee3350\nparent 9d14b6505b3cbe47826c8f4d62f67f0e5e474750\nparent 271da7d8bc9f0f5ca98cdfeb999872a7a0b6cf74\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1633773360 +0200\ncommitter GitHub <noreply@github.com> 1633773360 +0200\n\nRollup merge of #89641 - asquared31415:asm-feature-attr-regs, r=oli-obk\n\nmake #[target_feature] work with `asm` register classes\n\nFixes #89289\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "html_url": "https://github.com/rust-lang/rust/commit/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d14b6505b3cbe47826c8f4d62f67f0e5e474750", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d14b6505b3cbe47826c8f4d62f67f0e5e474750", "html_url": "https://github.com/rust-lang/rust/commit/9d14b6505b3cbe47826c8f4d62f67f0e5e474750"}, {"sha": "271da7d8bc9f0f5ca98cdfeb999872a7a0b6cf74", "url": "https://api.github.com/repos/rust-lang/rust/commits/271da7d8bc9f0f5ca98cdfeb999872a7a0b6cf74", "html_url": "https://github.com/rust-lang/rust/commit/271da7d8bc9f0f5ca98cdfeb999872a7a0b6cf74"}], "stats": {"total": 325, "additions": 213, "deletions": 112}, "files": [{"sha": "957b14f34872962eef8455fcbf1bc5ffa712993d", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -202,39 +202,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let mut used_input_regs = FxHashMap::default();\n         let mut used_output_regs = FxHashMap::default();\n-        let mut required_features: Vec<&str> = vec![];\n+\n         for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n             if let Some(reg) = op.reg() {\n-                // Make sure we don't accidentally carry features from the\n-                // previous iteration.\n-                required_features.clear();\n-\n                 let reg_class = reg.reg_class();\n                 if reg_class == asm::InlineAsmRegClass::Err {\n                     continue;\n                 }\n \n-                // We ignore target feature requirements for clobbers: if the\n-                // feature is disabled then the compiler doesn't care what we\n-                // do with the registers.\n-                //\n-                // Note that this is only possible for explicit register\n-                // operands, which cannot be used in the asm string.\n-                let is_clobber = matches!(\n-                    op,\n-                    hir::InlineAsmOperand::Out {\n-                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n-                        late: _,\n-                        expr: None\n-                    }\n-                );\n-\n                 // Some register classes can only be used as clobbers. This\n                 // means that we disallow passing a value in/out of the asm and\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap())\n-                    && !(is_clobber && matches!(reg, asm::InlineAsmRegOrRegClass::Reg(_)))\n+                    && !(op.is_clobber() && matches!(reg, asm::InlineAsmRegOrRegClass::Reg(_)))\n                 {\n                     let msg = format!(\n                         \"register class `{}` can only be used as a clobber, \\\n@@ -245,47 +226,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     continue;\n                 }\n \n-                if !is_clobber {\n-                    // Validate register classes against currently enabled target\n-                    // features. We check that at least one type is available for\n-                    // the current target.\n-                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                        if let Some(feature) = feature {\n-                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n-                                required_features.clear();\n-                                break;\n-                            } else {\n-                                required_features.push(feature);\n-                            }\n-                        } else {\n-                            required_features.clear();\n-                            break;\n-                        }\n-                    }\n-                    // We are sorting primitive strs here and can use unstable sort here\n-                    required_features.sort_unstable();\n-                    required_features.dedup();\n-                    match &required_features[..] {\n-                        [] => {}\n-                        [feature] => {\n-                            let msg = format!(\n-                                \"register class `{}` requires the `{}` target feature\",\n-                                reg_class.name(),\n-                                feature\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                        features => {\n-                            let msg = format!(\n-                                \"register class `{}` requires at least one target feature: {}\",\n-                                reg_class.name(),\n-                                features.join(\", \")\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                    }\n-                }\n-\n                 // Check for conflicts between explicit register operands.\n                 if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n                     let (input, output) = match op {"}, {"sha": "5264f7cc326128edea67e2d149ae524971589288", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -2293,6 +2293,13 @@ impl<'hir> InlineAsmOperand<'hir> {\n             Self::Const { .. } | Self::Sym { .. } => None,\n         }\n     }\n+\n+    pub fn is_clobber(&self) -> bool {\n+        matches!(\n+            self,\n+            InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(_), late: _, expr: None }\n+        )\n+    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "008b856ebf2fab873801412b4aa325000afff27b", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -141,6 +141,7 @@ impl ExprVisitor<'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+        target_features: &[Symbol],\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n@@ -283,17 +284,20 @@ impl ExprVisitor<'tcx> {\n         };\n \n         // Check whether the selected type requires a target feature. Note that\n-        // this is different from the feature check we did earlier in AST\n-        // lowering. While AST lowering checked that this register class is\n-        // usable at all with the currently enabled features, some types may\n-        // only be usable with a register class when a certain feature is\n-        // enabled. We check this here since it depends on the results of typeck.\n+        // this is different from the feature check we did earlier. While the\n+        // previous check checked that this register class is usable at all\n+        // with the currently enabled features, some types may only be usable\n+        // with a register class when a certain feature is enabled. We check\n+        // this here since it depends on the results of typeck.\n         //\n         // Also note that this check isn't run when the operand type is never\n-        // (!). In that case we still need the earlier check in AST lowering to\n-        // verify that the register class is usable at all.\n+        // (!). In that case we still need the earlier check to verify that the\n+        // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !self.tcx.sess.target_features.contains(&Symbol::intern(feature)) {\n+            let feat_sym = Symbol::intern(feature);\n+            if !self.tcx.sess.target_features.contains(&feat_sym)\n+                && !target_features.contains(&feat_sym)\n+            {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!(\n@@ -349,23 +353,122 @@ impl ExprVisitor<'tcx> {\n         Some(asm_ty)\n     }\n \n-    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>) {\n-        for (idx, (op, _)) in asm.operands.iter().enumerate() {\n+    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, hir_id: hir::HirId) {\n+        let hir = self.tcx.hir();\n+        let enclosing_id = hir.enclosing_body_owner(hir_id);\n+        let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n+        let attrs = self.tcx.codegen_fn_attrs(enclosing_def_id);\n+        for (idx, (op, op_sp)) in asm.operands.iter().enumerate() {\n+            // Validate register classes against currently enabled target\n+            // features. We check that at least one type is available for\n+            // the enabled features.\n+            //\n+            // We ignore target feature requirements for clobbers: if the\n+            // feature is disabled then the compiler doesn't care what we\n+            // do with the registers.\n+            //\n+            // Note that this is only possible for explicit register\n+            // operands, which cannot be used in the asm string.\n+            if let Some(reg) = op.reg() {\n+                if !op.is_clobber() {\n+                    let mut missing_required_features = vec![];\n+                    let reg_class = reg.reg_class();\n+                    for &(_, feature) in reg_class.supported_types(self.tcx.sess.asm_arch.unwrap())\n+                    {\n+                        match feature {\n+                            Some(feature) => {\n+                                let feat_sym = Symbol::intern(feature);\n+                                if self.tcx.sess.target_features.contains(&feat_sym)\n+                                    || attrs.target_features.contains(&feat_sym)\n+                                {\n+                                    missing_required_features.clear();\n+                                    break;\n+                                } else {\n+                                    missing_required_features.push(feature);\n+                                }\n+                            }\n+                            None => {\n+                                missing_required_features.clear();\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    missing_required_features.sort_unstable();\n+                    missing_required_features.dedup();\n+                    match &missing_required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            // register isn't enabled, don't do more checks\n+                            continue;\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one of the following target features: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            // register isn't enabled, don't do more checks\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+\n             match *op {\n                 hir::InlineAsmOperand::In { reg, ref expr } => {\n-                    self.check_asm_operand_type(idx, reg, expr, asm.template, true, None);\n+                    self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        expr,\n+                        asm.template,\n+                        true,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                 }\n                 hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n                     if let Some(expr) = expr {\n-                        self.check_asm_operand_type(idx, reg, expr, asm.template, false, None);\n+                        self.check_asm_operand_type(\n+                            idx,\n+                            reg,\n+                            expr,\n+                            asm.template,\n+                            false,\n+                            None,\n+                            &attrs.target_features,\n+                        );\n                     }\n                 }\n                 hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n-                    self.check_asm_operand_type(idx, reg, expr, asm.template, false, None);\n+                    self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        expr,\n+                        asm.template,\n+                        false,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n-                    let in_ty =\n-                        self.check_asm_operand_type(idx, reg, in_expr, asm.template, true, None);\n+                    let in_ty = self.check_asm_operand_type(\n+                        idx,\n+                        reg,\n+                        in_expr,\n+                        asm.template,\n+                        true,\n+                        None,\n+                        &attrs.target_features,\n+                    );\n                     if let Some(out_expr) = out_expr {\n                         self.check_asm_operand_type(\n                             idx,\n@@ -374,6 +477,7 @@ impl ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             Some((in_expr, in_ty)),\n+                            &attrs.target_features,\n                         );\n                     }\n                 }\n@@ -422,7 +526,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm),\n+            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm, expr.hir_id),\n \n             _ => {}\n         }"}, {"sha": "91d0f8c33f9793c58a0d8b37e6e20f7c3a321036", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -21,10 +21,6 @@ fn main() {\n         //~^ ERROR asm template modifiers are not allowed for `const` arguments\n         asm!(\"{:a}\", sym main);\n         //~^ ERROR asm template modifiers are not allowed for `sym` arguments\n-        asm!(\"{}\", in(zmm_reg) foo);\n-        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n-        asm!(\"\", in(\"zmm0\") foo);\n-        //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n         asm!(\"\", in(\"ebp\") foo);\n         //~^ ERROR invalid register `ebp`: the frame pointer cannot be used as an operand\n         asm!(\"\", in(\"rsp\") foo);"}, {"sha": "102a17e981570d4fe857639cbfb50742dc228288", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -46,127 +46,115 @@ LL |         asm!(\"{:a}\", sym main);\n    |               |\n    |               template modifier\n \n-error: register class `zmm_reg` requires the `avx512f` target feature\n-  --> $DIR/bad-reg.rs:24:20\n-   |\n-LL |         asm!(\"{}\", in(zmm_reg) foo);\n-   |                    ^^^^^^^^^^^^^^^\n-\n-error: register class `zmm_reg` requires the `avx512f` target feature\n-  --> $DIR/bad-reg.rs:26:18\n-   |\n-LL |         asm!(\"\", in(\"zmm0\") foo);\n-   |                  ^^^^^^^^^^^^^^\n-\n error: invalid register `ebp`: the frame pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:28:18\n+  --> $DIR/bad-reg.rs:24:18\n    |\n LL |         asm!(\"\", in(\"ebp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `rsp`: the stack pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:30:18\n+  --> $DIR/bad-reg.rs:26:18\n    |\n LL |         asm!(\"\", in(\"rsp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `ip`: the instruction pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:32:18\n+  --> $DIR/bad-reg.rs:28:18\n    |\n LL |         asm!(\"\", in(\"ip\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: invalid register `k0`: the k0 AVX mask register cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:34:18\n+  --> $DIR/bad-reg.rs:30:18\n    |\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: invalid register `ah`: high byte registers cannot be used as an operand on x86_64\n-  --> $DIR/bad-reg.rs:36:18\n+  --> $DIR/bad-reg.rs:32:18\n    |\n LL |         asm!(\"\", in(\"ah\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:39:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:41:18\n+  --> $DIR/bad-reg.rs:37:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:45:20\n+  --> $DIR/bad-reg.rs:41:20\n    |\n LL |         asm!(\"{}\", in(x87_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:47:20\n+  --> $DIR/bad-reg.rs:43:20\n    |\n LL |         asm!(\"{}\", in(mmx_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:49:20\n+  --> $DIR/bad-reg.rs:45:20\n    |\n LL |         asm!(\"{}\", out(x87_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:51:20\n+  --> $DIR/bad-reg.rs:47:20\n    |\n LL |         asm!(\"{}\", out(mmx_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register `al` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:57:33\n+  --> $DIR/bad-reg.rs:53:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n    |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:59:33\n+  --> $DIR/bad-reg.rs:55:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:59:18\n+  --> $DIR/bad-reg.rs:55:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:62:34\n+  --> $DIR/bad-reg.rs:58:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:64:34\n+  --> $DIR/bad-reg.rs:60:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:64:18\n+  --> $DIR/bad-reg.rs:60:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "4f82cd8aab9d03ea768165993e85c93aa58a7a7d", "filename": "src/test/ui/asm/x86_64/target-feature-attr.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.rs?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -0,0 +1,40 @@\n+// only-x86_64\n+\n+#![feature(asm, avx512_target_feature)]\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn foo() {\n+    let mut x = 1;\n+    let y = 2;\n+    asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+    assert_eq!(x, 3);\n+}\n+\n+unsafe fn bar() {\n+    let mut x = 1;\n+    let y = 2;\n+    asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+    //~^ ERROR: register class `ymm_reg` requires the `avx` target feature\n+    //~| ERROR: register class `ymm_reg` requires the `avx` target feature\n+    //~| ERROR: register class `ymm_reg` requires the `avx` target feature\n+    assert_eq!(x, 3);\n+}\n+\n+#[target_feature(enable = \"avx512bw\")]\n+unsafe fn baz() {\n+    let x = 1;\n+    asm!(\"/* {0} */\", in(kreg) x);\n+}\n+\n+unsafe fn baz2() {\n+    let x = 1;\n+    asm!(\"/* {0} */\", in(kreg) x);\n+    //~^ ERROR: register class `kreg` requires at least one of the following target features: avx512bw, avx512f\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}, {"sha": "295c8a97ed3bc4607a03a7f3a6948f941df349a2", "filename": "src/test/ui/asm/x86_64/target-feature-attr.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Ftarget-feature-attr.stderr?ref=5ebb6a8fd93eb559eb8e00a7947fbc4ad7e63580", "patch": "@@ -0,0 +1,26 @@\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:40\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                        ^^^^^^^^^^^^^\n+\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:55\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                                       ^^^^^^^^^^^^^\n+\n+error: register class `ymm_reg` requires the `avx` target feature\n+  --> $DIR/target-feature-attr.rs:16:70\n+   |\n+LL |     asm!(\"vaddps {2:y}, {0:y}, {1:y}\", in(ymm_reg) x, in(ymm_reg) y, lateout(ymm_reg) x);\n+   |                                                                      ^^^^^^^^^^^^^^^^^^\n+\n+error: register class `kreg` requires at least one of the following target features: avx512bw, avx512f\n+  --> $DIR/target-feature-attr.rs:31:23\n+   |\n+LL |     asm!(\"/* {0} */\", in(kreg) x);\n+   |                       ^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}