{"sha": "4ae956f600e72d62a6b17d95705148442841cef0", "node_id": "C_kwDOAAsO6NoAKDRhZTk1NmY2MDBlNzJkNjJhNmIxN2Q5NTcwNTE0ODQ0Mjg0MWNlZjA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-05T03:16:41Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-05T03:20:38Z"}, "message": "Remove `ExtCtxt::expr_lit`.", "tree": {"sha": "b316d765e3ee169f8a3b7f48918a3ed723987b9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b316d765e3ee169f8a3b7f48918a3ed723987b9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ae956f600e72d62a6b17d95705148442841cef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae956f600e72d62a6b17d95705148442841cef0", "html_url": "https://github.com/rust-lang/rust/commit/4ae956f600e72d62a6b17d95705148442841cef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ae956f600e72d62a6b17d95705148442841cef0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d30472180855735929e42595aefb4344b4c8562", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d30472180855735929e42595aefb4344b4c8562", "html_url": "https://github.com/rust-lang/rust/commit/7d30472180855735929e42595aefb4344b4c8562"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "4cc4b6367b48b39a8fb44ef93026424155e9f30b", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ae956f600e72d62a6b17d95705148442841cef0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae956f600e72d62a6b17d95705148442841cef0/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=4ae956f600e72d62a6b17d95705148442841cef0", "patch": "@@ -8,6 +8,26 @@ use rustc_span::Span;\n use std::ascii;\n use std::str;\n \n+// Escapes a string, represented as a symbol. Reuses the original symbol,\n+// avoiding interning, if no changes are required.\n+pub fn escape_string_symbol(symbol: Symbol) -> Symbol {\n+    let s = symbol.as_str();\n+    let escaped = s.escape_default().to_string();\n+    if s == escaped { symbol } else { Symbol::intern(&escaped) }\n+}\n+\n+// Escapes a char.\n+pub fn escape_char_symbol(ch: char) -> Symbol {\n+    let s: String = ch.escape_default().map(Into::<char>::into).collect();\n+    Symbol::intern(&s)\n+}\n+\n+// Escapes a byte string.\n+pub fn escape_byte_str_symbol(bytes: &[u8]) -> Symbol {\n+    let s = bytes.escape_ascii().to_string();\n+    Symbol::intern(&s)\n+}\n+\n #[derive(Debug)]\n pub enum LitError {\n     LexerError,\n@@ -149,16 +169,11 @@ impl LitKind {\n     pub fn synthesize_token_lit(&self) -> token::Lit {\n         let (kind, symbol, suffix) = match *self {\n             LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n-                // Don't re-intern unless the escaped string is different.\n-                let s = symbol.as_str();\n-                let escaped = s.escape_default().to_string();\n-                let symbol = if s == escaped { symbol } else { Symbol::intern(&escaped) };\n-                (token::Str, symbol, None)\n+                (token::Str, escape_string_symbol(symbol), None)\n             }\n             LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n             LitKind::ByteStr(ref bytes, ast::StrStyle::Cooked) => {\n-                let string = bytes.escape_ascii().to_string();\n-                (token::ByteStr, Symbol::intern(&string), None)\n+                (token::ByteStr, escape_byte_str_symbol(bytes), None)\n             }\n             LitKind::ByteStr(ref bytes, ast::StrStyle::Raw(n)) => {\n                 // Unwrap because raw byte string literals can only contain ASCII.\n@@ -169,10 +184,7 @@ impl LitKind {\n                 let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n                 (token::Byte, Symbol::intern(&string), None)\n             }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                (token::Char, Symbol::intern(&string), None)\n-            }\n+            LitKind::Char(ch) => (token::Char, escape_char_symbol(ch), None),\n             LitKind::Int(n, ty) => {\n                 let suffix = match ty {\n                     ast::LitIntType::Unsigned(ty) => Some(ty.name()),"}, {"sha": "2fec24a1aece8c9262a4953215a5b228f3cce405", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4ae956f600e72d62a6b17d95705148442841cef0/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae956f600e72d62a6b17d95705148442841cef0/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=4ae956f600e72d62a6b17d95705148442841cef0", "patch": "@@ -1,8 +1,7 @@\n use crate::base::ExtCtxt;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, LocalKind, PatKind, UnOp};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -332,36 +331,36 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n-        let token_lit = lit_kind.synthesize_token_lit();\n-        self.expr(span, ast::ExprKind::Lit(token_lit))\n+    pub fn expr_usize(&self, span: Span, n: usize) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::Usize.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(\n-            span,\n-            ast::LitKind::Int(i as u128, ast::LitIntType::Unsigned(ast::UintTy::Usize)),\n-        )\n-    }\n-\n-    pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+    pub fn expr_u32(&self, span: Span, n: u32) -> P<ast::Expr> {\n+        let suffix = Some(ast::UintTy::U32.name());\n+        let lit = token::Lit::new(token::Integer, sym::integer(n), suffix);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Bool(value))\n+    pub fn expr_bool(&self, span: Span, value: bool) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Bool, if value { kw::True } else { kw::False }, None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n+    pub fn expr_str(&self, span: Span, s: Symbol) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Str, literal::escape_string_symbol(s), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_char(&self, sp: Span, ch: char) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Char(ch))\n+    pub fn expr_char(&self, span: Span, ch: char) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::Char, literal::escape_char_symbol(ch), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n-    pub fn expr_byte_str(&self, sp: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::ByteStr(Lrc::from(bytes), ast::StrStyle::Cooked))\n+    pub fn expr_byte_str(&self, span: Span, bytes: Vec<u8>) -> P<ast::Expr> {\n+        let lit = token::Lit::new(token::ByteStr, literal::escape_byte_str_symbol(&bytes), None);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n \n     /// `[expr1, expr2, ...]`"}]}