{"sha": "3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "node_id": "C_kwDOAAsO6NoAKDNjZTQ2Yjc0YWEzOTY4YjQ1OWNmZjNjZTVjMGQ0ZjEzZTIyMGIyMTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T00:34:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T00:34:02Z"}, "message": "Auto merge of #100668 - nnethercote:use-AttrVec-more, r=spastorino\n\nUse `AttrVec` more\n\nIn some places we use `Vec<Attribute>` and some places we use\n`ThinVec<Attribute>` (a.k.a. `AttrVec`). This results in various points\nwhere we have to convert between `Vec` and `ThinVec`.\n\nThis commit changes the places that use `Vec<Attribute>` to use\n`AttrVec`. A lot of this is mechanical and boring, but there are\nsome interesting parts:\n- It adds a few new methods to `ThinVec`.\n- It implements `MapInPlace` for `ThinVec`, and introduces a macro to\n  avoid the repetition of this trait for `Vec`, `SmallVec`, and\n  `ThinVec`.\n\nOverall, it makes the code a little nicer, and has little effect on\nperformance. But it is a precursor to removing\n`rustc_data_structures::ThinVec` and replacing it with\n`thin_vec::ThinVec`, which is implemented more efficiently.\n\nr? `@spastorino`", "tree": {"sha": "6ac719850e121ccc2c5f7826874a2fb9de8b768e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac719850e121ccc2c5f7826874a2fb9de8b768e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "html_url": "https://github.com/rust-lang/rust/commit/3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b71ffca18a9f4a9515773b2c23d13f501d1e08f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b71ffca18a9f4a9515773b2c23d13f501d1e08f", "html_url": "https://github.com/rust-lang/rust/commit/0b71ffca18a9f4a9515773b2c23d13f501d1e08f"}, {"sha": "619b8abaa65efd7fcc05453381e532ed8b716cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/619b8abaa65efd7fcc05453381e532ed8b716cf0", "html_url": "https://github.com/rust-lang/rust/commit/619b8abaa65efd7fcc05453381e532ed8b716cf0"}], "stats": {"total": 742, "additions": 351, "deletions": 391}, "files": [{"sha": "598bf771008dbb009d64ccd28c90d6b8b5fb0d97", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -504,7 +504,7 @@ pub struct WhereEqPredicate {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: AttrVec,\n     pub items: Vec<P<Item>>,\n     pub spans: ModSpans,\n     /// Must be equal to `CRATE_NODE_ID` after the crate root is expanded, but may hold\n@@ -1268,7 +1268,7 @@ impl Expr {\n                 id: DUMMY_NODE_ID,\n                 kind: ExprKind::Err,\n                 span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n                 tokens: None,\n             },\n         )\n@@ -2669,7 +2669,7 @@ impl VariantData {\n /// An item definition.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n@@ -3036,19 +3036,19 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(AssocItem, 120);\n+    static_assert_size!(AssocItem, 104);\n     static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n     static_assert_size!(Fn, 192);\n-    static_assert_size!(ForeignItem, 112);\n+    static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericBound, 88);\n     static_assert_size!(Generics, 72);\n     static_assert_size!(Impl, 200);\n-    static_assert_size!(Item, 200);\n+    static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);"}, {"sha": "0947a71b8243261a7e7efad25f1599b7a92fb943", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -270,7 +270,7 @@ pub trait HasAttrs {\n     /// during token collection.\n     const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n     fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec));\n }\n \n macro_rules! impl_has_attrs {\n@@ -283,8 +283,8 @@ macro_rules! impl_has_attrs {\n                     &self.attrs\n                 }\n \n-                fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                    VecOrAttrVec::visit(&mut self.attrs, f)\n+                fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n+                    f(&mut self.attrs)\n                 }\n             }\n         )+\n@@ -299,7 +299,7 @@ macro_rules! impl_has_attrs_none {\n                 fn attrs(&self) -> &[Attribute] {\n                     &[]\n                 }\n-                fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+                fn visit_attrs(&mut self, _f: impl FnOnce(&mut AttrVec)) {}\n             }\n         )+\n     };\n@@ -330,7 +330,7 @@ impl<T: AstDeref<Target: HasAttrs>> HasAttrs for T {\n     fn attrs(&self) -> &[Attribute] {\n         self.ast_deref().attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.ast_deref_mut().visit_attrs(f)\n     }\n }\n@@ -340,7 +340,7 @@ impl<T: HasAttrs> HasAttrs for Option<T> {\n     fn attrs(&self) -> &[Attribute] {\n         self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         if let Some(inner) = self.as_mut() {\n             inner.visit_attrs(f);\n         }\n@@ -362,13 +362,13 @@ impl HasAttrs for StmtKind {\n         }\n     }\n \n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         match self {\n-            StmtKind::Local(local) => visit_attrvec(&mut local.attrs, f),\n+            StmtKind::Local(local) => f(&mut local.attrs),\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n             StmtKind::Item(item) => item.visit_attrs(f),\n             StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+            StmtKind::MacCall(mac) => f(&mut mac.attrs),\n         }\n     }\n }\n@@ -378,38 +378,11 @@ impl HasAttrs for Stmt {\n     fn attrs(&self) -> &[Attribute] {\n         self.kind.attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.kind.visit_attrs(f);\n     }\n }\n \n-/// Helper trait for the impls above. Abstracts over\n-/// the two types of attribute fields that AST nodes\n-/// may have (`Vec<Attribute>` or `AttrVec`).\n-trait VecOrAttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl VecOrAttrVec for Vec<Attribute> {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl VecOrAttrVec for AttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_attrvec(self, f)\n-    }\n-}\n-\n-fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n-    crate::mut_visit::visit_clobber(attrs, |attrs| {\n-        let mut vec = attrs.into();\n-        f(&mut vec);\n-        vec.into()\n-    });\n-}\n-\n /// A newtype around an AST node that implements the traits above if the node implements them.\n pub struct AstNodeWrapper<Wrapped, Tag> {\n     pub wrapped: Wrapped,"}, {"sha": "5b72ec2b6015c32550e8f53eb0ab6f01d3495fc1", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -12,7 +12,6 @@ use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyTokenStream, TokenStream};\n use crate::util::comments;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -487,7 +486,7 @@ impl MetaItemKind {\n                     id: ast::DUMMY_NODE_ID,\n                     kind: ast::ExprKind::Lit(lit.clone()),\n                     span: lit.span,\n-                    attrs: ThinVec::new(),\n+                    attrs: ast::AttrVec::new(),\n                     tokens: None,\n                 });\n                 MacArgs::Eq(span, MacArgsEq::Ast(expr))"}, {"sha": "458d1156ec251b7c17248facee6b2e8c91af9154", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -14,7 +14,6 @@ use crate::tokenstream::*;\n \n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n@@ -338,12 +337,7 @@ where\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n-    visit_vec(attrs, |attr| vis.visit_attribute(attr));\n-}\n-\n-// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n+pub fn visit_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n     for attr in attrs.iter_mut() {\n         vis.visit_attribute(attr);\n     }\n@@ -398,7 +392,7 @@ pub fn noop_flat_map_pat_field<T: MutVisitor>(\n     vis.visit_ident(ident);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![fp]\n }\n \n@@ -424,7 +418,7 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n \n pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[Arm; 1]> {\n     let Arm { attrs, pat, guard, body, span, id, is_placeholder: _ } = &mut arm;\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n@@ -507,7 +501,7 @@ pub fn noop_flat_map_variant<T: MutVisitor>(\n     let Variant { ident, vis, attrs, id, data, disr_expr, span, is_placeholder: _ } = &mut variant;\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n     visitor.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| visitor.visit_anon_const(disr_expr));\n@@ -589,7 +583,7 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n         }\n     }\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n@@ -640,7 +634,7 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> SmallVec<[Param; 1]> {\n     let Param { attrs, id, pat, span, ty, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n     vis.visit_ty(ty);\n@@ -882,7 +876,7 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     if let Some(ref mut colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n     match kind {\n         GenericParamKind::Lifetime => {}\n@@ -978,7 +972,7 @@ pub fn noop_flat_map_field_def<T: MutVisitor>(\n     visitor.visit_vis(vis);\n     visitor.visit_id(id);\n     visitor.visit_ty(ty);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     smallvec![fd]\n }\n \n@@ -991,7 +985,7 @@ pub fn noop_flat_map_expr_field<T: MutVisitor>(\n     vis.visit_expr(expr);\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![f]\n }\n \n@@ -1432,7 +1426,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n@@ -1478,7 +1472,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::MacCall(mut mac) => {\n             let MacCallStmt { mac: mac_, style: _, attrs, tokens } = mac.deref_mut();\n             vis.visit_mac_call(mac_);\n-            visit_thin_attrs(attrs, vis);\n+            visit_attrs(attrs, vis);\n             visit_lazy_tts(tokens, vis);\n             smallvec![StmtKind::MacCall(mac)]\n         }\n@@ -1513,12 +1507,6 @@ impl<T: DummyAstNode + 'static> DummyAstNode for P<T> {\n     }\n }\n \n-impl<T> DummyAstNode for ThinVec<T> {\n-    fn dummy() -> Self {\n-        Default::default()\n-    }\n-}\n-\n impl DummyAstNode for Item {\n     fn dummy() -> Self {\n         Item {"}, {"sha": "bd61f4fa87ab8d493b0a41f63086c47478e69fea", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -6,7 +6,6 @@ use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -448,12 +447,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n         let new_cond = self.manage_let_cond(lowered_cond);\n         let then = self.lower_block_expr(body);\n-        let expr_break = self.expr_break(span, ThinVec::new());\n+        let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n-        let else_expr = self.arena.alloc(self.expr_block(else_blk, ThinVec::new()));\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n         let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n-        let if_expr = self.expr(span, if_kind, ThinVec::new());\n+        let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n         let opt_label = self.lower_label(opt_label);\n@@ -512,7 +511,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let constructor = self.arena.alloc(self.expr_lang_item_path(\n             method_span,\n             lang_item,\n-            ThinVec::new(),\n+            AttrVec::new(),\n             None,\n         ));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n@@ -635,7 +634,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let gen_future = self.expr_lang_item_path(\n             unstable_span,\n             hir::LangItem::FromGenerator,\n-            ThinVec::new(),\n+            AttrVec::new(),\n             None,\n         );\n \n@@ -747,7 +746,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                this.arena.alloc(this.expr(gen_future_span, expr_break, ThinVec::new()))\n+                this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new()))\n             });\n             self.arm(ready_pat, break_x)\n         };\n@@ -780,7 +779,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }),\n-                ThinVec::new(),\n+                AttrVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n \n@@ -987,7 +986,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n-                this.expr(fn_decl_span, async_body, ThinVec::new())\n+                this.expr(fn_decl_span, async_body, AttrVec::new())\n             });\n             body_id\n         });\n@@ -1257,7 +1256,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ident = self.expr_ident(lhs.span, ident, binding);\n         let assign =\n             hir::ExprKind::Assign(self.lower_expr(lhs), ident, self.lower_span(eq_sign_span));\n-        let expr = self.expr(lhs.span, assign, ThinVec::new());\n+        let expr = self.expr(lhs.span, assign, AttrVec::new());\n         assignments.push(self.stmt_expr(lhs.span, expr));\n         pat\n     }\n@@ -1299,7 +1298,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let fn_path =\n             hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, self.lower_span(span), None);\n         let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), AttrVec::new()));\n         hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n@@ -1472,7 +1471,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `None => break`\n         let none_arm = {\n             let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, ThinVec::new()));\n+                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, AttrVec::new()));\n             let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n@@ -1481,7 +1480,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let some_arm = {\n             let some_pat = self.pat_some(pat_span, pat);\n             let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-            let body_expr = self.arena.alloc(self.expr_block(body_block, ThinVec::new()));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block, AttrVec::new()));\n             self.arm(some_pat, body_expr)\n         };\n \n@@ -1596,7 +1595,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             };\n             attr::mk_attr_outer(allow)\n         };\n-        let attrs = vec![attr];\n+        let attrs: AttrVec = vec![attr].into();\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`\n         let continue_arm = {\n@@ -1606,7 +1605,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 span,\n                 val_ident,\n                 val_pat_nid,\n-                ThinVec::from(attrs.clone()),\n+                attrs.clone(),\n             ));\n             let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n             self.arm(continue_pat, val_expr)\n@@ -1625,7 +1624,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.arena.alloc(residual_expr),\n                 unstable_span,\n             );\n-            let thin_attrs = ThinVec::from(attrs);\n             let ret_expr = if let Some(catch_node) = self.catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n                 self.arena.alloc(self.expr(\n@@ -1634,13 +1632,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::Destination { label: None, target_id },\n                         Some(from_residual_expr),\n                     ),\n-                    thin_attrs,\n+                    attrs,\n                 ))\n             } else {\n                 self.arena.alloc(self.expr(\n                     try_span,\n                     hir::ExprKind::Ret(Some(from_residual_expr)),\n-                    thin_attrs,\n+                    attrs,\n                 ))\n             };\n \n@@ -1728,7 +1726,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), AttrVec::new())\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n@@ -1745,12 +1743,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n-            ThinVec::new(),\n+            AttrVec::new(),\n         )\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), AttrVec::new()))\n     }\n \n     fn expr_call_mut(\n@@ -1759,7 +1757,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args), AttrVec::new())\n     }\n \n     fn expr_call(\n@@ -1779,7 +1777,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n         let path =\n-            self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new(), hir_id));\n+            self.arena.alloc(self.expr_lang_item_path(span, lang_item, AttrVec::new(), hir_id));\n         self.expr_call_mut(span, path, args)\n     }\n \n@@ -1822,7 +1820,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         ident: Ident,\n         binding: hir::HirId,\n     ) -> hir::Expr<'hir> {\n-        self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n+        self.expr_ident_with_attrs(sp, ident, binding, AttrVec::new())\n     }\n \n     fn expr_ident_with_attrs(\n@@ -1860,13 +1858,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }),\n                 None,\n             ),\n-            ThinVec::new(),\n+            AttrVec::new(),\n         )\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        let expr = self.expr_block(blk, ThinVec::new());\n+        let expr = self.expr_block(blk, AttrVec::new());\n         self.arena.alloc(expr)\n     }\n "}, {"sha": "a1051d990b14b910b1634ca8e43288a511718ca1", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -852,7 +852,7 @@ pub(super) fn expand_global_asm<'cx>(\n             if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n                 MacEager::items(smallvec![P(ast::Item {\n                     ident: Ident::empty(),\n-                    attrs: Vec::new(),\n+                    attrs: ast::AttrVec::new(),\n                     id: ast::DUMMY_NODE_ID,\n                     kind: ast::ItemKind::GlobalAsm(Box::new(inline_asm)),\n                     vis: ast::Visibility {"}, {"sha": "d2ee4249989ee396a8195ae9030b70be35b55564", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -119,7 +119,8 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 vec![self.cx.attribute(attr::mk_list_item(\n                     Ident::new(sym::allow, self.span),\n                     vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))],\n+                ))]\n+                .into(),\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec!["}, {"sha": "dd7989cf48c37b784cd37fdc7020e71bcea334bc", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -68,7 +68,7 @@ pub fn expand_deriving_clone(\n     }\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "9b6d3e5032f9495f92caad1231e79e01680e7d05", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -20,7 +20,7 @@ pub fn expand_deriving_eq(\n     let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n     let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n     let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n+    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "0e17b95178759368b59147dfca1fda6751b78066", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -15,7 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "ac1325b92a6f38ed38acd385baded5839cdb076f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -68,7 +68,7 @@ pub fn expand_deriving_partial_eq(\n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "7763e55401783b19670703c070c72fa418e2117f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -19,7 +19,7 @@ pub fn expand_deriving_partial_ord(\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "4af7fd8165388894456292ac08518d98dabcbbde", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_debug(\n             explicit_self: true,\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n-            attributes: Vec::new(),\n+            attributes: ast::AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)"}, {"sha": "7174dbbe7ea8b5abc7e1ac07dd2f28e1edafa14b", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -47,7 +47,7 @@ pub fn expand_deriving_rustc_decodable(\n                 ],\n                 PathKind::Std,\n             )),\n-            attributes: Vec::new(),\n+            attributes: ast::AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)"}, {"sha": "f316f01ef66152e7bb1b3308ce9c924b0d80b6e2", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -2,9 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n \n use rustc_ast as ast;\n-use rustc_ast::walk_list;\n-use rustc_ast::EnumDef;\n-use rustc_ast::VariantData;\n+use rustc_ast::{walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -22,7 +20,7 @@ pub fn expand_deriving_default(\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),"}, {"sha": "b220e54238f462e27c1d5d383490dcb7bdb6ec99", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -89,7 +89,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::{ExprKind, MetaItem, Mutability};\n+use rustc_ast::{AttrVec, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -131,7 +131,7 @@ pub fn expand_deriving_rustc_encodable(\n                 ],\n                 PathKind::Std,\n             )),\n-            attributes: Vec::new(),\n+            attributes: AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)"}, {"sha": "c1bbc601560fa1550b2d5daa18c3302948fb4dcf", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -217,7 +217,7 @@ pub struct MethodDef<'a> {\n     /// Returns type\n     pub ret_ty: Ty,\n \n-    pub attributes: Vec<ast::Attribute>,\n+    pub attributes: ast::AttrVec,\n \n     /// Can we combine fieldless variants for enums into a single match arm?\n     /// If true, indicates that the trait operation uses the enum tag in some\n@@ -562,7 +562,7 @@ impl<'a> TraitDef<'a> {\n                     kind: ast::VisibilityKind::Inherited,\n                     tokens: None,\n                 },\n-                attrs: Vec::new(),\n+                attrs: ast::AttrVec::new(),\n                 kind: ast::AssocItemKind::TyAlias(Box::new(ast::TyAlias {\n                     defaultness: ast::Defaultness::Final,\n                     generics: Generics::default(),\n@@ -716,7 +716,7 @@ impl<'a> TraitDef<'a> {\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n-        let attrs = vec![attr];\n+        let attrs = vec![attr].into();\n         let opt_trait_ref = Some(trait_ref);\n \n         cx.item("}, {"sha": "f1f02e7ce778740246c2a81b0038ec2d0ced1453", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -2,7 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::{MetaItem, Mutability};\n+use rustc_ast::{AttrVec, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -31,7 +31,7 @@ pub fn expand_deriving_hash(\n             explicit_self: true,\n             nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n-            attributes: vec![],\n+            attributes: AttrVec::new(),\n             unify_fieldless_variants: true,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)"}, {"sha": "a65d0bad6de801e91d62ca492a2ba68ec9d20975", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -164,7 +164,7 @@ fn inject_impl_of_structural_trait(\n \n     // Keep the lint and stability attributes of the original item, to control\n     // how the generated implementation is linted.\n-    let mut attrs = Vec::new();\n+    let mut attrs = ast::AttrVec::new();\n     attrs.extend(\n         item.attrs\n             .iter()"}, {"sha": "2bad9bbce6650b30af53e970bd90a0ae21287552", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::expand::allocator::{\n     AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n };\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Attribute, Expr, FnHeader, FnSig, Generics, Param, StmtKind};\n+use rustc_ast::{self as ast, AttrVec, Expr, FnHeader, FnSig, Generics, Param, StmtKind};\n use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -113,10 +113,10 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.expr_call(self.ty_span, method, args)\n     }\n \n-    fn attrs(&self) -> Vec<Attribute> {\n+    fn attrs(&self) -> AttrVec {\n         let special = sym::rustc_std_internal_symbol;\n         let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(special)]\n+        vec![self.cx.attribute(special)].into()\n     }\n \n     fn arg_ty("}, {"sha": "ebe1c3663e3a7fafc65da5117b065ac2eccb962f", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -281,7 +281,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n     let span = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());\n \n     let proc_macro = Ident::new(sym::proc_macro, span);\n-    let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));\n+    let krate = cx.item(span, proc_macro, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None));\n \n     let bridge = Ident::new(sym::bridge, span);\n     let client = Ident::new(sym::client, span);"}, {"sha": "90ea1e457ba8031885f3941cb605e00e52590c0f", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -51,7 +51,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+                vec![cx.attribute(cx.meta_word(span, sym::macro_use))].into(),\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -78,7 +78,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))].into(),\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "03c84f5ec2a740fe1f158099885719b5369477c6", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -227,7 +227,8 @@ pub fn expand_test_or_bench(\n             )),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n-        ],\n+        ]\n+        .into(),\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,\n@@ -334,7 +335,7 @@ pub fn expand_test_or_bench(\n     });\n \n     // extern crate test\n-    let test_extern = cx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None));\n+    let test_extern = cx.item(sp, test_id, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None));\n \n     tracing::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n "}, {"sha": "093f0f10a3867e591108604f1547841a960ff125", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -298,8 +298,10 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // extern crate test\n-    let test_extern_stmt =\n-        ecx.stmt_item(sp, ecx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None)));\n+    let test_extern_stmt = ecx.stmt_item(\n+        sp,\n+        ecx.item(sp, test_id, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None)),\n+    );\n \n     // #[rustc_main]\n     let main_meta = ecx.meta_word(sp, sym::rustc_main);\n@@ -333,7 +335,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     let main = P(ast::Item {\n         ident: main_id,\n-        attrs: vec![main_attr],\n+        attrs: vec![main_attr].into(),\n         id: ast::DUMMY_NODE_ID,\n         kind: main,\n         vis: ast::Visibility { span: sp, kind: ast::VisibilityKind::Public, tokens: None },"}, {"sha": "d912211443a893813d6b5c4fda225f2487765289", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "modified", "additions": 49, "deletions": 78, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -1,3 +1,4 @@\n+use crate::thin_vec::ThinVec;\n use smallvec::{Array, SmallVec};\n use std::ptr;\n \n@@ -15,94 +16,64 @@ pub trait MapInPlace<T>: Sized {\n         I: IntoIterator<Item = T>;\n }\n \n-impl<T> MapInPlace<T> for Vec<T> {\n-    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n-    where\n-        F: FnMut(T) -> I,\n-        I: IntoIterator<Item = T>,\n-    {\n-        let mut read_i = 0;\n-        let mut write_i = 0;\n-        unsafe {\n-            let mut old_len = self.len();\n-            self.set_len(0); // make sure we just leak elements in case of panic\n+// The implementation of this method is syntactically identical for all the\n+// different vector types.\n+macro_rules! flat_map_in_place {\n+    () => {\n+        fn flat_map_in_place<F, I>(&mut self, mut f: F)\n+        where\n+            F: FnMut(T) -> I,\n+            I: IntoIterator<Item = T>,\n+        {\n+            let mut read_i = 0;\n+            let mut write_i = 0;\n+            unsafe {\n+                let mut old_len = self.len();\n+                self.set_len(0); // make sure we just leak elements in case of panic\n \n-            while read_i < old_len {\n-                // move the read_i'th item out of the vector and map it\n-                // to an iterator\n-                let e = ptr::read(self.as_ptr().add(read_i));\n-                let iter = f(e).into_iter();\n-                read_i += 1;\n+                while read_i < old_len {\n+                    // move the read_i'th item out of the vector and map it\n+                    // to an iterator\n+                    let e = ptr::read(self.as_ptr().add(read_i));\n+                    let iter = f(e).into_iter();\n+                    read_i += 1;\n \n-                for e in iter {\n-                    if write_i < read_i {\n-                        ptr::write(self.as_mut_ptr().add(write_i), e);\n-                        write_i += 1;\n-                    } else {\n-                        // If this is reached we ran out of space\n-                        // in the middle of the vector.\n-                        // However, the vector is in a valid state here,\n-                        // so we just do a somewhat inefficient insert.\n-                        self.set_len(old_len);\n-                        self.insert(write_i, e);\n+                    for e in iter {\n+                        if write_i < read_i {\n+                            ptr::write(self.as_mut_ptr().add(write_i), e);\n+                            write_i += 1;\n+                        } else {\n+                            // If this is reached we ran out of space\n+                            // in the middle of the vector.\n+                            // However, the vector is in a valid state here,\n+                            // so we just do a somewhat inefficient insert.\n+                            self.set_len(old_len);\n+                            self.insert(write_i, e);\n \n-                        old_len = self.len();\n-                        self.set_len(0);\n+                            old_len = self.len();\n+                            self.set_len(0);\n \n-                        read_i += 1;\n-                        write_i += 1;\n+                            read_i += 1;\n+                            write_i += 1;\n+                        }\n                     }\n                 }\n-            }\n \n-            // write_i tracks the number of actually written new items.\n-            self.set_len(write_i);\n+                // write_i tracks the number of actually written new items.\n+                self.set_len(write_i);\n+            }\n         }\n-    }\n+    };\n }\n \n-impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n-    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n-    where\n-        F: FnMut(T) -> I,\n-        I: IntoIterator<Item = T>,\n-    {\n-        let mut read_i = 0;\n-        let mut write_i = 0;\n-        unsafe {\n-            let mut old_len = self.len();\n-            self.set_len(0); // make sure we just leak elements in case of panic\n-\n-            while read_i < old_len {\n-                // move the read_i'th item out of the vector and map it\n-                // to an iterator\n-                let e = ptr::read(self.as_ptr().add(read_i));\n-                let iter = f(e).into_iter();\n-                read_i += 1;\n-\n-                for e in iter {\n-                    if write_i < read_i {\n-                        ptr::write(self.as_mut_ptr().add(write_i), e);\n-                        write_i += 1;\n-                    } else {\n-                        // If this is reached we ran out of space\n-                        // in the middle of the vector.\n-                        // However, the vector is in a valid state here,\n-                        // so we just do a somewhat inefficient insert.\n-                        self.set_len(old_len);\n-                        self.insert(write_i, e);\n-\n-                        old_len = self.len();\n-                        self.set_len(0);\n+impl<T> MapInPlace<T> for Vec<T> {\n+    flat_map_in_place!();\n+}\n \n-                        read_i += 1;\n-                        write_i += 1;\n-                    }\n-                }\n-            }\n+impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n+    flat_map_in_place!();\n+}\n \n-            // write_i tracks the number of actually written new items.\n-            self.set_len(write_i);\n-        }\n-    }\n+impl<T> MapInPlace<T> for ThinVec<T> {\n+    flat_map_in_place!();\n }"}, {"sha": "fce42e709ab74cfefcf6d81ebff7d2ddc164ea32", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -27,6 +27,51 @@ impl<T> ThinVec<T> {\n             ThinVec(None) => *self = vec![item].into(),\n         }\n     }\n+\n+    /// Note: if `set_len(0)` is called on a non-empty `ThinVec`, it will\n+    /// remain in the `Some` form. This is required for some code sequences\n+    /// (such as the one in `flat_map_in_place`) that call `set_len(0)` before\n+    /// an operation that might panic, and then call `set_len(n)` again\n+    /// afterwards.\n+    pub unsafe fn set_len(&mut self, new_len: usize) {\n+        match *self {\n+            ThinVec(None) => {\n+                // A prerequisite of `Vec::set_len` is that `new_len` must be\n+                // less than or equal to capacity(). The same applies here.\n+                if new_len != 0 {\n+                    panic!(\"unsafe ThinVec::set_len({})\", new_len);\n+                }\n+            }\n+            ThinVec(Some(ref mut vec)) => vec.set_len(new_len),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, value: T) {\n+        match *self {\n+            ThinVec(None) => {\n+                if index == 0 {\n+                    *self = vec![value].into();\n+                } else {\n+                    panic!(\"invalid ThinVec::insert\");\n+                }\n+            }\n+            ThinVec(Some(ref mut vec)) => vec.insert(index, value),\n+        }\n+    }\n+\n+    pub fn remove(&mut self, index: usize) -> T {\n+        match self {\n+            ThinVec(None) => panic!(\"invalid ThinVec::remove\"),\n+            ThinVec(Some(vec)) => vec.remove(index),\n+        }\n+    }\n+\n+    pub fn as_slice(&self) -> &[T] {\n+        match self {\n+            ThinVec(None) => &[],\n+            ThinVec(Some(vec)) => vec.as_slice(),\n+        }\n+    }\n }\n \n impl<T> From<Vec<T>> for ThinVec<T> {"}, {"sha": "dac8df7dc55e0966d1a86f3d3ef2fb98d4589984", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -1070,7 +1070,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n+fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::AttrVec> {\n     match input {\n         Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n         Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str("}, {"sha": "df56e032988c6e05c695e49d45b64a2d38741313", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, Attribute, HasAttrs, Item, NodeId, PatKind};\n+use rustc_ast::{self as ast, AttrVec, Attribute, HasAttrs, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::sync::{self, Lrc};\n@@ -71,7 +71,7 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    pub fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         match self {\n             Annotatable::Item(item) => item.visit_attrs(f),\n             Annotatable::TraitItem(trait_item) => trait_item.visit_attrs(f),"}, {"sha": "c4890b4a9c41378e14fdc07cf4ae6a2f883a9a45", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -575,7 +575,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         name: Ident,\n-        attrs: Vec<ast::Attribute>,\n+        attrs: ast::AttrVec,\n         kind: ast::ItemKind,\n     ) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n@@ -603,7 +603,7 @@ impl<'a> ExtCtxt<'a> {\n         mutbl: ast::Mutability,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n+        self.item(span, name, AttrVec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n     }\n \n     pub fn item_const(\n@@ -614,7 +614,7 @@ impl<'a> ExtCtxt<'a> {\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n         let def = ast::Defaultness::Final;\n-        self.item(span, name, Vec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n+        self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n     }\n \n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {"}, {"sha": "48ee23d2c3d18e50fb2712cfa3198f36a08ea7f1", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -215,7 +215,7 @@ pub fn features(\n     let features = match strip_unconfigured.configure_krate_attrs(krate.attrs) {\n         None => {\n             // The entire crate is unconfigured.\n-            krate.attrs = Vec::new();\n+            krate.attrs = ast::AttrVec::new();\n             krate.items = Vec::new();\n             Features::default()\n         }\n@@ -265,7 +265,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_krate_attrs(&self, mut attrs: Vec<ast::Attribute>) -> Option<Vec<ast::Attribute>> {\n+    fn configure_krate_attrs(&self, mut attrs: ast::AttrVec) -> Option<ast::AttrVec> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n@@ -292,9 +292,7 @@ impl<'a> StripUnconfigured<'a> {\n             .iter()\n             .flat_map(|(tree, spacing)| match tree.clone() {\n                 AttrAnnotatedTokenTree::Attributes(mut data) => {\n-                    let mut attrs: Vec<_> = std::mem::take(&mut data.attrs).into();\n-                    attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n-                    data.attrs = attrs.into();\n+                    data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n \n                     if self.in_cfg(&data.attrs) {\n                         data.tokens = LazyTokenStream::new("}, {"sha": "c2add852a0679672e97a5ae8a1714d29c1ad8c1c", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, AttrVec, ExprKind, ForeignItemKind};\n use rustc_ast::{HasAttrs, HasNodeId};\n use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n@@ -1001,7 +1001,7 @@ enum AddSemicolon {\n /// of functionality used by `InvocationCollector`.\n trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     type OutputTy = SmallVec<[Self; 1]>;\n-    type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n+    type AttrsTy: Deref<Target = [ast::Attribute]> = ast::AttrVec;\n     const KIND: AstFragmentKind;\n     fn to_annotatable(self) -> Annotatable;\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n@@ -1333,7 +1333,7 @@ impl InvocationCollectorNode for ast::Stmt {\n             }\n             StmtKind::Item(item) => match item.into_inner() {\n                 ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n-                    (mac.args.need_semicolon(), mac, attrs.into())\n+                    (mac.args.need_semicolon(), mac, attrs)\n                 }\n                 _ => unreachable!(),\n             },\n@@ -1390,7 +1390,7 @@ impl InvocationCollectorNode for P<ast::Ty> {\n     fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            TyKind::MacCall(mac) => (mac, AttrVec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1414,7 +1414,7 @@ impl InvocationCollectorNode for P<ast::Pat> {\n     fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            PatKind::MacCall(mac) => (mac, AttrVec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1646,7 +1646,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: ast::Attribute, pos: usize) {\n         node.visit_attrs(|attrs| {\n-            attrs.splice(pos..pos, self.cfg().expand_cfg_attr(attr, false));\n+            // Repeated `insert` calls is inefficient, but the number of\n+            // insertions is almost always 0 or 1 in practice.\n+            for cfg in self.cfg().expand_cfg_attr(attr, false).into_iter().rev() {\n+                attrs.insert(pos, cfg)\n+            }\n         });\n     }\n "}, {"sha": "9002a24e42f9df671dc913fe744306dd480909ef", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -1,6 +1,6 @@\n use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n-use rustc_ast::{token, Attribute, Inline, Item, ModSpans};\n+use rustc_ast::{token, AttrVec, Attribute, Inline, Item, ModSpans};\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_parse::new_parser_from_file;\n use rustc_parse::validate_attr;\n@@ -48,7 +48,7 @@ pub(crate) fn parse_external_mod(\n     span: Span, // The span to blame on errors.\n     module: &ModuleData,\n     mut dir_ownership: DirOwnership,\n-    attrs: &mut Vec<Attribute>,\n+    attrs: &mut AttrVec,\n ) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: Result<_, ModError<'_>> = try {\n@@ -63,9 +63,9 @@ pub(crate) fn parse_external_mod(\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n-        let (mut inner_attrs, items, inner_span) =\n+        let (inner_attrs, items, inner_span) =\n             parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n-        attrs.append(&mut inner_attrs);\n+        attrs.extend(inner_attrs);\n         (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module."}, {"sha": "3b0d5ddb97b4e184e11b2608a37dbb05a71c719d", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -24,7 +24,7 @@ pub fn placeholder(\n     }\n \n     let ident = Ident::empty();\n-    let attrs = Vec::new();\n+    let attrs = ast::AttrVec::new();\n     let vis = vis.unwrap_or(ast::Visibility {\n         span: DUMMY_SP,\n         kind: ast::VisibilityKind::Inherited,"}, {"sha": "3691d82a835a9d57158e101d24de1e05419e0b5d", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -62,7 +62,7 @@ pub fn parse_crate_from_file<'a>(input: &Path, sess: &'a ParseSess) -> PResult<'\n pub fn parse_crate_attrs_from_file<'a>(\n     input: &Path,\n     sess: &'a ParseSess,\n-) -> PResult<'a, Vec<ast::Attribute>> {\n+) -> PResult<'a, ast::AttrVec> {\n     let mut parser = new_parser_from_file(sess, input, None);\n     parser.parse_inner_attributes()\n }\n@@ -79,7 +79,7 @@ pub fn parse_crate_attrs_from_source_str(\n     name: FileName,\n     source: String,\n     sess: &ParseSess,\n-) -> PResult<'_, Vec<ast::Attribute>> {\n+) -> PResult<'_, ast::AttrVec> {\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n "}, {"sha": "72ab96b5ca67032aa9e4c83509e42a5b4ced6613", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -34,7 +34,7 @@ enum OuterAttributeType {\n impl<'a> Parser<'a> {\n     /// Parses attributes that appear before an item.\n     pub(super) fn parse_outer_attributes(&mut self) -> PResult<'a, AttrWrapper> {\n-        let mut outer_attrs: Vec<ast::Attribute> = Vec::new();\n+        let mut outer_attrs = ast::AttrVec::new();\n         let mut just_parsed_doc_comment = false;\n         let start_pos = self.token_cursor.num_next_calls;\n         loop {\n@@ -106,7 +106,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        Ok(AttrWrapper::new(outer_attrs.into(), start_pos))\n+        Ok(AttrWrapper::new(outer_attrs, start_pos))\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`.\n@@ -283,8 +283,8 @@ impl<'a> Parser<'a> {\n     /// terminated by a semicolon.\n     ///\n     /// Matches `inner_attrs*`.\n-    pub(crate) fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n-        let mut attrs: Vec<ast::Attribute> = vec![];\n+    pub(crate) fn parse_inner_attributes(&mut self) -> PResult<'a, ast::AttrVec> {\n+        let mut attrs = ast::AttrVec::new();\n         loop {\n             let start_pos: u32 = self.token_cursor.num_next_calls.try_into().unwrap();\n             // Only try to parse if it is an inner attribute (has `!`)."}, {"sha": "ed54af9f53fb7f914622ecb9ec7b7565b25ce5ac", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -15,11 +15,11 @@ use std::ops::Range;\n /// for the attribute target. This allows us to perform cfg-expansion on\n /// a token stream before we invoke a derive proc-macro.\n ///\n-/// This wrapper prevents direct access to the underlying `Vec<ast::Attribute>`.\n+/// This wrapper prevents direct access to the underlying `ast::AttrVec>`.\n /// Parsing code can only get access to the underlying attributes\n /// by passing an `AttrWrapper` to `collect_tokens_trailing_tokens`.\n /// This makes it difficult to accidentally construct an AST node\n-/// (which stores a `Vec<ast::Attribute>`) without first collecting tokens.\n+/// (which stores an `ast::AttrVec`) without first collecting tokens.\n ///\n /// This struct has its own module, to ensure that the parser code\n /// cannot directly access the `attrs` field\n@@ -49,9 +49,10 @@ impl AttrWrapper {\n         self.attrs\n     }\n \n+    // Prepend `self.attrs` to `attrs`.\n     // FIXME: require passing an NT to prevent misuse of this method\n-    pub(crate) fn prepend_to_nt_inner(self, attrs: &mut Vec<Attribute>) {\n-        let mut self_attrs: Vec<_> = self.attrs.into();\n+    pub(crate) fn prepend_to_nt_inner(self, attrs: &mut AttrVec) {\n+        let mut self_attrs = self.attrs.clone();\n         std::mem::swap(attrs, &mut self_attrs);\n         attrs.extend(self_attrs);\n     }\n@@ -196,7 +197,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         attrs: AttrWrapper,\n         force_collect: ForceCollect,\n-        f: impl FnOnce(&mut Self, Vec<ast::Attribute>) -> PResult<'a, (R, TrailingToken)>,\n+        f: impl FnOnce(&mut Self, ast::AttrVec) -> PResult<'a, (R, TrailingToken)>,\n     ) -> PResult<'a, R> {\n         // We only bail out when nothing could possibly observe the collected tokens:\n         // 1. We cannot be force collecting tokens (since force-collecting requires tokens\n@@ -212,7 +213,7 @@ impl<'a> Parser<'a> {\n             // or `#[cfg_attr]` attributes.\n             && !self.capture_cfg\n         {\n-            return Ok(f(self, attrs.attrs.into())?.0);\n+            return Ok(f(self, attrs.attrs)?.0);\n         }\n \n         let start_token = (self.token.clone(), self.token_spacing);\n@@ -222,7 +223,7 @@ impl<'a> Parser<'a> {\n         let prev_capturing = std::mem::replace(&mut self.capture_state.capturing, Capturing::Yes);\n         let replace_ranges_start = self.capture_state.replace_ranges.len();\n \n-        let ret = f(self, attrs.attrs.into());\n+        let ret = f(self, attrs.attrs);\n \n         self.capture_state.capturing = prev_capturing;\n \n@@ -352,7 +353,7 @@ impl<'a> Parser<'a> {\n         // on the captured token stream.\n         if self.capture_cfg\n             && matches!(self.capture_state.capturing, Capturing::Yes)\n-            && has_cfg_or_cfg_attr(&final_attrs)\n+            && has_cfg_or_cfg_attr(final_attrs)\n         {\n             let attr_data = AttributesData { attrs: final_attrs.to_vec().into(), tokens };\n "}, {"sha": "d7facb29714bc11d889c2641d3178c8631f94837", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -2370,7 +2370,7 @@ impl<'a> Parser<'a> {\n \n     fn recover_const_param_decl(&mut self, ty_generics: Option<&Generics>) -> Option<GenericArg> {\n         let snapshot = self.create_snapshot_for_diagnostic();\n-        let param = match self.parse_const_param(vec![]) {\n+        let param = match self.parse_const_param(AttrVec::new()) {\n             Ok(param) => param,\n             Err(err) => {\n                 err.cancel();"}, {"sha": "9fb9199231fb09ab04f953d7e26cf2fa6033ac67", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -950,15 +950,15 @@ impl<'a> Parser<'a> {\n         &mut self,\n         e0: P<Expr>,\n         lo: Span,\n-        mut attrs: Vec<ast::Attribute>,\n+        mut attrs: ast::AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n         self.parse_dot_or_call_expr_with_(e0, lo).map(|expr| {\n             expr.map(|mut expr| {\n-                attrs.extend::<Vec<_>>(expr.attrs.into());\n-                expr.attrs = attrs.into();\n+                attrs.extend(expr.attrs);\n+                expr.attrs = attrs;\n                 expr\n             })\n         })\n@@ -2224,7 +2224,7 @@ impl<'a> Parser<'a> {\n \n             Ok((\n                 Param {\n-                    attrs: attrs.into(),\n+                    attrs,\n                     ty,\n                     pat,\n                     span: lo.to(this.prev_token.span),\n@@ -2732,7 +2732,7 @@ impl<'a> Parser<'a> {\n                     let span = body.span;\n                     return Ok((\n                         ast::Arm {\n-                            attrs: attrs.into(),\n+                            attrs,\n                             pat,\n                             guard,\n                             body,\n@@ -2810,7 +2810,7 @@ impl<'a> Parser<'a> {\n \n             Ok((\n                 ast::Arm {\n-                    attrs: attrs.into(),\n+                    attrs,\n                     pat,\n                     guard,\n                     body: expr,\n@@ -3123,7 +3123,7 @@ impl<'a> Parser<'a> {\n                     span: lo.to(expr.span),\n                     expr,\n                     is_shorthand,\n-                    attrs: attrs.into(),\n+                    attrs,\n                     id: DUMMY_NODE_ID,\n                     is_placeholder: false,\n                 },\n@@ -3219,14 +3219,10 @@ impl<'a> Parser<'a> {\n         await_expr\n     }\n \n-    pub(crate) fn mk_expr_with_attrs<A>(&self, span: Span, kind: ExprKind, attrs: A) -> P<Expr>\n-    where\n-        A: Into<AttrVec>,\n-    {\n-        P(Expr { kind, span, attrs: attrs.into(), id: DUMMY_NODE_ID, tokens: None })\n+    pub(crate) fn mk_expr_with_attrs(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n+        P(Expr { kind, span, attrs, id: DUMMY_NODE_ID, tokens: None })\n     }\n \n-    // njn: rename\n     pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind) -> P<Expr> {\n         P(Expr { kind, span, attrs: AttrVec::new(), id: DUMMY_NODE_ID, tokens: None })\n     }\n@@ -3248,7 +3244,7 @@ impl<'a> Parser<'a> {\n     fn collect_tokens_for_expr(\n         &mut self,\n         attrs: AttrWrapper,\n-        f: impl FnOnce(&mut Self, Vec<ast::Attribute>) -> PResult<'a, P<Expr>>,\n+        f: impl FnOnce(&mut Self, ast::AttrVec) -> PResult<'a, P<Expr>>,\n     ) -> PResult<'a, P<Expr>> {\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let res = f(this, attrs)?;"}, {"sha": "4d0a8b05eb0271a573affbb80dbbd2312bf7cc59", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -1,9 +1,7 @@\n use super::{ForceCollect, Parser, TrailingToken};\n \n use rustc_ast::token;\n-use rustc_ast::{\n-    self as ast, Attribute, GenericBounds, GenericParam, GenericParamKind, WhereClause,\n-};\n+use rustc_ast::{self as ast, AttrVec, GenericBounds, GenericParam, GenericParamKind, WhereClause};\n use rustc_errors::{Applicability, PResult};\n use rustc_span::symbol::kw;\n \n@@ -26,7 +24,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?`.\n-    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+    fn parse_ty_param(&mut self, preceding_attrs: AttrVec) -> PResult<'a, GenericParam> {\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n@@ -43,7 +41,7 @@ impl<'a> Parser<'a> {\n         Ok(GenericParam {\n             ident,\n             id: ast::DUMMY_NODE_ID,\n-            attrs: preceding_attrs.into(),\n+            attrs: preceding_attrs,\n             bounds,\n             kind: GenericParamKind::Type { default },\n             is_placeholder: false,\n@@ -53,7 +51,7 @@ impl<'a> Parser<'a> {\n \n     pub(crate) fn parse_const_param(\n         &mut self,\n-        preceding_attrs: Vec<Attribute>,\n+        preceding_attrs: AttrVec,\n     ) -> PResult<'a, GenericParam> {\n         let const_span = self.token.span;\n \n@@ -68,7 +66,7 @@ impl<'a> Parser<'a> {\n         Ok(GenericParam {\n             ident,\n             id: ast::DUMMY_NODE_ID,\n-            attrs: preceding_attrs.into(),\n+            attrs: preceding_attrs,\n             bounds: Vec::new(),\n             kind: GenericParamKind::Const { ty, kw_span: const_span, default },\n             is_placeholder: false,\n@@ -109,7 +107,7 @@ impl<'a> Parser<'a> {\n                         Some(ast::GenericParam {\n                             ident: lifetime.ident,\n                             id: lifetime.id,\n-                            attrs: attrs.into(),\n+                            attrs,\n                             bounds,\n                             kind: ast::GenericParamKind::Lifetime,\n                             is_placeholder: false,"}, {"sha": "b743162a7e4d0809a234454ccea601335bb9cc2a", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -32,17 +32,17 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n-    fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+    fn parse_item_mod(&mut self, attrs: &mut AttrVec) -> PResult<'a, ItemInfo> {\n         let unsafety = self.parse_unsafety();\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let mod_kind = if self.eat(&token::Semi) {\n             ModKind::Unloaded\n         } else {\n             self.expect(&token::OpenDelim(Delimiter::Brace))?;\n-            let (mut inner_attrs, items, inner_span) =\n+            let (inner_attrs, items, inner_span) =\n                 self.parse_mod(&token::CloseDelim(Delimiter::Brace))?;\n-            attrs.append(&mut inner_attrs);\n+            attrs.extend(inner_attrs);\n             ModKind::Loaded(items, Inline::Yes, inner_span)\n         };\n         Ok((id, ItemKind::Mod(unsafety, mod_kind)))\n@@ -52,7 +52,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_mod(\n         &mut self,\n         term: &TokenKind,\n-    ) -> PResult<'a, (Vec<Attribute>, Vec<P<Item>>, ModSpans)> {\n+    ) -> PResult<'a, (AttrVec, Vec<P<Item>>, ModSpans)> {\n         let lo = self.token.span;\n         let attrs = self.parse_inner_attributes()?;\n \n@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_item_common_(\n         &mut self,\n-        mut attrs: Vec<Attribute>,\n+        mut attrs: AttrVec,\n         mac_allowed: bool,\n         attrs_allowed: bool,\n         fn_parse_mode: FnParseMode,\n@@ -198,7 +198,7 @@ impl<'a> Parser<'a> {\n     /// Parses one of the items allowed by the flags.\n     fn parse_item_kind(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         macros_allowed: bool,\n         lo: Span,\n         vis: &Visibility,\n@@ -534,7 +534,7 @@ impl<'a> Parser<'a> {\n     /// ```\n     fn parse_item_impl(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n         let unsafety = self.parse_unsafety();\n@@ -661,12 +661,12 @@ impl<'a> Parser<'a> {\n \n     fn parse_item_list<T>(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         mut parse_item: impl FnMut(&mut Parser<'a>) -> PResult<'a, Option<Option<T>>>,\n     ) -> PResult<'a, Vec<T>> {\n         let open_brace_span = self.token.span;\n         self.expect(&token::OpenDelim(Delimiter::Brace))?;\n-        attrs.append(&mut self.parse_inner_attributes()?);\n+        attrs.extend(self.parse_inner_attributes()?);\n \n         let mut items = Vec::new();\n         while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n@@ -775,7 +775,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, attrs: &mut Vec<Attribute>, lo: Span) -> PResult<'a, ItemInfo> {\n+    fn parse_item_trait(&mut self, attrs: &mut AttrVec, lo: Span) -> PResult<'a, ItemInfo> {\n         let unsafety = self.parse_unsafety();\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n@@ -1061,7 +1061,7 @@ impl<'a> Parser<'a> {\n     /// ```\n     fn parse_item_foreign_mod(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         mut unsafety: Unsafe,\n     ) -> PResult<'a, ItemInfo> {\n         let abi = self.parse_abi(); // ABI?\n@@ -1179,7 +1179,7 @@ impl<'a> Parser<'a> {\n     fn recover_const_impl(\n         &mut self,\n         const_span: Span,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n         let impl_span = self.token.span;\n@@ -1337,7 +1337,7 @@ impl<'a> Parser<'a> {\n                     ident,\n                     vis,\n                     id: DUMMY_NODE_ID,\n-                    attrs: variant_attrs.into(),\n+                    attrs: variant_attrs,\n                     data: struct_def,\n                     disr_expr,\n                     span: vlo.to(this.prev_token.span),\n@@ -1494,7 +1494,7 @@ impl<'a> Parser<'a> {\n                         ident: None,\n                         id: DUMMY_NODE_ID,\n                         ty,\n-                        attrs: attrs.into(),\n+                        attrs,\n                         is_placeholder: false,\n                     },\n                     TrailingToken::MaybeComma,\n@@ -1520,7 +1520,7 @@ impl<'a> Parser<'a> {\n         adt_ty: &str,\n         lo: Span,\n         vis: Visibility,\n-        attrs: Vec<Attribute>,\n+        attrs: AttrVec,\n     ) -> PResult<'a, FieldDef> {\n         let mut seen_comma: bool = false;\n         let a_var = self.parse_name_and_ty(adt_ty, lo, vis, attrs)?;\n@@ -1650,7 +1650,7 @@ impl<'a> Parser<'a> {\n         adt_ty: &str,\n         lo: Span,\n         vis: Visibility,\n-        attrs: Vec<Attribute>,\n+        attrs: AttrVec,\n     ) -> PResult<'a, FieldDef> {\n         let name = self.parse_field_ident(adt_ty, lo)?;\n         self.expect_field_ty_separator()?;\n@@ -1684,7 +1684,7 @@ impl<'a> Parser<'a> {\n             vis,\n             id: DUMMY_NODE_ID,\n             ty,\n-            attrs: attrs.into(),\n+            attrs,\n             is_placeholder: false,\n         })\n     }\n@@ -1703,7 +1703,7 @@ impl<'a> Parser<'a> {\n                 // We use `parse_fn` to get a span for the function\n                 let fn_parse_mode = FnParseMode { req_name: |_| true, req_body: true };\n                 if let Err(mut db) =\n-                    self.parse_fn(&mut Vec::new(), fn_parse_mode, lo, &inherited_vis)\n+                    self.parse_fn(&mut AttrVec::new(), fn_parse_mode, lo, &inherited_vis)\n                 {\n                     db.delay_as_bug();\n                 }\n@@ -1979,7 +1979,7 @@ impl<'a> Parser<'a> {\n     /// Parse a function starting from the front matter (`const ...`) to the body `{ ... }` or `;`.\n     fn parse_fn(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         fn_parse_mode: FnParseMode,\n         sig_lo: Span,\n         vis: &Visibility,\n@@ -2002,7 +2002,7 @@ impl<'a> Parser<'a> {\n     /// or e.g. a block when the function is a provided one.\n     fn parse_fn_body(\n         &mut self,\n-        attrs: &mut Vec<Attribute>,\n+        attrs: &mut AttrVec,\n         ident: &Ident,\n         sig_hi: &mut Span,\n         req_body: bool,\n@@ -2017,7 +2017,7 @@ impl<'a> Parser<'a> {\n             // Include the trailing semicolon in the span of the signature\n             self.expect_semi()?;\n             *sig_hi = self.prev_token.span;\n-            (Vec::new(), None)\n+            (AttrVec::new(), None)\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) || self.token.is_whole_block() {\n             self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n         } else if self.token.kind == token::Eq {\n@@ -2034,7 +2034,7 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            (Vec::new(), Some(self.mk_block_err(span)))\n+            (AttrVec::new(), Some(self.mk_block_err(span)))\n         } else {\n             let expected = if req_body {\n                 &[token::OpenDelim(Delimiter::Brace)][..]\n@@ -2051,7 +2051,7 @@ impl<'a> Parser<'a> {\n                     return Err(err);\n                 }\n             }\n-            (Vec::new(), None)\n+            (AttrVec::new(), None)\n         };\n         attrs.extend(inner_attrs);\n         Ok(body)\n@@ -2280,7 +2280,7 @@ impl<'a> Parser<'a> {\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n             if let Some(mut param) = this.parse_self_param()? {\n-                param.attrs = attrs.into();\n+                param.attrs = attrs;\n                 let res = if first_param { Ok(param) } else { this.recover_bad_self_param(param) };\n                 return Ok((res?, TrailingToken::None));\n             }\n@@ -2341,14 +2341,7 @@ impl<'a> Parser<'a> {\n             let span = lo.to(this.prev_token.span);\n \n             Ok((\n-                Param {\n-                    attrs: attrs.into(),\n-                    id: ast::DUMMY_NODE_ID,\n-                    is_placeholder: false,\n-                    pat,\n-                    span,\n-                    ty,\n-                },\n+                Param { attrs, id: ast::DUMMY_NODE_ID, is_placeholder: false, pat, span, ty },\n                 TrailingToken::None,\n             ))\n         })"}, {"sha": "8b3200d45fccd76b99b17ebebf0150cdf47eee89", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -4,8 +4,8 @@ use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n-    self as ast, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField,\n-    PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n+    self as ast, AttrVec, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField, PatKind,\n+    Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -1093,7 +1093,7 @@ impl<'a> Parser<'a> {\n             .emit();\n     }\n \n-    fn parse_pat_field(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, PatField> {\n+    fn parse_pat_field(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, PatField> {\n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let hi;\n         let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n@@ -1134,7 +1134,7 @@ impl<'a> Parser<'a> {\n             ident: fieldname,\n             pat: subpat,\n             is_shorthand,\n-            attrs: attrs.into(),\n+            attrs,\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n             is_placeholder: false,"}, {"sha": "3d957406b19d88a98d844962967fb53fb6ea064b", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -130,7 +130,7 @@ impl<'a> Parser<'a> {\n             let path = this.parse_path(PathStyle::Expr)?;\n \n             if this.eat(&token::Not) {\n-                let stmt_mac = this.parse_stmt_mac(lo, attrs.into(), path)?;\n+                let stmt_mac = this.parse_stmt_mac(lo, attrs, path)?;\n                 if this.token == token::Semi {\n                     return Ok((stmt_mac, TrailingToken::Semi));\n                 } else {\n@@ -190,7 +190,7 @@ impl<'a> Parser<'a> {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n-            let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n             StmtKind::Expr(e)\n         };\n@@ -229,7 +229,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Stmt> {\n         self.collect_tokens_trailing_token(attrs, force_collect, |this, attrs| {\n             this.expect_keyword(kw::Let)?;\n-            let local = this.parse_local(attrs.into())?;\n+            let local = this.parse_local(attrs)?;\n             let trailing = if capture_semi && this.token.kind == token::Semi {\n                 TrailingToken::Semi\n             } else {\n@@ -241,7 +241,7 @@ impl<'a> Parser<'a> {\n \n     fn recover_local_after_let(&mut self, lo: Span, attrs: AttrWrapper) -> PResult<'a, Stmt> {\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n-            let local = this.parse_local(attrs.into())?;\n+            let local = this.parse_local(attrs)?;\n             // FIXME - maybe capture semicolon in recovery?\n             Ok((\n                 this.mk_stmt(lo.to(this.prev_token.span), StmtKind::Local(local)),\n@@ -509,9 +509,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. Inner attributes are allowed.\n-    pub(super) fn parse_inner_attrs_and_block(\n-        &mut self,\n-    ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+    pub(super) fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (AttrVec, P<Block>)> {\n         self.parse_block_common(self.token.span, BlockCheckMode::Default)\n     }\n \n@@ -520,8 +518,8 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-    ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n-        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n+    ) -> PResult<'a, (AttrVec, P<Block>)> {\n+        maybe_whole!(self, NtBlock, |x| (AttrVec::new(), x));\n \n         self.maybe_recover_unexpected_block_label();\n         if !self.eat(&token::OpenDelim(Delimiter::Brace)) {"}, {"sha": "4c39021903c5b185790b2ed7e53b5817d69f362e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -1130,7 +1130,7 @@ pub struct RenderedLink {\n #[derive(Clone, Debug, Default)]\n pub(crate) struct Attributes {\n     pub(crate) doc_strings: Vec<DocFragment>,\n-    pub(crate) other_attrs: Vec<ast::Attribute>,\n+    pub(crate) other_attrs: ast::AttrVec,\n }\n \n impl Attributes {\n@@ -1173,7 +1173,7 @@ impl Attributes {\n         doc_only: bool,\n     ) -> Attributes {\n         let mut doc_strings = Vec::new();\n-        let mut other_attrs = Vec::new();\n+        let mut other_attrs = ast::AttrVec::new();\n         for (attr, parent_module) in attrs {\n             if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n                 trace!(\"got doc_str={doc_str:?}\");"}, {"sha": "117b798710cf00570fee91785d61787f65d091e8", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -30,7 +30,6 @@ use rustc_ast::mut_visit::{self, visit_clobber, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_parse::new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::FilePathMapping;\n@@ -47,7 +46,7 @@ fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n \n // Helper functions for building exprs\n fn expr(kind: ExprKind) -> P<Expr> {\n-    P(Expr { id: DUMMY_NODE_ID, kind, span: DUMMY_SP, attrs: ThinVec::new(), tokens: None })\n+    P(Expr { id: DUMMY_NODE_ID, kind, span: DUMMY_SP, attrs: AttrVec::new(), tokens: None })\n }\n \n fn make_x() -> P<Expr> {\n@@ -196,7 +195,7 @@ impl MutVisitor for AddParens {\n                 id: DUMMY_NODE_ID,\n                 kind: ExprKind::Paren(e),\n                 span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n                 tokens: None,\n             })\n         });"}, {"sha": "eb828bb9a2c179352d4e46b65dc26df8ef57fd68", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -4,74 +4,74 @@ PRE EXPANSION AST STATS\n Name                Accumulated Size         Count     Item Size\n ----------------------------------------------------------------\n ExprField                 48 ( 0.6%)             1            48\n-Attribute                 64 ( 0.7%)             2            32\n+Crate                     56 ( 0.7%)             1            56\n+Attribute                 64 ( 0.8%)             2            32\n - Normal                    32 ( 0.4%)             1\n - DocComment                32 ( 0.4%)             1\n-GenericArgs               64 ( 0.7%)             1            64\n-- AngleBracketed            64 ( 0.7%)             1\n-Local                     72 ( 0.8%)             1            72\n-WherePredicate            72 ( 0.8%)             1            72\n-- BoundPredicate            72 ( 0.8%)             1\n-Crate                     72 ( 0.8%)             1            72\n+GenericArgs               64 ( 0.8%)             1            64\n+- AngleBracketed            64 ( 0.8%)             1\n+Local                     72 ( 0.9%)             1            72\n+WherePredicate            72 ( 0.9%)             1            72\n+- BoundPredicate            72 ( 0.9%)             1\n Arm                       96 ( 1.1%)             2            48\n-ForeignItem              112 ( 1.3%)             1           112\n-- Fn                       112 ( 1.3%)             1\n-FieldDef                 160 ( 1.8%)             2            80\n-Stmt                     160 ( 1.8%)             5            32\n+ForeignItem               96 ( 1.1%)             1            96\n+- Fn                        96 ( 1.1%)             1\n+FieldDef                 160 ( 1.9%)             2            80\n+Stmt                     160 ( 1.9%)             5            32\n - Local                     32 ( 0.4%)             1\n - MacCall                   32 ( 0.4%)             1\n - Expr                      96 ( 1.1%)             3\n-Param                    160 ( 1.8%)             4            40\n-FnDecl                   200 ( 2.3%)             5            40\n+Param                    160 ( 1.9%)             4            40\n+FnDecl                   200 ( 2.4%)             5            40\n Variant                  240 ( 2.8%)             2           120\n-Block                    288 ( 3.3%)             6            48\n-GenericBound             352 ( 4.0%)             4            88\n-- Trait                    352 ( 4.0%)             4\n-AssocItem                480 ( 5.5%)             4           120\n-- TyAlias                  240 ( 2.8%)             2\n-- Fn                       240 ( 2.8%)             2\n-GenericParam             520 ( 6.0%)             5           104\n-PathSegment              720 ( 8.3%)            30            24\n-Expr                     832 ( 9.6%)             8           104\n+Block                    288 ( 3.4%)             6            48\n+GenericBound             352 ( 4.2%)             4            88\n+- Trait                    352 ( 4.2%)             4\n+AssocItem                416 ( 4.9%)             4           104\n+- TyAlias                  208 ( 2.5%)             2\n+- Fn                       208 ( 2.5%)             2\n+GenericParam             520 ( 6.1%)             5           104\n+PathSegment              720 ( 8.5%)            30            24\n+Expr                     832 ( 9.8%)             8           104\n - Path                     104 ( 1.2%)             1\n - Match                    104 ( 1.2%)             1\n - Struct                   104 ( 1.2%)             1\n-- Lit                      208 ( 2.4%)             2\n-- Block                    312 ( 3.6%)             3\n-Pat                      840 ( 9.7%)             7           120\n+- Lit                      208 ( 2.5%)             2\n+- Block                    312 ( 3.7%)             3\n+Pat                      840 ( 9.9%)             7           120\n - Struct                   120 ( 1.4%)             1\n - Wild                     120 ( 1.4%)             1\n-- Ident                    600 ( 6.9%)             5\n-Ty                     1_344 (15.5%)            14            96\n+- Ident                    600 ( 7.1%)             5\n+Ty                     1_344 (15.9%)            14            96\n - Rptr                      96 ( 1.1%)             1\n - Ptr                       96 ( 1.1%)             1\n-- ImplicitSelf             192 ( 2.2%)             2\n-- Path                     960 (11.0%)            10\n-Item                   1_800 (20.7%)             9           200\n-- Trait                    200 ( 2.3%)             1\n-- Enum                     200 ( 2.3%)             1\n-- ForeignMod               200 ( 2.3%)             1\n-- Impl                     200 ( 2.3%)             1\n-- Fn                       400 ( 4.6%)             2\n-- Use                      600 ( 6.9%)             3\n+- ImplicitSelf             192 ( 2.3%)             2\n+- Path                     960 (11.4%)            10\n+Item                   1_656 (19.6%)             9           184\n+- Trait                    184 ( 2.2%)             1\n+- Enum                     184 ( 2.2%)             1\n+- ForeignMod               184 ( 2.2%)             1\n+- Impl                     184 ( 2.2%)             1\n+- Fn                       368 ( 4.4%)             2\n+- Use                      552 ( 6.5%)             3\n ----------------------------------------------------------------\n-Total                  8_696\n+Total                  8_456\n \n \n POST EXPANSION AST STATS\n \n Name                Accumulated Size         Count     Item Size\n ----------------------------------------------------------------\n ExprField                 48 ( 0.5%)             1            48\n+Crate                     56 ( 0.6%)             1            56\n GenericArgs               64 ( 0.7%)             1            64\n - AngleBracketed            64 ( 0.7%)             1\n Local                     72 ( 0.8%)             1            72\n WherePredicate            72 ( 0.8%)             1            72\n - BoundPredicate            72 ( 0.8%)             1\n-Crate                     72 ( 0.8%)             1            72\n Arm                       96 ( 1.0%)             2            48\n-ForeignItem              112 ( 1.2%)             1           112\n-- Fn                       112 ( 1.2%)             1\n+ForeignItem               96 ( 1.0%)             1            96\n+- Fn                        96 ( 1.0%)             1\n InlineAsm                120 ( 1.3%)             1           120\n Attribute                128 ( 1.4%)             4            32\n - DocComment                32 ( 0.3%)             1\n@@ -82,42 +82,42 @@ Stmt                     160 ( 1.7%)             5            32\n - Semi                      32 ( 0.3%)             1\n - Expr                      96 ( 1.0%)             3\n Param                    160 ( 1.7%)             4            40\n-FnDecl                   200 ( 2.1%)             5            40\n-Variant                  240 ( 2.5%)             2           120\n-Block                    288 ( 3.0%)             6            48\n-GenericBound             352 ( 3.7%)             4            88\n-- Trait                    352 ( 3.7%)             4\n-AssocItem                480 ( 5.1%)             4           120\n-- TyAlias                  240 ( 2.5%)             2\n-- Fn                       240 ( 2.5%)             2\n-GenericParam             520 ( 5.5%)             5           104\n-PathSegment              792 ( 8.4%)            33            24\n-Pat                      840 ( 8.9%)             7           120\n+FnDecl                   200 ( 2.2%)             5            40\n+Variant                  240 ( 2.6%)             2           120\n+Block                    288 ( 3.1%)             6            48\n+GenericBound             352 ( 3.8%)             4            88\n+- Trait                    352 ( 3.8%)             4\n+AssocItem                416 ( 4.5%)             4           104\n+- TyAlias                  208 ( 2.3%)             2\n+- Fn                       208 ( 2.3%)             2\n+GenericParam             520 ( 5.7%)             5           104\n+PathSegment              792 ( 8.6%)            33            24\n+Pat                      840 ( 9.1%)             7           120\n - Struct                   120 ( 1.3%)             1\n - Wild                     120 ( 1.3%)             1\n-- Ident                    600 ( 6.3%)             5\n-Expr                     936 ( 9.9%)             9           104\n+- Ident                    600 ( 6.5%)             5\n+Expr                     936 (10.2%)             9           104\n - Path                     104 ( 1.1%)             1\n - Match                    104 ( 1.1%)             1\n - Struct                   104 ( 1.1%)             1\n - InlineAsm                104 ( 1.1%)             1\n-- Lit                      208 ( 2.2%)             2\n-- Block                    312 ( 3.3%)             3\n-Ty                     1_344 (14.2%)            14            96\n+- Lit                      208 ( 2.3%)             2\n+- Block                    312 ( 3.4%)             3\n+Ty                     1_344 (14.6%)            14            96\n - Rptr                      96 ( 1.0%)             1\n - Ptr                       96 ( 1.0%)             1\n-- ImplicitSelf             192 ( 2.0%)             2\n-- Path                     960 (10.2%)            10\n-Item                   2_200 (23.3%)            11           200\n-- Trait                    200 ( 2.1%)             1\n-- Enum                     200 ( 2.1%)             1\n-- ExternCrate              200 ( 2.1%)             1\n-- ForeignMod               200 ( 2.1%)             1\n-- Impl                     200 ( 2.1%)             1\n-- Fn                       400 ( 4.2%)             2\n-- Use                      800 ( 8.5%)             4\n+- ImplicitSelf             192 ( 2.1%)             2\n+- Path                     960 (10.5%)            10\n+Item                   2_024 (22.0%)            11           184\n+- Trait                    184 ( 2.0%)             1\n+- Enum                     184 ( 2.0%)             1\n+- ExternCrate              184 ( 2.0%)             1\n+- ForeignMod               184 ( 2.0%)             1\n+- Impl                     184 ( 2.0%)             1\n+- Fn                       368 ( 4.0%)             2\n+- Use                      736 ( 8.0%)             4\n ----------------------------------------------------------------\n-Total                  9_456\n+Total                  9_184\n \n \n HIR STATS"}, {"sha": "f5c1ee5fdd12130d28e470299c246d0846de8ef5", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -49,10 +49,7 @@ pub(crate) fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n }\n \n /// Returns attributes that are within `outer_span`.\n-pub(crate) fn filter_inline_attrs(\n-    attrs: &[ast::Attribute],\n-    outer_span: Span,\n-) -> Vec<ast::Attribute> {\n+pub(crate) fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> ast::AttrVec {\n     attrs\n         .iter()\n         .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())"}, {"sha": "b6530c69243ed1c16c056cffdc358763fb7b8e15", "filename": "src/tools/rustfmt/src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -116,7 +116,7 @@ pub(crate) struct UseTree {\n     // Additional fields for top level use items.\n     // Should we have another struct for top-level use items rather than reusing this?\n     visibility: Option<ast::Visibility>,\n-    attrs: Option<Vec<ast::Attribute>>,\n+    attrs: Option<ast::AttrVec>,\n }\n \n impl PartialEq for UseTree {\n@@ -417,7 +417,7 @@ impl UseTree {\n         list_item: Option<ListItem>,\n         visibility: Option<ast::Visibility>,\n         opt_lo: Option<BytePos>,\n-        attrs: Option<Vec<ast::Attribute>>,\n+        attrs: Option<ast::AttrVec>,\n     ) -> UseTree {\n         let span = if let Some(lo) = opt_lo {\n             mk_sp(lo, a.span.hi())"}, {"sha": "7a0d1736c59a66ae729b9305bb049c71921d925c", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -26,7 +26,7 @@ type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n pub(crate) struct Module<'a> {\n     ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n     pub(crate) items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n-    inner_attr: Vec<ast::Attribute>,\n+    inner_attr: ast::AttrVec,\n     pub(crate) span: Span,\n }\n \n@@ -35,7 +35,7 @@ impl<'a> Module<'a> {\n         mod_span: Span,\n         ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n         mod_items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n-        mod_attrs: Cow<'a, Vec<ast::Attribute>>,\n+        mod_attrs: Cow<'a, ast::AttrVec>,\n     ) -> Self {\n         let inner_attr = mod_attrs\n             .iter()\n@@ -158,7 +158,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         module_item.item.span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n                         Cow::Owned(vec![]),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n             }\n@@ -185,7 +185,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                         span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n                         Cow::Owned(vec![]),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n             }"}, {"sha": "e0bd065518b3db5f7e9016ba428e755086c8a923", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce46b74aa3968b459cff3ce5c0d4f13e220b217/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=3ce46b74aa3968b459cff3ce5c0d4f13e220b217", "patch": "@@ -109,7 +109,7 @@ impl<'a> Parser<'a> {\n         sess: &'a ParseSess,\n         path: &Path,\n         span: Span,\n-    ) -> Result<(Vec<ast::Attribute>, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n+    ) -> Result<(ast::AttrVec, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n         let result = catch_unwind(AssertUnwindSafe(|| {\n             let mut parser = new_parser_from_file(sess.inner(), path, Some(span));\n             match parser.parse_mod(&TokenKind::Eof) {"}]}