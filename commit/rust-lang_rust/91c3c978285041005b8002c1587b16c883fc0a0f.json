{"sha": "91c3c978285041005b8002c1587b16c883fc0a0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYzNjOTc4Mjg1MDQxMDA1YjgwMDJjMTU4N2IxNmM4ODNmYzBhMGY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-01T19:54:42Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-01T19:54:42Z"}, "message": "Merge pull request #274 from birkenfeld/copy_fix\n\nmethods: try to allow value self when type is Copy (fixes #273)", "tree": {"sha": "a795b8526074d3c48a7aba393a6d401ddfb72561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a795b8526074d3c48a7aba393a6d401ddfb72561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91c3c978285041005b8002c1587b16c883fc0a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91c3c978285041005b8002c1587b16c883fc0a0f", "html_url": "https://github.com/rust-lang/rust/commit/91c3c978285041005b8002c1587b16c883fc0a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91c3c978285041005b8002c1587b16c883fc0a0f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718da74c9f0add88bae471a40f973ecb6a17c43d", "url": "https://api.github.com/repos/rust-lang/rust/commits/718da74c9f0add88bae471a40f973ecb6a17c43d", "html_url": "https://github.com/rust-lang/rust/commit/718da74c9f0add88bae471a40f973ecb6a17c43d"}, {"sha": "5264196538a36d21d2666b9e5f1584c3806111ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/5264196538a36d21d2666b9e5f1584c3806111ba", "html_url": "https://github.com/rust-lang/rust/commit/5264196538a36d21d2666b9e5f1584c3806111ba"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "d55cf49daabab04073c5614de4ccc7fd48b25412", "filename": "src/methods.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91c3c978285041005b8002c1587b16c883fc0a0f/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c3c978285041005b8002c1587b16c883fc0a0f/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=91c3c978285041005b8002c1587b16c883fc0a0f", "patch": "@@ -68,28 +68,29 @@ impl LintPass for MethodsPass {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-        if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n-            for item in items {\n-                let name = item.ident.name;\n-                if let MethodImplItem(ref sig, _) = item.node {\n+        if let ItemImpl(_, _, _, None, ref ty, ref items) = item.node {\n+            for implitem in items {\n+                let name = implitem.ident.name;\n+                if let MethodImplItem(ref sig, _) = implitem.node {\n                     // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if_let_chain! {\n                             [\n                                 name == method_name,\n                                 sig.decl.inputs.len() == n_args,\n                                 out_type.matches(&sig.decl.output),\n-                                self_kind.matches(&sig.explicit_self.node)\n+                                self_kind.matches(&sig.explicit_self.node, false)\n                             ], {\n-                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n+                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                                     \"defining a method called `{}` on this type; consider implementing \\\n                                      the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n                             }\n                         }\n                     }\n                     // check conventions w.r.t. conversion method names and predicates\n                     for &(prefix, self_kind) in &CONVENTIONS {\n-                        if name.as_str().starts_with(prefix) && !self_kind.matches(&sig.explicit_self.node) {\n+                        if name.as_str().starts_with(prefix) &&\n+                                !self_kind.matches(&sig.explicit_self.node, is_copy(cx, &ty, &item)) {\n                             span_lint(cx, WRONG_SELF_CONVENTION, sig.explicit_self.span, &format!(\n                                 \"methods called `{}*` usually take {}; consider choosing a less \\\n                                  ambiguous name\", prefix, self_kind.description()));\n@@ -151,22 +152,26 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(&self, slf: &ExplicitSelf_) -> bool {\n+    fn matches(&self, slf: &ExplicitSelf_, allow_value_for_ref: bool) -> bool {\n         match (self, slf) {\n             (&ValueSelf, &SelfValue(_)) => true,\n             (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n             (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n+            (&RefSelf, &SelfValue(_)) => allow_value_for_ref,\n+            (&RefMutSelf, &SelfValue(_)) => allow_value_for_ref,\n             (&NoSelf, &SelfStatic) => true,\n-            (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty),\n+            (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false\n         }\n     }\n \n-    fn matches_explicit_type(&self, ty: &Ty) -> bool {\n+    fn matches_explicit_type(&self, ty: &Ty, allow_value_for_ref: bool) -> bool {\n         match (self, &ty.node) {\n             (&ValueSelf, &TyPath(..)) => true,\n             (&RefSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) => true,\n             (&RefMutSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n+            (&RefSelf, &TyPath(..)) => allow_value_for_ref,\n+            (&RefMutSelf, &TyPath(..)) => allow_value_for_ref,\n             _ => false\n         }\n     }\n@@ -212,3 +217,13 @@ fn is_bool(ty: &Ty) -> bool {\n     }\n     false\n }\n+\n+fn is_copy(cx: &Context, ast_ty: &Ty, item: &Item) -> bool {\n+    match cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+        None => false,\n+        Some(ty) => {\n+            let env = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n+            !ty.moves_by_default(&env, ast_ty.span)\n+        }\n+    }\n+}"}, {"sha": "314601f6dbd3662435898de04a0223363403d8ba", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91c3c978285041005b8002c1587b16c883fc0a0f/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c3c978285041005b8002c1587b16c883fc0a0f/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=91c3c978285041005b8002c1587b16c883fc0a0f", "patch": "@@ -18,6 +18,15 @@ impl T {\n \n     fn into_u32(self) -> u32 { 0 } // fine\n     fn into_u16(&self) -> u16 { 0 } //~ERROR methods called `into_*` usually take self by value\n+\n+    fn to_something(self) -> u32 { 0 } //~ERROR methods called `to_*` usually take self by reference\n+}\n+\n+#[derive(Clone,Copy)]\n+struct U;\n+\n+impl U {\n+    fn to_something(self) -> u32 { 0 } // ok because U is Copy\n }\n \n impl Mul<T> for T {"}]}