{"sha": "09c4569c87f813773f00d30ad3ce4df94416e56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YzQ1NjljODdmODEzNzczZjAwZDMwYWQzY2U0ZGY5NDQxNmU1NmY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-17T17:07:27Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-26T10:59:57Z"}, "message": "Implement line debuginfo", "tree": {"sha": "b42c964eb56ae7bba51013f1dd1759e789633b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b42c964eb56ae7bba51013f1dd1759e789633b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09c4569c87f813773f00d30ad3ce4df94416e56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09c4569c87f813773f00d30ad3ce4df94416e56f", "html_url": "https://github.com/rust-lang/rust/commit/09c4569c87f813773f00d30ad3ce4df94416e56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09c4569c87f813773f00d30ad3ce4df94416e56f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e609db886864cfc324fa54df98f04b006ec994b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e609db886864cfc324fa54df98f04b006ec994b", "html_url": "https://github.com/rust-lang/rust/commit/9e609db886864cfc324fa54df98f04b006ec994b"}], "stats": {"total": 710, "additions": 691, "deletions": 19}, "files": [{"sha": "c4f89330377fc75b90ef6d77f52614341f47b024", "filename": "Cargo.lock", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -22,6 +22,14 @@ dependencies = [\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.4.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.11\"\n@@ -284,6 +292,11 @@ dependencies = [\n  \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"fallible-iterator\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"fuchsia-zircon\"\n version = \"0.3.3\"\n@@ -303,6 +316,18 @@ name = \"gcc\"\n version = \"0.3.55\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"gimli\"\n+version = \"0.16.1\"\n+source = \"git+https://github.com/bjorn3/gimli.git?branch=impl_range_write#ff96c190bbb7a41623f009c969cb7ecd7a2716f4\"\n+dependencies = [\n+ \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fallible-iterator 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"goblin\"\n version = \"0.0.19\"\n@@ -375,6 +400,11 @@ dependencies = [\n  \"version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"nodrop\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"plain\"\n version = \"0.2.3\"\n@@ -565,6 +595,8 @@ dependencies = [\n  \"cranelift-module 0.26.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-simplejit 0.26.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"faerie 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gimli 0.16.1 (git+https://github.com/bjorn3/gimli.git?branch=impl_range_write)\",\n  \"libc 0.2.47 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"target-lexicon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -630,6 +662,11 @@ dependencies = [\n  \"serde 1.0.84 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"string-interner\"\n version = \"0.6.3\"\n@@ -816,6 +853,7 @@ dependencies = [\n \"checksum aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e9a933f4e58658d7b12defcf96dc5c720f20832deebe3e0a19efd3b6aaeeb9e\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum ar 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"579681b3fecd1e9d6b5ce6969e05f9feb913f296eddaf595be1166a5ca597bc4\"\n+\"checksum arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c7fb76bc8826a8b33b4ee5bb07a247a81e76764ab4d55e8f73e3a4d8808c71\"\n \"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n \"checksum autocfg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6d640bee2da49f60a4068a7fae53acde8982514ab7bae8b8cea9e88cbcfd799\"\n \"checksum backtrace 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b5b493b66e03090ebc4343eb02f94ff944e0cbc9ac6571491d170ba026741eb5\"\n@@ -843,9 +881,11 @@ dependencies = [\n \"checksum faerie 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"142ee8f6d2864117a92855815e710b03087763df41ab3c6a97ca25e00e178b98\"\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n+\"checksum fallible-iterator 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb7217124812dc5672b7476d0c2d20cfe9f7c0f1ba0904b674a9762a0212f72e\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum gcc 0.3.55 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2\"\n+\"checksum gimli 0.16.1 (git+https://github.com/bjorn3/gimli.git?branch=impl_range_write)\" = \"<none>\"\n \"checksum goblin 0.0.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c65cd533b33e3d04c6e393225fa8919ddfcf5862ca8919c7f9a167c312ef41c2\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ca7e5f2e110db35f93b837c81797f3714500b81d517bf20c431b16d3ca4f114\"\n@@ -856,6 +896,7 @@ dependencies = [\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n \"checksum mach 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86dd2487cdfea56def77b88438a2c915fb45113c5319bfe7e14306ca4cd0b0e1\"\n \"checksum memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db4c41318937f6e76648f42826b1d9ade5c09cafb5aef7e351240a70f39206e9\"\n+\"checksum nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9667ddcc6cc8a43afc9b7917599d7216aa09c463919ea32c59ed6cac8bc945\"\n \"checksum plain 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n \"checksum proc-macro2 0.4.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3797b7142c9aa74954e351fc089bbee7958cebbff6bf2815e7ffff0b19f547d\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n@@ -885,6 +926,7 @@ dependencies = [\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.84 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e732ed5a5592c17d961555e3b552985baf98d50ce418b7b655f31f6ba7eb1b7\"\n \"checksum serde_json 1.0.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"574378d957d6dcdf1bbb5d562a15cbd5e644159432f84634b94e485267abbcc7\"\n+\"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n \"checksum string-interner 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abb38a0d8fe673c40b10b6b75abcb076a958cc10fb894f14993d9737c4c87000\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum structopt 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"670ad348dc73012fcf78c71f06f9d942232cdd4c859d4b6975e27836c3efc0c3\""}, {"sha": "30824626feb26054f902f7d8ba1b46c65811fc8f", "filename": "Cargo.toml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -23,10 +23,12 @@ target-lexicon = \"0.2.0\"\n #goblin = \"0.0.17\"\n ar = \"0.6.1\"\n bitflags = \"1.0.3\"\n-byteorder = \"1.2.6\"\n+byteorder = \"1.2.7\"\n libc = \"0.2.45\"\n tempfile = \"3.0.4\"\n env_logger = \"0.6\"\n+gimli = { git = \"https://github.com/gimli-rs/gimli.git\" }\n+faerie = \"0.7.1\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/CraneStation/cranelift.git\"]\n@@ -35,5 +37,8 @@ env_logger = \"0.6\"\n #cranelift-simplejit = { path = \"../cranelift/lib/simplejit\" }\n #cranelift-faerie = { path = \"../cranelift/lib/faerie\" }\n \n+[patch.\"https://github.com/gimli-rs/gimli.git\"]\n+gimli = { git = \"https://github.com/bjorn3/gimli.git\", branch = \"impl_range_write\" }\n+\n [profile.dev.overrides.\"*\"]\n opt-level = 3"}, {"sha": "7f131fdd8fd78906b4fb5986a0b3c37f87c1d16a", "filename": "abc.cpp", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/abc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/abc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/abc.cpp?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -0,0 +1,35 @@\n+// compile using g++ -std=c++11 -g -c abc.cpp -o abc.o\n+\n+struct Opaque;\n+\n+struct MyType {\n+    unsigned int field_a;\n+    int field_b;\n+    void* field_c;\n+    float field_d;\n+    //double field_e;\n+    //long long field_f;\n+    bool field_g;\n+    char field_h;\n+    Opaque* field_i;\n+};\n+\n+MyType bcd(int x, MyType a) {\n+    MyType b = a;\n+    MyType c = b;\n+    MyType d = c;\n+    MyType e = d;\n+    MyType f = e;\n+    MyType g = f;\n+    MyType h = g;\n+    MyType i = h;\n+    MyType j = i;\n+    MyType k = j;\n+    MyType l = k;\n+    MyType m = l;\n+    return b;\n+}\n+int main() {\n+    bcd(42, {});\n+    return 0;\n+}"}, {"sha": "638db7d24ef95ce5a5f61c9775adbe137705e96e", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -115,7 +115,18 @@ struct Unique<T: ?Sized> {\n \n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n+fn take_f32(f: f32) {}\n+fn take_unique(u: Unique<()>) {}\n+\n fn main() {\n+    take_unique(Unique {\n+        pointer: 0 as *const (),\n+        _marker: PhantomData,\n+    });\n+    take_f32(0.1);\n+\n+    //return;\n+\n     unsafe {\n         let hello: &[u8] = b\"Hello\\0\" as &[u8; 6];\n         let ptr: *const u8 = hello as *const [u8] as *const u8;"}, {"sha": "f7f7af4b14465a76582bda46c9483476c13a1032", "filename": "mini_core_hello_world", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/mini_core_hello_world", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/mini_core_hello_world", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini_core_hello_world?ref=09c4569c87f813773f00d30ad3ce4df94416e56f"}, {"sha": "698a31312fc54882c4fbe8cdf73286b9ac888efd", "filename": "src/base.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -69,6 +69,13 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n     let func_id = cx.module\n         .declare_function(&name, linkage, &sig)\n         .unwrap();\n+    let mut debug_context = cx.debug_context.as_mut().map(|debug_context| FunctionDebugContext::new(\n+        tcx,\n+        debug_context,\n+        mir,\n+        &name,\n+        &sig,\n+    ));\n \n     // Step 3. Make FunctionBuilder\n     let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -101,13 +108,15 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         clif_comments,\n         constants: &mut cx.ccx,\n         caches: &mut cx.caches,\n+        spans: Vec::new(),\n     };\n \n     // Step 6. Codegen function\n     with_unimpl_span(fx.mir.span, || {\n         crate::abi::codegen_fn_prelude(&mut fx, start_ebb);\n         codegen_fn_content(&mut fx);\n     });\n+    let spans = fx.spans.clone();\n \n     // Step 7. Write function to file for debugging\n     #[cfg(debug_assertions)]\n@@ -119,8 +128,12 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n     // Step 9. Define function\n     cx.caches.context.func = func;\n     cx.module\n-        .define_function(func_id, &mut cx.caches.context)\n+        .define_function_peek_compiled(func_id, &mut cx.caches.context, |size, context, isa| {\n+            debug_context.as_mut().map(|x| x.define(tcx, size, context, isa, &spans[..]));\n+        })\n         .unwrap();\n+    //let module = &mut cx.module;\n+    //let caches = &cx.caches;\n     cx.caches.context.clear();\n }\n \n@@ -154,6 +167,7 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n \n         fx.bcx.ins().nop();\n         for stmt in &bb_data.statements {\n+            fx.set_debug_loc(stmt.source_info);\n             trans_stmt(fx, ebb, stmt);\n         }\n \n@@ -169,6 +183,8 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n             fx.add_comment(inst, terminator_head);\n         }\n \n+        fx.set_debug_loc(bb_data.terminator().source_info);\n+\n         match &bb_data.terminator().kind {\n             TerminatorKind::Goto { target } => {\n                 let ebb = fx.get_ebb(*target);\n@@ -322,6 +338,8 @@ fn trans_stmt<'a, 'tcx: 'a>(\n ) {\n     let _print_guard = PrintOnPanic(|| format!(\"stmt {:?}\", stmt));\n \n+    fx.set_debug_loc(stmt.source_info);\n+\n     #[cfg(debug_assertions)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful"}, {"sha": "ded45af6d5e987f3937e725d2763e95f81014ea9", "filename": "src/common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -539,6 +539,7 @@ pub struct FunctionCx<'a, 'tcx: 'a, B: Backend> {\n     pub clif_comments: crate::pretty_clif::CommentWriter,\n     pub constants: &'a mut crate::constant::ConstantCx,\n     pub caches: &'a mut Caches<'tcx>,\n+    pub spans: Vec<Span>,\n }\n \n impl<'a, 'tcx: 'a, B: Backend + 'a> fmt::Debug for FunctionCx<'a, 'tcx, B> {\n@@ -617,4 +618,11 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     pub fn get_local_place(&mut self, local: Local) -> CPlace<'tcx> {\n         *self.local_map.get(&local).unwrap()\n     }\n+\n+    pub fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n+        // FIXME: record scope too\n+        let index = self.spans.len() as u32;\n+        self.spans.push(source_info.span);\n+        self.bcx.set_srcloc(SourceLoc::new(index));\n+    }\n }"}, {"sha": "f4744f6b7becd63d945280cb0a99fcdd260170bd", "filename": "src/debuginfo.rs", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -0,0 +1,529 @@\n+extern crate gimli;\n+\n+use crate::prelude::*;\n+\n+use std::marker::PhantomData;\n+\n+use gimli::write::{\n+    Address, AttributeValue, CompilationUnit, DebugAbbrev, DebugInfo, DebugLine, DebugRanges,\n+    DebugRngLists, DebugStr, EndianVec, LineProgram, LineProgramId, LineProgramTable, Range,\n+    RangeList, RangesTable, Result, SectionId, StringTable, UnitEntryId, UnitId, UnitTable, Writer,\n+};\n+use gimli::Format;\n+\n+// FIXME: use target endian\n+use byteorder::ByteOrder;\n+use gimli::RunTimeEndian;\n+\n+use faerie::*;\n+\n+fn target_endian(tcx: TyCtxt) -> RunTimeEndian {\n+    use rustc::ty::layout::Endian;\n+\n+    match tcx.data_layout.endian {\n+        Endian::Big => RunTimeEndian::Big,\n+        Endian::Little => RunTimeEndian::Little,\n+    }\n+}\n+struct DebugReloc {\n+    offset: u32,\n+    size: u8,\n+    name: String,\n+    addend: i64,\n+}\n+\n+pub struct DebugContext<'tcx> {\n+    endian: RunTimeEndian,\n+    format: Format,\n+    version: u16,\n+    address_size: u8,\n+\n+    strings: StringTable,\n+    units: UnitTable,\n+    unit_id: UnitId,\n+    line_programs: LineProgramTable,\n+    global_line_program: LineProgramId,\n+    ranges: RangesTable,\n+    unit_ranges: RangeList,\n+    symbol_names: Vec<String>,\n+\n+    _dummy: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n+    pub fn new(tcx: TyCtxt, address_size: u8) -> Self {\n+        // TODO: this should be configurable\n+        let version = 4;\n+        let format = Format::Dwarf32;\n+\n+        // FIXME: how to get version when building out of tree?\n+        // Normally this would use option_env!(\"CFG_VERSION\").\n+        let producer = format!(\"cranelift fn (rustc version {})\", \"unknown version\");\n+        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n+        let name = match tcx.sess.local_crate_source_file {\n+            Some(ref path) => path.to_string_lossy().into_owned(),\n+            None => tcx.crate_name(LOCAL_CRATE).to_string(),\n+        };\n+\n+        let mut units = UnitTable::default();\n+        let mut strings = StringTable::default();\n+        let mut line_programs = LineProgramTable::default();\n+        let ranges = RangesTable::default();\n+\n+        let global_line_program = line_programs.add(LineProgram::new(\n+            version,\n+            address_size,\n+            format,\n+            1,\n+            1,\n+            -5,\n+            14,\n+            comp_dir.as_bytes(),\n+            name.as_bytes(),\n+            None,\n+        ));\n+\n+        let unit_id = units.add(CompilationUnit::new(version, address_size, format));\n+        {\n+            let name = strings.add(&*name);\n+            let comp_dir = strings.add(&*comp_dir);\n+\n+            let unit = units.get_mut(unit_id);\n+            let root = unit.root();\n+            let root = unit.get_mut(root);\n+            root.set(\n+                gimli::DW_AT_producer,\n+                AttributeValue::StringRef(strings.add(producer)),\n+            );\n+            root.set(\n+                gimli::DW_AT_language,\n+                AttributeValue::Language(gimli::DW_LANG_Rust),\n+            );\n+            root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n+            root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n+            root.set(\n+                gimli::DW_AT_stmt_list,\n+                AttributeValue::LineProgramRef(global_line_program),\n+            );\n+            root.set(\n+                gimli::DW_AT_low_pc,\n+                AttributeValue::Address(Address::Absolute(0)),\n+            );\n+        }\n+\n+        DebugContext {\n+            endian: target_endian(tcx),\n+            format,\n+            version,\n+            address_size,\n+\n+            strings,\n+            units,\n+            unit_id,\n+            line_programs,\n+            global_line_program,\n+            ranges,\n+            unit_ranges: RangeList(Vec::new()),\n+            symbol_names: Vec::new(),\n+            _dummy: PhantomData,\n+        }\n+    }\n+\n+    fn emit_location(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, entry_id: UnitEntryId, span: Span) {\n+        let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n+\n+        let unit = self.units.get_mut(self.unit_id);\n+        let entry = unit.get_mut(entry_id);\n+\n+        let file_id = self.strings.add(loc.file.name.to_string());\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::StringRef(file_id));\n+        entry.set(\n+            gimli::DW_AT_decl_line,\n+            AttributeValue::Udata(loc.line as u64),\n+        );\n+        // FIXME: probably omit this\n+        entry.set(\n+            gimli::DW_AT_decl_column,\n+            AttributeValue::Udata(loc.col.to_usize() as u64),\n+        );\n+    }\n+\n+    pub fn emit(&mut self, artifact: &mut Artifact) {\n+        let unit_range_id = self.ranges.add(self.unit_ranges.clone());\n+        let unit = self.units.get_mut(self.unit_id);\n+        let root = unit.root();\n+        let root = unit.get_mut(root);\n+        root.set(\n+            gimli::DW_AT_ranges,\n+            AttributeValue::RangeListsRef(unit_range_id),\n+        );\n+\n+        let mut debug_abbrev = DebugAbbrev::from(WriterRelocate::new(self));\n+        let mut debug_info = DebugInfo::from(WriterRelocate::new(self));\n+        let mut debug_str = DebugStr::from(WriterRelocate::new(self));\n+        let mut debug_line = DebugLine::from(WriterRelocate::new(self));\n+        let mut debug_ranges = DebugRanges::from(WriterRelocate::new(self));\n+        let mut debug_rnglists = DebugRngLists::from(WriterRelocate::new(self));\n+\n+        let debug_line_offsets = self.line_programs.write(&mut debug_line).unwrap();\n+        let debug_str_offsets = self.strings.write(&mut debug_str).unwrap();\n+        let (debug_ranges_offsets, debug_rnglists_offsets) = self\n+            .ranges\n+            .write(\n+                &mut debug_ranges,\n+                &mut debug_rnglists,\n+                self.format,\n+                self.version,\n+                self.address_size,\n+            )\n+            .unwrap();\n+        self.units\n+            .write(\n+                &mut debug_abbrev,\n+                &mut debug_info,\n+                &debug_line_offsets,\n+                &debug_ranges_offsets,\n+                &debug_rnglists_offsets,\n+                &debug_str_offsets,\n+            )\n+            .unwrap();\n+\n+        artifact\n+            .declare_with(\n+                SectionId::DebugAbbrev.name(),\n+                Decl::DebugSection,\n+                debug_abbrev.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+        artifact\n+            .declare_with(\n+                SectionId::DebugInfo.name(),\n+                Decl::DebugSection,\n+                debug_info.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+        artifact\n+            .declare_with(\n+                SectionId::DebugStr.name(),\n+                Decl::DebugSection,\n+                debug_str.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+        artifact\n+            .declare_with(\n+                SectionId::DebugLine.name(),\n+                Decl::DebugSection,\n+                debug_line.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+        artifact\n+            .declare_with(\n+                SectionId::DebugRanges.name(),\n+                Decl::DebugSection,\n+                debug_ranges.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+        artifact\n+            .declare_with(\n+                SectionId::DebugRngLists.name(),\n+                Decl::DebugSection,\n+                debug_rnglists.0.writer.into_vec(),\n+            )\n+            .unwrap();\n+\n+        for reloc in debug_abbrev.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugAbbrev.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+\n+        for reloc in debug_info.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugInfo.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+\n+        for reloc in debug_str.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugStr.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+\n+        for reloc in debug_line.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugLine.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+\n+        for reloc in debug_ranges.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugRanges.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+\n+        for reloc in debug_rnglists.0.relocs {\n+            artifact\n+                .link_with(\n+                    faerie::Link {\n+                        from: SectionId::DebugRngLists.name(),\n+                        to: &reloc.name,\n+                        at: u64::from(reloc.offset),\n+                    },\n+                    faerie::Reloc::Debug {\n+                        size: reloc.size,\n+                        addend: reloc.addend as i32,\n+                    },\n+                )\n+                .expect(\"faerie relocation error\");\n+        }\n+    }\n+\n+    fn section_name(&self, id: SectionId) -> String {\n+        id.name().to_string()\n+    }\n+}\n+\n+pub struct FunctionDebugContext<'a, 'tcx> {\n+    debug_context: &'a mut DebugContext<'tcx>,\n+    entry_id: UnitEntryId,\n+    symbol: usize,\n+}\n+\n+impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        debug_context: &'a mut DebugContext<'tcx>,\n+        mir: &Mir,\n+        name: &str,\n+        _sig: &Signature,\n+    ) -> Self {\n+        let symbol = debug_context.symbol_names.len();\n+        debug_context.symbol_names.push(name.to_string());\n+\n+        let unit = debug_context.units.get_mut(debug_context.unit_id);\n+        // FIXME: add to appropriate scope intead of root\n+        let scope = unit.root();\n+\n+        let entry_id = unit.add(scope, gimli::DW_TAG_subprogram);\n+        let entry = unit.get_mut(entry_id);\n+        let name_id = debug_context.strings.add(name);\n+        entry.set(\n+            gimli::DW_AT_linkage_name,\n+            AttributeValue::StringRef(name_id),\n+        );\n+\n+        entry.set(\n+            gimli::DW_AT_low_pc,\n+            AttributeValue::Address(Address::Relative { symbol, addend: 0 }),\n+        );\n+\n+        debug_context.emit_location(tcx, entry_id, mir.span);\n+\n+        FunctionDebugContext {\n+            debug_context,\n+            entry_id,\n+            symbol,\n+        }\n+    }\n+\n+    pub fn define(\n+        &mut self,\n+        tcx: TyCtxt,\n+        //module: &mut Module<impl Backend>,\n+        size: u32,\n+        context: &Context,\n+        isa: &cranelift::codegen::isa::TargetIsa,\n+        spans: &[Span],\n+    ) {\n+        let unit = self.debug_context.units.get_mut(self.debug_context.unit_id);\n+        // FIXME: add to appropriate scope intead of root\n+        let entry = unit.get_mut(self.entry_id);\n+        let mut size_array = [0; 8];\n+        byteorder::LittleEndian::write_u64(&mut size_array, size as u64);\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Data8(size_array));\n+\n+        self.debug_context.unit_ranges.0.push(Range {\n+            begin: Address::Relative {\n+                symbol: self.symbol,\n+                addend: 0,\n+            },\n+            end: Address::Relative {\n+                symbol: self.symbol,\n+                addend: size as i64,\n+            },\n+        });\n+\n+        let line_program = self\n+            .debug_context\n+            .line_programs\n+            .get_mut(self.debug_context.global_line_program);\n+\n+        line_program.begin_sequence(Some(Address::Relative {\n+            symbol: self.symbol,\n+            addend: 0,\n+        }));\n+\n+        let encinfo = isa.encoding_info();\n+        let func = &context.func;\n+        let mut ebbs = func.layout.ebbs().collect::<Vec<_>>();\n+        ebbs.sort_by_key(|ebb| func.offsets[*ebb]); // Ensure inst offsets always increase\n+        for ebb in ebbs {\n+            for (offset, inst, _size) in func.inst_offsets(ebb, &encinfo) {\n+                let srcloc = func.srclocs[inst];\n+                if !srcloc.is_default() {\n+                    let span = spans[srcloc.bits() as usize];\n+                    let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n+                    let file = loc.file.name.to_string();\n+                    let file = ::std::path::Path::new(&file);\n+                    let dir_id = line_program\n+                        .add_directory(file.parent().unwrap().to_str().unwrap().as_bytes());\n+                    let file_id = line_program.add_file(\n+                        file.file_name().unwrap().to_str().unwrap().as_bytes(),\n+                        dir_id,\n+                        None,\n+                    );\n+                    line_program.row().file = file_id;\n+                    //tcx.sess\n+                    //    .warn(&format!(\"srcloc {} {}:{}:{}\", offset, file, loc.line, loc.col.to_usize()));\n+                    line_program.row().address_offset = offset as u64;\n+                    line_program.row().line = loc.line as u64;\n+                    line_program.generate_row();\n+                }\n+            }\n+        }\n+\n+        let address_offset = line_program.row().address_offset;\n+        line_program.end_sequence(address_offset);\n+    }\n+}\n+\n+struct WriterRelocate<'a, 'tcx> {\n+    ctx: &'a DebugContext<'tcx>,\n+    relocs: Vec<DebugReloc>,\n+    writer: EndianVec<RunTimeEndian>,\n+}\n+\n+impl<'a, 'tcx> WriterRelocate<'a, 'tcx> {\n+    fn new(ctx: &'a DebugContext<'tcx>) -> Self {\n+        WriterRelocate {\n+            ctx,\n+            relocs: Vec::new(),\n+            writer: EndianVec::new(ctx.endian),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Writer for WriterRelocate<'a, 'tcx> {\n+    type Endian = RunTimeEndian;\n+\n+    fn endian(&self) -> Self::Endian {\n+        self.writer.endian()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.writer.len()\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> Result<()> {\n+        self.writer.write(bytes)\n+    }\n+\n+    fn write_at(&mut self, offset: usize, bytes: &[u8]) -> Result<()> {\n+        self.writer.write_at(offset, bytes)\n+    }\n+\n+    fn write_address(&mut self, address: Address, size: u8) -> Result<()> {\n+        match address {\n+            Address::Absolute(val) => self.write_word(val, size),\n+            Address::Relative { symbol, addend } => {\n+                let offset = self.len() as u64;\n+                self.relocs.push(DebugReloc {\n+                    offset: offset as u32,\n+                    size,\n+                    name: self.ctx.symbol_names[symbol].clone(),\n+                    addend: addend as i64,\n+                });\n+                self.write_word(0, size)\n+            }\n+        }\n+    }\n+\n+    fn write_offset(&mut self, val: usize, section: SectionId, size: u8) -> Result<()> {\n+        let offset = self.len() as u32;\n+        let name = self.ctx.section_name(section);\n+        self.relocs.push(DebugReloc {\n+            offset,\n+            size,\n+            name,\n+            addend: val as i64,\n+        });\n+        self.write_word(0, size)\n+    }\n+\n+    fn write_offset_at(\n+        &mut self,\n+        offset: usize,\n+        val: usize,\n+        section: SectionId,\n+        size: u8,\n+    ) -> Result<()> {\n+        let name = self.ctx.section_name(section);\n+        self.relocs.push(DebugReloc {\n+            offset: offset as u32,\n+            size,\n+            name,\n+            addend: val as i64,\n+        });\n+        self.write_word_at(offset, 0, size)\n+    }\n+}"}, {"sha": "7b0e4d231d6ddd1041d68d1e0913e9f9029aad33", "filename": "src/lib.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -20,7 +20,7 @@ use std::sync::mpsc;\n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{\n-    config::{OutputFilenames, OutputType},\n+    config::{DebugInfo, OutputFilenames, OutputType},\n     CompileIncomplete,\n };\n use rustc::ty::query::Providers;\n@@ -43,6 +43,7 @@ mod archive;\n mod base;\n mod common;\n mod constant;\n+mod debuginfo;\n mod intrinsics;\n mod link;\n mod link_copied;\n@@ -59,7 +60,7 @@ mod prelude {\n     pub use std::collections::{HashMap, HashSet};\n \n     pub use syntax::ast::{FloatTy, IntTy, UintTy};\n-    pub use syntax::source_map::DUMMY_SP;\n+    pub use syntax::source_map::{DUMMY_SP, Span, Pos};\n \n     pub use rustc::bug;\n     pub use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -85,17 +86,21 @@ mod prelude {\n     pub use rustc_codegen_ssa::traits::*;\n \n     pub use cranelift::codegen::ir::{\n-        condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, StackSlot,\n+        condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, StackSlot, SourceLoc,\n     };\n     pub use cranelift::codegen::isa::CallConv;\n     pub use cranelift::codegen::Context;\n     pub use cranelift::prelude::*;\n-    pub use cranelift_module::{Backend, DataContext, DataId, FuncId, Linkage, Module};\n+    pub use cranelift_module::{\n+        self, Backend, DataContext, DataId, FuncId, FuncOrDataId, Linkage,\n+        Module,\n+    };\n     pub use cranelift_simplejit::{SimpleJITBackend, SimpleJITBuilder};\n \n     pub use crate::abi::*;\n     pub use crate::base::{trans_operand, trans_place};\n     pub use crate::common::*;\n+    pub use crate::debuginfo::{DebugContext, FunctionDebugContext};\n     pub use crate::trap::*;\n     pub use crate::unimpl::{unimpl, with_unimpl_span};\n     pub use crate::{Caches, CodegenCx};\n@@ -120,15 +125,21 @@ pub struct CodegenCx<'a, 'clif, 'tcx, B: Backend + 'static> {\n     module: &'clif mut Module<B>,\n     ccx: ConstantCx,\n     caches: Caches<'tcx>,\n+    debug_context: Option<&'clif mut DebugContext<'tcx>>,\n }\n \n impl<'a, 'clif, 'tcx, B: Backend + 'static> CodegenCx<'a, 'clif, 'tcx, B> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, module: &'clif mut Module<B>) -> Self {\n+    fn new(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        module: &'clif mut Module<B>,\n+        debug_context: Option<&'clif mut DebugContext<'tcx>>,\n+    ) -> Self {\n         CodegenCx {\n             tcx,\n             module,\n             ccx: ConstantCx::default(),\n             caches: Caches::default(),\n+            debug_context,\n         }\n     }\n \n@@ -225,7 +236,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 .declare_function(\"main\", Linkage::Import, &sig)\n                 .unwrap();\n \n-            codegen_cgus(tcx, &mut jit_module, &mut log);\n+            codegen_cgus(tcx, &mut jit_module, &mut None, &mut log);\n             crate::allocator::codegen(tcx.sess, &mut jit_module);\n             jit_module.finalize_definitions();\n \n@@ -261,9 +272,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 module\n             };\n \n-            let emit_module = |name: &str, kind: ModuleKind, mut module: Module<FaerieBackend>| {\n+            let emit_module = |name: &str, kind: ModuleKind, mut module: Module<FaerieBackend>, debug: Option<DebugContext>| {\n                 module.finalize_definitions();\n-                let artifact = module.finish().artifact;\n+                let mut artifact = module.finish().artifact;\n+\n+                if let Some(mut debug) = debug {\n+                    debug.emit(&mut artifact);\n+                }\n \n                 let tmp_file = tcx\n                     .output_filenames(LOCAL_CRATE)\n@@ -281,7 +296,14 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             let mut faerie_module = new_module(\"some_file\".to_string());\n \n-            codegen_cgus(tcx, &mut faerie_module, &mut log);\n+            let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n+                let debug = DebugContext::new(tcx, faerie_module.target_config().pointer_type().bytes() as u8);\n+                Some(debug)\n+            } else {\n+                None\n+            };\n+\n+            codegen_cgus(tcx, &mut faerie_module, &mut debug, &mut log);\n \n             tcx.sess.abort_if_errors();\n \n@@ -291,9 +313,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             return Box::new(CodegenResults {\n                 crate_name: tcx.crate_name(LOCAL_CRATE),\n-                modules: vec![emit_module(\"dummy_name\", ModuleKind::Regular, faerie_module)],\n+                modules: vec![emit_module(\"dummy_name\", ModuleKind::Regular, faerie_module, debug)],\n                 allocator_module: if created_alloc_shim {\n-                    Some(emit_module(\"allocator_shim\", ModuleKind::Allocator, allocator_module))\n+                    Some(emit_module(\"allocator_shim\", ModuleKind::Allocator, allocator_module, None))\n                 } else {\n                     None\n                 },\n@@ -372,6 +394,7 @@ fn build_isa(sess: &Session) -> Box<isa::TargetIsa + 'static> {\n fn codegen_cgus<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     module: &mut Module<impl Backend + 'static>,\n+    debug: &mut Option<DebugContext<'tcx>>,\n     log: &mut Option<File>,\n ) {\n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n@@ -382,18 +405,19 @@ fn codegen_cgus<'a, 'tcx: 'a>(\n         .map(|(&mono_item, &(linkage, vis))| (mono_item, (linkage, vis)))\n         .collect::<FxHashMap<_, (_, _)>>();\n \n-    codegen_mono_items(tcx, module, log, mono_items);\n+    codegen_mono_items(tcx, module, debug.as_mut(), log, mono_items);\n \n     crate::main_shim::maybe_create_entry_wrapper(tcx, module);\n }\n \n fn codegen_mono_items<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     module: &mut Module<impl Backend + 'static>,\n+    debug_context: Option<&mut DebugContext<'tcx>>,\n     log: &mut Option<File>,\n     mono_items: FxHashMap<MonoItem<'tcx>, (RLinkage, Visibility)>,\n ) {\n-    let mut cx = CodegenCx::new(tcx, module);\n+    let mut cx = CodegenCx::new(tcx, module, debug_context);\n     time(\"codegen mono items\", move || {\n         for (mono_item, (linkage, vis)) in mono_items {\n             unimpl::try_unimpl(tcx, log, || {"}, {"sha": "1782df6113ddddeafa60148a0662cb47d4989a51", "filename": "test.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09c4569c87f813773f00d30ad3ce4df94416e56f/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/09c4569c87f813773f00d30ad3ce4df94416e56f/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=09c4569c87f813773f00d30ad3ce4df94416e56f", "patch": "@@ -10,16 +10,16 @@ rm -r target/out || true\n mkdir -p target/out/clif\n \n echo \"[BUILD] mini_core\"\n-$RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib\n+$RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib -g\n \n echo \"[BUILD] example\"\n-$RUSTC example/example.rs --crate-type lib\n+$RUSTC example/example.rs --crate-type lib -g\n \n echo \"[JIT] mini_core_hello_world\"\n SHOULD_RUN=1 $RUSTC --crate-type bin example/mini_core_hello_world.rs --cfg jit\n \n echo \"[AOT] mini_core_hello_world\"\n-$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin\n+$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g\n sh -c ./target/out/mini_core_hello_world || true\n \n echo \"[BUILD] sysroot\"\n@@ -31,7 +31,7 @@ time ./build_sysroot/build_sysroot.sh\n #./target/out/alloc_example\n \n echo \"[BUILD] mod_bench\"\n-$RUSTC --sysroot ./build_sysroot/sysroot example/mod_bench.rs --crate-type bin\n+$RUSTC --sysroot ./build_sysroot/sysroot example/mod_bench.rs --crate-type bin -g\n \n echo \"[BUILD] sysroot in release mode\"\n ./build_sysroot/build_sysroot.sh --release"}]}