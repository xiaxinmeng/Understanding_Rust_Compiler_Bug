{"sha": "896b113ec3b777c72fd240c24a47792c90e65be4", "node_id": "C_kwDOAAsO6NoAKDg5NmIxMTNlYzNiNzc3YzcyZmQyNDBjMjRhNDc3OTJjOTBlNjViZTQ", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-03-15T10:13:56Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-03-15T10:17:29Z"}, "message": "use `format_args_capture` in some parts of rustc_parse", "tree": {"sha": "ccc4c49d95d00ca1779c07bd8eb238de41097eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccc4c49d95d00ca1779c07bd8eb238de41097eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/896b113ec3b777c72fd240c24a47792c90e65be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/896b113ec3b777c72fd240c24a47792c90e65be4", "html_url": "https://github.com/rust-lang/rust/commit/896b113ec3b777c72fd240c24a47792c90e65be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/896b113ec3b777c72fd240c24a47792c90e65be4/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8", "html_url": "https://github.com/rust-lang/rust/commit/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "8f759ae84fa69ea457f8e11c2b3fb0d5718e8842", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=896b113ec3b777c72fd240c24a47792c90e65be4", "patch": "@@ -139,7 +139,7 @@ impl<'a> Parser<'a> {\n                 Ok(attr::mk_attr_from_item(item, None, style, attr_sp))\n             } else {\n                 let token_str = pprust::token_to_string(&this.token);\n-                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+                let msg = &format!(\"expected `#`, found `{token_str}`\");\n                 Err(this.struct_span_err(this.token.span, msg))\n             }\n         })\n@@ -421,7 +421,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let found = pprust::token_to_string(&self.token);\n-        let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n+        let msg = format!(\"expected unsuffixed literal or identifier, found `{found}`\");\n         Err(self.struct_span_err(self.token.span, &msg))\n     }\n }"}, {"sha": "1909e9ee749490acdcdfc642943ee2ab73d8fbe5", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=896b113ec3b777c72fd240c24a47792c90e65be4", "patch": "@@ -327,8 +327,8 @@ impl<'a> Parser<'a> {\n                 expect.clone()\n             };\n             (\n-                format!(\"expected one of {}, found {}\", expect, actual),\n-                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n+                format!(\"expected one of {expect}, found {actual}\"),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {short_expect}\")),\n             )\n         } else if expected.is_empty() {\n             (\n@@ -337,8 +337,8 @@ impl<'a> Parser<'a> {\n             )\n         } else {\n             (\n-                format!(\"expected {}, found {}\", expect, actual),\n-                (self.prev_token.span.shrink_to_hi(), format!(\"expected {}\", expect)),\n+                format!(\"expected {expect}, found {actual}\"),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected {expect}\")),\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n@@ -421,7 +421,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n-                err.note(&format!(\"the raw string started with {} `#`s\", n_hashes));\n+                err.note(&format!(\"the raw string started with {n_hashes} `#`s\"));\n                 true\n             }\n             _ => false,\n@@ -1191,7 +1191,7 @@ impl<'a> Parser<'a> {\n                     _ => None,\n                 };\n                 if let Some(name) = previous_item_kind_name {\n-                    err.help(&format!(\"{} declarations are not followed by a semicolon\", name));\n+                    err.help(&format!(\"{name} declarations are not followed by a semicolon\"));\n                 }\n             }\n             err.emit();\n@@ -1226,12 +1226,12 @@ impl<'a> Parser<'a> {\n             \"expected `{}`, found {}\",\n             token_str,\n             match (&self.token.kind, self.subparser_name) {\n-                (token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n+                (token::Eof, Some(origin)) => format!(\"end of {origin}\"),\n                 _ => this_token_str,\n             },\n         );\n         let mut err = self.struct_span_err(sp, &msg);\n-        let label_exp = format!(\"expected `{}`\", token_str);\n+        let label_exp = format!(\"expected `{token_str}`\");\n         match self.recover_closing_delimiter(&[t.clone()], err) {\n             Err(e) => err = e,\n             Ok(recovered) => {\n@@ -1368,7 +1368,7 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 );\n             }\n-            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\", prefix), \"r#\".to_string(), Applicability::MachineApplicable);\n+            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{prefix}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\"), \"r#\".to_string(), Applicability::MachineApplicable);\n             err.emit();\n             Ok(self.mk_expr_err(lo.to(hi)))\n         } else {\n@@ -1504,7 +1504,7 @@ impl<'a> Parser<'a> {\n                 delim.retain(|c| c != '`');\n                 err.span_suggestion_short(\n                     self.prev_token.span.shrink_to_hi(),\n-                    &format!(\"`{}` may belong here\", delim),\n+                    &format!(\"`{delim}` may belong here\"),\n                     delim,\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -1698,7 +1698,7 @@ impl<'a> Parser<'a> {\n                                 (\n                                     ident,\n                                     \"self: \".to_string(),\n-                                    format!(\"{}: &{}TypeName\", ident, mutab),\n+                                    format!(\"{ident}: &{mutab}TypeName\"),\n                                     \"_: \".to_string(),\n                                     pat.span.shrink_to_lo(),\n                                     pat.span,\n@@ -1826,7 +1826,7 @@ impl<'a> Parser<'a> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n                 let sp = self.sess.source_map().next_point(self.prev_token.span);\n-                (sp, format!(\"expected expression, found end of {}\", origin))\n+                (sp, format!(\"expected expression, found end of {origin}\"))\n             }\n             _ => (\n                 self.token.span,\n@@ -1975,8 +1975,8 @@ impl<'a> Parser<'a> {\n             (ty_generics, self.sess.source_map().span_to_snippet(param.span()))\n         {\n             let (span, sugg) = match &generics.params[..] {\n-                [] => (generics.span, format!(\"<{}>\", snippet)),\n-                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {}\", snippet)),\n+                [] => (generics.span, format!(\"<{snippet}>\")),\n+                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {snippet}\")),\n             };\n             err.multipart_suggestion(\n                 \"`const` parameters must be declared for the `impl`\","}, {"sha": "550d79a898c11ca94dd0fa000dfe8c52b45f1a5d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=896b113ec3b777c72fd240c24a47792c90e65be4", "patch": "@@ -223,7 +223,7 @@ impl<'a> Parser<'a> {\n                     AssocOp::NotEqual => \"!=\",\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(sp, &format!(\"invalid comparison operator `{}=`\", sugg))\n+                self.struct_span_err(sp, &format!(\"invalid comparison operator `{sugg}=`\"))\n                     .span_suggestion_short(\n                         sp,\n                         &format!(\"`{s}=` is not a valid comparison operator, use `{s}`\", s = sugg),\n@@ -441,10 +441,10 @@ impl<'a> Parser<'a> {\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n     fn error_bad_logical_op(&self, bad: &str, good: &str, english: &str) {\n-        self.struct_span_err(self.token.span, &format!(\"`{}` is not a logical operator\", bad))\n+        self.struct_span_err(self.token.span, &format!(\"`{bad}` is not a logical operator\"))\n             .span_suggestion_short(\n                 self.token.span,\n-                &format!(\"use `{}` to perform logical {}\", good, english),\n+                &format!(\"use `{good}` to perform logical {english}\"),\n                 good.to_string(),\n                 Applicability::MachineApplicable,\n             )\n@@ -766,9 +766,9 @@ impl<'a> Parser<'a> {\n                                 self.look_ahead(1, |t| t.span).to(span_after_type),\n                                 \"interpreted as generic arguments\",\n                             )\n-                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_label(self.token.span, format!(\"not interpreted as {op_noun}\"))\n                             .multipart_suggestion(\n-                                &format!(\"try {} the cast value\", op_verb),\n+                                &format!(\"try {op_verb} the cast value\"),\n                                 vec![\n                                     (expr.span.shrink_to_lo(), \"(\".to_string()),\n                                     (expr.span.shrink_to_hi(), \")\".to_string()),\n@@ -970,7 +970,7 @@ impl<'a> Parser<'a> {\n     fn error_unexpected_after_dot(&self) {\n         // FIXME Could factor this out into non_fatal_unexpected or something.\n         let actual = pprust::token_to_string(&self.token);\n-        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual)).emit();\n+        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{actual}`\")).emit();\n     }\n \n     // We need an identifier or integer, but the next token is a float.\n@@ -1151,15 +1151,15 @@ impl<'a> Parser<'a> {\n                             mem::replace(err, replacement_err).cancel();\n \n                             err.multipart_suggestion(\n-                                &format!(\"if `{}` is a struct, use braces as delimiters\", name),\n+                                &format!(\"if `{name}` is a struct, use braces as delimiters\"),\n                                 vec![\n                                     (open_paren, \" { \".to_string()),\n                                     (close_paren, \" }\".to_string()),\n                                 ],\n                                 Applicability::MaybeIncorrect,\n                             );\n                             err.multipart_suggestion(\n-                                &format!(\"if `{}` is a function, use the arguments directly\", name),\n+                                &format!(\"if `{name}` is a function, use the arguments directly\"),\n                                 fields\n                                     .into_iter()\n                                     .map(|field| (field.span.until(field.expr.span), String::new()))\n@@ -1776,9 +1776,9 @@ impl<'a> Parser<'a> {\n                         )\n                         .emit();\n                 } else {\n-                    let msg = format!(\"invalid suffix `{}` for number literal\", suf);\n+                    let msg = format!(\"invalid suffix `{suf}` for number literal\");\n                     self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n                         .help(\"the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\")\n                         .emit();\n                 }\n@@ -1791,9 +1791,9 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n                     self.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit();\n                 } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    let msg = format!(\"invalid suffix `{suf}` for float literal\");\n                     self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n                         .help(\"valid suffixes are `f32` and `f64`\")\n                         .emit();\n                 }\n@@ -1805,7 +1805,7 @@ impl<'a> Parser<'a> {\n                     2 => \"binary\",\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n+                self.struct_span_err(span, &format!(\"{descr} float literal is not supported\"))\n                     .span_label(span, \"not supported\")\n                     .emit();\n             }\n@@ -1825,7 +1825,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self\n                     .sess\n                     .span_diagnostic\n-                    .struct_span_warn(sp, &format!(\"suffixes on {} are invalid\", kind));\n+                    .struct_span_warn(sp, &format!(\"suffixes on {kind} are invalid\"));\n                 err.note(&format!(\n                     \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n                         incorrectly accepted on stable for a few releases\",\n@@ -1842,10 +1842,10 @@ impl<'a> Parser<'a> {\n                 );\n                 err\n             } else {\n-                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+                self.struct_span_err(sp, &format!(\"suffixes on {kind} are invalid\"))\n                     .forget_guarantee()\n             };\n-            err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n+            err.span_label(sp, format!(\"invalid suffix `{suf}`\"));\n             err.emit();\n         }\n     }\n@@ -2211,7 +2211,7 @@ impl<'a> Parser<'a> {\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n         self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n             .span_label(branch_span, \"the attributes are attached to this branch\")\n-            .span_label(ctx_span, format!(\"the branch belongs to this `{}`\", ctx))\n+            .span_label(ctx_span, format!(\"the branch belongs to this `{ctx}`\"))\n             .span_suggestion(\n                 span,\n                 \"remove the attributes\",\n@@ -2391,7 +2391,7 @@ impl<'a> Parser<'a> {\n             err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n             if stmts.len() > 1 {\n                 err.multipart_suggestion(\n-                    &format!(\"surround the statement{} with a body\", s),\n+                    &format!(\"surround the statement{s} with a body\"),\n                     vec![\n                         (span.shrink_to_lo(), \"{ \".to_string()),\n                         (span.shrink_to_hi(), \" }\".to_string()),"}, {"sha": "b582f060395c38c9c9994ca9cf5daadebaef46d6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896b113ec3b777c72fd240c24a47792c90e65be4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=896b113ec3b777c72fd240c24a47792c90e65be4", "patch": "@@ -66,7 +66,7 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let msg = &format!(\"expected item, found {}\", token_str);\n+                let msg = &format!(\"expected item, found {token_str}\");\n                 let mut err = self.struct_span_err(self.token.span, msg);\n                 err.span_label(self.token.span, \"expected item\");\n                 return Err(err);\n@@ -163,9 +163,9 @@ impl<'a> Parser<'a> {\n         }\n         let vs = pprust::vis_to_string(&vis);\n         let vs = vs.trim_end();\n-        self.struct_span_err(vis.span, &format!(\"visibility `{}` is not followed by an item\", vs))\n+        self.struct_span_err(vis.span, &format!(\"visibility `{vs}` is not followed by an item\"))\n             .span_label(vis.span, \"the visibility\")\n-            .help(&format!(\"you likely meant to define an item, e.g., `{} fn foo() {{}}`\", vs))\n+            .help(&format!(\"you likely meant to define an item, e.g., `{vs} fn foo() {{}}`\"))\n             .emit();\n     }\n \n@@ -327,7 +327,7 @@ impl<'a> Parser<'a> {\n         if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n             let ident = self.parse_ident().unwrap();\n-            let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n+            let msg = format!(\"add `struct` here to parse `{ident}` as a public struct\");\n             let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n             err.span_suggestion_short(\n                 sp,\n@@ -355,16 +355,16 @@ impl<'a> Parser<'a> {\n                 (\"fn` or `struct\", \"function or struct\", true)\n             };\n \n-            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n             let mut err = self.struct_span_err(sp, &msg);\n             if !ambiguous {\n                 self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                 let suggestion =\n-                    format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n+                    format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\");\n                 err.span_suggestion_short(\n                     sp,\n                     &suggestion,\n-                    format!(\" {} \", kw),\n+                    format!(\" {kw} \"),\n                     Applicability::MachineApplicable,\n                 );\n             } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n@@ -393,12 +393,12 @@ impl<'a> Parser<'a> {\n             } else {\n                 (\"fn` or `struct\", \"function or struct\", true)\n             };\n-            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n             let mut err = self.struct_span_err(sp, &msg);\n             if !ambiguous {\n                 err.span_suggestion_short(\n                     sp,\n-                    &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                    &format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\"),\n                     format!(\" {} \", kw),\n                     Applicability::MachineApplicable,\n                 );\n@@ -1031,8 +1031,8 @@ impl<'a> Parser<'a> {\n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n-        self.struct_span_err(span, &format!(\"{} is not supported in {}\", descr, ctx))\n-            .help(&format!(\"consider moving the {} out to a nearby module scope\", descr))\n+        self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n+            .help(&format!(\"consider moving the {descr} out to a nearby module scope\"))\n             .emit();\n         None\n     }\n@@ -1161,11 +1161,11 @@ impl<'a> Parser<'a> {\n             Some(Mutability::Not) => \"static\",\n             None => \"const\",\n         };\n-        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n+        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{kind}` item\"));\n         err.span_suggestion(\n             id.span,\n             \"provide a type for the item\",\n-            format!(\"{}: <type>\", id),\n+            format!(\"{id}: <type>\"),\n             Applicability::HasPlaceholders,\n         );\n         err.stash(id.span, StashKey::ItemNoType);\n@@ -1282,8 +1282,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let token_str = super::token_descr(&self.token);\n             let msg = &format!(\n-                \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n-                token_str\n+                \"expected `where`, `{{`, `(`, or `;` after struct name, found {token_str}\"\n             );\n             let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n@@ -1310,7 +1309,7 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\"expected `where` or `{{` after union name, found {}\", token_str);\n+            let msg = &format!(\"expected `where` or `{{` after union name, found {token_str}\");\n             let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n@@ -1591,7 +1590,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let mut err = self.struct_span_err(\n                     lo.to(self.prev_token.span),\n-                    &format!(\"functions are not allowed in {} definitions\", adt_ty),\n+                    &format!(\"functions are not allowed in {adt_ty} definitions\"),\n                 );\n                 err.help(\"unlike in C++, Java, and C#, functions are declared in `impl` blocks\");\n                 err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n@@ -1706,7 +1705,7 @@ impl<'a> Parser<'a> {\n         let vstr = pprust::vis_to_string(vis);\n         let vstr = vstr.trim_end();\n         if macro_rules {\n-            let msg = format!(\"can't qualify macro_rules invocation with `{}`\", vstr);\n+            let msg = format!(\"can't qualify macro_rules invocation with `{vstr}`\");\n             self.struct_span_err(vis.span, &msg)\n                 .span_suggestion(\n                     vis.span,\n@@ -1723,7 +1722,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n-                .help(&format!(\"try adjusting the macro to put `{}` inside the invocation\", vstr))\n+                .help(&format!(\"try adjusting the macro to put `{vstr}` inside the invocation\"))\n                 .emit();\n         }\n     }\n@@ -1781,11 +1780,11 @@ impl<'a> Parser<'a> {\n \n             self.struct_span_err(\n                 kw_token.span,\n-                &format!(\"`{}` definition cannot be nested inside `{}`\", kw_str, keyword),\n+                &format!(\"`{kw_str}` definition cannot be nested inside `{keyword}`\"),\n             )\n             .span_suggestion(\n                 item.unwrap().span,\n-                &format!(\"consider creating a new `{}` definition instead of nesting\", kw_str),\n+                &format!(\"consider creating a new `{kw_str}` definition instead of nesting\"),\n                 String::new(),\n                 Applicability::MaybeIncorrect,\n             )\n@@ -2045,11 +2044,11 @@ impl<'a> Parser<'a> {\n \n                         err.span_suggestion(\n                             self.token.uninterpolated_span(),\n-                            &format!(\"`{}` already used earlier, remove this one\", original_kw),\n+                            &format!(\"`{original_kw}` already used earlier, remove this one\"),\n                             \"\".to_string(),\n                             Applicability::MachineApplicable,\n                         )\n-                        .span_note(original_sp, &format!(\"`{}` first seen here\", original_kw));\n+                        .span_note(original_sp, &format!(\"`{original_kw}` first seen here\"));\n                     }\n                     // The keyword has not been seen yet, suggest correct placement in the function front matter\n                     else if let Some(WrongKw::Misplaced(correct_pos_sp)) = wrong_kw {\n@@ -2060,8 +2059,8 @@ impl<'a> Parser<'a> {\n \n                             err.span_suggestion(\n                                     correct_pos_sp.to(misplaced_qual_sp),\n-                                    &format!(\"`{}` must come before `{}`\", misplaced_qual, current_qual),\n-                                    format!(\"{} {}\", misplaced_qual, current_qual),\n+                                    &format!(\"`{misplaced_qual}` must come before `{current_qual}`\"),\n+                                    format!(\"{misplaced_qual} {current_qual}\"),\n                                     Applicability::MachineApplicable,\n                                 ).note(\"keyword order for functions declaration is `default`, `pub`, `const`, `async`, `unsafe`, `extern`\");\n                         }\n@@ -2084,8 +2083,8 @@ impl<'a> Parser<'a> {\n                             if matches!(orig_vis.kind, VisibilityKind::Inherited) {\n                                 err.span_suggestion(\n                                     sp_start.to(self.prev_token.span),\n-                                    &format!(\"visibility `{}` must come before `{}`\", vs, snippet),\n-                                    format!(\"{} {}\", vs, snippet),\n+                                    &format!(\"visibility `{vs}` must come before `{snippet}`\"),\n+                                    format!(\"{vs} {snippet}\"),\n                                     Applicability::MachineApplicable,\n                                 );\n                             }"}]}