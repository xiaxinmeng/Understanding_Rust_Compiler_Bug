{"sha": "ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViY2M3NmQ2OGQ1YWIxM2NkN2FiYzZkNDdjOTE0NzE3NDBmMDg5OWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-03T20:54:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-05T04:35:06Z"}, "message": "Move the library search into util::filesearch", "tree": {"sha": "05d01a29fac39209f5c21376dbc759b2ab28bf40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d01a29fac39209f5c21376dbc759b2ab28bf40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "html_url": "https://github.com/rust-lang/rust/commit/ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebcc76d68d5ab13cd7abc6d47c91471740f0899e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b25e78524c8de705fcd7dfe759e4a614ffa5f594", "url": "https://api.github.com/repos/rust-lang/rust/commits/b25e78524c8de705fcd7dfe759e4a614ffa5f594", "html_url": "https://github.com/rust-lang/rust/commit/b25e78524c8de705fcd7dfe759e4a614ffa5f594"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "a706a16726b8492ab3ea6c0fd13ca225323ebc4f", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ebcc76d68d5ab13cd7abc6d47c91471740f0899e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebcc76d68d5ab13cd7abc6d47c91471740f0899e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "patch": "@@ -8,7 +8,7 @@ import middle::resolve;\n import syntax::visit;\n import syntax::codemap::span;\n import back::x86;\n-import util::common;\n+import util::{common, filesearch};\n import std::{vec, str, fs, io, option};\n import std::option::{none, some};\n import std::map::{hashmap, new_int_hash};\n@@ -131,49 +131,41 @@ fn find_library_crate(sess: session::session, ident: ast::ident,\n     let nn = default_native_lib_naming(sess, sess.get_opts().static);\n     let x =\n         find_library_crate_aux(nn, crate_name, metas,\n-                               sess.filesearch().lib_search_paths());\n+                               sess.filesearch());\n     if x != none || sess.get_opts().static { ret x; }\n     let nn2 = default_native_lib_naming(sess, true);\n     ret find_library_crate_aux(nn2, crate_name, metas,\n-                               sess.filesearch().lib_search_paths());\n+                               sess.filesearch());\n }\n \n fn find_library_crate_aux(nn: {prefix: str, suffix: str}, crate_name: str,\n                           metas: [@ast::meta_item],\n-                          library_search_paths: [str]) ->\n+                          filesearch: filesearch::filesearch) ->\n    option::t<{ident: str, data: @[u8]}> {\n     let prefix: str = nn.prefix + crate_name;\n     let suffix: str = nn.suffix;\n-    // FIXME: we could probably use a 'glob' function in std::fs but it will\n-    // be much easier to write once the unsafe module knows more about FFI\n-    // tricks. Currently the glob(3) interface is a bit more than we can\n-    // stomach from here, and writing a C++ wrapper is more work than just\n-    // manually filtering fs::list_dir here.\n \n-    for library_search_path: str in library_search_paths {\n-        log #fmt[\"searching %s\", library_search_path];\n-        for path: str in fs::list_dir(library_search_path) {\n-            log #fmt[\"searching %s\", path];\n-            let f: str = fs::basename(path);\n-            if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n-                log #fmt[\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                         suffix];\n-                cont;\n-            }\n+    ret filesearch::search(filesearch, { |path|\n+        let f: str = fs::basename(path);\n+        if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n+            log #fmt[\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                     suffix];\n+            option::none\n+        } else {\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n                     log #fmt[\"skipping %s, metadata doesn't match\", path];\n-                    cont;\n+                    option::none\n+                } else {\n+                    log #fmt[\"found %s with matching metadata\", path];\n+                    option::some({ident: path, data: cvec})\n                 }\n-                log #fmt[\"found %s with matching metadata\", path];\n-                ret some({ident: path, data: cvec});\n               }\n-              _ { }\n+              _ { option::none }\n             }\n         }\n-    }\n-    ret none;\n+    });\n }\n \n fn get_metadata_section(filename: str) -> option::t<@[u8]> {"}, {"sha": "228d1266b1fc7474e72cbd2804ed31b46a5ef08c", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ebcc76d68d5ab13cd7abc6d47c91471740f0899e/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebcc76d68d5ab13cd7abc6d47c91471740f0899e/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=ebcc76d68d5ab13cd7abc6d47c91471740f0899e", "patch": "@@ -1,3 +1,5 @@\n+// A module for searching for libraries\n+\n import std::option;\n import std::fs;\n import std::vec;\n@@ -6,6 +8,10 @@ import back::link;\n \n export filesearch;\n export mk_filesearch;\n+export pick;\n+export search;\n+\n+type pick<@T> = block(path: fs::path) -> option::t<T>;\n \n type filesearch = obj {\n     fn sysroot() -> fs::path;\n@@ -37,9 +43,28 @@ fn mk_filesearch(binary_name: fs::path,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot, binary_name);\n+    log #fmt(\"using sysroot = %s\", sysroot);\n     ret filesearch_impl(sysroot, addl_lib_search_paths, target_triple);\n }\n \n+// FIXME #1001: This can't be an obj method\n+fn search<@T>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n+    for lib_search_path in filesearch.lib_search_paths() {\n+        log #fmt[\"searching %s\", lib_search_path];\n+        for path in fs::list_dir(lib_search_path) {\n+            log #fmt[\"testing %s\", path];\n+            let maybe_picked = pick(path);\n+            if option::is_some(maybe_picked) {\n+                log #fmt(\"picked %s\", path);\n+                ret maybe_picked;\n+            } else {\n+                log #fmt(\"rejected %s\", path);\n+            }\n+        }\n+    }\n+    ret option::none;\n+}\n+\n fn make_target_lib_path(sysroot: fs::path,\n                         target_triple: str) -> fs::path {\n     let path = [sysroot, \"lib/rustc\", target_triple, \"lib\"];"}]}