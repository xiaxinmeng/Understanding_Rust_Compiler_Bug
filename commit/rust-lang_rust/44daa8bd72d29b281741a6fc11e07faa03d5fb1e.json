{"sha": "44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZGFhOGJkNzJkMjliMjgxNzQxYTZmYzExZTA3ZmFhMDNkNWZiMWU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-13T11:57:44Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-13T12:17:11Z"}, "message": "Use span_suggestion in matches lints\n\nRef #442", "tree": {"sha": "6383779b3a95b1cde17a8f45631bcc9bb430b6f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6383779b3a95b1cde17a8f45631bcc9bb430b6f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "html_url": "https://github.com/rust-lang/rust/commit/44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44daa8bd72d29b281741a6fc11e07faa03d5fb1e/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f641a1009e92431b4a49a835c4e80c51ce44c88", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f641a1009e92431b4a49a835c4e80c51ce44c88", "html_url": "https://github.com/rust-lang/rust/commit/9f641a1009e92431b4a49a835c4e80c51ce44c88"}], "stats": {"total": 100, "additions": 45, "deletions": 55}, "files": [{"sha": "4cb4df19bf80ba30276c39eb7ad525e4e6849482", "filename": "src/matches.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/44daa8bd72d29b281741a6fc11e07faa03d5fb1e/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44daa8bd72d29b281741a6fc11e07faa03d5fb1e/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "patch": "@@ -9,7 +9,7 @@ use syntax::ast::Lit_::LitBool;\n use syntax::codemap::Span;\n \n use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n-use utils::{match_type, snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n+use utils::{match_type, snippet, span_lint, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n ///\n@@ -124,15 +124,17 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms[1].pats[0].node == PatWild {\n-        span_help_and_lint(cx,\n+        span_lint_and_then(cx,\n                            SINGLE_MATCH,\n                            expr.span,\n-                           \"you seem to be trying to use match for destructuring a single pattern. Consider using \\\n-                            `if let`\",\n-                           &format!(\"try\\nif let {} = {} {}\",\n-                                    snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                    snippet(cx, ex.span, \"..\"),\n-                                    expr_block(cx, &arms[0].body, None, \"..\")));\n+                           \"you seem to be trying to use match for destructuring a single pattern. \\\n+                           Consider using `if let`\", |db| {\n+                db.span_suggestion(expr.span, \"try this\",\n+                                   format!(\"if let {} = {} {}\",\n+                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                           snippet(cx, ex.span, \"..\"),\n+                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+            });\n     }\n }\n \n@@ -156,23 +158,25 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n \n     for &(ty_path, pat_path) in candidates {\n         if &path == pat_path && match_type(cx, ty, ty_path) {\n-            span_help_and_lint(cx,\n+            span_lint_and_then(cx,\n                                SINGLE_MATCH,\n                                expr.span,\n-                               \"you seem to be trying to use match for destructuring a single pattern. Consider using \\\n-                                `if let`\",\n-                               &format!(\"try\\nif let {} = {} {}\",\n-                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                        snippet(cx, ex.span, \"..\"),\n-                                        expr_block(cx, &arms[0].body, None, \"..\")));\n+                               \"you seem to be trying to use match for destructuring a single pattern. \\\n+                               Consider using `if let`\", |db| {\n+                db.span_suggestion(expr.span, \"try this\",\n+                                   format!(\"if let {} = {} {}\",\n+                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                           snippet(cx, ex.span, \"..\"),\n+                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+            });\n         }\n     }\n }\n \n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-        if arms.len() == 2 && arms[0].pats.len() == 1 {\n+        let sugg = if arms.len() == 2 && arms[0].pats.len() == 1 {\n             // no guards\n             let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                 if let ExprLit(ref lit) = arm_bool.node {\n@@ -187,56 +191,42 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n             } else {\n                 None\n             };\n+\n             if let Some((ref true_expr, ref false_expr)) = exprs {\n                 if !is_unit_expr(true_expr) {\n                     if !is_unit_expr(false_expr) {\n-                        span_help_and_lint(cx,\n-                                           MATCH_BOOL,\n-                                           expr.span,\n-                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                                            an if..else block:\",\n-                                           &format!(\"try\\nif {} {} else {}\",\n-                                                    snippet(cx, ex.span, \"b\"),\n-                                                    expr_block(cx, true_expr, None, \"..\"),\n-                                                    expr_block(cx, false_expr, None, \"..\")));\n+                        Some(format!(\"if {} {} else {}\",\n+                                     snippet(cx, ex.span, \"b\"),\n+                                     expr_block(cx, true_expr, None, \"..\"),\n+                                     expr_block(cx, false_expr, None, \"..\")))\n                     } else {\n-                        span_help_and_lint(cx,\n-                                           MATCH_BOOL,\n-                                           expr.span,\n-                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                                            an if..else block:\",\n-                                           &format!(\"try\\nif {} {}\",\n-                                                    snippet(cx, ex.span, \"b\"),\n-                                                    expr_block(cx, true_expr, None, \"..\")));\n+                        Some(format!(\"if {} {}\",\n+                                     snippet(cx, ex.span, \"b\"),\n+                                     expr_block(cx, true_expr, None, \"..\")))\n                     }\n                 } else if !is_unit_expr(false_expr) {\n-                    span_help_and_lint(cx,\n-                                       MATCH_BOOL,\n-                                       expr.span,\n-                                       \"you seem to be trying to match on a boolean expression. Consider using an \\\n-                                        if..else block:\",\n-                                       &format!(\"try\\nif !{} {}\",\n-                                                snippet(cx, ex.span, \"b\"),\n-                                                expr_block(cx, false_expr, None, \"..\")));\n+                    Some(format!(\"try\\nif !{} {}\",\n+                                 snippet(cx, ex.span, \"b\"),\n+                                 expr_block(cx, false_expr, None, \"..\")))\n                 } else {\n-                    span_lint(cx,\n-                              MATCH_BOOL,\n-                              expr.span,\n-                              \"you seem to be trying to match on a boolean expression. Consider using an if..else \\\n-                               block\");\n+                    None\n                 }\n             } else {\n-                span_lint(cx,\n-                          MATCH_BOOL,\n-                          expr.span,\n-                          \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n+                None\n             }\n         } else {\n-            span_lint(cx,\n-                      MATCH_BOOL,\n-                      expr.span,\n-                      \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n-        }\n+            None\n+        };\n+\n+        span_lint_and_then(cx,\n+                           MATCH_BOOL,\n+                           expr.span,\n+                           \"you seem to be trying to match on a boolean expression. Consider using \\\n+                           an if..else block:\", move |db| {\n+            if let Some(ref sugg) = sugg {\n+                db.span_suggestion(expr.span, \"try this\", sugg.clone());\n+            }\n+        });\n     }\n }\n "}]}