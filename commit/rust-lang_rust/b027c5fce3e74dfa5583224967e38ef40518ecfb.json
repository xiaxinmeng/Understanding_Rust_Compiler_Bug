{"sha": "b027c5fce3e74dfa5583224967e38ef40518ecfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMjdjNWZjZTNlNzRkZmE1NTgzMjI0OTY3ZTM4ZWY0MDUxOGVjZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T23:37:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T23:37:27Z"}, "message": "auto merge of #8074 : thestinger/rust/iterator, r=cmr\n\nd7c9bb4 r=alexcrichton\r\n7ae17e0 r=huonw", "tree": {"sha": "5cad2e4790c731ec1a825154612ef40c54ff4ae9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cad2e4790c731ec1a825154612ef40c54ff4ae9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b027c5fce3e74dfa5583224967e38ef40518ecfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b027c5fce3e74dfa5583224967e38ef40518ecfb", "html_url": "https://github.com/rust-lang/rust/commit/b027c5fce3e74dfa5583224967e38ef40518ecfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b027c5fce3e74dfa5583224967e38ef40518ecfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098106870e0ebdebb40964624185f304ee7b3d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/098106870e0ebdebb40964624185f304ee7b3d63", "html_url": "https://github.com/rust-lang/rust/commit/098106870e0ebdebb40964624185f304ee7b3d63"}, {"sha": "fe955e7b062f8787f9df7e9c36abc1b83485fead", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe955e7b062f8787f9df7e9c36abc1b83485fead", "html_url": "https://github.com/rust-lang/rust/commit/fe955e7b062f8787f9df7e9c36abc1b83485fead"}], "stats": {"total": 183, "additions": 106, "deletions": 77}, "files": [{"sha": "3cd2d91459f2ea2ca3f3cd36217a3c51fafbe604", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -356,7 +356,7 @@ impl<T> DList<T> {\n \n     /// Provide a reverse iterator\n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> InvertIterator<&'a T, DListIterator<'a, T>> {\n+    pub fn rev_iter<'a>(&'a self) -> InvertIterator<DListIterator<'a, T>> {\n         self.iter().invert()\n     }\n \n@@ -376,8 +376,7 @@ impl<T> DList<T> {\n     }\n     /// Provide a reverse iterator with mutable references\n     #[inline]\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<&'a mut T,\n-                                                MutDListIterator<'a, T>> {\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<MutDListIterator<'a, T>> {\n         self.mut_iter().invert()\n     }\n \n@@ -390,7 +389,7 @@ impl<T> DList<T> {\n \n     /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n-    pub fn consume_rev_iter(self) -> InvertIterator<T, ConsumeIterator<T>> {\n+    pub fn consume_rev_iter(self) -> InvertIterator<ConsumeIterator<T>> {\n         self.consume_iter().invert()\n     }\n }"}, {"sha": "334bf8f351f9b3fc010c0e974a8f4d74218dabdc", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -181,7 +181,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Back-to-front iterator.\n-    pub fn rev_iter<'a>(&'a self) -> InvertIterator<&'a T, RingBufIterator<'a, T>> {\n+    pub fn rev_iter<'a>(&'a self) -> InvertIterator<RingBufIterator<'a, T>> {\n         self.iter().invert()\n     }\n \n@@ -192,7 +192,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<&'a mut T, RingBufMutIterator<'a, T>> {\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> InvertIterator<RingBufMutIterator<'a, T>> {\n         self.mut_iter().invert()\n     }\n }"}, {"sha": "3c8d289b8b4c0a671acda78adb7b905ff8a4bc52", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -204,7 +204,7 @@ impl<V> SmallIntMap<V> {\n     /// Empties the hash map, moving all values into the specified closure\n     pub fn consume(&mut self)\n         -> FilterMapIterator<(uint, Option<V>), (uint, V),\n-                EnumerateIterator<Option<V>, VecConsumeIterator<Option<V>>>>\n+                EnumerateIterator<VecConsumeIterator<Option<V>>>>\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.consume_iter().enumerate().filter_map(|(i, v)| {\n@@ -290,8 +290,7 @@ pub struct SmallIntMapIterator<'self, T> {\n \n iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n-pub type SmallIntMapRevIterator<'self, T> = InvertIterator<(uint, &'self T),\n-                                                           SmallIntMapIterator<'self, T>>;\n+pub type SmallIntMapRevIterator<'self, T> = InvertIterator<SmallIntMapIterator<'self, T>>;\n \n pub struct SmallIntMapMutIterator<'self, T> {\n     priv front: uint,\n@@ -301,8 +300,7 @@ pub struct SmallIntMapMutIterator<'self, T> {\n \n iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n-pub type SmallIntMapMutRevIterator<'self, T> = InvertIterator<(uint, &'self mut T),\n-                                                              SmallIntMapMutIterator<'self, T>>;\n+pub type SmallIntMapMutRevIterator<'self, T> = InvertIterator<SmallIntMapMutIterator<'self, T>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "36b666ad5de46fe10aa58cc2a484bab02871712b", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -751,7 +751,7 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// Visit the values representing the symmetric difference\n     pub fn symmetric_difference_iter<'a>(&'a self, other: &'a HashSet<T>)\n-        -> ChainIterator<&'a T, SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n+        -> ChainIterator<SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n         self.difference_iter(other).chain_(other.difference_iter(self))\n     }\n \n@@ -764,7 +764,7 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// Visit the values representing the union\n     pub fn union_iter<'a>(&'a self, other: &'a HashSet<T>)\n-        -> ChainIterator<&'a T, HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n+        -> ChainIterator<HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n         self.iter().chain_(other.difference_iter(self))\n     }\n "}, {"sha": "2ec8ea41bfb308212f8a6a2a21276190feec6a48", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -29,7 +29,13 @@ use uint;\n /// Conversion from an `Iterator`\n pub trait FromIterator<A, T: Iterator<A>> {\n     /// Build a container with elements from an external iterator.\n-    pub fn from_iterator(iterator: &mut T) -> Self;\n+    fn from_iterator(iterator: &mut T) -> Self;\n+}\n+\n+/// A type growable from an `Iterator` implementation\n+pub trait Extendable<A, T: Iterator<A>>: FromIterator<A, T> {\n+    /// Extend a container with the elements yielded by an iterator\n+    fn extend(&mut self, iterator: &mut T);\n }\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n@@ -52,7 +58,9 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n }\n \n /// An object implementing random access indexing by `uint`\n-pub trait RandomAccessIterator<A> {\n+///\n+/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n+pub trait RandomAccessIterator<A>: Iterator<A> {\n     /// Return the number of indexable elements. At most `std::uint::max_value`\n     /// elements are indexable, even if the iterator represents a longer range.\n     fn indexable(&self) -> uint;\n@@ -64,37 +72,36 @@ pub trait RandomAccessIterator<A> {\n /// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n ///\n /// In the future these will be default methods instead of a utility trait.\n-pub trait DoubleEndedIteratorUtil<A> {\n+pub trait DoubleEndedIteratorUtil {\n     /// Flip the direction of the iterator\n-    fn invert(self) -> InvertIterator<A, Self>;\n+    fn invert(self) -> InvertIterator<Self>;\n }\n \n /// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n ///\n /// In the future these will be default methods instead of a utility trait.\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil<A> for T {\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil for T {\n     /// Flip the direction of the iterator\n     #[inline]\n-    fn invert(self) -> InvertIterator<A, T> {\n+    fn invert(self) -> InvertIterator<T> {\n         InvertIterator{iter: self}\n     }\n }\n \n /// An double-ended iterator with the direction inverted\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n #[deriving(Clone)]\n-pub struct InvertIterator<A, T> {\n+pub struct InvertIterator<T> {\n     priv iter: T\n }\n \n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for InvertIterator<A, T> {\n+impl<A, T: DoubleEndedIterator<A>> Iterator<A> for InvertIterator<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for InvertIterator<A, T> {\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for InvertIterator<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n@@ -118,7 +125,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, Self, U>;\n+    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<Self, U>;\n \n     /// Creates an iterator which iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n@@ -134,7 +141,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, Self, B, U>;\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<Self, U>;\n \n     // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n@@ -191,7 +198,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn enumerate(self) -> EnumerateIterator<A, Self>;\n+    fn enumerate(self) -> EnumerateIterator<Self>;\n \n     /// Creates an iterator which invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n@@ -236,7 +243,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &5);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn skip(self, n: uint) -> SkipIterator<A, Self>;\n+    fn skip(self, n: uint) -> SkipIterator<Self>;\n \n     // FIXME: #5898: should be called take\n     /// Creates an iterator which yields the first `n` elements of this\n@@ -252,7 +259,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &3);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take_(self, n: uint) -> TakeIterator<A, Self>;\n+    fn take_(self, n: uint) -> TakeIterator<Self>;\n \n     /// Creates a new iterator which behaves in a similar fashion to foldl.\n     /// There is a state which is passed between each iteration and can be\n@@ -295,7 +302,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~\n     // FIXME: #5898: should be called `flat_map`\n     fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMapIterator<'r, A, B, Self, U>;\n+        -> FlatMapIterator<'r, A, Self, U>;\n \n     /// Creates an iterator that calls a function with a reference to each\n     /// element before yielding it. This is often useful for debugging an\n@@ -462,12 +469,12 @@ pub trait IteratorUtil<A> {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n-    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n+    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n     #[inline]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, T, B, U> {\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n         ZipIterator{a: self, b: other}\n     }\n \n@@ -488,7 +495,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline]\n-    fn enumerate(self) -> EnumerateIterator<A, T> {\n+    fn enumerate(self) -> EnumerateIterator<T> {\n         EnumerateIterator{iter: self, count: 0}\n     }\n \n@@ -503,13 +510,13 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline]\n-    fn skip(self, n: uint) -> SkipIterator<A, T> {\n+    fn skip(self, n: uint) -> SkipIterator<T> {\n         SkipIterator{iter: self, n: n}\n     }\n \n     // FIXME: #5898: should be called take\n     #[inline]\n-    fn take_(self, n: uint) -> TakeIterator<A, T> {\n+    fn take_(self, n: uint) -> TakeIterator<T> {\n         TakeIterator{iter: self, n: n}\n     }\n \n@@ -521,7 +528,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     #[inline]\n     fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMapIterator<'r, A, B, T, U> {\n+        -> FlatMapIterator<'r, A, T, U> {\n         FlatMapIterator{iter: self, f: f, subiter: None }\n     }\n \n@@ -756,8 +763,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// A trait for iterators that are clonable.\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n-pub trait ClonableIterator<A> {\n+pub trait ClonableIterator {\n     /// Repeats an iterator endlessly\n     ///\n     /// # Example\n@@ -768,24 +774,24 @@ pub trait ClonableIterator<A> {\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n     /// ~~~\n-    fn cycle(self) -> CycleIterator<A, Self>;\n+    fn cycle(self) -> CycleIterator<Self>;\n }\n \n-impl<A, T: Clone + Iterator<A>> ClonableIterator<A> for T {\n+impl<A, T: Clone + Iterator<A>> ClonableIterator for T {\n     #[inline]\n-    fn cycle(self) -> CycleIterator<A, T> {\n+    fn cycle(self) -> CycleIterator<T> {\n         CycleIterator{orig: self.clone(), iter: self}\n     }\n }\n \n /// An iterator that repeats endlessly\n #[deriving(Clone)]\n-pub struct CycleIterator<A, T> {\n+pub struct CycleIterator<T> {\n     priv orig: T,\n     priv iter: T,\n }\n \n-impl<A, T: Clone + Iterator<A>> Iterator<A> for CycleIterator<A, T> {\n+impl<A, T: Clone + Iterator<A>> Iterator<A> for CycleIterator<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.iter.next() {\n@@ -806,15 +812,14 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for CycleIterator<A, T> {\n }\n \n /// An iterator which strings two iterators together\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n #[deriving(Clone)]\n-pub struct ChainIterator<A, T, U> {\n+pub struct ChainIterator<T, U> {\n     priv a: T,\n     priv b: U,\n     priv flag: bool\n }\n \n-impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n+impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -851,7 +856,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n }\n \n impl<A, T: DoubleEndedIterator<A>, U: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n-for ChainIterator<A, T, U> {\n+for ChainIterator<T, U> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         match self.b.next_back() {\n@@ -862,7 +867,7 @@ for ChainIterator<A, T, U> {\n }\n \n impl<A, T: RandomAccessIterator<A>, U: RandomAccessIterator<A>> RandomAccessIterator<A>\n-for ChainIterator<A, T, U> {\n+for ChainIterator<T, U> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n@@ -886,14 +891,13 @@ for ChainIterator<A, T, U> {\n }\n \n /// An iterator which iterates two other iterators simultaneously\n-// FIXME #6967: Dummy A & B parameters to get around type inference bug\n #[deriving(Clone)]\n-pub struct ZipIterator<A, T, B, U> {\n+pub struct ZipIterator<T, U> {\n     priv a: T,\n     priv b: U\n }\n \n-impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<A, T, B, U> {\n+impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<(A, B)> {\n         match (self.a.next(), self.b.next()) {\n@@ -1040,14 +1044,13 @@ for FilterMapIterator<'self, A, B, T> {\n }\n \n /// An iterator which yields the current count and the element during iteration\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n #[deriving(Clone)]\n-pub struct EnumerateIterator<A, T> {\n+pub struct EnumerateIterator<T> {\n     priv iter: T,\n     priv count: uint\n }\n \n-impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<A, T> {\n+impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<T> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, A)> {\n         match self.iter.next() {\n@@ -1139,14 +1142,13 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhileIterator<'self, A, T> {\n }\n \n /// An iterator which skips over `n` elements of `iter`.\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n #[deriving(Clone)]\n-pub struct SkipIterator<A, T> {\n+pub struct SkipIterator<T> {\n     priv iter: T,\n     priv n: uint\n }\n \n-impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<A, T> {\n+impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let mut next = self.iter.next();\n@@ -1188,14 +1190,13 @@ impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<A, T> {\n }\n \n /// An iterator which only iterates over the first `n` iterations of `iter`.\n-// FIXME #6967: Dummy A parameter to get around type inference bug\n #[deriving(Clone)]\n-pub struct TakeIterator<A, T> {\n+pub struct TakeIterator<T> {\n     priv iter: T,\n     priv n: uint\n }\n \n-impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<A, T> {\n+impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n@@ -1247,15 +1248,14 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for ScanIterator<'self, A, B,\n /// An iterator that maps each element to an iterator,\n /// and yields the elements of the produced iterators\n ///\n-// FIXME #6967: Dummy B parameter to get around type inference bug\n-pub struct FlatMapIterator<'self, A, B, T, U> {\n+pub struct FlatMapIterator<'self, A, T, U> {\n     priv iter: T,\n     priv f: &'self fn(A) -> U,\n     priv subiter: Option<U>,\n }\n \n impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n-    FlatMapIterator<'self, A, B, T, U> {\n+    FlatMapIterator<'self, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {"}, {"sha": "379deff233c621b2b03b4aaaf9181cb9101f61d4", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b027c5fce3e74dfa5583224967e38ef40518ecfb/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=b027c5fce3e74dfa5583224967e38ef40518ecfb", "patch": "@@ -49,12 +49,11 @@ pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do v.as_mut_buf |p, _len| {\n-            let mut i: uint = 0u;\n-            while i < n_elts {\n-                intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n-                i += 1u;\n-            }\n+        let p = raw::to_mut_ptr(v);\n+        let mut i: uint = 0u;\n+        while i < n_elts {\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n+            i += 1u;\n         }\n         raw::set_len(&mut v, n_elts);\n         v\n@@ -74,12 +73,11 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do v.as_mut_buf |p, _len| {\n-            let mut i = 0u;\n-            while i < n_elts {\n-                intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), t.clone());\n-                i += 1u;\n-            }\n+        let p = raw::to_mut_ptr(v);\n+        let mut i = 0u;\n+        while i < n_elts {\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), t.clone());\n+            i += 1u;\n         }\n         raw::set_len(&mut v, n_elts);\n         v\n@@ -1656,6 +1654,8 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n #[allow(missing_doc)]\n pub trait MutableVector<'self, T> {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n+    fn mut_slice_from(self, start: uint) -> &'self mut [T];\n+    fn mut_slice_to(self, end: uint) -> &'self mut [T];\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n     fn mut_rev_iter(self) -> VecMutRevIterator<'self, T>;\n \n@@ -1709,6 +1709,27 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    #[inline]\n+    fn mut_slice_from(self, start: uint) -> &'self mut [T] {\n+        let len = self.len();\n+        self.mut_slice(start, len)\n+    }\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    #[inline]\n+    fn mut_slice_to(self, end: uint) -> &'self mut [T] {\n+        self.mut_slice(0, end)\n+    }\n+\n     #[inline]\n     fn mut_split(self, mid: uint) -> (&'self mut [T], &'self mut [T]) {\n         unsafe {\n@@ -2145,7 +2166,7 @@ pub struct VecIterator<'self, T> {\n iterator!{impl VecIterator -> &'self T}\n double_ended_iterator!{impl VecIterator -> &'self T}\n random_access_iterator!{impl VecIterator -> &'self T}\n-pub type VecRevIterator<'self, T> = InvertIterator<&'self T, VecIterator<'self, T>>;\n+pub type VecRevIterator<'self, T> = InvertIterator<VecIterator<'self, T>>;\n \n impl<'self, T> Clone for VecIterator<'self, T> {\n     fn clone(&self) -> VecIterator<'self, T> { *self }\n@@ -2161,7 +2182,7 @@ pub struct VecMutIterator<'self, T> {\n iterator!{impl VecMutIterator -> &'self mut T}\n double_ended_iterator!{impl VecMutIterator -> &'self mut T}\n random_access_iterator!{impl VecMutIterator -> &'self mut T}\n-pub type VecMutRevIterator<'self, T> = InvertIterator<&'self mut T, VecMutIterator<'self, T>>;\n+pub type VecMutRevIterator<'self, T> = InvertIterator<VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n@@ -2203,7 +2224,7 @@ impl<T> Iterator<T> for VecConsumeRevIterator<T> {\n }\n \n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n-    pub fn from_iterator(iterator: &mut T) -> ~[A] {\n+    fn from_iterator(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let mut xs = with_capacity(lower);\n         for iterator.advance |x| {\n@@ -2213,6 +2234,17 @@ impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     }\n }\n \n+impl<A, T: Iterator<A>> Extendable<A, T> for ~[A] {\n+    fn extend(&mut self, iterator: &mut T) {\n+        let (lower, _) = iterator.size_hint();\n+        let len = self.len();\n+        self.reserve(len + lower);\n+        for iterator.advance |x| {\n+            self.push(x);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use option::{None, Option, Some};"}]}