{"sha": "1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOGIyYzQ5OGEwMWRjMmM5MmQ2MDA4Y2RjNWI2MTFjZjNhOTZiMWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-12T13:50:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-12T13:50:34Z"}, "message": "Merge #5637\n\n5637: SSR: Matching trait associated constants, types and functions r=matklad a=davidlattimore\n\nThis fixes matching of things like `HashMap::default()` by resolving `HashMap` instead of `default` (which resolves to `Default::default`).\r\n\r\nSame for associated constants and types that are part of a trait implementation.\r\n\r\nHowever, we still don't support matching calls to trait methods.\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "e1f4652227443b07f592ba156dad938e11ef2e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1f4652227443b07f592ba156dad938e11ef2e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfM/OqCRBK7hj4Ov3rIwAAdHIIACIryIp//FeAw4/dtl9+b8FK\nlNsU6LGSRhxvhYoeFBYCjY73mFBOgekZ4yg6gBDIEP2k+CLWgKYFr5uo9cgAA7rp\nZZBMyzAnpBj108GYoQ/bxaBjrIcGfX594XOwj4F6nn3hCUGiKktFn1JtFzEWR4BQ\njFCZQBZnDS2isxhU+niQiV7I2NTncCv2/GaKh05YAqroaPMs0BzP3PMac60MFAgP\n2Ae7J6Vsm2JHSC40yCfjEnPe8eWVtaA9Y4Xhv2hRzCqgL5NlZkRKYr5fN96nfioF\nxNcIHs5Kmk9SHQJ3xxMY0XjqbBA7CdV1y1eRMsCYduZPUU7IQkSB6Uw/64rAsXY=\n=ZLWT\n-----END PGP SIGNATURE-----\n", "payload": "tree e1f4652227443b07f592ba156dad938e11ef2e0b\nparent 5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a\nparent 21d2cebcf1a417bce72da98aa638a20235c050db\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597240234 +0000\ncommitter GitHub <noreply@github.com> 1597240234 +0000\n\nMerge #5637\n\n5637: SSR: Matching trait associated constants, types and functions r=matklad a=davidlattimore\n\nThis fixes matching of things like `HashMap::default()` by resolving `HashMap` instead of `default` (which resolves to `Default::default`).\r\n\r\nSame for associated constants and types that are part of a trait implementation.\r\n\r\nHowever, we still don't support matching calls to trait methods.\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "html_url": "https://github.com/rust-lang/rust/commit/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "html_url": "https://github.com/rust-lang/rust/commit/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a"}, {"sha": "21d2cebcf1a417bce72da98aa638a20235c050db", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d2cebcf1a417bce72da98aa638a20235c050db", "html_url": "https://github.com/rust-lang/rust/commit/21d2cebcf1a417bce72da98aa638a20235c050db"}], "stats": {"total": 99, "additions": 93, "deletions": 6}, "files": [{"sha": "8be862fd6e1d74de334703742a355b0de1befa8b", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "patch": "@@ -21,8 +21,8 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // replacement occurs. For example if our replacement template is `foo::Bar` and we match some\n // code in the `foo` module, we'll insert just `Bar`.\n //\n-// Method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will match\n-// `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+// Inherent method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will\n+// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n //\n // The scope of the search / replace will be restricted to the current selection if any, otherwise\n // it will apply to the whole workspace."}, {"sha": "d53bd46c77fc5f2a1b7a930592eb6a70039c909e", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "patch": "@@ -5,7 +5,7 @@ use crate::{parsing, SsrError};\n use parsing::Placeholder;\n use ra_db::FilePosition;\n use ra_syntax::{ast, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use test_utils::mark;\n \n pub(crate) struct ResolutionScope<'db> {\n@@ -124,8 +124,10 @@ impl Resolver<'_, '_> {\n                     .resolution_scope\n                     .resolve_path(&path)\n                     .ok_or_else(|| error!(\"Failed to resolve path `{}`\", node.text()))?;\n-                resolved_paths.insert(node, ResolvedPath { resolution, depth });\n-                return Ok(());\n+                if self.ok_to_use_path_resolution(&resolution) {\n+                    resolved_paths.insert(node, ResolvedPath { resolution, depth });\n+                    return Ok(());\n+                }\n             }\n         }\n         for node in node.children() {\n@@ -149,6 +151,27 @@ impl Resolver<'_, '_> {\n         }\n         false\n     }\n+\n+    fn ok_to_use_path_resolution(&self, resolution: &hir::PathResolution) -> bool {\n+        match resolution {\n+            hir::PathResolution::AssocItem(hir::AssocItem::Function(function)) => {\n+                if function.has_self_param(self.resolution_scope.scope.db) {\n+                    // If we don't use this path resolution, then we won't be able to match method\n+                    // calls. e.g. `Foo::bar($s)` should match `x.bar()`.\n+                    true\n+                } else {\n+                    mark::hit!(replace_associated_trait_default_function_call);\n+                    false\n+                }\n+            }\n+            hir::PathResolution::AssocItem(_) => {\n+                // Not a function. Could be a constant or an associated type.\n+                mark::hit!(replace_associated_trait_constant);\n+                false\n+            }\n+            _ => true,\n+        }\n+    }\n }\n \n impl<'db> ResolutionScope<'db> {\n@@ -195,7 +218,7 @@ impl<'db> ResolutionScope<'db> {\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 self.scope.module()?.krate(),\n-                &FxHashSet::default(),\n+                &self.scope.traits_in_scope(),\n                 Some(hir_path.segments().last()?.name),\n                 |_ty, assoc_item| Some(hir::PathResolution::AssocItem(assoc_item)),\n             )"}, {"sha": "7d4d470c0eda1889121fd733bc9d1ab5e6441fde", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=1e8b2c498a01dc2c92d6008cdc5b611cf3a96b1e", "patch": "@@ -549,6 +549,70 @@ fn replace_associated_function_call() {\n     );\n }\n \n+#[test]\n+fn replace_associated_trait_default_function_call() {\n+    mark::check!(replace_associated_trait_default_function_call);\n+    assert_ssr_transform(\n+        \"Bar2::foo() ==>> Bar2::foo2()\",\n+        r#\"\n+            trait Foo { fn foo() {} }\n+            pub struct Bar {}\n+            impl Foo for Bar {}\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 {}\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::foo();\n+                Bar2::foo();\n+            }\n+        \"#,\n+        expect![[r#\"\n+            trait Foo { fn foo() {} }\n+            pub struct Bar {}\n+            impl Foo for Bar {}\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 {}\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::foo();\n+                Bar2::foo2();\n+            }\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_associated_trait_constant() {\n+    mark::check!(replace_associated_trait_constant);\n+    assert_ssr_transform(\n+        \"Bar2::VALUE ==>> Bar2::VALUE_2222\",\n+        r#\"\n+            trait Foo { const VALUE: i32; const VALUE_2222: i32; }\n+            pub struct Bar {}\n+            impl Foo for Bar { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::VALUE;\n+                Bar2::VALUE;\n+            }\n+            \"#,\n+        expect![[r#\"\n+            trait Foo { const VALUE: i32; const VALUE_2222: i32; }\n+            pub struct Bar {}\n+            impl Foo for Bar { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::VALUE;\n+                Bar2::VALUE_2222;\n+            }\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn replace_path_in_different_contexts() {\n     // Note the <|> inside module a::b which marks the point where the rule is interpreted. We"}]}