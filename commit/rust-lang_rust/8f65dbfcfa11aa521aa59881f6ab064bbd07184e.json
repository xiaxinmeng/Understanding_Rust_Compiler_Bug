{"sha": "8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNjVkYmZjZmExMWFhNTIxYWE1OTg4MWY2YWIwNjRiYmQwNzE4NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-08T21:32:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-08T21:32:02Z"}, "message": "auto merge of #8385 : cmr/rust/big-rollup, r=alexcrichton\n\nThis is a fairly large rollup, but I've tested everything locally, and none of\r\nit should be platform-specific.\r\n\r\nr=alexcrichton (bdfdbdd)\r\nr=brson (d803c18)\r\nr=alexcrichton (a5041d0)\r\nr=bstrie (317412a)\r\nr=alexcrichton (135c85e)\r\nr=thestinger (8805baa)\r\nr=pcwalton (0661178)\r\nr=cmr (9397fe0)\r\nr=cmr (caa4135)\r\nr=cmr (6a21d93)\r\nr=cmr (4dc3379)\r\nr=cmr (0aa5154)\r\nr=cmr (18be261)\r\nr=thestinger (f10be03)", "tree": {"sha": "8d482dd18bcf6651529fa26941b7a1598cd3dfc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d482dd18bcf6651529fa26941b7a1598cd3dfc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "html_url": "https://github.com/rust-lang/rust/commit/8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0080f4e07891c89aa1f9851f8b0a3c754734fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0080f4e07891c89aa1f9851f8b0a3c754734fe8", "html_url": "https://github.com/rust-lang/rust/commit/a0080f4e07891c89aa1f9851f8b0a3c754734fe8"}, {"sha": "878e74e1cedd80a909e06073f8fb677d6ffd895f", "url": "https://api.github.com/repos/rust-lang/rust/commits/878e74e1cedd80a909e06073f8fb677d6ffd895f", "html_url": "https://github.com/rust-lang/rust/commit/878e74e1cedd80a909e06073f8fb677d6ffd895f"}], "stats": {"total": 1316, "additions": 762, "deletions": 554}, "files": [{"sha": "d1aa793e5fc1b83d0501baea22f99cbf542b66c8", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -228,6 +228,48 @@ unsafe fn kaboom(ptr: *int) -> int { *ptr }\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n \n+# Accessing foreign globals\n+\n+Foreign APIs often export a global variable which could do something like track\n+global state. In order to access these variables, you declare them in `extern`\n+blocks with the `static` keyword:\n+\n+~~~{.xfail-test}\n+use std::libc;\n+\n+#[link_args = \"-lreadline\"]\n+extern {\n+    static rl_readline_version: libc::c_int;\n+}\n+\n+fn main() {\n+    println(fmt!(\"You have readline version %d installed.\",\n+                 rl_readline_version as int));\n+}\n+~~~\n+\n+Alternatively, you may need to alter global state provided by a foreign\n+interface. To do this, statics can be declared with `mut` so rust can mutate\n+them.\n+\n+~~~{.xfail-test}\n+use std::libc;\n+use std::ptr;\n+\n+#[link_args = \"-lreadline\"]\n+extern {\n+    static mut rl_prompt: *libc::c_char;\n+}\n+\n+fn main() {\n+    do \"[my-awesome-shell] $\".as_c_str |buf| {\n+        unsafe { rl_prompt = buf; }\n+        // get a line, process it\n+        unsafe { rl_prompt = ptr::null(); }\n+    }\n+}\n+~~~\n+\n # Foreign calling conventions\n \n Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when"}, {"sha": "40e276ae04a158e92ecaf413bfbb12734f7d42a2", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -2288,8 +2288,8 @@ pub mod farm {\n     }\n \n     impl Farm {\n-        priv fn feed_chickens(&self) { ... }\n-        priv fn feed_cows(&self) { ... }\n+        fn feed_chickens(&self) { ... }\n+        fn feed_cows(&self) { ... }\n         pub fn add_chicken(&self, c: Chicken) { ... }\n     }\n "}, {"sha": "9c176b504b2ee61fcb7440687d91412b294f0fad", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -412,8 +412,8 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n     }\n \n-    for i in range(0u, found_flags.len()) {\n-        if !found_flags[i] {\n+    for (i, &flag) in found_flags.iter().enumerate() {\n+        if !flag {\n             let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n                                ee.kind, ee.line, ee.msg), ProcRes);"}, {"sha": "b1180098bd2acc3ce7ed618888548b25de7acb9c", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -50,6 +50,7 @@\n \t\t<keyword>for</keyword>\n \t\t<keyword>if</keyword>\n \t\t<keyword>impl</keyword>\n+\t\t<keyword>in</keyword>\n \t\t<keyword>let</keyword>\n \t\t<keyword>log</keyword>\n \t\t<keyword>loop</keyword>"}, {"sha": "69203b753cdc5c0159bf7be6e83092771b2e721a", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -847,22 +847,16 @@ mod tests {\n                 }\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n-                // FIXME: #7372: hits type inference bug with iterators\n                 // send to other readers\n-                for i in range(0u, reader_convos.len()) {\n-                    match reader_convos[i] {\n-                        (ref rc, _) => rc.send(()),\n-                    }\n+                for &(ref rc, _) in reader_convos.iter() {\n+                    rc.send(())\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n-                // FIXME: #7372: hits type inference bug with iterators\n                 // complete handshake with other readers\n-                for i in range(0u, reader_convos.len()) {\n-                    match reader_convos[i] {\n-                        (_, ref rp) => rp.recv(),\n-                    }\n+                for &(_, ref rp) in reader_convos.iter() {\n+                    rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n                 assert_eq!(*state, 31337);"}, {"sha": "20a3add3e7b3d64e7a79d6b03daaa9af6ada9ec3", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -145,22 +145,24 @@ impl BigBitv {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n-        for i in range(0, len) {\n+        for (i, (a, b)) in self.storage.mut_iter()\n+                               .zip(b.storage.iter())\n+                               .enumerate() {\n             let mask = big_mask(nbits, i);\n-            let w0 = self.storage[i] & mask;\n-            let w1 = b.storage[i] & mask;\n+            let w0 = *a & mask;\n+            let w1 = *b & mask;\n             let w = op(w0, w1) & mask;\n             if w0 != w {\n                 changed = true;\n-                self.storage[i] = w;\n+                *a = w;\n             }\n         }\n         changed\n     }\n \n     #[inline]\n     pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n-        range(0u, self.storage.len()).advance(|i| op(&mut self.storage[i]))\n+        self.storage.mut_iter().advance(|elt| op(elt))\n     }\n \n     #[inline]\n@@ -205,10 +207,9 @@ impl BigBitv {\n \n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n-        let len = b.storage.len();\n-        for i in range(0, len) {\n+        for (i, elt) in b.storage.iter().enumerate() {\n             let mask = big_mask(nbits, i);\n-            if mask & self.storage[i] != mask & b.storage[i] {\n+            if mask & self.storage[i] != mask & *elt {\n                 return false;\n             }\n         }"}, {"sha": "14b02688cffcfc1481ff2927727b3ab5c0981a1e", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -129,27 +129,27 @@ struct FileInput_ {\n     `Some(path)` is the file represented by `path`, `None` is\n     `stdin`. Consumed as the files are read.\n     */\n-    priv files: ~[Option<Path>],\n+    files: ~[Option<Path>],\n     /**\n     The current file: `Some(r)` for an open file, `None` before\n     starting and after reading everything.\n     */\n-    priv current_reader: Option<@io::Reader>,\n-    priv state: FileInputState,\n+    current_reader: Option<@io::Reader>,\n+    state: FileInputState,\n \n     /**\n     Used to keep track of whether we need to insert the newline at the\n     end of a file that is missing it, which is needed to separate the\n     last and first lines.\n     */\n-    priv previous_was_newline: bool\n+    previous_was_newline: bool\n }\n \n // XXX: remove this when Reader has &mut self. Should be removable via\n // \"self.fi.\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    priv fi: @mut FileInput_\n+    fi: @mut FileInput_\n }\n \n impl FileInput {\n@@ -198,7 +198,7 @@ impl FileInput {\n         FileInput::from_vec(pathed)\n     }\n \n-    priv fn current_file_eof(&self) -> bool {\n+    fn current_file_eof(&self) -> bool {\n         match self.fi.current_reader {\n             None => false,\n             Some(r) => r.eof()\n@@ -240,7 +240,7 @@ impl FileInput {\n     Returns `true` if it had to move to the next file and did\n     so successfully.\n     */\n-    priv fn next_file_if_eof(&self) -> bool {\n+    fn next_file_if_eof(&self) -> bool {\n         match self.fi.current_reader {\n             None => self.next_file(),\n             Some(r) => {"}, {"sha": "ed8cbcd0663f3f9874afc34e6ef92a827c76eeae", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -43,16 +43,18 @@ static LZ_NONE : c_int = 0x0;   // Huffman-coding only.\n static LZ_FAST : c_int = 0x1;   // LZ with only one probe\n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n+static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n+static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n                                                    &mut outsz,\n-                                                   LZ_NORM);\n+                                                   flags);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n@@ -62,15 +64,23 @@ pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    deflate_bytes_internal(bytes, LZ_NORM)\n+}\n+\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n+    deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n+}\n+\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n                                                      &mut outsz,\n-                                                     0);\n+                                                     flags);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n@@ -80,6 +90,14 @@ pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n     }\n }\n \n+pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    inflate_bytes_internal(bytes, 0)\n+}\n+\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n+    inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -109,4 +127,12 @@ mod tests {\n             assert_eq!(input, out);\n         }\n     }\n+\n+    #[test]\n+    fn test_zlib_flate() {\n+        let bytes = ~[1, 2, 3, 4, 5];\n+        let deflated = deflate_bytes(bytes);\n+        let inflated = inflate_bytes(deflated);\n+        assert_eq!(inflated, bytes);\n+    }\n }"}, {"sha": "cc65c49d73a9c2b569619591a145df84c8036d3f", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -46,7 +46,7 @@ impl<A> Drop for Future<A> {\n     fn drop(&self) {}\n }\n \n-priv enum FutureState<A> {\n+enum FutureState<A> {\n     Pending(~fn() -> A),\n     Evaluating,\n     Forced(A)"}, {"sha": "1b65528923a100c16a5c50108447d92dd1a637e1", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 90, "deletions": 39, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -114,7 +114,8 @@ pub enum Occur {\n pub struct Opt {\n     name: Name,\n     hasarg: HasArg,\n-    occur: Occur\n+    occur: Occur,\n+    aliases: ~[Opt],\n }\n \n fn mkname(nm: &str) -> Name {\n@@ -127,37 +128,37 @@ fn mkname(nm: &str) -> Name {\n \n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Req};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Req, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an argument\n pub fn optopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Optional, aliases: ~[]};\n }\n \n /// Create an option that is optional and does not take an argument\n pub fn optflag(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: No, occur: Optional, aliases: ~[]};\n }\n \n /** Create an option that is optional, does not take an argument,\n   * and may occur multiple times.\n   */\n pub fn optflagmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: No, occur: Multi, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an optional argument\n pub fn optflagopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional, aliases: ~[]};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n pub fn optmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Multi, aliases: ~[]};\n }\n \n #[deriving(Clone, Eq)]\n@@ -189,7 +190,20 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    opts.iter().position(|opt| opt.name == nm)\n+    // search main options\n+    let pos = opts.iter().position(|opt| opt.name == nm);\n+    if pos.is_some() {\n+        return pos\n+    }\n+\n+    // search in aliases\n+    for candidate in opts.iter() {\n+        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n+            return opts.iter().position(|opt| opt.name == candidate.name);\n+        }\n+    }\n+\n+    None\n }\n \n /**\n@@ -488,8 +502,6 @@ pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    use std::vec;\n-\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n@@ -542,6 +554,20 @@ pub mod groups {\n                 occur: Optional};\n     }\n \n+    /// Create a long option that can occur more than once and does not\n+    /// take an argument\n+    pub fn optflagmulti(short_name: &str, long_name: &str,\n+                   desc: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: ~\"\",\n+                desc: desc.to_owned(),\n+                hasarg: No,\n+                occur: Multi};\n+    }\n+\n     /// Create a long option that is optional and takes an optional argument\n     pub fn optflagopt(short_name: &str, long_name: &str,\n                       desc: &str, hint: &str) -> OptGroup {\n@@ -573,40 +599,45 @@ pub mod groups {\n \n     // translate OptGroup into Opt\n     // (both short and long names correspond to different Opts)\n-    pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n+    pub fn long_to_short(lopt: &OptGroup) -> Opt {\n         let OptGroup{short_name: short_name,\n                      long_name: long_name,\n                      hasarg: hasarg,\n                      occur: occur,\n                      _} = (*lopt).clone();\n \n         match (short_name.len(), long_name.len()) {\n-           (0,0) => fail!(\"this long-format option was given no name\"),\n-\n-           (0,_) => ~[Opt {name: Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur:  occur},\n-                      Opt {name:   Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur:  occur}],\n-\n-           (_,_) => fail!(\"something is wrong with the long-form opt\")\n+            (0,0) => fail!(\"this long-format option was given no name\"),\n+\n+            (0,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,0) => Opt {name: Short(short_name.char_at(0)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur:  occur,\n+                          aliases: ~[Opt {\n+                              name: Short(short_name.char_at(0)),\n+                              hasarg: hasarg,\n+                              occur:  occur,\n+                              aliases: ~[]\n+                          }]},\n+\n+            (_,_) => fail!(\"something is wrong with the long-form opt\")\n         }\n     }\n \n     /*\n      * Parse command line args with the provided long format options\n      */\n     pub fn getopts(args: &[~str], opts: &[OptGroup]) -> ::getopts::Result {\n-        ::getopts::getopts(args, vec::flat_map(opts, long_to_short))\n+        ::getopts::getopts(args, opts.map(long_to_short))\n     }\n \n     /**\n@@ -708,9 +739,9 @@ pub mod groups {\n      *  Fails during iteration if the string contains a non-whitespace\n      *  sequence longer than the limit.\n      */\n-    priv fn each_split_within<'a>(ss: &'a str,\n-                                lim: uint,\n-                                it: &fn(&'a str) -> bool) -> bool {\n+    fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) -> bool {\n         // Just for fun, let's write this as an state machine:\n \n         enum SplitWithinState {\n@@ -778,7 +809,7 @@ pub mod groups {\n     }\n \n     #[test]\n-    priv fn test_split_within() {\n+    fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n             do each_split_within(s, i) |s| { v.push(s.to_owned()); true };\n@@ -1440,18 +1471,25 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let short = ~[reqopt(\"b\"), reqopt(\"banana\")];\n+        let mut short = reqopt(\"banana\");\n+        short.aliases = ~[reqopt(\"b\")];\n         let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n+        let mut banana = reqopt(\"banana\");\n+        banana.aliases = ~[reqopt(\"b\")];\n+        let mut apple = optopt(\"apple\");\n+        apple.aliases = ~[optopt(\"a\")];\n+        let mut kiwi = optflag(\"kiwi\");\n+        kiwi.aliases = ~[optflag(\"k\")];\n         let short = ~[\n-            reqopt(\"b\"), reqopt(\"banana\"),\n-            optopt(\"a\"), optopt(\"apple\"),\n-            optflag(\"k\"), optflagopt(\"kiwi\"),\n+            banana,\n+            apple,\n+            kiwi,\n             optflagopt(\"p\"),\n             optmulti(\"l\")\n         ];\n@@ -1464,14 +1502,27 @@ mod tests {\n             groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n-        let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n+        let sample_args = ~[~\"--kiwi\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n         assert!(getopts(sample_args, short)\n             == groups::getopts(sample_args, verbose));\n     }\n \n+    #[test]\n+    fn test_groups_aliases_long_and_short() {\n+        let opts = ~[\n+            groups::optflagmulti(\"a\", \"apple\", \"Desc\"),\n+        ];\n+\n+        let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n+\n+        let matches = groups::getopts(args, opts).unwrap();\n+        assert_eq!(3, opt_count(&matches, \"a\"));\n+        assert_eq!(3, opt_count(&matches, \"apple\"));\n+    }\n+\n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~["}, {"sha": "0c8701bd0b515b1db16a6dc7dc5f0b958cdb0558", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -59,13 +59,13 @@ pub mod BigDigit {\n     pub static bits: uint = 32;\n \n     pub static base: uint = 1 << bits;\n-    priv static hi_mask: uint = (-1 as uint) << bits;\n-    priv static lo_mask: uint = (-1 as uint) >> bits;\n+    static hi_mask: uint = (-1 as uint) << bits;\n+    static lo_mask: uint = (-1 as uint) >> bits;\n \n \n-    priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n \n-    priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+    fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n \n@@ -613,15 +613,15 @@ impl BigUint {\n     }\n \n \n-    priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n+    fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n         return BigUint::new(vec::from_elem(n_unit, ZERO_BIG_DIGIT)\n                             + self.data);\n     }\n \n \n-    priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n+    fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n@@ -637,7 +637,7 @@ impl BigUint {\n     }\n \n \n-    priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n+    fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return (*self).clone(); }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n@@ -646,7 +646,7 @@ impl BigUint {\n     }\n \n \n-    priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n+    fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n         let mut borrow = 0;\n@@ -661,7 +661,7 @@ impl BigUint {\n \n #[cfg(target_arch = \"x86_64\")]\n \n-priv fn get_radix_base(radix: uint) -> (uint, uint) {\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n@@ -687,7 +687,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n \n-priv fn get_radix_base(radix: uint) -> (uint, uint) {\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),"}, {"sha": "a601270e8ece16c80c27031c966ed22b69578daa", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 51, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -16,7 +16,6 @@\n #[allow(missing_doc)];\n \n use std::iterator::{Iterator, IteratorUtil, Enumerate, FilterMap, Invert};\n-use std::uint;\n use std::util::replace;\n use std::vec::{VecIterator, VecMutIterator};\n use std::vec;\n@@ -29,14 +28,12 @@ pub struct SmallIntMap<T> {\n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint {\n-        let mut sz = 0;\n-        for i in range(0u, self.v.len()) {\n-            match self.v[i] {\n-                Some(_) => sz += 1,\n-                None => {}\n-            }\n-        }\n-        sz\n+        self.v.iter().count(|elt| elt.is_some())\n+    }\n+\n+    /// Return true if there are no elements in the map\n+    fn is_empty(&self) -> bool {\n+        self.v.iter().all(|elt| elt.is_none())\n     }\n }\n \n@@ -116,48 +113,6 @@ impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n-    /// Visit all key-value pairs in order\n-    pub fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n-        for i in range(0u, self.v.len()) {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Visit all keys in order\n-    pub fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n-        self.each(|k, _| blk(k))\n-    }\n-\n-    /// Visit all values in order\n-    pub fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    pub fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n-        for i in range(0, self.v.len()) {\n-            match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n-        do uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => it(i, elt),\n-              None => true\n-            }\n-        }\n-    }\n-\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "daafdbc37182d581a8fc82c4c36ab2939f70daa2", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -469,10 +469,7 @@ impl<T:Clone + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n-        let mut tmp = ~[];\n-        for i in range(base1, base1+len1) {\n-            tmp.push(array[i].clone());\n-        }\n+        let mut tmp = array.slice(base1, base1 + len1).to_owned();\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -579,10 +576,7 @@ impl<T:Clone + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n-        let mut tmp = ~[];\n-        for i in range(base2, base2+len2) {\n-            tmp.push(array[i].clone());\n-        }\n+        let mut tmp = array.slice(base2, base2 + len2).to_owned();\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;"}, {"sha": "881d931fe0acc21749287991d5826564c8ded3c8", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -223,7 +223,7 @@ impl<'self> Stats for &'self [f64] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-priv fn percentile_of_sorted(sorted_samples: &[f64],\n+fn percentile_of_sorted(sorted_samples: &[f64],\n                              pct: f64) -> f64 {\n     assert!(sorted_samples.len() != 0);\n     if sorted_samples.len() == 1 {"}, {"sha": "d0412b8954db2abc963e43f87979ca96503709c8", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -75,7 +75,7 @@ pub mod attr {\n }\n \n #[cfg(not(target_os = \"win32\"))]\n-priv fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+fn cap_for_attr(attr: attr::Attr) -> &'static str {\n     match attr {\n         attr::Bold               => \"bold\",\n         attr::Dim                => \"dim\",\n@@ -234,7 +234,7 @@ impl Terminal {\n         }\n     }\n \n-    priv fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n         if color >= self.num_colors && color >= 8 && color < 16 {\n             color-8\n         } else { color }"}, {"sha": "0929575ee9e70bc1eb089e56b0d248d0f70f360c", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -430,7 +430,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n }\n \n #[deriving(Eq)]\n-priv struct Flags {\n+struct Flags {\n     width: uint,\n     precision: uint,\n     alternate: bool,\n@@ -440,13 +440,13 @@ priv struct Flags {\n }\n \n impl Flags {\n-    priv fn new() -> Flags {\n+    fn new() -> Flags {\n         Flags{ width: 0, precision: 0, alternate: false,\n                left: false, sign: false, space: false }\n     }\n }\n \n-priv enum FormatOp {\n+enum FormatOp {\n     FormatDigit,\n     FormatOctal,\n     FormatHex,\n@@ -455,7 +455,7 @@ priv enum FormatOp {\n }\n \n impl FormatOp {\n-    priv fn from_char(c: char) -> FormatOp {\n+    fn from_char(c: char) -> FormatOp {\n         match c {\n             'd' => FormatDigit,\n             'o' => FormatOctal,\n@@ -465,7 +465,7 @@ impl FormatOp {\n             _ => fail!(\"bad FormatOp char\")\n         }\n     }\n-    priv fn to_char(self) -> char {\n+    fn to_char(self) -> char {\n         match self {\n             FormatDigit => 'd',\n             FormatOctal => 'o',\n@@ -476,7 +476,7 @@ impl FormatOp {\n     }\n }\n \n-priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n             match op {"}, {"sha": "f6a5fd98234b58aabab5898bdc13b9137c500ee3", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -254,7 +254,7 @@ impl Tm {\n     }\n }\n \n-priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for ch in needle.byte_iter() {\n@@ -687,7 +687,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n }\n \n-priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n+fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || fmt!(\"strftime: can't understand this format %c \", ch);"}, {"sha": "4d898dfb2b4f082d6d8be4cee9562785b3e5db72", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 203, "deletions": 193, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -13,7 +13,6 @@\n //! `TotalOrd`.\n \n \n-use std::num;\n use std::util::{swap, replace};\n use std::iterator::{FromIterator, Extendable};\n \n@@ -42,39 +41,23 @@ pub struct TreeMap<K, V> {\n \n impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n     fn eq(&self, other: &TreeMap<K, V>) -> bool {\n-        if self.len() != other.len() {\n-            false\n-        } else {\n-            let mut x = self.iter();\n-            let mut y = other.iter();\n-            for _ in range(0u, self.len()) {\n-                if x.next().unwrap() != y.next().unwrap() {\n-                    return false\n-                }\n-            }\n-            true\n-        }\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n-    fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n // Lexicographical comparison\n fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n-    let mut x = a.iter();\n-    let mut y = b.iter();\n-\n-    let (a_len, b_len) = (a.len(), b.len());\n-    for _ in range(0u, num::min(a_len, b_len)) {\n-        let (key_a, value_a) = x.next().unwrap();\n-        let (key_b, value_b) = y.next().unwrap();\n+    // the Zip iterator is as long as the shortest of a and b.\n+    for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n         if *key_a < *key_b { return true; }\n         if *key_a > *key_b { return false; }\n         if *value_a < *value_b { return true; }\n         if *value_a > *value_b { return false; }\n     }\n \n-    a_len < b_len\n+    a.len() < b.len()\n }\n \n impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n@@ -151,36 +134,11 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Visit all keys in order\n-    pub fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n-        self.iter().advance(|(k, _)| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    pub fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n-        self.iter().advance(|(_, v)| f(v))\n-    }\n-\n     /// Iterate over the map and mutate the contained values\n     pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n         mutate_values(&mut self.root, f)\n     }\n \n-    /// Visit all key-value pairs in reverse order\n-    pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n-        each_reverse(&self.root, f)\n-    }\n-\n-    /// Visit all keys in reverse order\n-    pub fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n-        self.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in reverse order\n-    pub fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n-        self.each_reverse(|_, v| f(v))\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -192,6 +150,12 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n         }\n     }\n \n+    /// Get a lazy reverse iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    pub fn rev_iter<'a>(&'a self) -> TreeMapRevIterator<'a, K, V> {\n+        TreeMapRevIterator{iter: self.iter()}\n+    }\n+\n     /// Get a lazy iterator that should be initialized using\n     /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -270,20 +234,18 @@ pub struct TreeMapIterator<'self, K, V> {\n     priv remaining_max: uint\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+impl<'self, K, V> TreeMapIterator<'self, K, V> {\n+    #[inline(always)]\n+    fn next_(&mut self, forward: bool) -> Option<(&'self K, &'self V)> {\n         while !self.stack.is_empty() || self.node.is_some() {\n             match *self.node {\n               Some(ref x) => {\n                 self.stack.push(x);\n-                self.node = &x.left;\n+                self.node = if forward { &x.left } else { &x.right };\n               }\n               None => {\n                 let res = self.stack.pop();\n-                self.node = &res.right;\n+                self.node = if forward { &res.right } else { &res.left };\n                 self.remaining_max -= 1;\n                 if self.remaining_min > 0 {\n                     self.remaining_min -= 1;\n@@ -294,13 +256,41 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n         }\n         None\n     }\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        self.next_(true)\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         (self.remaining_min, Some(self.remaining_max))\n     }\n }\n \n+/// Lazy backward iterator over a map\n+pub struct TreeMapRevIterator<'self, K, V> {\n+    priv iter: TreeMapIterator<'self, K, V>,\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapRevIterator<'self, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        self.iter.next_(false)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n /// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n /// initialize TreeMapIterator pointing to element inside tree structure.\n ///\n@@ -398,6 +388,14 @@ impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     }\n }\n \n+impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n+    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self T> {\n+        do self.iter.next().map |&(value, _)| { value }\n+    }\n+}\n+\n /// A implementation of the `Set` trait on top of the `TreeMap` container. The\n /// only requirement is that the type of the elements contained ascribes to the\n /// `TotalOrd` trait.\n@@ -449,20 +447,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-            match a1.cmp(b1) {\n-              Less => a = x.next(),\n-              Greater => b = y.next(),\n-              Equal => return false\n-            }\n-        }\n-        true\n+        self.intersection(other).next().is_none()\n     }\n \n     /// Return true if the set is a subset of another\n@@ -521,6 +506,13 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline]\n+    pub fn rev_iter<'a>(&'a self) -> TreeSetRevIterator<'a, T> {\n+        TreeSetRevIterator{iter: self.map.rev_iter()}\n+    }\n+\n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n     #[inline]\n@@ -535,138 +527,170 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.upper_bound_iter(v)}\n     }\n \n-    /// Visit all values in reverse order\n-    #[inline]\n-    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n+    /// Visit the values (in-order) representing the difference\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n     }\n \n-    /// Visit the values (in-order) representing the difference\n-    pub fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+    /// Visit the values (in-order) representing the symmetric difference\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> SymDifference<'a, T> {\n+        SymDifference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+    /// Visit the values (in-order) representing the intersection\n+    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> Intersection<'a, T> {\n+        Intersection{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+    /// Visit the values (in-order) representing the union\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n+        Union{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+/// Lazy forward iterator over a set\n+pub struct TreeSetIterator<'self, T> {\n+    priv iter: TreeMapIterator<'self, T, ()>\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy backward iterator over a set\n+pub struct TreeSetRevIterator<'self, T> {\n+    priv iter: TreeMapRevIterator<'self, T, ()>\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Equal { a = x.next() }\n-                b = y.next();\n-            }\n-        }\n-        return true;\n-    }\n+// Encapsulate an iterator and hold its latest value until stepped forward\n+struct Focus<A, T> {\n+    priv iter: T,\n+    priv focus: Option<A>,\n+}\n \n-    /// Visit the values (in-order) representing the symmetric difference\n-    pub fn symmetric_difference(&self, other: &TreeSet<T>,\n-                            f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+impl<A, T: Iterator<A>> Focus<A, T> {\n+    fn new(mut it: T) -> Focus<A, T> {\n+        Focus{focus: it.next(), iter: it}\n+    }\n+    fn step(&mut self) {\n+        self.focus = self.iter.next()\n+    }\n+}\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+/// Lazy iterator producing elements in the set difference (in-order)\n+pub struct Difference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+/// Lazy iterator producing elements in the set symmetric difference (in-order)\n+pub struct SymDifference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Intersection<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Union<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Greater {\n-                    if !f(b1) { return false; }\n-                } else {\n-                    a = x.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        if cmp == Equal { self.a.step() }\n+                        self.b.step();\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n+}\n \n-    /// Visit the values (in-order) representing the intersection\n-    pub fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                a = x.next();\n-            } else {\n-                if cmp == Equal {\n-                    if !f(a1) { return false }\n+impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (None    , ret     ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Greater {\n+                            return Some(b1);\n+                        } else {\n+                            self.a.step();\n+                        }\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        return true;\n     }\n+}\n \n-    /// Visit the values (in-order) representing the union\n-    pub fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (_       , None    ) => return None,\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Equal {\n+                            return Some(a1);\n+                        }\n+                    }\n+                },\n             }\n+        }\n+    }\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Greater {\n-                if !f(b1) { return false; }\n-                b = y.next();\n-            } else {\n-                if !f(a1) { return false; }\n-                if cmp == Equal {\n-                    b = y.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None) => { self.a.step(); return ret },\n+                (None    , ret ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Greater {\n+                        self.b.step();\n+                        return Some(b1);\n+                    } else {\n+                        self.a.step();\n+                        if cmp == Equal {\n+                            self.b.step();\n+                        }\n+                        return Some(a1);\n+                    }\n                 }\n-                a = x.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n }\n \n-/// Lazy forward iterator over a set\n-pub struct TreeSetIterator<'self, T> {\n-    priv iter: TreeMapIterator<'self, T, ()>\n-}\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n // leaves and with a red child sharing the level of the parent.\n@@ -687,18 +711,6 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                            f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each(&x.left,  |k,v| f(k,v)) && f(&x.key, &x.value) &&\n-                            each(&x.right, |k,v| f(k,v)))\n-}\n-\n-fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                                    f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each_reverse(&x.right, |k,v| f(k,v)) && f(&x.key, &x.value) &&\n-                            each_reverse(&x.left,  |k,v| f(k,v)))\n-}\n-\n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n                                      f: &fn(&'r K, &'r mut V) -> bool)\n                                   -> bool {\n@@ -1129,7 +1141,7 @@ mod test_treemap {\n     }\n \n     #[test]\n-    fn test_each_reverse() {\n+    fn test_rev_iter() {\n         let mut m = TreeMap::new();\n \n         assert!(m.insert(3, 6));\n@@ -1139,12 +1151,11 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        do m.each_reverse |k, v| {\n+        for (k, v) in m.rev_iter() {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n-            true\n-        };\n+        }\n     }\n \n     #[test]\n@@ -1405,7 +1416,7 @@ mod test_set {\n     }\n \n     #[test]\n-    fn test_each_reverse() {\n+    fn test_rev_iter() {\n         let mut m = TreeSet::new();\n \n         assert!(m.insert(3));\n@@ -1415,11 +1426,10 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 4;\n-        do m.each_reverse |x| {\n+        for x in m.rev_iter() {\n             assert_eq!(*x, n);\n             n -= 1;\n-            true\n-        };\n+        }\n     }\n \n     fn check(a: &[int], b: &[int], expected: &[int],\n@@ -1442,7 +1452,7 @@ mod test_set {\n     #[test]\n     fn test_intersection() {\n         fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.intersection(y, z))\n+            check(a, b, expected, |x, y, f| x.intersection(y).advance(f))\n         }\n \n         check_intersection([], [], []);\n@@ -1458,7 +1468,7 @@ mod test_set {\n     #[test]\n     fn test_difference() {\n         fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.difference(y, z))\n+            check(a, b, expected, |x, y, f| x.difference(y).advance(f))\n         }\n \n         check_difference([], [], []);\n@@ -1476,7 +1486,7 @@ mod test_set {\n     fn test_symmetric_difference() {\n         fn check_symmetric_difference(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.symmetric_difference(y, z))\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).advance(f))\n         }\n \n         check_symmetric_difference([], [], []);\n@@ -1491,7 +1501,7 @@ mod test_set {\n     fn test_union() {\n         fn check_union(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.union(y, z))\n+            check(a, b, expected, |x, y, f| x.union(y).advance(f))\n         }\n \n         check_union([], [], []);"}, {"sha": "88e168db5584f7baabcd24290976f35e9a92cfb5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -159,10 +159,10 @@ impl<'self> CheckLoanCtxt<'self> {\n             true\n         };\n \n-        for i in range(0u, new_loan_indices.len()) {\n-            let old_loan = &self.all_loans[new_loan_indices[i]];\n-            for j in range(i+1, new_loan_indices.len()) {\n-                let new_loan = &self.all_loans[new_loan_indices[j]];\n+        for (i, &x) in new_loan_indices.iter().enumerate() {\n+            let old_loan = &self.all_loans[x];\n+            for &y in new_loan_indices.slice_from(i+1).iter() {\n+                let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n         }"}, {"sha": "46b6d2214ae49dac47703d4c1de09fe3bb957171", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -983,10 +983,10 @@ fn bitwise(out_vec: &mut [uint],\n            op: &fn(uint, uint) -> uint) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for i in range(0u, out_vec.len()) {\n-        let old_val = out_vec[i];\n-        let new_val = op(old_val, in_vec[i]);\n-        out_vec[i] = new_val;\n+    for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {\n+        let old_val = *out_elt;\n+        let new_val = op(old_val, *in_elt);\n+        *out_elt = new_val;\n         changed |= (old_val != new_val);\n     }\n     changed"}, {"sha": "46394454d006f80e8f3d84cc2b58cc8c7b4cf1e2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -187,12 +187,12 @@ impl<N,E> Graph<N,E> {\n \n     pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n         //! Iterates over all edges defined in the graph.\n-        range(0u, self.nodes.len()).advance(|i| f(NodeIndex(i), &self.nodes[i]))\n+        self.nodes.iter().enumerate().advance(|(i, node)| f(NodeIndex(i), node))\n     }\n \n     pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n-        //! Iterates over all edges defined in the graph.\n-        range(0u, self.nodes.len()).advance(|i| f(EdgeIndex(i), &self.edges[i]))\n+        //! Iterates over all edges defined in the graph\n+        self.edges.iter().enumerate().advance(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n     pub fn each_outgoing_edge(&self,"}, {"sha": "f55fdd22c9a9f8bcd91889887db598a33fc367da", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -13,7 +13,7 @@ use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n-use metadata::csearch::get_type_name_if_impl;\n+use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n@@ -1700,9 +1700,12 @@ impl Resolver {\n           }\n           def_struct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building type %s\",\n+                    crate) building type and value for %s\",\n                    final_ident);\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n+            if get_struct_fields(self.session.cstore, def_id).len() == 0 {\n+                child_name_bindings.define_value(privacy, def, dummy_sp());\n+            }\n             self.structs.insert(def_id);\n           }\n           def_method(*) => {"}, {"sha": "db8a86fe948dff3d38bb9fafcbd811ef2e0d9219", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -1742,8 +1742,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         _ => {}\n     }\n \n-    for arg_n in range(0u, arg_tys.len()) {\n-        let arg_ty = arg_tys[arg_n];\n+    for (arg_n, &arg_ty) in arg_tys.iter().enumerate() {\n         let raw_llarg = raw_llargs[arg_n];\n \n         // For certain mode/type combinations, the raw llarg values are passed"}, {"sha": "dd24ec3ff1ac198222cecf77cb54afb0b97cfa1d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -145,8 +145,8 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        for i in range(0u, cls.len()) {\n-            cls[i] = Memory;\n+        for elt in cls.mut_iter() {\n+            *elt = Memory;\n         }\n     }\n "}, {"sha": "f25bf011f5d062f56c2130bb570bc725dc40e3d8", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -206,15 +206,8 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n \n pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    let len = {\n-        let uses = &*cx.uses;\n-        uses.len()\n-    };\n-    for i in range(0u, len) {\n-        if cx.uses[i] & use_ != use_ {\n-            type_needs_inner(cx, use_, ty, @Nil);\n-            return;\n-        }\n+    if cx.uses.iter().any(|&elt| elt & use_ != use_) {\n+        type_needs_inner(cx, use_, ty, @Nil);\n     }\n }\n "}, {"sha": "ae0a95688ed20dfef1b5c1607283f9518d0cd8b3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -772,8 +772,8 @@ impl<'self> LookupContext<'self> {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 \"multiple applicable methods in scope\");\n-            for idx in range(0u, relevant_candidates.len()) {\n-                self.report_candidate(idx, &relevant_candidates[idx].origin);\n+            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n+                self.report_candidate(idx, &candidate.origin);\n             }\n         }\n "}, {"sha": "c3df0d06f83dd5bd78499100c1b9093f962e8e45", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -554,8 +554,8 @@ impl CoherenceChecker {\n \n         let mut provided_names = HashSet::new();\n         // Implemented methods\n-        for i in range(0u, all_methods.len()) {\n-            provided_names.insert(all_methods[i].ident);\n+        for elt in all_methods.iter() {\n+            provided_names.insert(elt.ident);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);"}, {"sha": "91b6a4ce3bce3820b8c26eeece0d95338d548c76", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -374,8 +374,8 @@ impl RegionVarBindings {\n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n                                        -> ~[RegionVid] {\n         do vec::build |push| {\n-            for i in range(snapshot, self.undo_log.len()) {\n-                match self.undo_log[i] {\n+            for &elt in self.undo_log.slice_from(snapshot).iter() {\n+                match elt {\n                     AddVar(vid) => push(vid),\n                     _ => ()\n                 }"}, {"sha": "c9e2b8dd37b9dfb02d6a3fdc83bccc19ea0b9cfa", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -215,7 +215,7 @@ impl region_scope for MethodRscope {\n pub struct type_rscope(Option<RegionParameterization>);\n \n impl type_rscope {\n-    priv fn replacement(&self) -> ty::Region {\n+    fn replacement(&self) -> ty::Region {\n         if self.is_some() {\n             ty::re_bound(ty::br_self)\n         } else {"}, {"sha": "5bc22db0ca1a76700fc93d12394c72ed7d0699d0", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -136,7 +136,7 @@ Additional help:\n \n pub fn describe_warnings() {\n     use extra::sort::Sort;\n-    printfln!(\"\n+    println(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n     -A <foo>           Allow <foo>\n@@ -157,7 +157,7 @@ Available lint options:\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n-    printfln!(\"\\nAvailable lint checks:\\n\");\n+    println(\"\\nAvailable lint checks:\\n\");\n     printfln!(\"    %s  %7.7s  %s\",\n               padded(max_key, \"name\"), \"default\", \"meaning\");\n     printfln!(\"    %s  %7.7s  %s\\n\",\n@@ -173,7 +173,7 @@ Available lint options:\n }\n \n pub fn describe_debug_flags() {\n-    printfln!(\"\\nAvailable debug options:\\n\");\n+    println(\"\\nAvailable debug options:\\n\");\n     let r = session::debugging_opts_map();\n     for tuple in r.iter() {\n         match *tuple {"}, {"sha": "aba7ea1f0d753f807e7b30021f2f9724ce942533", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -54,7 +54,7 @@ pub struct CrateDoc {\n pub enum ItemTag {\n     ModTag(ModDoc),\n     NmodTag(NmodDoc),\n-    ConstTag(ConstDoc),\n+    StaticTag(StaticDoc),\n     FnTag(FnDoc),\n     EnumTag(EnumDoc),\n     TraitTag(TraitDoc),\n@@ -95,7 +95,7 @@ pub struct NmodDoc {\n     index: Option<Index>\n }\n \n-pub type ConstDoc = SimpleItemDoc;\n+pub type StaticDoc = SimpleItemDoc;\n \n pub type FnDoc = SimpleItemDoc;\n \n@@ -214,8 +214,8 @@ impl ModDoc {\n         md!(FnTag)\n     }\n \n-    pub fn consts(&self) -> ~[ConstDoc] {\n-        md!(ConstTag)\n+    pub fn statics(&self) -> ~[StaticDoc] {\n+        md!(StaticTag)\n     }\n \n     pub fn enums(&self) -> ~[EnumDoc] {\n@@ -249,7 +249,7 @@ pub trait PageUtils {\n     fn mods(&self) -> ~[ModDoc];\n     fn nmods(&self) -> ~[NmodDoc];\n     fn fns(&self) -> ~[FnDoc];\n-    fn consts(&self) -> ~[ConstDoc];\n+    fn statics(&self) -> ~[StaticDoc];\n     fn enums(&self) -> ~[EnumDoc];\n     fn traits(&self) -> ~[TraitDoc];\n     fn impls(&self) -> ~[ImplDoc];\n@@ -270,8 +270,8 @@ impl PageUtils for ~[Page] {\n         pu!(FnTag)\n     }\n \n-    fn consts(&self) -> ~[ConstDoc] {\n-        pu!(ConstTag)\n+    fn statics(&self) -> ~[StaticDoc] {\n+        pu!(StaticTag)\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n@@ -301,7 +301,7 @@ impl Item for ItemTag {\n           &doc::ModTag(ref doc) => doc.item.clone(),\n           &doc::NmodTag(ref doc) => doc.item.clone(),\n           &doc::FnTag(ref doc) => doc.item.clone(),\n-          &doc::ConstTag(ref doc) => doc.item.clone(),\n+          &doc::StaticTag(ref doc) => doc.item.clone(),\n           &doc::EnumTag(ref doc) => doc.item.clone(),\n           &doc::TraitTag(ref doc) => doc.item.clone(),\n           &doc::ImplTag(ref doc) => doc.item.clone(),"}, {"sha": "2cab62296a4ddbdec2d051013ee1dde305bca2fd", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -101,8 +101,8 @@ fn moddoc_from_mod(\n                 ))\n               }\n               ast::item_static(*) => {\n-                Some(doc::ConstTag(\n-                    constdoc_from_const(ItemDoc)\n+                Some(doc::StaticTag(\n+                    staticdoc_from_static(ItemDoc)\n                 ))\n               }\n               ast::item_enum(enum_definition, _) => {\n@@ -165,7 +165,7 @@ fn fndoc_from_fn(itemdoc: doc::ItemDoc) -> doc::FnDoc {\n     }\n }\n \n-fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n+fn staticdoc_from_static(itemdoc: doc::ItemDoc) -> doc::StaticDoc {\n     doc::SimpleItemDoc {\n         item: itemdoc,\n         sig: None\n@@ -356,10 +356,10 @@ mod test {\n     }\n \n     #[test]\n-    fn should_extract_const_name_and_id() {\n+    fn should_extract_static_name_and_id() {\n         let doc = mk_doc(@\"static a: int = 0;\");\n-        assert!(doc.cratemod().consts()[0].id() != 0);\n-        assert!(doc.cratemod().consts()[0].name_() == ~\"a\");\n+        assert!(doc.cratemod().statics()[0].id() != 0);\n+        assert!(doc.cratemod().statics()[0].name_() == ~\"a\");\n     }\n \n     #[test]"}, {"sha": "589232f6e2f2f3cc447c2df44d5c770f8e0b6bf3", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -21,7 +21,7 @@ pub struct Fold<T> {\n     fold_mod: FoldMod<T>,\n     fold_nmod: FoldNmod<T>,\n     fold_fn: FoldFn<T>,\n-    fold_const: FoldConst<T>,\n+    fold_static: FoldStatic<T>,\n     fold_enum: FoldEnum<T>,\n     fold_trait: FoldTrait<T>,\n     fold_impl: FoldImpl<T>,\n@@ -39,7 +39,7 @@ impl<T:Clone> Clone for Fold<T> {\n             fold_mod: self.fold_mod,\n             fold_nmod: self.fold_nmod,\n             fold_fn: self.fold_fn,\n-            fold_const: self.fold_const,\n+            fold_static: self.fold_static,\n             fold_enum: self.fold_enum,\n             fold_trait: self.fold_trait,\n             fold_impl: self.fold_impl,\n@@ -55,7 +55,7 @@ type FoldItem<T> = @fn(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n type FoldMod<T> = @fn(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n type FoldNmod<T> = @fn(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n type FoldFn<T> = @fn(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n-type FoldConst<T> = @fn(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n+type FoldStatic<T> = @fn(fold: &Fold<T>, doc: doc::StaticDoc) -> doc::StaticDoc;\n type FoldEnum<T> = @fn(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n type FoldTrait<T> = @fn(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n type FoldImpl<T> = @fn(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n@@ -73,7 +73,7 @@ fn mk_fold<T>(\n     fold_mod: FoldMod<T>,\n     fold_nmod: FoldNmod<T>,\n     fold_fn: FoldFn<T>,\n-    fold_const: FoldConst<T>,\n+    fold_static: FoldStatic<T>,\n     fold_enum: FoldEnum<T>,\n     fold_trait: FoldTrait<T>,\n     fold_impl: FoldImpl<T>,\n@@ -88,7 +88,7 @@ fn mk_fold<T>(\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n         fold_fn: fold_fn,\n-        fold_const: fold_const,\n+        fold_static: fold_static,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -106,7 +106,7 @@ pub fn default_any_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_any_fold_mod(f, d),\n         |f, d| default_any_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -124,7 +124,7 @@ pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_seq_fold_mod(f, d),\n         |f, d| default_seq_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -142,7 +142,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_par_fold_mod(f, d),\n         |f, d| default_par_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -272,8 +272,8 @@ pub fn fold_ItemTag<T>(fold: &Fold<T>, doc: doc::ItemTag) -> doc::ItemTag {\n       doc::FnTag(FnDoc) => {\n         doc::FnTag((fold.fold_fn)(fold, FnDoc))\n       }\n-      doc::ConstTag(ConstDoc) => {\n-        doc::ConstTag((fold.fold_const)(fold, ConstDoc))\n+      doc::StaticTag(StaticDoc) => {\n+        doc::StaticTag((fold.fold_static)(fold, StaticDoc))\n       }\n       doc::EnumTag(EnumDoc) => {\n         doc::EnumTag((fold.fold_enum)(fold, EnumDoc))\n@@ -303,10 +303,10 @@ pub fn default_seq_fold_fn<T>(\n     }\n }\n \n-pub fn default_seq_fold_const<T>(\n+pub fn default_seq_fold_static<T>(\n     fold: &Fold<T>,\n-    doc: doc::ConstDoc\n-) -> doc::ConstDoc {\n+    doc: doc::StaticDoc\n+) -> doc::StaticDoc {\n     doc::SimpleItemDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n@@ -374,7 +374,7 @@ fn default_fold_should_produce_same_doc() {\n }\n \n #[test]\n-fn default_fold_should_produce_same_consts() {\n+fn default_fold_should_produce_same_statics() {\n     let source = @\"static a: int = 0;\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");"}, {"sha": "7d07b4864f50e1b57e6a50e11ef4a51bd0bd238d", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -150,8 +150,8 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n         doc::FnTag(_) => {\n             ~\"Function\"\n         }\n-        doc::ConstTag(_) => {\n-            ~\"Freeze\"\n+        doc::StaticTag(_) => {\n+            ~\"Static\"\n         }\n         doc::EnumTag(_) => {\n             ~\"Enum\"\n@@ -321,7 +321,7 @@ fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n         doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n         doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n         doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n-        doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n+        doc::StaticTag(StaticDoc) => write_static(ctxt, StaticDoc),\n         doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n         doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n         doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n@@ -409,9 +409,9 @@ fn code_block(s: ~str) -> ~str {\n ~~~\", s)\n }\n \n-fn write_const(\n+fn write_static(\n     ctxt: &Ctxt,\n-    doc: doc::ConstDoc\n+    doc: doc::StaticDoc\n ) {\n     write_sig(ctxt, doc.sig.clone());\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -775,13 +775,13 @@ mod test {\n     }\n \n     #[test]\n-    fn should_write_const_header() {\n+    fn should_write_static_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(markdown.contains(\"## Freeze `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Static `a`\\n\\n\"));\n     }\n \n     #[test]\n-    fn should_write_const_description() {\n+    fn should_write_static_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");"}, {"sha": "3e380732d0f07e87aaff5be5ff76c00d5813524d", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -202,7 +202,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n@@ -212,7 +212,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n@@ -232,7 +232,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }"}, {"sha": "ba8f37601fd567cb64660ccaf81a635f0c6d995d", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -18,7 +18,7 @@ pub fn mk_pass() -> Pass {\n     fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         fn score(item: &doc::ItemTag) -> int {\n             match *item {\n-              doc::ConstTag(_) => 0,\n+              doc::StaticTag(_) => 0,\n               doc::TyTag(_) => 1,\n               doc::EnumTag(_) => 2,\n               doc::StructTag(_) => 3,\n@@ -43,7 +43,7 @@ fn test() {\n \n     let source =\n         ~\"mod imod { } \\\n-         static iconst: int = 0; \\\n+         static istatic: int = 0; \\\n          fn ifn() { } \\\n          enum ienum { ivar } \\\n          trait itrait { fn a(); } \\\n@@ -54,7 +54,7 @@ fn test() {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[0].name_(), ~\"iconst\");\n+        assert_eq!(doc.cratemod().items[0].name_(), ~\"istatic\");\n         assert_eq!(doc.cratemod().items[1].name_(), ~\"itype\");\n         assert_eq!(doc.cratemod().items[2].name_(), ~\"ienum\");\n         assert_eq!(doc.cratemod().items[3].name_(), ~\"istruct\");"}, {"sha": "196c7e892a8801e90b04cceb87eac3d3af7d636e", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -39,7 +39,7 @@ pub fn run(\n     let fold = Fold {\n         ctxt: srv.clone(),\n         fold_fn: fold_fn,\n-        fold_const: fold_const,\n+        fold_static: fold_static,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -93,10 +93,10 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     }\n }\n \n-fn fold_const(\n+fn fold_static(\n     fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ConstDoc\n-) -> doc::ConstDoc {\n+    doc: doc::StaticDoc\n+) -> doc::StaticDoc {\n     let srv = fold.ctxt.clone();\n \n     doc::SimpleItemDoc {\n@@ -109,7 +109,7 @@ fn fold_const(\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }\n-                    _ => fail!(\"fold_const: id not bound to a const item\")\n+                    _ => fail!(\"fold_static: id not bound to a static item\")\n                 }\n             }}),\n         .. doc\n@@ -384,9 +384,9 @@ mod test {\n     }\n \n     #[test]\n-    fn should_add_const_types() {\n+    fn should_add_static_types() {\n         let doc = mk_doc(~\"static a: bool = true;\");\n-        assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n+        assert!(doc.cratemod().statics()[0].sig == Some(~\"bool\"));\n     }\n \n     #[test]"}, {"sha": "f2470bed7329e81fcd1df99620574989f49607cd", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -12,7 +12,7 @@\n \n use clone::Clone;\n use container::Container;\n-use iterator::{Iterator, range};\n+use iterator::Iterator;\n use option::{Option, Some, None};\n use sys;\n use unstable::raw::Repr;\n@@ -92,8 +92,8 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n         for x in lhs.iter() {\n             push((*x).clone());\n         }\n-        for i in range(0u, rhs.len()) {\n-            push(rhs[i].clone());\n+        for elt in rhs.iter() {\n+            push(elt.clone());\n         }\n     }\n }"}, {"sha": "a4de10f8c7760aae76a718f95a74aab086ad7cb7", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -314,7 +314,7 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod oneshot {\n-        priv use std::kinds::Send;\n+        use std::kinds::Send;\n         use ptr::to_mut_unsafe_ptr;\n \n         pub fn init<T: Send>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n@@ -341,7 +341,7 @@ mod pipesy {\n         #[allow(non_camel_case_types)]\n         pub mod client {\n \n-            priv use std::kinds::Send;\n+            use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_send<T: Send>(pipe: Oneshot<T>, x_0: T) ->\n@@ -489,7 +489,7 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod streamp {\n-        priv use std::kinds::Send;\n+        use std::kinds::Send;\n \n         pub fn init<T: Send>() -> (server::Open<T>, client::Open<T>) {\n             pub use std::pipes::HasBuffer;\n@@ -501,7 +501,7 @@ mod pipesy {\n \n         #[allow(non_camel_case_types)]\n         pub mod client {\n-            priv use std::kinds::Send;\n+            use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_data<T: Send>(pipe: Open<T>, x_0: T) ->"}, {"sha": "84cba254dcf23599258f50f64fdbfdc1637cff30", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -19,7 +19,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, range};\n+use iterator::{Iterator, IteratorUtil, FromIterator, Extendable};\n use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n@@ -265,8 +265,8 @@ impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        for idx in range(0u, self.buckets.len()) {\n-            self.buckets[idx] = None;\n+        for bkt in self.buckets.mut_iter() {\n+            *bkt = None;\n         }\n         self.size = 0;\n     }"}, {"sha": "d10a5541e41a683fef643f9c02aa2957abf2a15c", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -18,9 +18,9 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use num::{Zero, One, Saturating};\n+use num::{Zero, One, Integer, Saturating};\n use option::{Option, Some, None};\n-use ops::{Add, Mul};\n+use ops::{Add, Mul, Sub};\n use cmp::Ord;\n use clone::Clone;\n use uint;\n@@ -1531,7 +1531,7 @@ pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> {\n     Range{state: start, stop: stop, one: One::one()}\n }\n \n-impl<A: Add<A, A> + Ord + Clone + One> Iterator<A> for Range<A> {\n+impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1544,6 +1544,22 @@ impl<A: Add<A, A> + Ord + Clone + One> Iterator<A> for Range<A> {\n     }\n }\n \n+impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.stop > self.state {\n+            // Integer doesn't technically define this rule, but we're going to assume that every\n+            // Integer is reachable from every other one by adding or subtracting enough Ones. This\n+            // seems like a reasonable-enough rule that every Integer should conform to, even if it\n+            // can't be statically checked.\n+            self.stop = self.stop - self.one;\n+            Some(self.stop.clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2121,4 +2137,17 @@ mod tests {\n         check_randacc_iter(xs.iter().cycle().take_(27), 27);\n         check_randacc_iter(empty.iter().cycle(), 0);\n     }\n+\n+    #[test]\n+    fn test_double_ended_range() {\n+        assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n+        for _ in range(10i, 0).invert() {\n+            fail!(\"unreachable\");\n+        }\n+\n+        assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n+        for _ in range(10u, 0).invert() {\n+            fail!(\"unreachable\");\n+        }\n+    }\n }"}, {"sha": "60527905779f035296e8a126b7dfbe9b037677a0", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -278,18 +278,22 @@ impl One for f64 {\n \n #[cfg(not(test))]\n impl Add<f64,f64> for f64 {\n+    #[inline]\n     fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(not(test))]\n impl Sub<f64,f64> for f64 {\n+    #[inline]\n     fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(not(test))]\n impl Mul<f64,f64> for f64 {\n+    #[inline]\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(not(test))]\n impl Div<f64,f64> for f64 {\n+    #[inline]\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(not(test))]"}, {"sha": "b692bedebfd54f0ed17b39f5fcc99701abec5d32", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -124,14 +124,6 @@ pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool)\n     range_step_core(start, last, step, Closed, it)\n }\n \n-\n-#[inline]\n-/// Iterate over the range (`hi`..`lo`]\n-pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    if hi == min_value { return true; }\n-    range_step_inclusive(hi-1, lo, -1 as $T, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -889,10 +881,6 @@ mod tests {\n     fn test_ranges() {\n         let mut l = ~[];\n \n-        do range_rev(14,11) |i| {\n-            l.push(i);\n-            true\n-        };\n         do range_step(20,26,2) |i| {\n             l.push(i);\n             true\n@@ -917,18 +905,14 @@ mod tests {\n             l.push(i);\n             true\n         };\n-        assert_eq!(l, ~[13,12,11,\n-                        20,22,24,\n+        assert_eq!(l, ~[20,22,24,\n                         36,34,32,\n                         max_value-2,\n                         max_value-3,max_value-1,\n                         min_value+2,\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        do range_rev(0,10) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n         do range_step(10,0,1) |_i| {\n             fail!(~\"unreachable\");\n         };"}, {"sha": "1f22343ad9c36063b8dc392120a4b3c451c15e45", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -422,9 +422,9 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n \n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n-priv static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-priv static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n-priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n+static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n /**\n  * Parses a byte slice as a number. This is meant to"}, {"sha": "29b8f29d87d3f866a37bff576ea9e408be768687", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -125,13 +125,6 @@ pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) ->\n     range_step_core(start, last, step, Closed, it)\n }\n \n-#[inline]\n-/// Iterate over the range (`hi`..`lo`]\n-pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    if hi == min_value { return true; }\n-    range_step_inclusive(hi-1, lo, -1 as $T_SIGNED, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -654,10 +647,6 @@ mod tests {\n     pub fn test_ranges() {\n         let mut l = ~[];\n \n-        do range_rev(14,11) |i| {\n-            l.push(i);\n-            true\n-        };\n         do range_step(20,26,2) |i| {\n             l.push(i);\n             true\n@@ -683,18 +672,14 @@ mod tests {\n             true\n         };\n \n-        assert_eq!(l, ~[13,12,11,\n-                        20,22,24,\n+        assert_eq!(l, ~[20,22,24,\n                         36,34,32,\n                         max_value-2,\n                         max_value-3,max_value-1,\n                         min_value+2,\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        do range_rev(0,0) |_i| {\n-            fail!(\"unreachable\");\n-        };\n         do range_step(10,0,1) |_i| {\n             fail!(\"unreachable\");\n         };"}, {"sha": "5f8fa9fddbcf7c2808f06ea9247590d49d4fa297", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -610,15 +610,32 @@ impl<R: Rng> RngUtil for R {\n }\n \n /// Create a random number generator with a default algorithm and seed.\n+///\n+/// It returns the cryptographically-safest `Rng` algorithm currently\n+/// available in Rust. If you require a specifically seeded `Rng` for\n+/// consistency over time you should pick one algorithm and create the\n+/// `Rng` yourself.\n pub fn rng() -> IsaacRng {\n     IsaacRng::new()\n }\n \n+/// Create a weak random number generator with a default algorithm and seed.\n+///\n+/// It returns the fatest `Rng` algorithm currently available in Rust without\n+/// consideration for cryptography or security. If you require a specifically\n+/// seeded `Rng` for consistency over time you should pick one algorithm and\n+/// create the `Rng` yourself.\n+pub fn weak_rng() -> XorShiftRng {\n+    XorShiftRng::new()\n+}\n+\n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n /// A random number generator that uses the [ISAAC\n /// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n pub struct IsaacRng {\n     priv cnt: u32,\n     priv rsl: [u32, .. RAND_SIZE],\n@@ -794,8 +811,11 @@ impl Rng for IsaacRng {\n }\n \n /// An [Xorshift random number\n-/// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n-/// cryptographic purposes.\n+/// generator](http://en.wikipedia.org/wiki/Xorshift).\n+///\n+/// The Xorshift algorithm is not suitable for cryptographic purposes\n+/// but is very fast. If you do not know for sure that it fits your\n+/// requirements, use a more secure one such as `IsaacRng`.\n pub struct XorShiftRng {\n     priv x: u32,\n     priv y: u32,"}, {"sha": "6dc44dd1193b9e57532df2ca6a55029ec4e307c4", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -508,7 +508,11 @@ impl<T> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T> Select for Port<T> {\n+// XXX: Kind of gross. A Port<T> should be selectable so you can make an array\n+// of them, but a &Port<T> should also be selectable so you can select2 on it\n+// alongside a PortOne<U> without passing the port by value in recv_ready.\n+\n+impl<'self, T> Select for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         do self.next.with_mut_ref |pone| { pone.optimistic_check() }\n@@ -526,12 +530,29 @@ impl<T> Select for Port<T> {\n     }\n }\n \n-impl<T> SelectPort<(T, Port<T>)> for Port<T> {\n-    fn recv_ready(self) -> Option<(T, Port<T>)> {\n+impl<T> Select for Port<T> {\n+    #[inline]\n+    fn optimistic_check(&mut self) -> bool {\n+        (&*self).optimistic_check()\n+    }\n+\n+    #[inline]\n+    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n+        (&*self).block_on(sched, task)\n+    }\n+\n+    #[inline]\n+    fn unblock_from(&mut self) -> bool {\n+        (&*self).unblock_from()\n+    }\n+}\n+\n+impl<'self, T> SelectPort<T> for &'self Port<T> {\n+    fn recv_ready(self) -> Option<T> {\n         match self.next.take().recv_ready() {\n             Some(StreamPayload { val, next }) => {\n                 self.next.put_back(next);\n-                Some((val, self))\n+                Some(val)\n             }\n             None => None\n         }"}, {"sha": "e07cb1425bf75819efa2dfc1a58568e5518fe0f3", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -590,7 +590,8 @@ impl Death {\n     #[inline]\n     pub fn assert_may_sleep(&self) {\n         if self.wont_sleep != 0 {\n-            rtabort!(\"illegal atomic-sleep: can't deschedule inside atomically()\");\n+            rtabort!(\"illegal atomic-sleep: attempt to reschedule while \\\n+                      using an Exclusive or LittleLock\");\n         }\n     }\n }"}, {"sha": "84ce36c3e6b5a36007f99ed280cf2b39a3b232a1", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -199,9 +199,7 @@ mod test {\n                 // get it back out\n                 util::swap(port.get_mut_ref(), &mut ports[index]);\n                 // NB. Not recv(), because optimistic_check randomly fails.\n-                let (data, new_port) = port.take_unwrap().recv_ready().unwrap();\n-                assert!(data == 31337);\n-                port = Some(new_port);\n+                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n             }\n         }\n     }"}, {"sha": "99cf96eaae2fff4be0fcdd9d72a4714c5ff2f06b", "filename": "src/libstd/run.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -632,7 +632,6 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n-    use int;\n \n     mod rustrt {\n         use libc::c_void;\n@@ -665,10 +664,9 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n         }\n         // close all other fds\n-        do int::range_rev(getdtablesize() as int, 3) |fd| {\n+        for fd in range(3, getdtablesize()).invert() {\n             close(fd as c_int);\n-            true\n-        };\n+        }\n \n         do with_dirp(dir) |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n@@ -763,14 +761,14 @@ fn with_dirp<T>(d: Option<&Path>,\n }\n \n #[cfg(windows)]\n-priv fn free_handle(handle: *()) {\n+fn free_handle(handle: *()) {\n     unsafe {\n         libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n }\n \n #[cfg(unix)]\n-priv fn free_handle(_handle: *()) {\n+fn free_handle(_handle: *()) {\n     // unix has no process handle object, just a pid\n }\n \n@@ -825,7 +823,7 @@ pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n  * operate on a none-existant process or, even worse, on a newer process\n  * with the same id.\n  */\n-priv fn waitpid(pid: pid_t) -> int {\n+fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]"}, {"sha": "fa75916fb8640e10785c53b3e70c6c69aab93a89", "filename": "src/libstd/str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -738,7 +738,7 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n }\n \n // https://tools.ietf.org/html/rfc3629\n-priv static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n@@ -781,15 +781,15 @@ macro_rules! utf8_acc_cont_byte(\n )\n \n // UTF-8 tags and ranges\n-priv static TAG_CONT_U8: u8 = 128u8;\n-priv static TAG_CONT: uint = 128u;\n-priv static MAX_ONE_B: uint = 128u;\n-priv static TAG_TWO_B: uint = 192u;\n-priv static MAX_TWO_B: uint = 2048u;\n-priv static TAG_THREE_B: uint = 224u;\n-priv static MAX_THREE_B: uint = 65536u;\n-priv static TAG_FOUR_B: uint = 240u;\n-priv static MAX_UNICODE: uint = 1114112u;\n+static TAG_CONT_U8: u8 = 128u8;\n+static TAG_CONT: uint = 128u;\n+static MAX_ONE_B: uint = 128u;\n+static TAG_TWO_B: uint = 192u;\n+static MAX_TWO_B: uint = 2048u;\n+static TAG_THREE_B: uint = 224u;\n+static MAX_THREE_B: uint = 65536u;\n+static TAG_FOUR_B: uint = 240u;\n+static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {"}, {"sha": "6ededb02107d497bb77a2d0b91e1b11d70b84978", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -274,7 +274,7 @@ pub fn to_ascii_lower(string: &str) -> ~str {\n }\n \n #[inline]\n-priv fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n+fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n     let len = string.len();\n     let mut result = str::with_capacity(len);\n     unsafe {\n@@ -298,7 +298,7 @@ pub fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {\n         |(byte_a, byte_b)| ASCII_LOWER_MAP[*byte_a] == ASCII_LOWER_MAP[*byte_b])\n }\n \n-priv static ASCII_LOWER_MAP: &'static [u8] = &[\n+static ASCII_LOWER_MAP: &'static [u8] = &[\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -333,7 +333,7 @@ priv static ASCII_LOWER_MAP: &'static [u8] = &[\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n-priv static ASCII_UPPER_MAP: &'static [u8] = &[\n+static ASCII_UPPER_MAP: &'static [u8] = &[\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,"}, {"sha": "5ef5526e5162d4833c3aeff09056c9d94fdc80d4", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -271,8 +271,8 @@ impl<T> TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        for idx in range(0u, self.children.len()) {\n-            match self.children[idx] {\n+        for elt in self.children.iter() {\n+            match *elt {\n                 Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n@@ -282,13 +282,14 @@ impl<T> TrieNode<T> {\n     }\n \n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        do uint::range_rev(self.children.len(), 0) |idx| {\n-            match self.children[idx] {\n-                Internal(ref x) => x.each_reverse(|i,t| f(i,t)),\n-                External(k, ref v) => f(&k, v),\n-                Nothing => true\n+        for elt in self.children.rev_iter() {\n+            match *elt {\n+                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n             }\n         }\n+        true\n     }\n \n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n@@ -539,10 +540,9 @@ mod test_map {\n     fn test_each_break() {\n         let mut m = TrieMap::new();\n \n-        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n             m.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut n = uint::max_value - 10000;\n         do m.each |k, v| {\n@@ -580,10 +580,9 @@ mod test_map {\n     fn test_each_reverse_break() {\n         let mut m = TrieMap::new();\n \n-        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n             m.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut n = uint::max_value - 1;\n         do m.each_reverse |k, v| {\n@@ -634,10 +633,9 @@ mod test_map {\n         let last = uint::max_value;\n \n         let mut map = TrieMap::new();\n-        do uint::range_rev(last, first) |x| {\n+        for x in range(first, last).invert() {\n             map.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut i = 0;\n         for (k, &v) in map.iter() {"}, {"sha": "0f6d94bb77107786bfff531ad73645ea73d8f380", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -1602,8 +1602,8 @@ impl<T:Clone> OwnedCopyableVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n \n-        for i in range(0u, rhs.len()) {\n-            self.push(unsafe { raw::get(rhs, i) })\n+        for elt in rhs.iter() {\n+            self.push((*elt).clone())\n         }\n     }\n "}, {"sha": "dda5e990221eccf066d42a502637108f17bad179", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -64,6 +64,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteMutWithMultipleBindings,\n     ObsoleteExternVisibility,\n     ObsoleteUnsafeExternFn,\n+    ObsoletePrivVisibility,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -253,6 +254,10 @@ impl ParserObsoleteMethods for Parser {\n                 \"external functions are always unsafe; remove the `unsafe` \\\n                  keyword\"\n             ),\n+            ObsoletePrivVisibility => (\n+                \"`priv` not necessary\",\n+                \"an item without a visibility qualifier is private by default\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "7d6dce22fb7b423553d034f8f718c373860d68c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -85,7 +85,7 @@ use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n use parse::obsolete::{ObsoleteMutWithMultipleBindings};\n use parse::obsolete::{ObsoleteExternVisibility, ObsoleteUnsafeExternFn};\n-use parse::obsolete::{ParserObsoleteMethods};\n+use parse::obsolete::{ParserObsoleteMethods, ObsoletePrivVisibility};\n use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n use parse::token::{is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n@@ -814,7 +814,7 @@ impl Parser {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n-            let vis = p.parse_visibility();\n+            let vis = p.parse_non_priv_visibility();\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n@@ -3608,7 +3608,7 @@ impl Parser {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n \n-        let visa = self.parse_visibility();\n+        let visa = self.parse_non_priv_visibility();\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n@@ -3871,6 +3871,18 @@ impl Parser {\n         else { inherited }\n     }\n \n+    // parse visibility, but emits an obsolete error if it's private\n+    fn parse_non_priv_visibility(&self) -> visibility {\n+        match self.parse_visibility() {\n+            public => public,\n+            inherited => inherited,\n+            private => {\n+                self.obsolete(*self.last_span, ObsoletePrivVisibility);\n+                inherited\n+            }\n+        }\n+    }\n+\n     fn parse_staticness(&self) -> bool {\n         if self.eat_keyword(keywords::Static) {\n             self.obsolete(*self.last_span, ObsoleteStaticMethod);\n@@ -4063,7 +4075,7 @@ impl Parser {\n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&self,  attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n-        let vis = self.parse_visibility();\n+        let vis = self.parse_non_priv_visibility();\n \n         // Parse obsolete purity.\n         let purity = self.parse_fn_purity();\n@@ -4443,7 +4455,7 @@ impl Parser {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility();\n+        let visibility = self.parse_non_priv_visibility();\n \n         // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n@@ -4575,7 +4587,7 @@ impl Parser {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility();\n+        let visibility = self.parse_non_priv_visibility();\n \n         if (self.is_keyword(keywords::Const) || self.is_keyword(keywords::Static)) {\n             // FOREIGN CONST ITEM"}, {"sha": "5b8bebda9248eba37bfa25ec2f750990aaf2c4e5", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -17,7 +17,7 @@ pub mod kitties {\n     }\n \n     impl cat {\n-        priv fn nap(&self) {}\n+        fn nap(&self) {}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "a72bf307e5dd6fb22871b907795aa21f0126d82e", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_type = \"lib\"];\n+\n+// used by the rpass test\n+\n+pub struct Struct;\n+\n+pub enum Unit {\n+    Unit,\n+    Argument(Struct)\n+}\n+\n+// used by the cfail test\n+\n+pub struct StructWithFields {\n+    foo: int,\n+}\n+\n+pub enum EnumWithVariants {\n+    EnumVariant,\n+    EnumVariantArg(int)\n+}"}, {"sha": "6475012e0097e9e7180f7eb55fce18ed49fe012e", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -53,24 +53,21 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     io::println(\" Descending integers:\");\n \n     do timed(\"insert\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys).invert() {\n             map.insert(i, i + 1);\n-            true\n-        };\n+        }\n     }\n \n     do timed(\"search\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys).invert() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n-            true\n-        };\n+        }\n     }\n \n     do timed(\"remove\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys) {\n             assert!(map.remove(&i));\n-            true\n-        };\n+        }\n     }\n }\n "}, {"sha": "7097615b87e74ff963b59ac0b1837b31ce21ca7d", "filename": "src/test/compile-fail/issue-3763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -16,7 +16,7 @@ mod my_mod {\n         MyStruct {priv_field: 4}\n     }\n     impl MyStruct {\n-        priv fn happyfun(&self) {}\n+        fn happyfun(&self) {}\n     }\n }\n "}, {"sha": "cab999f621de8f37b7637f61261f3784c4b2238f", "filename": "src/test/compile-fail/issue-3993-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -12,8 +12,8 @@ use zoo::fly; //~ ERROR failed to resolve import\n               //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n \n mod zoo {\n-    priv type fly = ();\n-    priv fn fly() {}\n+    type fly = ();\n+    fn fly() {}\n }\n \n "}, {"sha": "53a56ad2774235357000e824e86daf9f2e656979", "filename": "src/test/compile-fail/issue-3993.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -12,7 +12,7 @@ use zoo::fly; //~ ERROR failed to resolve import\n               //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n \n mod zoo {\n-    priv fn fly() {}\n+    fn fly() {}\n }\n \n "}, {"sha": "42da53e989036447b687fb645d0d0024aa14e296", "filename": "src/test/compile-fail/private-impl-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -14,7 +14,7 @@ mod a {\n     }\n \n     impl Foo {\n-        priv fn foo(&self) {}\n+        fn foo(&self) {}\n     }\n }\n "}, {"sha": "a31d0030f67e7be7066e6c640554070ad2a85a88", "filename": "src/test/compile-fail/private-item-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n mod a {\n-    priv fn f() {}\n+    fn f() {}\n }\n \n fn main() {"}, {"sha": "858227655955c614005dd4e23a08c5a84c571348", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -18,7 +18,7 @@ mod kitties {\n     }\n \n     impl cat {\n-        priv fn nap(&self) {}\n+        fn nap(&self) {}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "e71a0f05dffc5c24336de3ae80e5b2b5b536cd0a", "filename": "src/test/compile-fail/xcrate-unit-struct.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate_unit_struct.rs\n+\n+// Make sure that when we have cross-crate unit structs we don't accidentally\n+// make values out of cross-crate structs that aren't unit.\n+\n+extern mod xcrate_unit_struct;\n+\n+fn main() {\n+    let _ = xcrate_unit_struct::StructWithFields; //~ ERROR: unresolved name\n+    let _ = xcrate_unit_struct::Struct;\n+}"}, {"sha": "2841756d4a0e10e1d852b1e651e62f7903f954ac", "filename": "src/test/run-fail/assert-eq-macro-fail", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e"}, {"sha": "a134ffe49fd02f4f1ee2e75808ae0a8c2fbff2c5", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -21,7 +21,7 @@ struct dog {\n }\n \n impl dog {\n-    priv fn bark(&self) -> int {\n+    fn bark(&self) -> int {\n       info!(\"Woof %u %d\", *self.barks, *self.volume);\n       *self.barks += 1u;\n       if *self.barks % 3u == 0u {"}, {"sha": "ea7d4a651f75d181b88bc80fa85fa9f771e9768d", "filename": "src/test/run-pass/num-range-rev.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -20,11 +20,11 @@ fn int_range(lo: int,  hi: int, it: &fn(int) -> bool) -> bool {\n }\n \n fn uint_range_rev(hi: uint, lo: uint, it: &fn(uint) -> bool) -> bool {\n-    uint::range_rev(hi, lo, it)\n+    range(lo, hi).invert().advance(it)\n }\n \n fn int_range_rev(hi: int,  lo: int, it: &fn(int) -> bool) -> bool {\n-    int::range_rev(hi, lo, it)\n+    range(lo, hi).invert().advance(it)\n }\n \n fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {"}, {"sha": "d6522231f65fadbb33bc356b34cf51bffbeb840e", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65dbfcfa11aa521aa59881f6ab064bbd07184e/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate_unit_struct.rs\n+// xfail-fast\n+extern mod xcrate_unit_struct;\n+\n+use std::util;\n+\n+static s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n+static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::Unit;\n+static s3: xcrate_unit_struct::Unit =\n+                xcrate_unit_struct::Argument(xcrate_unit_struct::Struct);\n+static s4: xcrate_unit_struct::Unit = xcrate_unit_struct::Argument(s1);\n+\n+fn f1(_: xcrate_unit_struct::Struct) {}\n+fn f2(_: xcrate_unit_struct::Unit) {}\n+\n+fn main() {\n+    f1(xcrate_unit_struct::Struct);\n+    f2(xcrate_unit_struct::Unit);\n+    f2(xcrate_unit_struct::Argument(xcrate_unit_struct::Struct));\n+\n+    f1(s1);\n+    f2(s2);\n+    f2(s3);\n+    f2(s4);\n+}"}]}