{"sha": "66cf072ac8fa10648d5eccbacb75c7423204af1e", "node_id": "C_kwDOAAsO6NoAKDY2Y2YwNzJhYzhmYTEwNjQ4ZDVlY2NiYWNiNzVjNzQyMzIwNGFmMWU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-30T07:39:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-30T07:48:54Z"}, "message": "Merge `default.rs` into `mod.rs`.\n\nWithin `compiler/rustc_monomorphize/src/partitioning/`, because the\nprevious commit removed the need for `default.rs` to be a separate file.", "tree": {"sha": "270ebfb36af94d71851339a5c856c331cc4a0a0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270ebfb36af94d71851339a5c856c331cc4a0a0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66cf072ac8fa10648d5eccbacb75c7423204af1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66cf072ac8fa10648d5eccbacb75c7423204af1e", "html_url": "https://github.com/rust-lang/rust/commit/66cf072ac8fa10648d5eccbacb75c7423204af1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66cf072ac8fa10648d5eccbacb75c7423204af1e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "html_url": "https://github.com/rust-lang/rust/commit/97d4a38de9fd6efb4588a7262cd9c66c2093e29f"}], "stats": {"total": 1281, "additions": 632, "deletions": 649}, "files": [{"sha": "71cbee3b166953a4385b96cb48c144d344404fe3", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "removed", "additions": 0, "deletions": 637, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4a38de9fd6efb4588a7262cd9c66c2093e29f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=97d4a38de9fd6efb4588a7262cd9c66c2093e29f", "patch": "@@ -1,637 +0,0 @@\n-use std::cmp;\n-use std::collections::hash_map::Entry;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathDataName;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n-use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n-use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::collector::InliningMap;\n-use crate::partitioning::{MonoItemPlacement, PlacedRootMonoItems};\n-\n-// This modules implements the default (and only) partitioning strategy.\n-\n-pub(super) fn place_root_mono_items<'tcx, I>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    mono_items: &mut I,\n-) -> PlacedRootMonoItems<'tcx>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let mut roots = FxHashSet::default();\n-    let mut codegen_units = FxHashMap::default();\n-    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n-    let mut internalization_candidates = FxHashSet::default();\n-\n-    // Determine if monomorphizations instantiated in this crate will be made\n-    // available to downstream crates. This depends on whether we are in\n-    // share-generics mode and whether the current crate can even have\n-    // downstream crates.\n-    let export_generics =\n-        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-    let cgu_name_cache = &mut FxHashMap::default();\n-\n-    for mono_item in mono_items {\n-        match mono_item.instantiation_mode(cx.tcx) {\n-            InstantiationMode::GloballyShared { .. } => {}\n-            InstantiationMode::LocalCopy => continue,\n-        }\n-\n-        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n-        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-        let codegen_unit_name = match characteristic_def_id {\n-            Some(def_id) => compute_codegen_unit_name(\n-                cx.tcx,\n-                cgu_name_builder,\n-                def_id,\n-                is_volatile,\n-                cgu_name_cache,\n-            ),\n-            None => fallback_cgu_name(cgu_name_builder),\n-        };\n-\n-        let codegen_unit = codegen_units\n-            .entry(codegen_unit_name)\n-            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-        let mut can_be_internalized = true;\n-        let (linkage, visibility) = mono_item_linkage_and_visibility(\n-            cx.tcx,\n-            &mono_item,\n-            &mut can_be_internalized,\n-            export_generics,\n-        );\n-        if visibility == Visibility::Hidden && can_be_internalized {\n-            internalization_candidates.insert(mono_item);\n-        }\n-\n-        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-        roots.insert(mono_item);\n-    }\n-\n-    // Always ensure we have at least one CGU; otherwise, if we have a\n-    // crate with just types (for example), we could wind up with no CGU.\n-    if codegen_units.is_empty() {\n-        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-    }\n-\n-    let codegen_units = codegen_units.into_values().collect();\n-    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n-}\n-\n-pub(super) fn merge_codegen_units<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-) {\n-    assert!(cx.target_cgu_count >= 1);\n-\n-    // Note that at this point in time the `codegen_units` here may not be\n-    // in a deterministic order (but we know they're deterministically the\n-    // same set). We want this merging to produce a deterministic ordering\n-    // of codegen units from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the\n-    // two smallest into each other) we're sure to start off with a\n-    // deterministic order (sorted by name). This'll mean that if two cgus\n-    // have the same size the stable sort below will keep everything nice\n-    // and deterministic.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is\n-    // reached.\n-    while codegen_units.len() > cx.target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n-\n-        // Record that `second_smallest` now contains all the stuff that was\n-        // in `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-    if cx.tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of all\n-        // contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict. We are sorting primitive `&str`s here so we can\n-                // use unstable sort.\n-                cgu_contents.sort_unstable();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n-\n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable,\n-                    // we use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n-            }\n-        }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            let numbered_codegen_unit_name =\n-                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-            cgu.set_name(numbered_codegen_unit_name);\n-        }\n-    }\n-}\n-\n-pub(super) fn place_inlined_mono_items<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    codegen_units: &mut [CodegenUnit<'tcx>],\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-    let mut mono_item_placements = FxHashMap::default();\n-\n-    let single_codegen_unit = codegen_units.len() == 1;\n-\n-    for old_codegen_unit in codegen_units.iter_mut() {\n-        // Collect all items that need to be available in this codegen unit.\n-        let mut reachable = FxHashSet::default();\n-        for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, cx.inlining_map, &mut reachable);\n-        }\n-\n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-        // Add all monomorphizations that are not already there.\n-        for mono_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over.\n-                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-            } else {\n-                if roots.contains(&mono_item) {\n-                    bug!(\n-                        \"GloballyShared mono-item inlined into other CGU: \\\n-                          {:?}\",\n-                        mono_item\n-                    );\n-                }\n-\n-                // This is a CGU-private copy.\n-                new_codegen_unit\n-                    .items_mut()\n-                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n-            }\n-\n-            if !single_codegen_unit {\n-                // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each monomorphization is placed.\n-                match mono_item_placements.entry(mono_item) {\n-                    Entry::Occupied(e) => {\n-                        let placement = e.into_mut();\n-                        debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                cgu_name != new_codegen_unit.name()\n-                            }\n-                            MonoItemPlacement::MultipleCgus => true,\n-                        });\n-                        *placement = MonoItemPlacement::MultipleCgus;\n-                    }\n-                    Entry::Vacant(e) => {\n-                        e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name(),\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-\n-        *old_codegen_unit = new_codegen_unit;\n-    }\n-\n-    return mono_item_placements;\n-\n-    fn follow_inlining<'tcx>(\n-        mono_item: MonoItem<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n-        visited: &mut FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if !visited.insert(mono_item) {\n-            return;\n-        }\n-\n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n-        });\n-    }\n-}\n-\n-pub(super) fn internalize_symbols<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    codegen_units: &mut [CodegenUnit<'tcx>],\n-    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-) {\n-    if codegen_units.len() == 1 {\n-        // Fast path for when there is only one codegen unit. In this case we\n-        // can internalize all candidates, since there is nowhere else they\n-        // could be accessed from.\n-        for cgu in codegen_units {\n-            for candidate in &internalization_candidates {\n-                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-            }\n-        }\n-\n-        return;\n-    }\n-\n-    // Build a map from every monomorphization to all the monomorphizations that\n-    // reference it.\n-    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-    cx.inlining_map.iter_accesses(|accessor, accessees| {\n-        for accessee in accessees {\n-            accessor_map.entry(*accessee).or_default().push(accessor);\n-        }\n-    });\n-\n-    // For each internalization candidates in each codegen unit, check if it is\n-    // accessed from outside its defining codegen unit.\n-    for cgu in codegen_units {\n-        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n-\n-        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-            if !internalization_candidates.contains(accessee) {\n-                // This item is no candidate for internalizing, so skip it.\n-                continue;\n-            }\n-            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-            if let Some(accessors) = accessor_map.get(accessee) {\n-                if accessors\n-                    .iter()\n-                    .filter_map(|accessor| {\n-                        // Some accessors might not have been\n-                        // instantiated. We can safely ignore those.\n-                        mono_item_placements.get(accessor)\n-                    })\n-                    .any(|placement| *placement != home_cgu)\n-                {\n-                    // Found an accessor from another CGU, so skip to the next\n-                    // item without marking this one as internal.\n-                    continue;\n-                }\n-            }\n-\n-            // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this monomorphization internal.\n-            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n-        }\n-    }\n-}\n-\n-fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: MonoItem<'tcx>,\n-) -> Option<DefId> {\n-    match mono_item {\n-        MonoItem::Fn(instance) => {\n-            let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def,\n-                ty::InstanceDef::VTableShim(..)\n-                | ty::InstanceDef::ReifyShim(..)\n-                | ty::InstanceDef::FnPtrShim(..)\n-                | ty::InstanceDef::ClosureOnceShim { .. }\n-                | ty::InstanceDef::Intrinsic(..)\n-                | ty::InstanceDef::DropGlue(..)\n-                | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..)\n-                | ty::InstanceDef::ThreadLocalShim(..)\n-                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n-            };\n-\n-            // If this is a method, we want to put it into the same module as\n-            // its self-type. If the self-type does not provide a characteristic\n-            // DefId, we use the location of the impl after all.\n-\n-            if tcx.trait_of_item(def_id).is_some() {\n-                let self_ty = instance.substs.type_at(0);\n-                // This is a default implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n-            }\n-\n-            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-                if tcx.sess.opts.incremental.is_some()\n-                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n-                {\n-                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n-                    // since `drop_in_place` is the only thing that can\n-                    // call it.\n-                    return None;\n-                }\n-\n-                // When polymorphization is enabled, methods which do not depend on their generic\n-                // parameters, but the self-type of their impl block do will fail to normalize.\n-                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n-                    // This is a method within an impl, find out what the self-type is:\n-                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                        instance.substs,\n-                        ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id),\n-                    );\n-                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                        return Some(def_id);\n-                    }\n-                }\n-            }\n-\n-            Some(def_id)\n-        }\n-        MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n-    }\n-}\n-\n-fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    def_id: DefId,\n-    volatile: bool,\n-    cache: &mut CguNameCache,\n-) -> Symbol {\n-    // Find the innermost module that is not nested within a function.\n-    let mut current_def_id = def_id;\n-    let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for.\n-    loop {\n-        if current_def_id.is_crate_root() {\n-            if cgu_def_id.is_none() {\n-                // If we have not found a module yet, take the crate root.\n-                cgu_def_id = Some(def_id.krate.as_def_id());\n-            }\n-            break;\n-        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n-            if cgu_def_id.is_none() {\n-                cgu_def_id = Some(current_def_id);\n-            }\n-        } else {\n-            // If we encounter something that is not a module, throw away\n-            // any module that we've found so far because we now know that\n-            // it is nested within something else.\n-            cgu_def_id = None;\n-        }\n-\n-        current_def_id = tcx.parent(current_def_id);\n-    }\n-\n-    let cgu_def_id = cgu_def_id.unwrap();\n-\n-    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n-        let def_path = tcx.def_path(cgu_def_id);\n-\n-        let components = def_path.data.iter().map(|part| match part.data.name() {\n-            DefPathDataName::Named(name) => name,\n-            DefPathDataName::Anon { .. } => unreachable!(),\n-        });\n-\n-        let volatile_suffix = volatile.then_some(\"volatile\");\n-\n-        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n-    })\n-}\n-\n-// Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n-    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n-}\n-\n-fn mono_item_linkage_and_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> (Linkage, Visibility) {\n-    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n-        return (explicit_linkage, Visibility::Default);\n-    }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n-    (Linkage::External, vis)\n-}\n-\n-type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n-\n-fn static_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    can_be_internalized: &mut bool,\n-    def_id: DefId,\n-) -> Visibility {\n-    if tcx.is_reachable_non_generic(def_id) {\n-        *can_be_internalized = false;\n-        default_visibility(tcx, def_id, false)\n-    } else {\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn mono_item_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> Visibility {\n-    let instance = match mono_item {\n-        // This is pretty complicated; see below.\n-        MonoItem::Fn(instance) => instance,\n-\n-        // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n-        MonoItem::GlobalAsm(item_id) => {\n-            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n-        }\n-    };\n-\n-    let def_id = match instance.def {\n-        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-\n-        // We match the visibility of statics here\n-        InstanceDef::ThreadLocalShim(def_id) => {\n-            return static_visibility(tcx, can_be_internalized, def_id);\n-        }\n-\n-        // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VTableShim(..)\n-        | InstanceDef::ReifyShim(..)\n-        | InstanceDef::FnPtrShim(..)\n-        | InstanceDef::Virtual(..)\n-        | InstanceDef::Intrinsic(..)\n-        | InstanceDef::ClosureOnceShim { .. }\n-        | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..)\n-        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n-    };\n-\n-    // The `start_fn` lang item is actually a monomorphized instance of a\n-    // function in the standard library, used for the `main` function. We don't\n-    // want to export it so we tag it with `Hidden` visibility but this symbol\n-    // is only referenced from the actual `main` symbol which we unfortunately\n-    // don't know anything about during partitioning/collection. As a result we\n-    // forcibly keep this symbol out of the `internalization_candidates` set.\n-    //\n-    // FIXME: eventually we don't want to always force this symbol to have\n-    //        hidden visibility, it should indeed be a candidate for\n-    //        internalization, but we have to understand that it's referenced\n-    //        from the `main` symbol we'll generate later.\n-    //\n-    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n-    if tcx.lang_items().start_fn() == Some(def_id) {\n-        *can_be_internalized = false;\n-        return Visibility::Hidden;\n-    }\n-\n-    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n-\n-    // Upstream `DefId` instances get different handling than local ones.\n-    let Some(def_id) = def_id.as_local() else {\n-        return if export_generics && is_generic {\n-            // If it is an upstream monomorphization and we export generics, we must make\n-            // it available to downstream crates.\n-            *can_be_internalized = false;\n-            default_visibility(tcx, def_id, true)\n-        } else {\n-            Visibility::Hidden\n-        };\n-    };\n-\n-    if is_generic {\n-        if export_generics {\n-            if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used from another crate.\n-                Visibility::Hidden\n-            } else {\n-                // This instance might be useful in a downstream crate.\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), true)\n-            }\n-        } else {\n-            // We are not exporting generics or the definition is not reachable\n-            // for downstream crates, we can internalize its instantiations.\n-            Visibility::Hidden\n-        }\n-    } else {\n-        // If this isn't a generic function then we mark this a `Default` if\n-        // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n-        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n-            *can_be_internalized = false;\n-            debug_assert!(!is_generic);\n-            return default_visibility(tcx, def_id.to_def_id(), false);\n-        }\n-\n-        // If this isn't reachable then we're gonna tag this with `Hidden`\n-        // visibility. In some situations though we'll want to prevent this\n-        // symbol from being internalized.\n-        //\n-        // There's two categories of items here:\n-        //\n-        // * First is weak lang items. These are basically mechanisms for\n-        //   libcore to forward-reference symbols defined later in crates like\n-        //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referencable by\n-        //   libcore, so we're no longer a candidate for internalization.\n-        //   Removal of these functions can't be done by LLVM but rather must be\n-        //   done by the linker as it's a non-local decision.\n-        //\n-        // * Second is \"std internal symbols\". Currently this is primarily used\n-        //   for allocator symbols. Allocators are a little weird in their\n-        //   implementation, but the idea is that the compiler, at the last\n-        //   minute, defines an allocator with an injected object file. The\n-        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n-        //   definition doesn't get hooked up until a linked crate artifact is\n-        //   generated.\n-        //\n-        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n-        //   veneers around the actual implementation, some other symbol which\n-        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n-        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n-        //   internal symbols\".\n-        //\n-        //   The std-internal symbols here **should not show up in a dll as an\n-        //   exported interface**, so they return `false` from\n-        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n-        //   visibility below. Like the weak lang items, though, we can't let\n-        //   LLVM internalize them as this decision is left up to the linker to\n-        //   omit them, so prevent them from being internalized.\n-        let attrs = tcx.codegen_fn_attrs(def_id);\n-        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            *can_be_internalized = false;\n-        }\n-\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.default_hidden_visibility {\n-        return Visibility::Default;\n-    }\n-\n-    // Generic functions never have export-level C.\n-    if is_generic {\n-        return Visibility::Hidden;\n-    }\n-\n-    // Things with export level C don't get instantiated in\n-    // downstream crates.\n-    if !id.is_local() {\n-        return Visibility::Hidden;\n-    }\n-\n-    // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`.\n-    match tcx.reachable_non_generics(id.krate).get(&id) {\n-        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n-        _ => Visibility::Hidden,\n-    }\n-}"}, {"sha": "be9c349c3841621857f1b587bb4389e961fa29bb", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 632, "deletions": 12, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/66cf072ac8fa10648d5eccbacb75c7423204af1e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66cf072ac8fa10648d5eccbacb75c7423204af1e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=66cf072ac8fa10648d5eccbacb75c7423204af1e", "patch": "@@ -92,22 +92,26 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked `#[inline]`.\n \n-mod default;\n-\n use std::cmp;\n+use std::collections::hash_map::Entry;\n use std::fs::{self, File};\n use std::io::{BufWriter, Write};\n use std::path::{Path, PathBuf};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n-use rustc_hir::def_id::{DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::definitions::DefPathDataName;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n use rustc_middle::mir;\n-use rustc_middle::mir::mono::MonoItem;\n-use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n+use rustc_middle::mir::mono::{\n+    CodegenUnit, CodegenUnitNameBuilder, InstantiationMode, Linkage, MonoItem, Visibility,\n+};\n use rustc_middle::query::Providers;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n+use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n use rustc_span::symbol::Symbol;\n \n@@ -121,7 +125,7 @@ struct PartitioningCx<'a, 'tcx> {\n     inlining_map: &'a InliningMap<'tcx>,\n }\n \n-pub struct PlacedRootMonoItems<'tcx> {\n+struct PlacedRootMonoItems<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n     roots: FxHashSet<MonoItem<'tcx>>,\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n@@ -144,7 +148,7 @@ where\n     // functions and statics defined in the local crate.\n     let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        default::place_root_mono_items(cx, mono_items)\n+        place_root_mono_items(cx, mono_items)\n     };\n \n     for cgu in &mut codegen_units {\n@@ -158,7 +162,7 @@ where\n     // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        default::merge_codegen_units(cx, &mut codegen_units);\n+        merge_codegen_units(cx, &mut codegen_units);\n         debug_dump(tcx, \"POST MERGING\", &codegen_units);\n     }\n \n@@ -168,7 +172,7 @@ where\n     // local functions the definition of which is marked with `#[inline]`.\n     let mono_item_placements = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        default::place_inlined_mono_items(cx, &mut codegen_units, roots)\n+        place_inlined_mono_items(cx, &mut codegen_units, roots)\n     };\n \n     for cgu in &mut codegen_units {\n@@ -181,7 +185,7 @@ where\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        default::internalize_symbols(\n+        internalize_symbols(\n             cx,\n             &mut codegen_units,\n             mono_item_placements,\n@@ -229,6 +233,175 @@ where\n     codegen_units\n }\n \n+fn place_root_mono_items<'tcx, I>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    mono_items: &mut I,\n+) -> PlacedRootMonoItems<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let mut roots = FxHashSet::default();\n+    let mut codegen_units = FxHashMap::default();\n+    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet::default();\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics =\n+        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+    let cgu_name_cache = &mut FxHashMap::default();\n+\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(cx.tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n+\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n+        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n+\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(\n+                cx.tcx,\n+                cgu_name_builder,\n+                def_id,\n+                is_volatile,\n+                cgu_name_cache,\n+            ),\n+            None => fallback_cgu_name(cgu_name_builder),\n+        };\n+\n+        let codegen_unit = codegen_units\n+            .entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+        let mut can_be_internalized = true;\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            cx.tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n+        if visibility == Visibility::Hidden && can_be_internalized {\n+            internalization_candidates.insert(mono_item);\n+        }\n+\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n+    }\n+\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n+    if codegen_units.is_empty() {\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+    }\n+\n+    let codegen_units = codegen_units.into_values().collect();\n+    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+}\n+\n+fn merge_codegen_units<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n+) {\n+    assert!(cx.target_cgu_count >= 1);\n+\n+    // Note that at this point in time the `codegen_units` here may not be\n+    // in a deterministic order (but we know they're deterministically the\n+    // same set). We want this merging to produce a deterministic ordering\n+    // of codegen units from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the\n+    // two smallest into each other) we're sure to start off with a\n+    // deterministic order (sorted by name). This'll mean that if two cgus\n+    // have the same size the stable sort below will keep everything nice\n+    // and deterministic.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is\n+    // reached.\n+    while codegen_units.len() > cx.target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n+        }\n+\n+        // Record that `second_smallest` now contains all the stuff that was\n+        // in `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+    if cx.tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of all\n+        // contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict. We are sorting primitive `&str`s here so we can\n+                // use unstable sort.\n+                cgu_contents.sort_unstable();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable,\n+                    // we use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            let numbered_codegen_unit_name =\n+                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+            cgu.set_name(numbered_codegen_unit_name);\n+        }\n+    }\n+}\n+\n /// For symbol internalization, we need to know whether a symbol/mono-item is\n /// accessed from outside the codegen unit it is defined in. This type is used\n /// to keep track of that.\n@@ -238,6 +411,453 @@ enum MonoItemPlacement {\n     MultipleCgus,\n }\n \n+fn place_inlined_mono_items<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n+    let mut mono_item_placements = FxHashMap::default();\n+\n+    let single_codegen_unit = codegen_units.len() == 1;\n+\n+    for old_codegen_unit in codegen_units.iter_mut() {\n+        // Collect all items that need to be available in this codegen unit.\n+        let mut reachable = FxHashSet::default();\n+        for root in old_codegen_unit.items().keys() {\n+            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+        }\n+\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+        // Add all monomorphizations that are not already there.\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                // This is a root, just copy it over.\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+            } else {\n+                if roots.contains(&mono_item) {\n+                    bug!(\n+                        \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                        mono_item\n+                    );\n+                }\n+\n+                // This is a CGU-private copy.\n+                new_codegen_unit\n+                    .items_mut()\n+                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each monomorphization is placed.\n+                match mono_item_placements.entry(mono_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n+                            }\n+                            MonoItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = MonoItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name(),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        *old_codegen_unit = new_codegen_unit;\n+    }\n+\n+    return mono_item_placements;\n+\n+    fn follow_inlining<'tcx>(\n+        mono_item: MonoItem<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+        visited: &mut FxHashSet<MonoItem<'tcx>>,\n+    ) {\n+        if !visited.insert(mono_item) {\n+            return;\n+        }\n+\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n+        });\n+    }\n+}\n+\n+fn internalize_symbols<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+) {\n+    if codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in codegen_units {\n+            for candidate in &internalization_candidates {\n+                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every monomorphization to all the monomorphizations that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee).or_default().push(accessor);\n+        }\n+    });\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in codegen_units {\n+        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue;\n+            }\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors\n+                    .iter()\n+                    .filter_map(|accessor| {\n+                        // Some accessors might not have been\n+                        // instantiated. We can safely ignore those.\n+                        mono_item_placements.get(accessor)\n+                    })\n+                    .any(|placement| *placement != home_cgu)\n+                {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue;\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this monomorphization internal.\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n+    match mono_item {\n+        MonoItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def) => def,\n+                ty::InstanceDef::VTableShim(..)\n+                | ty::InstanceDef::ReifyShim(..)\n+                | ty::InstanceDef::FnPtrShim(..)\n+                | ty::InstanceDef::ClosureOnceShim { .. }\n+                | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::DropGlue(..)\n+                | ty::InstanceDef::Virtual(..)\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::ThreadLocalShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n+            };\n+\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if tcx.trait_of_item(def_id).is_some() {\n+                let self_ty = instance.substs.type_at(0);\n+                // This is a default implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+                if tcx.sess.opts.incremental.is_some()\n+                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n+                {\n+                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n+                    // since `drop_in_place` is the only thing that can\n+                    // call it.\n+                    return None;\n+                }\n+\n+                // When polymorphization is enabled, methods which do not depend on their generic\n+                // parameters, but the self-type of their impl block do will fail to normalize.\n+                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n+                    // This is a method within an impl, find out what the self-type is:\n+                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        tcx.type_of(impl_def_id),\n+                    );\n+                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                        return Some(def_id);\n+                    }\n+                }\n+            }\n+\n+            Some(def_id)\n+        }\n+        MonoItem::Static(def_id) => Some(def_id),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n+    }\n+}\n+\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> Symbol {\n+    // Find the innermost module that is not nested within a function.\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for.\n+    loop {\n+        if current_def_id.is_crate_root() {\n+            if cgu_def_id.is_none() {\n+                // If we have not found a module yet, take the crate root.\n+                cgu_def_id = Some(def_id.krate.as_def_id());\n+            }\n+            break;\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n+            if cgu_def_id.is_none() {\n+                cgu_def_id = Some(current_def_id);\n+            }\n+        } else {\n+            // If we encounter something that is not a module, throw away\n+            // any module that we've found so far because we now know that\n+            // it is nested within something else.\n+            cgu_def_id = None;\n+        }\n+\n+        current_def_id = tcx.parent(current_def_id);\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path.data.iter().map(|part| match part.data.name() {\n+            DefPathDataName::Named(name) => name,\n+            DefPathDataName::Anon { .. } => unreachable!(),\n+        });\n+\n+        let volatile_suffix = volatile.then_some(\"volatile\");\n+\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    })\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+}\n+\n+fn mono_item_linkage_and_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default);\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n+    (Linkage::External, vis)\n+}\n+\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n+\n+fn static_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    can_be_internalized: &mut bool,\n+    def_id: DefId,\n+) -> Visibility {\n+    if tcx.is_reachable_non_generic(def_id) {\n+        *can_be_internalized = false;\n+        default_visibility(tcx, def_id, false)\n+    } else {\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn mono_item_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated; see below.\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise:\n+        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n+        MonoItem::GlobalAsm(item_id) => {\n+            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n+        // We match the visibility of statics here\n+        InstanceDef::ThreadLocalShim(def_id) => {\n+            return static_visibility(tcx, can_be_internalized, def_id);\n+        }\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::VTableShim(..)\n+        | InstanceDef::ReifyShim(..)\n+        | InstanceDef::FnPtrShim(..)\n+        | InstanceDef::Virtual(..)\n+        | InstanceDef::Intrinsic(..)\n+        | InstanceDef::ClosureOnceShim { .. }\n+        | InstanceDef::DropGlue(..)\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden;\n+    }\n+\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones.\n+    let Some(def_id) = def_id.as_local() else {\n+        return if export_generics && is_generic {\n+            // If it is an upstream monomorphization and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        };\n+    };\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id.to_def_id(), true)\n+            }\n+        } else {\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id.to_def_id(), false);\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_handler]` definitions. The\n+        //   definition of these weak lang items needs to be referencable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let attrs = tcx.codegen_fn_attrs(def_id);\n+        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.default_hidden_visibility {\n+        return Visibility::Default;\n+    }\n+\n+    // Generic functions never have export-level C.\n+    if is_generic {\n+        return Visibility::Hidden;\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates.\n+    if !id.is_local() {\n+        return Visibility::Hidden;\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`.\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}\n fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n     let dump = move || {\n         use std::fmt::Write;"}]}