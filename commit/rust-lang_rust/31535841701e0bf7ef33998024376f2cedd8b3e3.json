{"sha": "31535841701e0bf7ef33998024376f2cedd8b3e3", "node_id": "C_kwDOAAsO6NoAKDMxNTM1ODQxNzAxZTBiZjdlZjMzOTk4MDI0Mzc2ZjJjZWRkOGIzZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-19T02:16:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-19T02:16:00Z"}, "message": "Auto merge of #95101 - Dylan-DPC:rollup-r1f1v9t, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #92519 (Use verbatim paths for `process::Command` if necessary)\n - #92612 (Update stdlib for the l4re target)\n - #92663 (Implement `Write for Cursor<[u8; N]>`, plus `A: Allocator` cursor support)\n - #93263 (Consistently present absent stdio handles on Windows as NULL handles.)\n - #93692 (keyword_docs: document use of `in` with `pub` keyword)\n - #94984 (add `CStr` method that accepts any slice containing a nul-terminated string)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e7324ba6fe7594fb039b2a4cd064ed457f43f57e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7324ba6fe7594fb039b2a4cd064ed457f43f57e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31535841701e0bf7ef33998024376f2cedd8b3e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31535841701e0bf7ef33998024376f2cedd8b3e3", "html_url": "https://github.com/rust-lang/rust/commit/31535841701e0bf7ef33998024376f2cedd8b3e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31535841701e0bf7ef33998024376f2cedd8b3e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b701e7eaa08c2b2ef8c6e59b8b33436cb10aa45", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b701e7eaa08c2b2ef8c6e59b8b33436cb10aa45", "html_url": "https://github.com/rust-lang/rust/commit/9b701e7eaa08c2b2ef8c6e59b8b33436cb10aa45"}, {"sha": "30b4182fa7ff8718335771b80a7687acb86f498a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30b4182fa7ff8718335771b80a7687acb86f498a", "html_url": "https://github.com/rust-lang/rust/commit/30b4182fa7ff8718335771b80a7687acb86f498a"}], "stats": {"total": 1273, "additions": 1159, "deletions": 114}, "files": [{"sha": "a68def1e83dbb42c7435f3360c261013b91ecf5f", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -328,6 +328,27 @@ impl FromVecWithNulError {\n     }\n }\n \n+/// An error indicating that no nul byte was present.\n+///\n+/// A slice used to create a [`CStr`] must contain a nul byte somewhere\n+/// within the slice.\n+///\n+/// This error is created by the [`CStr::from_bytes_until_nul`] method.\n+///\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+pub struct FromBytesUntilNulError(());\n+\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+impl Error for FromBytesUntilNulError {}\n+\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+impl fmt::Display for FromBytesUntilNulError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"data provided does not contain a nul\")\n+    }\n+}\n+\n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n /// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n@@ -1239,12 +1260,60 @@ impl CStr {\n         }\n     }\n \n+    /// Creates a C string wrapper from a byte slice.\n+    ///\n+    /// This method will create a `CStr` from any byte slice that contains at\n+    /// least one nul byte. The caller does not need to know or specify where\n+    /// the nul byte is located.\n+    ///\n+    /// If the first byte is a nul character, this method will return an\n+    /// empty `CStr`. If multiple nul characters are present, the `CStr` will\n+    /// end at the first one.\n+    ///\n+    /// If the slice only has a single nul byte at the end, this method is\n+    /// equivalent to [`CStr::from_bytes_with_nul`].\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(cstr_from_bytes_until_nul)]\n+    ///\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let mut buffer = [0u8; 16];\n+    /// unsafe {\n+    ///     // Here we might call an unsafe C function that writes a string\n+    ///     // into the buffer.\n+    ///     let buf_ptr = buffer.as_mut_ptr();\n+    ///     buf_ptr.write_bytes(b'A', 8);\n+    /// }\n+    /// // Attempt to extract a C nul-terminated string from the buffer.\n+    /// let c_str = CStr::from_bytes_until_nul(&buffer[..]).unwrap();\n+    /// assert_eq!(c_str.to_str().unwrap(), \"AAAAAAAA\");\n+    /// ```\n+    ///\n+    #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+    pub fn from_bytes_until_nul(bytes: &[u8]) -> Result<&CStr, FromBytesUntilNulError> {\n+        let nul_pos = memchr::memchr(0, bytes);\n+        match nul_pos {\n+            Some(nul_pos) => {\n+                // SAFETY: We know there is a nul byte at nul_pos, so this slice\n+                // (ending at the nul byte) is a well-formed C string.\n+                let subslice = &bytes[..nul_pos + 1];\n+                Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })\n+            }\n+            None => Err(FromBytesUntilNulError(())),\n+        }\n+    }\n+\n     /// Creates a C string wrapper from a byte slice.\n     ///\n     /// This function will cast the provided `bytes` to a `CStr`\n     /// wrapper after ensuring that the byte slice is nul-terminated\n     /// and does not contain any interior nul bytes.\n     ///\n+    /// If the nul byte may not be at the end,\n+    /// [`CStr::from_bytes_until_nul`] can be used instead.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "c20da138a18d074d24548335e38a3e6f5e455472", "filename": "library/std/src/ffi/c_str/tests.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -117,6 +117,43 @@ fn from_bytes_with_nul_interior() {\n     assert!(cstr.is_err());\n }\n \n+#[test]\n+fn cstr_from_bytes_until_nul() {\n+    // Test an empty slice. This should fail because it\n+    // does not contain a nul byte.\n+    let b = b\"\";\n+    assert_eq!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError(())));\n+\n+    // Test a non-empty slice, that does not contain a nul byte.\n+    let b = b\"hello\";\n+    assert_eq!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError(())));\n+\n+    // Test an empty nul-terminated string\n+    let b = b\"\\0\";\n+    let r = CStr::from_bytes_until_nul(&b[..]).unwrap();\n+    assert_eq!(r.to_bytes(), b\"\");\n+\n+    // Test a slice with the nul byte in the middle\n+    let b = b\"hello\\0world!\";\n+    let r = CStr::from_bytes_until_nul(&b[..]).unwrap();\n+    assert_eq!(r.to_bytes(), b\"hello\");\n+\n+    // Test a slice with the nul byte at the end\n+    let b = b\"hello\\0\";\n+    let r = CStr::from_bytes_until_nul(&b[..]).unwrap();\n+    assert_eq!(r.to_bytes(), b\"hello\");\n+\n+    // Test a slice with two nul bytes at the end\n+    let b = b\"hello\\0\\0\";\n+    let r = CStr::from_bytes_until_nul(&b[..]).unwrap();\n+    assert_eq!(r.to_bytes(), b\"hello\");\n+\n+    // Test a slice containing lots of nul bytes\n+    let b = b\"\\0\\0\\0\\0\";\n+    let r = CStr::from_bytes_until_nul(&b[..]).unwrap();\n+    assert_eq!(r.to_bytes(), b\"\");\n+}\n+\n #[test]\n fn into_boxed() {\n     let orig: &[u8] = b\"Hello, world!\\0\";"}, {"sha": "57f1d628f6ad994c4dea0a9fdd3736f121803b36", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -3,6 +3,7 @@ mod tests;\n \n use crate::io::prelude::*;\n \n+use crate::alloc::Allocator;\n use crate::cmp;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n \n@@ -398,7 +399,10 @@ fn slice_write_vectored(\n }\n \n // Resizing write implementation\n-fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n+fn vec_write<A>(pos_mut: &mut u64, vec: &mut Vec<u8, A>, buf: &[u8]) -> io::Result<usize>\n+where\n+    A: Allocator,\n+{\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n         io::const_io_error!(\n             ErrorKind::InvalidInput,\n@@ -426,11 +430,14 @@ fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usi\n     Ok(buf.len())\n }\n \n-fn vec_write_vectored(\n+fn vec_write_vectored<A>(\n     pos_mut: &mut u64,\n-    vec: &mut Vec<u8>,\n+    vec: &mut Vec<u8, A>,\n     bufs: &[IoSlice<'_>],\n-) -> io::Result<usize> {\n+) -> io::Result<usize>\n+where\n+    A: Allocator,\n+{\n     let mut nwritten = 0;\n     for buf in bufs {\n         nwritten += vec_write(pos_mut, vec, buf)?;\n@@ -462,7 +469,10 @@ impl Write for Cursor<&mut [u8]> {\n }\n \n #[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\n-impl Write for Cursor<&mut Vec<u8>> {\n+impl<A> Write for Cursor<&mut Vec<u8, A>>\n+where\n+    A: Allocator,\n+{\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)\n     }\n@@ -483,7 +493,10 @@ impl Write for Cursor<&mut Vec<u8>> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Write for Cursor<Vec<u8>> {\n+impl<A> Write for Cursor<Vec<u8, A>>\n+where\n+    A: Allocator,\n+{\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, &mut self.inner, buf)\n     }\n@@ -504,7 +517,33 @@ impl Write for Cursor<Vec<u8>> {\n }\n \n #[stable(feature = \"cursor_box_slice\", since = \"1.5.0\")]\n-impl Write for Cursor<Box<[u8]>> {\n+impl<A> Write for Cursor<Box<[u8], A>>\n+where\n+    A: Allocator,\n+{\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        slice_write(&mut self.pos, &mut self.inner, buf)\n+    }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"cursor_array\", since = \"1.61.0\")]\n+impl<const N: usize> Write for Cursor<[u8; N]> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, &mut self.inner, buf)"}, {"sha": "f1ee177b7f3bccaaef053a128053334ab8c63a58", "filename": "library/std/src/io/cursor/tests.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -50,9 +50,11 @@ fn test_mem_mut_writer() {\n     assert_eq!(&writer.get_ref()[..], b);\n }\n \n-#[test]\n-fn test_box_slice_writer() {\n-    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+fn test_slice_writer<T>(writer: &mut Cursor<T>)\n+where\n+    T: AsRef<[u8]>,\n+    Cursor<T>: Write,\n+{\n     assert_eq!(writer.position(), 0);\n     assert_eq!(writer.write(&[0]).unwrap(), 1);\n     assert_eq!(writer.position(), 1);\n@@ -65,12 +67,14 @@ fn test_box_slice_writer() {\n     assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n     assert_eq!(writer.write(&[10]).unwrap(), 0);\n     let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(&**writer.get_ref(), b);\n+    assert_eq!(writer.get_ref().as_ref(), b);\n }\n \n-#[test]\n-fn test_box_slice_writer_vectored() {\n-    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+fn test_slice_writer_vectored<T>(writer: &mut Cursor<T>)\n+where\n+    T: AsRef<[u8]>,\n+    Cursor<T>: Write,\n+{\n     assert_eq!(writer.position(), 0);\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n     assert_eq!(writer.position(), 1);\n@@ -85,53 +89,45 @@ fn test_box_slice_writer_vectored() {\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n     let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(&**writer.get_ref(), b);\n+    assert_eq!(writer.get_ref().as_ref(), b);\n+}\n+\n+#[test]\n+fn test_box_slice_writer() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    test_slice_writer(&mut writer);\n+}\n+\n+#[test]\n+fn test_box_slice_writer_vectored() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    test_slice_writer_vectored(&mut writer);\n+}\n+\n+#[test]\n+fn test_array_writer() {\n+    let mut writer = Cursor::new([0u8; 9]);\n+    test_slice_writer(&mut writer);\n+}\n+\n+#[test]\n+fn test_array_writer_vectored() {\n+    let mut writer = Cursor::new([0u8; 9]);\n+    test_slice_writer_vectored(&mut writer);\n }\n \n #[test]\n fn test_buf_writer() {\n     let mut buf = [0 as u8; 9];\n-    {\n-        let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n-        assert_eq!(writer.write(&[10]).unwrap(), 0);\n-    }\n-    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(buf, b);\n+    let mut writer = Cursor::new(&mut buf[..]);\n+    test_slice_writer(&mut writer);\n }\n \n #[test]\n fn test_buf_writer_vectored() {\n     let mut buf = [0 as u8; 9];\n-    {\n-        let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n-                .unwrap(),\n-            7,\n-        );\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n-    }\n-    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(buf, b);\n+    let mut writer = Cursor::new(&mut buf[..]);\n+    test_slice_writer_vectored(&mut writer);\n }\n \n #[test]"}, {"sha": "ac6d41e13b009e8c2abbc743b6cee210a21155b0", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -202,12 +202,18 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n ///\n /// [`io::stdin`]: stdin\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n ///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// ```no_run\n@@ -230,12 +236,18 @@ pub struct Stdin {\n /// This handle implements both the [`Read`] and [`BufRead`] traits, and\n /// is constructed via the [`Stdin::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n ///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// ```no_run\n@@ -263,11 +275,18 @@ pub struct StdinLock<'a> {\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdin::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:\n@@ -490,11 +509,18 @@ impl fmt::Debug for StdinLock<'_> {\n ///\n /// Created by the [`io::stdout`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// [`lock`]: Stdout::lock\n /// [`io::stdout`]: stdout\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -510,10 +536,17 @@ pub struct Stdout {\n /// This handle implements the [`Write`] trait, and is constructed via\n /// the [`Stdout::lock`] method. See its documentation for more.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[must_use = \"if unused stdout will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n@@ -528,11 +561,18 @@ static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Sy\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdout::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:\n@@ -710,10 +750,17 @@ impl fmt::Debug for StdoutLock<'_> {\n ///\n /// [`io::stderr`]: stderr\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n     inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n@@ -724,10 +771,17 @@ pub struct Stderr {\n /// This handle implements the [`Write`] trait and is constructed via\n /// the [`Stderr::lock`] method. See its documentation for more.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[must_use = \"if unused stderr will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n@@ -738,11 +792,18 @@ pub struct StderrLock<'a> {\n ///\n /// This handle is not buffered.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:"}, {"sha": "bc2384c88d25c57b6613a78c8fae00cb493ee2fc", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -728,6 +728,20 @@ mod impl_keyword {}\n /// [`IntoIterator`]: ../book/ch13-04-performance.html\n /// [range patterns]: ../reference/patterns.html?highlight=range#range-patterns\n /// [`for`]: keyword.for.html\n+///\n+/// The other use of `in` is with the keyword `pub`. It allows users to declare an item as visible\n+/// only within a given scope.\n+///\n+/// ## Literal Example:\n+///\n+///    * `pub(in crate::outer_mod) fn outer_mod_visible_fn() {}` - fn is visible in `outer_mod`\n+///\n+/// Starting with the 2018 edition, paths for `pub(in path)` must start with `crate`, `self` or\n+/// `super`. The 2015 edition may also use paths starting with `::` or modules from the crate root.\n+///\n+/// For more information, see the [Reference].\n+///\n+/// [Reference]: ../reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself\n mod in_keyword {}\n \n #[doc(keyword = \"let\")]"}, {"sha": "b9b6918292fae7d75f0974b3668e1bed9bd27a24", "filename": "library/std/src/os/l4re/fs.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Ffs.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -0,0 +1,382 @@\n+//! L4Re-specific extensions to primitives in the [`std::fs`] module.\n+//!\n+//! [`std::fs`]: crate::fs\n+\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use crate::os::l4re::raw;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: crate::fs::Metadata\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    /// Gain a reference to the underlying `stat` structure which contains\n+    /// the raw information returned by the OS.\n+    ///\n+    /// The contents of the returned [`stat`] are **not** consistent across\n+    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n+    /// cross-Unix abstractions contained within the raw stat.\n+    ///\n+    /// [`stat`]: struct@crate::os::linux::raw::stat\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let stat = meta.as_raw_stat();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(since = \"1.8.0\", reason = \"other methods of this trait are now preferred\")]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    /// Returns the device ID on which this file resides.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_dev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    /// Returns the inode number.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ino());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    /// Returns the file type and mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mode());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    /// Returns the number of hard links to file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_nlink());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    /// Returns the user ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_uid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    /// Returns the group ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_gid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    /// Returns the device ID that this file represents. Only relevant for special file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_rdev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n+    ///\n+    /// The size of a symbolic link is the length of the pathname it contains,\n+    /// without a terminating null byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_size());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    /// Returns the last access time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    /// Returns the last access time of the file, in nanoseconds since [`st_atime`].\n+    ///\n+    /// [`st_atime`]: Self::st_atime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    /// Returns the last modification time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    /// Returns the last modification time of the file, in nanoseconds since [`st_mtime`].\n+    ///\n+    /// [`st_mtime`]: Self::st_mtime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    /// Returns the last status change time of the file, in seconds since Unix Epoch.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    /// Returns the last status change time of the file, in nanoseconds since [`st_ctime`].\n+    ///\n+    /// [`st_ctime`]: Self::st_ctime\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    /// Returns the \"preferred\" block size for efficient filesystem I/O.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blksize());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    /// Returns the number of blocks allocated to the file, 512-byte units.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blocks());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat64 as *const raw::stat) }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "14c2425c165179ee66c4a8439605f27cb546ff38", "filename": "library/std/src/os/l4re/mod.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fmod.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -0,0 +1,7 @@\n+//! L4Re-specific definitions.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![doc(cfg(target_os = \"l4re\"))]\n+\n+pub mod fs;\n+pub mod raw;"}, {"sha": "5efd6301fc92b2d411115f61ec59fdf271dfa4fa", "filename": "library/std/src/os/l4re/raw.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fl4re%2Fraw.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -0,0 +1,365 @@\n+//! L4Re-specific raw type definitions.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n+#![allow(deprecated)]\n+\n+use crate::os::raw::c_ulong;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = c_ulong;\n+\n+#[doc(inline)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use self::arch::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n+\n+#[cfg(any(\n+    target_arch = \"x86\",\n+    target_arch = \"le32\",\n+    target_arch = \"m68k\",\n+    target_arch = \"powerpc\",\n+    target_arch = \"sparc\",\n+    target_arch = \"arm\",\n+    target_arch = \"asmjs\",\n+    target_arch = \"wasm32\"\n+))]\n+mod arch {\n+    use crate::os::raw::{c_long, c_short, c_uint};\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad1: c_short,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __st_ino: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad2: c_uint,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: u64,\n+    }\n+}\n+\n+#[cfg(target_arch = \"mips\")]\n+mod arch {\n+    use crate::os::raw::{c_long, c_ulong};\n+\n+    #[cfg(target_env = \"musl\")]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n+    #[cfg(not(target_env = \"musl\"))]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[cfg(target_env = \"musl\")]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[cfg(not(target_env = \"musl\"))]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[cfg(target_env = \"musl\")]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[cfg(not(target_env = \"musl\"))]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_pad1: [c_long; 3],\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: c_ulong,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_pad2: [c_long; 2],\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"hexagon\")]\n+mod arch {\n+    use crate::os::raw::{c_int, c_long, c_uint};\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = c_long;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = c_uint;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad1: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad2: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad3: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(any(\n+    target_arch = \"mips64\",\n+    target_arch = \"s390x\",\n+    target_arch = \"sparc64\",\n+    target_arch = \"riscv64\",\n+    target_arch = \"riscv32\"\n+))]\n+mod arch {\n+    pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use crate::os::raw::{c_int, c_long};\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = i32;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u32;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = c_long;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad1: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: i32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad2: c_int,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: time_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: time_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: time_t,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"x86_64\", target_arch = \"powerpc64\"))]\n+mod arch {\n+    use crate::os::raw::{c_int, c_long};\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    #[derive(Clone)]\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub struct stat {\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_dev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ino: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_nlink: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mode: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_uid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_gid: u32,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __pad0: c_int,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_rdev: u64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_size: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blksize: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_blocks: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_atime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_mtime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime: i64,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub st_ctime_nsec: c_long,\n+        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "029f131c40be0820743db60c5e83cbfd8979fefb", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -81,7 +81,7 @@ pub mod unix;\n         all(target_vendor = \"fortanix\", target_env = \"sgx\")\n     )\n )))]\n-#[cfg(any(target_os = \"linux\", target_os = \"l4re\", doc))]\n+#[cfg(any(target_os = \"linux\", doc))]\n pub mod linux;\n \n // wasi\n@@ -127,6 +127,8 @@ pub mod haiku;\n pub mod illumos;\n #[cfg(target_os = \"ios\")]\n pub mod ios;\n+#[cfg(target_os = \"l4re\")]\n+pub mod l4re;\n #[cfg(target_os = \"macos\")]\n pub mod macos;\n #[cfg(target_os = \"netbsd\")]"}, {"sha": "7b8ca79eeb8460ae22f245ee9aede11a813ad4af", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -55,7 +55,9 @@ mod platform {\n     pub use crate::os::illumos::*;\n     #[cfg(target_os = \"ios\")]\n     pub use crate::os::ios::*;\n-    #[cfg(any(target_os = \"linux\", target_os = \"l4re\"))]\n+    #[cfg(target_os = \"l4re\")]\n+    pub use crate::os::l4re::*;\n+    #[cfg(target_os = \"linux\")]\n     pub use crate::os::linux::*;\n     #[cfg(target_os = \"macos\")]\n     pub use crate::os::macos::*;"}, {"sha": "be2ccbd98e9c227773bafda5c043323c634e2548", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -164,12 +164,22 @@ impl OwnedHandle {\n         inherit: bool,\n         options: c::DWORD,\n     ) -> io::Result<Self> {\n+        let handle = self.as_raw_handle();\n+\n+        // `Stdin`, `Stdout`, and `Stderr` can all hold null handles, such as\n+        // in a process with a detached console. `DuplicateHandle` would fail\n+        // if we passed it a null handle, but we can treat null as a valid\n+        // handle which doesn't do any I/O, and allow it to be duplicated.\n+        if handle.is_null() {\n+            return unsafe { Ok(Self::from_raw_handle(handle)) };\n+        }\n+\n         let mut ret = 0 as c::HANDLE;\n         cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle(\n                 cur_proc,\n-                self.as_raw_handle(),\n+                handle,\n                 cur_proc,\n                 &mut ret,\n                 access,"}, {"sha": "68fa8918a56a08a4fc3ad0aef8fcedfb03387ad1", "filename": "library/std/src/os/windows/io/raw.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -9,6 +9,7 @@ use crate::net;\n use crate::os::windows::io::{AsHandle, AsSocket};\n use crate::os::windows::io::{OwnedHandle, OwnedSocket};\n use crate::os::windows::raw;\n+use crate::ptr;\n use crate::sys;\n use crate::sys::c;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n@@ -96,45 +97,57 @@ impl AsRawHandle for fs::File {\n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdin {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdout {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stderr {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdinLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdoutLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StderrLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n+// Translate a handle returned from `GetStdHandle` into a handle to return to\n+// the user.\n+fn stdio_handle(raw: RawHandle) -> RawHandle {\n+    // `GetStdHandle` isn't expected to actually fail, so when it returns\n+    // `INVALID_HANDLE_VALUE`, it means we were launched from a parent which\n+    // didn't provide us with stdio handles, such as a parent with a detached\n+    // console. In that case, return null to the user, which is consistent\n+    // with what they'd get in the parent, and which avoids the problem that\n+    // `INVALID_HANDLE_VALUE` aliases the current process handle.\n+    if raw == c::INVALID_HANDLE_VALUE { ptr::null_mut() } else { raw }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     #[inline]"}, {"sha": "f052d8f7f055f3cb23200df5d95122315dc15853", "filename": "library/std/src/sys/unix/l4re.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -13,6 +13,7 @@ pub mod net {\n     use crate::fmt;\n     use crate::io::{self, IoSlice, IoSliceMut};\n     use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+    use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n     use crate::sys::fd::FileDesc;\n     use crate::sys_common::{AsInner, FromInner, IntoInner};\n     use crate::time::Duration;\n@@ -59,7 +60,7 @@ pub mod net {\n         }\n \n         pub fn is_read_vectored(&self) -> bool {\n-            unimpl!();\n+            false\n         }\n \n         pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n@@ -83,7 +84,7 @@ pub mod net {\n         }\n \n         pub fn is_write_vectored(&self) -> bool {\n-            unimpl!();\n+            false\n         }\n \n         pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n@@ -121,23 +122,52 @@ pub mod net {\n         pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n             unimpl!();\n         }\n+\n+        // This is used by sys_common code to abstract over Windows and Unix.\n+        pub fn as_raw(&self) -> RawFd {\n+            self.as_raw_fd()\n+        }\n+    }\n+\n+    impl AsInner<FileDesc> for Socket {\n+        fn as_inner(&self) -> &FileDesc {\n+            &self.0\n+        }\n+    }\n+\n+    impl FromInner<FileDesc> for Socket {\n+        fn from_inner(file_desc: FileDesc) -> Socket {\n+            Socket(file_desc)\n+        }\n     }\n \n-    impl AsInner<libc::c_int> for Socket {\n-        fn as_inner(&self) -> &libc::c_int {\n-            self.0.as_inner()\n+    impl IntoInner<FileDesc> for Socket {\n+        fn into_inner(self) -> FileDesc {\n+            self.0\n         }\n     }\n \n-    impl FromInner<libc::c_int> for Socket {\n-        fn from_inner(fd: libc::c_int) -> Socket {\n-            Socket(FileDesc::new(fd))\n+    impl AsFd for Socket {\n+        fn as_fd(&self) -> BorrowedFd<'_> {\n+            self.0.as_fd()\n         }\n     }\n \n-    impl IntoInner<libc::c_int> for Socket {\n-        fn into_inner(self) -> libc::c_int {\n-            self.0.into_raw()\n+    impl AsRawFd for Socket {\n+        fn as_raw_fd(&self) -> RawFd {\n+            self.0.as_raw_fd()\n+        }\n+    }\n+\n+    impl IntoRawFd for Socket {\n+        fn into_raw_fd(self) -> RawFd {\n+            self.0.into_raw_fd()\n+        }\n+    }\n+\n+    impl FromRawFd for Socket {\n+        unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+            Self(FromRawFd::from_raw_fd(raw_fd))\n         }\n     }\n \n@@ -191,7 +221,7 @@ pub mod net {\n         }\n \n         pub fn is_read_vectored(&self) -> bool {\n-            unimpl!();\n+            false\n         }\n \n         pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n@@ -203,7 +233,7 @@ pub mod net {\n         }\n \n         pub fn is_write_vectored(&self) -> bool {\n-            unimpl!();\n+            false\n         }\n \n         pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n@@ -497,7 +527,7 @@ pub mod net {\n \n     impl LookupHost {\n         pub fn port(&self) -> u16 {\n-            unimpl!();\n+            0 // unimplemented\n         }\n     }\n "}, {"sha": "7423d90263dc2ee396386393f59c36b4b42cc57a", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -80,6 +80,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n                 target_os = \"macos\",\n                 target_os = \"ios\",\n                 target_os = \"redox\",\n+                target_os = \"l4re\",\n             )))] {\n                 use crate::sys::os::errno;\n                 let pfds: &mut [_] = &mut ["}, {"sha": "2a97a802a2036a4977c4f92b13a06545a41e5da6", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -27,7 +27,10 @@ use crate::sys::weak::weak;\n use libc::RTP_ID as pid_t;\n \n #[cfg(not(target_os = \"vxworks\"))]\n-use libc::{c_int, gid_t, pid_t, uid_t};\n+use libc::{c_int, pid_t};\n+\n+#[cfg(not(any(target_os = \"vxworks\", target_os = \"l4re\")))]\n+use libc::{gid_t, uid_t};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command"}, {"sha": "a13585a02224aed6e43f0cc1fd042635275c3b25", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -19,12 +19,12 @@ use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::c::NonZeroDWORD;\n+use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::path;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n-use crate::sys::{cvt, to_u16s};\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n use crate::sys_common::{AsInner, IntoInner};\n@@ -269,8 +269,13 @@ impl Command {\n             None\n         };\n         let program = resolve_exe(&self.program, || env::var_os(\"PATH\"), child_paths)?;\n+        // Case insensitive \"ends_with\" of UTF-16 encoded \".bat\" or \".cmd\"\n+        let is_batch_file = matches!(\n+            program.len().checked_sub(5).and_then(|i| program.get(i..)),\n+            Some([46, 98 | 66, 97 | 65, 116 | 84, 0] | [46, 99 | 67, 109 | 77, 100 | 68, 0])\n+        );\n         let mut cmd_str =\n-            make_command_line(program.as_os_str(), &self.args, self.force_quotes_enabled)?;\n+            make_command_line(&program, &self.args, self.force_quotes_enabled, is_batch_file)?;\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -309,7 +314,6 @@ impl Command {\n         si.hStdOutput = stdout.as_raw_handle();\n         si.hStdError = stderr.as_raw_handle();\n \n-        let program = to_u16s(&program)?;\n         unsafe {\n             cvt(c::CreateProcessW(\n                 program.as_ptr(),\n@@ -366,7 +370,7 @@ fn resolve_exe<'a>(\n     exe_path: &'a OsStr,\n     parent_paths: impl FnOnce() -> Option<OsString>,\n     child_paths: Option<&OsStr>,\n-) -> io::Result<PathBuf> {\n+) -> io::Result<Vec<u16>> {\n     // Early return if there is no filename.\n     if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n         return Err(io::const_io_error!(\n@@ -388,19 +392,19 @@ fn resolve_exe<'a>(\n         if has_exe_suffix {\n             // The application name is a path to a `.exe` file.\n             // Let `CreateProcessW` figure out if it exists or not.\n-            return Ok(exe_path.into());\n+            return path::maybe_verbatim(Path::new(exe_path));\n         }\n         let mut path = PathBuf::from(exe_path);\n \n         // Append `.exe` if not already there.\n         path = path::append_suffix(path, EXE_SUFFIX.as_ref());\n-        if program_exists(&path) {\n+        if let Some(path) = program_exists(&path) {\n             return Ok(path);\n         } else {\n             // It's ok to use `set_extension` here because the intent is to\n             // remove the extension that was just added.\n             path.set_extension(\"\");\n-            return Ok(path);\n+            return path::maybe_verbatim(&path);\n         }\n     } else {\n         ensure_no_nuls(exe_path)?;\n@@ -415,7 +419,7 @@ fn resolve_exe<'a>(\n             if !has_extension {\n                 path.set_extension(EXE_EXTENSION);\n             }\n-            if program_exists(&path) { Some(path) } else { None }\n+            program_exists(&path)\n         });\n         if let Some(path) = result {\n             return Ok(path);\n@@ -431,10 +435,10 @@ fn search_paths<Paths, Exists>(\n     parent_paths: Paths,\n     child_paths: Option<&OsStr>,\n     mut exists: Exists,\n-) -> Option<PathBuf>\n+) -> Option<Vec<u16>>\n where\n     Paths: FnOnce() -> Option<OsString>,\n-    Exists: FnMut(PathBuf) -> Option<PathBuf>,\n+    Exists: FnMut(PathBuf) -> Option<Vec<u16>>,\n {\n     // 1. Child paths\n     // This is for consistency with Rust's historic behaviour.\n@@ -486,17 +490,18 @@ where\n }\n \n /// Check if a file exists without following symlinks.\n-fn program_exists(path: &Path) -> bool {\n+fn program_exists(path: &Path) -> Option<Vec<u16>> {\n     unsafe {\n-        to_u16s(path)\n-            .map(|path| {\n-                // Getting attributes using `GetFileAttributesW` does not follow symlinks\n-                // and it will almost always be successful if the link exists.\n-                // There are some exceptions for special system files (e.g. the pagefile)\n-                // but these are not executable.\n-                c::GetFileAttributesW(path.as_ptr()) != c::INVALID_FILE_ATTRIBUTES\n-            })\n-            .unwrap_or(false)\n+        let path = path::maybe_verbatim(path).ok()?;\n+        // Getting attributes using `GetFileAttributesW` does not follow symlinks\n+        // and it will almost always be successful if the link exists.\n+        // There are some exceptions for special system files (e.g. the pagefile)\n+        // but these are not executable.\n+        if c::GetFileAttributesW(path.as_ptr()) == c::INVALID_FILE_ATTRIBUTES {\n+            None\n+        } else {\n+            Some(path)\n+        }\n     }\n }\n \n@@ -730,7 +735,12 @@ enum Quote {\n \n // Produces a wide string *without terminating null*; returns an error if\n // `prog` or any of the `args` contain a nul.\n-fn make_command_line(prog: &OsStr, args: &[Arg], force_quotes: bool) -> io::Result<Vec<u16>> {\n+fn make_command_line(\n+    prog: &[u16],\n+    args: &[Arg],\n+    force_quotes: bool,\n+    is_batch_file: bool,\n+) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n@@ -739,17 +749,18 @@ fn make_command_line(prog: &OsStr, args: &[Arg], force_quotes: bool) -> io::Resu\n     // need to add an extra pair of quotes surrounding the whole command line\n     // so they are properly passed on to the script.\n     // See issue #91991.\n-    let is_batch_file = Path::new(prog)\n-        .extension()\n-        .map(|ext| ext.eq_ignore_ascii_case(\"cmd\") || ext.eq_ignore_ascii_case(\"bat\"))\n-        .unwrap_or(false);\n     if is_batch_file {\n         cmd.push(b'\"' as u16);\n     }\n \n-    // Always quote the program name so CreateProcess doesn't interpret args as\n-    // part of the name if the binary wasn't found first time.\n-    append_arg(&mut cmd, prog, Quote::Always)?;\n+    // Always quote the program name so CreateProcess to avoid ambiguity when\n+    // the child process parses its arguments.\n+    // Note that quotes aren't escaped here because they can't be used in arg0.\n+    // But that's ok because file paths can't contain quotes.\n+    cmd.push(b'\"' as u16);\n+    cmd.extend_from_slice(prog.strip_suffix(&[0]).unwrap_or(prog));\n+    cmd.push(b'\"' as u16);\n+\n     for arg in args {\n         cmd.push(' ' as u16);\n         let (arg, quote) = match arg {"}, {"sha": "96477fb19dafaf1802801e8e21ea9b04b1ab6125", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31535841701e0bf7ef33998024376f2cedd8b3e3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=31535841701e0bf7ef33998024376f2cedd8b3e3", "patch": "@@ -3,11 +3,12 @@ use super::Arg;\n use crate::env;\n use crate::ffi::{OsStr, OsString};\n use crate::process::Command;\n+use crate::sys::to_u16s;\n \n #[test]\n fn test_raw_args() {\n     let command_line = &make_command_line(\n-        OsStr::new(\"quoted exe\"),\n+        &to_u16s(\"quoted exe\").unwrap(),\n         &[\n             Arg::Regular(OsString::from(\"quote me\")),\n             Arg::Raw(OsString::from(\"quote me *not*\")),\n@@ -16,6 +17,7 @@ fn test_raw_args() {\n             Arg::Regular(OsString::from(\"optional-quotes\")),\n         ],\n         false,\n+        false,\n     )\n     .unwrap();\n     assert_eq!(\n@@ -28,9 +30,10 @@ fn test_raw_args() {\n fn test_make_command_line() {\n     fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n         let command_line = &make_command_line(\n-            OsStr::new(prog),\n+            &to_u16s(prog).unwrap(),\n             &args.iter().map(|a| Arg::Regular(OsString::from(a))).collect::<Vec<_>>(),\n             force_quotes,\n+            false,\n         )\n         .unwrap();\n         String::from_utf16(command_line).unwrap()"}]}