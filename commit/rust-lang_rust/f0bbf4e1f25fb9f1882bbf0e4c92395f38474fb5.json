{"sha": "f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYmJmNGUxZjI1ZmI5ZjE4ODJiYmYwZTRjOTIzOTVmMzg0NzRmYjU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-26T17:43:17Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-02T13:38:57Z"}, "message": "incr.comp.: Re-execute queries during red/green marking in order to find out their color.", "tree": {"sha": "82c087a2a5edcb48c56d2bb87e754c21f3b1f0ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82c087a2a5edcb48c56d2bb87e754c21f3b1f0ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "html_url": "https://github.com/rust-lang/rust/commit/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db27d9f90223693e84d230e5654d4c1a5afe700", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db27d9f90223693e84d230e5654d4c1a5afe700", "html_url": "https://github.com/rust-lang/rust/commit/6db27d9f90223693e84d230e5654d4c1a5afe700"}], "stats": {"total": 489, "additions": 397, "deletions": 92}, "files": [{"sha": "987bb5a9a4de8338268edb42154d75a72d7336fc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -66,7 +66,6 @@ use hir::{HirId, ItemLocalId};\n \n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef};\n-use ty::fast_reject::SimplifiedType;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n use std::fmt;\n@@ -430,7 +429,6 @@ define_dep_nodes!( <'tcx>\n     [] RegionScopeTree(DefId),\n     [] Coherence,\n     [] CoherenceInherentImplOverlapCheck,\n-    [] Resolve,\n     [] CoherenceCheckTrait(DefId),\n     [] PrivacyAccessLevels(CrateNum),\n \n@@ -447,10 +445,8 @@ define_dep_nodes!( <'tcx>\n     [] MirBorrowCheck(DefId),\n     [] UnsafetyViolations(DefId),\n \n-    [] RvalueCheck(DefId),\n     [] Reachability,\n     [] MirKeys,\n-    [] TransWriteMetadata,\n     [] CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n@@ -498,18 +494,9 @@ define_dep_nodes!( <'tcx>\n \n     // The set of impls for a given trait.\n     [] TraitImpls(DefId),\n-    [] RelevantTraitImpls(DefId, SimplifiedType),\n \n     [] AllLocalTraitImpls,\n \n-    // Nodes representing caches. To properly handle a true cache, we\n-    // don't use a DepTrackingMap, but rather we push a task node.\n-    // Otherwise the write into the map would be incorrectly\n-    // attributed to the first task that happened to fill the cache,\n-    // which would yield an overly conservative dep-graph.\n-    [] TraitItems(DefId),\n-    [] ReprHints(DefId),\n-\n     // Trait selection cache is a little funny. Given a trait\n     // reference like `Foo: SomeTrait<Bar>`, there could be\n     // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n@@ -598,7 +585,6 @@ define_dep_nodes!( <'tcx>\n     [] MissingLangItems(CrateNum),\n     [] ExternConstBody(DefId),\n     [] VisibleParentMap,\n-    [] IsDirectExternCrate(CrateNum),\n     [] MissingExternCrateItem(CrateNum),\n     [] UsedCrateSource(CrateNum),\n     [] PostorderCnums,\n@@ -618,6 +604,9 @@ define_dep_nodes!( <'tcx>\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [] OutputFilenames,\n+\n+    // We use this for most things when incr. comp. is turned off.\n+    [] Null,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "80b408f67bb0ef3deb253360422e850d9f16cc62", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -460,8 +460,9 @@ impl DepGraph {\n \n         let mut current_deps = Vec::new();\n \n-        for &dep_dep_node in prev_deps {\n-            let dep_dep_node = &data.previous.index_to_node(dep_dep_node);\n+        for &dep_dep_node_index in prev_deps {\n+            let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+\n             let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n             match dep_dep_node_color {\n                 Some(DepNodeColor::Green(node_index)) => {\n@@ -478,19 +479,42 @@ impl DepGraph {\n                     return None\n                 }\n                 None => {\n+                    if dep_dep_node.kind.is_input() {\n+                        // This input does not exist anymore.\n+                        debug_assert!(dep_dep_node.extract_def_id(tcx).is_none());\n+                        return None;\n+                    }\n+\n                     // We don't know the state of this dependency. Let's try to\n                     // mark it green.\n                     if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n                         current_deps.push(node_index);\n                     } else {\n-                        // We failed to mark it green. This can have various\n-                        // reasons.\n-                        return None\n+                        // We failed to mark it green, so we try to force the query.\n+                        if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n+                            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n+                            match dep_dep_node_color {\n+                                Some(DepNodeColor::Green(node_index)) => {\n+                                    current_deps.push(node_index);\n+                                }\n+                                Some(DepNodeColor::Red) => {\n+                                    return None\n+                                }\n+                                None => {\n+                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                          should have set its color\")\n+                                }\n+                            }\n+                        } else {\n+                            // The DepNode could not be forced.\n+                            return None\n+                        }\n                     }\n                 }\n             }\n         }\n \n+\n         // If we got here without hitting a `return` that means that all\n         // dependencies of this DepNode could be marked as green. Therefore we\n         // can also mark this DepNode as green. We do so by..."}, {"sha": "f6c587a931000099d15304e53ca6ff6a98660791", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -56,6 +56,7 @@ use syntax::symbol::Symbol;\n #[macro_use]\n mod plumbing;\n use self::plumbing::*;\n+pub use self::plumbing::force_from_dep_node;\n \n mod keys;\n pub use self::keys::Key;"}, {"sha": "6b1fa8f685d00feee2dbceef734f46551e61220d", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 344, "deletions": 65, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -12,7 +12,7 @@\n //! that generate the actual methods on tcx which find and execute the\n //! provider, manage the caches, and so forth.\n \n-use dep_graph::{DepNodeIndex};\n+use dep_graph::{DepNodeIndex, DepNode, DepKind};\n use errors::{Diagnostic, DiagnosticBuilder};\n use ty::{TyCtxt};\n use ty::maps::Query; // NB: actually generated by the macros in this file\n@@ -232,12 +232,10 @@ macro_rules! define_maps {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                  mut span: Span,\n-                                  key: $K,\n-                                  f: F)\n-                                  -> Result<R, CycleError<'a, $tcx>>\n-                where F: FnOnce(&$V) -> R\n+            fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                            mut span: Span,\n+                            key: $K)\n+                            -> Result<$V, CycleError<'a, $tcx>>\n             {\n                 debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                        stringify!($name),\n@@ -264,18 +262,53 @@ macro_rules! define_maps {\n                     }\n                     profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                     tcx.dep_graph.read_index(value.index);\n-                    return Ok(f(&value.value));\n+                    return Ok((&value.value).clone());\n                 }\n+\n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n                 // default_span calls def_span query internally.\n                 if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n                     span = key.default_span(tcx)\n                 }\n \n+                // Fast path for when incr. comp. is off. `to_dep_node` is\n+                // expensive for some DepKinds.\n+                if !tcx.dep_graph.is_fully_enabled() {\n+                    let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n+                    return Self::force(tcx, key, span, null_dep_node)\n+                                .map(|(v, _)| v);\n+                }\n+\n                 let dep_node = Self::to_dep_node(tcx, &key);\n \n-                if !dep_node.kind.is_input() && tcx.sess.opts.build_dep_graph() {\n+                if dep_node.kind.is_anon() {\n+                    profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n+\n+                    let res = tcx.cycle_check(span, Query::$name(key), || {\n+                        tcx.sess.diagnostic().track_diagnostics(|| {\n+                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                                Self::compute_result(tcx.global_tcx(), key)\n+                            })\n+                        })\n+                    })?;\n+\n+                    profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+                    let ((result, dep_node_index), diagnostics) = res;\n+\n+                    tcx.dep_graph.read_index(dep_node_index);\n+                    let value = QueryValue::new(result, dep_node_index, diagnostics);\n+\n+                    return Ok((&tcx.maps\n+                                    .$name\n+                                    .borrow_mut()\n+                                    .map\n+                                    .entry(key)\n+                                    .or_insert(value)\n+                                    .value).clone());\n+                }\n+\n+                if !dep_node.kind.is_input() {\n                     use dep_graph::DepNodeColor;\n                     if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph\n                                                                           .node_color(&dep_node) {\n@@ -284,8 +317,7 @@ macro_rules! define_maps {\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n-                                                                        dep_node_index,\n-                                                                        f)\n+                                                                        dep_node_index)\n                     }\n \n                     if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n@@ -295,57 +327,29 @@ macro_rules! define_maps {\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n-                                                                        dep_node_index,\n-                                                                        f)\n+                                                                        dep_node_index)\n                     }\n                 }\n \n-                // else, we are going to run the provider:\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        if dep_node.kind.is_anon() {\n-                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                Self::compute_result(tcx.global_tcx(), key)\n-                            })\n-                        } else {\n-                            tcx.dep_graph.with_task(dep_node,\n-                                                    tcx,\n-                                                    key,\n-                                                    Self::compute_result)\n-                        }\n-                    })\n-                })?;\n-\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                let ((result, dep_node_index), diagnostics) = res;\n-\n-                tcx.dep_graph.read_index(dep_node_index);\n-\n-                let value = QueryValue::new(result, dep_node_index, diagnostics);\n-\n-                Ok(f(&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value))\n+                match Self::force(tcx, key, span, dep_node) {\n+                    Ok((result, dep_node_index)) => {\n+                        tcx.dep_graph.read_index(dep_node_index);\n+                        Ok(result)\n+                    }\n+                    Err(e) => Err(e)\n+                }\n             }\n \n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n             }\n \n-            fn load_from_disk_and_cache_in_memory<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                                        key: $K,\n-                                                        span: Span,\n-                                                        dep_node_index: DepNodeIndex,\n-                                                        f: F)\n-                                                        -> Result<R, CycleError<'a, $tcx>>\n-                where F: FnOnce(&$V) -> R\n+            fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                                  key: $K,\n+                                                  span: Span,\n+                                                  dep_node_index: DepNodeIndex)\n+                                                  -> Result<$V, CycleError<'a, $tcx>>\n             {\n                 debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n \n@@ -361,32 +365,56 @@ macro_rules! define_maps {\n \n                 let value = QueryValue::new(result, dep_node_index, diagnostics);\n \n-                Ok(f(&tcx.maps\n+                Ok((&tcx.maps\n+                         .$name\n+                         .borrow_mut()\n+                         .map\n+                         .entry(key)\n+                         .or_insert(value)\n+                         .value).clone())\n+            }\n+\n+            fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                     key: $K,\n+                     span: Span,\n+                     dep_node: DepNode)\n+                     -> Result<($V, DepNodeIndex), CycleError<'a, $tcx>> {\n+                debug_assert!(tcx.dep_graph.node_color(&dep_node).is_none());\n+\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n+                let res = tcx.cycle_check(span, Query::$name(key), || {\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        tcx.dep_graph.with_task(dep_node,\n+                                                tcx,\n+                                                key,\n+                                                Self::compute_result)\n+                    })\n+                })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+\n+                let ((result, dep_node_index), diagnostics) = res;\n+\n+                let value = QueryValue::new(result, dep_node_index, diagnostics);\n+\n+                Ok(((&tcx.maps\n                          .$name\n                          .borrow_mut()\n                          .map\n                          .entry(key)\n                          .or_insert(value)\n-                         .value))\n+                         .value).clone(),\n+                   dep_node_index))\n             }\n \n+\n+\n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n                            -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key, Clone::clone) {\n+                match Self::try_get_with(tcx, span, key) {\n                     Ok(e) => Ok(e),\n                     Err(e) => Err(tcx.report_cycle(e)),\n                 }\n             }\n-\n-            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n-                // Ignore dependencies, since we not reading the computed value\n-                let _task = tcx.dep_graph.in_ignore();\n-\n-                match Self::try_get_with(tcx, span, key, |_| ()) {\n-                    Ok(()) => {}\n-                    Err(e) => tcx.report_cycle(e).emit(),\n-                }\n-            }\n         })*\n \n         #[derive(Copy, Clone)]\n@@ -564,3 +592,254 @@ macro_rules! define_provider_struct {\n         }\n     };\n }\n+\n+pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n+                                           dep_node: &DepNode)\n+                                           -> bool {\n+    use ty::maps::keys::Key;\n+    use hir::def_id::LOCAL_CRATE;\n+\n+    // We should never get into the situation of having to force this from the DepNode.\n+    // Since we cannot reconstruct the query key, we would always end up having to evaluate\n+    // the first caller of this query that *is* reconstructible. This might very well be\n+    // compile_codegen_unit() in which case we'd lose all re-use.\n+    debug_assert!(dep_node.kind != DepKind::CodegenUnit,\n+                  \"calling force_from_dep_node() on DepKind::CodegenUnit\");\n+\n+    if !dep_node.kind.can_reconstruct_query_key() {\n+        return false\n+    }\n+\n+    macro_rules! def_id {\n+        () => {\n+            if let Some(def_id) = dep_node.extract_def_id(tcx) {\n+                def_id\n+            } else {\n+                // return from the whole function\n+                return false\n+            }\n+        }\n+    };\n+\n+    macro_rules! krate {\n+        () => { (def_id!()).krate }\n+    };\n+\n+    macro_rules! force {\n+        ($query:ident, $key:expr) => {\n+            {\n+                use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n+\n+                // FIXME(eddyb) Get more valid Span's on queries.\n+                // def_span guard is necessary to prevent a recursive loop,\n+                // default_span calls def_span query internally.\n+                let span = if stringify!($query) != \"def_span\" {\n+                    $key.default_span(tcx)\n+                } else {\n+                    ::syntax_pos::DUMMY_SP\n+                };\n+\n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        ::ty::maps::QueryMsg::$query(profq_key!(tcx, $key))\n+                    )\n+                );\n+\n+                match ::ty::maps::queries::$query::force(tcx, $key, span, *dep_node) {\n+                    Ok(_) => {},\n+                    Err(e) => {\n+                        tcx.report_cycle(e).emit();\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    match dep_node.kind {\n+        // These are inputs that are expected to be pre-allocated and that\n+        // should therefore always be red or green already\n+        DepKind::AllLocalTraitImpls |\n+        DepKind::Krate |\n+        DepKind::CrateMetadata |\n+        DepKind::HirBody |\n+        DepKind::Hir |\n+\n+        // This are anonymous nodes\n+        DepKind::IsCopy |\n+        DepKind::IsSized |\n+        DepKind::IsFreeze |\n+        DepKind::NeedsDrop |\n+        DepKind::Layout |\n+        DepKind::TraitSelect |\n+        DepKind::ProjectionCache |\n+        DepKind::ConstEval |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these\n+        DepKind::InstanceSymbolName |\n+        DepKind::MirShim |\n+        DepKind::BorrowCheckKrate |\n+        DepKind::Specializes |\n+        DepKind::ImplementationsOfTrait |\n+        DepKind::TypeParamPredicates |\n+        DepKind::CodegenUnit |\n+        DepKind::CompileCodegenUnit |\n+\n+        // This one is just odd\n+        DepKind::Null |\n+        DepKind::WorkProduct => {\n+            bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node.kind)\n+        }\n+\n+        // These is not a queries\n+        DepKind::CoherenceCheckTrait |\n+        DepKind::ItemVarianceConstraints => {\n+            return false\n+        }\n+\n+        DepKind::RegionScopeTree => { force!(region_scope_tree, def_id!()); }\n+\n+        DepKind::Coherence => { force!(crate_inherent_impls, LOCAL_CRATE); }\n+        DepKind::CoherenceInherentImplOverlapCheck => {\n+            force!(crate_inherent_impls_overlap_check, LOCAL_CRATE)\n+        },\n+        DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n+        DepKind::MirConstQualif => { force!(mir_const_qualif, def_id!()); }\n+        DepKind::MirConst => { force!(mir_const, def_id!()); }\n+        DepKind::MirValidated => { force!(mir_validated, def_id!()); }\n+        DepKind::MirOptimized => { force!(optimized_mir, def_id!()); }\n+\n+        DepKind::BorrowCheck => { force!(borrowck, def_id!()); }\n+        DepKind::MirBorrowCheck => { force!(mir_borrowck, def_id!()); }\n+        DepKind::UnsafetyViolations => { force!(unsafety_violations, def_id!()); }\n+        DepKind::Reachability => { force!(reachable_set, LOCAL_CRATE); }\n+        DepKind::MirKeys => { force!(mir_keys, LOCAL_CRATE); }\n+        DepKind::CrateVariances => { force!(crate_variances, LOCAL_CRATE); }\n+        DepKind::AssociatedItems => { force!(associated_item, def_id!()); }\n+        DepKind::TypeOfItem => { force!(type_of, def_id!()); }\n+        DepKind::GenericsOfItem => { force!(generics_of, def_id!()); }\n+        DepKind::PredicatesOfItem => { force!(predicates_of, def_id!()); }\n+        DepKind::SuperPredicatesOfItem => { force!(super_predicates_of, def_id!()); }\n+        DepKind::TraitDefOfItem => { force!(trait_def, def_id!()); }\n+        DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }\n+        DepKind::IsDefaultImpl => { force!(is_default_impl, def_id!()); }\n+        DepKind::ImplTraitRef => { force!(impl_trait_ref, def_id!()); }\n+        DepKind::ImplPolarity => { force!(impl_polarity, def_id!()); }\n+        DepKind::ClosureKind => { force!(closure_kind, def_id!()); }\n+        DepKind::FnSignature => { force!(fn_sig, def_id!()); }\n+        DepKind::GenSignature => { force!(generator_sig, def_id!()); }\n+        DepKind::CoerceUnsizedInfo => { force!(coerce_unsized_info, def_id!()); }\n+        DepKind::ItemVariances => { force!(variances_of, def_id!()); }\n+        DepKind::IsConstFn => { force!(is_const_fn, def_id!()); }\n+        DepKind::IsForeignItem => { force!(is_foreign_item, def_id!()); }\n+        DepKind::SizedConstraint => { force!(adt_sized_constraint, def_id!()); }\n+        DepKind::DtorckConstraint => { force!(adt_dtorck_constraint, def_id!()); }\n+        DepKind::AdtDestructor => { force!(adt_destructor, def_id!()); }\n+        DepKind::AssociatedItemDefIds => { force!(associated_item_def_ids, def_id!()); }\n+        DepKind::InherentImpls => { force!(inherent_impls, def_id!()); }\n+        DepKind::TypeckBodiesKrate => { force!(typeck_item_bodies, LOCAL_CRATE); }\n+        DepKind::TypeckTables => { force!(typeck_tables_of, def_id!()); }\n+        DepKind::HasTypeckTables => { force!(has_typeck_tables, def_id!()); }\n+        DepKind::SymbolName => { force!(def_symbol_name, def_id!()); }\n+        DepKind::SpecializationGraph => { force!(specialization_graph_of, def_id!()); }\n+        DepKind::ObjectSafety => { force!(is_object_safe, def_id!()); }\n+        DepKind::TraitImpls => { force!(trait_impls_of, def_id!()); }\n+\n+        DepKind::ParamEnv => { force!(param_env, def_id!()); }\n+        DepKind::DescribeDef => { force!(describe_def, def_id!()); }\n+        DepKind::DefSpan => { force!(def_span, def_id!()); }\n+        DepKind::LookupStability => { force!(lookup_stability, def_id!()); }\n+        DepKind::LookupDeprecationEntry => {\n+            force!(lookup_deprecation_entry, def_id!());\n+        }\n+        DepKind::ItemBodyNestedBodies => { force!(item_body_nested_bodies, def_id!()); }\n+        DepKind::ConstIsRvaluePromotableToStatic => {\n+            force!(const_is_rvalue_promotable_to_static, def_id!());\n+        }\n+        DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n+        DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n+        DepKind::IsExportedSymbol => { force!(is_exported_symbol, def_id!()); }\n+        DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n+        DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n+        DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n+        DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n+        DepKind::IsPanicRuntime => { force!(is_panic_runtime, krate!()); }\n+        DepKind::IsCompilerBuiltins => { force!(is_compiler_builtins, krate!()); }\n+        DepKind::HasGlobalAllocator => { force!(has_global_allocator, krate!()); }\n+        DepKind::ExternCrate => { force!(extern_crate, def_id!()); }\n+        DepKind::LintLevels => { force!(lint_levels, LOCAL_CRATE); }\n+        DepKind::InScopeTraits => { force!(in_scope_traits_map, def_id!().index); }\n+        DepKind::ModuleExports => { force!(module_exports, def_id!()); }\n+        DepKind::IsSanitizerRuntime => { force!(is_sanitizer_runtime, krate!()); }\n+        DepKind::IsProfilerRuntime => { force!(is_profiler_runtime, krate!()); }\n+        DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n+        DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n+        DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n+        DepKind::ExportedSymbolIds => { force!(exported_symbol_ids, krate!()); }\n+        DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n+        DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n+        DepKind::DeriveRegistrarFn => { force!(derive_registrar_fn, krate!()); }\n+        DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n+        DepKind::CrateHash => { force!(crate_hash, krate!()); }\n+        DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n+\n+        DepKind::AllTraitImplementations => {\n+            force!(all_trait_implementations, krate!());\n+        }\n+\n+        DepKind::IsDllimportForeignItem => {\n+            force!(is_dllimport_foreign_item, def_id!());\n+        }\n+        DepKind::IsStaticallyIncludedForeignItem => {\n+            force!(is_statically_included_foreign_item, def_id!());\n+        }\n+        DepKind::NativeLibraryKind => { force!(native_library_kind, def_id!()); }\n+        DepKind::LinkArgs => { force!(link_args, LOCAL_CRATE); }\n+\n+        DepKind::NamedRegion => { force!(named_region_map, def_id!().index); }\n+        DepKind::IsLateBound => { force!(is_late_bound_map, def_id!().index); }\n+        DepKind::ObjectLifetimeDefaults => {\n+            force!(object_lifetime_defaults_map, def_id!().index);\n+        }\n+\n+        DepKind::Visibility => { force!(visibility, def_id!()); }\n+        DepKind::DepKind => { force!(dep_kind, krate!()); }\n+        DepKind::CrateName => { force!(crate_name, krate!()); }\n+        DepKind::ItemChildren => { force!(item_children, def_id!()); }\n+        DepKind::ExternModStmtCnum => { force!(extern_mod_stmt_cnum, def_id!()); }\n+        DepKind::GetLangItems => { force!(get_lang_items, LOCAL_CRATE); }\n+        DepKind::DefinedLangItems => { force!(defined_lang_items, krate!()); }\n+        DepKind::MissingLangItems => { force!(missing_lang_items, krate!()); }\n+        DepKind::ExternConstBody => { force!(extern_const_body, def_id!()); }\n+        DepKind::VisibleParentMap => { force!(visible_parent_map, LOCAL_CRATE); }\n+        DepKind::MissingExternCrateItem => {\n+            force!(missing_extern_crate_item, krate!());\n+        }\n+        DepKind::UsedCrateSource => { force!(used_crate_source, krate!()); }\n+        DepKind::PostorderCnums => { force!(postorder_cnums, LOCAL_CRATE); }\n+        DepKind::HasCloneClosures => { force!(has_clone_closures, krate!()); }\n+        DepKind::HasCopyClosures => { force!(has_copy_closures, krate!()); }\n+\n+        DepKind::Freevars => { force!(freevars, def_id!()); }\n+        DepKind::MaybeUnusedTraitImport => {\n+            force!(maybe_unused_trait_import, def_id!());\n+        }\n+        DepKind::MaybeUnusedExternCrates => { force!(maybe_unused_extern_crates, LOCAL_CRATE); }\n+        DepKind::StabilityIndex => { force!(stability_index, LOCAL_CRATE); }\n+        DepKind::AllCrateNums => { force!(all_crate_nums, LOCAL_CRATE); }\n+        DepKind::ExportedSymbols => { force!(exported_symbols, krate!()); }\n+        DepKind::CollectAndPartitionTranslationItems => {\n+            force!(collect_and_partition_translation_items, LOCAL_CRATE);\n+        }\n+        DepKind::ExportName => { force!(export_name, def_id!()); }\n+        DepKind::ContainsExternIndicator => {\n+            force!(contains_extern_indicator, def_id!());\n+        }\n+        DepKind::IsTranslatedFunction => { force!(is_translated_function, def_id!()); }\n+        DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n+    }\n+\n+    true\n+}\n+"}, {"sha": "322f46cf02b6332b6877c29617eae386875fd858", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -13,15 +13,15 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::Mir;\n use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource,\n                             MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::ty::steal::Steal;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::DefIdSet;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use transform;\n \n pub mod add_validation;\n@@ -114,11 +114,10 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     let source = MirSource::from_local_def_id(tcx, def_id);\n     if let MirSource::Const(_) = source {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n-        // this point, before we steal the mir-const result. We don't\n-        // directly need the result or `mir_const_qualif`, so we can just force it.\n-        ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n+        // this point, before we steal the mir-const result.\n+        let _ = tcx.mir_const_qualif(def_id);\n     }\n-    ty::queries::unsafety_violations::force(tcx, DUMMY_SP, def_id);\n+    let _ = tcx.unsafety_violations(def_id);\n \n     let mut mir = tcx.mir_const(def_id).steal();\n     transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n@@ -128,8 +127,8 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n     // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n-    ty::queries::mir_borrowck::force(tcx, DUMMY_SP, def_id);\n-    ty::queries::borrowck::force(tcx, DUMMY_SP, def_id);\n+    let _ = tcx.mir_borrowck(def_id);\n+    let _ = tcx.borrowck(def_id);\n \n     let mut mir = tcx.mir_validated(def_id).steal();\n     let source = MirSource::from_local_def_id(tcx, def_id);"}, {"sha": "56b20047808ccd05c86fb4912b707bcbc51d658d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f0bbf4e1f25fb9f1882bbf0e4c92395f38474fb5", "patch": "@@ -947,6 +947,19 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         shared_ccx.tcx().collect_and_partition_translation_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n+    // Force all codegen_unit queries so they are already either red or green\n+    // when compile_codegen_unit accesses them. We are not able to re-execute\n+    // the codegen_unit query from just the DepNode, so an unknown color would\n+    // lead to having to re-execute compile_codegen_unit, possibly\n+    // unnecessarily.\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &codegen_units {\n+            tcx.codegen_unit(cgu.name().clone());\n+        }\n+    }\n+\n+    assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n+\n     let ongoing_translation = write::start_async_translation(\n         tcx,\n         time_graph.clone(),"}]}