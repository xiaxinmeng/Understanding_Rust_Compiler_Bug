{"sha": "a4dbcb525b2f36f66c89df6919a7506cd99041cc", "node_id": "C_kwDOAAsO6NoAKGE0ZGJjYjUyNWIyZjM2ZjY2Yzg5ZGY2OTE5YTc1MDZjZDk5MDQxY2M", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-01-11T20:41:13Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-01-11T23:25:45Z"}, "message": "Expand format_args!() in rust_ast_lowering.", "tree": {"sha": "16d2087b2a8daef1d705c168e05db854902149aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16d2087b2a8daef1d705c168e05db854902149aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4dbcb525b2f36f66c89df6919a7506cd99041cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4dbcb525b2f36f66c89df6919a7506cd99041cc", "html_url": "https://github.com/rust-lang/rust/commit/a4dbcb525b2f36f66c89df6919a7506cd99041cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4dbcb525b2f36f66c89df6919a7506cd99041cc/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e83945150f65eaf8b644a4042229fcac4c82596b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e83945150f65eaf8b644a4042229fcac4c82596b", "html_url": "https://github.com/rust-lang/rust/commit/e83945150f65eaf8b644a4042229fcac4c82596b"}], "stats": {"total": 919, "additions": 535, "deletions": 384}, "files": [{"sha": "faf4fd05c354ffe4a81c79eedab53eb442001546", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -3699,6 +3699,7 @@ name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n+ \"rustc_parse_format\",\n  \"rustc_span\",\n ]\n "}, {"sha": "5b1722dffb90eebde66d67178888691751092aa4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -18,6 +18,7 @@\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n \n+pub use crate::format::*;\n pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n@@ -1269,6 +1270,7 @@ impl Expr {\n             ExprKind::Try(..) => ExprPrecedence::Try,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n             ExprKind::Yeet(..) => ExprPrecedence::Yeet,\n+            ExprKind::FormatArgs(..) => ExprPrecedence::FormatArgs,\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n@@ -1498,6 +1500,9 @@ pub enum ExprKind {\n     /// with a `ByteStr` literal.\n     IncludedBytes(Lrc<[u8]>),\n \n+    /// A `format_args!()` expression.\n+    FormatArgs(P<FormatArgs>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }"}, {"sha": "ce99c2b58b5703da19c733c4fb28212a0f280275", "filename": "compiler/rustc_ast/src/format.rs", "status": "renamed", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -1,5 +1,5 @@\n-use rustc_ast::ptr::P;\n-use rustc_ast::Expr;\n+use crate::ptr::P;\n+use crate::Expr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -39,7 +39,7 @@ use rustc_span::Span;\n /// Basically the \"AST\" for a complete `format_args!()`.\n ///\n /// E.g., `format_args!(\"hello {name}\");`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgs {\n     pub span: Span,\n     pub template: Vec<FormatArgsPiece>,\n@@ -49,7 +49,7 @@ pub struct FormatArgs {\n /// A piece of a format template string.\n ///\n /// E.g. \"hello\" or \"{name}\".\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgsPiece {\n     Literal(Symbol),\n     Placeholder(FormatPlaceholder),\n@@ -59,7 +59,7 @@ pub enum FormatArgsPiece {\n ///\n /// E.g. `1, 2, name=\"ferris\", n=3`,\n /// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArguments {\n     arguments: Vec<FormatArgument>,\n     num_unnamed_args: usize,\n@@ -121,18 +121,22 @@ impl FormatArguments {\n         &self.arguments[..self.num_explicit_args]\n     }\n \n-    pub fn into_vec(self) -> Vec<FormatArgument> {\n-        self.arguments\n+    pub fn all_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..]\n+    }\n+\n+    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n+        &mut self.arguments[..]\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgument {\n     pub kind: FormatArgumentKind,\n     pub expr: P<Expr>,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgumentKind {\n     /// `format_args(\u2026, arg)`\n     Normal,\n@@ -152,7 +156,7 @@ impl FormatArgumentKind {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatPlaceholder {\n     /// Index into [`FormatArgs::arguments`].\n     pub argument: FormatArgPosition,\n@@ -164,7 +168,7 @@ pub struct FormatPlaceholder {\n     pub format_options: FormatOptions,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatArgPosition {\n     /// Which argument this position refers to (Ok),\n     /// or would've referred to if it existed (Err).\n@@ -175,7 +179,7 @@ pub struct FormatArgPosition {\n     pub span: Option<Span>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatArgPositionKind {\n     /// `{}` or `{:.*}`\n     Implicit,\n@@ -185,7 +189,7 @@ pub enum FormatArgPositionKind {\n     Named,\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq, Hash)]\n pub enum FormatTrait {\n     /// `{}`\n     Display,\n@@ -207,7 +211,7 @@ pub enum FormatTrait {\n     UpperHex,\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Default, Debug, PartialEq, Eq)]\n pub struct FormatOptions {\n     /// The width. E.g. `{:5}` or `{:width$}`.\n     pub width: Option<FormatCount>,\n@@ -221,7 +225,7 @@ pub struct FormatOptions {\n     pub flags: u32,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatAlignment {\n     /// `{:<}`\n     Left,\n@@ -231,7 +235,7 @@ pub enum FormatAlignment {\n     Center,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatCount {\n     /// `{:5}` or `{:.5}`\n     Literal(usize),", "previous_filename": "compiler/rustc_builtin_macros/src/format/ast.rs"}, {"sha": "0f8ebcfdc150844ad4d72751ac8619161bfbbed0", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -42,6 +42,7 @@ pub mod ast_traits;\n pub mod attr;\n pub mod entry;\n pub mod expand;\n+pub mod format;\n pub mod mut_visit;\n pub mod node_id;\n pub mod ptr;\n@@ -51,6 +52,7 @@ pub mod visit;\n \n pub use self::ast::*;\n pub use self::ast_traits::{AstDeref, AstNodeWrapper, HasAttrs, HasNodeId, HasSpan, HasTokens};\n+pub use self::format::*;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "561274cc6f91941b60eb32032afb8f596bf18902", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -297,6 +297,10 @@ pub trait MutVisitor: Sized {\n     fn visit_inline_asm_sym(&mut self, sym: &mut InlineAsmSym) {\n         noop_visit_inline_asm_sym(sym, self)\n     }\n+\n+    fn visit_format_args(&mut self, fmt: &mut FormatArgs) {\n+        noop_visit_format_args(fmt, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -1284,6 +1288,15 @@ pub fn noop_visit_inline_asm_sym<T: MutVisitor>(\n     vis.visit_path(path);\n }\n \n+pub fn noop_visit_format_args<T: MutVisitor>(fmt: &mut FormatArgs, vis: &mut T) {\n+    for arg in fmt.arguments.all_args_mut() {\n+        if let FormatArgumentKind::Named(name) = &mut arg.kind {\n+            vis.visit_ident(name);\n+        }\n+        vis.visit_expr(&mut arg.expr);\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1423,6 +1436,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(fmt) => vis.visit_format_args(fmt),\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "2db2ab5e811570693682001322507435ffe48c2b", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -271,6 +271,7 @@ pub enum ExprPrecedence {\n     Try,\n     InlineAsm,\n     Mac,\n+    FormatArgs,\n \n     Array,\n     Repeat,\n@@ -335,7 +336,8 @@ impl ExprPrecedence {\n             | ExprPrecedence::Index\n             | ExprPrecedence::Try\n             | ExprPrecedence::InlineAsm\n-            | ExprPrecedence::Mac => PREC_POSTFIX,\n+            | ExprPrecedence::Mac\n+            | ExprPrecedence::FormatArgs => PREC_POSTFIX,\n \n             // Never need parens\n             ExprPrecedence::Array"}, {"sha": "cb5c17084ec2aaf64ad5813468e3a2a787c0c2a1", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -242,6 +242,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_inline_asm(&mut self, asm: &'ast InlineAsm) {\n         walk_inline_asm(self, asm)\n     }\n+    fn visit_format_args(&mut self, fmt: &'ast FormatArgs) {\n+        walk_format_args(self, fmt)\n+    }\n     fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n         walk_inline_asm_sym(self, sym)\n     }\n@@ -756,6 +759,15 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n     visitor.visit_path(&sym.path, sym.id);\n }\n \n+pub fn walk_format_args<'a, V: Visitor<'a>>(visitor: &mut V, fmt: &'a FormatArgs) {\n+    for arg in fmt.arguments.all_args() {\n+        if let FormatArgumentKind::Named(name) = arg.kind {\n+            visitor.visit_ident(name);\n+        }\n+        visitor.visit_expr(&arg.expr);\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n@@ -895,6 +907,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(f) => visitor.visit_format_args(f),\n         ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }"}, {"sha": "5e0f1b9b61ffc56ff7f573f4bd76fc903be6956a", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -292,6 +292,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n+                ExprKind::FormatArgs(fmt) => self.lower_format_args(e.span, fmt),\n                 ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),"}, {"sha": "f8ed164b356f1de659951705d9669b948dd49205", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -0,0 +1,356 @@\n+use super::LoweringContext;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir as hir;\n+use rustc_span::{\n+    sym,\n+    symbol::{kw, Ident},\n+    Span,\n+};\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n+        expand_format_args(self, sp, fmt)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+fn make_argument<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    arg: &'hir hir::Expr<'hir>,\n+    ty: ArgumentType,\n+) -> hir::Expr<'hir> {\n+    // Generate:\n+    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    let new_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatArgument,\n+        match ty {\n+            Format(Display) => sym::new_display,\n+            Format(Debug) => sym::new_debug,\n+            Format(LowerExp) => sym::new_lower_exp,\n+            Format(UpperExp) => sym::new_upper_exp,\n+            Format(Octal) => sym::new_octal,\n+            Format(Pointer) => sym::new_pointer,\n+            Format(Binary) => sym::new_binary,\n+            Format(LowerHex) => sym::new_lower_hex,\n+            Format(UpperHex) => sym::new_upper_hex,\n+            Usize => sym::from_usize,\n+        },\n+    ));\n+    ctx.expr_call_mut(sp, new_fn, std::slice::from_ref(arg))\n+}\n+\n+fn make_count<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n+    match count {\n+        Some(FormatCount::Literal(n)) => {\n+            let count_is = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                sp,\n+                hir::LangItem::FormatCount,\n+                sym::Is,\n+            ));\n+            let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, *n)]);\n+            ctx.expr_call_mut(sp, count_is, value)\n+        }\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                    sp,\n+                    hir::LangItem::FormatCount,\n+                    sym::Param,\n+                ));\n+                let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n+                ctx.expr_call_mut(sp, count_param, value)\n+            } else {\n+                ctx.expr(sp, hir::ExprKind::Err)\n+            }\n+        }\n+        None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n+    }\n+}\n+\n+fn make_format_spec<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Argument {\n+    //         position: 0usize,\n+    //         format: ::core::fmt::rt::v1::FormatSpec {\n+    //             fill: ' ',\n+    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n+    //             flags: 0u32,\n+    //             precision: ::core::fmt::rt::v1::Count::Implied,\n+    //             width: ::core::fmt::rt::v1::Count::Implied,\n+    //         },\n+    //     }\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) =\n+                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            ctx.expr_usize(sp, i)\n+        }\n+        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+    };\n+    let fill = ctx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n+    let align = ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatAlignment,\n+        match placeholder.format_options.alignment {\n+            Some(FormatAlignment::Left) => sym::Left,\n+            Some(FormatAlignment::Right) => sym::Right,\n+            Some(FormatAlignment::Center) => sym::Center,\n+            None => sym::Unknown,\n+        },\n+    );\n+    let flags = ctx.expr_u32(sp, placeholder.format_options.flags);\n+    let prec = make_count(ctx, sp, &placeholder.format_options.precision, argmap);\n+    let width = make_count(ctx, sp, &placeholder.format_options.width, argmap);\n+    let format_placeholder_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatPlaceholder,\n+        sym::new,\n+    ));\n+    let args = ctx.arena.alloc_from_iter([position, fill, align, flags, prec, width]);\n+    ctx.expr_call_mut(sp, format_placeholder_new, args)\n+}\n+\n+fn expand_format_args<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    macsp: Span,\n+    fmt: &FormatArgs,\n+) -> hir::ExprKind<'hir> {\n+    let lit_pieces =\n+        ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n+            match piece {\n+                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ctx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        }));\n+    let lit_pieces = ctx.expr_array_ref(fmt.span, lit_pieces);\n+\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n+\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexSet::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        let elements: Vec<_> = fmt\n+            .template\n+            .iter()\n+            .filter_map(|piece| {\n+                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                Some(make_format_spec(ctx, macsp, placeholder, &mut argmap))\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    });\n+\n+    let arguments = fmt.arguments.all_args();\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    let use_simple_array = argmap.len() == arguments.len()\n+        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n+\n+    let args = if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n+        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n+        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n+        //     ]\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .zip(argmap)\n+            .map(|(arg, (_, ty))| {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let arg = ctx.lower_expr(&arg.expr);\n+                let ref_arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n+                ));\n+                make_argument(ctx, sp, ref_arg, ty)\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    } else {\n+        // Generate:\n+        //     &match (&arg0, &arg1, &arg2) {\n+        //         args => [\n+        //             ::core::fmt::ArgumentV1::new_display(args.0),\n+        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n+        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n+            if let Some(arg) = arguments.get(arg_index) {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, sp, arg, ty)\n+            } else {\n+                ctx.expr(macsp, hir::ExprKind::Err)\n+            }\n+        }));\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .map(|arg| {\n+                let arg_expr = ctx.lower_expr(&arg.expr);\n+                ctx.expr(\n+                    arg.expr.span.with_ctxt(macsp.ctxt()),\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg_expr),\n+                )\n+            })\n+            .collect();\n+        let args_tuple = ctx\n+            .arena\n+            .alloc(ctx.expr(macsp, hir::ExprKind::Tup(ctx.arena.alloc_from_iter(elements))));\n+        let array = ctx.arena.alloc(ctx.expr(macsp, hir::ExprKind::Array(args)));\n+        let match_arms = ctx.arena.alloc_from_iter([ctx.arm(args_pat, array)]);\n+        let match_expr = ctx.arena.alloc(ctx.expr_match(\n+            macsp,\n+            args_tuple,\n+            match_arms,\n+            hir::MatchSource::FormatArgs,\n+        ));\n+        ctx.expr(\n+            macsp,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, match_expr),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        let new_v1_formatted = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1_formatted,\n+        ));\n+        let unsafe_arg_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatUnsafeArg,\n+            sym::new,\n+        ));\n+        let unsafe_arg_new_call = ctx.expr_call(macsp, unsafe_arg_new, &[]);\n+        let hir_id = ctx.next_id();\n+        let unsafe_arg = ctx.expr_block(ctx.arena.alloc(hir::Block {\n+            stmts: &[],\n+            expr: Some(unsafe_arg_new_call),\n+            hir_id,\n+            rules: hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::CompilerGenerated),\n+            span: macsp,\n+            targeted_by_break: false,\n+        }));\n+        let args = ctx.arena.alloc_from_iter([lit_pieces, args, format_options, unsafe_arg]);\n+        hir::ExprKind::Call(new_v1_formatted, args)\n+    } else {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        let new_v1 = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces, args]);\n+        hir::ExprKind::Call(new_v1, new_args)\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            self.0 = true;\n+        }\n+\n+        fn visit_attribute(&mut self, _: &ast::Attribute) {\n+            // Conservatively assume this may be a proc macro attribute in\n+            // expression position.\n+            self.0 = true;\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "01aba94fe39f4101ba4f97603312d33eeb90bcbd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -80,6 +80,7 @@ mod asm;\n mod block;\n mod errors;\n mod expr;\n+mod format;\n mod index;\n mod item;\n mod lifetime_collector;"}, {"sha": "b4900dc39a8af4d98913c75f26146923df617714", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -6,5 +6,6 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_parse_format = { path = \"../rustc_parse_format\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "03beae3a45bb113e32674c5d6ad6388b5399af97", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -6,6 +6,8 @@ use rustc_ast::token;\n use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode};\n+use rustc_ast::{FormatAlignment, FormatArgPosition, FormatArgsPiece, FormatCount, FormatTrait};\n+use std::fmt::Write;\n \n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n@@ -528,6 +530,18 @@ impl<'a> State<'a> {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n+            ast::ExprKind::FormatArgs(fmt) => {\n+                self.word(\"format_args!\");\n+                self.popen();\n+                self.rbox(0, Inconsistent);\n+                self.word(reconstruct_format_args_template_string(&fmt.template));\n+                for arg in fmt.arguments.all_args() {\n+                    self.word_space(\",\");\n+                    self.print_expr(&arg.expr);\n+                }\n+                self.end();\n+                self.pclose();\n+            }\n             ast::ExprKind::MacCall(m) => self.print_mac(m),\n             ast::ExprKind::Paren(e) => {\n                 self.popen();\n@@ -627,3 +641,91 @@ impl<'a> State<'a> {\n         }\n     }\n }\n+\n+pub fn reconstruct_format_args_template_string(pieces: &[FormatArgsPiece]) -> String {\n+    let mut template = \"\\\"\".to_string();\n+    for piece in pieces {\n+        match piece {\n+            FormatArgsPiece::Literal(s) => {\n+                for c in s.as_str().escape_debug() {\n+                    template.push(c);\n+                    if let '{' | '}' = c {\n+                        template.push(c);\n+                    }\n+                }\n+            }\n+            FormatArgsPiece::Placeholder(p) => {\n+                template.push('{');\n+                let (Ok(n) | Err(n)) = p.argument.index;\n+                write!(template, \"{n}\").unwrap();\n+                if p.format_options != Default::default() || p.format_trait != FormatTrait::Display\n+                {\n+                    template.push_str(\":\");\n+                }\n+                if let Some(fill) = p.format_options.fill {\n+                    template.push(fill);\n+                }\n+                match p.format_options.alignment {\n+                    Some(FormatAlignment::Left) => template.push_str(\"<\"),\n+                    Some(FormatAlignment::Right) => template.push_str(\">\"),\n+                    Some(FormatAlignment::Center) => template.push_str(\"^\"),\n+                    None => {}\n+                }\n+                let flags = p.format_options.flags;\n+                if flags >> (rustc_parse_format::FlagSignPlus as usize) & 1 != 0 {\n+                    template.push('+');\n+                }\n+                if flags >> (rustc_parse_format::FlagSignMinus as usize) & 1 != 0 {\n+                    template.push('-');\n+                }\n+                if flags >> (rustc_parse_format::FlagAlternate as usize) & 1 != 0 {\n+                    template.push('#');\n+                }\n+                if flags >> (rustc_parse_format::FlagSignAwareZeroPad as usize) & 1 != 0 {\n+                    template.push('0');\n+                }\n+                if let Some(width) = &p.format_options.width {\n+                    match width {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                if let Some(precision) = &p.format_options.precision {\n+                    template.push('.');\n+                    match precision {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                if flags >> (rustc_parse_format::FlagDebugLowerHex as usize) & 1 != 0 {\n+                    template.push('X');\n+                }\n+                if flags >> (rustc_parse_format::FlagDebugUpperHex as usize) & 1 != 0 {\n+                    template.push('x');\n+                }\n+                template.push_str(match p.format_trait {\n+                    FormatTrait::Display => \"\",\n+                    FormatTrait::Debug => \"?\",\n+                    FormatTrait::LowerExp => \"e\",\n+                    FormatTrait::UpperExp => \"E\",\n+                    FormatTrait::Octal => \"o\",\n+                    FormatTrait::Pointer => \"p\",\n+                    FormatTrait::Binary => \"b\",\n+                    FormatTrait::LowerHex => \"x\",\n+                    FormatTrait::UpperHex => \"X\",\n+                });\n+                template.push('}');\n+            }\n+        }\n+    }\n+    template.push('\"');\n+    template\n+}"}, {"sha": "342b1735661df9acd779fdf54fc6f7fc6154174c", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -297,6 +297,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Continue(_)\n             | ExprKind::Err\n             | ExprKind::Field(_, _)\n+            | ExprKind::FormatArgs(_)\n             | ExprKind::ForLoop(_, _, _, _)\n             | ExprKind::If(_, _, _)\n             | ExprKind::IncludedBytes(..)"}, {"sha": "47b63a7fa122fcd3f0f376f51233f75387a07b78", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -1,7 +1,11 @@\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::Expr;\n+use rustc_ast::{\n+    Expr, ExprKind, FormatAlignment, FormatArgPosition, FormatArgPositionKind, FormatArgs,\n+    FormatArgsPiece, FormatArgument, FormatArgumentKind, FormatArguments, FormatCount,\n+    FormatOptions, FormatPlaceholder, FormatTrait,\n+};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n@@ -12,12 +16,6 @@ use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n \n-mod ast;\n-use ast::*;\n-\n-mod expand;\n-use expand::expand_parsed_format_args;\n-\n // The format_args!() macro is expanded in three steps:\n //  1. First, `parse_args` will parse the `(literal, arg, arg, name=arg, name=arg)` syntax,\n //     but doesn't parse the template (the literal) itself.\n@@ -850,7 +848,7 @@ fn expand_format_args_impl<'cx>(\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args)) => {\n             if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n-                MacEager::expr(expand_parsed_format_args(ecx, format_args))\n+                MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))\n             }"}, {"sha": "9dde5efcb28b7611c514e8517fc0d769fcb4d126", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/e83945150f65eaf8b644a4042229fcac4c82596b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83945150f65eaf8b644a4042229fcac4c82596b/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=e83945150f65eaf8b644a4042229fcac4c82596b", "patch": "@@ -1,353 +0,0 @@\n-use super::*;\n-use rustc_ast as ast;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{BlockCheckMode, UnsafeSource};\n-use rustc_data_structures::fx::FxIndexSet;\n-use rustc_span::{sym, symbol::kw};\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-enum ArgumentType {\n-    Format(FormatTrait),\n-    Usize,\n-}\n-\n-fn make_argument(ecx: &ExtCtxt<'_>, sp: Span, arg: P<ast::Expr>, ty: ArgumentType) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n-    use ArgumentType::*;\n-    use FormatTrait::*;\n-    ecx.expr_call_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::ArgumentV1,\n-            match ty {\n-                Format(Display) => sym::new_display,\n-                Format(Debug) => sym::new_debug,\n-                Format(LowerExp) => sym::new_lower_exp,\n-                Format(UpperExp) => sym::new_upper_exp,\n-                Format(Octal) => sym::new_octal,\n-                Format(Pointer) => sym::new_pointer,\n-                Format(Binary) => sym::new_binary,\n-                Format(LowerHex) => sym::new_lower_hex,\n-                Format(UpperHex) => sym::new_upper_hex,\n-                Usize => sym::from_usize,\n-            },\n-        ]),\n-        vec![arg],\n-    )\n-}\n-\n-fn make_count(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n-    match count {\n-        Some(FormatCount::Literal(n)) => ecx.expr_call_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Is]),\n-            vec![ecx.expr_usize(sp, *n)],\n-        ),\n-        Some(FormatCount::Argument(arg)) => {\n-            if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n-                ecx.expr_call_global(\n-                    sp,\n-                    ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Param]),\n-                    vec![ecx.expr_usize(sp, i)],\n-                )\n-            } else {\n-                DummyResult::raw_expr(sp, true)\n-            }\n-        }\n-        None => ecx.expr_path(ecx.path_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Implied]),\n-        )),\n-    }\n-}\n-\n-fn make_format_spec(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Argument {\n-    //         position: 0usize,\n-    //         format: ::core::fmt::rt::v1::FormatSpec {\n-    //             fill: ' ',\n-    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n-    //             flags: 0u32,\n-    //             precision: ::core::fmt::rt::v1::Count::Implied,\n-    //             width: ::core::fmt::rt::v1::Count::Implied,\n-    //         },\n-    //     }\n-    let position = match placeholder.argument.index {\n-        Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n-            ecx.expr_usize(sp, i)\n-        }\n-        Err(_) => DummyResult::raw_expr(sp, true),\n-    };\n-    let fill = ecx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n-    let align = ecx.expr_path(ecx.path_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::rt,\n-            sym::v1,\n-            sym::Alignment,\n-            match placeholder.format_options.alignment {\n-                Some(FormatAlignment::Left) => sym::Left,\n-                Some(FormatAlignment::Right) => sym::Right,\n-                Some(FormatAlignment::Center) => sym::Center,\n-                None => sym::Unknown,\n-            },\n-        ]),\n-    ));\n-    let flags = ecx.expr_u32(sp, placeholder.format_options.flags);\n-    let prec = make_count(ecx, sp, &placeholder.format_options.precision, argmap);\n-    let width = make_count(ecx, sp, &placeholder.format_options.width, argmap);\n-    ecx.expr_struct(\n-        sp,\n-        ecx.path_global(sp, ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Argument])),\n-        vec![\n-            ecx.field_imm(sp, Ident::new(sym::position, sp), position),\n-            ecx.field_imm(\n-                sp,\n-                Ident::new(sym::format, sp),\n-                ecx.expr_struct(\n-                    sp,\n-                    ecx.path_global(\n-                        sp,\n-                        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::FormatSpec]),\n-                    ),\n-                    vec![\n-                        ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n-                        ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n-                        ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n-                        ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n-                        ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n-                    ],\n-                ),\n-            ),\n-        ],\n-    )\n-}\n-\n-pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<ast::Expr> {\n-    let macsp = ecx.with_def_site_ctxt(ecx.call_site());\n-\n-    let lit_pieces = ecx.expr_array_ref(\n-        fmt.span,\n-        fmt.template\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(i, piece)| match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ecx.expr_str(fmt.span, s)),\n-                &FormatArgsPiece::Placeholder(_) => {\n-                    // Inject empty string before placeholders when not already preceded by a literal piece.\n-                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n-                        Some(ecx.expr_str(fmt.span, kw::Empty))\n-                    } else {\n-                        None\n-                    }\n-                }\n-            })\n-            .collect(),\n-    );\n-\n-    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n-    // or the `Arguments::new_v1` form (false).\n-    let mut use_format_options = false;\n-\n-    // Create a list of all _unique_ (argument, format trait) combinations.\n-    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n-    for piece in &fmt.template {\n-        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n-        if placeholder.format_options != Default::default() {\n-            // Can't use basic form if there's any formatting options.\n-            use_format_options = true;\n-        }\n-        if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n-                // Duplicate (argument, format trait) combination,\n-                // which we'll only put once in the args array.\n-                use_format_options = true;\n-            }\n-        }\n-    }\n-\n-    let format_options = use_format_options.then(|| {\n-        // Generate:\n-        //     &[format_spec_0, format_spec_1, format_spec_2]\n-        ecx.expr_array_ref(\n-            macsp,\n-            fmt.template\n-                .iter()\n-                .filter_map(|piece| {\n-                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n-                    Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n-                })\n-                .collect(),\n-        )\n-    });\n-\n-    let arguments = fmt.arguments.into_vec();\n-\n-    // If the args array contains exactly all the original arguments once,\n-    // in order, we can use a simple array instead of a `match` construction.\n-    // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n-    let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n-        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n-\n-    let args = if use_simple_array {\n-        // Generate:\n-        //     &[\n-        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n-        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n-        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n-        //     ]\n-        ecx.expr_array_ref(\n-            macsp,\n-            arguments\n-                .into_iter()\n-                .zip(argmap)\n-                .map(|(arg, (_, ty))| {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg.expr), ty)\n-                })\n-                .collect(),\n-        )\n-    } else {\n-        // Generate:\n-        //     match (&arg0, &arg1, &arg2) {\n-        //         args => &[\n-        //             ::core::fmt::ArgumentV1::new_display(args.0),\n-        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n-        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n-        //         ]\n-        //     }\n-        let args_ident = Ident::new(sym::args, macsp);\n-        let args = argmap\n-            .iter()\n-            .map(|&(arg_index, ty)| {\n-                if let Some(arg) = arguments.get(arg_index) {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(\n-                        ecx,\n-                        sp,\n-                        ecx.expr_field(\n-                            sp,\n-                            ecx.expr_ident(macsp, args_ident),\n-                            Ident::new(sym::integer(arg_index), macsp),\n-                        ),\n-                        ty,\n-                    )\n-                } else {\n-                    DummyResult::raw_expr(macsp, true)\n-                }\n-            })\n-            .collect();\n-        ecx.expr_addr_of(\n-            macsp,\n-            ecx.expr_match(\n-                macsp,\n-                ecx.expr_tuple(\n-                    macsp,\n-                    arguments\n-                        .into_iter()\n-                        .map(|arg| {\n-                            ecx.expr_addr_of(arg.expr.span.with_ctxt(macsp.ctxt()), arg.expr)\n-                        })\n-                        .collect(),\n-                ),\n-                vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],\n-            ),\n-        )\n-    };\n-\n-    if let Some(format_options) = format_options {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1_formatted(\n-        //         lit_pieces,\n-        //         args,\n-        //         format_options,\n-        //         unsafe { ::core::fmt::UnsafeArg::new() }\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n-            vec![\n-                lit_pieces,\n-                args,\n-                format_options,\n-                ecx.expr_block(P(ast::Block {\n-                    stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n-                        macsp,\n-                        ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]),\n-                        Vec::new(),\n-                    ))],\n-                    id: ast::DUMMY_NODE_ID,\n-                    rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-                    span: macsp,\n-                    tokens: None,\n-                    could_be_bare_literal: false,\n-                })),\n-            ],\n-        )\n-    } else {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1(\n-        //         lit_pieces,\n-        //         args,\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n-            vec![lit_pieces, args],\n-        )\n-    }\n-}\n-\n-fn may_contain_yield_point(e: &ast::Expr) -> bool {\n-    struct MayContainYieldPoint(bool);\n-\n-    impl Visitor<'_> for MayContainYieldPoint {\n-        fn visit_expr(&mut self, e: &ast::Expr) {\n-            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n-                self.0 = true;\n-            } else {\n-                visit::walk_expr(self, e);\n-            }\n-        }\n-\n-        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n-            self.0 = true;\n-        }\n-\n-        fn visit_attribute(&mut self, _: &ast::Attribute) {\n-            // Conservatively assume this may be a proc macro attribute in\n-            // expression position.\n-            self.0 = true;\n-        }\n-\n-        fn visit_item(&mut self, _: &ast::Item) {\n-            // Do not recurse into nested items.\n-        }\n-    }\n-\n-    let mut visitor = MayContainYieldPoint(false);\n-    visitor.visit_expr(e);\n-    visitor.0\n-}"}, {"sha": "c827600179def37638459474156d91c66654e043", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -2108,6 +2108,8 @@ pub enum MatchSource {\n     TryDesugar,\n     /// A desugared `<expr>.await`.\n     AwaitDesugar,\n+    /// A desugared `format_args!()`.\n+    FormatArgs,\n }\n \n impl MatchSource {\n@@ -2119,6 +2121,7 @@ impl MatchSource {\n             ForLoopDesugar => \"for\",\n             TryDesugar => \"?\",\n             AwaitDesugar => \".await\",\n+            FormatArgs => \"format_args!()\",\n         }\n     }\n }"}, {"sha": "2b52c410ecd2aad2eddc5133ca11fdb4c2bff89a", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -208,9 +208,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n             // when the iterator is an uninhabited type. unreachable_code will trigger instead.\n             hir::MatchSource::ForLoopDesugar if arms.len() == 1 => {}\n-            hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                report_arm_reachability(&cx, &report)\n-            }\n+            hir::MatchSource::ForLoopDesugar\n+            | hir::MatchSource::Normal\n+            | hir::MatchSource::FormatArgs => report_arm_reachability(&cx, &report),\n             // Unreachable patterns in try and await expressions occur when one of\n             // the arms are an uninhabited type. Which is OK.\n             hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}"}, {"sha": "dd8c646a43c82e837b0393155f7660931147e0d1", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -48,7 +48,7 @@ impl NonConstExpr {\n             Self::Match(TryDesugar) => &[sym::const_try],\n \n             // All other expressions are allowed.\n-            Self::Loop(Loop | While) | Self::Match(Normal) => &[],\n+            Self::Loop(Loop | While) | Self::Match(Normal | FormatArgs) => &[],\n         };\n \n         Some(gates)"}, {"sha": "d1b896e940e6e7d6f054b22c2ac7bc0f98e8b592", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4dbcb525b2f36f66c89df6919a7506cd99041cc/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=a4dbcb525b2f36f66c89df6919a7506cd99041cc", "patch": "@@ -567,7 +567,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n                 Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n                 If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n                 AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n-                InlineAsm, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err\n+                InlineAsm, FormatArgs, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err\n             ]\n         );\n         ast_visit::walk_expr(self, e)"}]}