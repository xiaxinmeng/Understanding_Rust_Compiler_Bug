{"sha": "9f82785c81c68d117617b6b45bce437649f94833", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODI3ODVjODFjNjhkMTE3NjE3YjZiNDViY2U0Mzc2NDlmOTQ4MzM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-16T04:43:06Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-22T20:26:39Z"}, "message": "Replace `rustc_data_structures::sync::Once` with `OnceCell`", "tree": {"sha": "45374c2f25487cfa0e2eba863614b5089de78fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45374c2f25487cfa0e2eba863614b5089de78fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f82785c81c68d117617b6b45bce437649f94833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f82785c81c68d117617b6b45bce437649f94833", "html_url": "https://github.com/rust-lang/rust/commit/9f82785c81c68d117617b6b45bce437649f94833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f82785c81c68d117617b6b45bce437649f94833/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "html_url": "https://github.com/rust-lang/rust/commit/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d"}], "stats": {"total": 136, "additions": 7, "deletions": 129}, "files": [{"sha": "ebcc11d2b26d64cfecc44610442f7aabe9877b3f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f82785c81c68d117617b6b45bce437649f94833/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9f82785c81c68d117617b6b45bce437649f94833/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9f82785c81c68d117617b6b45bce437649f94833", "patch": "@@ -3791,6 +3791,7 @@ dependencies = [\n  \"libc\",\n  \"log\",\n  \"measureme\",\n+ \"once_cell\",\n  \"parking_lot 0.10.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\","}, {"sha": "67721220526cac88f0f709213b15ccde4119968c", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f82785c81c68d117617b6b45bce437649f94833/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f82785c81c68d117617b6b45bce437649f94833/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=9f82785c81c68d117617b6b45bce437649f94833", "patch": "@@ -15,6 +15,7 @@ indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n+once_cell = { version = \"1\", features = [\"parking_lot\"] }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\""}, {"sha": "39afb3d82ff5aae9ef943718051b9709ff5229c5", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 4, "deletions": 129, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9f82785c81c68d117617b6b45bce437649f94833/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f82785c81c68d117617b6b45bce437649f94833/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=9f82785c81c68d117617b6b45bce437649f94833", "patch": "@@ -20,7 +20,6 @@\n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n-use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n \n pub use std::sync::atomic::Ordering;\n@@ -230,6 +229,8 @@ cfg_if! {\n         pub use std::cell::RefMut as LockGuard;\n         pub use std::cell::RefMut as MappedLockGuard;\n \n+        pub use once_cell::unsync::OnceCell;\n+\n         use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n \n@@ -313,6 +314,8 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n+        pub use once_cell::sync::OnceCell;\n+\n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n         pub use crossbeam_utils::atomic::AtomicCell;\n@@ -432,134 +435,6 @@ impl<K: Eq + Hash, V: Eq, S: BuildHasher> HashMapExt<K, V> for HashMap<K, V, S>\n     }\n }\n \n-/// A type whose inner value can be written once and then will stay read-only\n-// This contains a PhantomData<T> since this type conceptually owns a T outside the Mutex once\n-// initialized. This ensures that Once<T> is Sync only if T is. If we did not have PhantomData<T>\n-// we could send a &Once<Cell<bool>> to multiple threads and call `get` on it to get access\n-// to &Cell<bool> on those threads.\n-pub struct Once<T>(Lock<Option<T>>, PhantomData<T>);\n-\n-impl<T> Once<T> {\n-    /// Creates an Once value which is uninitialized\n-    #[inline(always)]\n-    pub fn new() -> Self {\n-        Once(Lock::new(None), PhantomData)\n-    }\n-\n-    /// Consumes the value and returns Some(T) if it was initialized\n-    #[inline(always)]\n-    pub fn into_inner(self) -> Option<T> {\n-        self.0.into_inner()\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set(&self, value: T) -> Option<T> {\n-        let mut lock = self.0.lock();\n-        if lock.is_some() {\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it asserts that `value` is equal to the inner\n-    /// value and then returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set_same(&self, value: T) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        let mut lock = self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            assert!(*inner == value);\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value` and panics if it was already initialized\n-    #[inline]\n-    pub fn set(&self, value: T) {\n-        assert!(self.try_set(value).is_none());\n-    }\n-\n-    /// Initializes the inner value if it wasn't already done by calling the provided closure. It\n-    /// ensures that no-one else can access the value in the mean time by holding a lock for the\n-    /// duration of the closure.\n-    /// A reference to the inner value is returned.\n-    #[inline]\n-    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> &T {\n-        {\n-            let mut lock = self.0.lock();\n-            if lock.is_none() {\n-                *lock = Some(f());\n-            }\n-        }\n-\n-        self.borrow()\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value,\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking<F: FnOnce() -> T>(&self, f: F) -> Option<T> {\n-        if self.0.lock().is_some() { None } else { self.try_set(f()) }\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value, we assert that it our closure computed\n-    /// a value equal to the value already set and then\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking_same<F: FnOnce() -> T>(&self, f: F) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        if self.0.lock().is_some() { None } else { self.try_set_same(f()) }\n-    }\n-\n-    /// Tries to get a reference to the inner value, returns `None` if it is not yet initialized\n-    #[inline(always)]\n-    pub fn try_get(&self) -> Option<&T> {\n-        let lock = &*self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            // This is safe since we won't mutate the inner value\n-            unsafe { Some(&*(inner as *const T)) }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn get(&self) -> &T {\n-        self.try_get().expect(\"value was not set\")\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn borrow(&self) -> &T {\n-        self.get()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct Lock<T>(InnerLock<T>);\n "}, {"sha": "61389028cc78c1d519f23e7d662b17640a952760", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f82785c81c68d117617b6b45bce437649f94833/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f82785c81c68d117617b6b45bce437649f94833/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=9f82785c81c68d117617b6b45bce437649f94833", "patch": "@@ -128,6 +128,7 @@ const WHITELIST: &[&str] = &[\n     \"miniz_oxide\",\n     \"nodrop\",\n     \"num_cpus\",\n+    \"once_cell\",\n     \"opaque-debug\",\n     \"parking_lot\",\n     \"parking_lot_core\","}]}