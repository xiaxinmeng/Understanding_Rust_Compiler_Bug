{"sha": "c14105bb8a9a36428a67ac508464b54259675f69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDEwNWJiOGE5YTM2NDI4YTY3YWM1MDg0NjRiNTQyNTk2NzVmNjk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-20T00:08:48Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-20T02:16:20Z"}, "message": "Remove serialize::traits submodule.", "tree": {"sha": "3b69b143aff8123c02b53eb67e271ed442e0610e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b69b143aff8123c02b53eb67e271ed442e0610e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14105bb8a9a36428a67ac508464b54259675f69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14105bb8a9a36428a67ac508464b54259675f69", "html_url": "https://github.com/rust-lang/rust/commit/c14105bb8a9a36428a67ac508464b54259675f69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14105bb8a9a36428a67ac508464b54259675f69/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "html_url": "https://github.com/rust-lang/rust/commit/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2"}], "stats": {"total": 617, "additions": 613, "deletions": 4}, "files": [{"sha": "08023f5371d5746a5b088534340fa37413b433c7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -25,7 +25,11 @@ use reader = std::ebml::reader;\n use std::ebml;\n use std::map::HashMap;\n use std::map;\n+#[cfg(stage0)]\n use std::serialize::traits::Decodable;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+use std::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;"}, {"sha": "9e23276c8a437e8f388f2293fd04786381953bb7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -29,7 +29,11 @@ use std::ebml;\n use std::map::HashMap;\n use std::serialize;\n use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers};\n+#[cfg(stage0)]\n use std::serialize::traits::Decodable;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+use std::serialize::Decodable;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;"}, {"sha": "59e0a1e84fe8fb444393be45be8529388402fff1", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -657,7 +657,7 @@ mod tests {\n             };\n             let ebml_doc = reader::Doc(@bytes);\n             let deser = reader::Decoder(ebml_doc);\n-            let v1 = serialize::traits::Decodable::decode(&deser);\n+            let v1 = serialize::Decodable::decode(&deser);\n             debug!(\"v1 == %?\", v1);\n             assert v == v1;\n         }"}, {"sha": "79ceab6241f3140a0f180fd0b56582922f6cefda", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -102,6 +102,7 @@ pub trait Decoder {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n+#[cfg(stage0)]\n pub mod traits {\n pub trait Encodable<S: Encoder> {\n     fn encode(&self, s: &S);\n@@ -583,4 +584,606 @@ pub impl<D: Decoder> D: DecoderHelpers {\n }\n }\n \n+#[cfg(stage0)]\n pub use serialize::traits::*;\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &S);\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub trait Decodable<D: Decoder> {\n+    static fn decode(&self, d: &D) -> self;\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> uint: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_uint(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> uint: Decodable<D> {\n+    static fn decode(&self, d: &D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> u8: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> u8: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> u16: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> u16: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> u32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> u32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> u64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> u64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> int: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> int: Decodable<D> {\n+    static fn decode(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> i8: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> i8: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> i16: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> i16: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> i32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> i32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> i64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_i64(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> i64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> &str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> ~str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> ~str: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> @str: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> @str: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> float: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_float(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> float: Decodable<D> {\n+    static fn decode(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> f32: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_f32(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> f32: Decodable<D> {\n+    static fn decode(&self, d: &D) -> f32 {\n+        d.read_f32() }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> f64: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_f64(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> f64: Decodable<D> {\n+    static fn decode(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> bool: Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_bool(*self) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> bool: Decodable<D> {\n+    static fn decode(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> (): Encodable<S> {\n+    fn encode(&self, s: &S) { s.emit_nil() }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> (): Decodable<D> {\n+    static fn decode(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> &T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).encode(s))\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> ~T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_owned(|| (**self).encode(s))\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder, T: Decodable<D>> ~T: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~Decodable::decode(d))\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> @T: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        s.emit_managed(|| (**self).encode(s))\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder, T: Decodable<D>> @T: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @T {\n+        d.read_managed(|| @Decodable::decode(d))\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> &[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> ~[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder, T: Decodable<D>> ~[T]: Decodable<D> {\n+    static fn decode(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || Decodable::decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> @[T]: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.encode(s))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder, T: Decodable<D>> @[T]: Decodable<D> {\n+    static fn decode(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || Decodable::decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder, T: Encodable<S>> Option<T>: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.encode(s))\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder, T: Decodable<D>> Option<T>: Decodable<D> {\n+    static fn decode(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(\n+                      0u, || Decodable::decode(d))),\n+                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>\n+> (T0, T1): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>\n+> (T0, T1): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || Decodable::decode(d)),\n+                d.read_tup_elt(1, || Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>\n+> (T0, T1, T2): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>\n+> (T0, T1, T2): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || Decodable::decode(d)),\n+                d.read_tup_elt(1, || Decodable::decode(d)),\n+                d.read_tup_elt(2, || Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>\n+> (T0, T1, T2, T3): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                    s.emit_tup_elt(3, || t3.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>\n+> (T0, T1, T2, T3): Decodable<D> {\n+    static fn decode(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || Decodable::decode(d)),\n+                d.read_tup_elt(1, || Decodable::decode(d)),\n+                d.read_tup_elt(2, || Decodable::decode(d)),\n+                d.read_tup_elt(3, || Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>,\n+    T4: Encodable<S>\n+> (T0, T1, T2, T3, T4): Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.encode(s));\n+                    s.emit_tup_elt(1, || t1.encode(s));\n+                    s.emit_tup_elt(2, || t2.encode(s));\n+                    s.emit_tup_elt(3, || t3.encode(s));\n+                    s.emit_tup_elt(4, || t4.encode(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>,\n+    T4: Decodable<D>\n+> (T0, T1, T2, T3, T4): Decodable<D> {\n+    static fn decode(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || Decodable::decode(d)),\n+                d.read_tup_elt(1, || Decodable::decode(d)),\n+                d.read_tup_elt(2, || Decodable::decode(d)),\n+                d.read_tup_elt(3, || Decodable::decode(d)),\n+                d.read_tup_elt(4, || Decodable::decode(d))\n+            )\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub trait EncoderHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<S: Encoder> S: EncoderHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub trait DecoderHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<D: Decoder> D: DecoderHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n+            }\n+        }\n+    }\n+}"}, {"sha": "8eb37386364f41cf24d1cb7c5a7eef649f02a636", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -818,7 +818,6 @@ fn mk_deser_fields(\n                     cx.expr_path(span, ~[\n                         cx.ident_of(~\"std\"),\n                         cx.ident_of(~\"serialize\"),\n-                        cx.ident_of(~\"traits\"),\n                         cx.ident_of(~\"Decodable\"),\n                         cx.ident_of(~\"decode\"),\n                     ]),\n@@ -1023,7 +1022,6 @@ fn mk_enum_deser_variant_nary(\n                 cx.expr_path(span, ~[\n                     cx.ident_of(~\"std\"),\n                     cx.ident_of(~\"serialize\"),\n-                    cx.ident_of(~\"traits\"),\n                     cx.ident_of(~\"Decodable\"),\n                     cx.ident_of(~\"decode\"),\n                 ]),"}, {"sha": "555171f9d5f30423167b78be0dff9ff25461e3a9", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14105bb8a9a36428a67ac508464b54259675f69/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14105bb8a9a36428a67ac508464b54259675f69/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=c14105bb8a9a36428a67ac508464b54259675f69", "patch": "@@ -22,7 +22,7 @@ use std::ebml;\n use EBReader = std::ebml::reader;\n use EBWriter = std::ebml::writer;\n use io::Writer;\n-use std::serialize::traits::{Encodable, Decodable};\n+use std::serialize::{Encodable, Decodable};\n use std::prettyprint;\n use std::time;\n "}]}