{"sha": "f70d139f9c2ceac9bb31e917c073a9643a0e6f8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MGQxMzlmOWMyY2VhYzliYjMxZTkxN2MwNzNhOTY0M2EwZTZmOGI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-20T15:58:47Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-20T15:58:47Z"}, "message": "Do not trim a block from expression if its condition will go multi-line", "tree": {"sha": "f5ad071e7821063a9bd7b3348d3eac382c599067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ad071e7821063a9bd7b3348d3eac382c599067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b", "html_url": "https://github.com/rust-lang/rust/commit/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec32c961d3bffd472a3473fd4c594f1845ad29e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec32c961d3bffd472a3473fd4c594f1845ad29e3", "html_url": "https://github.com/rust-lang/rust/commit/ec32c961d3bffd472a3473fd4c594f1845ad29e3"}], "stats": {"total": 27, "additions": 21, "deletions": 6}, "files": [{"sha": "a143c20f4bfecaa35defdc01b1c574f10c12de87", "filename": "src/matches.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70d139f9c2ceac9bb31e917c073a9643a0e6f8b/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=f70d139f9c2ceac9bb31e917c073a9643a0e6f8b", "patch": "@@ -19,7 +19,7 @@ use syntax::{ast, ptr};\n use comment::{combine_strs_with_missing_comments, rewrite_comment};\n use config::{Config, ControlBraceStyle, IndentStyle};\n use expr::{\n-    format_expr, is_empty_block, is_simple_block, is_unsafe_block, prefer_next_line,\n+    format_expr, is_empty_block, is_simple_block, is_unsafe_block, prefer_next_line, rewrite_cond,\n     rewrite_multiple_patterns, ExprType, RhsTactics,\n };\n use lists::{itemize_list, write_list, ListFormatting};\n@@ -231,7 +231,7 @@ fn rewrite_match_arm(\n ) -> Option<String> {\n     let (missing_span, attrs_str) = if !arm.attrs.is_empty() {\n         if contains_skip(&arm.attrs) {\n-            let (_, body) = flatten_arm_body(context, &arm.body);\n+            let (_, body) = flatten_arm_body(context, &arm.body, None);\n             // `arm.span()` does not include trailing comma, add it manually.\n             return Some(format!(\n                 \"{}{}\",\n@@ -313,16 +313,27 @@ fn block_can_be_flattened<'a>(\n // (extend, body)\n // @extend: true if the arm body can be put next to `=>`\n // @body: flattened body, if the body is block with a single expression\n-fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n+fn flatten_arm_body<'a>(\n+    context: &'a RewriteContext,\n+    body: &'a ast::Expr,\n+    opt_shape: Option<Shape>,\n+) -> (bool, &'a ast::Expr) {\n     let can_extend =\n         |expr| !context.config.force_multiline_blocks() && can_flatten_block_around_this(expr);\n \n     if let Some(ref block) = block_can_be_flattened(context, body) {\n         if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n             if let ast::ExprKind::Block(..) = expr.node {\n-                flatten_arm_body(context, expr)\n+                flatten_arm_body(context, expr, None)\n             } else {\n-                (can_extend(expr), &*expr)\n+                let cond_becomes_muti_line = opt_shape\n+                    .and_then(|shape| rewrite_cond(context, expr, shape))\n+                    .map_or(false, |cond| cond.contains('\\n'));\n+                if cond_becomes_muti_line {\n+                    (false, &*body)\n+                } else {\n+                    (can_extend(expr), &*expr)\n+                }\n             }\n         } else {\n             (false, &*body)\n@@ -341,7 +352,11 @@ fn rewrite_match_body(\n     arrow_span: Span,\n     is_last: bool,\n ) -> Option<String> {\n-    let (extend, body) = flatten_arm_body(context, body);\n+    let (extend, body) = flatten_arm_body(\n+        context,\n+        body,\n+        shape.offset_left(extra_offset(pats_str, shape) + 4),\n+    );\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block, _) = body.node {\n         (\n             true,"}]}