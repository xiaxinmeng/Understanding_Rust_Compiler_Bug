{"sha": "3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZDBiY2NiNzAzYzlhNmViYjVjYTlkMWQ3MjdjN2JjMjQ4YjFkZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-09T12:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-09T12:43:20Z"}, "message": "Auto merge of #6873 - Y-Nak:refactor-casts-lint, r=flip1995\n\nRefactor casts lint\n\nRef: #6724\n\nChanges:\n1. Separate the `casts` group from the `types` group.\n2. Reorganize the lints of the `casts` group into their own modules.\n\nNotes:\n1. I didn't `fix` #6874 in order to maintain this PR as small as possible.\n\n---\nchangelog: none", "tree": {"sha": "416df452e2f7d64ad5eedddb3bb62262492cc377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416df452e2f7d64ad5eedddb3bb62262492cc377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "html_url": "https://github.com/rust-lang/rust/commit/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "727e5f133cfacc15ab21236b08ab49479eafb51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/727e5f133cfacc15ab21236b08ab49479eafb51d", "html_url": "https://github.com/rust-lang/rust/commit/727e5f133cfacc15ab21236b08ab49479eafb51d"}, {"sha": "9e631da454e3ab6f756228b438b61126a0e51518", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e631da454e3ab6f756228b438b61126a0e51518", "html_url": "https://github.com/rust-lang/rust/commit/9e631da454e3ab6f756228b438b61126a0e51518"}], "stats": {"total": 2163, "additions": 1166, "deletions": 997}, "files": [{"sha": "478832a5164a08e61920e8cb314acb826e637c0c", "filename": "clippy_lints/src/casts/cast_lossless.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,87 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{in_constant, is_isize_or_usize, snippet_opt, span_lint_and_sugg};\n+\n+use super::{utils, CAST_LOSSLESS};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !should_lint(cx, expr, cast_from, cast_to) {\n+        return;\n+    }\n+\n+    // The suggestion is to use a function call, so if the original expression\n+    // has parens on the outside, they are no longer needed.\n+    let mut applicability = Applicability::MachineApplicable;\n+    let opt = snippet_opt(cx, cast_op.span);\n+    let sugg = opt.as_ref().map_or_else(\n+        || {\n+            applicability = Applicability::HasPlaceholders;\n+            \"..\"\n+        },\n+        |snip| {\n+            if should_strip_parens(cast_op, snip) {\n+                &snip[1..snip.len() - 1]\n+            } else {\n+                snip.as_str()\n+            }\n+        },\n+    );\n+\n+    span_lint_and_sugg(\n+        cx,\n+        CAST_LOSSLESS,\n+        expr.span,\n+        &format!(\n+            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n+            cast_from, cast_to\n+        ),\n+        \"try\",\n+        format!(\"{}::from({})\", cast_to, sugg),\n+        applicability,\n+    );\n+}\n+\n+fn should_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+    // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n+    if in_constant(cx, expr.hir_id) {\n+        return false;\n+    }\n+\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+            !is_isize_or_usize(cast_from)\n+                && !is_isize_or_usize(cast_to)\n+                && from_nbits < to_nbits\n+                && !cast_signed_to_unsigned\n+        },\n+\n+        (true, false) => {\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n+                32\n+            } else {\n+                64\n+            };\n+            from_nbits < to_nbits\n+        },\n+\n+        (_, _) => {\n+            matches!(cast_from.kind(), ty::Float(FloatTy::F32)) && matches!(cast_to.kind(), ty::Float(FloatTy::F64))\n+        },\n+    }\n+}\n+\n+fn should_strip_parens(cast_expr: &Expr<'_>, snip: &str) -> bool {\n+    if let ExprKind::Binary(_, _, _) = cast_expr.kind {\n+        if snip.starts_with('(') && snip.ends_with(')') {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "33b06b8fe7caff7a12f1b50fa5b093e73a47d0c8", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,54 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_POSSIBLE_TRUNCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let msg = match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            let (should_lint, suffix) = match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+                (true, true) | (false, false) => (to_nbits < from_nbits, \"\"),\n+                (true, false) => (\n+                    to_nbits <= 32,\n+                    if to_nbits == 32 {\n+                        \" on targets with 64-bit wide pointers\"\n+                    } else {\n+                        \"\"\n+                    },\n+                ),\n+                (false, true) => (from_nbits == 64, \" on targets with 32-bit wide pointers\"),\n+            };\n+\n+            if !should_lint {\n+                return;\n+            }\n+\n+            format!(\n+                \"casting `{}` to `{}` may truncate the value{}\",\n+                cast_from, cast_to, suffix,\n+            )\n+        },\n+\n+        (false, true) => {\n+            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n+        },\n+\n+        (_, _) => {\n+            if matches!(cast_from.kind(), &ty::Float(FloatTy::F64))\n+                && matches!(cast_to.kind(), &ty::Float(FloatTy::F32))\n+            {\n+                \"casting `f64` to `f32` may truncate the value\".to_string()\n+            } else {\n+                return;\n+            }\n+        },\n+    };\n+\n+    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg);\n+}"}, {"sha": "56d301ed3e1c55485968c23b4fc5b5459fd6a6a7", "filename": "clippy_lints/src/casts/cast_possible_wrap.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,44 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_POSSIBLE_WRAP};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !(cast_from.is_integral() && cast_to.is_integral()) {\n+        return;\n+    }\n+\n+    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n+    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n+    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n+    let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+    let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+    let (should_lint, suffix) = match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+        (true, true) | (false, false) => (to_nbits == from_nbits && cast_unsigned_to_signed, \"\"),\n+        (true, false) => (to_nbits <= 32 && cast_unsigned_to_signed, arch_32_suffix),\n+        (false, true) => (\n+            cast_unsigned_to_signed,\n+            if from_nbits == 64 {\n+                arch_64_suffix\n+            } else {\n+                arch_32_suffix\n+            },\n+        ),\n+    };\n+\n+    if should_lint {\n+        span_lint(\n+            cx,\n+            CAST_POSSIBLE_WRAP,\n+            expr.span,\n+            &format!(\n+                \"casting `{}` to `{}` may wrap around the value{}\",\n+                cast_from, cast_to, suffix,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "a1c3900ce1f6c0a8a27d2ec6566e39140bde6b37", "filename": "clippy_lints/src/casts/cast_precision_loss.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,51 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_PRECISION_LOSS};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !cast_from.is_integral() || cast_to.is_integral() {\n+        return;\n+    }\n+\n+    let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+    let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n+        32\n+    } else {\n+        64\n+    };\n+\n+    if !(is_isize_or_usize(cast_from) || from_nbits >= to_nbits) {\n+        return;\n+    }\n+\n+    let cast_to_f64 = to_nbits == 64;\n+    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n+    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n+    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n+    let from_nbits_str = if arch_dependent {\n+        \"64\".to_owned()\n+    } else if is_isize_or_usize(cast_from) {\n+        \"32 or 64\".to_owned()\n+    } else {\n+        utils::int_ty_to_nbits(cast_from, cx.tcx).to_string()\n+    };\n+\n+    span_lint(\n+        cx,\n+        CAST_PRECISION_LOSS,\n+        expr.span,\n+        &format!(\n+            \"casting `{0}` to `{1}` causes a loss of precision {2}(`{0}` is {3} bits wide, \\\n+             but `{1}`'s mantissa is only {4} bits wide)\",\n+            cast_from,\n+            if cast_to_f64 { \"f64\" } else { \"f32\" },\n+            if arch_dependent { arch_dependent_str } else { \"\" },\n+            from_nbits_str,\n+            mantissa_nbits\n+        ),\n+    );\n+}"}, {"sha": "87fb5557be066abf082b02f672dec71963d7d668", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,81 @@\n+use rustc_hir::{Expr, ExprKind, GenericArg};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{is_hir_ty_cfg_dependant, span_lint};\n+\n+use super::CAST_PTR_ALIGNMENT;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+        if is_hir_ty_cfg_dependant(cx, cast_to) {\n+            return;\n+        }\n+        let (cast_from, cast_to) = (\n+            cx.typeck_results().expr_ty(cast_expr),\n+            cx.typeck_results().expr_ty(expr),\n+        );\n+        lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+    } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+        if_chain! {\n+            if method_path.ident.name == sym!(cast);\n+            if let Some(generic_args) = method_path.args;\n+            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n+            if !is_hir_ty_cfg_dependant(cx, cast_to);\n+            then {\n+                let (cast_from, cast_to) =\n+                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+    if_chain! {\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n+        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n+        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n+        if from_layout.align.abi < to_layout.align.abi;\n+        // with c_void, we inherently need to trust the user\n+        if !is_c_void(cx, from_ptr_ty.ty);\n+        // when casting from a ZST, we don't know enough to properly lint\n+        if !from_layout.is_zst();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_PTR_ALIGNMENT,\n+                expr.span,\n+                &format!(\n+                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                    cast_from,\n+                    cast_to,\n+                    from_layout.align.abi.bytes(),\n+                    to_layout.align.abi.bytes(),\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Check if the given type is either `core::ffi::c_void` or\n+/// one of the platform specific `libc::<platform>::c_void` of libc.\n+fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind() {\n+        let names = cx.get_def_path(adt.did);\n+\n+        if names.is_empty() {\n+            return false;\n+        }\n+        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "3fdc1c6168ba9b05d75080a2045effdf1e6aa56a", "filename": "clippy_lints/src/casts/cast_ref_to_mut.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,28 @@\n+use rustc_hir::{Expr, ExprKind, MutTy, Mutability, TyKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::span_lint;\n+\n+use super::CAST_REF_TO_MUT;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n+        if let ExprKind::Cast(e, t) = &e.kind;\n+        if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n+        if let ExprKind::Cast(e, t) = &e.kind;\n+        if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n+        if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_REF_TO_MUT,\n+                expr.span,\n+                \"casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "9656fbebd772089ab159054227c47e04c049939c", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,70 @@\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils::{method_chain_args, sext, span_lint};\n+\n+use super::CAST_SIGN_LOSS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if should_lint(cx, cast_op, cast_from, cast_to) {\n+        span_lint(\n+            cx,\n+            CAST_SIGN_LOSS,\n+            expr.span,\n+            &format!(\n+                \"casting `{}` to `{}` may lose the sign of the value\",\n+                cast_from, cast_to\n+            ),\n+        );\n+    }\n+}\n+\n+fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            if !cast_from.is_signed() || cast_to.is_signed() {\n+                return false;\n+            }\n+\n+            // Don't lint for positive constants.\n+            let const_val = constant(cx, &cx.typeck_results(), cast_op);\n+            if_chain! {\n+                if let Some((Constant::Int(n), _)) = const_val;\n+                if let ty::Int(ity) = *cast_from.kind();\n+                if sext(cx.tcx, n, ity) >= 0;\n+                then {\n+                    return false;\n+                }\n+            }\n+\n+            // Don't lint for the result of methods that always return non-negative values.\n+            if let ExprKind::MethodCall(ref path, _, _, _) = cast_op.kind {\n+                let mut method_name = path.ident.name.as_str();\n+                let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n+\n+                if_chain! {\n+                    if method_name == \"unwrap\";\n+                    if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n+                    if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n+                    then {\n+                        method_name = inner_path.ident.name.as_str();\n+                    }\n+                }\n+\n+                if allowed_methods.iter().any(|&name| method_name == name) {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        },\n+\n+        (false, true) => !cast_to.is_signed(),\n+\n+        (_, _) => false,\n+    }\n+}"}, {"sha": "ccaad1b8f2ac7eae4b2b6fad0a613cfe38bf1588", "filename": "clippy_lints/src/casts/char_lit_as_u8.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,42 @@\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_then};\n+\n+use super::CHAR_LIT_AS_U8;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Cast(e, _) = &expr.kind;\n+        if let ExprKind::Lit(l) = &e.kind;\n+        if let LitKind::Char(c) = l.node;\n+        if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n+\n+            span_lint_and_then(\n+                cx,\n+                CHAR_LIT_AS_U8,\n+                expr.span,\n+                \"casting a character literal to `u8` truncates\",\n+                |diag| {\n+                    diag.note(\"`char` is four bytes wide, but `u8` is a single byte\");\n+\n+                    if c.is_ascii() {\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"use a byte literal instead\",\n+                            format!(\"b{}\", snippet),\n+                            applicability,\n+                        );\n+                    }\n+            });\n+        }\n+    }\n+}"}, {"sha": "a8d508585b5d416c3427d517bda9500ce9b41c89", "filename": "clippy_lints/src/casts/fn_to_numeric_cast.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,37 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, UintTy};\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+\n+use super::{utils, FN_TO_NUMERIC_CAST};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    // We only want to check casts to `ty::Uint` or `ty::Int`\n+    match cast_to.kind() {\n+        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n+        _ => return,\n+    }\n+\n+    match cast_from.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            if (to_nbits >= cx.tcx.data_layout.pointer_size.bits()) && (*cast_to.kind() != ty::Uint(UintTy::Usize)) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST,\n+                    expr.span,\n+                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n+                );\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "0085c7b27b2906021fdccc7e706067207fae7c20", "filename": "clippy_lints/src/casts/fn_to_numeric_cast_with_truncation.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,39 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+\n+use super::{utils, FN_TO_NUMERIC_CAST_WITH_TRUNCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    // We only want to check casts to `ty::Uint` or `ty::Int`\n+    match cast_to.kind() {\n+        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n+        _ => return,\n+    }\n+    match cast_from.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n+\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+            if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+                    expr.span,\n+                    &format!(\n+                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n+                        from_snippet, cast_to\n+                    ),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n+                );\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "b726bd75f1d83ca7702a8d0aec672003d789ef33", "filename": "clippy_lints/src/casts/mod.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,407 @@\n+mod cast_lossless;\n+mod cast_possible_truncation;\n+mod cast_possible_wrap;\n+mod cast_precision_loss;\n+mod cast_ptr_alignment;\n+mod cast_ref_to_mut;\n+mod cast_sign_loss;\n+mod char_lit_as_u8;\n+mod fn_to_numeric_cast;\n+mod fn_to_numeric_cast_with_truncation;\n+mod ptr_as_ptr;\n+mod unnecessary_cast;\n+mod utils;\n+\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+use crate::utils::is_hir_ty_cfg_dependant;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from any numerical to a float type where\n+    /// the receiving type cannot store all values from the original type without\n+    /// rounding errors. This possible rounding is to be expected, so this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n+    /// or any 64-bit integer to `f64`.\n+    ///\n+    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n+    /// helpful to know where precision loss can take place. This lint can help find\n+    /// those places in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = u64::MAX;\n+    /// x as f64;\n+    /// ```\n+    pub CAST_PRECISION_LOSS,\n+    pedantic,\n+    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n+    /// type. In this case, negative values wrap around to large positive values,\n+    /// which can be quite surprising in practice. However, as the cast works as\n+    /// defined, this lint is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n+    /// as a one-time check to see where numerical wrapping can arise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y: i8 = -1;\n+    /// y as u128; // will return 18446744073709551615\n+    /// ```\n+    pub CAST_SIGN_LOSS,\n+    pedantic,\n+    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts between numerical types that may\n+    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n+    /// default.\n+    ///\n+    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n+    /// truncation. This lint can be activated to help assess where additional\n+    /// checks could be beneficial.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u8(x: u64) -> u8 {\n+    ///     x as u8\n+    /// }\n+    /// ```\n+    pub CAST_POSSIBLE_TRUNCATION,\n+    pedantic,\n+    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n+    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n+    /// i.e., nothing is changed at the bit level, and the binary representation of\n+    /// the value is reinterpreted. This can cause wrapping if the value is too big\n+    /// for the target signed type. However, the cast works as defined, so this lint\n+    /// is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n+    /// be surprising when this is not the intended behavior, as demonstrated by the\n+    /// example below.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// u32::MAX as i32; // will yield a value of `-1`\n+    /// ```\n+    pub CAST_POSSIBLE_WRAP,\n+    pedantic,\n+    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts between numerical types that may\n+    /// be replaced by safe conversion functions.\n+    ///\n+    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n+    /// conversions, including silently lossy conversions. Conversion functions such\n+    /// as `i32::from` will only perform lossless conversions. Using the conversion\n+    /// functions prevents conversions from turning into silent lossy conversions if\n+    /// the types of the input expressions ever change, and make it easier for\n+    /// people reading the code to know that the conversion is lossless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     x as u64\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `::from` would look like this:\n+    ///\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     u64::from(x)\n+    /// }\n+    /// ```\n+    pub CAST_LOSSLESS,\n+    pedantic,\n+    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n+    /// and casts of float literals to float types.\n+    ///\n+    /// **Why is this bad?** It's just unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = 2i32 as i32;\n+    /// let _ = 0.5 as f32;\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// let _ = 2_i32;\n+    /// let _ = 0.5_f32;\n+    /// ```\n+    pub UNNECESSARY_CAST,\n+    complexity,\n+    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n+    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n+    ///\n+    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n+    /// behavior.\n+    ///\n+    /// **Known problems:** Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n+    /// on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n+    /// u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (&1u8 as *const u8) as *const u16;\n+    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    ///\n+    /// (&1u8 as *const u8).cast::<u16>();\n+    /// (&mut 1u8 as *mut u8).cast::<u16>();\n+    /// ```\n+    pub CAST_PTR_ALIGNMENT,\n+    pedantic,\n+    \"cast from a pointer to a more-strictly-aligned pointer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of function pointers to something other than usize\n+    ///\n+    /// **Why is this bad?**\n+    /// Casting a function pointer to anything other than usize/isize is not portable across\n+    /// architectures, because you end up losing bits if the target type is too small or end up with a\n+    /// bunch of extra bits that waste space and add more instructions to the final binary than\n+    /// strictly necessary for the problem\n+    ///\n+    /// Casting to isize also doesn't make sense since there are no signed addresses.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fun() -> i32 { 1 }\n+    /// let a = fun as i64;\n+    ///\n+    /// // Good\n+    /// fn fun2() -> i32 { 1 }\n+    /// let a = fun2 as usize;\n+    /// ```\n+    pub FN_TO_NUMERIC_CAST,\n+    style,\n+    \"casting a function pointer to a numeric type other than usize\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n+    /// store address.\n+    ///\n+    /// **Why is this bad?**\n+    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n+    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+    /// a comment) to perform the truncation.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fn1() -> i16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn1 as i32;\n+    ///\n+    /// // Better: Cast to usize first, then comment with the reason for the truncation\n+    /// fn fn2() -> i16 {\n+    ///     1\n+    /// };\n+    /// let fn_ptr = fn2 as usize;\n+    /// let fn_ptr_truncated = fn_ptr as i32;\n+    /// ```\n+    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    style,\n+    \"casting a function pointer to a numeric type not wide enough to store the address\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n+    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n+    /// mutable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// fn x(r: &i32) {\n+    ///     unsafe {\n+    ///         *(r as *const _ as *mut _) += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead consider using interior mutability types.\n+    ///\n+    /// ```rust\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// fn x(r: &UnsafeCell<i32>) {\n+    ///     unsafe {\n+    ///         *r.get() += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    pub CAST_REF_TO_MUT,\n+    correctness,\n+    \"a cast of reference to a mutable pointer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where a character literal is cast\n+    /// to `u8` and suggests using a byte literal instead.\n+    ///\n+    /// **Why is this bad?** In general, casting values to smaller types is\n+    /// error-prone and should be avoided where possible. In the particular case of\n+    /// converting a character literal to u8, it is easy to avoid by just using a\n+    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+    /// than `'a' as u8`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// 'x' as u8\n+    /// ```\n+    ///\n+    /// A better version, using the byte literal:\n+    ///\n+    /// ```rust,ignore\n+    /// b'x'\n+    /// ```\n+    pub CHAR_LIT_AS_U8,\n+    complexity,\n+    \"casting a character literal to `u8` truncates\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for `as` casts between raw pointers without changing its mutability,\n+    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n+    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr as *const i32;\n+    /// let _ = mut_ptr as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr.cast::<i32>();\n+    /// let _ = mut_ptr.cast::<i32>();\n+    /// ```\n+    pub PTR_AS_PTR,\n+    pedantic,\n+    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n+}\n+\n+pub struct Casts {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Casts {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(Casts => [\n+    CAST_PRECISION_LOSS,\n+    CAST_SIGN_LOSS,\n+    CAST_POSSIBLE_TRUNCATION,\n+    CAST_POSSIBLE_WRAP,\n+    CAST_LOSSLESS,\n+    CAST_REF_TO_MUT,\n+    CAST_PTR_ALIGNMENT,\n+    UNNECESSARY_CAST,\n+    FN_TO_NUMERIC_CAST,\n+    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    CHAR_LIT_AS_U8,\n+    PTR_AS_PTR,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Casts {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+                return;\n+            }\n+            let (cast_from, cast_to) = (\n+                cx.typeck_results().expr_ty(cast_expr),\n+                cx.typeck_results().expr_ty(expr),\n+            );\n+\n+            if unnecessary_cast::check(cx, expr, cast_expr, cast_from, cast_to) {\n+                return;\n+            }\n+\n+            fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n+            fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n+            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n+                cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n+                cast_precision_loss::check(cx, expr, cast_from, cast_to);\n+                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to);\n+                cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n+            }\n+        }\n+\n+        cast_ref_to_mut::check(cx, expr);\n+        cast_ptr_alignment::check(cx, expr);\n+        char_lit_as_u8::check(cx, expr);\n+        ptr_as_ptr::check(cx, expr, &self.msrv);\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "abfbadf3642bed7e875f67ff6e1197c3b030a4fc", "filename": "clippy_lints/src/casts/ptr_as_ptr.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,52 @@\n+use std::borrow::Cow;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, TypeAndMut};\n+use rustc_semver::RustcVersion;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{meets_msrv, span_lint_and_sugg};\n+\n+use super::PTR_AS_PTR;\n+\n+const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: &Option<RustcVersion>) {\n+    if !meets_msrv(msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n+        return;\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n+        let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n+        if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n+        if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n+        if matches!((from_mutbl, to_mutbl),\n+            (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n+        // The `U` in `pointer::cast` have to be `Sized`\n+        // as explained here: https://github.com/rust-lang/rust/issues/60602.\n+        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n+            let turbofish = match &cast_to_hir_ty.kind {\n+                    TyKind::Infer => Cow::Borrowed(\"\"),\n+                    TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n+                    _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n+                };\n+            span_lint_and_sugg(\n+                cx,\n+                PTR_AS_PTR,\n+                expr.span,\n+                \"`as` casting between raw pointers without changing its mutability\",\n+                \"try `pointer::cast`, a safer alternative\",\n+                format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "fa2a07ef1da0c098adb6374eec6594ee46f4a916", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,106 @@\n+use rustc_ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Lit, UnOp};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, FloatTy, InferTy, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{numeric_literal::NumericLiteral, snippet_opt, span_lint, span_lint_and_sugg};\n+\n+use super::UNNECESSARY_CAST;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) -> bool {\n+    if let Some(lit) = get_numeric_literal(cast_expr) {\n+        let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+\n+        if_chain! {\n+            if let LitKind::Int(n, _) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if cast_to.is_floating_point();\n+            if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n+            let from_nbits = 128 - n.leading_zeros();\n+            let to_nbits = fp_ty_mantissa_nbits(cast_to);\n+            if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n+            then {\n+                let literal_str = if is_unary_neg(cast_expr) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                return true\n+            }\n+        }\n+\n+        match lit.node {\n+            LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n+            _ => {\n+                if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n+                    span_lint(\n+                        cx,\n+                        UNNECESSARY_CAST,\n+                        expr.span,\n+                        &format!(\n+                            \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n+                            cast_from, cast_to\n+                        ),\n+                    );\n+                    return true;\n+                }\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    span_lint_and_sugg(\n+        cx,\n+        UNNECESSARY_CAST,\n+        expr.span,\n+        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        \"try\",\n+        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n+    match expr.kind {\n+        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Unary(UnOp::Neg, e) => {\n+            if let ExprKind::Lit(ref lit) = e.kind {\n+                Some(lit)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns the mantissa bits wide of a fp type.\n+/// Will return 0 if the type is not a fp\n+fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n+    match typ.kind() {\n+        ty::Float(FloatTy::F32) => 23,\n+        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n+        _ => 0,\n+    }\n+}\n+\n+fn is_unary_neg(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n+}"}, {"sha": "00fd0b3473b4417949097b5ebb34ba8c10144e60", "filename": "clippy_lints/src/casts/utils.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -0,0 +1,25 @@\n+use rustc_middle::ty::{self, IntTy, Ty, TyCtxt, UintTy};\n+\n+/// Returns the size in bits of an integral type.\n+/// Will return 0 if the type is not an int or uint variant\n+pub(super) fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n+    match typ.kind() {\n+        ty::Int(i) => match i {\n+            IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n+        },\n+        ty::Uint(i) => match i {\n+            UintTy::Usize => tcx.data_layout.pointer_size.bits(),\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n+        },\n+        _ => 0,\n+    }\n+}"}, {"sha": "04e151df8e8547efa01bfac782ff04afb02f1f77", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -182,6 +182,7 @@ mod booleans;\n mod bytecount;\n mod cargo_common_metadata;\n mod case_sensitive_file_extension_comparisons;\n+mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n@@ -586,6 +587,18 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &bytecount::NAIVE_BYTECOUNT,\n         &cargo_common_metadata::CARGO_COMMON_METADATA,\n         &case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+        &casts::CAST_LOSSLESS,\n+        &casts::CAST_POSSIBLE_TRUNCATION,\n+        &casts::CAST_POSSIBLE_WRAP,\n+        &casts::CAST_PRECISION_LOSS,\n+        &casts::CAST_PTR_ALIGNMENT,\n+        &casts::CAST_REF_TO_MUT,\n+        &casts::CAST_SIGN_LOSS,\n+        &casts::CHAR_LIT_AS_U8,\n+        &casts::FN_TO_NUMERIC_CAST,\n+        &casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+        &casts::PTR_AS_PTR,\n+        &casts::UNNECESSARY_CAST,\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n         &collapsible_if::COLLAPSIBLE_ELSE_IF,\n@@ -943,28 +956,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n-        &types::CAST_LOSSLESS,\n-        &types::CAST_POSSIBLE_TRUNCATION,\n-        &types::CAST_POSSIBLE_WRAP,\n-        &types::CAST_PRECISION_LOSS,\n-        &types::CAST_PTR_ALIGNMENT,\n-        &types::CAST_REF_TO_MUT,\n-        &types::CAST_SIGN_LOSS,\n-        &types::CHAR_LIT_AS_U8,\n-        &types::FN_TO_NUMERIC_CAST,\n-        &types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n         &types::IMPLICIT_HASHER,\n         &types::INVALID_UPCAST_COMPARISONS,\n         &types::LET_UNIT_VALUE,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n-        &types::PTR_AS_PTR,\n         &types::RC_BUFFER,\n         &types::REDUNDANT_ALLOCATION,\n         &types::TYPE_COMPLEXITY,\n         &types::UNIT_ARG,\n         &types::UNIT_CMP,\n-        &types::UNNECESSARY_CAST,\n         &types::VEC_BOX,\n         &undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n         &unicode::INVISIBLE_CHARACTERS,\n@@ -1075,6 +1076,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n     store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n     store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark::new(msrv));\n+    store.register_late_pass(move || box casts::Casts::new(msrv));\n \n     store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n@@ -1086,7 +1088,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n     store.register_late_pass(|| box minmax::MinMaxPass);\n@@ -1107,7 +1108,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n     store.register_late_pass(|| box strings::StringLitAsBytes);\n     store.register_late_pass(|| box derive::Derive);\n-    store.register_late_pass(|| box types::CharLitAsU8);\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n     store.register_late_pass(|| box empty_enum::EmptyEnum);\n@@ -1175,7 +1175,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n     store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n     store.register_late_pass(|| box unnecessary_wraps::UnnecessaryWraps);\n-    store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n     store.register_late_pass(|| box transmuting_null::TransmutingNull);\n     store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n@@ -1277,7 +1276,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringToString);\n     store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n     store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n-    store.register_late_pass(move || box types::PtrAsPtr::new(msrv));\n     store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n     store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n     store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n@@ -1345,6 +1343,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n+        LintId::of(&casts::CAST_LOSSLESS),\n+        LintId::of(&casts::CAST_POSSIBLE_TRUNCATION),\n+        LintId::of(&casts::CAST_POSSIBLE_WRAP),\n+        LintId::of(&casts::CAST_PRECISION_LOSS),\n+        LintId::of(&casts::CAST_PTR_ALIGNMENT),\n+        LintId::of(&casts::CAST_SIGN_LOSS),\n+        LintId::of(&casts::PTR_AS_PTR),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n@@ -1404,18 +1409,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&types::CAST_LOSSLESS),\n-        LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n-        LintId::of(&types::CAST_POSSIBLE_WRAP),\n-        LintId::of(&types::CAST_PRECISION_LOSS),\n-        LintId::of(&types::CAST_PTR_ALIGNMENT),\n-        LintId::of(&types::CAST_SIGN_LOSS),\n         LintId::of(&types::IMPLICIT_HASHER),\n         LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&types::LET_UNIT_VALUE),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n-        LintId::of(&types::PTR_AS_PTR),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n         LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n@@ -1459,6 +1457,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&booleans::LOGIC_BUG),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n+        LintId::of(&casts::CAST_REF_TO_MUT),\n+        LintId::of(&casts::CHAR_LIT_AS_U8),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n+        LintId::of(&casts::UNNECESSARY_CAST),\n         LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n@@ -1699,15 +1702,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::BOX_VEC),\n-        LintId::of(&types::CAST_REF_TO_MUT),\n-        LintId::of(&types::CHAR_LIT_AS_U8),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&types::TYPE_COMPLEXITY),\n         LintId::of(&types::UNIT_ARG),\n         LintId::of(&types::UNIT_CMP),\n-        LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n@@ -1740,6 +1738,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n@@ -1836,8 +1836,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(&try_err::TRY_ERR),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&upper_case_acronyms::UPPER_CASE_ACRONYMS),\n@@ -1853,6 +1851,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(&attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n+        LintId::of(&casts::CHAR_LIT_AS_U8),\n+        LintId::of(&casts::UNNECESSARY_CAST),\n         LintId::of(&double_comparison::DOUBLE_COMPARISONS),\n         LintId::of(&double_parens::DOUBLE_PARENS),\n         LintId::of(&duration_subsec::DURATION_SUBSEC),\n@@ -1929,10 +1929,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::TRANSMUTE_PTR_TO_PTR),\n         LintId::of(&transmute::TRANSMUTE_PTR_TO_REF),\n         LintId::of(&types::BORROWED_BOX),\n-        LintId::of(&types::CHAR_LIT_AS_U8),\n         LintId::of(&types::TYPE_COMPLEXITY),\n         LintId::of(&types::UNIT_ARG),\n-        LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n@@ -1950,6 +1948,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&booleans::LOGIC_BUG),\n+        LintId::of(&casts::CAST_REF_TO_MUT),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n@@ -2002,7 +2001,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n-        LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::UNIT_CMP),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),"}, {"sha": "7be4ea0379318448a6897fbc9c0697c6b7d36c39", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 6, "deletions": 963, "changes": 969, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -14,20 +14,18 @@ use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n use if_chain::if_chain;\n-use rustc_ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind, TraitFn,\n-    TraitItem, TraitItemKind, TyKind, UnOp,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, MutTy, Node, QPath, Stmt, StmtKind, TraitFn, TraitItem,\n+    TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults, UintTy};\n-use rustc_semver::RustcVersion;\n+use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -38,12 +36,10 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n-    is_type_diagnostic_item, match_path, meets_msrv, method_chain_args, multispan_sugg,\n-    numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    clip, comparisons, differing_macro_contexts, higher, indent_of, int_bits, is_isize_or_usize,\n+    is_type_diagnostic_item, match_path, multispan_sugg, reindent_multiline, sext, snippet, snippet_opt,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -778,749 +774,6 @@ fn is_unit_literal(expr: &Expr<'_>) -> bool {\n     matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from any numerical to a float type where\n-    /// the receiving type cannot store all values from the original type without\n-    /// rounding errors. This possible rounding is to be expected, so this lint is\n-    /// `Allow` by default.\n-    ///\n-    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n-    /// or any 64-bit integer to `f64`.\n-    ///\n-    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n-    /// helpful to know where precision loss can take place. This lint can help find\n-    /// those places in the code.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = u64::MAX;\n-    /// x as f64;\n-    /// ```\n-    pub CAST_PRECISION_LOSS,\n-    pedantic,\n-    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n-    /// type. In this case, negative values wrap around to large positive values,\n-    /// which can be quite surprising in practice. However, as the cast works as\n-    /// defined, this lint is `Allow` by default.\n-    ///\n-    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n-    /// as a one-time check to see where numerical wrapping can arise.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let y: i8 = -1;\n-    /// y as u128; // will return 18446744073709551615\n-    /// ```\n-    pub CAST_SIGN_LOSS,\n-    pedantic,\n-    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts between numerical types that may\n-    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n-    /// default.\n-    ///\n-    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n-    /// truncation. This lint can be activated to help assess where additional\n-    /// checks could be beneficial.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn as_u8(x: u64) -> u8 {\n-    ///     x as u8\n-    /// }\n-    /// ```\n-    pub CAST_POSSIBLE_TRUNCATION,\n-    pedantic,\n-    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n-    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n-    /// i.e., nothing is changed at the bit level, and the binary representation of\n-    /// the value is reinterpreted. This can cause wrapping if the value is too big\n-    /// for the target signed type. However, the cast works as defined, so this lint\n-    /// is `Allow` by default.\n-    ///\n-    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n-    /// be surprising when this is not the intended behavior, as demonstrated by the\n-    /// example below.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// u32::MAX as i32; // will yield a value of `-1`\n-    /// ```\n-    pub CAST_POSSIBLE_WRAP,\n-    pedantic,\n-    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts between numerical types that may\n-    /// be replaced by safe conversion functions.\n-    ///\n-    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n-    /// conversions, including silently lossy conversions. Conversion functions such\n-    /// as `i32::from` will only perform lossless conversions. Using the conversion\n-    /// functions prevents conversions from turning into silent lossy conversions if\n-    /// the types of the input expressions ever change, and make it easier for\n-    /// people reading the code to know that the conversion is lossless.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn as_u64(x: u8) -> u64 {\n-    ///     x as u64\n-    /// }\n-    /// ```\n-    ///\n-    /// Using `::from` would look like this:\n-    ///\n-    /// ```rust\n-    /// fn as_u64(x: u8) -> u64 {\n-    ///     u64::from(x)\n-    /// }\n-    /// ```\n-    pub CAST_LOSSLESS,\n-    pedantic,\n-    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n-    /// and casts of float literals to float types.\n-    ///\n-    /// **Why is this bad?** It's just unnecessary.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let _ = 2i32 as i32;\n-    /// let _ = 0.5 as f32;\n-    /// ```\n-    ///\n-    /// Better:\n-    ///\n-    /// ```rust\n-    /// let _ = 2_i32;\n-    /// let _ = 0.5_f32;\n-    /// ```\n-    pub UNNECESSARY_CAST,\n-    complexity,\n-    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n-    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n-    ///\n-    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n-    /// behavior.\n-    ///\n-    /// **Known problems:** Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n-    /// on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n-    /// u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let _ = (&1u8 as *const u8) as *const u16;\n-    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n-    ///\n-    /// (&1u8 as *const u8).cast::<u16>();\n-    /// (&mut 1u8 as *mut u8).cast::<u16>();\n-    /// ```\n-    pub CAST_PTR_ALIGNMENT,\n-    pedantic,\n-    \"cast from a pointer to a more-strictly-aligned pointer\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of function pointers to something other than usize\n-    ///\n-    /// **Why is this bad?**\n-    /// Casting a function pointer to anything other than usize/isize is not portable across\n-    /// architectures, because you end up losing bits if the target type is too small or end up with a\n-    /// bunch of extra bits that waste space and add more instructions to the final binary than\n-    /// strictly necessary for the problem\n-    ///\n-    /// Casting to isize also doesn't make sense since there are no signed addresses.\n-    ///\n-    /// **Example**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn fun() -> i32 { 1 }\n-    /// let a = fun as i64;\n-    ///\n-    /// // Good\n-    /// fn fun2() -> i32 { 1 }\n-    /// let a = fun2 as usize;\n-    /// ```\n-    pub FN_TO_NUMERIC_CAST,\n-    style,\n-    \"casting a function pointer to a numeric type other than usize\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n-    /// store address.\n-    ///\n-    /// **Why is this bad?**\n-    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n-    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n-    /// a comment) to perform the truncation.\n-    ///\n-    /// **Example**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn fn1() -> i16 {\n-    ///     1\n-    /// };\n-    /// let _ = fn1 as i32;\n-    ///\n-    /// // Better: Cast to usize first, then comment with the reason for the truncation\n-    /// fn fn2() -> i16 {\n-    ///     1\n-    /// };\n-    /// let fn_ptr = fn2 as usize;\n-    /// let fn_ptr_truncated = fn_ptr as i32;\n-    /// ```\n-    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-    style,\n-    \"casting a function pointer to a numeric type not wide enough to store the address\"\n-}\n-\n-/// Returns the size in bits of an integral type.\n-/// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n-    match typ.kind() {\n-        ty::Int(i) => match i {\n-            IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        },\n-        ty::Uint(i) => match i {\n-            UintTy::Usize => tcx.data_layout.pointer_size.bits(),\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        },\n-        _ => 0,\n-    }\n-}\n-\n-fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n-}\n-\n-fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n-    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n-    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n-    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n-    let from_nbits_str = if arch_dependent {\n-        \"64\".to_owned()\n-    } else if is_isize_or_usize(cast_from) {\n-        \"32 or 64\".to_owned()\n-    } else {\n-        int_ty_to_nbits(cast_from, cx.tcx).to_string()\n-    };\n-    span_lint(\n-        cx,\n-        CAST_PRECISION_LOSS,\n-        expr.span,\n-        &format!(\n-            \"casting `{0}` to `{1}` causes a loss of precision {2}(`{0}` is {3} bits wide, \\\n-             but `{1}`'s mantissa is only {4} bits wide)\",\n-            cast_from,\n-            if cast_to_f64 { \"f64\" } else { \"f32\" },\n-            if arch_dependent { arch_dependent_str } else { \"\" },\n-            from_nbits_str,\n-            mantissa_nbits\n-        ),\n-    );\n-}\n-\n-fn should_strip_parens(op: &Expr<'_>, snip: &str) -> bool {\n-    if let ExprKind::Binary(_, _, _) = op.kind {\n-        if snip.starts_with('(') && snip.ends_with(')') {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n-    if in_constant(cx, expr.hir_id) {\n-        return;\n-    }\n-    // The suggestion is to use a function call, so if the original expression\n-    // has parens on the outside, they are no longer needed.\n-    let mut applicability = Applicability::MachineApplicable;\n-    let opt = snippet_opt(cx, op.span);\n-    let sugg = opt.as_ref().map_or_else(\n-        || {\n-            applicability = Applicability::HasPlaceholders;\n-            \"..\"\n-        },\n-        |snip| {\n-            if should_strip_parens(op, snip) {\n-                &snip[1..snip.len() - 1]\n-            } else {\n-                snip.as_str()\n-            }\n-        },\n-    );\n-\n-    span_lint_and_sugg(\n-        cx,\n-        CAST_LOSSLESS,\n-        expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n-            cast_from, cast_to\n-        ),\n-        \"try\",\n-        format!(\"{}::from({})\", cast_to, sugg),\n-        applicability,\n-    );\n-}\n-\n-enum ArchSuffix {\n-    _32,\n-    _64,\n-    None,\n-}\n-\n-fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    if !cast_from.is_signed() || cast_to.is_signed() {\n-        return;\n-    }\n-\n-    // don't lint for positive constants\n-    let const_val = constant(cx, &cx.typeck_results(), op);\n-    if_chain! {\n-        if let Some((Constant::Int(n), _)) = const_val;\n-        if let ty::Int(ity) = *cast_from.kind();\n-        if sext(cx.tcx, n, ity) >= 0;\n-        then {\n-            return\n-        }\n-    }\n-\n-    // don't lint for the result of methods that always return non-negative values\n-    if let ExprKind::MethodCall(ref path, _, _, _) = op.kind {\n-        let mut method_name = path.ident.name.as_str();\n-        let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n-\n-        if_chain! {\n-            if method_name == \"unwrap\";\n-            if let Some(arglist) = method_chain_args(op, &[\"unwrap\"]);\n-            if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n-            then {\n-                method_name = inner_path.ident.name.as_str();\n-            }\n-        }\n-\n-        if allowed_methods.iter().any(|&name| method_name == name) {\n-            return;\n-        }\n-    }\n-\n-    span_lint(\n-        cx,\n-        CAST_SIGN_LOSS,\n-        expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may lose the sign of the value\",\n-            cast_from, cast_to\n-        ),\n-    );\n-}\n-\n-fn check_truncation_and_wrapping(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n-    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n-    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n-    let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-    let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n-        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n-            (true, true) | (false, false) => (\n-                to_nbits < from_nbits,\n-                ArchSuffix::None,\n-                to_nbits == from_nbits && cast_unsigned_to_signed,\n-                ArchSuffix::None,\n-            ),\n-            (true, false) => (\n-                to_nbits <= 32,\n-                if to_nbits == 32 {\n-                    ArchSuffix::_64\n-                } else {\n-                    ArchSuffix::None\n-                },\n-                to_nbits <= 32 && cast_unsigned_to_signed,\n-                ArchSuffix::_32,\n-            ),\n-            (false, true) => (\n-                from_nbits == 64,\n-                ArchSuffix::_32,\n-                cast_unsigned_to_signed,\n-                if from_nbits == 64 {\n-                    ArchSuffix::_64\n-                } else {\n-                    ArchSuffix::_32\n-                },\n-            ),\n-        };\n-    if span_truncation {\n-        span_lint(\n-            cx,\n-            CAST_POSSIBLE_TRUNCATION,\n-            expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may truncate the value{}\",\n-                cast_from,\n-                cast_to,\n-                match suffix_truncation {\n-                    ArchSuffix::_32 => arch_32_suffix,\n-                    ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\",\n-                }\n-            ),\n-        );\n-    }\n-    if span_wrap {\n-        span_lint(\n-            cx,\n-            CAST_POSSIBLE_WRAP,\n-            expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may wrap around the value{}\",\n-                cast_from,\n-                cast_to,\n-                match suffix_wrap {\n-                    ArchSuffix::_32 => arch_32_suffix,\n-                    ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\",\n-                }\n-            ),\n-        );\n-    }\n-}\n-\n-fn check_lossless(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n-    let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-    let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) && from_nbits < to_nbits && !cast_signed_to_unsigned\n-    {\n-        span_lossless_lint(cx, expr, op, cast_from, cast_to);\n-    }\n-}\n-\n-declare_lint_pass!(Casts => [\n-    CAST_PRECISION_LOSS,\n-    CAST_SIGN_LOSS,\n-    CAST_POSSIBLE_TRUNCATION,\n-    CAST_POSSIBLE_WRAP,\n-    CAST_LOSSLESS,\n-    UNNECESSARY_CAST,\n-    CAST_PTR_ALIGNMENT,\n-    FN_TO_NUMERIC_CAST,\n-    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-]);\n-\n-// Check if the given type is either `core::ffi::c_void` or\n-// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns the mantissa bits wide of a fp type.\n-/// Will return 0 if the type is not a fp\n-fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.kind() {\n-        ty::Float(FloatTy::F32) => 23,\n-        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n-        _ => 0,\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for Casts {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Cast(ref ex, cast_to) = expr.kind {\n-            if is_hir_ty_cfg_dependant(cx, cast_to) {\n-                return;\n-            }\n-            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n-            lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let Some(lit) = get_numeric_literal(ex) {\n-                let literal_str = snippet_opt(cx, ex.span).unwrap_or_default();\n-\n-                if_chain! {\n-                    if let LitKind::Int(n, _) = lit.node;\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if cast_to.is_floating_point();\n-                    if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n-                    let from_nbits = 128 - n.leading_zeros();\n-                    let to_nbits = fp_ty_mantissa_nbits(cast_to);\n-                    if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n-                    then {\n-                        let literal_str = if is_unary_neg(ex) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                        return;\n-                    }\n-                }\n-\n-                match lit.node {\n-                    LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n-                    _ => {\n-                        if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n-                            span_lint(\n-                                cx,\n-                                UNNECESSARY_CAST,\n-                                expr.span,\n-                                &format!(\n-                                    \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n-                                    cast_from, cast_to\n-                                ),\n-                            );\n-                        }\n-                    },\n-                }\n-            }\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n-                lint_numeric_casts(cx, expr, ex, cast_from, cast_to);\n-            }\n-\n-            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-        } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n-            if_chain! {\n-            if method_path.ident.name == sym!(cast);\n-            if let Some(generic_args) = method_path.args;\n-            if let [GenericArg::Type(cast_to)] = generic_args.args;\n-            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n-            if !is_hir_ty_cfg_dependant(cx, cast_to);\n-            then {\n-                let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n-                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-            }\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unary_neg(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n-}\n-\n-fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n-    match expr.kind {\n-        ExprKind::Lit(ref lit) => Some(lit),\n-        ExprKind::Unary(UnOp::Neg, e) => {\n-            if let ExprKind::Lit(ref lit) = e.kind {\n-                Some(lit)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n-    span_lint_and_sugg(\n-        cx,\n-        UNNECESSARY_CAST,\n-        expr.span,\n-        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n-        \"try\",\n-        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn lint_numeric_casts<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &Expr<'tcx>,\n-    cast_expr: &Expr<'_>,\n-    cast_from: Ty<'tcx>,\n-    cast_to: Ty<'tcx>,\n-) {\n-    match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (true, false) => {\n-            let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n-                32\n-            } else {\n-                64\n-            };\n-            if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n-                span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n-            }\n-            if from_nbits < to_nbits {\n-                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n-            }\n-        },\n-        (false, true) => {\n-            span_lint(\n-                cx,\n-                CAST_POSSIBLE_TRUNCATION,\n-                expr.span,\n-                &format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to),\n-            );\n-            if !cast_to.is_signed() {\n-                span_lint(\n-                    cx,\n-                    CAST_SIGN_LOSS,\n-                    expr.span,\n-                    &format!(\n-                        \"casting `{}` to `{}` may lose the sign of the value\",\n-                        cast_from, cast_to\n-                    ),\n-                );\n-            }\n-        },\n-        (true, true) => {\n-            check_loss_of_sign(cx, expr, cast_expr, cast_from, cast_to);\n-            check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n-            check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n-        },\n-        (false, false) => {\n-            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind(), &cast_to.kind()) {\n-                span_lint(\n-                    cx,\n-                    CAST_POSSIBLE_TRUNCATION,\n-                    expr.span,\n-                    \"casting `f64` to `f32` may truncate the value\",\n-                );\n-            }\n-            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind(), &cast_to.kind()) {\n-                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n-            }\n-        },\n-    }\n-}\n-\n-fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n-    if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n-        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-        if from_layout.align.abi < to_layout.align.abi;\n-        // with c_void, we inherently need to trust the user\n-        if !is_c_void(cx, from_ptr_ty.ty);\n-        // when casting from a ZST, we don't know enough to properly lint\n-        if !from_layout.is_zst();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_PTR_ALIGNMENT,\n-                expr.span,\n-                &format!(\n-                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                    cast_from,\n-                    cast_to,\n-                    from_layout.align.abi.bytes(),\n-                    to_layout.align.abi.bytes(),\n-                ),\n-            );\n-        }\n-    }\n-}\n-\n-fn lint_fn_to_numeric_cast(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    cast_expr: &Expr<'_>,\n-    cast_from: Ty<'_>,\n-    cast_to: Ty<'_>,\n-) {\n-    // We only want to check casts to `ty::Uint` or `ty::Int`\n-    match cast_to.kind() {\n-        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n-        _ => return,\n-    }\n-    match cast_from.kind() {\n-        ty::FnDef(..) | ty::FnPtr(_) => {\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n-\n-            let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-            if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n-                span_lint_and_sugg(\n-                    cx,\n-                    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-                    expr.span,\n-                    &format!(\n-                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n-                        from_snippet, cast_to\n-                    ),\n-                    \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n-                    applicability,\n-                );\n-            } else if *cast_to.kind() != ty::Uint(UintTy::Usize) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    FN_TO_NUMERIC_CAST,\n-                    expr.span,\n-                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n-                    \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n-                    applicability,\n-                );\n-            }\n-        },\n-        _ => {},\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for types used in structs, parameters and `let`\n     /// declarations above a certain complexity threshold.\n@@ -1686,69 +939,6 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for expressions where a character literal is cast\n-    /// to `u8` and suggests using a byte literal instead.\n-    ///\n-    /// **Why is this bad?** In general, casting values to smaller types is\n-    /// error-prone and should be avoided where possible. In the particular case of\n-    /// converting a character literal to u8, it is easy to avoid by just using a\n-    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n-    /// than `'a' as u8`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// 'x' as u8\n-    /// ```\n-    ///\n-    /// A better version, using the byte literal:\n-    ///\n-    /// ```rust,ignore\n-    /// b'x'\n-    /// ```\n-    pub CHAR_LIT_AS_U8,\n-    complexity,\n-    \"casting a character literal to `u8` truncates\"\n-}\n-\n-declare_lint_pass!(CharLitAsU8 => [CHAR_LIT_AS_U8]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if !expr.span.from_expansion();\n-            if let ExprKind::Cast(e, _) = &expr.kind;\n-            if let ExprKind::Lit(l) = &e.kind;\n-            if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    CHAR_LIT_AS_U8,\n-                    expr.span,\n-                    \"casting a character literal to `u8` truncates\",\n-                    |diag| {\n-                        diag.note(\"`char` is four bytes wide, but `u8` is a single byte\");\n-\n-                        if c.is_ascii() {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"use a byte literal instead\",\n-                                format!(\"b{}\", snippet),\n-                                applicability,\n-                            );\n-                        }\n-                });\n-            }\n-        }\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for comparisons where one side of the relation is\n     /// either the minimum or maximum value for its type and warns if it involves a\n@@ -2476,150 +1666,3 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n         NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n-    ///\n-    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n-    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n-    /// mutable.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// fn x(r: &i32) {\n-    ///     unsafe {\n-    ///         *(r as *const _ as *mut _) += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// Instead consider using interior mutability types.\n-    ///\n-    /// ```rust\n-    /// use std::cell::UnsafeCell;\n-    ///\n-    /// fn x(r: &UnsafeCell<i32>) {\n-    ///     unsafe {\n-    ///         *r.get() += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    pub CAST_REF_TO_MUT,\n-    correctness,\n-    \"a cast of reference to a mutable pointer\"\n-}\n-\n-declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RefToMut {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n-            if let ExprKind::Cast(e, t) = &e.kind;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n-            if let ExprKind::Cast(e, t) = &e.kind;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n-            then {\n-                span_lint(\n-                    cx,\n-                    CAST_REF_TO_MUT,\n-                    expr.span,\n-                    \"casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n-\n-declare_clippy_lint! {\n-    /// **What it does:**\n-    /// Checks for `as` casts between raw pointers without changing its mutability,\n-    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n-    ///\n-    /// **Why is this bad?**\n-    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n-    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let ptr: *const u32 = &42_u32;\n-    /// let mut_ptr: *mut u32 = &mut 42_u32;\n-    /// let _ = ptr as *const i32;\n-    /// let _ = mut_ptr as *mut i32;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let ptr: *const u32 = &42_u32;\n-    /// let mut_ptr: *mut u32 = &mut 42_u32;\n-    /// let _ = ptr.cast::<i32>();\n-    /// let _ = mut_ptr.cast::<i32>();\n-    /// ```\n-    pub PTR_AS_PTR,\n-    pedantic,\n-    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n-}\n-\n-pub struct PtrAsPtr {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl PtrAsPtr {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl_lint_pass!(PtrAsPtr => [PTR_AS_PTR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for PtrAsPtr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n-            return;\n-        }\n-\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n-            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n-            if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n-            if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n-            if matches!((from_mutbl, to_mutbl),\n-                (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n-            // The `U` in `pointer::cast` have to be `Sized`\n-            // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-            if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n-                let turbofish = match &cast_to_hir_ty.kind {\n-                        TyKind::Infer => Cow::Borrowed(\"\"),\n-                        TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n-                        _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n-                    };\n-                span_lint_and_sugg(\n-                    cx,\n-                    PTR_AS_PTR,\n-                    expr.span,\n-                    \"`as` casting between raw pointers without changing its mutability\",\n-                    \"try `pointer::cast`, a safer alternative\",\n-                    format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}"}, {"sha": "74429982759b282f224fa2130c6c238d67d56d3f", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3ed0bccb703c9a6ebb5ca9d1d727c7bc248b1dd5", "patch": "@@ -72,7 +72,7 @@ use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n@@ -262,6 +262,11 @@ pub fn is_ty_param_diagnostic_item(\n     }\n }\n \n+/// Return `true` if the passed `typ` is `isize` or `usize`.\n+pub fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n+    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+}\n+\n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();"}]}