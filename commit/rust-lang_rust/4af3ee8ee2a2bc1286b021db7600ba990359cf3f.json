{"sha": "4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjNlZThlZTJhMmJjMTI4NmIwMjFkYjc2MDBiYTk5MDM1OWNmM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T08:35:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T08:35:24Z"}, "message": "Auto merge of #66950 - RalfJung:rollup-12d0zx8, r=RalfJung\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #66245 (Conditional compilation for sanitizers)\n - #66654 (Handle const-checks for `&mut` outside of `HasMutInterior`)\n - #66822 (libunwind_panic: adjust miri panic hack)\n - #66827 (handle diverging functions forwarding their return place)\n - #66834 (rustbuild fixes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8631bfc4d4f6746bdc573f206f8f5edf4bbdfc74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8631bfc4d4f6746bdc573f206f8f5edf4bbdfc74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "html_url": "https://github.com/rust-lang/rust/commit/4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c81e0a986e4285d3d0fd781a1bd475753eb12c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c81e0a986e4285d3d0fd781a1bd475753eb12c", "html_url": "https://github.com/rust-lang/rust/commit/f5c81e0a986e4285d3d0fd781a1bd475753eb12c"}, {"sha": "910e83eab2f65dd922f8d980c71840a68b3d7c6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/910e83eab2f65dd922f8d980c71840a68b3d7c6a", "html_url": "https://github.com/rust-lang/rust/commit/910e83eab2f65dd922f8d980c71840a68b3d7c6a"}], "stats": {"total": 553, "additions": 292, "deletions": 261}, "files": [{"sha": "bb169414886de2da6e0c37c50928b47fe0e604ef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -643,7 +643,9 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n-        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2 \"\n+        # preserve existing RUSTFLAGS\n+        env.setdefault(\"RUSTFLAGS\", \"\")\n+        env[\"RUSTFLAGS\"] += \" -Cdebuginfo=2\"\n \n         build_section = \"target.{}\".format(self.build_triple())\n         target_features = []\n@@ -652,13 +654,13 @@ def build_bootstrap(self):\n         elif self.get_toml(\"crt-static\", build_section) == \"false\":\n             target_features += [\"-crt-static\"]\n         if target_features:\n-            env[\"RUSTFLAGS\"] += \"-C target-feature=\" + (\",\".join(target_features)) + \" \"\n+            env[\"RUSTFLAGS\"] += \" -C target-feature=\" + (\",\".join(target_features))\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n-            env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n-        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n+            env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n-            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n+            env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]"}, {"sha": "f8734ebdf4254213b743dfa125fbc701250addba", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -260,7 +260,7 @@ install!((self, builder, _config),\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: self.compiler,\n+            compiler: builder.compiler(builder.top_stage, self.target),\n         });\n         install_rustc(builder, self.compiler.stage, self.target);\n     };"}, {"sha": "949f24ab9c11eb5337050c3fadfdc51bcf3bcf91", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -0,0 +1,36 @@\n+# `cfg_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `cfg_sanitize` feature makes it possible to execute different code\n+depending on whether a particular sanitizer is enabled or not.\n+\n+## Examples\n+\n+``` rust\n+#![feature(cfg_sanitize)]\n+\n+#[cfg(sanitize = \"thread\")]\n+fn a() {\n+  // ...\n+}\n+\n+#[cfg(not(sanitize = \"thread\"))]\n+fn a() {\n+  // ...\n+}\n+\n+fn b() {\n+  if cfg!(sanitize = \"leak\") {\n+    // ...\n+  } else {\n+    // ...\n+  }\n+}\n+\n+```\n+"}, {"sha": "d4952f53bf7fed3ff2831dc20d1ed150d9d9a40c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -1348,9 +1348,11 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding.\n+    /// Compiles to a NOP during non-Miri codegen.\n+    ///\n     /// Perma-unstable: do not use\n     #[cfg(not(bootstrap))]\n-    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> !;\n+    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> ();\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "3a14197c77bec3ba289315fc1cfb8773f58a6a2f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -36,10 +36,7 @@ use core::raw;\n use core::panic::BoxMeUp;\n \n cfg_if::cfg_if! {\n-    if #[cfg(miri)] {\n-        #[path = \"miri.rs\"]\n-        mod imp;\n-    } else if #[cfg(target_os = \"emscripten\")] {\n+    if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n     } else if #[cfg(target_arch = \"wasm32\")] {\n@@ -94,5 +91,14 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;\n-    imp::panic(Box::from_raw((*payload).take_box()))\n+    let payload = (*payload).take_box();\n+\n+    // Miri panic support: cfg'd out of normal builds just to be sure.\n+    // When going through normal codegen, `miri_start_panic` is a NOP, so the\n+    // Miri-enabled sysroot still supports normal unwinding. But when executed in\n+    // Miri, this line initiates unwinding.\n+    #[cfg(miri)]\n+    core::intrinsics::miri_start_panic(payload);\n+\n+    imp::panic(Box::from_raw(payload))\n }"}, {"sha": "f26c42fd4bcbaac9c707b22ff7b50fd961b64e98", "filename": "src/libpanic_unwind/miri.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Flibpanic_unwind%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Flibpanic_unwind%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmiri.rs?ref=f5c81e0a986e4285d3d0fd781a1bd475753eb12c", "patch": "@@ -1,42 +0,0 @@\n-#![allow(nonstandard_style)]\n-\n-use core::any::Any;\n-use alloc::boxed::Box;\n-\n-pub fn payload() -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n-\n-pub unsafe fn panic(data: Box<dyn Any + Send>) -> ! {\n-    core::intrinsics::miri_start_panic(Box::into_raw(data))\n-}\n-\n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    Box::from_raw(ptr)\n-}\n-\n-// This is required by the compiler to exist (e.g., it's a lang item),\n-// but is never used by Miri. Therefore, we just use a stub here\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-fn rust_eh_personality() {\n-    unsafe { core::intrinsics::abort() }\n-}\n-\n-// The rest is required on *some* targets to exist (specifically, MSVC targets that use SEH).\n-// We just add it on all targets. Copied from `seh.rs`.\n-#[repr(C)]\n-pub struct _TypeDescriptor {\n-    pub pVFTable: *const u8,\n-    pub spare: *mut u8,\n-    pub name: [u8; 11],\n-}\n-\n-const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n-\n-#[cfg_attr(not(test), lang = \"eh_catch_typeinfo\")]\n-static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: core::ptr::null(),\n-    spare: core::ptr::null_mut(),\n-    name: TYPE_NAME,\n-};"}, {"sha": "9a242d9d0769b4517278d009ec211d35be44ad8c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -47,6 +47,17 @@ pub enum Sanitizer {\n     Thread,\n }\n \n+impl fmt::Display for Sanitizer {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Sanitizer::Address => \"address\".fmt(f),\n+            Sanitizer::Leak => \"leak\".fmt(f),\n+            Sanitizer::Memory => \"memory\".fmt(f),\n+            Sanitizer::Thread => \"thread\".fmt(f),\n+        }\n+    }\n+}\n+\n impl FromStr for Sanitizer {\n     type Err = ();\n     fn from_str(s: &str) -> Result<Sanitizer, ()> {\n@@ -1580,6 +1591,10 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n             }\n         }\n     }\n+    if let Some(s) = &sess.opts.debugging_opts.sanitizer {\n+        let symbol = Symbol::intern(&s.to_string());\n+        ret.insert((sym::sanitize, Some(symbol)));\n+    }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }"}, {"sha": "d76392f7570b410690b922e72a9f4df0ae844986", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -528,18 +528,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => FnAbi::new(&bx, sig, &extra_args)\n         };\n \n-        // This should never be reachable at runtime:\n-        // We should only emit a call to this intrinsic in #[cfg(miri)] mode,\n-        // which means that we will never actually use the generate object files\n-        // (we will just be interpreting the MIR)\n-        //\n-        // Note that we still need to be able to codegen *something* for this intrisnic:\n-        // Miri currently uses Xargo to build a special libstd. As a side effect,\n-        // we generate normal object files for libstd - while these are never used,\n-        // we still need to be able to build them.\n+        // For normal codegen, this Miri-specific intrinsic is just a NOP.\n         if intrinsic == Some(\"miri_start_panic\") {\n-            bx.abort();\n-            bx.unreachable();\n+            let target = destination.as_ref().unwrap().1;\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n "}, {"sha": "16d8ada9f24c0857f93c2c29f662da0bfbd1d76c", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -524,6 +524,9 @@ declare_features! (\n     /// Allows the use of `if` and `match` in constants.\n     (active, const_if_match, \"1.41.0\", Some(49146), None),\n \n+    /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n+    (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "4fa0198d8716d2463d49f9e1ca56f2cd58418040", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -25,6 +25,7 @@ const GATED_CFGS: &[GatedCfg] = &[\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::sanitize, sym::cfg_sanitize, cfg_fn!(cfg_sanitize)),\n ];\n \n /// Find a gated cfg determined by the `pred`icate which is given the cfg's name."}, {"sha": "70d9836b6ff0fd1bbf6373baeafc3bf1f0b7b209", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -651,20 +651,28 @@ where\n         use rustc::mir::PlaceBase;\n \n         let mut place_ty = match &place.base {\n-            PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n-                Some(return_place) => {\n-                    // We use our layout to verify our assumption; caller will validate\n-                    // their layout on return.\n-                    PlaceTy {\n-                        place: *return_place,\n-                        layout: self.layout_of(\n-                            self.subst_from_frame_and_normalize_erasing_regions(\n-                                self.frame().body.return_ty()\n-                            )\n-                        )?,\n-                    }\n+            PlaceBase::Local(mir::RETURN_PLACE) => {\n+                // `return_place` has the *caller* layout, but we want to use our\n+                // `layout to verify our assumption. The caller will validate\n+                // their layout on return.\n+                PlaceTy {\n+                    place: match self.frame().return_place {\n+                        Some(p) => *p,\n+                        // Even if we don't have a return place, we sometimes need to\n+                        // create this place, but any attempt to read from / write to it\n+                        // (even a ZST read/write) needs to error, so let us make this\n+                        // a NULL place.\n+                        //\n+                        // FIXME: Ideally we'd make sure that the place projections also\n+                        // bail out.\n+                        None => Place::null(&*self),\n+                    },\n+                    layout: self.layout_of(\n+                        self.subst_from_frame_and_normalize_erasing_regions(\n+                            self.frame().body.return_ty()\n+                        )\n+                    )?,\n                 }\n-                None => throw_unsup!(InvalidNullPointerUsage),\n             },\n             PlaceBase::Local(local) => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n@@ -791,8 +799,8 @@ where\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        let ptr = match self.check_mplace_access(dest, None)\n-            .expect(\"places should be checked on creation\")\n+        // Invalid places are a thing: the return place of a diverging function\n+        let ptr = match self.check_mplace_access(dest, None)?\n         {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access"}, {"sha": "f4fb9a5e4f2a2ad20a2438ca5d9835fcd272f0ad", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -29,6 +29,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(stmt_expr_attributes)]\n #![feature(bool_to_option)]\n #![feature(trait_alias)]\n+#![feature(matches_macro)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "2d5a0a2afcd016e0e263f0feb2ced56c7099ed07", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::{self, Ty};\n use rustc::hir::def_id::DefId;\n use syntax_pos::DUMMY_SP;\n \n-use super::{ConstKind, Item as ConstCx};\n+use super::Item as ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {\n@@ -33,9 +33,10 @@ pub trait Qualif {\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n \n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _def_id: DefId) -> bool {\n-        // FIXME(eddyb) should we do anything here for value properties?\n-        false\n+    fn in_static(cx: &ConstCx<'_, 'tcx>, def_id: DefId) -> bool {\n+        // `mir_const_qualif` does return the qualifs in the final value of a `static`, so we could\n+        // use value-based qualification here, but we shouldn't do this without a good reason.\n+        Self::in_any_value_of_ty(cx, cx.tcx.type_of(def_id))\n     }\n \n     fn in_projection_structurally(\n@@ -217,34 +218,6 @@ impl Qualif for HasMutInterior {\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n-            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n-            // allowed in constants (and the `Checker` will error), and/or it\n-            // won't be promoted, due to `&mut ...` or interior mutability.\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.body, cx.tcx).ty;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences.\n-                    match ty.kind {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        | ty::Array(..)\n-                        | ty::Slice(_)\n-                        if cx.const_kind == Some(ConstKind::StaticMut)\n-                        => {},\n-\n-                        // FIXME(eddyb): We only return false for `&mut []` outside a const\n-                        // context which seems unnecessary given that this is merely a ZST.\n-                        | ty::Array(_, len)\n-                        if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                            && cx.const_kind == None\n-                        => {},\n-\n-                        _ => return true,\n-                    }\n-                }\n-            }\n-\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {"}, {"sha": "783c64ece73715a61e620981d07f4861b494e2c2", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 95, "deletions": 97, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -23,13 +23,6 @@ use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum CheckOpResult {\n-    Forbidden,\n-    Unleashed,\n-    Allowed,\n-}\n-\n pub type IndirectlyMutableResults<'mir, 'tcx> =\n     old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n \n@@ -149,17 +142,6 @@ pub struct Validator<'a, 'mir, 'tcx> {\n \n     /// The span of the current statement.\n     span: Span,\n-\n-    /// True if the local was assigned the result of an illegal borrow (`ops::MutBorrow`).\n-    ///\n-    /// This is used to hide errors from {re,}borrowing the newly-assigned local, instead pointing\n-    /// the user to the place where the illegal borrow occurred. This set is only populated once an\n-    /// error has been emitted, so it will never cause an erroneous `mir::Body` to pass validation.\n-    ///\n-    /// FIXME(ecstaticmorse): assert at the end of checking that if `tcx.has_errors() == false`,\n-    /// this set is empty. Note that if we start removing locals from\n-    /// `derived_from_illegal_borrow`, just checking at the end won't be enough.\n-    derived_from_illegal_borrow: BitSet<Local>,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n@@ -213,7 +195,6 @@ impl Validator<'a, 'mir, 'tcx> {\n             span: item.body.span,\n             item,\n             qualifs,\n-            derived_from_illegal_borrow: BitSet::new_empty(item.body.local_decls.len()),\n         }\n     }\n \n@@ -258,15 +239,15 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n-    /// context. Returns `Forbidden` if an error was emitted.\n-    pub fn check_op_spanned<O>(&mut self, op: O, span: Span) -> CheckOpResult\n+    /// context.\n+    pub fn check_op_spanned<O>(&mut self, op: O, span: Span)\n     where\n         O: NonConstOp\n     {\n         trace!(\"check_op: op={:?}\", op);\n \n         if op.is_allowed_in_item(self) {\n-            return CheckOpResult::Allowed;\n+            return;\n         }\n \n         // If an operation is supported in miri (and is not already controlled by a feature gate) it\n@@ -276,20 +257,19 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         if is_unleashable && self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n             self.tcx.sess.span_warn(span, \"skipping const checks\");\n-            return CheckOpResult::Unleashed;\n+            return;\n         }\n \n         op.emit_error(self, span);\n-        CheckOpResult::Forbidden\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp) -> CheckOpResult {\n+    pub fn check_op(&mut self, op: impl NonConstOp) {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n \n-    fn check_static(&mut self, def_id: DefId, span: Span) -> CheckOpResult {\n+    fn check_static(&mut self, def_id: DefId, span: Span) {\n         let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n         if is_thread_local {\n             self.check_op_spanned(ops::ThreadLocalAccess, span)\n@@ -322,20 +302,9 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n-        // Check nested operands and places.\n+        // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Special-case reborrows to be more like a copy of a reference.\n-            let mut reborrow_place = None;\n-            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                if elem == ProjectionElem::Deref {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        reborrow_place = Some(proj_base);\n-                    }\n-                }\n-            }\n-\n-            if let Some(proj) = reborrow_place {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -351,14 +320,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     ),\n                 };\n                 self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, proj, ctx, location);\n-            } else {\n-                self.super_rvalue(rvalue, location);\n+                self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                return;\n             }\n-        } else {\n-            self.super_rvalue(rvalue, location);\n         }\n \n+        self.super_rvalue(rvalue, location);\n+\n         match *rvalue {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n@@ -369,9 +337,58 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Cast(CastKind::Pointer(_), ..) |\n             Rvalue::Discriminant(..) |\n             Rvalue::Len(_) |\n-            Rvalue::Ref(..) |\n             Rvalue::Aggregate(..) => {}\n \n+            | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n+            => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n+                let is_allowed = match ty.kind {\n+                    // Inside a `static mut`, `&mut [...]` is allowed.\n+                    ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n+                        => true,\n+\n+                    // FIXME(ecstaticmorse): We could allow `&mut []` inside a const context given\n+                    // that this is merely a ZST and it is already eligible for promotion.\n+                    // This may require an RFC?\n+                    /*\n+                    ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                        => true,\n+                    */\n+\n+                    _ => false,\n+                };\n+\n+                if !is_allowed {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+\n+            // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n+            | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            if matches!(place.base, PlaceBase::Static(_))\n+            => bug!(\"Saw a promoted during const-checking, which must run before promotion\"),\n+\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shallow, ref place)\n+            => {\n+                // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n+                // seek the cursors beforehand.\n+                self.qualifs.has_mut_interior.cursor.seek_before(location);\n+                self.qualifs.indirectly_mutable.seek(location);\n+\n+                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                    &self.item,\n+                    &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                    place.as_ref(),\n+                );\n+\n+                if borrowed_place_has_mut_interior {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n@@ -436,58 +453,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_assign(&mut self, dest: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n-        trace!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-\n-        // Error on mutable borrows or shared borrows of values with interior mutability.\n-        //\n-        // This replicates the logic at the start of `assign` in the old const checker.  Note that\n-        // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n-        // interior mutability.\n-        if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n-            // the cursors beforehand.\n-            self.qualifs.has_mut_interior.cursor.seek_before(location);\n-            self.qualifs.indirectly_mutable.seek(location);\n-\n-            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n-                &self.item,\n-                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-                rvalue,\n-            );\n-\n-            if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n-                    // If an unprojected local was borrowed and its value was the result of an\n-                    // illegal borrow, suppress this error and mark the result of this borrow as\n-                    // illegal as well.\n-                    Some(borrowed_local)\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n-                    {\n-                        true\n-                    }\n-\n-                    // Otherwise proceed normally: check the legality of a mutable borrow in this\n-                    // context.\n-                    _ => self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden,\n-                };\n-\n-                // When the target of the assignment is a local with no projections, mark it as\n-                // derived from an illegal borrow if necessary.\n-                //\n-                // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n-                // assigned a new value?\n-                if is_derived_from_illegal_borrow {\n-                    if let Some(dest) = dest.as_local() {\n-                        self.derived_from_illegal_borrow.insert(dest);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.super_assign(dest, rvalue, location);\n-    }\n-\n     fn visit_projection_elem(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,\n@@ -724,3 +689,36 @@ fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId)\n         }\n     });\n }\n+\n+fn place_as_reborrow(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    place: &'a Place<'tcx>,\n+) -> Option<&'a [PlaceElem<'tcx>]> {\n+    place\n+        .projection\n+        .split_last()\n+        .and_then(|(outermost, inner)| {\n+            if outermost != &ProjectionElem::Deref {\n+                return None;\n+            }\n+\n+            // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n+            // that points to the allocation for the static. Don't treat these as reborrows.\n+            if let PlaceBase::Local(local) = place.base {\n+                if body.local_decls[local].is_ref_to_static() {\n+                    return None;\n+                }\n+            }\n+\n+            // Ensure the type being derefed is a reference and not a raw pointer.\n+            //\n+            // This is sufficient to prevent an access to a `static mut` from being marked as a\n+            // reborrow, even if the check above were to disappear.\n+            let inner_ty = Place::ty_from(&place.base, inner, body, tcx).ty;\n+            match inner_ty.kind {\n+                ty::Ref(..) => Some(inner),\n+                _ => None,\n+            }\n+        })\n+}"}, {"sha": "3059b059691067c51966b1646a1bcc35ec6e7892", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -177,6 +177,7 @@ symbols! {\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,\n+        cfg_sanitize,\n         cfg_target_feature,\n         cfg_target_has_atomic,\n         cfg_target_thread_local,\n@@ -634,6 +635,7 @@ symbols! {\n         rust_eh_unwind_resume,\n         rust_oom,\n         rvalue_static_promotion,\n+        sanitize,\n         sanitizer_runtime,\n         _Self,\n         self_in_typedefs,"}, {"sha": "5e2be0d4f3f02ee73be0731b934390bdbc4de1d2", "filename": "src/test/ui/consts/const-multi-ref.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -1,11 +1,24 @@\n-const _X: i32 = {\n+// Ensure that we point the user to the erroneous borrow but not to any subsequent borrows of that\n+// initial one.\n+\n+const _: i32 = {\n     let mut a = 5;\n-    let p = &mut a;      //~ ERROR references in constants may only refer to immutable values\n+    let p = &mut a; //~ ERROR references in constants may only refer to immutable values\n \n-    let reborrow = {p};  //~ ERROR references in constants may only refer to immutable values\n+    let reborrow = {p};\n     let pp = &reborrow;\n     let ppp = &pp;\n     ***ppp\n };\n \n+const _: std::cell::Cell<i32> = {\n+    let mut a = std::cell::Cell::new(5);\n+    let p = &a; //~ ERROR cannot borrow a constant which may contain interior mutability\n+\n+    let reborrow = {p};\n+    let pp = &reborrow;\n+    let ppp = &pp;\n+    a\n+};\n+\n fn main() {}"}, {"sha": "ed3837e9c9ee589be2aea3a8298887e2ac8dfb93", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -1,15 +1,16 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/const-multi-ref.rs:3:13\n+  --> $DIR/const-multi-ref.rs:6:13\n    |\n LL |     let p = &mut a;\n    |             ^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/const-multi-ref.rs:5:21\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/const-multi-ref.rs:16:13\n    |\n-LL |     let reborrow = {p};\n-   |                     ^ constants require immutable values\n+LL |     let p = &a;\n+   |             ^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0017, E0492.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "3bc518c2c2b719c8ef983aecbea807d58e9b68e4", "filename": "src/test/ui/error-codes/E0017.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -1,8 +1,11 @@\n static X: i32 = 1;\n const C: i32 = 2;\n+static mut M: i32 = 3;\n \n const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n+                                              //~| ERROR E0019\n                                               //~| ERROR cannot borrow\n static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n+static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR E0017\n fn main() {}"}, {"sha": "8c8660adceb7a6d1ccdec30ef256aaf07b998871", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -1,28 +1,40 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/E0017.rs:4:30\n+  --> $DIR/E0017.rs:5:30\n    |\n LL | const CR: &'static mut i32 = &mut C;\n    |                              ^^^^^^ constants require immutable values\n \n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/E0017.rs:6:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^\n+\n error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0017.rs:5:39\n+  --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ statics require immutable values\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n-  --> $DIR/E0017.rs:5:39\n+  --> $DIR/E0017.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ cannot borrow as mutable\n \n error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0017.rs:7:38\n+  --> $DIR/E0017.rs:9:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n    |                                      ^^^^^^ statics require immutable values\n \n-error: aborting due to 4 previous errors\n+error[E0017]: references in statics may only refer to immutable values\n+  --> $DIR/E0017.rs:10:52\n+   |\n+LL | static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M };\n+   |                                                    ^^^^^^ statics require immutable values\n+\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0017, E0596.\n+Some errors have detailed explanations: E0017, E0019, E0596.\n For more information about an error, try `rustc --explain E0017`."}, {"sha": "3aa4ac9655cc976cdad4944451b19a9ef795b391", "filename": "src/test/ui/error-codes/E0388.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs?ref=f5c81e0a986e4285d3d0fd781a1bd475753eb12c", "patch": "@@ -1,9 +0,0 @@\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n-static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-                                              //~| ERROR cannot borrow\n-static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n-\n-fn main() {}"}, {"sha": "b52d5260b13c82444cbaf444b35425e9c4c6e4a5", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5c81e0a986e4285d3d0fd781a1bd475753eb12c/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=f5c81e0a986e4285d3d0fd781a1bd475753eb12c", "patch": "@@ -1,28 +0,0 @@\n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/E0388.rs:4:30\n-   |\n-LL | const CR: &'static mut i32 = &mut C;\n-   |                              ^^^^^^ constants require immutable values\n-\n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0388.rs:5:39\n-   |\n-LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ statics require immutable values\n-\n-error[E0596]: cannot borrow immutable static item `X` as mutable\n-  --> $DIR/E0388.rs:5:39\n-   |\n-LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ cannot borrow as mutable\n-\n-error[E0017]: references in statics may only refer to immutable values\n-  --> $DIR/E0388.rs:7:38\n-   |\n-LL | static CONST_REF: &'static mut i32 = &mut C;\n-   |                                      ^^^^^^ statics require immutable values\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0017, E0596.\n-For more information about an error, try `rustc --explain E0017`."}, {"sha": "c3e7cc9ed8a9bcbe1252abf0cf281aaddcc2ac79", "filename": "src/test/ui/feature-gates/feature-gate-cfg_sanitize.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -0,0 +1,3 @@\n+#[cfg(not(sanitize = \"thread\"))]\n+//~^ `cfg(sanitize)` is experimental\n+fn main() {}"}, {"sha": "f67a0d83bdd3a1fab70eddaa13cf86d91cf6edf2", "filename": "src/test/ui/feature-gates/feature-gate-cfg_sanitize.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg_sanitize.stderr?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: `cfg(sanitize)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg_sanitize.rs:1:11\n+   |\n+LL | #[cfg(not(sanitize = \"thread\"))]\n+   |           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/39699\n+   = help: add `#![feature(cfg_sanitize)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9c198543a86649572cd42aa4fc6105d4231b985b", "filename": "src/test/ui/sanitize-cfg.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fsanitize-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af3ee8ee2a2bc1286b021db7600ba990359cf3f/src%2Ftest%2Fui%2Fsanitize-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize-cfg.rs?ref=4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "patch": "@@ -0,0 +1,26 @@\n+// Verifies that when compiling with -Zsanitizer=option,\n+// the `#[cfg(sanitize = \"option\")]` attribute is configured.\n+\n+// needs-sanitizer-support\n+// only-linux\n+// only-x86_64\n+// check-pass\n+// revisions: address leak memory thread\n+//[address]compile-flags: -Zsanitizer=address --cfg address\n+//[leak]compile-flags:    -Zsanitizer=leak    --cfg leak\n+//[memory]compile-flags:  -Zsanitizer=memory  --cfg memory\n+//[thread]compile-flags:  -Zsanitizer=thread  --cfg thread\n+\n+#![feature(cfg_sanitize)]\n+\n+#[cfg(all(sanitize = \"address\", address))]\n+fn main() {}\n+\n+#[cfg(all(sanitize = \"leak\", leak))]\n+fn main() {}\n+\n+#[cfg(all(sanitize = \"memory\", memory))]\n+fn main() {}\n+\n+#[cfg(all(sanitize = \"thread\", thread))]\n+fn main() {}"}]}