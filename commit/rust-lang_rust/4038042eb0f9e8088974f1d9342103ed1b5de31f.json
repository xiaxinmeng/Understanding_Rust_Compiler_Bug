{"sha": "4038042eb0f9e8088974f1d9342103ed1b5de31f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMzgwNDJlYjBmOWU4MDg4OTc0ZjFkOTM0MjEwM2VkMWI1ZGUzMWY=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2020-08-12T22:19:53Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-01-11T09:09:22Z"}, "message": "Add `[T; N]::each_ref` and `[T; N]::each_mut`\n\nThese methods work very similarly to `Option`'s methods `as_ref` and\n`as_mut`. They are useful in several situation, particularly when\ncalling other array methods (like `map`) on the result. Unfortunately,\nwe can't easily call them `as_ref` and `as_mut` as that would shadow\nthose methods on slices, thus being a breaking change (that is likely\nto affect a lot of code).", "tree": {"sha": "56350c45d1d62a89d9db51b23233f530c74d5e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56350c45d1d62a89d9db51b23233f530c74d5e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4038042eb0f9e8088974f1d9342103ed1b5de31f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl/8FcIACgkQ+boUO5X/\nbYLpkQ/+LzdGtFGAC40HjiMNqfkHWdNSRd1OjmHptGikzPMT15qDWV369j8tTrXZ\nOzMVL9AN9Oh6cWHZ7zDyj5rawg8HI04dsWnaW2P8s7KJJ4SZT1rQ0vwWw1vF8IT+\nTVrgHsPiwpP+3YOos+x/4nXvqqrXnT+mJEZ+c8eDYN7aECD6id13IwtiCTCJ8eSw\nE4xH8oIM++z7x6P54nJv4S4gwGPR8fUZghXWldlnQ2OobuEjNj7H3rFL92qaeFF2\nJFJ81rKQujXbrLxvE2n2kyxAbF+9HlRL9ejcLBn9piqC9zQeyh0pV138Zo32ewPU\nvN50fqb7iks4tWNhGGG8mGUW7D2e0Mb2/gBUAD+BkbzHaXakekaJDCjS/q9blGUY\nBBi/da8QjKbFru4OubKnx2FelUklol7AlFAy7AO5zXfdNxQd+m1Vc8Z1C72gVNwG\nrEqa/Iph0o/8DggDmSmWXFzWBfYiP9RPu7P4Md3sxfTr/bpDj2u4F/j1fwoFnfLz\n8MMo+572dFZpUzwqnFrzhL3hoOq6Lj9x7FtkrF06rctq5nQd8B3n0qTHkhy5Vvs4\n3r0nWfdSJXKzb3s6wbxQu5XEqAYCAV6dmtdNFlHxrgZ7PsmskIIl8Vfn+YrdHkar\neQ/oeFZvr546digk3UN2oKU5kqzwzrRSpzk3BjUKvC6X1ekSVnU=\n=6Hck\n-----END PGP SIGNATURE-----", "payload": "tree 56350c45d1d62a89d9db51b23233f530c74d5e4d\nparent a2cd91ceb0f156cb442d75e12dc77c3d064cdde4\nauthor Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1597270793 +0200\ncommitter David Tolnay <dtolnay@gmail.com> 1610356162 -0800\n\nAdd `[T; N]::each_ref` and `[T; N]::each_mut`\n\nThese methods work very similarly to `Option`'s methods `as_ref` and\n`as_mut`. They are useful in several situation, particularly when\ncalling other array methods (like `map`) on the result. Unfortunately,\nwe can't easily call them `as_ref` and `as_mut` as that would shadow\nthose methods on slices, thus being a breaking change (that is likely\nto affect a lot of code).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4038042eb0f9e8088974f1d9342103ed1b5de31f", "html_url": "https://github.com/rust-lang/rust/commit/4038042eb0f9e8088974f1d9342103ed1b5de31f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4038042eb0f9e8088974f1d9342103ed1b5de31f/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2cd91ceb0f156cb442d75e12dc77c3d064cdde4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2cd91ceb0f156cb442d75e12dc77c3d064cdde4", "html_url": "https://github.com/rust-lang/rust/commit/a2cd91ceb0f156cb442d75e12dc77c3d064cdde4"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "85b1a47f4a9ff5b3f64ca4ae4d3d076245eb523b", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4038042eb0f9e8088974f1d9342103ed1b5de31f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4038042eb0f9e8088974f1d9342103ed1b5de31f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=4038042eb0f9e8088974f1d9342103ed1b5de31f", "patch": "@@ -12,6 +12,7 @@ use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n use crate::marker::Unsize;\n+use crate::mem::MaybeUninit;\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n@@ -429,7 +430,6 @@ impl<T, const N: usize> [T; N] {\n     where\n         F: FnMut(T) -> U,\n     {\n-        use crate::mem::MaybeUninit;\n         struct Guard<T, const N: usize> {\n             dst: *mut T,\n             initialized: usize,\n@@ -481,8 +481,6 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        use crate::mem::MaybeUninit;\n-\n         let mut dst = MaybeUninit::uninit_array::<N>();\n         for (i, (lhs, rhs)) in IntoIter::new(self).zip(IntoIter::new(rhs)).enumerate() {\n             dst[i].write((lhs, rhs));\n@@ -506,4 +504,75 @@ impl<T, const N: usize> [T; N] {\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         self\n     }\n+\n+    /// Borrows each element and returns an array of references with the same\n+    /// size as `self`.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(array_methods)]\n+    ///\n+    /// let floats = [3.1, 2.7, -1.0];\n+    /// let float_refs: [&f64; 3] = floats.each_ref();\n+    /// assert_eq!(float_refs, [&3.1, &2.7, &-1.0]);\n+    /// ```\n+    ///\n+    /// This method is particularly useful if combined with other methods, like\n+    /// [`map`](#method.map). This way, you can can avoid moving the original\n+    /// array if its elements are not `Copy`.\n+    ///\n+    /// ```\n+    /// #![feature(array_methods, array_map)]\n+    ///\n+    /// let strings = [\"Ferris\".to_string(), \"\u2665\".to_string(), \"Rust\".to_string()];\n+    /// let is_ascii = strings.each_ref().map(|s| s.is_ascii());\n+    /// assert_eq!(is_ascii, [true, false, true]);\n+    ///\n+    /// // We can still access the original array: it has not been moved.\n+    /// assert_eq!(strings.len(), 3);\n+    /// ```\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn each_ref(&self) -> [&T; N] {\n+        // Unlike in `map`, we don't need a guard here, as dropping a reference\n+        // is a noop.\n+        let mut out = MaybeUninit::uninit_array::<N>();\n+        for (src, dst) in self.iter().zip(&mut out) {\n+            dst.write(src);\n+        }\n+\n+        // SAFETY: All elements of `dst` are properly initialized and\n+        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n+        unsafe { (&mut out as *mut _ as *mut [&T; N]).read() }\n+    }\n+\n+    /// Borrows each element mutably and returns an array of mutable references\n+    /// with the same size as `self`.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(array_methods)]\n+    ///\n+    /// let mut floats = [3.1, 2.7, -1.0];\n+    /// let float_refs: [&mut f64; 3] = floats.each_mut();\n+    /// *float_refs[0] = 0.0;\n+    /// assert_eq!(float_refs, [&mut 0.0, &mut 2.7, &mut -1.0]);\n+    /// assert_eq!(floats, [0.0, 2.7, -1.0]);\n+    /// ```\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn each_mut(&mut self) -> [&mut T; N] {\n+        // Unlike in `map`, we don't need a guard here, as dropping a reference\n+        // is a noop.\n+        let mut out = MaybeUninit::uninit_array::<N>();\n+        for (src, dst) in self.iter_mut().zip(&mut out) {\n+            dst.write(src);\n+        }\n+\n+        // SAFETY: All elements of `dst` are properly initialized and\n+        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n+        unsafe { (&mut out as *mut _ as *mut [&mut T; N]).read() }\n+    }\n }"}]}