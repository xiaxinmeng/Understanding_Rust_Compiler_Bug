{"sha": "42584d36f6a2d8021c0b642ec0cbf1afed750f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNTg0ZDM2ZjZhMmQ4MDIxYzBiNjQyZWMwY2JmMWFmZWQ3NTBmMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-21T22:12:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-21T22:12:43Z"}, "message": "Auto merge of #35777 - nrc:carrier3, r=@nikomatsakis\n\nCarrier trait (third attempt)\n\nThis adds a `Carrier` trait to operate with `?`. The only public implementation is for `Result`, so effectively the trait does not exist, however, it ensures future compatibility for the `?` operator. This is not intended to be used, nor is it intended to be a long-term solution.\n\nAlthough this exact PR has not been through Crater, I do not expect it to be a breaking change based on putting numerous similar PRs though Crater in the past.\n\ncc:\n* [? tracking issue](https://github.com/rust-lang/rust/issues/31436)\n* [previous PR](https://github.com/rust-lang/rust/pull/35056)\n* [RFC issue](https://github.com/rust-lang/rfcs/issues/1718) for discussion of long-term Carrier trait solutions.\n\nr? @nikomatsakis", "tree": {"sha": "f058fd1eb31f1fcfe507e35e887a917a487cb97c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f058fd1eb31f1fcfe507e35e887a917a487cb97c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42584d36f6a2d8021c0b642ec0cbf1afed750f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42584d36f6a2d8021c0b642ec0cbf1afed750f32", "html_url": "https://github.com/rust-lang/rust/commit/42584d36f6a2d8021c0b642ec0cbf1afed750f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42584d36f6a2d8021c0b642ec0cbf1afed750f32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1576de0ce6b75fd177eca289a2826d0190e407a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1576de0ce6b75fd177eca289a2826d0190e407a5", "html_url": "https://github.com/rust-lang/rust/commit/1576de0ce6b75fd177eca289a2826d0190e407a5"}, {"sha": "c32456da8f14a7c4206278c55b90a535c4d98e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32456da8f14a7c4206278c55b90a535c4d98e20", "html_url": "https://github.com/rust-lang/rust/commit/c32456da8f14a7c4206278c55b90a535c4d98e20"}], "stats": {"total": 306, "additions": 255, "deletions": 51}, "files": [{"sha": "3a2d6c8bcf7d6da82522f1b172b6fcdd73cd7608", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=42584d36f6a2d8021c0b642ec0cbf1afed750f32", "patch": "@@ -74,6 +74,7 @@\n use cmp::PartialOrd;\n use fmt;\n use marker::{Sized, Unsize};\n+use result::Result::{self, Ok, Err};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -2271,3 +2272,74 @@ pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n     /// Creates a globally fresh place.\n     fn make_place() -> Self;\n }\n+\n+/// A trait for types which have success and error states and are meant to work\n+/// with the question mark operator.\n+/// When the `?` operator is used with a value, whether the value is in the\n+/// success or error state is determined by calling `translate`.\n+///\n+/// This trait is **very** experimental, it will probably be iterated on heavily\n+/// before it is stabilised. Implementors should expect change. Users of `?`\n+/// should not rely on any implementations of `Carrier` other than `Result`,\n+/// i.e., you should not expect `?` to continue to work with `Option`, etc.\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+pub trait Carrier {\n+    /// The type of the value when computation succeeds.\n+    type Success;\n+    /// The type of the value when computation errors out.\n+    type Error;\n+\n+    /// Create a `Carrier` from a success value.\n+    fn from_success(Self::Success) -> Self;\n+\n+    /// Create a `Carrier` from an error value.\n+    fn from_error(Self::Error) -> Self;\n+\n+    /// Translate this `Carrier` to another implementation of `Carrier` with the\n+    /// same associated types.\n+    fn translate<T>(self) -> T where T: Carrier<Success=Self::Success, Error=Self::Error>;\n+}\n+\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl<U, V> Carrier for Result<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> Result<U, V> {\n+        Ok(u)\n+    }\n+\n+    fn from_error(e: V) -> Result<U, V> {\n+        Err(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            Ok(u) => T::from_success(u),\n+            Err(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+struct _DummyErrorType;\n+\n+impl Carrier for _DummyErrorType {\n+    type Success = ();\n+    type Error = ();\n+\n+    fn from_success(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+\n+    fn from_error(_: ()) -> _DummyErrorType {\n+        _DummyErrorType\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=(), Error=()>\n+    {\n+        T::from_success(())\n+    }\n+}"}, {"sha": "b45610c3fe820150bccc4f68a437991fc7887d7f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 81, "deletions": 49, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=42584d36f6a2d8021c0b642ec0cbf1afed750f32", "patch": "@@ -966,7 +966,7 @@ impl<'a> LoweringContext<'a> {\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.core_path(e.span, p);\n+                        let path = this.std_path(e.span, p);\n                         let path = this.expr_path(path, ThinVec::new());\n                         this.expr_call(e.span, path, args)\n                     };\n@@ -1159,15 +1159,13 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n-                        let strs = this.std_path(&iter::once(&\"ops\")\n-                                                        .chain(path)\n-                                                        .map(|s| *s)\n-                                                        .collect::<Vec<_>>());\n-\n-                        let structpath = this.path_global(ast_expr.span, strs);\n+                        let struct_path = this.std_path(ast_expr.span,\n+                                                        &iter::once(&\"ops\").chain(path)\n+                                                                           .map(|s| *s)\n+                                                                           .collect::<Vec<_>>());\n \n                         let hir_expr = if fields.len() == 0 {\n-                            this.expr_path(structpath, ast_expr.attrs.clone())\n+                            this.expr_path(struct_path, ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = this.lower_expr(&e);\n@@ -1180,7 +1178,7 @@ impl<'a> LoweringContext<'a> {\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_struct(ast_expr.span, structpath, fields, None, attrs)\n+                            this.expr_struct(ast_expr.span, struct_path, fields, None, attrs)\n                         };\n \n                         this.signal_block_expr(hir_vec![],\n@@ -1463,11 +1461,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n-                        let next_path = {\n-                            let strs = self.std_path(&[\"iter\", \"Iterator\", \"next\"]);\n-\n-                            self.path_global(e.span, strs)\n-                        };\n+                        let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n                         let iter = self.expr_ident(e.span, iter, iter_pat.id);\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n                         let next_path = self.expr_path(next_path, ThinVec::new());\n@@ -1494,11 +1488,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n-                        let into_iter_path = {\n-                            let strs = self.std_path(&[\"iter\", \"IntoIterator\", \"into_iter\"]);\n-\n-                            self.path_global(e.span, strs)\n-                        };\n+                        let into_iter_path = self.std_path(e.span,\n+                                                           &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n                         let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n                         self.expr_call(e.span, into_iter, hir_vec![head])\n@@ -1527,16 +1518,32 @@ impl<'a> LoweringContext<'a> {\n                     // to:\n                     //\n                     // {\n-                    //     match <expr> {\n+                    //     match { Carrier::translate( { <expr> } ) } {\n                     //         Ok(val) => val,\n-                    //         Err(err) => {\n-                    //             return Err(From::from(err))\n-                    //         }\n+                    //         Err(err) => { return Carrier::from_error(From::from(err)); }\n                     //     }\n                     // }\n \n-                    // expand <expr>\n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    // { Carrier::translate( { <expr> } ) }\n+                    let discr = {\n+                        // expand <expr>\n+                        let sub_expr = self.lower_expr(sub_expr);\n+                        let sub_expr = self.signal_block_expr(hir_vec![],\n+                                                              sub_expr,\n+                                                              e.span,\n+                                                              hir::PopUnstableBlock,\n+                                                              ThinVec::new());\n+\n+                        let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n+                        let path = self.expr_path(path, ThinVec::new());\n+                        let call = self.expr_call(e.span, path, hir_vec![sub_expr]);\n+\n+                        self.signal_block_expr(hir_vec![],\n+                                               call,\n+                                               e.span,\n+                                               hir::PushUnstableBlock,\n+                                               ThinVec::new())\n+                    };\n \n                     // Ok(val) => val\n                     let ok_arm = {\n@@ -1548,32 +1555,35 @@ impl<'a> LoweringContext<'a> {\n                         self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n-                    // Err(err) => return Err(From::from(err))\n+                    // Err(err) => { return Carrier::from_error(From::from(err)); }\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n-                            let path = self.path_global(e.span, path);\n+                            let path = self.std_path(e.span, &[\"convert\", \"From\", \"from\"]);\n                             let from = self.expr_path(path, ThinVec::new());\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n-                        let err_expr = {\n-                            let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n-                            let path = self.path_global(e.span, path);\n-                            let err_ctor = self.expr_path(path, ThinVec::new());\n-                            self.expr_call(e.span, err_ctor, hir_vec![from_expr])\n+                        let from_err_expr = {\n+                            let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n+                            let from_err = self.expr_path(path, ThinVec::new());\n+                            self.expr_call(e.span, from_err, hir_vec![from_expr])\n                         };\n-                        let err_pat = self.pat_err(e.span, err_local);\n+\n                         let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(err_expr)),\n-                                                 ThinVec::new());\n-                        self.arm(hir_vec![err_pat], ret_expr)\n+                                                 hir::Expr_::ExprRet(Some(from_err_expr)),\n+                                                                     ThinVec::new());\n+                        let ret_stmt = self.stmt_expr(ret_expr);\n+                        let block = self.signal_block_stmt(ret_stmt, e.span,\n+                                                           hir::PushUnstableBlock, ThinVec::new());\n+\n+                        let err_pat = self.pat_err(e.span, err_local);\n+                        self.arm(hir_vec![err_pat], block)\n                     };\n \n-                    return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                    return self.expr_match(e.span, discr, hir_vec![err_arm, ok_arm],\n                                            hir::MatchSource::TryDesugar);\n                 }\n \n@@ -1787,6 +1797,15 @@ impl<'a> LoweringContext<'a> {\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n     }\n \n+    // Turns `<expr>` into `<expr>;`, note that this produces a StmtSemi, not a\n+    // StmtExpr.\n+    fn stmt_expr(&self, expr: P<hir::Expr>) -> hir::Stmt {\n+        hir::Stmt {\n+            span: expr.span,\n+            node: hir::StmtSemi(expr, self.next_id()),\n+        }\n+    }\n+\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> P<hir::Block> {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n@@ -1803,26 +1822,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n-        let path = self.path_global(span, ok);\n+        let path = self.std_path(span, &[\"result\", \"Result\", \"Ok\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n-        let path = self.path_global(span, err);\n+        let path = self.std_path(span, &[\"result\", \"Result\", \"Err\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n-        let path = self.path_global(span, some);\n+        let path = self.std_path(span, &[\"option\", \"Option\", \"Some\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        let none = self.std_path(&[\"option\", \"Option\", \"None\"]);\n-        let path = self.path_global(span, none);\n+        let path = self.std_path(span, &[\"option\", \"Option\", \"None\"]);\n         self.pat_enum(span, path, hir_vec![])\n     }\n \n@@ -1920,7 +1935,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn std_path(&mut self, components: &[&str]) -> Vec<Name> {\n+    fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n             v.push(token::intern(s));\n@@ -1931,8 +1946,8 @@ impl<'a> LoweringContext<'a> {\n \n     // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n     // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    fn core_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n-        let idents = self.std_path(components);\n+    fn std_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n+        let idents = self.std_path_components(components);\n         self.path_global(span, idents)\n     }\n \n@@ -1953,4 +1968,21 @@ impl<'a> LoweringContext<'a> {\n         });\n         self.expr_block(block, attrs)\n     }\n+\n+    fn signal_block_stmt(&mut self,\n+                         stmt: hir::Stmt,\n+                         span: Span,\n+                         rule: hir::BlockCheckMode,\n+                         attrs: ThinVec<Attribute>)\n+                         -> P<hir::Expr> {\n+        let id = self.next_id();\n+        let block = P(hir::Block {\n+            rules: rule,\n+            span: span,\n+            id: id,\n+            stmts: hir_vec![stmt],\n+            expr: None,\n+        });\n+        self.expr_block(block, attrs)\n+    }\n }"}, {"sha": "8975a799be14328bd2ab057dbf7eafe5cf90e4e2", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=42584d36f6a2d8021c0b642ec0cbf1afed750f32", "patch": "@@ -151,13 +151,13 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         let b_ty = &b_subst.types[i];\n         let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n         relation.relate_with_variance(variance, a_ty, b_ty)\n-    }).collect()?;\n+    }).collect::<Result<_, _>>()?;\n \n     let regions = a_subst.regions.iter().enumerate().map(|(i, a_r)| {\n         let b_r = &b_subst.regions[i];\n         let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n         relation.relate_with_variance(variance, a_r, b_r)\n-    }).collect()?;\n+    }).collect::<Result<_, _>>()?;\n \n     Ok(Substs::new(tcx, types, regions))\n }"}, {"sha": "e15c9af41e0821c7de7329db350959fd00a12a64", "filename": "src/test/compile-fail/question-mark-type-infer.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Ftest%2Fcompile-fail%2Fquestion-mark-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Ftest%2Fcompile-fail%2Fquestion-mark-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fquestion-mark-type-infer.rs?ref=42584d36f6a2d8021c0b642ec0cbf1afed750f32", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(question_mark, question_mark_carrier)]\n+\n+// Test that type inference fails where there are multiple possible return types\n+// for the `?` operator.\n+\n+fn f(x: &i32) -> Result<i32, ()> {\n+    Ok(*x)\n+}\n+\n+fn g() -> Result<Vec<i32>, ()> {\n+    let l = [1, 2, 3, 4];\n+    l.iter().map(f).collect()? //~ ERROR type annotations required: cannot resolve\n+}\n+\n+fn main() {\n+    g();\n+}"}, {"sha": "577d19a58960da6382bb21ea20cd7aaf70aa7a91", "filename": "src/test/run-pass/try-operator-custom.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42584d36f6a2d8021c0b642ec0cbf1afed750f32/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs?ref=42584d36f6a2d8021c0b642ec0cbf1afed750f32", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(question_mark, question_mark_carrier)]\n+\n+use std::ops::Carrier;\n+\n+enum MyResult<T, U> {\n+    Awesome(T),\n+    Terrible(U)\n+}\n+\n+impl<U, V> Carrier for MyResult<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> MyResult<U, V> {\n+        MyResult::Awesome(u)\n+    }\n+\n+    fn from_error(e: V) -> MyResult<U, V> {\n+        MyResult::Terrible(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            MyResult::Awesome(u) => T::from_success(u),\n+            MyResult::Terrible(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+fn f(x: i32) -> Result<i32, String> {\n+    if x == 0 {\n+        Ok(42)\n+    } else {\n+        let y = g(x)?;\n+        Ok(y)\n+    }\n+}\n+\n+fn g(x: i32) -> MyResult<i32, String> {\n+    let _y = f(x - 1)?;\n+    MyResult::Terrible(\"Hello\".to_owned())\n+}\n+\n+fn h() -> MyResult<i32, String> {\n+    let a: Result<i32, &'static str> = Err(\"Hello\");\n+    let b = a?;\n+    MyResult::Awesome(b)\n+}\n+\n+fn i() -> MyResult<i32, String> {\n+    let a: MyResult<i32, &'static str> = MyResult::Terrible(\"Hello\");\n+    let b = a?;\n+    MyResult::Awesome(b)\n+}\n+\n+fn main() {\n+    assert!(f(0) == Ok(42));\n+    assert!(f(10) == Err(\"Hello\".to_owned()));\n+    let _ = h();\n+    let _ = i();\n+}"}]}