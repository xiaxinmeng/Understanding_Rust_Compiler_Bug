{"sha": "e74f6ff54fc6c0d266387a3f04730abd43d69901", "node_id": "C_kwDOAAsO6NoAKGU3NGY2ZmY1NGZjNmMwZDI2NjM4N2EzZjA0NzMwYWJkNDNkNjk5MDE", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T03:35:10Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T03:35:10Z"}, "message": "Fix rebase", "tree": {"sha": "58cbd2e06df0c49f366fccc694145ecd4aec0249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58cbd2e06df0c49f366fccc694145ecd4aec0249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e74f6ff54fc6c0d266387a3f04730abd43d69901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e74f6ff54fc6c0d266387a3f04730abd43d69901", "html_url": "https://github.com/rust-lang/rust/commit/e74f6ff54fc6c0d266387a3f04730abd43d69901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e74f6ff54fc6c0d266387a3f04730abd43d69901/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f3a7ed1ffc2787205bf64fc70cfa15640fba1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f3a7ed1ffc2787205bf64fc70cfa15640fba1e", "html_url": "https://github.com/rust-lang/rust/commit/78f3a7ed1ffc2787205bf64fc70cfa15640fba1e"}], "stats": {"total": 195, "additions": 96, "deletions": 99}, "files": [{"sha": "913f5734ff0d9265eb8c60f1a8ea780a7b955efc", "filename": "src/builder.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=e74f6ff54fc6c0d266387a3f04730abd43d69901", "patch": "@@ -455,12 +455,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let try_block = self.current_func().new_block(\"try\");\n \n         let current_block = self.block.clone();\n         self.block = try_block;\n-        let call = self.call(typ, func, args, None); // TODO(antoyo): use funclet here?\n+        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n         self.block = current_block;\n \n         let return_value = self.current_func()\n@@ -1210,23 +1210,20 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let zero = self.cx.context.new_rvalue_zero(self.int_type);\n         let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n \n-        let field1_type = self.u8_type.make_pointer();\n-        let field1 = self.context.new_field(None, field1_type, \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_2\");\n-        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n-        let value = self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\");\n-        let ptr = self.cx.context.new_cast(None, ptr, field1_type);\n-        self.block.add_assignment(None, value.access_field(None, field1), ptr);\n-        self.block.add_assignment(None, value.access_field(None, field2), zero); // TODO(antoyo): set the proper value here (the type of exception?).\n+        let value1_type = self.u8_type.make_pointer();\n+        let ptr = self.cx.context.new_cast(None, ptr, value1_type);\n+        let value1 = ptr;\n+        let value2 = zero; // TODO(antoyo): set the proper value here (the type of exception?).\n \n-        value.to_rvalue()\n+        (value1, value2)\n     }\n \n     #[cfg(not(feature=\"master\"))]\n     fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n-        let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n-        (field1, field2)\n+        let value1 = self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue();\n+        let value2 = self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue();\n+        (value1, value2)\n     }\n \n     #[cfg(feature=\"master\")]"}, {"sha": "661681bdb50f2f1094b0f18736ad43846110cc64", "filename": "src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=e74f6ff54fc6c0d266387a3f04730abd43d69901", "patch": "@@ -391,7 +391,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                             tcx,\n                             ty::ParamEnv::reveal_all(),\n                             def_id,\n-                            tcx.intern_substs(&[]),\n+                            ty::List::empty(),\n                         )\n                         .unwrap().unwrap();\n "}, {"sha": "2590e0e3af4443efca8bb055c363b26e002dc691", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=e74f6ff54fc6c0d266387a3f04730abd43d69901", "patch": "@@ -1202,21 +1202,21 @@ fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>,\n         let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n         let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n \n         // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n         // generate a try/catch.\n         // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n         bx.switch_to_block(current_block);\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n     });\n \n     let func = unsafe { std::mem::transmute(func) };\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, func, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1253,8 +1253,8 @@ fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut\n     )));\n     // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n     let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n-        [try_fn_ty, i8p, catch_fn_ty].iter(),\n-        &tcx.types.i32,\n+        [try_fn_ty, i8p, catch_fn_ty],\n+        tcx.types.i32,\n         false,\n         rustc_hir::Unsafety::Unsafe,\n         Abi::Rust,"}, {"sha": "fca59d50974f2a7936e1e9219689cfc9f25fa47a", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 79, "deletions": 75, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=e74f6ff54fc6c0d266387a3f04730abd43d69901", "patch": "@@ -4,6 +4,7 @@ use gccjit::{BinaryOp, RValue, Type};\n \n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::errors::{ExpectedPointerMutability, InvalidMonomorphization};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -295,11 +296,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             (Style::Unsupported, Style::Unsupported) => {\n                 require!(\n                     false,\n-                    \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-                    in_ty,\n-                    in_elem,\n-                    ret_ty,\n-                    out_elem\n+                    InvalidMonomorphization::UnsupportedCast {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty,\n+                        out_elem\n+                    }\n                 );\n             },\n             _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n@@ -362,7 +366,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             }\n             ty::Array(elem, len)\n                 if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n-                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n                         == Some(expected_bytes) =>\n             {\n                 // Zero-extend iN to the array length:\n@@ -375,12 +379,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -410,9 +415,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                     }\n                 }\n             }\n-        } else {\n-            return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n-        };\n+            else {\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n+            };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n \n@@ -560,27 +565,32 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -607,15 +617,15 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                    to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                        element_ty1,\n-                        arg_tys[1],\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n                         in_elem,\n                         in_ty,\n-                        element_ty1,\n-                        in_elem\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -631,10 +641,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                    to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -660,23 +672,25 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -707,15 +721,15 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                    to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                        element_ty1,\n-                        arg_tys[1],\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n                         in_elem,\n                         in_ty,\n-                        element_ty1,\n-                        in_elem\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -730,10 +744,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                    be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -816,18 +832,6 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 });\n             }\n         };\n-        let builtin_name =\n-            match (signed, is_add, in_len, elem_width) {\n-                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n-            };\n \n         let result =\n             match (signed, is_add) {"}, {"sha": "929499666173e2b4c2e5e78f7854e3cf63f1776c", "filename": "src/type_.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74f6ff54fc6c0d266387a3f04730abd43d69901/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=e74f6ff54fc6c0d266387a3f04730abd43d69901", "patch": "@@ -247,10 +247,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n-\n-    pub fn type_bool(&self) -> Type<'gcc> {\n-        self.context.new_type::<bool>()\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {"}]}