{"sha": "9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmN2FhN2ZhNzZiMjI5M2M5OTQ4ZDkyMTFkMzFlZWM3ZmQ1M2Q5YWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-10-31T08:51:16Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-11-19T04:24:35Z"}, "message": "rustc: middle: remove obsolete ty::get.", "tree": {"sha": "beed7322a9d90425c2ccd06546e2c0c005165923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beed7322a9d90425c2ccd06546e2c0c005165923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "html_url": "https://github.com/rust-lang/rust/commit/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01105ffde363bff46ebe16d032edb7a538609e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/01105ffde363bff46ebe16d032edb7a538609e18", "html_url": "https://github.com/rust-lang/rust/commit/01105ffde363bff46ebe16d032edb7a538609e18"}], "stats": {"total": 672, "additions": 326, "deletions": 346}, "files": [{"sha": "fce8627e226738b7b08e4e174a30b6e33f3b6d3d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -100,7 +100,7 @@ impl LintPass for UnusedCasts {\n         match e.node {\n             ast::ExprCast(ref expr, ref ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n-                if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n+                if ty::expr_ty(cx.tcx, &**expr) == t_t {\n                     cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n                 }\n             }\n@@ -156,7 +156,7 @@ impl LintPass for TypeLimits {\n                     },\n                     _ => {\n                         let t = ty::expr_ty(cx.tcx, &**expr);\n-                        match ty::get(t).sty {\n+                        match t.sty {\n                             ty::ty_uint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int variable may \\\n@@ -181,7 +181,7 @@ impl LintPass for TypeLimits {\n                 }\n \n                 if is_shift_binop(binop) {\n-                    let opt_ty_bits = match ty::get(ty::expr_ty(cx.tcx, &**l)).sty {\n+                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n                         ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n@@ -206,7 +206,7 @@ impl LintPass for TypeLimits {\n                 }\n             },\n             ast::ExprLit(ref lit) => {\n-                match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                match ty::expr_ty(cx.tcx, e).sty {\n                     ty::ty_int(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n@@ -344,7 +344,7 @@ impl LintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match ty::get(ty::expr_ty(tcx, expr)).sty {\n+            match ty::expr_ty(tcx, expr).sty {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -478,7 +478,7 @@ impl BoxPointers {\n                                  span: Span, ty: Ty<'tcx>) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_uniq(_) |\n                 ty::ty_closure(box ty::ClosureTy {\n                     store: ty::UniqTraitStore,\n@@ -578,7 +578,7 @@ impl LintPass for RawPointerDeriving {\n         }\n         let did = match item.node {\n             ast::ItemImpl(..) => {\n-                match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                match ty::node_id_to_type(cx.tcx, item.id).sty {\n                     ty::ty_enum(did, _) => did,\n                     ty::ty_struct(did, _) => did,\n                     _ => return,\n@@ -740,7 +740,7 @@ impl LintPass for UnusedResults {\n \n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => return,\n             ty::ty_bool => return,\n             ty::ty_struct(did, _) |"}, {"sha": "209e78682b418b3c5f77207c58c975770ae5a361", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -699,7 +699,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n-        let (ctor_ty, arg_tys) = match ty::get(ctor_ty).sty {\n+        let (ctor_ty, arg_tys) = match ctor_ty.sty {\n             ty::ty_bare_fn(ref f) =>\n                 (Some(ctor_ty), f.sig.inputs.clone()),\n             _ => // Nullary or struct enum variant."}, {"sha": "ea778d07e1c9d2b75b07258640ec1a0ddc7c8572", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -54,7 +54,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         None => {}\n     }\n     let pos = w.tell().unwrap();\n-    enc_sty(w, cx, &ty::get(t).sty);\n+    enc_sty(w, cx, &t.sty);\n     let end = w.tell().unwrap();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {"}, {"sha": "4caea5ae423bd096d3f87a4829dd369ce129ac13", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -146,7 +146,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n         mc::cat_downcast(ref b) |\n         mc::cat_interior(ref b, _) => {\n-            match ty::get(b.ty).sty {\n+            match b.ty.sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n                         Some(cmt.clone())"}, {"sha": "c7ffcc3ac1d1506078f4e30c7904fdc7127036a3", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -126,7 +126,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n         mc::cat_downcast(ref b) |\n         mc::cat_interior(ref b, _) => {\n-            match ty::get(b.ty).sty {\n+            match b.ty.sty {\n                 ty::ty_struct(did, _)\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err("}, {"sha": "fbb0a87cf3f873a02cfc657975fb325642a549dc", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         fn move_suggestion<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>,\n                                  default_msgs: (&'static str, &'static str))\n                                  -> (&'static str, &'static str) {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                 ty::ty_closure(box ty::ClosureTy {\n                         store: ty::RegionTraitStore(..),\n                         .."}, {"sha": "edc4e4ac7758b9b0060a4fb8b321e4f94b46b7b6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -406,7 +406,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                      pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n-    let pat = match ty::get(left_ty).sty {\n+    let pat = match left_ty.sty {\n         ty::ty_tup(_) => ast::PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n@@ -438,7 +438,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         }\n \n         ty::ty_rptr(_, ty::mt { ty, .. }) => {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n@@ -498,11 +498,11 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// the column of patterns being analyzed.\n fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: uint) -> Vec<Constructor> {\n-    match ty::get(left_ty).sty {\n+    match left_ty.sty {\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::ty_vec(_, None) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n             _ => vec!(Single)\n@@ -671,7 +671,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         ast::PatRange(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n         ast::PatVec(ref before, ref slice, ref after) =>\n-            match ty::get(left_ty).sty {\n+            match left_ty.sty {\n                 ty::ty_vec(_, Some(_)) => vec!(Single),\n                 _                      => if slice.is_some() {\n                     range_inclusive(before.len() + after.len(), max_slice_length)\n@@ -696,10 +696,10 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_uniq(_) => 1u,\n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::ty_vec(_, None) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0u,"}, {"sha": "afba72cea99a20de4b8ae118fe2a323dc244ed59", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n \n         let node_ty = ty::node_id_to_type(self.tcx, e.id);\n \n-        match ty::get(node_ty).sty {\n+        match node_ty.sty {\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,"}, {"sha": "c7c67e8a67b6142b017c9c3995bfecdb50213295", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -524,7 +524,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                     $const_type:ident,\n                     $target_ty:ty\n                 )),*\n-            }) => (match ty::get(ety).sty {\n+            }) => (match ety.sty {\n                 $($ty_pat => {\n                     match $val {\n                         const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),"}, {"sha": "62a5d23e3332cb839c69cc3b2daefe3022ca91ce", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: &ast::Ident) {\n-        match ty::get(ty::expr_ty_adjusted(self.tcx, lhs)).sty {\n+        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields.iter()\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: uint) {\n-        match ty::get(ty::expr_ty_adjusted(self.tcx, lhs)).sty {\n+        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields[idx].id;"}, {"sha": "71885a769f580e452cc3a69fee7a86a25e98c42e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -31,7 +31,7 @@ enum UnsafeContext {\n }\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_bare_fn(ref f) => f.fn_style == ast::UnsafeFn,\n         ty::ty_closure(ref f) => f.fn_style == ast::UnsafeFn,\n         _ => false,\n@@ -70,8 +70,8 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         };\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_string(self.tcx, base_type));\n-        match ty::get(base_type).sty {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+        match base_type.sty {\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n                 ty::ty_str => {\n                     span_err!(self.tcx.sess, e.span, E0134,\n                               \"modification of string types is not allowed\");\n@@ -166,7 +166,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_string(self.tcx, base_type));\n-                match ty::get(base_type).sty {\n+                match base_type.sty {\n                     ty::ty_ptr(_) => {\n                         self.require_unsafe(expr.span,\n                                             \"dereference of unsafe pointer\")"}, {"sha": "f4c22c571639001b2dd89b338202d6d9e49bef59", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -519,7 +519,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let callee_ty = ty::expr_ty_adjusted(self.tcx(), callee);\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n-        match ty::get(callee_ty).sty {\n+        match callee_ty.sty {\n             ty::ty_bare_fn(..) => {\n                 self.consume_expr(callee);\n             }\n@@ -656,7 +656,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        let with_fields = match ty::get(with_cmt.ty).sty {\n+        let with_fields = match with_cmt.ty.sty {\n             ty::ty_struct(did, ref substs) => {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n@@ -745,7 +745,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n-                    let (m, r) = match ty::get(self_ty).sty {\n+                    let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\","}, {"sha": "7514a63c7fa58f5bfd1186da8c6fde92e521eed0", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -53,7 +53,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n      * are to be considered bound.\n      */\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_bool => Some(BoolSimplifiedType),\n         ty::ty_char => Some(CharSimplifiedType),\n         ty::ty_int(int_type) => Some(IntSimplifiedType(int_type)),"}, {"sha": "68d0ac932164a4272b55cd302cb3a43e378e207c", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -27,7 +27,7 @@ fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<\n                                                   -> bool {\n     let mut result = false;\n     ty::maybe_walk_ty(typ, |typ| {\n-        match ty::get(typ).sty {\n+        match typ.sty {\n             ty::ty_uniq(_) | ty::ty_ptr(_) | ty::ty_rptr(..) |\n             ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n                 false\n@@ -73,7 +73,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match ty::get(ty::lookup_item_type(self.tcx, def_id).ty).sty {\n+        let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n             ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n@@ -123,7 +123,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 match ty::resolve_expr(self.tcx, expr) {\n                     DefFn(did, _) if self.def_id_is_transmute(did) => {\n                         let typ = ty::node_id_to_type(self.tcx, expr.id);\n-                        match ty::get(typ).sty {\n+                        match typ.sty {\n                             ty_bare_fn(ref bare_fn_ty)\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n                                 if let ty::FnConverging(to) = bare_fn_ty.sig.output {"}, {"sha": "82edfdf146eaefa70de2e0fb45ad1dc1d831fd44", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -1520,7 +1520,7 @@ fn check_fn(_v: &Liveness,\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n-        match ty::get(fn_ty).sty {\n+        match fn_ty.sty {\n             ty::ty_unboxed_closure(closure_def_id, _, _) =>\n                 self.ir.tcx.unboxed_closures()\n                     .borrow()\n@@ -1550,8 +1550,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         None if body.stmts.len() > 0 =>\n                             match body.stmts.last().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n-                                    let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n-                                    ty::get(t_stmt).sty == ty::get(t_ret).sty\n+                                    ty::expr_ty(self.ir.tcx, &**e) == t_ret\n                                 },\n                                 _ => false\n                             },"}, {"sha": "93c2e8f0d9933e9bc557a56eefec09737cf65d35", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -197,7 +197,7 @@ pub enum deref_kind {\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n@@ -585,7 +585,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n-              match ty::get(ty).sty {\n+              match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n                       // closure kind/capture mode\n@@ -808,7 +808,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                            -> cmt<'tcx> {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n-                match ty::get(expr_ty).sty {\n+                match expr_ty.sty {\n                     ty::ty_vec(_, Some(0)) => self.cat_rvalue(id, span, ty::ReStatic, expr_ty),\n                     _ => self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n                 }\n@@ -1069,8 +1069,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n              * to recurse through rptrs.\n              */\n \n-            match ty::get(slice_ty).sty {\n-                ty::ty_rptr(r, ref mt) => match ty::get(mt.ty).sty {\n+            match slice_ty.sty {\n+                ty::ty_rptr(r, ref mt) => match mt.ty.sty {\n                     ty::ty_vec(_, None) => (mt.mutbl, r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n@@ -1533,9 +1533,9 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n }\n \n fn element_kind(t: Ty) -> ElementKind {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_rptr(_, ty::mt{ty, ..}) |\n-        ty::ty_uniq(ty) => match ty::get(ty).sty {\n+        ty::ty_uniq(ty) => match ty.sty {\n             ty::ty_vec(_, None) => VecElement,\n             _ => OtherElement\n         },"}, {"sha": "c2835ba5647e8a91ab1c79b20c1c6d2164045899", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -667,7 +667,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         }\n \n         let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n-        let struct_desc = match ty::get(struct_type).sty {\n+        let struct_desc = match struct_type.sty {\n             ty::ty_struct(_, _) =>\n                 format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n             // struct variant fields have inherited visibility\n@@ -837,15 +837,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n+                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, NamedField(ident.node));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::ExprTupField(ref base, idx, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n+                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, UnnamedField(idx.node));\n                     }\n@@ -867,7 +867,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n+                match ty::expr_ty(self.tcx, expr).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n                             self.check_field(expr.span, id,\n@@ -976,7 +976,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n                             self.check_field(pattern.span, id,\n@@ -1007,7 +1007,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n-                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             match field.node {"}, {"sha": "bac417c8218a4383ab0f0bce396c3119bb6d5af9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -641,7 +641,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n         self.ty_stack_depth += 1;\n \n-        let t1 = match ty::get(t).sty {\n+        let t1 = match t.sty {\n             ty::ty_param(p) => {\n                 self.ty_for_param(p, t)\n             }"}, {"sha": "c84a2a0d11e6b3b01a3c20a67899e21cb945ee39", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -79,7 +79,7 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |"}, {"sha": "b884cb535d7a5de9488ac78b33eb4ca2be92fc6e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -1030,7 +1030,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let (closure_def_id, substs) = match ty::get(self_ty).sty {\n+        let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_unboxed_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true;\n@@ -1233,7 +1233,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n         let self_ty = self.infcx.shallow_resolve(self_ty);\n-        return match ty::get(self_ty).sty {\n+        return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n             ty::ty_uint(_) |"}, {"sha": "eb1fe227084c51bf0ad143527a9a8a99b423c9a3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 80, "deletions": 91, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -653,28 +653,21 @@ impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n     }\n }\n \n-pub fn get<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    ty\n-}\n-\n-pub fn tbox_has_flag(tb: &TyS, flag: TypeFlags) -> bool {\n-    tb.flags.intersects(flag)\n-}\n pub fn type_has_params(ty: Ty) -> bool {\n-    tbox_has_flag(get(ty), HAS_PARAMS)\n+    ty.flags.intersects(HAS_PARAMS)\n }\n pub fn type_has_self(ty: Ty) -> bool {\n-    tbox_has_flag(get(ty), HAS_SELF)\n+    ty.flags.intersects(HAS_SELF)\n }\n pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    tbox_has_flag(get(ty), HAS_TY_INFER)\n+    ty.flags.intersects(HAS_TY_INFER)\n }\n pub fn type_needs_infer(ty: Ty) -> bool {\n-    tbox_has_flag(get(ty), HAS_TY_INFER | HAS_RE_INFER)\n+    ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n }\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    get(ty).flags.intersects(HAS_RE_LATE_BOUND)\n+    ty.flags.intersects(HAS_RE_LATE_BOUND)\n }\n \n pub fn type_has_escaping_regions(ty: Ty) -> bool {\n@@ -714,7 +707,7 @@ pub fn type_has_escaping_regions(ty: Ty) -> bool {\n }\n \n pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n-    get(ty).region_depth > depth\n+    ty.region_depth > depth\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -1929,9 +1922,8 @@ impl FlagComputation {\n     }\n \n     fn add_ty(&mut self, ty: Ty) {\n-        let t_box = get(ty);\n-        self.add_flags(t_box.flags);\n-        self.add_depth(t_box.region_depth);\n+        self.add_flags(ty.flags);\n+        self.add_depth(ty.region_depth);\n     }\n \n     fn add_tys(&mut self, tys: &[Ty]) {\n@@ -2211,7 +2203,7 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n     if !f(ty) {\n         return;\n     }\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n@@ -2302,43 +2294,43 @@ impl<'tcx> ParamBounds<'tcx> {\n // Type utilities\n \n pub fn type_is_nil(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_tup(ref tys) => tys.is_empty(),\n         _ => false\n     }\n }\n \n pub fn type_is_error(ty: Ty) -> bool {\n-    get(ty).flags.intersects(HAS_TY_ERR)\n+    ty.flags.intersects(HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: Ty) -> bool {\n-    tbox_has_flag(get(ty), NEEDS_SUBST)\n+    ty.flags.intersects(NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n     tref.substs.types.any(|&ty| type_is_error(ty))\n }\n \n pub fn type_is_ty_var(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_infer(TyVar(_)) => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_bool(ty: Ty) -> bool { get(ty).sty == ty_bool }\n+pub fn type_is_bool(ty: Ty) -> bool { ty.sty == ty_bool }\n \n pub fn type_is_self(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_param(ref p) => p.space == subst::SelfSpace,\n         _ => false\n     }\n }\n \n fn type_is_slice(ty: Ty) -> bool {\n-    match get(ty).sty {\n-        ty_ptr(mt) | ty_rptr(_, mt) => match get(mt.ty).sty {\n+    match ty.sty {\n+        ty_ptr(mt) | ty_rptr(_, mt) => match mt.ty.sty {\n             ty_vec(_, None) | ty_str => true,\n             _ => false,\n         },\n@@ -2347,10 +2339,10 @@ fn type_is_slice(ty: Ty) -> bool {\n }\n \n pub fn type_is_vec(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_vec(..) => true,\n         ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..}) |\n-        ty_uniq(ty) => match get(ty).sty {\n+        ty_uniq(ty) => match ty.sty {\n             ty_vec(_, None) => true,\n             _ => false\n         },\n@@ -2359,22 +2351,22 @@ pub fn type_is_vec(ty: Ty) -> bool {\n }\n \n pub fn type_is_structural(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n       ty_vec(_, Some(_)) | ty_unboxed_closure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n \n pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n     }\n }\n \n pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n@@ -2384,7 +2376,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n }\n \n pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n@@ -2394,7 +2386,7 @@ pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n }\n \n pub fn simd_size(cx: &ctxt, ty: Ty) -> uint {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n@@ -2404,22 +2396,22 @@ pub fn simd_size(cx: &ctxt, ty: Ty) -> uint {\n }\n \n pub fn type_is_region_ptr(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_rptr(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_unsafe_ptr(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n pub fn type_is_unique(ty: Ty) -> bool {\n-    match get(ty).sty {\n-        ty_uniq(_) => match get(ty).sty {\n+    match ty.sty {\n+        ty_uniq(_) => match ty.sty {\n             ty_trait(..) => false,\n             _ => true\n         },\n@@ -2428,7 +2420,7 @@ pub fn type_is_unique(ty: Ty) -> bool {\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n         | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n         _ => false,\n@@ -2441,7 +2433,7 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n  contents are abstract to rustc.)\n */\n pub fn type_is_scalar(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n@@ -2452,7 +2444,7 @@ pub fn type_is_scalar(ty: Ty) -> bool {\n \n /// Returns true if this type is a floating point type and false otherwise.\n pub fn type_is_floating_point(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_float(_) => true,\n         _ => false,\n     }\n@@ -2480,7 +2472,7 @@ pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         let mut needs_unwind_cleanup = false;\n         maybe_walk_ty(ty, |ty| {\n-            needs_unwind_cleanup |= match get(ty).sty {\n+            needs_unwind_cleanup |= match ty.sty {\n                 ty_bool | ty_int(_) | ty_uint(_) |\n                 ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n@@ -2732,7 +2724,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         }\n         cache.insert(ty, TC::None);\n \n-        let result = match get(ty).sty {\n+        let result = match ty.sty {\n             // uint and int are ffi-unsafe\n             ty_uint(ast::TyU) | ty_int(ast::TyI) => {\n                 TC::ReachesFfiUnsafe\n@@ -2750,7 +2742,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_uniq(typ) => {\n-                TC::ReachesFfiUnsafe | match get(typ).sty {\n+                TC::ReachesFfiUnsafe | match typ.sty {\n                     ty_str => TC::OwnsOwned,\n                     _ => tc_ty(cx, typ, cache).owned_pointer(),\n                 }\n@@ -2765,7 +2757,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_rptr(r, ref mt) => {\n-                TC::ReachesFfiUnsafe | match get(mt.ty).sty {\n+                TC::ReachesFfiUnsafe | match mt.ty.sty {\n                     ty_str => borrowed_contents(r, ast::MutImmutable),\n                     ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n                     _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n@@ -2852,7 +2844,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                                 }\n \n                                 if variants[data_idx].args.len() == 1 {\n-                                    match get(variants[data_idx].args[0]).sty {\n+                                    match variants[data_idx].args[0].sty {\n                                         ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n                                         _ => { }\n                                     }\n@@ -3026,10 +3018,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n-        let r = {\n-            get(r_ty).sty == get(ty).sty ||\n-                subtypes_require(cx, seen, r_ty, ty)\n-        };\n+        let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n         debug!(\"type_requires({}, {})? {}\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n@@ -3044,7 +3033,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n \n-        let r = match get(ty).sty {\n+        let r = match ty.sty {\n             // fixed length vectors need special treatment compared to\n             // normal vectors, since they don't necessarily have the\n             // possibility to have length zero.\n@@ -3163,7 +3152,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn are_inner_types_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                        seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                        -> Representability {\n-        match get(ty).sty {\n+        match ty.sty {\n             ty_tup(ref ts) => {\n                 find_nonrepresentable(cx, sp, seen, ts.iter().map(|ty| *ty))\n             }\n@@ -3193,7 +3182,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     }\n \n     fn same_struct_or_enum_def_id(ty: Ty, did: DefId) -> bool {\n-        match get(ty).sty {\n+        match ty.sty {\n             ty_struct(ty_did, _) | ty_enum(ty_did, _) => {\n                  ty_did == did\n             }\n@@ -3202,7 +3191,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     }\n \n     fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match (&get(a).sty, &get(b).sty) {\n+        match (&a.sty, &b.sty) {\n             (&ty_struct(did_a, ref substs_a), &ty_struct(did_b, ref substs_b)) |\n             (&ty_enum(did_a, ref substs_a), &ty_enum(did_b, ref substs_b)) => {\n                 if did_a != did_b {\n@@ -3230,7 +3219,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         debug!(\"is_type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_string(cx, ty));\n \n-        match get(ty).sty {\n+        match ty.sty {\n             ty_struct(did, _) | ty_enum(did, _) => {\n                 {\n                     // Iterate through stack of previously seen types.\n@@ -3307,8 +3296,8 @@ pub fn type_is_trait(ty: Ty) -> bool {\n }\n \n pub fn type_trait_info<'tcx>(ty: Ty<'tcx>) -> Option<&'tcx TyTrait<'tcx>> {\n-    match get(ty).sty {\n-        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n+    match ty.sty {\n+        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match ty.sty {\n             ty_trait(ref t) => Some(&**t),\n             _ => None\n         },\n@@ -3318,43 +3307,43 @@ pub fn type_trait_info<'tcx>(ty: Ty<'tcx>) -> Option<&'tcx TyTrait<'tcx>> {\n }\n \n pub fn type_is_integral(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_skolemized(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_infer(SkolemizedTy(_)) => true,\n       ty_infer(SkolemizedIntTy(_)) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_uint(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_char(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_char => true,\n         _ => false\n     }\n }\n \n pub fn type_is_bare_fn(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_bare_fn(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_fp(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_infer(FloatVar(_)) | ty_float(_) => true,\n       _ => false\n     }\n@@ -3365,14 +3354,14 @@ pub fn type_is_numeric(ty: Ty) -> bool {\n }\n \n pub fn type_is_signed(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n       ty_int(_) => true,\n       _ => false\n     }\n }\n \n pub fn type_is_machine(ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_int(ast::TyI) | ty_uint(ast::TyU) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n@@ -3385,7 +3374,7 @@ pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_open(_) => true,\n         _ => type_contents(cx, ty).is_sized(cx)\n     }\n@@ -3395,7 +3384,7 @@ pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n         ty_struct(def_id, ref substs) => {\n             let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n@@ -3416,7 +3405,7 @@ pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n             if variants.len() == 0 {\n@@ -3434,7 +3423,7 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_uniq(ty) => {\n             Some(mt {\n                 ty: ty,\n@@ -3448,23 +3437,23 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n }\n \n pub fn deref_or_dont<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n         _ => ty\n     }\n }\n \n pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n                                  ty_to_string(cx, ty)).as_slice())\n     }\n }\n \n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n         _ => ty\n@@ -3473,15 +3462,15 @@ pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n \n // Extract the unsized type in an open type (or just return ty if it is not open).\n pub fn unopen_type<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_open(ty) => ty,\n         _ => ty\n     }\n }\n \n // Returns the type of ty[i]\n pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_vec(ty, _) => Some(ty),\n         _ => None\n     }\n@@ -3491,7 +3480,7 @@ pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_vec(ty, _) => Some(ty),\n         ty_str => Some(mk_u8()),\n         _ => None\n@@ -3536,7 +3525,7 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n }\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_bare_fn(ref f) => f.sig.variadic,\n         ty_closure(ref f) => f.sig.variadic,\n         ref s => {\n@@ -3546,7 +3535,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n }\n \n pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx FnSig<'tcx> {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_bare_fn(ref f) => &f.sig,\n         ty_closure(ref f) => &f.sig,\n         ref s => {\n@@ -3557,7 +3546,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx FnSig<'tcx> {\n \n /// Returns the ABI of the given function.\n pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_bare_fn(ref f) => f.abi,\n         ty_closure(ref f) => f.abi,\n         _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n@@ -3570,7 +3559,7 @@ pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_closure(ref f) => f.store,\n         ty_unboxed_closure(..) => {\n             // Close enough for the purposes of all the callers of this\n@@ -3584,7 +3573,7 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n }\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n@@ -3594,7 +3583,7 @@ pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n }\n \n pub fn is_fn_ty(fty: Ty) -> bool {\n-    match get(fty).sty {\n+    match fty.sty {\n         ty_bare_fn(_) => true,\n         ty_closure(_) => true,\n         _ => false\n@@ -3604,7 +3593,7 @@ pub fn is_fn_ty(fty: Ty) -> bool {\n pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: Ty) -> Region {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_rptr(r, _) => r,\n         ref s => {\n             tcx.sess.span_bug(\n@@ -3716,7 +3705,7 @@ pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n                        -> Ty<'tcx> {\n     /*! See `expr_ty_adjusted` */\n \n-    match get(unadjusted_ty).sty {\n+    match unadjusted_ty.sty {\n         ty_err => return unadjusted_ty,\n         _ => {}\n     }\n@@ -3725,7 +3714,7 @@ pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n         Some(adjustment) => {\n             match *adjustment {\n                 AdjustAddEnv(store) => {\n-                    match ty::get(unadjusted_ty).sty {\n+                    match unadjusted_ty.sty {\n                         ty::ty_bare_fn(ref b) => {\n                             let bounds = ty::ExistentialBounds {\n                                 region_bound: ReStatic,\n@@ -3829,7 +3818,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                        span: Span)\n                        -> Ty<'tcx> {\n     match kind {\n-        &UnsizeLength(len) => match get(ty).sty {\n+        &UnsizeLength(len) => match ty.sty {\n             ty_vec(ty, Some(n)) => {\n                 assert!(len == n);\n                 mk_vec(cx, ty, None)\n@@ -3838,7 +3827,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n                                           ty_to_string(cx, ty)).as_slice())\n         },\n-        &UnsizeStruct(box ref k, tp_index) => match get(ty).sty {\n+        &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, ref substs) => {\n                 let ty_substs = substs.types.get_slice(subst::TypeSpace);\n                 let new_ty = unsize_ty(cx, ty_substs[tp_index], k, span);\n@@ -3925,7 +3914,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 }\n \n                 def::DefStruct(_) => {\n-                    match get(expr_ty(tcx, expr)).sty {\n+                    match expr_ty(tcx, expr).sty {\n                         ty_bare_fn(..) => RvalueDatumExpr,\n                         _ => RvalueDpsExpr\n                     }\n@@ -4089,7 +4078,7 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n }\n \n pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_string(cx, ty)\n@@ -4529,7 +4518,7 @@ pub fn try_add_builtin_trait(\n }\n \n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n-    match get(ty).sty {\n+    match ty.sty {\n         ty_trait(ref tt) =>\n             Some(tt.principal.def_id),\n         ty_struct(id, _) |\n@@ -4684,7 +4673,7 @@ pub fn enum_is_univariant(cx: &ctxt, id: ast::DefId) -> bool {\n }\n \n pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n@@ -5108,7 +5097,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n-        match get(ty).sty {\n+        match ty.sty {\n           ty_char => tycat_char,\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n@@ -5534,7 +5523,7 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n         mt.mutbl.hash(state);\n     };\n     ty::walk_ty(ty, |ty| {\n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty_bool => byte!(2),\n             ty_char => byte!(3),\n             ty_int(i) => {\n@@ -5870,7 +5859,7 @@ pub enum ExplicitSelfCategory {\n pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                                     ty: Ty) {\n     walk_ty(ty, |ty| {\n-        match get(ty).sty {\n+        match ty.sty {\n             ty_rptr(region, _) => {\n                 accumulator.push(region)\n             }"}, {"sha": "913919fe774f341f0a7320347904dc2d72565d8d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -490,7 +490,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                 t: Ty<'tcx>)\n                                                 -> Ty<'tcx> {\n-    let sty = ty::get(t).sty.fold_with(this);\n+    let sty = t.sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n "}, {"sha": "ea652bc7e6599cc393b06e7135277d0a89d48562", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -667,7 +667,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 def::DefTy(did, _) |\n                 def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n                     let ty = ast_path_to_ty(this, rscope, did, path).ty;\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty::ty_struct(struct_def_id, ref substs) => {\n                             assert_eq!(struct_def_id, did);\n                             assert_eq!(substs.types.len(TypeSpace), 1);\n@@ -1294,7 +1294,7 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n             if impl_modifiers >= method_modifiers {\n                 ty::ByValueExplicitSelfCategory\n             } else {\n-                match ty::get(explicit_type).sty {\n+                match explicit_type.sty {\n                     ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n                     ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n@@ -1304,7 +1304,7 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n     };\n \n     fn count_modifiers(ty: Ty) -> uint {\n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n             ty::ty_uniq(t) => count_modifiers(t) + 1,\n             _ => 0,"}, {"sha": "92b30cd7af8f76e97d1288ab41602dda11fdee14", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -165,7 +165,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n-            let pat_ty = match ty::get(expected_ty).sty {\n+            let pat_ty = match expected_ty.sty {\n                 ty::ty_vec(_, Some(size)) => ty::mk_vec(tcx, inner_ty, Some({\n                     let min_len = before.len() + after.len();\n                     match *slice {\n@@ -217,7 +217,7 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         fcx.infcx(), Some(span),\n         expected, resolve::try_resolve_tvar_shallow) {\n         Ok(t) if pat_is_binding(&tcx.def_map, inner) => {\n-            ty::deref(t, true).map_or(true, |mt| match ty::get(mt.ty).sty {\n+            ty::deref(t, true).map_or(true, |mt| match mt.ty.sty {\n                 ty::ty_trait(_) => {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n@@ -313,7 +313,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n         },\n         _ => {\n             let def_type = ty::lookup_item_type(tcx, def.def_id());\n-            match ty::get(def_type.ty).sty {\n+            match def_type.ty.sty {\n                 ty::ty_struct(struct_def_id, _) =>\n                     (struct_def_id, struct_def_id),\n                 ty::ty_enum(enum_def_id, _)\n@@ -378,7 +378,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n     let real_path_ty = fcx.node_ty(pat.id);\n-    let (arg_tys, kind_name) = match ty::get(real_path_ty).sty {\n+    let (arg_tys, kind_name) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, ref expected_substs) => {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n             (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),"}, {"sha": "af8ef09d2a072865fae7816f499d68de6a32dde6", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -305,7 +305,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             check::autoderef(\n                 self.fcx, self.span, self_ty, None, NoPreference,\n                 |ty, _| {\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n                         _ => None,\n                     }\n@@ -482,13 +482,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n          * `DerefMut` and `IndexMut` respectively.\n          */\n \n-        let sig = match ty::get(method_callee.ty).sty {\n+        let sig = match method_callee.ty.sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n             _ => return,\n         };\n \n-        match ty::get(sig.inputs[0]).sty {\n+        match sig.inputs[0].sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,"}, {"sha": "411948ed6b4acffd44da09d70c5d84dd9d39fac7", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -262,7 +262,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                 ty::ByReferenceExplicitSelfCategory(..) => {\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n-                    match ty::get(transformed_self_ty).sty {\n+                    match transformed_self_ty.sty {\n                         ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n                             let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n                             let autoref = autoref.map(|r| box r);\n@@ -321,7 +321,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // True if the type is a struct and contains a field with\n             // the same name as the not-found method\n-            let is_field = match ty::get(rcvr_ty).sty {\n+            let is_field = match rcvr_ty.sty {\n                 ty_struct(did, _) =>\n                     ty::lookup_struct_fields(cx, did)\n                         .iter()"}, {"sha": "a98b4cf011d97e38f1a9b4eb414a813c2349e455", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -173,7 +173,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None::<()> // keep iterating until we can't anymore\n             });\n \n-    match ty::get(fully_dereferenced_ty).sty {\n+    match fully_dereferenced_ty.sty {\n         ty::ty_vec(elem_ty, Some(len)) => {\n             steps.push(CandidateStep {\n                 self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),\n@@ -186,9 +186,9 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     return steps;\n \n-    fn consider_reborrow(t: Ty, d: uint) -> PickAdjustment {\n+    fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n         // Insert a `&*` or `&mut *` if this is a reference type:\n-        match ty::get(t).sty {\n+        match ty.sty {\n             ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n             _ => AutoDeref(d),\n         }\n@@ -238,7 +238,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_probe: self_ty={}\",\n                self_ty.repr(self.tcx()));\n \n-        match ty::get(self_ty).sty {\n+        match self_ty.sty {\n             ty::ty_trait(box ty::TyTrait { ref principal, bounds, .. }) => {\n                 self.assemble_inherent_candidates_from_object(self_ty, &*principal, bounds);\n                 self.assemble_inherent_impl_candidates_for_type(principal.def_id);\n@@ -562,7 +562,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            let (closure_def_id, _, _) = match ty::get(step.self_ty).sty {\n+            let (closure_def_id, _, _) = match step.self_ty.sty {\n                 ty::ty_unboxed_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n             };\n@@ -638,7 +638,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // FIXME -- Super hack. For DST types, we will convert to\n         // &&[T] or &&str, as part of a kind of legacy lookup scheme.\n-        match ty::get(step.self_ty).sty {\n+        match step.self_ty.sty {\n             ty::ty_str | ty::ty_vec(_, None) => self.pick_autorefrefd_method(step),\n             _ => None\n         }"}, {"sha": "543eb44697c06ce5fdaaa5c79293326b1330685c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -405,7 +405,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // (replace any type-scheme with a type)\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n \n-    match ty::get(fty).sty {\n+    match fty.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n             let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n@@ -1436,7 +1436,7 @@ fn check_cast(fcx: &FnCtxt,\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n         }, t_e, None);\n-        match ty::get(t_e).sty {\n+        match t_e.sty {\n             ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n                     ast::MutMutable => \"mut \",\n@@ -1505,19 +1505,19 @@ fn check_cast(fcx: &FnCtxt,\n         // casts from C-like enums are allowed\n     } else if t_1_is_char {\n         let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n+        if t_e.sty != ty::ty_uint(ast::TyU8) {\n             fcx.type_error_message(span, |actual| {\n                 format!(\"only `u8` can be cast as \\\n                          `char`, not `{}`\", actual)\n             }, t_e, None);\n         }\n-    } else if ty::get(t_1).sty == ty::ty_bool {\n+    } else if t_1.sty == ty::ty_bool {\n         span_err!(fcx.tcx().sess, span, E0054,\n             \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n         fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                                       t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n-            match ty::get(t1).sty {\n+            match t1.sty {\n                 ty::ty_vec(_, Some(_)) => {}\n                 _ => return false\n             }\n@@ -1545,7 +1545,7 @@ fn check_cast(fcx: &FnCtxt,\n \n         /* this cast is only allowed from &[T, ..n] to *T or\n         &T to *T. */\n-        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n+        match (&t_e.sty, &t_1.sty) {\n             (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n              &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n             if types_compatible(fcx, e.span, mt1, mt2) => {\n@@ -2370,7 +2370,7 @@ fn autoderef_for_index<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n     // do a final unsized coercion to yield [T].\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_vec(element_ty, Some(n)) => {\n             let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n             let autoderefref = ty::AutoDerefRef {\n@@ -2653,7 +2653,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     structurally_resolved_type(fcx, iterator_expr.span, return_type),\n                 ty::FnDiverging => ty::mk_err()\n             };\n-            match ty::get(return_type).sty {\n+            match return_type.sty {\n                 ty::ty_enum(_, ref substs)\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n@@ -2695,7 +2695,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              tuple_arguments);\n         ty::FnConverging(ty::mk_err())\n     } else {\n-        match ty::get(method_fn_ty).sty {\n+        match method_fn_ty.sty {\n             ty::ty_bare_fn(ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n@@ -2743,7 +2743,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let expected_arg_count = fn_inputs.len();\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n-        match ty::get(tuple_type).sty {\n+        match tuple_type.sty {\n             ty::ty_tup(ref arg_types) => {\n                 if arg_types.len() != args.len() {\n                     span_err!(tcx.sess, sp, E0057,\n@@ -2834,7 +2834,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                 match deref_args {\n                     DoDerefArgs => {\n-                        match ty::get(formal_ty).sty {\n+                        match formal_ty.sty {\n                             ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                             ty::ty_err => (),\n                             _ => {\n@@ -2866,7 +2866,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n                                                     fcx.expr_ty(&***arg));\n-            match ty::get(arg_ty).sty {\n+            match arg_ty.sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n                                            |t| {\n@@ -3298,7 +3298,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 //   could also solve this with variance or different\n                 //   traits that don't force left and right to have same\n                 //   type.\n-                let (adj_ty, adjustment) = match ty::get(lhs_ty).sty {\n+                let (adj_ty, adjustment) = match lhs_ty.sty {\n                     ty::ty_rptr(r_in, mt) => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n                         fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n@@ -3700,7 +3700,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n-                match ty::get(base_t).sty {\n+                match base_t.sty {\n                     ty::ty_struct(base_id, ref substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n@@ -3761,7 +3761,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n-                match ty::get(base_t).sty {\n+                match base_t.sty {\n                     ty::ty_struct(base_id, ref substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n@@ -4092,7 +4092,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                            Some(&**oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n-                                let is_newtype = match ty::get(oprnd_t).sty {\n+                                let is_newtype = match oprnd_t.sty {\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n@@ -4121,7 +4121,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n-                         ty::get(oprnd_t).sty == ty::ty_bool) {\n+                         oprnd_t.sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n                                                   expr, &**oprnd, oprnd_t);\n@@ -4387,7 +4387,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprVec(ref args) => {\n         let uty = match expected {\n             ExpectHasType(uty) => {\n-                match ty::get(uty).sty {\n+                match uty.sty {\n                         ty::ty_vec(ty, _) => Some(ty),\n                         _ => None\n                 }\n@@ -4419,7 +4419,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n-                match ty::get(uty).sty {\n+                match uty.sty {\n                         ty::ty_vec(ty, _) => Some(ty),\n                         _ => None\n                 }\n@@ -4510,7 +4510,7 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             Some(def) => {\n                 // Verify that this was actually a struct.\n                 let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n-                match ty::get(typ.ty).sty {\n+                match typ.ty.sty {\n                     ty::ty_struct(struct_did, _) => {\n                         check_struct_constructor(fcx,\n                                                  id,\n@@ -4733,7 +4733,7 @@ impl<'tcx> Expectation<'tcx> {\n                -> Expectation<'tcx> {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n \n@@ -4744,7 +4744,7 @@ impl<'tcx> Expectation<'tcx> {\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n }\n@@ -5042,7 +5042,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::lookup_struct_fields(tcx, did);\n             if fields.is_empty() {\n@@ -5750,7 +5750,7 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n // Returns the one-level-deep structure of the given type.\n pub fn structure_of<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span, typ: Ty<'tcx>)\n                         -> &'tcx ty::sty<'tcx> {\n-    &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n+    &structurally_resolved_type(fcx, sp, typ).sty\n }\n \n // Returns true if b contains a break that can exit from b\n@@ -5789,7 +5789,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut tps_used = Vec::from_elem(tps.len(), false);\n \n     ty::walk_ty(ty, |t| {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n                     tps_used[idx] = true;"}, {"sha": "44c11318038d39c244c78072b8f5cc8f1abeadc5", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -693,7 +693,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            match ty::get(base_ty).sty {\n+            match base_ty.sty {\n                 ty::ty_rptr(r_ptr, _) => {\n                     mk_subregion_due_to_dereference(rcx, expr.span,\n                                                     ty::ReScope(expr.id), r_ptr);\n@@ -814,7 +814,7 @@ fn constrain_cast(rcx: &mut Rcx,\n         debug!(\"walk_cast(from_ty={}, to_ty={})\",\n                from_ty.repr(rcx.tcx()),\n                to_ty.repr(rcx.tcx()));\n-        match (&ty::get(from_ty).sty, &ty::get(to_ty).sty) {\n+        match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n             /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n@@ -846,7 +846,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let function_type = rcx.resolve_node_type(expr.id);\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy{store: ty::RegionTraitStore(..),\n                                          ref bounds,\n                                          ..}) => {\n@@ -889,7 +889,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n@@ -905,7 +905,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         _ => {}\n     }\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy {bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n@@ -1092,7 +1092,7 @@ fn constrain_callee(rcx: &mut Rcx,\n     let call_region = ty::ReScope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n-    match ty::get(callee_ty).sty {\n+    match callee_ty.sty {\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n             let region = match closure_ty.store {\n@@ -1204,7 +1204,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n                 let self_ty = fn_sig.inputs[0];\n-                let (m, r) = match ty::get(self_ty).sty {\n+                let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n@@ -1232,7 +1232,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n             None => derefd_ty\n         };\n \n-        match ty::get(derefd_ty).sty {\n+        match derefd_ty.sty {\n             ty::ty_rptr(r_ptr, _) => {\n                 mk_subregion_due_to_dereference(rcx, deref_expr.span,\n                                                 r_deref_expr, r_ptr);\n@@ -1272,8 +1272,8 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n-    match ty::get(indexed_ty).sty {\n-        ty::ty_rptr(r_ptr, mt) => match ty::get(mt.ty).sty {\n+    match indexed_ty.sty {\n+        ty::ty_rptr(r_ptr, mt) => match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n                                 r_index_expr, r_ptr);"}, {"sha": "9fd24c4ee784e411a0bfc2df0a9bff9bc391388f", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));\n \n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "99ffe898622297fc6cd86e77b93ae597b3c6eafd", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -39,7 +39,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let source_ty = fcx.expr_ty(source_expr);\n     let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n     debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n-    match (&ty::get(source_ty).sty, &ty::get(target_object_ty).sty) {\n+    match (&source_ty.sty, &target_object_ty.sty) {\n         (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n             let object_trait = object_trait(&object_trait_ty);\n \n@@ -97,7 +97,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n-        match ty::get(*t).sty {\n+        match t.sty {\n             ty::ty_trait(ref ty_trait) => &**ty_trait,\n             _ => panic!(\"expected ty_trait\")\n         }"}, {"sha": "5cc619bba26ba48148dc85a4547de1dfd244abc7", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -193,7 +193,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n                 !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n             {\n-                match ty::get(self_ty).sty {\n+                match self_ty.sty {\n                     ty::ty_struct(def_id, _) |\n                     ty::ty_enum(def_id, _) => {\n                         check_struct_safe_for_destructor(fcx, item.span, self_ty, def_id);\n@@ -336,7 +336,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             None => { }\n         }\n \n-        match ty::get(t).sty{\n+        match t.sty{\n             ty::ty_struct(type_id, ref substs) |\n             ty::ty_enum(type_id, ref substs) => {\n                 let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);"}, {"sha": "1f32110a0933883744d33461d60a96af2354428a", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -20,7 +20,6 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n@@ -71,7 +70,7 @@ fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n     };\n \n-    match get(resolved_type).sty {\n+    match resolved_type.sty {\n         ty_enum(..) | ty_struct(..) | ty_unboxed_closure(..) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n@@ -87,7 +86,7 @@ fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {}\",\n-                   get(original_type).sty);\n+                   original_type.sty);\n             None\n         }\n         ty_trait(..) => panic!(\"should have been caught\")\n@@ -102,7 +101,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n     match get_base_type(inference_context, span, original_type) {\n         None => None,\n         Some(base_type) => {\n-            match get(base_type).sty {\n+            match base_type.sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n                 ty_unboxed_closure(def_id, _, _) => {\n@@ -111,7 +110,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n                 ty_ptr(ty::mt {ty, ..}) |\n                 ty_rptr(_, ty::mt {ty, ..}) |\n                 ty_uniq(ty) => {\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty_trait(box ty::TyTrait { ref principal, .. }) => {\n                             Some(principal.def_id)\n                         }\n@@ -442,7 +441,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let method_def_id = items[0];\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n-            match ty::get(self_type.ty).sty {\n+            match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n                 ty::ty_unboxed_closure(type_def_id, _, _) => {"}, {"sha": "57ce7f79e030a11b3d18790bf93ee1098999863f", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -51,7 +51,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n-                match ty::get(self_ty).sty {\n+                match self_ty.sty {\n                     ty::ty_enum(def_id, _) |\n                     ty::ty_struct(def_id, _) => {\n                         self.check_def_id(item.span, def_id);"}, {"sha": "b0e8b664d06d7d7189d00d8ae88a6fbd47921575", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -663,7 +663,7 @@ fn is_associated_type_valid_for_param(ty: Ty,\n                                       trait_id: ast::DefId,\n                                       generics: &ty::Generics)\n                                       -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_param(param_ty) => {\n             let type_parameter = generics.types.get(param_ty.space,\n                                                     param_ty.idx);\n@@ -694,7 +694,7 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n         Some(ty) => ty,\n     };\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_param(ref param_ty) => {\n             /*let type_parameter = generics.types.get(param_ty.space,\n                                                     param_ty.idx);\n@@ -722,7 +722,7 @@ fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn type_is_self(ty: Ty) -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n         _ => false,\n     }\n@@ -1908,7 +1908,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n-                match ty::get(t).sty {\n+                match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(this.tcx().sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n@@ -2150,7 +2150,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     match explicit_self.node {\n         ast::SelfExplicit(ref ast_type, _) => {\n             let typ = crate_context.to_ty(rs, &**ast_type);\n-            let base_type = match ty::get(typ).sty {\n+            let base_type = match typ.sty {\n                 ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n                 ty::ty_uniq(typ) => typ,\n                 _ => typ,"}, {"sha": "49ac7178eb8db48d2fed3f25d59c2be8fc88e896", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -105,9 +105,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n-        match ty::get(b).sty {\n+        match b.sty {\n             ty::ty_ptr(mt_b) => {\n-                match ty::get(mt_b.ty).sty {\n+                match mt_b.ty.sty {\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_unsafe_ptr(a, sty_a, b, ast::MutImmutable)\n@@ -134,7 +134,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n \n             ty::ty_rptr(_, mt_b) => {\n-                match ty::get(mt_b.ty).sty {\n+                match mt_b.ty.sty {\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n@@ -202,7 +202,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n-                f(&ty::get(t).sty)\n+                f(&t.sty)\n             }\n             Err(e) => {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n@@ -273,7 +273,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sub = Sub(self.get_ref().clone());\n \n-        let sty_b = &ty::get(b).sty;\n+        let sty_b = &b.sty;\n         match (sty_a, sty_b) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n@@ -472,7 +472,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let tcx = self.get_ref().infcx.tcx;\n \n         match *sty_a {\n-            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty::get(ty).sty {\n+            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n                     // FIXME what is purpose of this type `tr`?"}, {"sha": "763f204dc98bc5b942524195a0d32784d67b5483", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -329,8 +329,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                                          -> cres<'tcx, Ty<'tcx>> {\n \n     let tcx = this.infcx().tcx;\n-    let a_sty = &ty::get(a).sty;\n-    let b_sty = &ty::get(b).sty;\n+    let a_sty = &a.sty;\n+    let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving var:\n@@ -387,7 +387,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n       (&ty::ty_float(_), _) => {\n-        if ty::get(a).sty == ty::get(b).sty {\n+        if a == b {\n             Ok(a)\n         } else {\n             Err(ty::terr_sorts(expected_found(this, a, b)))\n@@ -449,7 +449,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n             // path which would require invariance.\n-            let mt = match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n+            let mt = match (&a_mt.ty.sty, &b_mt.ty.sty) {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n                     let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n                     ty::mt { ty: ty, mutbl: a_mt.mutbl }\n@@ -692,7 +692,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         //\n         // (In particular, you could have something like `$0 = Box<$1>`\n         //  where `$1` has already been instantiated with `Box<$0>`)\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(vid)) => {\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;"}, {"sha": "356081c199afa5b9b144299cedc29c368ead685d", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -111,7 +111,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n-        match (&ty::get(a).sty, &ty::get(b).sty) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n                 Ok(a)"}, {"sha": "6e6c631f007490382f221058a5c68814448cb750", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -80,7 +80,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n     let infcx = this.infcx();\n     let a = infcx.type_variables.borrow().replace_if_possible(a);\n     let b = infcx.type_variables.borrow().replace_if_possible(b);\n-    match (&ty::get(a).sty, &ty::get(b).sty) {\n+    match (&a.sty, &b.sty) {\n         (&ty::ty_infer(TyVar(..)), &ty::ty_infer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n             let v = infcx.next_diverging_ty_var();"}, {"sha": "93c11693091c2daef28c7dd05d2dd25640eeb058", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n         }\n@@ -838,7 +838,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty::get(typ).sty {\n+        match typ.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.type_variables.borrow()\n                     .probe(v)\n@@ -878,7 +878,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                   (*trait_ref).clone(),\n                                   ty::region_existential_bound(ty::ReStatic));\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n-        match ty::get(dummy1).sty {\n+        match dummy1.sty {\n             ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n                 (*principal).clone()\n             }"}, {"sha": "cf5efd188ed96ed8724cf8628e9e9f8dcb40b7af", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n             return typ;\n         }\n \n-        match ty::get(typ).sty {\n+        match typ.sty {\n             ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n             }"}, {"sha": "5907a2bb9b61d945d2eee360d7ea99653f65d937", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.skolemize(self.infcx.type_variables.borrow().probe(v),\n                                ty::TyVar(v),"}, {"sha": "65d2a5133936c974e6ab42e6ca258b74de13b9ed", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -127,7 +127,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n-        match (&ty::get(a).sty, &ty::get(b).sty) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables\n                     .borrow_mut()"}, {"sha": "f7f7389602f8292892a8c92ee9f4c88455cb4203", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     pub fn replace_if_possible(&self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     None => t,"}, {"sha": "ad64537e1533ea2c5cec285dcfd4b4fed2b746c4", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -363,7 +363,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n-    match ty::get(main_t).sty {\n+    match main_t.sty {\n         ty::ty_bare_fn(..) => {\n             match tcx.map.find(main_id) {\n                 Some(ast_map::NodeItem(it)) => {\n@@ -410,7 +410,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n-    match ty::get(start_t).sty {\n+    match start_t.sty {\n         ty::ty_bare_fn(_) => {\n             match tcx.map.find(start_id) {\n                 Some(ast_map::NodeItem(it)) => {"}, {"sha": "b20ab0b05488025e6c685ba59772c6214f9de67a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -729,7 +729,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n             ty::ty_float(_) | ty::ty_str => {"}, {"sha": "2591051e9b90a23e808f6f1b488bbe71ffbfe1f7", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -1300,9 +1300,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n-                let t_box = ty::get(t);\n-                match t_box.sty {\n+                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n@@ -1328,9 +1326,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n-                let t_box = ty::get(t);\n-                match t_box.sty {\n+                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {"}, {"sha": "de406cff6e74124378a5cbce2f472bd0eefbf961", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -811,10 +811,10 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         return Result::new(rs.bcx, rs.val);\n     }\n \n-    match ty::get(rhs_t).sty {\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+    match rhs_t.sty {\n+        ty::ty_rptr(_, mt) => match mt.ty.sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            ty::ty_vec(ty, _) => match ty::get(ty).sty {\n+            ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n@@ -1034,7 +1034,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n         Some(vec!(Load(bcx, val)))\n     } else {\n-        match ty::get(left_ty).sty {\n+        match left_ty.sty {\n             ty::ty_vec(_, Some(n)) => {\n                 let args = extract_vec_elems(bcx, left_ty, n, 0, val);\n                 Some(args.vals)"}, {"sha": "c5f66cf0c542ffbda014fa31bbf649ecb305d271", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -166,7 +166,7 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_tup(ref elems) => {\n             Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n         }\n@@ -306,9 +306,9 @@ impl<'tcx> Case<'tcx> {\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n         for (i, &ty) in self.tys.iter().enumerate() {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                 // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n+                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n                     // &[T] and &str are a pointer and length pair\n                     ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i)),\n "}, {"sha": "b3f64e3fd798c612a4a5ae1abad7be32834c2dd5", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -266,7 +266,7 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n+    let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n         }\n@@ -561,7 +561,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n         ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n@@ -642,7 +642,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                     size: uint,\n                     op: ast::BinOp)\n                     -> ValueRef {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_float(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n@@ -711,7 +711,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     };\n \n     let mut cx = cx;\n-    match ty::get(t).sty {\n+    match t.sty {\n       ty::ty_struct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n@@ -871,7 +871,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         (\"attempted remainder with a divisor of zero\",\n          \"attempted remainder with overflow\")\n     };\n-    let (is_zero, is_signed) = match ty::get(rhs_t).sty {\n+    let (is_zero, is_signed) = match rhs_t.sty {\n         ty::ty_int(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero), true)\n@@ -899,7 +899,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     // signed division/remainder which would trigger overflow. For unsigned\n     // integers, no action beyond checking for zero need be taken.\n     if is_signed {\n-        let (llty, min) = match ty::get(rhs_t).sty {\n+        let (llty, min) = match rhs_t.sty {\n             ty::ty_int(t) => {\n                 let llty = Type::int_from_ty(cx.ccx(), t);\n                 let min = match t {\n@@ -932,7 +932,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n@@ -1564,7 +1564,7 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n         }\n \n         // This is the last argument. Tuple it.\n-        match ty::get(arg_ty).sty {\n+        match arg_ty.sty {\n             ty::ty_tup(ref tupled_arg_tys) => {\n                 let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n                 let tuple =\n@@ -1661,7 +1661,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                       arg_datum.to_lvalue_datum_in_scope(bcx,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n-    let untupled_arg_types = match ty::get(monomorphized_arg_types[0]).sty {\n+    let untupled_arg_types = match monomorphized_arg_types[0].sty {\n         ty::ty_tup(ref types) => types.as_slice(),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n@@ -1978,7 +1978,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.fcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let result_ty = match ty::get(ctor_ty).sty {\n+    let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n@@ -2050,7 +2050,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n     let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n-    let result_ty = match ty::get(ctor_ty).sty {\n+    let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n@@ -2387,7 +2387,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_id: ast::NodeId,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n-    match ty::get(node_type).sty {\n+    match node_type.sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n         }\n@@ -2403,7 +2403,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                                         -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n-    let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n+    let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n@@ -2425,19 +2425,19 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n-    let input_tys = match ty::get(fn_ty).sty {\n+    let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match ty::get(fn_sig.inputs[0]).sty {\n+            match fn_sig.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n-            match ty::get(fn_sig.inputs[1]).sty {\n+            match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n@@ -2469,7 +2469,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n         } else {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n@@ -2480,7 +2480,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             }\n \n             // We can also mark the return value as `dereferenceable` in certain cases\n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::ty_uniq(it) |\n                 ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n@@ -2491,7 +2491,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                 _ => {}\n             }\n \n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 ty::ty_bool => {\n                     attrs.ret(llvm::ZExtAttribute);\n                 }\n@@ -2501,7 +2501,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     }\n \n     for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n-        match ty::get(t).sty {\n+        match t.sty {\n             // this needs to be first to prevent fat pointers from falling through\n             _ if !type_is_immediate(ccx, t) => {\n                 let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));"}, {"sha": "bf7adbbecef1a847d03e2a28d58b344f96125c6c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -107,7 +107,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n     fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                 -> Callee<'blk, 'tcx> {\n         let DatumBlock {mut bcx, datum} = expr::trans(bcx, expr);\n-        match ty::get(datum.ty).sty {\n+        match datum.ty.sty {\n             ty::ty_bare_fn(..) => {\n                 let llval = datum.to_llscalarish(bcx);\n                 return Callee {\n@@ -163,7 +163,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     data: NamedTupleConstructor(substs, 0)\n                 }\n             }\n-            def::DefFn(did, _) if match ty::get(expr_ty).sty {\n+            def::DefFn(did, _) if match expr_ty.sty {\n                 ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n@@ -707,7 +707,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n     let mut bcx = callee.bcx;\n \n-    let (abi, ret_ty) = match ty::get(callee_ty).sty {\n+    let (abi, ret_ty) = match callee_ty.sty {\n         ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n         ty::ty_closure(ref f) => (f.abi, f.sig.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n@@ -933,7 +933,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     let tuple_expr = &arg_exprs[1];\n     let tuple_type = node_id_type(bcx, tuple_expr.id);\n \n-    match ty::get(tuple_type).sty {\n+    match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n                                             expr::trans(bcx, &**tuple_expr));\n@@ -991,7 +991,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n \n     // Now untuple the rest of the arguments.\n     let tuple_type = arg_tys[1];\n-    match ty::get(tuple_type).sty {\n+    match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum ="}, {"sha": "d4c93be7eafca17c26ae6976d14de5312ed25f6f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -15,7 +15,6 @@ use back::link::mangle_internal_name_by_path_and_seq;\n use llvm::ValueRef;\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst::Substs;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n@@ -470,7 +469,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let function_type = ty::normalize_ty(bcx.tcx(), function_type);\n-    let params = match ty::get(function_type).sty {\n+    let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n     };\n@@ -605,7 +604,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"get_wrapper_for_bare_fn(closure_ty={})\", closure_ty.repr(tcx));\n \n-    let f = match ty::get(closure_ty).sty {\n+    let f = match closure_ty.sty {\n         ty::ty_closure(ref f) => f,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\"}, {"sha": "9cd249f1e005dd106cd2114197899591de6696a8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -57,7 +57,7 @@ pub use trans::context::CrateContext;\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        ty: Ty<'tcx>) -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n@@ -84,7 +84,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     if !ty::type_is_sized(tcx, ty) {\n         return false;\n     }\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);"}, {"sha": "4213e9417276c8ac447810b58bef2ffd9c774446", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -52,7 +52,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n             let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n-            match ty::get(lit_int_ty).sty {\n+            match lit_int_ty.sty {\n                 ty::ty_int(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n                 }\n@@ -70,7 +70,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n-            match ty::get(lit_float_ty).sty {\n+            match lit_float_ty.sty {\n                 ty::ty_float(t) => {\n                     C_floating(fs.get(), Type::float_from_ty(cx, t))\n                 }\n@@ -144,7 +144,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                          -> (ValueRef, Ty<'tcx>) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n                     if ty::type_is_sized(cx.tcx(), mt.ty) {\n                         (const_deref_ptr(cx, v), mt.ty)\n@@ -260,7 +260,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                         llconst = const_addr_of(cx, llconst, ast::MutImmutable)\n                                     }\n \n-                                    match ty::get(ty).sty {\n+                                    match ty.sty {\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n                                             let llptr = const_ptrcast(cx, llconst, llunitty);\n@@ -442,9 +442,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(index.span,\n                                           \"index is not an integer-constant expression\")\n               };\n-              let (arr, len) = match ty::get(bt).sty {\n+              let (arr, len) = match bt.sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_open(ty) => match ty::get(ty).sty {\n+                  ty::ty_open(ty) => match ty.sty {\n                       ty::ty_vec(_, None) | ty::ty_str => {\n                           let e1 = const_get_elt(cx, bv, &[0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n@@ -454,7 +454,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                                                        or string type, found {}\",\n                                                       ty_to_string(cx.tcx(), bt)).as_slice())\n                   },\n-                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                  ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))\n                       },\n@@ -470,8 +470,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n-              let len = match ty::get(bt).sty {\n-                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+              let len = match bt.sty {\n+                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n                       ty::ty_str => {\n                           assert!(len > 0);\n                           len - 1"}, {"sha": "354a6072207156f9ca5d622532ed1ffa8a198784", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -518,7 +518,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     pub fn get_element<'blk>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n                              gep: |ValueRef| -> ValueRef)\n                              -> Datum<'tcx, Lvalue> {\n-        let val = match ty::get(self.ty).sty {\n+        let val = match self.ty.sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n                 let base = Load(bcx, expr::get_dataptr(bcx, self.val));"}, {"sha": "7b3f619f41f1a5139db159e0b70173dd6903dc20", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -357,7 +357,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let mut unique_type_id = String::with_capacity(256);\n         unique_type_id.push('{');\n \n-        match ty::get(type_).sty {\n+        match type_.sty {\n             ty::ty_bool     |\n             ty::ty_char     |\n             ty::ty_str      |\n@@ -485,7 +485,7 @@ impl<'tcx> TypeMap<'tcx> {\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n                                       ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n-                                      ty::get(type_).sty).as_slice())\n+                                      type_.sty).as_slice())\n             }\n         };\n \n@@ -1743,9 +1743,9 @@ fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n-    debug!(\"basic_type_metadata: {}\", ty::get(t));\n+    debug!(\"basic_type_metadata: {}\", t);\n \n-    let (name, encoding) = match ty::get(t).sty {\n+    let (name, encoding) = match t.sty {\n         ty::ty_tup(ref elements) if elements.is_empty() =>\n             (\"()\".to_string(), DW_ATE_unsigned),\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n@@ -2787,7 +2787,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // return type\n     signature_metadata.push(match signature.output {\n-        ty::FnConverging(ret_ty) => match ty::get(ret_ty).sty {\n+        ty::FnConverging(ret_ty) => match ret_ty.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n         },\n@@ -2826,7 +2826,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n-    let def_id = match ty::get(trait_type).sty {\n+    let def_id = match trait_type.sty {\n         ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id,\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n@@ -2891,9 +2891,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"type_metadata: {}\", ty::get(t));\n+    debug!(\"type_metadata: {}\", t);\n \n-    let sty = &ty::get(t).sty;\n+    let sty = &t.sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::ty_bool     |\n         ty::ty_char     |\n@@ -2920,7 +2920,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             false)\n         }\n         ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                 ty::ty_vec(typ, None) => {\n                     vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n@@ -3688,7 +3688,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       t: Ty<'tcx>,\n                                       qualified: bool,\n                                       output: &mut String) {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),"}, {"sha": "8ccc59831993ac3f2919e1d4c221080b049b5f1a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -212,7 +212,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // also be just in case we need to unsize. But if there are no nested\n                 // adjustments then it should be a no-op).\n                 Some(ty::AutoPtr(_, _, None)) if adj.autoderefs == 1 => {\n-                    match ty::get(datum.ty).sty {\n+                    match datum.ty.sty {\n                         // Don't skip a conversion from Box<T> to &T, etc.\n                         ty::ty_rptr(..) => {\n                             let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n@@ -318,7 +318,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 mk_ty: |Ty<'tcx>| -> Ty<'tcx>) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n-            &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n+            &ty::UnsizeStruct(box ref k, tp_index) => match unsized_ty.sty {\n                 ty::ty_struct(_, ref substs) => {\n                     let ty_substs = substs.types.get_slice(subst::TypeSpace);\n                     // The dtor for a field treats it like a value, so mk_ty\n@@ -446,7 +446,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let tcx = bcx.tcx();\n \n         let datum_ty = datum.ty;\n-        let unboxed_ty = match ty::get(datum_ty).sty {\n+        let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n                                         bcx.ty_to_string(datum_ty)).as_slice())\n@@ -628,7 +628,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Special case for `Box<T>`\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, &**contents);\n-            match ty::get(box_ty).sty {\n+            match box_ty.sty {\n                 ty::ty_uniq(..) => {\n                     trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n                 }\n@@ -1173,7 +1173,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n@@ -1276,7 +1276,7 @@ pub fn with_field_tys<'tcx, R>(tcx: &ty::ctxt<'tcx>,\n      * is and `node_id_opt` is none, this function panics).\n      */\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs).as_slice())\n         }\n@@ -1605,7 +1605,7 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    match ty::get(sub_datum.ty).sty {\n+    match sub_datum.ty.sty {\n         ty::ty_open(_) => {\n             // Opened DST value, close to a fat pointer\n             debug!(\"Closing fat pointer {}\", bcx.ty_to_string(sub_datum.ty));\n@@ -1906,7 +1906,7 @@ pub enum cast_kind {\n }\n \n pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n@@ -2139,7 +2139,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let r = match ty::get(datum.ty).sty {\n+    let r = match datum.ty.sty {\n         ty::ty_uniq(content_ty) => {\n             if ty::type_is_sized(bcx.tcx(), content_ty) {\n                 deref_owned_pointer(bcx, expr, datum, content_ty)"}, {"sha": "1f6aeacc860586cad25b8d3980aabebe08a67d89", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -122,7 +122,7 @@ pub fn register_static(ccx: &CrateContext,\n                                           \"invalid linkage specified\");\n                 }\n             };\n-            let llty2 = match ty::get(ty).sty {\n+            let llty2 = match ty.sty {\n                 ty::ty_ptr(ref mt) => type_of::type_of(ccx, mt.ty),\n                 _ => {\n                     ccx.sess().span_fatal(foreign_item.span,\n@@ -235,7 +235,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llfn),\n            ccx.tn().val_to_string(llretptr));\n \n-    let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n+    let (fn_abi, fn_sig) = match callee_ty.sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n@@ -490,7 +490,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                -> ValueRef {\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let cconv = match ty::get(t).sty {\n+    let cconv = match t.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n@@ -513,7 +513,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let tys = foreign_types_for_id(ccx, node_id);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n-    let cconv = match ty::get(t).sty {\n+    let cconv = match t.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n@@ -567,7 +567,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_bare_fn(ref f) => {\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n@@ -864,7 +864,7 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n-    let fn_sig = match ty::get(ty).sty {\n+    let fn_sig = match ty.sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };"}, {"sha": "67b3310dbdf88d25cf30711634ab75b95bb8bb37", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -87,7 +87,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ)\n                          && ty::type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n@@ -225,7 +225,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n-    let self_ty = match ty::get(fty).sty {\n+    let self_ty = match fty.sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.sig.inputs.len() == 1);\n             f.sig.inputs[0]\n@@ -308,7 +308,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n         let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n         return (size, align);\n     }\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_struct(id, ref substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n@@ -358,9 +358,9 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_uniq(content_ty) => {\n-            match ty::get(content_ty).sty {\n+            match content_ty.sty {\n                 ty::ty_vec(ty, None) => {\n                     tvec::make_drop_glue_unboxed(bcx, v0, ty, true)\n                 }"}, {"sha": "6bdb35f8d6074dc345f03e62a63492f6391b0401", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -149,7 +149,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n-    let ret_ty = match ty::get(callee_ty).sty {\n+    let ret_ty = match callee_ty.sty {\n         ty::ty_bare_fn(ref f) => f.sig.output,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };"}, {"sha": "0311d37c3de524cf1f1c0bcd522fb3904f7808ca", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -488,7 +488,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-    let llcallee_ty = match ty::get(callee_ty).sty {\n+    let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n@@ -585,12 +585,10 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  unboxed closure\");\n                     if closure_info.kind == ty::FnOnceUnboxedClosureKind {\n                         // Untuple the arguments and create an unboxing shim.\n-                        let (new_inputs, new_output) = match ty::get(self_ty).sty {\n+                        let (new_inputs, new_output) = match self_ty.sty {\n                             ty::ty_unboxed_closure(_, _, ref substs) => {\n                                 let mut new_inputs = vec![self_ty.clone()];\n-                                match ty::get(closure_info.closure_type\n-                                              .sig\n-                                              .inputs[0]).sty {\n+                                match closure_info.closure_type.sig.inputs[0].sty {\n                                     ty::ty_tup(ref elements) => {\n                                         for element in elements.iter() {\n                                             new_inputs.push(element.subst(bcx.tcx(), substs));"}, {"sha": "359f74bdbf134d866fc1df7a27054422ed9aa8c1", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -420,15 +420,15 @@ pub fn get_base_and_len(bcx: Block,\n \n     let ccx = bcx.ccx();\n \n-    match ty::get(vec_ty).sty {\n+    match vec_ty.sty {\n         ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n-        ty::ty_open(ty) => match ty::get(ty).sty {\n+        ty::ty_open(ty) => match ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n             _ => ccx.sess().bug(\"unexpected type in get_base_and_len\")\n         },\n \n         // Only used for pattern matching.\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n             ty::ty_vec(_, Some(n)) => {\n                 let base = GEPi(bcx, Load(bcx, llval), &[0u, 0u]);"}, {"sha": "31e8130dd751334b982bd9e786239af68cbc8b56", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -81,7 +81,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    match ty::get(inputs[inputs.len() - 1]).sty {\n+    match inputs[inputs.len() - 1].sty {\n         ty::ty_tup(ref tupled_arguments) => {\n             debug!(\"untuple_arguments_if_necessary(): untupling arguments\");\n             for &tupled_argument in tupled_arguments.iter() {\n@@ -142,7 +142,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>) -> Type {\n-    match ty::get(fty).sty {\n+    match fty.sty {\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx,\n                             Some(Type::i8p(cx)),\n@@ -184,7 +184,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         None => ()\n     }\n \n-    let llsizingty = match ty::get(t).sty {\n+    let llsizingty = match t.sty {\n         _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n                                   ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n@@ -269,7 +269,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n             return Type::i8p(cx);\n         }\n \n-        match ty::get(ty::unsized_part_of_type(cx.tcx(), t)).sty {\n+        match ty::unsized_part_of_type(cx.tcx(), t).sty {\n             ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n             _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n@@ -283,7 +283,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         None => ()\n     }\n \n-    debug!(\"type_of {} {}\", t.repr(cx.tcx()), ty::get(t).sty);\n+    debug!(\"type_of {} {}\", t.repr(cx.tcx()), t.sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -304,7 +304,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         return llty;\n     }\n \n-    let mut llty = match ty::get(t).sty {\n+    let mut llty = match t.sty {\n       ty::ty_bool => Type::bool(cx),\n       ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -333,7 +333,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n-          match ty::get(ty).sty {\n+          match ty.sty {\n               ty::ty_str => {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized).\n@@ -393,7 +393,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n       }\n \n-      ty::ty_open(t) => match ty::get(t).sty {\n+      ty::ty_open(t) => match t.sty {\n           ty::ty_struct(..) => {\n               let p_ty = type_of(cx, t).ptr_to();\n               Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n@@ -424,7 +424,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     cx.lltypes().borrow_mut().insert(t, llty);\n \n     // If this was an enum or struct, fill in the type now.\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_unboxed_closure(..)\n                 if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);"}, {"sha": "16edccd154302ce4118d4a653536ef6e9b28c1dd", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -169,7 +169,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n \n fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n-    let (decl, style) = match ty::get(t.ty).sty {\n+    let (decl, style) = match t.ty.sty {\n         ty::ty_bare_fn(ref f) => ((did, &f.sig).clean(cx), f.fn_style),\n         _ => panic!(\"bad function\"),\n     };\n@@ -201,7 +201,7 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n \n fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n-    match ty::get(t.ty).sty {\n+    match t.ty.sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, subst::TypeSpace).clean(cx),"}, {"sha": "22b646e9ffe5b5e0c8ccab37d01f766b3df0f957", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7aa7fa76b2293c9948d9211d31eec7fd53d9af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9f7aa7fa76b2293c9948d9211d31eec7fd53d9af", "patch": "@@ -1049,7 +1049,7 @@ impl Clean<Item> for ty::Method {\n                 let s = match s {\n                     ty::ByValueExplicitSelfCategory => SelfValue,\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n-                        match ty::get(self.fty.sig.inputs[0]).sty {\n+                        match self.fty.sig.inputs[0].sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n@@ -1259,7 +1259,7 @@ impl Clean<Type> for ast::Ty {\n \n impl Clean<Type> for Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n-        match ty::get(*self).sty {\n+        match self.sty {\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n             ty::ty_int(ast::TyI) => Primitive(Int),\n@@ -1321,7 +1321,7 @@ impl Clean<Type> for Ty {\n                 let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()\n                 }).collect();\n-                let kind = match ty::get(*self).sty {\n+                let kind = match self.sty {\n                     ty::ty_struct(..) => TypeStruct,\n                     ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,"}]}