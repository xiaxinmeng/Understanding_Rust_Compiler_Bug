{"sha": "2791877009996dba1a4c7b84fbd7af01ac36bd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OTE4NzcwMDk5OTZkYmExYTRjN2I4NGZiZDdhZjAxYWMzNmJkMDQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-08T21:49:21Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-08T21:49:21Z"}, "message": "Merge pull request #4388 from lkuper/alt-to-match\n\nRename identifiers that still use 'alt' to use 'match'", "tree": {"sha": "4ce8b2220f434828c27481f66adfa7d49bd012c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ce8b2220f434828c27481f66adfa7d49bd012c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2791877009996dba1a4c7b84fbd7af01ac36bd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2791877009996dba1a4c7b84fbd7af01ac36bd04", "html_url": "https://github.com/rust-lang/rust/commit/2791877009996dba1a4c7b84fbd7af01ac36bd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2791877009996dba1a4c7b84fbd7af01ac36bd04/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd73dd0e37d17ecfec4fb9a38d4cfd68dcf299eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd73dd0e37d17ecfec4fb9a38d4cfd68dcf299eb", "html_url": "https://github.com/rust-lang/rust/commit/dd73dd0e37d17ecfec4fb9a38d4cfd68dcf299eb"}, {"sha": "816cb8c5350084e04770b9c3a133400923bd2e1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/816cb8c5350084e04770b9c3a133400923bd2e1b", "html_url": "https://github.com/rust-lang/rust/commit/816cb8c5350084e04770b9c3a133400923bd2e1b"}], "stats": {"total": 191, "additions": 96, "deletions": 95}, "files": [{"sha": "b5f57d904bcc6a35fe5a7a351766600cd20a3bd8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -275,8 +275,8 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n         time(time_passes, ~\"mode computation\", ||\n              middle::mode::compute_modes(ty_cx, method_map, crate));\n \n-        time(time_passes, ~\"alt checking\", ||\n-             middle::check_alt::check_crate(ty_cx, method_map, crate));\n+        time(time_passes, ~\"match checking\", ||\n+             middle::check_match::check_crate(ty_cx, method_map, crate));\n \n         let last_use_map =\n             time(time_passes, ~\"liveness checking\", ||"}, {"sha": "d5652ae78d6eec188d091383aff8e0f1dd0d8e46", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -506,19 +506,19 @@ impl gather_loan_ctxt {\n                   discr_cmt: cmt,\n                   root_pat: @ast::pat,\n                   arm_id: ast::node_id,\n-                  alt_id: ast::node_id) {\n+                  match_id: ast::node_id) {\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n                 match bm {\n                   ast::bind_by_value | ast::bind_by_move => {\n                     // copying does not borrow anything, so no check\n                     // is required\n-                    // as for move, check::alt ensures it's from an rvalue.\n+                    // as for move, check::_match ensures it's from an rvalue.\n                   }\n                   ast::bind_by_ref(mutbl) => {\n                     // ref x or ref x @ p --- creates a ptr which must\n-                    // remain valid for the scope of the alt\n+                    // remain valid for the scope of the match\n \n                     // find the region of the resulting pointer (note that\n                     // the type of such a pattern will *always* be a\n@@ -531,7 +531,7 @@ impl gather_loan_ctxt {\n                     // of the function of this node in method preserve():\n                     let arm_scope = ty::re_scope(arm_id);\n                     if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                        let cmt_discr = self.bccx.cat_discr(cmt, alt_id);\n+                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n                         self.guarantee_valid(cmt_discr, mutbl, scope_r);\n                     } else {\n                         self.guarantee_valid(cmt, mutbl, scope_r);"}, {"sha": "fa7dfd1b77f311313baad749454677011c956b50", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -494,8 +494,8 @@ impl borrowck_ctxt {\n         cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n     }\n \n-    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n-        return @{cat:cat_discr(cmt, alt_id),.. *cmt};\n+    fn cat_discr(cmt: cmt, match_id: ast::node_id) -> cmt {\n+        return @{cat:cat_discr(cmt, match_id),.. *cmt};\n     }\n \n     fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {"}, {"sha": "e6d311fd04fc7ba2ae28e9562cfd7cd9c1e799e3", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -195,15 +195,15 @@ priv impl &preserve_ctxt {\n                 self.attempt_root(cmt, base, derefs)\n             }\n           }\n-          cat_discr(base, alt_id) => {\n-            // Subtle: in an alt, we must ensure that each binding\n+          cat_discr(base, match_id) => {\n+            // Subtle: in a match, we must ensure that each binding\n             // variable remains valid for the duration of the arm in\n             // which it appears, presuming that this arm is taken.\n             // But it is inconvenient in trans to root something just\n             // for one arm.  Therefore, we insert a cat_discr(),\n             // basically a special kind of category that says \"if this\n             // value must be dynamically rooted, root it for the scope\n-            // `alt_id`.\n+            // `match_id`.\n             //\n             // As an example, consider this scenario:\n             //\n@@ -213,7 +213,7 @@ priv impl &preserve_ctxt {\n             // Technically, the value `x` need only be rooted\n             // in the `some` arm.  However, we evaluate `x` in trans\n             // before we know what arm will be taken, so we just\n-            // always root it for the duration of the alt.\n+            // always root it for the duration of the match.\n             //\n             // As a second example, consider *this* scenario:\n             //\n@@ -225,7 +225,7 @@ priv impl &preserve_ctxt {\n             // found only when checking which pattern matches: but\n             // this check is done before entering the arm.  Therefore,\n             // even in this case we just choose to keep the value\n-            // rooted for the entire alt.  This means the value will be\n+            // rooted for the entire match.  This means the value will be\n             // rooted even if the none arm is taken.  Oh well.\n             //\n             // At first, I tried to optimize the second case to only\n@@ -247,12 +247,12 @@ priv impl &preserve_ctxt {\n             // Nonetheless, if you decide to optimize this case in the\n             // future, you need only adjust where the cat_discr()\n             // node appears to draw the line between what will be rooted\n-            // in the *arm* vs the *alt*.\n+            // in the *arm* vs the *match*.\n \n-            let alt_rooting_ctxt =\n-                preserve_ctxt({scope_region: ty::re_scope(alt_id),\n+            let match_rooting_ctxt =\n+                preserve_ctxt({scope_region: ty::re_scope(match_id),\n                                .. **self});\n-            (&alt_rooting_ctxt).preserve(base)\n+            (&match_rooting_ctxt).preserve(base)\n           }\n         }\n     }"}, {"sha": "dc66df9362498424968e22415b600890e5c4c9fd", "filename": "src/librustc/middle/check_match.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -30,13 +30,13 @@ use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n-struct AltCheckCtxt {\n+struct MatchCheckCtxt {\n     tcx: ty::ctxt,\n     method_map: method_map,\n }\n \n fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n-    let cx = @AltCheckCtxt { tcx: tcx, method_map: method_map };\n+    let cx = @MatchCheckCtxt { tcx: tcx, method_map: method_map };\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n         visit_local: |a,b,c| check_local(cx, a, b, c),\n@@ -47,7 +47,7 @@ fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn expr_is_non_moving_lvalue(cx: @AltCheckCtxt, expr: @expr) -> bool {\n+fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n         return false;\n     }\n@@ -61,7 +61,7 @@ fn expr_is_non_moving_lvalue(cx: @AltCheckCtxt, expr: @expr) -> bool {\n     }\n }\n \n-fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n+fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n@@ -107,7 +107,7 @@ fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: @AltCheckCtxt, arms: ~[arm]) {\n+fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n     let mut seen = ~[];\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n@@ -130,7 +130,7 @@ fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-fn check_exhaustive(cx: @AltCheckCtxt, sp: span, pats: ~[@pat]) {\n+fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n     let ext = match is_useful(cx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n@@ -216,7 +216,7 @@ impl ctor : cmp::Eq {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: @AltCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n+fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n@@ -289,7 +289,7 @@ fn is_useful(cx: @AltCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n     }\n }\n \n-fn is_useful_specialized(cx: @AltCheckCtxt, m: matrix, +v: ~[@pat],\n+fn is_useful_specialized(cx: @MatchCheckCtxt, m: matrix, +v: ~[@pat],\n                          +ctor: ctor, arity: uint, lty: ty::t) -> useful {\n     let ms = vec::filter_map(m, |r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n@@ -300,7 +300,7 @@ fn is_useful_specialized(cx: @AltCheckCtxt, m: matrix, +v: ~[@pat],\n     }\n }\n \n-fn pat_ctor_id(cx: @AltCheckCtxt, p: @pat) -> Option<ctor> {\n+fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match /*bad*/copy pat.node {\n       pat_wild => { None }\n@@ -337,7 +337,7 @@ fn pat_ctor_id(cx: @AltCheckCtxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-fn is_wild(cx: @AltCheckCtxt, p: @pat) -> bool {\n+fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { true }\n@@ -351,7 +351,7 @@ fn is_wild(cx: @AltCheckCtxt, p: @pat) -> bool {\n     }\n }\n \n-fn missing_ctor(cx: @AltCheckCtxt,\n+fn missing_ctor(cx: @MatchCheckCtxt,\n                 m: matrix,\n                 left_ty: ty::t)\n              -> Option<ctor> {\n@@ -451,7 +451,7 @@ fn missing_ctor(cx: @AltCheckCtxt,\n     }\n }\n \n-fn ctor_arity(cx: @AltCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n+fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     match /*bad*/copy ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n@@ -479,7 +479,7 @@ fn wild() -> @pat {\n     @{id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n }\n \n-fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n+fn specialize(cx: @MatchCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n               left_ty: ty::t) -> Option<~[@pat]> {\n     let r0 = raw_pat(r[0]);\n     match /*bad*/copy r0.node {\n@@ -637,12 +637,12 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n     }\n }\n \n-fn default(cx: @AltCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n+fn default(cx: @MatchCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n     if is_wild(cx, r[0]) { Some(vec::tail(r)) }\n     else { None }\n }\n \n-fn check_local(cx: @AltCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n+fn check_local(cx: @MatchCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n@@ -657,7 +657,7 @@ fn check_local(cx: @AltCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n }\n \n-fn check_fn(cx: @AltCheckCtxt,\n+fn check_fn(cx: @MatchCheckCtxt,\n             kind: visit::fn_kind,\n             decl: fn_decl,\n             body: blk,\n@@ -674,7 +674,7 @@ fn check_fn(cx: @AltCheckCtxt,\n     }\n }\n \n-fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n+fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(pat.id) {\n       Some(def_variant(enum_id, _)) => {\n         if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n@@ -712,7 +712,7 @@ fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n \n // Legality of move bindings checking\n \n-fn check_legality_of_move_bindings(cx: @AltCheckCtxt,\n+fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                                    is_lvalue: bool,\n                                    has_guard: bool,\n                                    pats: &[@pat]) {", "previous_filename": "src/librustc/middle/check_alt.rs"}, {"sha": "e2de186ca2ffbfb2277178c313fb6907757734a5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -46,7 +46,7 @@ use syntax::ast::*;\n //        & and * pointers\n //        copies of general constants\n //\n-//        (in theory, probably not at first: if/alt on integer-const\n+//        (in theory, probably not at first: if/match on integer-const\n //         conditions / descriminants)\n //\n //   - Non-constants: everything else."}, {"sha": "9b373ef0c16c2220b6356d3667a15fca54c1224f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -904,7 +904,7 @@ impl &mem_categorization_ctxt {\n         //     local(x)->@->@\n         //\n         // where the id of `local(x)` is the id of the `x` that appears\n-        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n+        // in the match, the id of `local(x)->@` is the `@y` pattern,\n         // and the id of `local(x)->@->@` is the id of the `y` pattern.\n \n "}, {"sha": "6f9c3070a0e8ef7ead5c7a863fa226505cea34c0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -71,7 +71,7 @@ struct ctxt {\n     // that when we visit it we can view it as a parent.\n     root_exprs: HashMap<ast::node_id, ()>,\n \n-    // The parent scope is the innermost block, statement, call, or alt\n+    // The parent scope is the innermost block, statement, call, or match\n     // expression during the execution of which the current expression\n     // will be evaluated.  Generally speaking, the innermost parent\n     // scope is also the closest suitable ancestor in the AST tree."}, {"sha": "9733102156016541bb463e2ccbc01bd7e83b3fff", "filename": "src/librustc/middle/trans/_match.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -245,7 +245,7 @@ enum opt_result {\n     range_result(Result, Result),\n }\n fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n-    let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n+    let _icx = bcx.insn_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match *o {\n@@ -463,8 +463,8 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n-// <pcwalton> in trans/alt\n-// <pcwalton> trans/alt.rs is like stumbling around in a dark cave\n+// <pcwalton> in trans/match\n+// <pcwalton> trans/match.rs is like stumbling around in a dark cave\n // <nmatsakis> pcwalton: the enter family of functions adjust the set of\n //             patterns as needed\n // <nmatsakis> yeah, at some point I kind of achieved some level of\n@@ -810,7 +810,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         val: ValueRef)\n     -> {vals: ~[ValueRef], bcx: block}\n {\n-    let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n+    let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n       ty::ty_enum(id, ref substs) => {\n@@ -841,7 +841,7 @@ fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n                      elem_count: uint, tail: bool, val: ValueRef)\n     -> {vals: ~[ValueRef], bcx: block}\n {\n-    let _icx = bcx.insn_ctxt(\"alt::extract_vec_elems\");\n+    let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n     let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n     let (base, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n@@ -909,7 +909,7 @@ fn root_pats_as_necessary(bcx: block, m: &[@Match],\n         match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n             None => (),\n             Some(scope_id) => {\n-                // Note: the scope_id will always be the id of the alt.  See\n+                // Note: the scope_id will always be the id of the match.  See\n                 // the extended comment in rustc::middle::borrowck::preserve()\n                 // for details (look for the case covering cat_discr).\n \n@@ -1201,7 +1201,7 @@ fn compile_submatch(bcx: block,\n       For an empty match, a fall-through case must exist\n      */\n     assert(m.len() > 0u || chk.is_some());\n-    let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n+    let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u {\n@@ -1520,22 +1520,22 @@ fn compile_submatch(bcx: block,\n     }\n }\n \n-fn trans_alt(bcx: block,\n-             alt_expr: @ast::expr,\n+fn trans_match(bcx: block,\n+             match_expr: @ast::expr,\n              discr_expr: @ast::expr,\n              arms: ~[ast::arm],\n              dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n-    do with_scope(bcx, alt_expr.info(), ~\"alt\") |bcx| {\n-        trans_alt_inner(bcx, discr_expr, arms, dest)\n+    let _icx = bcx.insn_ctxt(\"match::trans_match\");\n+    do with_scope(bcx, match_expr.info(), ~\"match\") |bcx| {\n+        trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n }\n \n-fn trans_alt_inner(scope_cx: block,\n+fn trans_match_inner(scope_cx: block,\n                    discr_expr: @ast::expr,\n                    arms: &[ast::arm],\n                    dest: Dest) -> block {\n-    let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n+    let _icx = scope_cx.insn_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n@@ -1655,18 +1655,18 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-// Not alt-related, but similar to the pattern-munging code above\n+// Not match-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: block,\n                         pat: @ast::pat,\n                         val: ValueRef,\n                         make_copy: bool,\n                         binding_mode: IrrefutablePatternBindingMode)\n                      -> block {\n-    let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n+    let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n \n-    // Necessary since bind_irrefutable_pat is called outside trans_alt\n+    // Necessary since bind_irrefutable_pat is called outside trans_match\n     match /*bad*/copy pat.node {\n         ast::pat_ident(_, _,inner) => {\n             if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {", "previous_filename": "src/librustc/middle/trans/alt.rs"}, {"sha": "c3b4adeaf8ba21e96b2d9cff18b6d22277941906", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -41,7 +41,7 @@ use metadata::{csearch, cstore, decoder, encoder};\n use middle::astencode;\n use middle::pat_util::*;\n use middle::resolve;\n-use middle::trans::alt;\n+use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n@@ -1045,11 +1045,11 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n            bcx.to_str());\n     add_clean(bcx, llptr, ty);\n \n-    return alt::bind_irrefutable_pat(bcx,\n-                                     local.node.pat,\n-                                     llptr,\n-                                     false,\n-                                     alt::BindLocal);\n+    return _match::bind_irrefutable_pat(bcx,\n+                                       local.node.pat,\n+                                       llptr,\n+                                       false,\n+                                       _match::BindLocal);\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n@@ -1597,11 +1597,11 @@ fn copy_args_to_allocas(fcx: fn_ctxt,\n             }\n         }\n \n-        bcx = alt::bind_irrefutable_pat(bcx,\n-                                        args[arg_n].pat,\n-                                        llarg,\n-                                        false,\n-                                        alt::BindArgument);\n+        bcx = _match::bind_irrefutable_pat(bcx,\n+                                          args[arg_n].pat,\n+                                          llarg,\n+                                          false,\n+                                          _match::BindArgument);\n \n         fcx.llargs.insert(arg_id, local_mem(llarg));\n "}, {"sha": "10edfb2f92925b05371cf3102d98785e172d0b0d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -266,7 +266,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let fname = /*bad*/copy start.file.name;\n     let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n     let tg = LexicalBlockTag;\n-    /*alt cached_metadata::<@metadata<block_md>>(\n+    /*match cached_metadata::<@metadata<block_md>>(\n         cache, tg,\n         {|md| start == md.data.start && end == md.data.end}) {\n       option::Some(md) { return md; }"}, {"sha": "ed9abea465b1b1d38228fa9e11cf16c3b3317346", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -528,7 +528,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return controlflow::trans_if(bcx, cond, (*thn), els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n-            return alt::trans_alt(bcx, expr, discr, /*bad*/copy *arms, dest);\n+            return _match::trans_match(bcx, expr, discr, /*bad*/copy *arms,\n+                                       dest);\n         }\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, (*blk).info(),"}, {"sha": "7ff3dfcb07387d0382d4cf53830c1acebbd81599", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -21,10 +21,10 @@ use syntax::ast_util::walk_pat;\n use syntax::ast_util;\n use syntax::print::pprust;\n \n-fn check_alt(fcx: @fn_ctxt,\n-             expr: @ast::expr,\n-             discrim: @ast::expr,\n-             arms: ~[ast::arm]) -> bool {\n+fn check_match(fcx: @fn_ctxt,\n+               expr: @ast::expr,\n+               discrim: @ast::expr,\n+               arms: ~[ast::arm]) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let mut bot;\n \n@@ -37,7 +37,7 @@ fn check_alt(fcx: @fn_ctxt,\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n-            alt_region: ty::re_scope(expr.id),\n+            match_region: ty::re_scope(expr.id),\n             block_region: ty::re_scope(arm.body.node.id)\n         };\n \n@@ -65,7 +65,7 @@ fn check_alt(fcx: @fn_ctxt,\n struct pat_ctxt {\n     fcx: @fn_ctxt,\n     map: PatIdMap,\n-    alt_region: ty::Region,   // Region for the alt as a whole\n+    match_region: ty::Region, // Region for the match as a whole\n     block_region: ty::Region, // Region for the block of the arm\n }\n \n@@ -389,7 +389,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, typ);\n \n-        debug!(\"(checking alt) writing type for pat id %d\", pat.id);\n+        debug!(\"(checking match) writing type for pat id %d\", pat.id);\n \n         match sub {\n           Some(p) => check_pat(pcx, p, expected),", "previous_filename": "src/librustc/middle/typeck/check/alt.rs"}, {"sha": "4eaf6311148b760f605d47670ad1b572bb24edc6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -85,7 +85,7 @@ use middle::ty;\n use middle::typeck::astconv::{ast_conv, ast_path_to_ty};\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n-use middle::typeck::check::alt::pat_ctxt;\n+use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::TransformTypeNormally;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_ty;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n@@ -117,7 +117,7 @@ use syntax::print::pprust;\n use syntax::visit;\n use syntax;\n \n-export alt;\n+export _match;\n export vtable;\n export writeback;\n export regionmanip;\n@@ -133,7 +133,7 @@ export DoDerefArgs;\n export check_item_types;\n \n #[legacy_exports]\n-pub mod alt;\n+pub mod _match;\n #[legacy_exports]\n pub mod vtable;\n #[legacy_exports]\n@@ -427,10 +427,10 @@ fn check_fn(ccx: @crate_ctxt,\n             let pcx = pat_ctxt {\n                 fcx: fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n-                alt_region: region,\n+                match_region: region,\n                 block_region: region,\n             };\n-            alt::check_pat(pcx, input.pat, *arg_ty);\n+            _match::check_pat(pcx, input.pat, *arg_ty);\n         }\n \n         // Add explicitly-declared locals.\n@@ -2124,7 +2124,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = !may_break(tcx, expr.id, (*body));\n       }\n       ast::expr_match(discrim, ref arms) => {\n-        bot = alt::check_alt(fcx, expr, discrim, (/*bad*/copy *arms));\n+        bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n       ast::expr_fn(proto, ref decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, Some(proto),\n@@ -2517,10 +2517,10 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n-        alt_region: region,\n+        match_region: region,\n         block_region: region,\n     };\n-    alt::check_pat(pcx, local.node.pat, t);\n+    _match::check_pat(pcx, local.node.pat, t);\n     return bot;\n }\n "}, {"sha": "60780df52873d2954280c1628ee10c853c8b1250", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -77,7 +77,7 @@ mod middle {\n         #[legacy_exports]\n         mod base;\n         #[legacy_exports]\n-        mod alt;\n+        mod _match;\n         #[legacy_exports]\n         mod uniq;\n         #[legacy_exports]\n@@ -109,7 +109,7 @@ mod middle {\n     #[legacy_exports]\n     mod check_loop;\n     #[legacy_exports]\n-    mod check_alt;\n+    mod check_match;\n     #[legacy_exports]\n     mod check_const;\n     #[legacy_exports]"}, {"sha": "12dd40356eb558dfda1c00b15205c5f948b8cc05", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -158,7 +158,7 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::expr_match(*) => {\n-            fmt!(\"<alt at %s>\",\n+            fmt!(\"<match at %s>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::expr_assign_op(*) |"}, {"sha": "724e2fc9dba6383bf4d2ca2d970a010bcbfde4a2", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -245,7 +245,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n             /* at end of sequence */\n             if idx >= len {\n-                // can't move out of `alt`s, so:\n+                // can't move out of `match`es, so:\n                 if is_some(ei.up) {\n                     // hack: a matcher sequence is repeating iff it has a\n                     // parent (the top level is just a container)"}, {"sha": "f32a782622a1fd030ff2b762807274ef068e2bee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -940,7 +940,7 @@ impl Parser {\n         } else if self.eat_keyword(~\"loop\") {\n             return self.parse_loop_expr();\n         } else if self.eat_keyword(~\"match\") {\n-            return self.parse_alt_expr();\n+            return self.parse_match_expr();\n         } else if self.eat_keyword(~\"fn\") {\n             let opt_proto = self.parse_fn_ty_proto();\n             let proto = match opt_proto {\n@@ -1722,7 +1722,7 @@ impl Parser {\n         return expr_rec(fields, base);\n     }\n \n-    fn parse_alt_expr() -> @expr {\n+    fn parse_match_expr() -> @expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.expect(token::LBRACE);"}, {"sha": "239cff22cc0c26b13f9f67712fb91430ed2615f6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2791877009996dba1a4c7b84fbd7af01ac36bd04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2791877009996dba1a4c7b84fbd7af01ac36bd04", "patch": "@@ -83,7 +83,7 @@ fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n }\n \n const indent_unit: uint = 4u;\n-const alt_indent_unit: uint = 2u;\n+const match_indent_unit: uint = 2u;\n \n const default_columns: uint = 78u;\n \n@@ -1251,7 +1251,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_block(s, (*blk));\n       }\n       ast::expr_match(expr, ref arms) => {\n-        cbox(s, alt_indent_unit);\n+        cbox(s, match_indent_unit);\n         ibox(s, 4);\n         word_nbsp(s, ~\"match\");\n         print_expr(s, expr);\n@@ -1260,7 +1260,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         let len = (*arms).len();\n         for (*arms).eachi |i, arm| {\n             space(s.s);\n-            cbox(s, alt_indent_unit);\n+            cbox(s, match_indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n             for arm.pats.each |p| {\n@@ -1293,7 +1293,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                             ast::expr_block(ref blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n-                                    s, (*blk), alt_indent_unit);\n+                                    s, (*blk), match_indent_unit);\n                             }\n                             _ => {\n                                 end(s); // close the ibox for the pattern\n@@ -1310,10 +1310,10 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                print_block_unclosed_indent(s, arm.body, alt_indent_unit);\n+                print_block_unclosed_indent(s, arm.body, match_indent_unit);\n             }\n         }\n-        bclose_(s, expr.span, alt_indent_unit);\n+        bclose_(s, expr.span, match_indent_unit);\n       }\n       ast::expr_fn(proto, decl, ref body, cap_clause) => {\n         // containing cbox, will be closed by print-block at }"}]}