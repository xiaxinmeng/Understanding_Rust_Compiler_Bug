{"sha": "05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZTFjN2IxOTcyYTg3YWJlNmQzNTJiNWQwY2Q4YTU4ZTJiN2FkYzc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-08T14:11:57Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-08T14:15:46Z"}, "message": "Handle visibility for assoc item path completion as well", "tree": {"sha": "20baf0458f8909b101d5f0fe84bd577b76644058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20baf0458f8909b101d5f0fe84bd577b76644058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "html_url": "https://github.com/rust-lang/rust/commit/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9c77c54534fcde7c432c6e11746d636d972a20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c77c54534fcde7c432c6e11746d636d972a20b", "html_url": "https://github.com/rust-lang/rust/commit/d9c77c54534fcde7c432c6e11746d636d972a20b"}], "stats": {"total": 146, "additions": 124, "deletions": 22}, "files": [{"sha": "911c809fdde5a04741a6d9109f8e443487a84352", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "patch": "@@ -204,19 +204,25 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase, visible_from: Option<Module>) -> Vec<(Name, ScopeDef)> {\n+    pub fn scope(\n+        self,\n+        db: &impl HirDatabase,\n+        visible_from: Option<Module>,\n+    ) -> Vec<(Name, ScopeDef)> {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n-            .filter_map(|(name, def)| if let Some(m) = visible_from {\n-                let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));\n-                if filtered.is_none() && !def.is_none() {\n-                    None\n+            .filter_map(|(name, def)| {\n+                if let Some(m) = visible_from {\n+                    let filtered = def.filter_visibility(|vis| vis.is_visible_from(db, m.id));\n+                    if filtered.is_none() && !def.is_none() {\n+                        None\n+                    } else {\n+                        Some((name, filtered))\n+                    }\n                 } else {\n-                    Some((name, filtered))\n+                    Some((name, def))\n                 }\n-            } else {\n-                Some((name, def))\n             })\n             .map(|(name, def)| (name.clone(), def.into()))\n             .collect()\n@@ -608,6 +614,14 @@ impl Const {\n     }\n }\n \n+impl HasVisibility for Const {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let function_data = db.const_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db, &self.id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Static {\n     pub(crate) id: StaticId,\n@@ -682,6 +696,14 @@ impl TypeAlias {\n     }\n }\n \n+impl HasVisibility for TypeAlias {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        let function_data = db.type_alias_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db, &self.id.resolver(db))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n@@ -769,6 +791,16 @@ impl AssocItem {\n     }\n }\n \n+impl HasVisibility for AssocItem {\n+    fn visibility(&self, db: &impl HirDatabase) -> Visibility {\n+        match self {\n+            AssocItem::Function(f) => f.visibility(db),\n+            AssocItem::Const(c) => c.visibility(db),\n+            AssocItem::TypeAlias(t) => t.visibility(db),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n     Function(Function),"}, {"sha": "a72eb53690a5df58ad8a978e99956fd29e57492c", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "patch": "@@ -97,17 +97,19 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n+    pub visibility: RawVisibility,\n }\n \n impl TypeAliasData {\n     pub(crate) fn type_alias_data_query(\n         db: &impl DefDatabase,\n         typ: TypeAliasId,\n     ) -> Arc<TypeAliasData> {\n-        let node = typ.lookup(db).source(db).value;\n-        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.type_ref().map(TypeRef::from_ast);\n-        Arc::new(TypeAliasData { name, type_ref })\n+        let node = typ.lookup(db).source(db);\n+        let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n+        let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n+        let visibility = RawVisibility::from_ast(db, node.map(|n| n.visibility()));\n+        Arc::new(TypeAliasData { name, type_ref, visibility })\n     }\n }\n \n@@ -223,23 +225,28 @@ pub struct ConstData {\n     /// const _: () = ();\n     pub name: Option<Name>,\n     pub type_ref: TypeRef,\n+    pub visibility: RawVisibility,\n }\n \n impl ConstData {\n     pub(crate) fn const_data_query(db: &impl DefDatabase, konst: ConstId) -> Arc<ConstData> {\n-        let node = konst.lookup(db).source(db).value;\n-        Arc::new(ConstData::new(&node))\n+        let node = konst.lookup(db).source(db);\n+        Arc::new(ConstData::new(db, node))\n     }\n \n     pub(crate) fn static_data_query(db: &impl DefDatabase, konst: StaticId) -> Arc<ConstData> {\n-        let node = konst.lookup(db).source(db).value;\n-        Arc::new(ConstData::new(&node))\n+        let node = konst.lookup(db).source(db);\n+        Arc::new(ConstData::new(db, node))\n     }\n \n-    fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(node: &N) -> ConstData {\n-        let name = node.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(node.ascribed_type());\n-        ConstData { name, type_ref }\n+    fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n+        db: &impl DefDatabase,\n+        node: InFile<N>,\n+    ) -> ConstData {\n+        let name = node.value.name().map(|n| n.as_name());\n+        let type_ref = TypeRef::from_ast_opt(node.value.ascribed_type());\n+        let visibility = RawVisibility::from_ast(db, node.map(|n| n.visibility()));\n+        ConstData { name, type_ref, visibility }\n     }\n }\n "}, {"sha": "d2c75857126eba77e83f33fa0ce1699a7fff5415", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=05e1c7b1972a87abe6d352b5d0cd8a58e2b7adc7", "patch": "@@ -1,6 +1,6 @@\n //! Completion of paths, including when writing a single name.\n \n-use hir::{Adt, PathResolution, ScopeDef, HasVisibility};\n+use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -52,9 +52,12 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope().traits_in_scope();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n                     match item {\n                         hir::AssocItem::Function(func) => {\n-                            if !func.has_self_param(ctx.db) && context_module.map_or(true, |m| func.is_visible_from(ctx.db, m)) {\n+                            if !func.has_self_param(ctx.db) {\n                                 acc.add_function(ctx, func);\n                             }\n                         }\n@@ -65,6 +68,9 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 });\n \n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n                     match item {\n                         hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => {}\n                         hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n@@ -75,6 +81,9 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n         hir::ModuleDef::Trait(t) => {\n             for item in t.items(ctx.db) {\n+                if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    continue;\n+                }\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {\n@@ -537,6 +546,60 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn associated_item_visibility() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                struct S;\n+\n+                mod m {\n+                    impl super::S {\n+                        pub(super) fn public_method() { }\n+                        fn private_method() { }\n+                        pub(super) type PublicType = u32;\n+                        type PrivateType = u32;\n+                        pub(super) const PUBLIC_CONST: u32 = 1;\n+                        const PRIVATE_CONST: u32 = 1;\n+                    }\n+                }\n+\n+                fn foo() { let _ = S::<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"PUBLIC_CONST\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"PUBLIC_CONST\",\n+                kind: Const,\n+                detail: \"pub(super) const PUBLIC_CONST: u32 = 1;\",\n+            },\n+            CompletionItem {\n+                label: \"PublicType\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"PublicType\",\n+                kind: TypeAlias,\n+                detail: \"pub(super) type PublicType = u32;\",\n+            },\n+            CompletionItem {\n+                label: \"public_method()\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"public_method()$0\",\n+                kind: Function,\n+                lookup: \"public_method\",\n+                detail: \"pub(super) fn public_method()\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_enum_associated_method() {\n         assert_debug_snapshot!("}]}