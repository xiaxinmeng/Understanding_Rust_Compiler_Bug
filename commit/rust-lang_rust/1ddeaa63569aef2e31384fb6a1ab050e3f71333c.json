{"sha": "1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZGVhYTYzNTY5YWVmMmUzMTM4NGZiNmExYWIwNTBlM2Y3MTMzM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-30T03:59:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-30T03:59:45Z"}, "message": "Auto merge of #6990 - Y-Nak:refactor-functions, r=giraffate\n\nOrganize functions into functions module\n\nRef: #6680\nRearrange lints in `functions`.\n\nchangelog: none", "tree": {"sha": "761d7087b395d46ef38365270c7cb574aeab7057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761d7087b395d46ef38365270c7cb574aeab7057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "html_url": "https://github.com/rust-lang/rust/commit/1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5214450006f9f1a422ffe3f86affd17716dc2f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5214450006f9f1a422ffe3f86affd17716dc2f6", "html_url": "https://github.com/rust-lang/rust/commit/a5214450006f9f1a422ffe3f86affd17716dc2f6"}, {"sha": "541c8b8f69b1b14fe3de272d5fad4323cfd1ae0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/541c8b8f69b1b14fe3de272d5fad4323cfd1ae0c", "html_url": "https://github.com/rust-lang/rust/commit/541c8b8f69b1b14fe3de272d5fad4323cfd1ae0c"}], "stats": {"total": 1615, "additions": 874, "deletions": 741}, "files": [{"sha": "730492fc7e3efafd787169327b883ec2d94608a7", "filename": "clippy_lints/src/functions.rs", "status": "removed", "additions": 0, "deletions": 738, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/a5214450006f9f1a422ffe3f86affd17716dc2f6/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214450006f9f1a422ffe3f86affd17716dc2f6/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=a5214450006f9f1a422ffe3f86affd17716dc2f6", "patch": "@@ -1,738 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, type_is_unsafe_function};\n-use clippy_utils::{\n-    attr_by_name, attrs::is_proc_macro, is_trait_impl_item, iter_input_pats, match_def_path, must_use_attr,\n-    path_to_local, return_ty, trait_ref_of_method,\n-};\n-use if_chain::if_chain;\n-use rustc_ast::ast::Attribute;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit;\n-use rustc_hir::{def::Res, def_id::DefId, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n-use rustc_target::spec::abi::Abi;\n-use rustc_typeck::hir_ty_to_ty;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions with too many parameters.\n-    ///\n-    /// **Why is this bad?** Functions with lots of parameters are considered bad\n-    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n-    /// grouping some parameters into a new type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct Color;\n-    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n-    ///     // ..\n-    /// }\n-    /// ```\n-    pub TOO_MANY_ARGUMENTS,\n-    complexity,\n-    \"functions with too many arguments\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions with a large amount of lines.\n-    ///\n-    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n-    /// due to having to look at a larger amount of code to understand what the\n-    /// function is doing. Consider splitting the body of the function into\n-    /// multiple functions.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn im_too_long() {\n-    ///     println!(\"\");\n-    ///     // ... 100 more LoC\n-    ///     println!(\"\");\n-    /// }\n-    /// ```\n-    pub TOO_MANY_LINES,\n-    pedantic,\n-    \"functions with too many lines\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that dereference raw pointer\n-    /// arguments but are not marked unsafe.\n-    ///\n-    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n-    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n-    /// valid.\n-    ///\n-    /// **Known problems:**\n-    ///\n-    /// * It does not check functions recursively so if the pointer is passed to a\n-    /// private non-`unsafe` function which does the dereferencing, the lint won't\n-    /// trigger.\n-    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n-    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n-    /// `some_argument.get_raw_ptr()`).\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// // Bad\n-    /// pub fn foo(x: *const u8) {\n-    ///     println!(\"{}\", unsafe { *x });\n-    /// }\n-    ///\n-    /// // Good\n-    /// pub unsafe fn foo(x: *const u8) {\n-    ///     println!(\"{}\", unsafe { *x });\n-    /// }\n-    /// ```\n-    pub NOT_UNSAFE_PTR_ARG_DEREF,\n-    correctness,\n-    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n-    /// unit-returning functions and methods.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** Unit values are useless. The attribute is likely\n-    /// a remnant of a refactoring that removed the return type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// #[must_use]\n-    /// fn useless() { }\n-    /// ```\n-    pub MUST_USE_UNIT,\n-    style,\n-    \"`#[must_use]` attribute on a unit-returning function / method\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n-    /// further information on functions and methods that return a type already\n-    /// marked as `#[must_use]`.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** The attribute isn't needed. Not using the result\n-    /// will already be reported. Alternatively, one can add some text to the\n-    /// attribute to improve the lint message.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// #[must_use]\n-    /// fn double_must_use() -> Result<(), ()> {\n-    ///     unimplemented!();\n-    /// }\n-    /// ```\n-    pub DOUBLE_MUST_USE,\n-    style,\n-    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that have no\n-    /// [`#[must_use]`] attribute, but return something not already marked\n-    /// must-use, have no mutable arg and mutate no statics.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** Not bad at all, this lint just shows places where\n-    /// you could add the attribute.\n-    ///\n-    /// **Known problems:** The lint only checks the arguments for mutable\n-    /// types without looking if they are actually changed. On the other hand,\n-    /// it also ignores a broad range of potentially interesting side effects,\n-    /// because we cannot decide whether the programmer intends the function to\n-    /// be called for the side effect or the result. Expect many false\n-    /// positives. At least we don't lint if the result type is unit or already\n-    /// `#[must_use]`.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// // this could be annotated with `#[must_use]`.\n-    /// fn id<T>(t: T) -> T { t }\n-    /// ```\n-    pub MUST_USE_CANDIDATE,\n-    pedantic,\n-    \"function or method that could take a `#[must_use]` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that return a `Result`\n-    /// with an `Err` type of `()`. It suggests using a custom type that\n-    /// implements [`std::error::Error`].\n-    ///\n-    /// **Why is this bad?** Unit does not implement `Error` and carries no\n-    /// further information about what went wrong.\n-    ///\n-    /// **Known problems:** Of course, this lint assumes that `Result` is used\n-    /// for a fallible operation (which is after all the intended use). However\n-    /// code may opt to (mis)use it as a basic two-variant-enum. In that case,\n-    /// the suggestion is misguided, and the code should use a custom enum\n-    /// instead.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// pub fn read_u8() -> Result<u8, ()> { Err(()) }\n-    /// ```\n-    /// should become\n-    /// ```rust,should_panic\n-    /// use std::fmt;\n-    ///\n-    /// #[derive(Debug)]\n-    /// pub struct EndOfStream;\n-    ///\n-    /// impl fmt::Display for EndOfStream {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         write!(f, \"End of Stream\")\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for EndOfStream { }\n-    ///\n-    /// pub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n-    ///# fn main() {\n-    ///#     read_u8().unwrap();\n-    ///# }\n-    /// ```\n-    ///\n-    /// Note that there are crates that simplify creating the error type, e.g.\n-    /// [`thiserror`](https://docs.rs/thiserror).\n-    pub RESULT_UNIT_ERR,\n-    style,\n-    \"public function returning `Result` with an `Err` type of `()`\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Functions {\n-    threshold: u64,\n-    max_lines: u64,\n-}\n-\n-impl Functions {\n-    pub fn new(threshold: u64, max_lines: u64) -> Self {\n-        Self { threshold, max_lines }\n-    }\n-}\n-\n-impl_lint_pass!(Functions => [\n-    TOO_MANY_ARGUMENTS,\n-    TOO_MANY_LINES,\n-    NOT_UNSAFE_PTR_ARG_DEREF,\n-    MUST_USE_UNIT,\n-    DOUBLE_MUST_USE,\n-    MUST_USE_CANDIDATE,\n-    RESULT_UNIT_ERR,\n-]);\n-\n-impl<'tcx> LateLintPass<'tcx> for Functions {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: intravisit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        body: &'tcx hir::Body<'_>,\n-        span: Span,\n-        hir_id: hir::HirId,\n-    ) {\n-        let unsafety = match kind {\n-            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-            intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n-            intravisit::FnKind::Closure => return,\n-        };\n-\n-        // don't warn for implementations, it's not their fault\n-        if !is_trait_impl_item(cx, hir_id) {\n-            // don't lint extern functions decls, it's not their fault either\n-            match kind {\n-                intravisit::FnKind::Method(\n-                    _,\n-                    &hir::FnSig {\n-                        header: hir::FnHeader { abi: Abi::Rust, .. },\n-                        ..\n-                    },\n-                    _,\n-                )\n-                | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => {\n-                    self.check_arg_number(cx, decl, span.with_hi(decl.output.span().hi()))\n-                },\n-                _ => {},\n-            }\n-        }\n-\n-        Self::check_raw_ptr(cx, unsafety, decl, body, hir_id);\n-        self.check_line_number(cx, span, body);\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n-        if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-                return;\n-            }\n-            if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this function could have a `#[must_use]` attribute\",\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none()\n-            {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this method could have a `#[must_use]` attribute\",\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-            // don't lint extern functions decls, it's not their fault\n-            if sig.header.abi == Abi::Rust {\n-                self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n-            }\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            }\n-            if let hir::TraitFn::Provided(eid) = *eid {\n-                let body = cx.tcx.hir().body(eid);\n-                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n-\n-                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n-                    check_must_use_candidate(\n-                        cx,\n-                        &sig.decl,\n-                        body,\n-                        item.span,\n-                        item.hir_id(),\n-                        item.span.with_hi(sig.decl.output.span().hi()),\n-                        \"this method could have a `#[must_use]` attribute\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span) {\n-        let args = decl.inputs.len() as u64;\n-        if args > self.threshold {\n-            span_lint(\n-                cx,\n-                TOO_MANY_ARGUMENTS,\n-                fn_span,\n-                &format!(\"this function has too many arguments ({}/{})\", args, self.threshold),\n-            );\n-        }\n-    }\n-\n-    fn check_line_number(self, cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>) {\n-        if in_external_macro(cx.sess(), span) {\n-            return;\n-        }\n-\n-        let code_snippet = snippet(cx, body.value.span, \"..\");\n-        let mut line_count: u64 = 0;\n-        let mut in_comment = false;\n-        let mut code_in_line;\n-\n-        // Skip the surrounding function decl.\n-        let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n-        let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n-        let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n-\n-        for mut line in function_lines {\n-            code_in_line = false;\n-            loop {\n-                line = line.trim_start();\n-                if line.is_empty() {\n-                    break;\n-                }\n-                if in_comment {\n-                    if let Some(i) = line.find(\"*/\") {\n-                        line = &line[i + 2..];\n-                        in_comment = false;\n-                        continue;\n-                    }\n-                } else {\n-                    let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n-                    let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n-                    code_in_line |= multi_idx > 0 && single_idx > 0;\n-                    // Implies multi_idx is below line.len()\n-                    if multi_idx < single_idx {\n-                        line = &line[multi_idx + 2..];\n-                        in_comment = true;\n-                        continue;\n-                    }\n-                }\n-                break;\n-            }\n-            if code_in_line {\n-                line_count += 1;\n-            }\n-        }\n-\n-        if line_count > self.max_lines {\n-            span_lint(\n-                cx,\n-                TOO_MANY_LINES,\n-                span,\n-                &format!(\"this function has too many lines ({}/{})\", line_count, self.max_lines),\n-            )\n-        }\n-    }\n-\n-    fn check_raw_ptr(\n-        cx: &LateContext<'tcx>,\n-        unsafety: hir::Unsafety,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        body: &'tcx hir::Body<'_>,\n-        hir_id: hir::HirId,\n-    ) {\n-        let expr = &body.value;\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n-            let raw_ptrs = iter_input_pats(decl, body)\n-                .zip(decl.inputs.iter())\n-                .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n-                .collect::<FxHashSet<_>>();\n-\n-            if !raw_ptrs.is_empty() {\n-                let typeck_results = cx.tcx.typeck_body(body.id());\n-                let mut v = DerefVisitor {\n-                    cx,\n-                    ptrs: raw_ptrs,\n-                    typeck_results,\n-                };\n-\n-                intravisit::walk_expr(&mut v, expr);\n-            }\n-        }\n-    }\n-}\n-\n-fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n-    if_chain! {\n-        if !in_external_macro(cx.sess(), item_span);\n-        if let hir::FnRetTy::Return(ref ty) = decl.output;\n-        let ty = hir_ty_to_ty(cx.tcx, ty);\n-        if is_type_diagnostic_item(cx, ty, sym::result_type);\n-        if let ty::Adt(_, substs) = ty.kind();\n-        let err_ty = substs.type_at(1);\n-        if err_ty.is_unit();\n-        then {\n-            span_lint_and_help(\n-                cx,\n-                RESULT_UNIT_ERR,\n-                fn_header_span,\n-                \"this returns a `Result<_, ()>\",\n-                None,\n-                \"use a custom Error type instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn check_needless_must_use(\n-    cx: &LateContext<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    item_id: hir::HirId,\n-    item_span: Span,\n-    fn_header_span: Span,\n-    attr: &Attribute,\n-) {\n-    if in_external_macro(cx.sess(), item_span) {\n-        return;\n-    }\n-    if returns_unit(decl) {\n-        span_lint_and_then(\n-            cx,\n-            MUST_USE_UNIT,\n-            fn_header_span,\n-            \"this unit-returning function has a `#[must_use]` attribute\",\n-            |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-        );\n-    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n-        span_lint_and_help(\n-            cx,\n-            DOUBLE_MUST_USE,\n-            fn_header_span,\n-            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n-            None,\n-            \"either add some descriptive text or remove the attribute\",\n-        );\n-    }\n-}\n-\n-fn check_must_use_candidate<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    decl: &'tcx hir::FnDecl<'_>,\n-    body: &'tcx hir::Body<'_>,\n-    item_span: Span,\n-    item_id: hir::HirId,\n-    fn_span: Span,\n-    msg: &str,\n-) {\n-    if has_mutable_arg(cx, body)\n-        || mutates_static(cx, body)\n-        || in_external_macro(cx.sess(), item_span)\n-        || returns_unit(decl)\n-        || !cx.access_levels.is_exported(item_id)\n-        || is_must_use_ty(cx, return_ty(cx, item_id))\n-    {\n-        return;\n-    }\n-    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n-        if let Some(snippet) = snippet_opt(cx, fn_span) {\n-            diag.span_suggestion(\n-                fn_span,\n-                \"add the attribute\",\n-                format!(\"#[must_use] {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n-}\n-\n-fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => true,\n-        hir::FnRetTy::Return(ref ty) => match ty.kind {\n-            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n-            hir::TyKind::Never => true,\n-            _ => false,\n-        },\n-    }\n-}\n-\n-fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n-    let mut tys = FxHashSet::default();\n-    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n-}\n-\n-fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n-    if let hir::PatKind::Wild = pat.kind {\n-        return false; // ignore `_` patterns\n-    }\n-    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n-    } else {\n-        false\n-    }\n-}\n-\n-static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n-\n-fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n-    match *ty.kind() {\n-        // primitive types are never mutable\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n-        ty::Adt(ref adt, ref substs) => {\n-            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n-                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n-        },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n-        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n-        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n-        },\n-        // calling something constitutes a side effect, so return true on all callables\n-        // also never calls need not be used, so return true for them, too\n-        _ => true,\n-    }\n-}\n-\n-fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n-        Some(id)\n-    } else {\n-        None\n-    }\n-}\n-\n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: FxHashSet<hir::HirId>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(ref f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n-\n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n-            Call(_, args) | MethodCall(_, _, args, _) => {\n-                let mut tys = FxHashSet::default();\n-                for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n-                        && is_mutated_static(arg)\n-                    {\n-                        self.mutates_static = true;\n-                        return;\n-                    }\n-                    tys.clear();\n-                }\n-            },\n-            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n-                self.mutates_static |= is_mutated_static(target)\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, &body.value);\n-    v.mutates_static\n-}"}, {"sha": "2beb9bc94bf06397f203a9e9a1a849335083d353", "filename": "clippy_lints/src/functions/mod.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,267 @@\n+mod must_use;\n+mod not_unsafe_ptr_arg_deref;\n+mod result_unit_err;\n+mod too_many_arguments;\n+mod too_many_lines;\n+\n+use rustc_hir as hir;\n+use rustc_hir::intravisit;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with too many parameters.\n+    ///\n+    /// **Why is this bad?** Functions with lots of parameters are considered bad\n+    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+    /// grouping some parameters into a new type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct Color;\n+    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub TOO_MANY_ARGUMENTS,\n+    complexity,\n+    \"functions with too many arguments\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with a large amount of lines.\n+    ///\n+    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n+    /// due to having to look at a larger amount of code to understand what the\n+    /// function is doing. Consider splitting the body of the function into\n+    /// multiple functions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn im_too_long() {\n+    ///     println!(\"\");\n+    ///     // ... 100 more LoC\n+    ///     println!(\"\");\n+    /// }\n+    /// ```\n+    pub TOO_MANY_LINES,\n+    pedantic,\n+    \"functions with too many lines\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that dereference raw pointer\n+    /// arguments but are not marked `unsafe`.\n+    ///\n+    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n+    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+    /// valid.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * It does not check functions recursively so if the pointer is passed to a\n+    /// private non-`unsafe` function which does the dereferencing, the lint won't\n+    /// trigger.\n+    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n+    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+    /// `some_argument.get_raw_ptr()`).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// pub fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    ///\n+    /// // Good\n+    /// pub unsafe fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    /// ```\n+    pub NOT_UNSAFE_PTR_ARG_DEREF,\n+    correctness,\n+    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n+    /// unit-returning functions and methods.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Unit values are useless. The attribute is likely\n+    /// a remnant of a refactoring that removed the return type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn useless() { }\n+    /// ```\n+    pub MUST_USE_UNIT,\n+    style,\n+    \"`#[must_use]` attribute on a unit-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n+    /// further information on functions and methods that return a type already\n+    /// marked as `#[must_use]`.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** The attribute isn't needed. Not using the result\n+    /// will already be reported. Alternatively, one can add some text to the\n+    /// attribute to improve the lint message.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn double_must_use() -> Result<(), ()> {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub DOUBLE_MUST_USE,\n+    style,\n+    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that have no\n+    /// [`#[must_use]`] attribute, but return something not already marked\n+    /// must-use, have no mutable arg and mutate no statics.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Not bad at all, this lint just shows places where\n+    /// you could add the attribute.\n+    ///\n+    /// **Known problems:** The lint only checks the arguments for mutable\n+    /// types without looking if they are actually changed. On the other hand,\n+    /// it also ignores a broad range of potentially interesting side effects,\n+    /// because we cannot decide whether the programmer intends the function to\n+    /// be called for the side effect or the result. Expect many false\n+    /// positives. At least we don't lint if the result type is unit or already\n+    /// `#[must_use]`.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// // this could be annotated with `#[must_use]`.\n+    /// fn id<T>(t: T) -> T { t }\n+    /// ```\n+    pub MUST_USE_CANDIDATE,\n+    pedantic,\n+    \"function or method that could take a `#[must_use]` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that return a `Result`\n+    /// with an `Err` type of `()`. It suggests using a custom type that\n+    /// implements `std::error::Error`.\n+    ///\n+    /// **Why is this bad?** Unit does not implement `Error` and carries no\n+    /// further information about what went wrong.\n+    ///\n+    /// **Known problems:** Of course, this lint assumes that `Result` is used\n+    /// for a fallible operation (which is after all the intended use). However\n+    /// code may opt to (mis)use it as a basic two-variant-enum. In that case,\n+    /// the suggestion is misguided, and the code should use a custom enum\n+    /// instead.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// pub fn read_u8() -> Result<u8, ()> { Err(()) }\n+    /// ```\n+    /// should become\n+    /// ```rust,should_panic\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// pub struct EndOfStream;\n+    ///\n+    /// impl fmt::Display for EndOfStream {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         write!(f, \"End of Stream\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for EndOfStream { }\n+    ///\n+    /// pub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n+    ///# fn main() {\n+    ///#     read_u8().unwrap();\n+    ///# }\n+    /// ```\n+    ///\n+    /// Note that there are crates that simplify creating the error type, e.g.\n+    /// [`thiserror`](https://docs.rs/thiserror).\n+    pub RESULT_UNIT_ERR,\n+    style,\n+    \"public function returning `Result` with an `Err` type of `()`\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Functions {\n+    too_many_arguments_threshold: u64,\n+    too_many_lines_threshold: u64,\n+}\n+\n+impl Functions {\n+    pub fn new(too_many_arguments_threshold: u64, too_many_lines_threshold: u64) -> Self {\n+        Self {\n+            too_many_arguments_threshold,\n+            too_many_lines_threshold,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(Functions => [\n+    TOO_MANY_ARGUMENTS,\n+    TOO_MANY_LINES,\n+    NOT_UNSAFE_PTR_ARG_DEREF,\n+    MUST_USE_UNIT,\n+    DOUBLE_MUST_USE,\n+    MUST_USE_CANDIDATE,\n+    RESULT_UNIT_ERR,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Functions {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'_>,\n+        body: &'tcx hir::Body<'_>,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        too_many_arguments::check_fn(cx, kind, decl, span, hir_id, self.too_many_arguments_threshold);\n+        too_many_lines::check_fn(cx, span, body, self.too_many_lines_threshold);\n+        not_unsafe_ptr_arg_deref::check_fn(cx, kind, decl, body, hir_id);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        must_use::check_item(cx, item);\n+        result_unit_err::check_item(cx, item);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+        must_use::check_impl_item(cx, item);\n+        result_unit_err::check_impl_item(cx, item);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        too_many_arguments::check_trait_item(cx, item, self.too_many_arguments_threshold);\n+        not_unsafe_ptr_arg_deref::check_trait_item(cx, item);\n+        must_use::check_trait_item(cx, item);\n+        result_unit_err::check_trait_item(cx, item);\n+    }\n+}"}, {"sha": "3825699936ffde6d2b136cb470e2195c89fe115c", "filename": "clippy_lints/src/functions/must_use.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,272 @@\n+use rustc_ast::ast::Attribute;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def::Res, def_id::DefId, intravisit, QPath};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::{\n+    hir::map::Map,\n+    lint::in_external_macro,\n+    ty::{self, Ty},\n+};\n+use rustc_span::Span;\n+\n+use clippy_utils::attrs::is_proc_macro;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::{attr_by_name, match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+\n+use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n+\n+pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let attr = must_use_attr(attrs);\n+    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            return;\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n+            check_must_use_candidate(\n+                cx,\n+                &sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this function could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            check_must_use_candidate(\n+                cx,\n+                &sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this method could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if let hir::TraitFn::Provided(eid) = *eid {\n+            let body = cx.tcx.hir().body(eid);\n+            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+                check_must_use_candidate(\n+                    cx,\n+                    &sig.decl,\n+                    body,\n+                    item.span,\n+                    item.hir_id(),\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this method could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_must_use(\n+    cx: &LateContext<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    item_id: hir::HirId,\n+    item_span: Span,\n+    fn_header_span: Span,\n+    attr: &Attribute,\n+) {\n+    if in_external_macro(cx.sess(), item_span) {\n+        return;\n+    }\n+    if returns_unit(decl) {\n+        span_lint_and_then(\n+            cx,\n+            MUST_USE_UNIT,\n+            fn_header_span,\n+            \"this unit-returning function has a `#[must_use]` attribute\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    \"\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        span_lint_and_help(\n+            cx,\n+            DOUBLE_MUST_USE,\n+            fn_header_span,\n+            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n+            None,\n+            \"either add some descriptive text or remove the attribute\",\n+        );\n+    }\n+}\n+\n+fn check_must_use_candidate<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    body: &'tcx hir::Body<'_>,\n+    item_span: Span,\n+    item_id: hir::HirId,\n+    fn_span: Span,\n+    msg: &str,\n+) {\n+    if has_mutable_arg(cx, body)\n+        || mutates_static(cx, body)\n+        || in_external_macro(cx.sess(), item_span)\n+        || returns_unit(decl)\n+        || !cx.access_levels.is_exported(item_id)\n+        || is_must_use_ty(cx, return_ty(cx, item_id))\n+    {\n+        return;\n+    }\n+    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n+        if let Some(snippet) = snippet_opt(cx, fn_span) {\n+            diag.span_suggestion(\n+                fn_span,\n+                \"add the attribute\",\n+                format!(\"#[must_use] {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n+    match decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => true,\n+        hir::FnRetTy::Return(ref ty) => match ty.kind {\n+            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n+            hir::TyKind::Never => true,\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n+    let mut tys = FxHashSet::default();\n+    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n+}\n+\n+fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n+    if let hir::PatKind::Wild = pat.kind {\n+        return false; // ignore `_` patterns\n+    }\n+    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n+    } else {\n+        false\n+    }\n+}\n+\n+static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n+    match *ty.kind() {\n+        // primitive types are never mutable\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n+        ty::Adt(ref adt, ref substs) => {\n+            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+        },\n+        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+        },\n+        // calling something constitutes a side effect, so return true on all callables\n+        // also never calls need not be used, so return true for them, too\n+        _ => true,\n+    }\n+}\n+\n+struct StaticMutVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    mutates_static: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n+\n+        if self.mutates_static {\n+            return;\n+        }\n+        match expr.kind {\n+            Call(_, args) | MethodCall(_, _, args, _) => {\n+                let mut tys = FxHashSet::default();\n+                for arg in args {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n+            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n+                self.mutates_static |= is_mutated_static(target)\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n+}\n+\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    let mut v = StaticMutVisitor {\n+        cx,\n+        mutates_static: false,\n+    };\n+    intravisit::walk_expr(&mut v, &body.value);\n+    v.mutates_static\n+}"}, {"sha": "ac02b60a356f689bea866b734b5c60aaf6dde0cc", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,125 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{self as hir, intravisit};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::{iter_input_pats, path_to_local};\n+\n+use super::NOT_UNSAFE_PTR_ARG_DEREF;\n+\n+pub(super) fn check_fn(\n+    cx: &LateContext<'tcx>,\n+    kind: intravisit::FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let unsafety = match kind {\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n+        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::Closure => return,\n+    };\n+\n+    check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n+        let body = cx.tcx.hir().body(eid);\n+        check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n+    }\n+}\n+\n+fn check_raw_ptr(\n+    cx: &LateContext<'tcx>,\n+    unsafety: hir::Unsafety,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let expr = &body.value;\n+    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n+        let raw_ptrs = iter_input_pats(decl, body)\n+            .zip(decl.inputs.iter())\n+            .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+            .collect::<FxHashSet<_>>();\n+\n+        if !raw_ptrs.is_empty() {\n+            let typeck_results = cx.tcx.typeck_body(body.id());\n+            let mut v = DerefVisitor {\n+                cx,\n+                ptrs: raw_ptrs,\n+                typeck_results,\n+            };\n+\n+            intravisit::walk_expr(&mut v, expr);\n+        }\n+    }\n+}\n+\n+fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n+        Some(id)\n+    } else {\n+        None\n+    }\n+}\n+\n+struct DerefVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ptrs: FxHashSet<hir::HirId>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        match expr.kind {\n+            hir::ExprKind::Call(ref f, args) => {\n+                let ty = self.typeck_results.expr_ty(f);\n+\n+                if type_is_unsafe_function(self.cx, ty) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n+                let base_type = self.cx.tcx.type_of(def_id);\n+\n+                if type_is_unsafe_function(self.cx, base_type) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n+            _ => (),\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n+    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n+        if let Some(id) = path_to_local(ptr) {\n+            if self.ptrs.contains(&id) {\n+                span_lint(\n+                    self.cx,\n+                    NOT_UNSAFE_PTR_ARG_DEREF,\n+                    ptr.span,\n+                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "f71bfc690f6c6dc3f8a18acaecc170d04b014135", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,66 @@\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_span::{sym, Span};\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::trait_ref_of_method;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+\n+use super::RESULT_UNIT_ERR;\n+\n+pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+    if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public {\n+            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public {\n+            check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n+    if_chain! {\n+        if !in_external_macro(cx.sess(), item_span);\n+        if let hir::FnRetTy::Return(ref ty) = decl.output;\n+        let ty = hir_ty_to_ty(cx.tcx, ty);\n+        if is_type_diagnostic_item(cx, ty, sym::result_type);\n+        if let ty::Adt(_, substs) = ty.kind();\n+        let err_ty = substs.type_at(1);\n+        if err_ty.is_unit();\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                RESULT_UNIT_ERR,\n+                fn_header_span,\n+                \"this returns a `Result<_, ()>\",\n+                None,\n+                \"use a custom Error type instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "62b1e6bd7ca4efc9c43eb44d5d4d98b5c126e0e2", "filename": "clippy_lints/src/functions/too_many_arguments.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,73 @@\n+use rustc_hir::{self as hir, intravisit};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_trait_impl_item;\n+\n+use super::TOO_MANY_ARGUMENTS;\n+\n+pub(super) fn check_fn(\n+    cx: &LateContext<'tcx>,\n+    kind: intravisit::FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    span: Span,\n+    hir_id: hir::HirId,\n+    too_many_arguments_threshold: u64,\n+) {\n+    // don't warn for implementations, it's not their fault\n+    if !is_trait_impl_item(cx, hir_id) {\n+        // don't lint extern functions decls, it's not their fault either\n+        match kind {\n+            intravisit::FnKind::Method(\n+                _,\n+                &hir::FnSig {\n+                    header: hir::FnHeader { abi: Abi::Rust, .. },\n+                    ..\n+                },\n+                _,\n+            )\n+            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => check_arg_number(\n+                cx,\n+                decl,\n+                span.with_hi(decl.output.span().hi()),\n+                too_many_arguments_threshold,\n+            ),\n+            _ => {},\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(\n+    cx: &LateContext<'tcx>,\n+    item: &'tcx hir::TraitItem<'_>,\n+    too_many_arguments_threshold: u64,\n+) {\n+    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n+        // don't lint extern functions decls, it's not their fault\n+        if sig.header.abi == Abi::Rust {\n+            check_arg_number(\n+                cx,\n+                &sig.decl,\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                too_many_arguments_threshold,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_arg_number(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span, too_many_arguments_threshold: u64) {\n+    let args = decl.inputs.len() as u64;\n+    if args > too_many_arguments_threshold {\n+        span_lint(\n+            cx,\n+            TOO_MANY_ARGUMENTS,\n+            fn_span,\n+            &format!(\n+                \"this function has too many arguments ({}/{})\",\n+                args, too_many_arguments_threshold\n+            ),\n+        );\n+    }\n+}"}, {"sha": "aa5494d5a7d2c74b54f251f4325b2cd52df7aabd", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -0,0 +1,68 @@\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_span::Span;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+\n+use super::TOO_MANY_LINES;\n+\n+pub(super) fn check_fn(cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>, too_many_lines_threshold: u64) {\n+    if in_external_macro(cx.sess(), span) {\n+        return;\n+    }\n+\n+    let code_snippet = snippet(cx, body.value.span, \"..\");\n+    let mut line_count: u64 = 0;\n+    let mut in_comment = false;\n+    let mut code_in_line;\n+\n+    // Skip the surrounding function decl.\n+    let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n+    let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n+    let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n+\n+    for mut line in function_lines {\n+        code_in_line = false;\n+        loop {\n+            line = line.trim_start();\n+            if line.is_empty() {\n+                break;\n+            }\n+            if in_comment {\n+                if let Some(i) = line.find(\"*/\") {\n+                    line = &line[i + 2..];\n+                    in_comment = false;\n+                    continue;\n+                }\n+            } else {\n+                let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n+                let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n+                code_in_line |= multi_idx > 0 && single_idx > 0;\n+                // Implies multi_idx is below line.len()\n+                if multi_idx < single_idx {\n+                    line = &line[multi_idx + 2..];\n+                    in_comment = true;\n+                    continue;\n+                }\n+            }\n+            break;\n+        }\n+        if code_in_line {\n+            line_count += 1;\n+        }\n+    }\n+\n+    if line_count > too_many_lines_threshold {\n+        span_lint(\n+            cx,\n+            TOO_MANY_LINES,\n+            span,\n+            &format!(\n+                \"this function has too many lines ({}/{})\",\n+                line_count, too_many_lines_threshold\n+            ),\n+        )\n+    }\n+}"}, {"sha": "3d3e57f7d2fbe1c72488db40884675522b70503b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddeaa63569aef2e31384fb6a1ab050e3f71333c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1ddeaa63569aef2e31384fb6a1ab050e3f71333c", "patch": "@@ -1124,9 +1124,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box new_without_default::NewWithoutDefault::default());\n     let blacklisted_names = conf.blacklisted_names.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || box blacklisted_name::BlacklistedName::new(blacklisted_names.clone()));\n-    let too_many_arguments_threshold1 = conf.too_many_arguments_threshold;\n-    let too_many_lines_threshold2 = conf.too_many_lines_threshold;\n-    store.register_late_pass(move || box functions::Functions::new(too_many_arguments_threshold1, too_many_lines_threshold2));\n+    let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n+    let too_many_lines_threshold = conf.too_many_lines_threshold;\n+    store.register_late_pass(move || box functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold));\n     let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || box doc::DocMarkdown::new(doc_valid_idents.clone()));\n     store.register_late_pass(|| box neg_multiply::NegMultiply);"}]}