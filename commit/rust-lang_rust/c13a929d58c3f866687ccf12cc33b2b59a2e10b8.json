{"sha": "c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxM2E5MjlkNThjM2Y4NjY2ODdjY2YxMmNjMzNiMmI1OWEyZTEwYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T20:41:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T20:41:30Z"}, "message": "auto merge of #12020 : alexcrichton/rust/output-flags, r=brson\n\nThis commit removes the -c, --emit-llvm, -s, --rlib, --dylib, --staticlib,\r\n--lib, and --bin flags from rustc, adding the following flags:\r\n\r\n* --emit=[asm,ir,bc,obj,link]\r\n* --crate-type=[dylib,rlib,staticlib,bin,lib]\r\n\r\nThe -o option has also been redefined to be used for *all* flavors of outputs.\r\nThis means that we no longer ignore it for libraries. The --out-dir remains the\r\nsame as before.\r\n\r\nThe new logic for files that rustc emits is as follows:\r\n\r\n1. Output types are dictated by the --emit flag. The default value is\r\n   --emit=link, and this option can be passed multiple times and have all options\r\n   stacked on one another.\r\n2. Crate types are dictated by the --crate-type flag and the #[crate_type]\r\n   attribute. The flags can be passed many times and stack with the crate\r\n   attribute.\r\n3. If the -o flag is specified, and only one output type is specified, the\r\n   output will be emitted at this location. If more than one output type is\r\n   specified, then the filename of -o is ignored, and all output goes in the\r\n   directory that -o specifies. The -o option always ignores the --out-dir\r\n   option.\r\n4. If the --out-dir flag is specified, all output goes in this directory.\r\n5. If -o and --out-dir are both not present, all output goes in the directory of\r\n   the crate file.\r\n6. When multiple output types are specified, the filestem of all output is the\r\n   same as the name of the CrateId (derived from a crate attribute or from the\r\n   filestem of the crate file).\r\n\r\nCloses #7791\r\nCloses #11056\r\nCloses #11667", "tree": {"sha": "5a37f2b5ab2e0e7e25d458f6456fda93ac713264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a37f2b5ab2e0e7e25d458f6456fda93ac713264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "html_url": "https://github.com/rust-lang/rust/commit/c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680925e258411f817ffa2ff963708ee0a0da1784", "url": "https://api.github.com/repos/rust-lang/rust/commits/680925e258411f817ffa2ff963708ee0a0da1784", "html_url": "https://github.com/rust-lang/rust/commit/680925e258411f817ffa2ff963708ee0a0da1784"}, {"sha": "6e7968b10a32cbef810dcb9e3d5bc736dbf61d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7968b10a32cbef810dcb9e3d5bc736dbf61d1f", "html_url": "https://github.com/rust-lang/rust/commit/6e7968b10a32cbef810dcb9e3d5bc736dbf61d1f"}], "stats": {"total": 775, "additions": 417, "deletions": 358}, "files": [{"sha": "0f84c26df2b02c5090859d235aed122ed1d0a271", "filename": "man/rustc.1", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -12,27 +12,21 @@ This program is a compiler for the Rust language, available at\n .SH OPTIONS\n \n .TP\n-\\fB\\-\\-bin\\fR\n-Compile an executable crate (default)\n-.TP\n-\\fB\\-c\\fR\n-Compile and assemble, but do not link\n+\\fB\\-\\-crate-type=[bin|lib|dylib|rlib|staticlib]\\fR\n+Configure the flavor of rust crate that is generated (default `bin`)\n .TP\n \\fB\\-\\-cfg\\fR SPEC\n Configure the compilation environment\n .TP\n-\\fB\\-\\-emit\\-llvm\\fR\n-Produce an LLVM bitcode file\n+\\fB\\-\\-emit=[asm,ir,bc,obj,link]\\fR\n+Configure the output that rustc will produce\n .TP\n \\fB\\-h\\fR, \\fB\\-\\-help\\fR\n Display this message\n .TP\n \\fB\\-L\\fR PATH\n Add a directory to the library search path\n .TP\n-\\fB\\-\\-lib\\fR\n-Compile a library crate\n-.TP\n \\fB\\-\\-linker\\fR LINKER\n Program to use for linking instead of the default\n .TP\n@@ -49,7 +43,7 @@ Run all passes except translation; no output\n Equivalent to \\fI\\-\\-opt\\-level=2\\fR\n .TP\n \\fB\\-o\\fR FILENAME\n-Write output to <filename>\n+Write output to <filename>. Ignored if more than one --emit is specified.\n .TP\n \\fB\\-\\-opt\\-level\\fR LEVEL\n Optimize with possible levels 0-3\n@@ -60,7 +54,8 @@ the default passes for the optimization level. A value of 'list'\n will list the available passes.\n .TP\n \\fB\\-\\-out\\-dir\\fR DIR\n-Write output to compiler-chosen filename in <dir>\n+Write output to compiler-chosen filename in <dir>. Ignored if -o is specified.\n+(default the current directory)\n .TP\n \\fB\\-\\-parse\\-only\\fR\n Parse only; do not compile, assemble, or link\n@@ -71,9 +66,6 @@ Pretty-print the input instead of compiling; valid types are: normal\n expanded, with type annotations), or identified (fully parenthesized,\n AST nodes and blocks with IDs)\n .TP\n-\\fB\\-S\\fR\n-Compile only; do not assemble or link\n-.TP\n \\fB\\-\\-save\\-temps\\fR\n Write intermediate files (.bc, .opt.bc, .o) in addition to normal output\n .TP\n@@ -120,7 +112,7 @@ To build an executable from a source file with a main function:\n     $ rustc -o hello hello.rs\n \n To build a library from a source file:\n-    $ rustc --lib hello-lib.rs\n+    $ rustc --crate-type=lib hello-lib.rs\n \n To build either with a crate (.rs) file:\n     $ rustc hello.rs"}, {"sha": "eb6c75e27d06cc9879b4283ff2511d79399f8da7", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -104,7 +104,7 @@ $(foreach crate,$(CRATES),$(eval $(call RUST_CRATE,$(crate))))\n #\n # $(1) is the crate to generate variables for\n define RUST_TOOL\n-TOOL_INPUTS_$(1) := $$(wildcard $$(addprefix $(S)$$(dir $$(TOOL_SOURCE_$(1))), \\\n+TOOL_INPUTS_$(1) := $$(wildcard $$(addprefix $$(dir $$(TOOL_SOURCE_$(1))), \\\n \t\t\t\t*.rs */*.rs */*/*.rs */*/*/*.rs))\n endef\n "}, {"sha": "f8898ee8d0602cd3c554a5f5988f55825a01b4ef", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -835,7 +835,7 @@ $$(TLIB2_T_$(2)_H_$(3))/$$(FT_LIB): \\\n \t\ttmp/$$(FT).rc \\\n \t\t$$(SREQ2_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE2_T_$(2)_H_$(3)) --lib -o $$@ $$< \\\n+\t$$(STAGE2_T_$(2)_H_$(3)) --crate-type=dylib --out-dir $$(@D) $$< \\\n \t  -L \"$$(RT_OUTPUT_DIR_$(2))\"\n \n $(3)/test/$$(FT_DRIVER)-$(2)$$(X_$(2)): \\"}, {"sha": "adb81803ab09501c370c3220f7688fde498462f5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -245,7 +245,7 @@ actual:\\n\\\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = ~[~\"-\",\n-                         ~\"--no-trans\", ~\"--lib\",\n+                         ~\"--no-trans\", ~\"--crate-type=lib\",\n                          ~\"--target=\" + target,\n                          ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n                          ~\"-L\",\n@@ -659,7 +659,7 @@ fn compile_test_(config: &config, props: &TestProps,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n     let args = make_compile_args(config, props, link_args + extra_args,\n-                                 make_exe_name, testfile);\n+                                 |a, b| ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n@@ -702,8 +702,12 @@ fn compose_and_run_compiler(\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = load_props(&abs_ab);\n         let aux_args =\n-            make_compile_args(config, &aux_props, ~[~\"--dylib\"] + extra_link_args,\n-                              |a,b| make_lib_name(a, b, testfile), &abs_ab);\n+            make_compile_args(config, &aux_props, ~[~\"--crate-type=dylib\"]\n+                                                  + extra_link_args,\n+                              |a,b| {\n+                                  let f = make_lib_name(a, b, testfile);\n+                                  ThisDirectory(f.dir_path())\n+                              }, &abs_ab);\n         let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, None);\n         if !auxres.status.success() {\n@@ -741,10 +745,15 @@ fn compose_and_run(config: &config, testfile: &Path,\n                           prog, args, procenv, input);\n }\n \n+enum TargetLocation {\n+    ThisFile(Path),\n+    ThisDirectory(Path),\n+}\n+\n fn make_compile_args(config: &config,\n                      props: &TestProps,\n                      extras: ~[~str],\n-                     xform: |&config, &Path| -> Path,\n+                     xform: |&config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n     let xform_file = xform(config, testfile);\n@@ -755,10 +764,14 @@ fn make_compile_args(config: &config,\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut args = ~[testfile.as_str().unwrap().to_owned(),\n-                     ~\"-o\", xform_file.as_str().unwrap().to_owned(),\n                      ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n                      ~\"--target=\" + target]\n         + extras;\n+    let path = match xform_file {\n+        ThisFile(path) => { args.push(~\"-o\"); path }\n+        ThisDirectory(path) => { args.push(~\"--out-dir\"); path }\n+    };\n+    args.push(path.as_str().unwrap().to_owned());\n     args.push_all_move(split_maybe_args(&config.rustcflags));\n     args.push_all_move(split_maybe_args(&props.compile_flags));\n     return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n@@ -1043,10 +1056,10 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n-    let llvm_args = ~[~\"-c\", ~\"--lib\", ~\"--save-temps\"];\n+    let llvm_args = ~[~\"--emit=obj\", ~\"--crate-type=lib\", ~\"--save-temps\"];\n     let args = make_compile_args(config, props,\n                                  link_args + llvm_args,\n-                                 make_o_name, testfile);\n+                                 |a, b| ThisFile(make_o_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n "}, {"sha": "b412fa4967df0861656c57a14c1224ce5fc50325", "filename": "src/doc/rust.md", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -3678,43 +3678,43 @@ found in the [ffi tutorial][ffi].\n In one session of compilation, the compiler can generate multiple artifacts\n through the usage of command line flags and the `crate_type` attribute.\n \n-* `--bin`, `#[crate_type = \"bin\"]` - A runnable executable will be produced.\n-  This requires that there is a `main` function in the crate which will be run\n-  when the program begins executing. This will link in all Rust and native\n-  dependencies, producing a distributable binary.\n-\n-* `--lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced. This is\n-  an ambiguous concept as to what exactly is produced because a library can\n-  manifest itself in several forms. The purpose of this generic `lib` option is\n-  to generate the \"compiler recommended\" style of library. The output library\n-  will always be usable by rustc, but the actual type of library may change\n-  from time-to-time. The remaining output types are all different flavors of\n-  libraries, and the `lib` type can be seen as an alias for one of them (but\n-  the actual one is compiler-defined).\n-\n-* `--dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will be\n-  produced. This is different from the `lib` output type in that this forces\n+* `--crate-type=bin`, `#[crate_type = \"bin\"]` - A runnable executable will be\n+  produced.  This requires that there is a `main` function in the crate which\n+  will be run when the program begins executing. This will link in all Rust and\n+  native dependencies, producing a distributable binary.\n+\n+* `--crate-type=lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced.\n+  This is an ambiguous concept as to what exactly is produced because a library\n+  can manifest itself in several forms. The purpose of this generic `lib` option\n+  is to generate the \"compiler recommended\" style of library. The output library\n+  will always be usable by rustc, but the actual type of library may change from\n+  time-to-time. The remaining output types are all different flavors of\n+  libraries, and the `lib` type can be seen as an alias for one of them (but the\n+  actual one is compiler-defined).\n+\n+* `--crate-type=dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will\n+  be produced. This is different from the `lib` output type in that this forces\n   dynamic library generation. The resulting dynamic library can be used as a\n   dependency for other libraries and/or executables.  This output type will\n   create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n   windows.\n \n-* `--staticlib`, `#[crate_type = \"staticlib\"]` - A static system library will\n-  be produced. This is different from other library outputs in that the Rust\n-  compiler will never attempt to link to `staticlib` outputs. The purpose of\n-  this output type is to create a static library containing all of the local\n-  crate's code along with all upstream dependencies. The static library is\n-  actually a `*.a` archive on linux and osx and a `*.lib` file on windows. This\n-  format is recommended for use in situtations such as linking Rust code into an\n-  existing non-Rust application because it will not have dynamic dependencies on\n-  other Rust code.\n-\n-* `--rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be produced.\n-  This is used as an intermediate artifact and can be thought of as a \"static\n-  Rust library\". These `rlib` files, unlike `staticlib` files, are interpreted\n-  by the Rust compiler in future linkage. This essentially means that `rustc`\n-  will look for metadata in `rlib` files like it looks for metadata in dynamic\n-  libraries. This form of output is used to produce statically linked\n+* `--crate-type=staticlib`, `#[crate_type = \"staticlib\"]` - A static system\n+  library will be produced. This is different from other library outputs in that\n+  the Rust compiler will never attempt to link to `staticlib` outputs. The\n+  purpose of this output type is to create a static library containing all of\n+  the local crate's code along with all upstream dependencies. The static\n+  library is actually a `*.a` archive on linux and osx and a `*.lib` file on\n+  windows. This format is recommended for use in situtations such as linking\n+  Rust code into an existing non-Rust application because it will not have\n+  dynamic dependencies on other Rust code.\n+\n+* `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n+  produced.  This is used as an intermediate artifact and can be thought of as a\n+  \"static Rust library\". These `rlib` files, unlike `staticlib` files, are\n+  interpreted by the Rust compiler in future linkage. This essentially means\n+  that `rustc` will look for metadata in `rlib` files like it looks for metadata\n+  in dynamic libraries. This form of output is used to produce statically linked\n   executables as well as `staticlib` outputs.\n \n Note that these outputs are stackable in the sense that if multiple are\n@@ -3769,9 +3769,9 @@ dependencies will be used:\n    then the compiler will force all dependencies to be dynamic and will generate\n    errors if dynamic versions could not be found.\n \n-In general, `--bin` or `--lib` should be sufficient for all compilation needs,\n-and the other options are just available if more fine-grained control is desired\n-over the output format of a Rust crate.\n+In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n+all compilation needs, and the other options are just available if more\n+fine-grained control is desired over the output format of a Rust crate.\n \n ### Logging system\n "}, {"sha": "7010eb4e48d8b27a09b3dd0f05e8ea460f0fcd57", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -3162,8 +3162,8 @@ fn main() { println!(\"hello {}\", world::explore()); }\n Now compile and run like this (adjust to your platform if necessary):\n \n ~~~~ {.notrust}\n-> rustc --lib world.rs  # compiles libworld-<HASH>-0.42.so\n-> rustc main.rs -L .    # compiles main\n+> rustc --crate-type=lib world.rs  # compiles libworld-<HASH>-0.42.so\n+> rustc main.rs -L .               # compiles main\n > ./main\n \"hello world\"\n ~~~~"}, {"sha": "f1f9e88f7c92643c270b217f514dbff6dfdc8674", "filename": "src/etc/zsh/_rust", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -7,18 +7,15 @@ typeset -A opt_args\n _rustc_opts_switches=(\n     --android-cross-path'[The path to the Android NDK]'\n     --ar'[Program to use for managing archives instead of the default.]'\n-    --bin'[Compile an executable crate (default)]'\n     -c'[Compile and assemble, but do not link]'\n     --cfg'[Configure the compilation environment]'\n     --crate-id'[Output the crate id and exit]'\n     --crate-file-name'[Output the file(s) that would be written if compilation continued and exit]'\n     --crate-name'[Output the crate name and exit]'\n     --dep-info'[Output dependency info to <filename> after compiling]'\n-    --dylib'[Compile a dynamic library crate]'\n-    --emit-llvm'[Produce an LLVM bitcode file]'\n+    --crate-type'[Specify the type of crate to crate]'\n     {-h,--help}'[Display this message]'\n     -L'[Add a directory to the library search path]'\n-    --lib'[Compile a library crate]'\n     --linker'[Program to use for linking instead of the default.]'\n     --link-args'[FLAGS is a space-separated list of flags passed to the linker]'\n     --llvm-args'[A list of arguments to pass to llvm, comma separated]'\n@@ -33,10 +30,7 @@ _rustc_opts_switches=(\n     --parse-only'[Parse only; do not compile, assemble, or link]'\n     --passes'[Comma or space separated list of pass names to use]'\n     --pretty'[Pretty-print the input instead of compiling]'\n-    --rlib'[Compile a rust library crate as an rlib file]'\n-    -S'[Compile only; do not assemble or link]'\n     --save-temps'[Write intermediate files (.bc, .opt.bc, .o) in addition to normal output]'\n-    --staticlib'[Compile a static library crate]'\n     --sysroot'[Override the system root]'\n     --test'[Build a test harness]'\n     --target'[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]'"}, {"sha": "62fdff49168aaff3d985f726bb6a2df800a3f102", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 94, "deletions": 78, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -11,7 +11,7 @@\n \n use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n-use driver::driver::CrateTranslation;\n+use driver::driver::{CrateTranslation, OutputFilenames};\n use driver::session::Session;\n use driver::session;\n use lib::llvm::llvm;\n@@ -44,9 +44,8 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::crateid::CrateId;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, TotalOrd, TotalEq)]\n pub enum OutputType {\n-    OutputTypeNone,\n     OutputTypeBitcode,\n     OutputTypeAssembly,\n     OutputTypeLlvmAssembly,\n@@ -90,7 +89,7 @@ pub mod write {\n     use back::link::{OutputTypeAssembly, OutputTypeBitcode};\n     use back::link::{OutputTypeExe, OutputTypeLlvmAssembly};\n     use back::link::{OutputTypeObject};\n-    use driver::driver::CrateTranslation;\n+    use driver::driver::{CrateTranslation, OutputFilenames};\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;\n@@ -101,7 +100,6 @@ pub mod write {\n \n     use std::c_str::ToCStr;\n     use std::libc::{c_uint, c_int};\n-    use std::path::Path;\n     use std::run;\n     use std::str;\n \n@@ -125,8 +123,8 @@ pub mod write {\n \n     pub fn run_passes(sess: Session,\n                       trans: &CrateTranslation,\n-                      output_type: OutputType,\n-                      output: &Path) {\n+                      output_types: &[OutputType],\n+                      output: &OutputFilenames) {\n         let llmod = trans.module;\n         let llcx = trans.context;\n         unsafe {\n@@ -209,10 +207,11 @@ pub mod write {\n             // Emit the bytecode if we're either saving our temporaries or\n             // emitting an rlib. Whenever an rlib is created, the bytecode is\n             // inserted into the archive in order to allow LTO against it.\n-            let outputs = sess.outputs.borrow();\n+            let crate_types = sess.crate_types.borrow();\n             if sess.opts.save_temps ||\n-               outputs.get().iter().any(|&o| o == session::OutputRlib) {\n-                output.with_extension(\"bc\").with_c_str(|buf| {\n+               (crate_types.get().contains(&session::CrateTypeRlib) &&\n+                sess.opts.output_types.contains(&OutputTypeExe)) {\n+                output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 })\n             }\n@@ -247,52 +246,68 @@ pub mod write {\n                 }\n             }\n \n-            time(sess.time_passes(), \"codegen passes\", (), |()| {\n-                match output_type {\n-                    OutputTypeNone => {}\n+            let mut object_file = None;\n+            let mut needs_metadata = false;\n+            for output_type in output_types.iter() {\n+                let path = output.path(*output_type);\n+                match *output_type {\n                     OutputTypeBitcode => {\n-                        output.with_c_str(|buf| {\n+                        path.with_c_str(|buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         })\n                     }\n                     OutputTypeLlvmAssembly => {\n-                        output.with_c_str(|output| {\n+                        path.with_c_str(|output| {\n                             with_codegen(tm, llmod, |cpm| {\n                                 llvm::LLVMRustPrintModule(cpm, llmod, output);\n                             })\n                         })\n                     }\n                     OutputTypeAssembly => {\n-                        with_codegen(tm, llmod, |cpm| {\n-                            WriteOutputFile(sess, tm, cpm, llmod, output,\n-                                            lib::llvm::AssemblyFile);\n-                        });\n-\n                         // If we're not using the LLVM assembler, this function\n                         // could be invoked specially with output_type_assembly,\n                         // so in this case we still want the metadata object\n                         // file.\n-                        if sess.opts.output_type != OutputTypeAssembly {\n-                            with_codegen(tm, trans.metadata_module, |cpm| {\n-                                let out = output.with_extension(\"metadata.o\");\n-                                WriteOutputFile(sess, tm, cpm,\n-                                                trans.metadata_module, &out,\n-                                                lib::llvm::ObjectFile);\n-                            })\n-                        }\n+                        let ty = OutputTypeAssembly;\n+                        let path = if sess.opts.output_types.contains(&ty) {\n+                           path\n+                        } else {\n+                            needs_metadata = true;\n+                            output.temp_path(OutputTypeAssembly)\n+                        };\n+                        with_codegen(tm, llmod, |cpm| {\n+                            WriteOutputFile(sess, tm, cpm, llmod, &path,\n+                                            lib::llvm::AssemblyFile);\n+                        });\n+                    }\n+                    OutputTypeObject => {\n+                        object_file = Some(path);\n                     }\n-                    OutputTypeExe | OutputTypeObject => {\n+                    OutputTypeExe => {\n+                        object_file = Some(output.temp_path(OutputTypeObject));\n+                        needs_metadata = true;\n+                    }\n+                }\n+            }\n+\n+            time(sess.time_passes(), \"codegen passes\", (), |()| {\n+                match object_file {\n+                    Some(ref path) => {\n                         with_codegen(tm, llmod, |cpm| {\n-                            WriteOutputFile(sess, tm, cpm, llmod, output,\n+                            WriteOutputFile(sess, tm, cpm, llmod, path,\n                                             lib::llvm::ObjectFile);\n                         });\n-                        with_codegen(tm, trans.metadata_module, |cpm| {\n-                            let out = output.with_extension(\"metadata.o\");\n-                            WriteOutputFile(sess, tm, cpm,\n-                                            trans.metadata_module, &out,\n-                                            lib::llvm::ObjectFile);\n-                        })\n                     }\n+                    None => {}\n+                }\n+                if needs_metadata {\n+                    with_codegen(tm, trans.metadata_module, |cpm| {\n+                        let out = output.temp_path(OutputTypeObject)\n+                                        .with_extension(\"metadata.o\");\n+                        WriteOutputFile(sess, tm, cpm,\n+                                        trans.metadata_module, &out,\n+                                        lib::llvm::ObjectFile);\n+                    })\n                 }\n             });\n \n@@ -304,8 +319,10 @@ pub mod write {\n         }\n     }\n \n-    pub fn run_assembler(sess: Session, assembly: &Path, object: &Path) {\n+    pub fn run_assembler(sess: Session, outputs: &OutputFilenames) {\n         let cc = super::get_cc_prog(sess);\n+        let assembly = outputs.temp_path(OutputTypeAssembly);\n+        let object = outputs.path(OutputTypeObject);\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let args = [\n@@ -480,9 +497,8 @@ pub mod write {\n  *    system linkers understand.\n  */\n \n-pub fn build_link_meta(sess: Session,\n-                       attrs: &[ast::Attribute],\n-                       output: &Path,\n+pub fn build_link_meta(attrs: &[ast::Attribute],\n+                       output: &OutputFilenames,\n                        symbol_hasher: &mut Sha256)\n                        -> LinkMeta {\n     // This calculates CMH as defined above\n@@ -493,14 +509,7 @@ pub fn build_link_meta(sess: Session,\n     }\n \n     let crateid = match attr::find_crateid(attrs) {\n-        None => {\n-            let stem = session::expect(\n-                sess,\n-                output.filestem_str(),\n-                || format!(\"output file name '{}' doesn't appear to have a stem\",\n-                           output.display()));\n-            from_str(stem).unwrap()\n-        }\n+        None => from_str(output.out_filestem).unwrap(),\n         Some(s) => s,\n     };\n \n@@ -794,20 +803,21 @@ fn remove(sess: Session, path: &Path) {\n /// of the requested outputs for this compilation session.\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n-                   obj_filename: &Path,\n-                   out_filename: &Path,\n+                   outputs: &OutputFilenames,\n                    lm: &LinkMeta) -> ~[Path] {\n     let mut out_filenames = ~[];\n-    let outputs = sess.outputs.borrow();\n-    for &output in outputs.get().iter() {\n-        let out_file = link_binary_output(sess, trans, output, obj_filename,\n-                                          out_filename, lm);\n+    let crate_types = sess.crate_types.borrow();\n+    for &crate_type in crate_types.get().iter() {\n+        let out_file = link_binary_output(sess, trans, crate_type, outputs, lm);\n         out_filenames.push(out_file);\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.save_temps {\n-        remove(sess, obj_filename);\n+        let obj_filename = outputs.temp_path(OutputTypeObject);\n+        if !sess.opts.output_types.contains(&OutputTypeObject) {\n+            remove(sess, &obj_filename);\n+        }\n         remove(sess, &obj_filename.with_extension(\"metadata.o\"));\n     }\n \n@@ -821,14 +831,14 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn filename_for_input(sess: &Session, output: session::OutputStyle, lm: &LinkMeta,\n-                      out_filename: &Path) -> Path {\n+pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n+                          lm: &LinkMeta, out_filename: &Path) -> Path {\n     let libname = output_lib_filename(lm);\n-    match output {\n-        session::OutputRlib => {\n+    match crate_type {\n+        session::CrateTypeRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n-        session::OutputDylib => {\n+        session::CrateTypeDylib => {\n             let (prefix, suffix) = match sess.targ_cfg.os {\n                 abi::OsWin32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n                 abi::OsMacos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n@@ -838,27 +848,32 @@ pub fn filename_for_input(sess: &Session, output: session::OutputStyle, lm: &Lin\n             };\n             out_filename.with_filename(format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        session::OutputStaticlib => {\n+        session::CrateTypeStaticlib => {\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n-        session::OutputExecutable => out_filename.clone(),\n+        session::CrateTypeExecutable => out_filename.clone(),\n     }\n-\n }\n \n fn link_binary_output(sess: Session,\n                       trans: &CrateTranslation,\n-                      output: session::OutputStyle,\n-                      obj_filename: &Path,\n-                      out_filename: &Path,\n+                      crate_type: session::CrateType,\n+                      outputs: &OutputFilenames,\n                       lm: &LinkMeta) -> Path {\n-    let out_filename = filename_for_input(&sess, output, lm, out_filename);\n+    let obj_filename = outputs.temp_path(OutputTypeObject);\n+    let out_filename = match outputs.single_output_file {\n+        Some(ref file) => file.clone(),\n+        None => {\n+            let out_filename = outputs.path(OutputTypeExe);\n+            filename_for_input(&sess, crate_type, lm, &out_filename)\n+        }\n+    };\n \n     // Make sure the output and obj_filename are both writeable.\n     // Mac, FreeBSD, and Windows system linkers check this already --\n     // however, the Linux linker will happily overwrite a read-only file.\n     // We should be consistent.\n-    let obj_is_writeable = is_writeable(obj_filename);\n+    let obj_is_writeable = is_writeable(&obj_filename);\n     let out_is_writeable = is_writeable(&out_filename);\n     if !out_is_writeable {\n         sess.fatal(format!(\"Output file {} is not writeable -- check its permissions.\",\n@@ -869,18 +884,18 @@ fn link_binary_output(sess: Session,\n                            obj_filename.display()));\n     }\n \n-    match output {\n-        session::OutputRlib => {\n-            link_rlib(sess, Some(trans), obj_filename, &out_filename);\n+    match crate_type {\n+        session::CrateTypeRlib => {\n+            link_rlib(sess, Some(trans), &obj_filename, &out_filename);\n         }\n-        session::OutputStaticlib => {\n-            link_staticlib(sess, obj_filename, &out_filename);\n+        session::CrateTypeStaticlib => {\n+            link_staticlib(sess, &obj_filename, &out_filename);\n         }\n-        session::OutputExecutable => {\n-            link_natively(sess, false, obj_filename, &out_filename);\n+        session::CrateTypeExecutable => {\n+            link_natively(sess, false, &obj_filename, &out_filename);\n         }\n-        session::OutputDylib => {\n-            link_natively(sess, true, obj_filename, &out_filename);\n+        session::CrateTypeDylib => {\n+            link_natively(sess, true, &obj_filename, &out_filename);\n         }\n     }\n \n@@ -954,7 +969,8 @@ fn link_rlib(sess: Session,\n             // into the archive.\n             let bc = obj_filename.with_extension(\"bc\");\n             a.add_file(&bc, false);\n-            if !sess.opts.save_temps {\n+            if !sess.opts.save_temps &&\n+               !sess.opts.output_types.contains(&OutputTypeBitcode) {\n                 remove(sess, &bc);\n             }\n "}, {"sha": "3c7d804435f2fdb2d76bf8a6f26cdd8ba0275175", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -26,10 +26,10 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     }\n \n     // Make sure we actually can run LTO\n-    let outputs = sess.outputs.borrow();\n-    for output in outputs.get().iter() {\n-        match *output {\n-            session::OutputExecutable | session::OutputStaticlib => {}\n+    let crate_types = sess.crate_types.borrow();\n+    for crate_type in crate_types.get().iter() {\n+        match *crate_type {\n+            session::CrateTypeExecutable | session::CrateTypeStaticlib => {}\n             _ => {\n                 sess.fatal(\"lto can only be run for executables and \\\n                             static library outputs\");"}, {"sha": "b7bb603dd65e7f9fdc0a6429ae98fbf60febb85f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 153, "deletions": 156, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -11,7 +11,7 @@\n \n use back::link;\n use back::{arm, x86, x86_64, mips};\n-use driver::session::{Aggressive, OutputExecutable};\n+use driver::session::{Aggressive, CrateTypeExecutable};\n use driver::session::{Session, Session_, No, Less, Default};\n use driver::session;\n use front;\n@@ -182,7 +182,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &crate));\n-    sess.outputs.set(session::collect_outputs(&sess, crate.attrs));\n+    sess.crate_types.set(session::collect_crate_types(&sess, crate.attrs));\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &crate));\n@@ -373,38 +373,32 @@ pub fn phase_4_translate_to_llvm(sess: Session,\n                                  analysis: &CrateAnalysis,\n                                  outputs: &OutputFilenames) -> CrateTranslation {\n     time(sess.time_passes(), \"translation\", crate, |crate|\n-         trans::base::trans_crate(sess, crate, analysis,\n-                                  &outputs.obj_filename))\n+         trans::base::trans_crate(sess, crate, analysis, outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: Session,\n                                trans: &CrateTranslation,\n                                outputs: &OutputFilenames) {\n-\n     if sess.no_integrated_as() {\n         let output_type = link::OutputTypeAssembly;\n-        let asm_filename = outputs.obj_filename.with_extension(\"s\");\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            link::write::run_passes(sess,\n-                                    trans,\n-                                    output_type,\n-                                    &asm_filename));\n+            link::write::run_passes(sess, trans, [output_type], outputs));\n \n-        link::write::run_assembler(sess, &asm_filename, &outputs.obj_filename);\n+        link::write::run_assembler(sess, outputs);\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            fs::unlink(&asm_filename).unwrap();\n+            fs::unlink(&outputs.temp_path(link::OutputTypeAssembly)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n                                     trans,\n-                                    sess.opts.output_type,\n-                                    &outputs.obj_filename));\n+                                    sess.opts.output_types,\n+                                    outputs));\n     }\n }\n \n@@ -416,8 +410,7 @@ pub fn phase_6_link_output(sess: Session,\n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n-                           &outputs.obj_filename,\n-                           &outputs.out_filename,\n+                           outputs,\n                            &trans.link));\n }\n \n@@ -446,24 +439,34 @@ pub fn stop_after_phase_2(sess: Session) -> bool {\n }\n \n pub fn stop_after_phase_5(sess: Session) -> bool {\n-    if sess.opts.output_type != link::OutputTypeExe {\n+    if !sess.opts.output_types.iter().any(|&i| i == link::OutputTypeExe) {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n-fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames,\n-                  crate: &ast::Crate) -> io::IoResult<()>\n-{\n-    let lm = link::build_link_meta(sess, crate.attrs, &outputs.obj_filename,\n+fn write_out_deps(sess: Session,\n+                  input: &Input,\n+                  outputs: &OutputFilenames,\n+                  crate: &ast::Crate) -> io::IoResult<()> {\n+    let lm = link::build_link_meta(crate.attrs, outputs,\n                                    &mut ::util::sha2::Sha256::new());\n \n-    let sess_outputs = sess.outputs.borrow();\n-    let out_filenames = sess_outputs.get().iter()\n-        .map(|&output| link::filename_for_input(&sess, output, &lm,\n-                                                &outputs.out_filename))\n-        .to_owned_vec();\n+    let mut out_filenames = ~[];\n+    for output_type in sess.opts.output_types.iter() {\n+        let file = outputs.path(*output_type);\n+        match *output_type {\n+            link::OutputTypeExe => {\n+                let crate_types = sess.crate_types.borrow();\n+                for output in crate_types.get().iter() {\n+                    let p = link::filename_for_input(&sess, *output, &lm, &file);\n+                    out_filenames.push(p);\n+                }\n+            }\n+            _ => { out_filenames.push(file); }\n+        }\n+    }\n \n     // Write out dependency rules to the dep-info file if requested with\n     // --dep-info\n@@ -473,12 +476,7 @@ fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames,\n         // Use default filename: crate source filename with extension replaced\n         // by \".d\"\n         (true, None) => match *input {\n-            FileInput(ref input_path) => {\n-                let filestem = input_path.filestem().expect(\"input file must \\\n-                                                             have stem\");\n-                let filename = out_filenames[0].dir_path().join(filestem);\n-                filename.with_extension(\"d\")\n-            },\n+            FileInput(..) => outputs.with_extension(\"d\"),\n             StrInput(..) => {\n                 sess.warn(\"can not write --dep-info without a filename \\\n                            when compiling stdin.\");\n@@ -526,19 +524,19 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n         let outputs = build_output_filenames(input, outdir, output,\n                                              expanded_crate.attrs, sess);\n \n-        write_out_deps(sess, input, outputs, &expanded_crate).unwrap();\n+        write_out_deps(sess, input, &outputs, &expanded_crate).unwrap();\n \n         if stop_after_phase_2(sess) { return; }\n \n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n         if stop_after_phase_3(sess) { return; }\n         let trans = phase_4_translate_to_llvm(sess, expanded_crate,\n-                                              &analysis, outputs);\n+                                              &analysis, &outputs);\n         (outputs, trans)\n     };\n-    phase_5_run_llvm_passes(sess, &trans, outputs);\n+    phase_5_run_llvm_passes(sess, &trans, &outputs);\n     if stop_after_phase_5(sess) { return; }\n-    phase_6_link_output(sess, &trans, outputs);\n+    phase_6_link_output(sess, &trans, &outputs);\n }\n \n struct IdentifiedAnnotation {\n@@ -735,22 +733,19 @@ pub fn build_session_options(binary: ~str,\n                              matches: &getopts::Matches,\n                              demitter: @diagnostic::Emitter)\n                              -> @session::Options {\n-    let mut outputs = ~[];\n-    if matches.opt_present(\"lib\") {\n-        outputs.push(session::default_lib_output());\n-    }\n-    if matches.opt_present(\"rlib\") {\n-        outputs.push(session::OutputRlib)\n-    }\n-    if matches.opt_present(\"staticlib\") {\n-        outputs.push(session::OutputStaticlib)\n-    }\n-    if matches.opt_present(\"dylib\") {\n-        outputs.push(session::OutputDylib)\n-    }\n-    if matches.opt_present(\"bin\") {\n-        outputs.push(session::OutputExecutable)\n-    }\n+    let crate_types = matches.opt_strs(\"crate-type\").flat_map(|s| {\n+        s.split(',').map(|part| {\n+            match part {\n+                \"lib\"       => session::default_lib_output(),\n+                \"rlib\"      => session::CrateTypeRlib,\n+                \"staticlib\" => session::CrateTypeStaticlib,\n+                \"dylib\"     => session::CrateTypeDylib,\n+                \"bin\"       => session::CrateTypeExecutable,\n+                _ => early_error(demitter,\n+                                 format!(\"unknown crate type: `{}`\", part))\n+            }\n+        }).collect()\n+    });\n \n     let parse_only = matches.opt_present(\"parse-only\");\n     let no_trans = matches.opt_present(\"no-trans\");\n@@ -801,19 +796,30 @@ pub fn build_session_options(binary: ~str,\n         unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n-    let output_type =\n-        if parse_only || no_trans {\n-            link::OutputTypeNone\n-        } else if matches.opt_present(\"S\") &&\n-                  matches.opt_present(\"emit-llvm\") {\n-            link::OutputTypeLlvmAssembly\n-        } else if matches.opt_present(\"S\") {\n-            link::OutputTypeAssembly\n-        } else if matches.opt_present(\"c\") {\n-            link::OutputTypeObject\n-        } else if matches.opt_present(\"emit-llvm\") {\n-            link::OutputTypeBitcode\n-        } else { link::OutputTypeExe };\n+    let mut output_types = if parse_only || no_trans {\n+        ~[]\n+    } else {\n+        matches.opt_strs(\"emit\").flat_map(|s| {\n+            s.split(',').map(|part| {\n+                match part.as_slice() {\n+                    \"asm\"  => link::OutputTypeAssembly,\n+                    \"ir\"   => link::OutputTypeLlvmAssembly,\n+                    \"bc\"   => link::OutputTypeBitcode,\n+                    \"obj\"  => link::OutputTypeObject,\n+                    \"link\" => link::OutputTypeExe,\n+                    _ => early_error(demitter,\n+                                     format!(\"unknown emission type: `{}`\",\n+                                             part))\n+                }\n+            }).collect()\n+        })\n+    };\n+    output_types.sort();\n+    output_types.dedup();\n+    if output_types.len() == 0 {\n+        output_types.push(link::OutputTypeExe);\n+    }\n+\n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::new(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n@@ -886,7 +892,7 @@ pub fn build_session_options(binary: ~str,\n                        matches.opt_present(\"crate-file-name\"));\n \n     let sopts = @session::Options {\n-        outputs: outputs,\n+        crate_types: crate_types,\n         gc: gc,\n         optimize: opt_level,\n         custom_passes: custom_passes,\n@@ -895,7 +901,7 @@ pub fn build_session_options(binary: ~str,\n         extra_debuginfo: extra_debuginfo,\n         lint_opts: lint_opts,\n         save_temps: save_temps,\n-        output_type: output_type,\n+        output_types: output_types,\n         addl_lib_search_paths: @RefCell::new(addl_lib_search_paths),\n         ar: ar,\n         linker: linker,\n@@ -972,7 +978,7 @@ pub fn build_session_(sopts: @session::Options,\n         working_dir: os::getcwd(),\n         lints: RefCell::new(HashMap::new()),\n         node_id: Cell::new(1),\n-        outputs: @RefCell::new(~[]),\n+        crate_types: @RefCell::new(~[]),\n     }\n }\n \n@@ -994,20 +1000,15 @@ pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n // rustc command line options\n pub fn optgroups() -> ~[getopts::OptGroup] {\n  ~[\n-  optflag(\"c\", \"\",    \"Compile and assemble, but do not link\"),\n-  optmulti(\"\", \"cfg\", \"Configure the compilation\n-                          environment\", \"SPEC\"),\n-  optflag(\"\",  \"emit-llvm\",\n-                        \"Produce an LLVM assembly file if used with -S option;\n-                         produce an LLVM bitcode file otherwise\"),\n-  optflag(\"h\", \"help\",\"Display this message\"),\n-  optmulti(\"L\", \"\",   \"Add a directory to the library search path\",\n-                              \"PATH\"),\n-  optflag(\"\",  \"bin\", \"Compile an executable crate (default)\"),\n-  optflag(\"\",  \"lib\", \"Compile a rust library crate using the compiler's default\"),\n-  optflag(\"\",  \"rlib\", \"Compile a rust library crate as an rlib file\"),\n-  optflag(\"\",  \"staticlib\", \"Compile a static library crate\"),\n-  optflag(\"\",  \"dylib\", \"Compile a dynamic library crate\"),\n+  optflag(\"h\", \"help\", \"Display this message\"),\n+  optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+  optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n+  optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates for the \\\n+                              compiler to emit\",\n+           \"[bin|lib|rlib|dylib|staticlib]\"),\n+  optmulti(\"\", \"emit\", \"Comma separated list of types of output for the compiler\n+                        to emit\",\n+           \"[asm|bc|ir|obj|link]\"),\n   optopt(\"\", \"linker\", \"Program to use for linking instead of the default.\", \"LINKER\"),\n   optopt(\"\", \"ar\", \"Program to use for managing archives instead of the default.\", \"AR\"),\n   optflag(\"\", \"crate-id\", \"Output the crate id and exit\"),\n@@ -1045,7 +1046,6 @@ pub fn optgroups() -> ~[getopts::OptGroup] {\n                           typed (crates expanded, with type annotations),\n                           or identified (fully parenthesized,\n                           AST nodes and blocks with IDs)\", \"TYPE\"),\n-  optflag(\"S\", \"\",    \"Compile only; do not assemble or link\"),\n   optflagopt(\"\", \"dep-info\",\n                         \"Output dependency info to <filename> after compiling\", \"FILENAME\"),\n   optflag(\"\", \"save-temps\",\n@@ -1081,92 +1081,89 @@ pub fn optgroups() -> ~[getopts::OptGroup] {\n }\n \n pub struct OutputFilenames {\n-    out_filename: Path,\n-    obj_filename: Path\n+    out_directory: Path,\n+    out_filestem: ~str,\n+    single_output_file: Option<Path>,\n+}\n+\n+impl OutputFilenames {\n+    pub fn path(&self, flavor: link::OutputType) -> Path {\n+        match self.single_output_file {\n+            Some(ref path) => return path.clone(),\n+            None => {}\n+        }\n+        self.temp_path(flavor)\n+    }\n+\n+    pub fn temp_path(&self, flavor: link::OutputType) -> Path {\n+        let base = self.out_directory.join(self.out_filestem.as_slice());\n+        match flavor {\n+            link::OutputTypeBitcode => base.with_extension(\"bc\"),\n+            link::OutputTypeAssembly => base.with_extension(\"s\"),\n+            link::OutputTypeLlvmAssembly => base.with_extension(\"ll\"),\n+            link::OutputTypeObject => base.with_extension(\"o\"),\n+            link::OutputTypeExe => base,\n+        }\n+    }\n+\n+    pub fn with_extension(&self, extension: &str) -> Path {\n+        let stem = self.out_filestem.as_slice();\n+        self.out_directory.join(stem).with_extension(extension)\n+    }\n }\n \n pub fn build_output_filenames(input: &Input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               attrs: &[ast::Attribute],\n                               sess: Session)\n-                           -> ~OutputFilenames {\n-    let obj_path;\n-    let out_path;\n-    let sopts = sess.opts;\n-    let stop_after_codegen = sopts.output_type != link::OutputTypeExe;\n-\n-    let obj_suffix = match sopts.output_type {\n-        link::OutputTypeNone => ~\"none\",\n-        link::OutputTypeBitcode => ~\"bc\",\n-        link::OutputTypeAssembly => ~\"s\",\n-        link::OutputTypeLlvmAssembly => ~\"ll\",\n-        // Object and exe output both use the '.o' extension here\n-        link::OutputTypeObject | link::OutputTypeExe => ~\"o\"\n-    };\n-\n+                           -> OutputFilenames {\n     match *ofile {\n-      None => {\n-          // \"-\" as input file will cause the parser to read from stdin so we\n-          // have to make up a name\n-          // We want to toss everything after the final '.'\n-          let dirpath = match *odir {\n-              Some(ref d) => (*d).clone(),\n-              None => match *input {\n-                  StrInput(_) => os::getcwd(),\n-                  FileInput(ref ifile) => (*ifile).dir_path()\n-              }\n-          };\n-\n-          let mut stem = match *input {\n-              // FIXME (#9639): This needs to handle non-utf8 paths\n-              FileInput(ref ifile) => {\n-                  (*ifile).filestem_str().unwrap().to_str()\n-              }\n-              StrInput(_) => ~\"rust_out\"\n-          };\n-\n-          // If a crateid is present, we use it as the link name\n-          let crateid = attr::find_crateid(attrs);\n-          match crateid {\n-              None => {}\n-              Some(crateid) => stem = crateid.name.to_str(),\n-          }\n-\n-          if sess.building_library.get() {\n-              out_path = dirpath.join(os::dll_filename(stem));\n-              obj_path = {\n-                  let mut p = dirpath.join(stem);\n-                  p.set_extension(obj_suffix);\n-                  p\n-              };\n-          } else {\n-              out_path = dirpath.join(stem);\n-              obj_path = out_path.with_extension(obj_suffix);\n-          }\n-      }\n+        None => {\n+            // \"-\" as input file will cause the parser to read from stdin so we\n+            // have to make up a name\n+            // We want to toss everything after the final '.'\n+            let dirpath = match *odir {\n+                Some(ref d) => d.clone(),\n+                None => os::getcwd(),\n+            };\n \n-      Some(ref out_file) => {\n-        out_path = out_file.clone();\n-        obj_path = if stop_after_codegen {\n-            out_file.clone()\n-        } else {\n-            out_file.with_extension(obj_suffix)\n-        };\n+            let mut stem = match *input {\n+                // FIXME (#9639): This needs to handle non-utf8 paths\n+                FileInput(ref ifile) => ifile.filestem_str().unwrap().to_str(),\n+                StrInput(_) => ~\"rust_out\"\n+            };\n \n-        if sess.building_library.get() {\n-            sess.warn(\"ignoring specified output filename for library.\");\n+            // If a crateid is present, we use it as the link name\n+            let crateid = attr::find_crateid(attrs);\n+            match crateid {\n+                None => {}\n+                Some(crateid) => stem = crateid.name.to_str(),\n+            }\n+            OutputFilenames {\n+                out_directory: dirpath,\n+                out_filestem: stem,\n+                single_output_file: None,\n+            }\n         }\n \n-        if *odir != None {\n-            sess.warn(\"ignoring --out-dir flag due to -o flag.\");\n+        Some(ref out_file) => {\n+            let ofile = if sess.opts.output_types.len() > 1 {\n+                sess.warn(\"ignoring specified output filename because multiple \\\n+                           outputs were requested\");\n+                None\n+            } else {\n+                Some(out_file.clone())\n+            };\n+            if *odir != None {\n+                sess.warn(\"ignoring --out-dir flag due to -o flag.\");\n+            }\n+            OutputFilenames {\n+                out_directory: out_file.dir_path(),\n+                out_filestem: out_file.filestem_str().unwrap().to_str(),\n+                single_output_file: ofile,\n+            }\n         }\n-      }\n-    }\n-\n-    ~OutputFilenames {\n-        out_filename: out_path,\n-        obj_filename: obj_path\n     }\n }\n "}, {"sha": "859d09b59627c91465613d5aa1f0ff3f1f3c5a5d", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use back::link;\n use back::target_strs;\n use back;\n use driver::driver::host_triple;\n@@ -139,7 +138,7 @@ pub enum OptLevel {\n pub struct Options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n-    outputs: ~[OutputStyle],\n+    crate_types: ~[CrateType],\n \n     gc: bool,\n     optimize: OptLevel,\n@@ -149,7 +148,7 @@ pub struct Options {\n     extra_debuginfo: bool,\n     lint_opts: ~[(lint::Lint, lint::level)],\n     save_temps: bool,\n-    output_type: back::link::OutputType,\n+    output_types: ~[back::link::OutputType],\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -192,11 +191,11 @@ pub enum EntryFnType {\n }\n \n #[deriving(Eq, Clone, TotalOrd, TotalEq)]\n-pub enum OutputStyle {\n-    OutputExecutable,\n-    OutputDylib,\n-    OutputRlib,\n-    OutputStaticlib,\n+pub enum CrateType {\n+    CrateTypeExecutable,\n+    CrateTypeDylib,\n+    CrateTypeRlib,\n+    CrateTypeStaticlib,\n }\n \n pub struct Session_ {\n@@ -219,7 +218,7 @@ pub struct Session_ {\n     lints: RefCell<HashMap<ast::NodeId,\n                            ~[(lint::Lint, codemap::Span, ~str)]>>,\n     node_id: Cell<ast::NodeId>,\n-    outputs: @RefCell<~[OutputStyle]>,\n+    crate_types: @RefCell<~[CrateType]>,\n }\n \n pub type Session = @Session_;\n@@ -374,7 +373,7 @@ impl Session_ {\n /// Some reasonable defaults\n pub fn basic_options() -> @Options {\n     @Options {\n-        outputs: ~[],\n+        crate_types: ~[],\n         gc: false,\n         optimize: No,\n         custom_passes: ~[],\n@@ -383,7 +382,7 @@ pub fn basic_options() -> @Options {\n         extra_debuginfo: false,\n         lint_opts: ~[],\n         save_temps: false,\n-        output_type: link::OutputTypeExe,\n+        output_types: ~[],\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         ar: None,\n         linker: None,\n@@ -413,10 +412,10 @@ pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n \n pub fn building_library(options: &Options, crate: &ast::Crate) -> bool {\n     if options.test { return false }\n-    for output in options.outputs.iter() {\n+    for output in options.crate_types.iter() {\n         match *output {\n-            OutputExecutable => {}\n-            OutputStaticlib | OutputDylib | OutputRlib => return true\n+            CrateTypeExecutable => {}\n+            CrateTypeStaticlib | CrateTypeDylib | CrateTypeRlib => return true\n         }\n     }\n     match syntax::attr::first_attr_value_str_by_name(crate.attrs, \"crate_type\") {\n@@ -430,30 +429,30 @@ pub fn building_library(options: &Options, crate: &ast::Crate) -> bool {\n     }\n }\n \n-pub fn default_lib_output() -> OutputStyle {\n-    OutputRlib\n+pub fn default_lib_output() -> CrateType {\n+    CrateTypeRlib\n }\n \n-pub fn collect_outputs(session: &Session,\n-                       attrs: &[ast::Attribute]) -> ~[OutputStyle] {\n+pub fn collect_crate_types(session: &Session,\n+                           attrs: &[ast::Attribute]) -> ~[CrateType] {\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return ~[OutputExecutable];\n+        return ~[CrateTypeExecutable];\n     }\n-    let mut base = session.opts.outputs.clone();\n+    let mut base = session.opts.crate_types.clone();\n     let mut iter = attrs.iter().filter_map(|a| {\n         if a.name().equiv(&(\"crate_type\")) {\n             match a.value_str() {\n-                Some(ref n) if n.equiv(&(\"rlib\")) => Some(OutputRlib),\n-                Some(ref n) if n.equiv(&(\"dylib\")) => Some(OutputDylib),\n+                Some(ref n) if n.equiv(&(\"rlib\")) => Some(CrateTypeRlib),\n+                Some(ref n) if n.equiv(&(\"dylib\")) => Some(CrateTypeDylib),\n                 Some(ref n) if n.equiv(&(\"lib\")) => {\n                     Some(default_lib_output())\n                 }\n                 Some(ref n) if n.equiv(&(\"staticlib\")) => {\n-                    Some(OutputStaticlib)\n+                    Some(CrateTypeStaticlib)\n                 }\n-                Some(ref n) if n.equiv(&(\"bin\")) => Some(OutputExecutable),\n+                Some(ref n) if n.equiv(&(\"bin\")) => Some(CrateTypeExecutable),\n                 Some(_) => {\n                     session.add_lint(lint::UnknownCrateType,\n                                      ast::CRATE_NODE_ID,\n@@ -473,7 +472,7 @@ pub fn collect_outputs(session: &Session,\n     });\n     base.extend(&mut iter);\n     if base.len() == 0 {\n-        base.push(OutputExecutable);\n+        base.push(CrateTypeExecutable);\n     }\n     base.sort();\n     base.dedup();"}, {"sha": "2c7821f965f48f28fd2af53f50f4945776944e7b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -301,12 +301,12 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n         }\n \n         if crate_file_name {\n-            let lm = link::build_link_meta(sess, attrs, &t_outputs.obj_filename,\n+            let lm = link::build_link_meta(attrs, &t_outputs,\n                                            &mut ::util::sha2::Sha256::new());\n-            let outputs = session::collect_outputs(&sess, attrs);\n-            for &style in outputs.iter() {\n+            let crate_types = session::collect_crate_types(&sess, attrs);\n+            for &style in crate_types.iter() {\n                 let fname = link::filename_for_input(&sess, style, &lm,\n-                                                     &t_outputs.out_filename);\n+                                                     &t_outputs.with_extension(\"\"));\n                 println!(\"{}\", fname.filename_display());\n             }\n         }"}, {"sha": "485daf3d387fce3d704ca2ea409e7750978884a4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -28,6 +28,7 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n+use driver::driver::OutputFilenames;\n use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, True, Vector};\n@@ -2657,7 +2658,7 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n pub fn trans_crate(sess: session::Session,\n                    crate: ast::Crate,\n                    analysis: &CrateAnalysis,\n-                   output: &Path) -> CrateTranslation {\n+                   output: &OutputFilenames) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use sync::one::{Once, ONCE_INIT};\n@@ -2677,7 +2678,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     let mut symbol_hasher = Sha256::new();\n-    let link_meta = link::build_link_meta(sess, crate.attrs, output,\n+    let link_meta = link::build_link_meta(crate.attrs, output,\n                                           &mut symbol_hasher);\n \n     // Append \".rs\" to crate name as LLVM module identifier."}, {"sha": "174841f282a5bdd05d73bebf570f4f55c428d101", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -55,7 +55,7 @@ fn get_ast_and_resolve(cpath: &Path,\n         binary: ~\"rustdoc\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n-        outputs: ~[driver::session::OutputDylib],\n+        crate_types: ~[driver::session::CrateTypeDylib],\n         .. (*rustc::driver::session::basic_options()).clone()\n     };\n "}, {"sha": "b2216b3a28c57491e738c660b79be9e1627e4fb0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -17,6 +17,7 @@ use std::str;\n \n use extra::tempfile::TempDir;\n use extra::test;\n+use rustc::back::link;\n use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n@@ -43,7 +44,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n         binary: ~\"rustdoc\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: libs,\n-        outputs: ~[session::OutputDylib],\n+        crate_types: ~[session::CrateTypeDylib],\n         .. (*session::basic_options()).clone()\n     };\n \n@@ -104,8 +105,9 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n         binary: ~\"rustdoctest\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n-        outputs: ~[session::OutputExecutable],\n+        crate_types: ~[session::CrateTypeExecutable],\n         debugging_opts: session::PREFER_DYNAMIC,\n+        output_types: ~[link::OutputTypeExe],\n         .. (*session::basic_options()).clone()\n     };\n "}, {"sha": "5009ed15ee6c02dacc0f64389840b67a42a59f02", "filename": "src/test/run-make/crate-data-smoke/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fcrate-data-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fcrate-data-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcrate-data-smoke%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -4,7 +4,7 @@ all:\n \t[ `$(RUSTC) --crate-id crate.rs` = \"foo#0.10-pre\" ]\n \t[ `$(RUSTC) --crate-name crate.rs` = \"foo\" ]\n \t[ `$(RUSTC) --crate-file-name crate.rs` = \"foo\" ]\n-\t[ `$(RUSTC) --crate-file-name --lib --test crate.rs` = \"foo\" ]\n+\t[ `$(RUSTC) --crate-file-name --crate-type=lib --test crate.rs` = \"foo\" ]\n \t[ `$(RUSTC) --crate-file-name --test lib.rs` = \"mylib\" ]\n \t$(RUSTC) --crate-file-name lib.rs\n \t$(RUSTC) --crate-file-name rlib.rs"}, {"sha": "72ce26ee6c638f7513f78ed1bbfe911b8beb6d07", "filename": "src/test/run-make/dep-info-custom/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) --dep-info $(TMPDIR)/custom-deps-file.d --lib lib.rs\n+\t$(RUSTC) --dep-info $(TMPDIR)/custom-deps-file.d --crate-type=lib lib.rs\n \tsleep 1\n \ttouch foo.rs\n \t-rm -f $(TMPDIR)/done"}, {"sha": "302bb84908b66caf9ade6c81429ace97b4341803", "filename": "src/test/run-make/dep-info-custom/Makefile.foo", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile.foo", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile.foo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-custom%2FMakefile.foo?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n-LIB := $(shell $(RUSTC) --crate-file-name --lib lib.rs)\n+LIB := $(shell $(RUSTC) --crate-file-name --crate-type=lib lib.rs)\n \n $(TMPDIR)/$(LIB):\n-\t$(RUSTC) --dep-info $(TMPDIR)/custom-deps-file.d --lib lib.rs\n+\t$(RUSTC) --dep-info $(TMPDIR)/custom-deps-file.d --crate-type=lib lib.rs\n \ttouch $(TMPDIR)/done\n \n -include $(TMPDIR)/custom-deps-file.d"}, {"sha": "00a59383176df4354ebb4a1d0d933748fa7ab517", "filename": "src/test/run-make/dep-info/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) --dep-info --lib lib.rs\n+\t$(RUSTC) --dep-info --crate-type=lib lib.rs\n \tsleep 1\n \ttouch foo.rs\n \t-rm -f $(TMPDIR)/done"}, {"sha": "2b43dd0ec7095fbde0af1a498e01a0619628d8bf", "filename": "src/test/run-make/dep-info/Makefile.foo", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile.foo", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile.foo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info%2FMakefile.foo?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n-LIB := $(shell $(RUSTC) --crate-file-name --lib lib.rs)\n+LIB := $(shell $(RUSTC) --crate-file-name --crate-type=lib lib.rs)\n \n $(TMPDIR)/$(LIB):\n-\t$(RUSTC) --dep-info --lib lib.rs\n+\t$(RUSTC) --dep-info --crate-type=lib lib.rs\n \ttouch $(TMPDIR)/done\n \n--include $(TMPDIR)/lib.d\n+-include $(TMPDIR)/foo.d"}, {"sha": "d40b6862a0143dbfe2c5f2b3178700e118fa5e91", "filename": "src/test/run-make/duplicate-output-flavors/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fduplicate-output-flavors%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,4 +1,4 @@\n include ../tools.mk\n \n all:\n-\t$(RUSTC) --rlib foo.rs\n+\t$(RUSTC) --crate-type=rlib foo.rs"}, {"sha": "533a6933a6dbc247de548d4c919f005923072dee", "filename": "src/test/run-make/mixing-libs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-libs%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -3,7 +3,7 @@\n all:\n \t$(RUSTC) rlib.rs\n \t$(RUSTC) dylib.rs && exit 1 || exit 0\n-\t$(RUSTC) rlib.rs --dylib\n+\t$(RUSTC) rlib.rs --crate-type=dylib\n \t$(RUSTC) dylib.rs\n \trm $(call DYLIB,rlib-*)\n \t$(RUSTC) prog.rs && exit 1 || exit 0"}, {"sha": "258cbf04c611dba792f65b70a9461958b02c4e26", "filename": "src/test/run-make/no-intermediate-extras/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fno-intermediate-extras%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fno-intermediate-extras%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-intermediate-extras%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -3,5 +3,5 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) --rlib --test foo.rs\n+\t$(RUSTC) --crate-type=rlib --test foo.rs\n \trm $(TMPDIR)/foo.bc && exit 1 || exit 0"}, {"sha": "72f96b21fa8b2e3bc79d78fef5391bca7bfe531a", "filename": "src/test/run-make/output-type-permutations/Makefile", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Foutput-type-permutations%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -0,0 +1,42 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs --crate-type=rlib,dylib,staticlib\n+\trm $(TMPDIR)/$(call RLIB_GLOB,bar)\n+\trm $(TMPDIR)/$(call DYLIB_GLOB,bar)\n+\trm $(TMPDIR)/$(call STATICLIB_GLOB,bar)\n+\t$(RUSTC) foo.rs --crate-type=bin\n+\trm $(TMPDIR)/bar\n+\t$(RUSTC) foo.rs --emit=asm,ir,bc,obj,link\n+\trm $(TMPDIR)/bar.ll\n+\trm $(TMPDIR)/bar.bc\n+\trm $(TMPDIR)/bar.s\n+\trm $(TMPDIR)/bar.o\n+\trm $(TMPDIR)/bar\n+\t$(RUSTC) foo.rs --emit=asm,ir,bc,obj,link --crate-type=staticlib\n+\trm $(TMPDIR)/bar.ll\n+\trm $(TMPDIR)/bar.bc\n+\trm $(TMPDIR)/bar.s\n+\trm $(TMPDIR)/bar.o\n+\trm $(TMPDIR)/$(call STATICLIB_GLOB,bar)\n+\t$(RUSTC) foo.rs --emit=asm -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --emit=bc -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --emit=ir -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --emit=obj -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --emit=link -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --crate-type=rlib -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --crate-type=dylib -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --crate-type=staticlib -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --crate-type=bin -o $(TMPDIR)/foo\n+\trm $(TMPDIR)/foo\n+\t$(RUSTC) foo.rs --emit=bc,link --crate-type=rlib\n+\trm $(TMPDIR)/bar.bc\n+\trm $(TMPDIR)/$(call RLIB_GLOB,bar)"}, {"sha": "3d944fd7a58aa57cbbe219d4da285caf4b6de700", "filename": "src/test/run-make/output-type-permutations/foo.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Foutput-type-permutations%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Foutput-type-permutations%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Foutput-type-permutations%2Ffoo.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -0,0 +1,3 @@\n+#[crate_id = \"bar\"];\n+\n+fn main() {}"}, {"sha": "6fb7434e68ab3a43c10b0163223da9886fbab8e2", "filename": "src/test/run-make/prefer-dylib/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fprefer-dylib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fprefer-dylib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fprefer-dylib%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) bar.rs --dylib --rlib\n+\t$(RUSTC) bar.rs --crate-type=dylib --crate-type=rlib\n \t$(RUSTC) foo.rs -Z prefer-dynamic\n \t$(call RUN,foo)\n \trm $(TMPDIR)/*bar*"}, {"sha": "c6a239eef08e287577e068e8e95e098f80e35bf2", "filename": "src/test/run-make/prefer-rlib/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fprefer-rlib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fprefer-rlib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fprefer-rlib%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n all:\n-\t$(RUSTC) bar.rs --dylib --rlib\n+\t$(RUSTC) bar.rs --crate-type=dylib --crate-type=rlib\n \tls $(TMPDIR)/$(call RLIB_GLOB,bar)\n \t$(RUSTC) foo.rs\n \trm $(TMPDIR)/*bar*"}, {"sha": "84e6e079e6f06bea606c775438de005fc6a3fa2d", "filename": "src/test/run-make/simple-dylib/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fsimple-dylib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fsimple-dylib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimple-dylib%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,5 +1,5 @@\n -include ../tools.mk\n all:\n-\t$(RUSTC) bar.rs --dylib\n+\t$(RUSTC) bar.rs --crate-type=dylib\n \t$(RUSTC) foo.rs\n \t$(call RUN,foo)"}, {"sha": "7b156cb87488065d8949d79447fa610eb597e446", "filename": "src/test/run-make/simple-rlib/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fsimple-rlib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fsimple-rlib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimple-rlib%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,5 +1,5 @@\n -include ../tools.mk\n all:\n-\t$(RUSTC) bar.rs --rlib\n+\t$(RUSTC) bar.rs --crate-type=rlib\n \t$(RUSTC) foo.rs\n \t$(call RUN,foo)"}, {"sha": "bf79ca68c9461ac8d6fe57a456a7d8ad1f39038c", "filename": "src/test/run-make/volatile-intrinsics/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2FMakefile?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -5,6 +5,6 @@ all:\n \t$(RUSTC) main.rs\n \t$(call RUN,main)\n \t# ... and the loads/stores must not be optimized out.\n-\t$(RUSTC) main.rs --emit-llvm -S\n+\t$(RUSTC) main.rs --emit=ir\n \tgrep \"load volatile\"  $(TMPDIR)/main.ll\n \tgrep \"store volatile\" $(TMPDIR)/main.ll"}]}