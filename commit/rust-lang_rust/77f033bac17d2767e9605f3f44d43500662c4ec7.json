{"sha": "77f033bac17d2767e9605f3f44d43500662c4ec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZjAzM2JhYzE3ZDI3NjdlOTYwNWYzZjQ0ZDQzNTAwNjYyYzRlYzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-08T21:08:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-24T21:41:09Z"}, "message": "Lift the restriction on reusing names of primitive types", "tree": {"sha": "ad7e82adf0a13336d8caca3b5d52fc03b13f6068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad7e82adf0a13336d8caca3b5d52fc03b13f6068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f033bac17d2767e9605f3f44d43500662c4ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f033bac17d2767e9605f3f44d43500662c4ec7", "html_url": "https://github.com/rust-lang/rust/commit/77f033bac17d2767e9605f3f44d43500662c4ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f033bac17d2767e9605f3f44d43500662c4ec7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d4b1d1cf38a51b92b91e020ecb22a5d442297be", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4b1d1cf38a51b92b91e020ecb22a5d442297be", "html_url": "https://github.com/rust-lang/rust/commit/8d4b1d1cf38a51b92b91e020ecb22a5d442297be"}], "stats": {"total": 121, "additions": 23, "deletions": 98}, "files": [{"sha": "8a196768ae5168ea178c4c7f1f511b787474c0c7", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=77f033bac17d2767e9605f3f44d43500662c4ec7", "patch": "@@ -205,51 +205,6 @@ about what constitutes an Item declaration and what does not:\n https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n-E0317: r##\"\n-User-defined types or type parameters cannot shadow the primitive types.\n-This error indicates you tried to define a type, struct or enum with the same\n-name as an existing primitive type:\n-\n-```compile_fail\n-struct u8 {\n-    // ...\n-}\n-```\n-\n-To fix this, simply name it something else.\n-\n-Such an error may also occur if you define a type parameter which shadows a\n-primitive type. An example would be something like:\n-\n-```compile_fail\n-impl<u8> MyTrait for Option<u8> {\n-    // ...\n-}\n-```\n-\n-In such a case, if you meant for `u8` to be a generic type parameter (i.e. any\n-type can be used in its place), use something like `T` instead:\n-\n-```ignore\n-impl<T> MyTrait for Option<T> {\n-    // ...\n-}\n-```\n-\n-On the other hand, if you wished to refer to the specific type `u8`, remove it\n-from the type parameter list:\n-\n-```ignore\n-impl MyTrait for Option<u8> {\n-    // ...\n-}\n-\n-See the Types section of the reference for more information about the primitive\n-types:\n-\n-https://doc.rust-lang.org/reference.html#types\n-\"##,\n-\n E0364: r##\"\n Private items cannot be publicly re-exported.  This error indicates that you\n attempted to `pub use` a type or value that was not itself public."}, {"sha": "a54338b63607863c8bd381f915ace321d8e6ec9c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=77f033bac17d2767e9605f3f44d43500662c4ec7", "patch": "@@ -1615,15 +1615,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         intravisit::walk_crate(self, krate);\n     }\n \n-    fn check_if_primitive_type_name(&self, name: Name, span: Span) {\n-        if let Some(_) = self.primitive_type_table.primitive_types.get(&name) {\n-            span_err!(self.session,\n-                      span,\n-                      E0317,\n-                      \"user-defined types or type parameters cannot shadow the primitive types\");\n-        }\n-    }\n-\n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.name;\n \n@@ -1633,8 +1624,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemEnum(_, ref generics) |\n             ItemTy(_, ref generics) |\n             ItemStruct(_, ref generics) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n                                              |this| intravisit::walk_item(this, item));\n             }\n@@ -1655,8 +1644,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n@@ -1691,8 +1678,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n-                                    this.check_if_primitive_type_name(trait_item.name,\n-                                                                      trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n                                         intravisit::walk_trait_item(this, trait_item)\n                                     });\n@@ -1716,28 +1701,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemUse(ref view_path) => {\n-                // check for imports shadowing primitive types\n-                let check_rename = |this: &Self, id, name| {\n-                    match this.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                        Some(Def::Enum(..)) | Some(Def::TyAlias(..)) | Some(Def::Struct(..)) |\n-                        Some(Def::Trait(..)) | None => {\n-                            this.check_if_primitive_type_name(name, item.span);\n-                        }\n-                        _ => {}\n-                    }\n-                };\n-\n                 match view_path.node {\n-                    hir::ViewPathSimple(name, _) => {\n-                        check_rename(self, item.id, name);\n-                    }\n                     hir::ViewPathList(ref prefix, ref items) => {\n-                        for item in items {\n-                            if let Some(name) = item.node.rename() {\n-                                check_rename(self, item.node.id(), name);\n-                            }\n-                        }\n-\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n                             match self.resolve_crate_relative_path(prefix.span,\n@@ -1918,9 +1883,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.check_if_primitive_type_name(type_parameter.name, type_parameter.span);\n-        }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(_) |\n@@ -2699,7 +2661,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           -> Option<LocalDef> {\n         let def = self.resolve_identifier(identifier, namespace, check_ribs, record_used);\n         match def {\n-            None | Some(LocalDef{def: Def::Mod(..), ..}) => {\n+            None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS => {\n                 if let Some(&prim_ty) = self.primitive_type_table\n                                             .primitive_types\n                                             .get(&identifier.unhygienic_name) {"}, {"sha": "43674ccf543526d896dcdab57a754b499c88aff1", "filename": "src/test/run-pass/issue-20427.rs", "status": "renamed", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f033bac17d2767e9605f3f44d43500662c4ec7/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20427.rs?ref=77f033bac17d2767e9605f3f44d43500662c4ec7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,12 +15,9 @@ static i32: i32 = 0;\n const i64: i64 = 0;\n fn u8(f32: f32) {}\n fn f<f64>(f64: f64) {}\n-//~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n-type u16 = u16; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n-enum u32 {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-struct u64; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-trait bool {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+enum u32 {}\n+struct u64;\n+trait bool {}\n \n mod char {\n     extern crate i8;\n@@ -41,29 +38,40 @@ mod char {\n         use super::u8_ as u8;\n         use super::f_ as f64;\n         use super::u16_ as u16;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u32_ as u32;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u64_ as u64;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::bool_ as bool;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::{bool_ as str};\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::char_ as char;\n     }\n }\n \n trait isize_ {\n-    type isize; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+    type isize;\n }\n \n fn usize<'usize>(usize: &'usize usize) -> &'usize usize { usize }\n \n+mod reuse {\n+    use std::mem::size_of;\n+\n+    type u8 = u64;\n+    use std::string::String as i16;\n+\n+    pub fn check<u16>() {\n+        assert_eq!(size_of::<u8>(), 8);\n+        assert_eq!(size_of::<::u64>(), 0);\n+        assert_eq!(size_of::<i16>(), 3 * size_of::<*const ()>());\n+        assert_eq!(size_of::<u16>(), 0);\n+    }\n+}\n+\n fn main() {\n     let bool = true;\n-    match bool {\n+    let _ = match bool {\n         str @ true => if str { i32 as i64 } else { i64 },\n         false => i64,\n     };\n+\n+    reuse::check::<u64>();\n }", "previous_filename": "src/test/compile-fail/issue-20427.rs"}]}