{"sha": "0b86d30594fe03858416139a940262d2277f53a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiODZkMzA1OTRmZTAzODU4NDE2MTM5YTk0MDI2MmQyMjc3ZjUzYTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T15:14:59Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T15:14:59Z"}, "message": "enable Lvalue::Local to refer to a ValPair field", "tree": {"sha": "5005f921a4f0486d20b58105985c9714c3743d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5005f921a4f0486d20b58105985c9714c3743d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b86d30594fe03858416139a940262d2277f53a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b86d30594fe03858416139a940262d2277f53a0", "html_url": "https://github.com/rust-lang/rust/commit/0b86d30594fe03858416139a940262d2277f53a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b86d30594fe03858416139a940262d2277f53a0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31f3aabdd46e93bdbe88c08c1e62d5530dab182f", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f3aabdd46e93bdbe88c08c1e62d5530dab182f", "html_url": "https://github.com/rust-lang/rust/commit/31f3aabdd46e93bdbe88c08c1e62d5530dab182f"}], "stats": {"total": 138, "additions": 106, "deletions": 32}, "files": [{"sha": "114927b9574bb96873e810303e061eb6df687d28", "filename": "src/eval_context.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0b86d30594fe03858416139a940262d2277f53a0/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b86d30594fe03858416139a940262d2277f53a0/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=0b86d30594fe03858416139a940262d2277f53a0", "patch": "@@ -851,17 +851,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         lvalue: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n-            Lvalue::Local { frame, local } => {\n-                match self.stack[frame].get_local(local) {\n-                    Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n+            Lvalue::Local { frame, local, field } => {\n+                // -1 since we don't store the return value\n+                match self.stack[frame].locals[local.index() - 1] {\n+                    Value::ByRef(ptr) => {\n+                        assert!(field.is_none());\n+                        Lvalue::from_ptr(ptr)\n+                    },\n                     val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].substs);\n                         let substs = self.stack[frame].substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].set_local(local, Value::ByRef(ptr));\n+                        self.stack[frame].locals[local.index() - 1] = Value::ByRef(ptr);\n                         self.write_value_to_ptr(val, ptr, ty)?;\n-                        Lvalue::from_ptr(ptr)\n+                        let lval = Lvalue::from_ptr(ptr);\n+                        if let Some((field, field_ty)) = field {\n+                            self.lvalue_field(lval, field, ty, field_ty)?\n+                        } else {\n+                            lval\n+                        }\n                     }\n                 }\n             }\n@@ -924,8 +933,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(ptr, val, size)\n             }\n-            Lvalue::Local { frame, local } => {\n-                self.stack[frame].set_local(local, Value::ByVal(val));\n+            Lvalue::Local { frame, local, field } => {\n+                self.stack[frame].set_local(local, field.map(|(i, _)| i), Value::ByVal(val));\n                 Ok(())\n             }\n             Lvalue::Global(cid) => {\n@@ -966,11 +975,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n-            Lvalue::Local { frame, local } => {\n-                let dest = self.stack[frame].get_local(local);\n+            Lvalue::Local { frame, local, field } => {\n+                let dest = self.stack[frame].get_local(local, field.map(|(i, _)| i));\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| this.stack[frame].set_local(local, val),\n+                    |this, val| this.stack[frame].set_local(local, field.map(|(i, _)| i), val),\n                     dest,\n                     dest_ty,\n                 )\n@@ -1355,16 +1364,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n-        if let Lvalue::Local { frame, local } = lvalue {\n+        if let Lvalue::Local { frame, local, field } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n             let last_frame = self.stack.len() - 1;\n             if frame != last_frame {\n                 write!(msg, \" ({} frames up)\", last_frame - frame).unwrap();\n             }\n+            if let Some(field) = field {\n+                write!(msg, \" (field {:?})\", field).unwrap();\n+            }\n             write!(msg, \":\").unwrap();\n \n-            match self.stack[frame].get_local(local) {\n+            match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n                 Value::ByRef(ptr) => {\n                     allocs.push(ptr.alloc_id);\n                 }\n@@ -1402,13 +1414,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         frame: usize,\n         local: mir::Local,\n+        field: Option<usize>,\n         f: F,\n     ) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack[frame].get_local(local);\n+        let val = self.stack[frame].get_local(local, field);\n         let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, new_val);\n+        self.stack[frame].set_local(local, field, new_val);\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n         // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n         //     self.memory.deallocate(ptr)?;\n@@ -1418,14 +1431,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl<'tcx> Frame<'tcx> {\n-    pub fn get_local(&self, local: mir::Local) -> Value {\n+    pub fn get_local(&self, local: mir::Local, field: Option<usize>) -> Value {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1]\n+        if let Some(field) = field {\n+            match self.locals[local.index() - 1] {\n+                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n+                val @ Value::ByVal(_) => {\n+                    assert_eq!(field, 0);\n+                    val\n+                },\n+                Value::ByValPair(a, b) => {\n+                    match field {\n+                        0 => Value::ByVal(a),\n+                        1 => Value::ByVal(b),\n+                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n+                    }\n+                },\n+            }\n+        } else {\n+            self.locals[local.index() - 1]\n+        }\n     }\n \n-    fn set_local(&mut self, local: mir::Local, value: Value) {\n+    fn set_local(&mut self, local: mir::Local, field: Option<usize>, value: Value) {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1] = value;\n+        if let Some(field) = field {\n+            match self.locals[local.index() - 1] {\n+                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n+                Value::ByVal(_) => {\n+                    assert_eq!(field, 0);\n+                    self.set_local(local, None, value);\n+                },\n+                Value::ByValPair(a, b) => {\n+                    let prim = match value {\n+                        Value::ByRef(_) => bug!(\"can't set ValPair field to ByRef\"),\n+                        Value::ByVal(val) => val,\n+                        Value::ByValPair(_, _) => bug!(\"can't set ValPair field to ValPair\"),\n+                    };\n+                    match field {\n+                        0 => self.set_local(local, None, Value::ByValPair(prim, b)),\n+                        1 => self.set_local(local, None, Value::ByValPair(a, prim)),\n+                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n+                    }\n+                },\n+            }\n+        } else {\n+            self.locals[local.index() - 1] = value;\n+        }\n     }\n }\n "}, {"sha": "6a4bfb3c7d472dac8ba5932dd746ab7d50373f31", "filename": "src/lvalue.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b86d30594fe03858416139a940262d2277f53a0/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b86d30594fe03858416139a940262d2277f53a0/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=0b86d30594fe03858416139a940262d2277f53a0", "patch": "@@ -23,6 +23,8 @@ pub enum Lvalue<'tcx> {\n     Local {\n         frame: usize,\n         local: mir::Local,\n+        /// Optionally, this lvalue can point to a field of the stack value\n+        field: Option<(usize, Ty<'tcx>)>,\n     },\n \n     /// An lvalue referring to a global\n@@ -116,7 +118,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if let mir::Lvalue::Local(index) = proj.base {\n-                if let Value::ByValPair(a, b) = self.frame().get_local(index) {\n+                if let Value::ByValPair(a, b) = self.frame().get_local(index, None) {\n                     if let mir::ProjectionElem::Field(ref field, _) = proj.elem {\n                         let val = [a, b][field.index()];\n                         return Ok(Value::ByVal(val));\n@@ -134,7 +136,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 assert_eq!(extra, LvalueExtra::None);\n                 Value::ByRef(ptr)\n             }\n-            Lvalue::Local { frame, local } => self.stack[frame].get_local(local),\n+            Lvalue::Local { frame, local, field } => self.stack[frame].get_local(local, field.map(|(i, _)| i)),\n             Lvalue::Global(cid) => self.globals.get(&cid).expect(\"global not cached\").value,\n         }\n     }\n@@ -143,7 +145,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local },\n+            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n \n             Static(def_id) => {\n                 let substs = self.tcx.intern_substs(&[]);\n@@ -163,7 +165,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn lvalue_field(\n         &mut self,\n         base: Lvalue<'tcx>,\n-        field: usize,\n+        field_index: usize,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n@@ -172,32 +174,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n             Univariant { ref variant, .. } => {\n-                (variant.offsets[field], variant.packed)\n+                (variant.offsets[field_index], variant.packed)\n             },\n \n             General { ref variants, .. } => {\n                 let (_, base_extra) = base.to_ptr_and_extra();\n                 if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n                     // +1 for the discriminant, which is field 0\n-                    (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n+                    (variants[variant_idx].offsets[field_index + 1], variants[variant_idx].packed)\n                 } else {\n                     bug!(\"field access on enum had no variant index\");\n                 }\n             }\n \n             RawNullablePointer { .. } => {\n-                assert_eq!(field, 0);\n+                assert_eq!(field_index, 0);\n                 return Ok(base);\n             }\n \n             StructWrappedNullablePointer { ref nonnull, .. } => {\n-                (nonnull.offsets[field], nonnull.packed)\n+                (nonnull.offsets[field_index], nonnull.packed)\n             }\n \n             UntaggedUnion { .. } => return Ok(base),\n \n             Vector { element, count } => {\n-                let field = field as u64;\n+                let field = field_index as u64;\n                 assert!(field < count);\n                 let elem_size = element.size(&self.tcx.data_layout).bytes();\n                 (Size::from_bytes(field * elem_size), false)\n@@ -206,9 +208,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n         };\n \n-        // FIXME(solson)\n-        let base = self.force_allocation(base)?;\n-        let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+        let (base_ptr, base_extra) = match base {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n+                Value::ByRef(ptr) => {\n+                    assert!(field.is_none(), \"local can't be ByRef and have a field offset\");\n+                    (ptr, LvalueExtra::None)\n+                },\n+                Value::ByVal(_) => {\n+                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n+                    return Ok(base);\n+                },\n+                Value::ByValPair(_, _) => {\n+                    assert!(field_index < 2);\n+                    return Ok(Lvalue::Local {\n+                        frame,\n+                        local,\n+                        field: Some((field_index, field_ty)),\n+                    });\n+                },\n+            },\n+            // FIXME: do for globals what we did for locals\n+            Lvalue::Global(_) => self.force_allocation(base)?.to_ptr_and_extra(),\n+        };\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {"}, {"sha": "f7e34d2bc639648fce2879544993ec9fe1b66686", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b86d30594fe03858416139a940262d2277f53a0/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b86d30594fe03858416139a940262d2277f53a0/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=0b86d30594fe03858416139a940262d2277f53a0", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok(zero_val)\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n+                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), init)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n+                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), uninit)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat ptr target\"),"}]}