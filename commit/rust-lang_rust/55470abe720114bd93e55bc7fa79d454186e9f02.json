{"sha": "55470abe720114bd93e55bc7fa79d454186e9f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NDcwYWJlNzIwMTE0YmQ5M2U1NWJjN2ZhNzlkNDU0MTg2ZTlmMDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T09:52:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-04T15:04:51Z"}, "message": "Remove one dependence on typeck from const_eval.", "tree": {"sha": "52fe4873a9e53a974e8d05188800b8c41aa3ecf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52fe4873a9e53a974e8d05188800b8c41aa3ecf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55470abe720114bd93e55bc7fa79d454186e9f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55470abe720114bd93e55bc7fa79d454186e9f02", "html_url": "https://github.com/rust-lang/rust/commit/55470abe720114bd93e55bc7fa79d454186e9f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55470abe720114bd93e55bc7fa79d454186e9f02/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ca861f9dfcbb5bc9f97d8463885fb04ef4812d", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ca861f9dfcbb5bc9f97d8463885fb04ef4812d", "html_url": "https://github.com/rust-lang/rust/commit/00ca861f9dfcbb5bc9f97d8463885fb04ef4812d"}], "stats": {"total": 218, "additions": 119, "deletions": 99}, "files": [{"sha": "5637f5d1755335d4417f6625145f4f70cb73b864", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=55470abe720114bd93e55bc7fa79d454186e9f02", "patch": "@@ -59,6 +59,7 @@ pub mod back {\n }\n \n pub mod middle {\n+    pub mod astconv_util;\n     pub mod astencode;\n     pub mod borrowck;\n     pub mod cfg;"}, {"sha": "6b90bcd60e75330f19be44f6fcc2897d3259a8df", "filename": "src/librustc/middle/astconv_util.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=55470abe720114bd93e55bc7fa79d454186e9f02", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * This module contains a simple utility routine\n+ * used by both `typeck` and `const_eval`.\n+ * Almost certainly this could (and should) be refactored out of existence.\n+ */\n+\n+use middle::def;\n+use middle::ty::{mod, Ty};\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub const NO_REGIONS: uint = 1;\n+pub const NO_TPS: uint = 2;\n+\n+pub fn check_path_args(tcx: &ty::ctxt,\n+                       path: &ast::Path,\n+                       flags: uint) {\n+    if (flags & NO_TPS) != 0u {\n+        if path.segments.iter().any(|s| s.parameters.has_types()) {\n+            span_err!(tcx.sess, path.span, E0109,\n+                \"type parameters are not allowed on this type\");\n+        }\n+    }\n+\n+    if (flags & NO_REGIONS) != 0u {\n+        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n+            span_err!(tcx.sess, path.span, E0110,\n+                \"region parameters are not allowed on this type\");\n+        }\n+    }\n+}\n+\n+pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n+                               -> Option<Ty<'tcx>> {\n+    match ast_ty.node {\n+        ast::TyPath(ref path, id) => {\n+            let a_def = match tcx.def_map.borrow().get(&id) {\n+                None => {\n+                    tcx.sess.span_bug(ast_ty.span,\n+                                      format!(\"unbound path {}\",\n+                                              path.repr(tcx)).as_slice())\n+                }\n+                Some(&d) => d\n+            };\n+            match a_def {\n+                def::DefPrimTy(nty) => {\n+                    match nty {\n+                        ast::TyBool => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_bool())\n+                        }\n+                        ast::TyChar => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_char())\n+                        }\n+                        ast::TyInt(it) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_int(it))\n+                        }\n+                        ast::TyUint(uit) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_uint(uit))\n+                        }\n+                        ast::TyFloat(ft) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_float(ft))\n+                        }\n+                        ast::TyStr => {\n+                            Some(ty::mk_str(tcx))\n+                        }\n+                    }\n+                }\n+                _ => None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+"}, {"sha": "43726f55bb989ae2ae2167b2dc2efff4c7af486a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=55470abe720114bd93e55bc7fa79d454186e9f02", "patch": "@@ -17,8 +17,8 @@ pub use self::constness::*;\n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n-use middle::ty::{mod, Ty};\n-use middle::typeck::{astconv, check};\n+use middle::ty::{mod};\n+use middle::astconv_util::{ast_ty_to_prim_ty};\n use util::nodemap::DefIdMap;\n \n use syntax::ast::{mod, Expr};\n@@ -277,14 +277,6 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n-        if let ast::TyFixedLengthVec(_, ref expr) = t.node {\n-            check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n-        }\n-\n-        visit::walk_ty(self, t);\n-    }\n-\n     fn visit_expr_post(&mut self, e: &Expr) {\n         self.classify(e);\n     }\n@@ -504,7 +496,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ty::expr_ty_opt(tcx, e)\n-                .or_else(|| astconv::ast_ty_to_prim_ty(tcx, &**target_ty))\n+                .or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")"}, {"sha": "abdf66eeb3b160fc6023216d6c1db09738a275d7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 68, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=55470abe720114bd93e55bc7fa79d454186e9f02", "patch": "@@ -46,6 +46,8 @@\n //! Note that the self region for the `foo` defaulted to `&` in the first\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n+\n+use middle::astconv_util::{ast_ty_to_prim_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n@@ -553,74 +555,6 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     }\n }\n \n-pub const NO_REGIONS: uint = 1;\n-pub const NO_TPS: uint = 2;\n-\n-fn check_path_args(tcx: &ty::ctxt,\n-                   path: &ast::Path,\n-                   flags: uint) {\n-    if (flags & NO_TPS) != 0u {\n-        if path.segments.iter().any(|s| s.parameters.has_types()) {\n-            span_err!(tcx.sess, path.span, E0109,\n-                \"type parameters are not allowed on this type\");\n-        }\n-    }\n-\n-    if (flags & NO_REGIONS) != 0u {\n-        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n-            span_err!(tcx.sess, path.span, E0110,\n-                \"region parameters are not allowed on this type\");\n-        }\n-    }\n-}\n-\n-pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n-                               -> Option<Ty<'tcx>> {\n-    match ast_ty.node {\n-        ast::TyPath(ref path, id) => {\n-            let a_def = match tcx.def_map.borrow().get(&id) {\n-                None => {\n-                    tcx.sess.span_bug(ast_ty.span,\n-                                      format!(\"unbound path {}\",\n-                                              path.repr(tcx)).as_slice())\n-                }\n-                Some(&d) => d\n-            };\n-            match a_def {\n-                def::DefPrimTy(nty) => {\n-                    match nty {\n-                        ast::TyBool => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_bool())\n-                        }\n-                        ast::TyChar => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_char())\n-                        }\n-                        ast::TyInt(it) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_int(it))\n-                        }\n-                        ast::TyUint(uit) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_uint(uit))\n-                        }\n-                        ast::TyFloat(ft) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_float(ft))\n-                        }\n-                        ast::TyStr => {\n-                            Some(ty::mk_str(tcx))\n-                        }\n-                    }\n-                }\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n-}\n-\n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>("}, {"sha": "cacccbda53ca709c0a26a393a8e2e18d338cb0bd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55470abe720114bd93e55bc7fa79d454186e9f02/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=55470abe720114bd93e55bc7fa79d454186e9f02", "patch": "@@ -361,6 +361,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        match t.node {\n+            ast::TyFixedLengthVec(_, ref expr) => {\n+                check_const_in_type(self.ccx, &**expr, ty::mk_uint());\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_ty(self, t);\n+    }\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n@@ -4672,36 +4683,29 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// Checks a constant appearing in a type. At the moment this is just the\n /// length expression in a fixed-length vector, but someday it might be\n /// extended to type-level numeric literals.\n-pub fn check_const_in_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 expr: &ast::Expr,\n-                                 expected_type: Ty<'tcx>) {\n-    // Synthesize a crate context. The trait map is not needed here (though I\n-    // imagine it will be if we have associated statics --pcwalton), so we\n-    // leave it blank.\n-    let ccx = CrateCtxt {\n-        trait_map: NodeMap::new(),\n-        tcx: tcx,\n-    };\n-    let inh = static_inherited_fields(&ccx);\n-    let fcx = blank_fn_ctxt(&ccx, &inh, ty::FnConverging(expected_type), expr.id);\n+fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n+                                expr: &ast::Expr,\n+                                expected_type: Ty<'tcx>) {\n+    let inh = static_inherited_fields(ccx);\n+    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n \n-pub fn check_const(ccx: &CrateCtxt,\n-                   sp: Span,\n-                   e: &ast::Expr,\n-                   id: ast::NodeId) {\n+fn check_const(ccx: &CrateCtxt,\n+               sp: Span,\n+               e: &ast::Expr,\n+               id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     _: Span,\n-                                     e: &ast::Expr,\n-                                     declty: Ty<'tcx>) {\n+fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 _: Span,\n+                                 e: &ast::Expr,\n+                                 declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly"}]}