{"sha": "65bd40e300323f1e4806dd84834b8d71bb89c08c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YmQ0MGUzMDAzMjNmMWU0ODA2ZGQ4NDgzNGI4ZDcxYmI4OWMwOGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-29T00:20:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-29T01:09:26Z"}, "message": "Remove uses of #[merge]", "tree": {"sha": "53b9245b13ba9991627a0e23b8378a328af42ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53b9245b13ba9991627a0e23b8378a328af42ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65bd40e300323f1e4806dd84834b8d71bb89c08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65bd40e300323f1e4806dd84834b8d71bb89c08c", "html_url": "https://github.com/rust-lang/rust/commit/65bd40e300323f1e4806dd84834b8d71bb89c08c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65bd40e300323f1e4806dd84834b8d71bb89c08c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b95d511316ae7124046de61d19335fdfaa021cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b95d511316ae7124046de61d19335fdfaa021cc", "html_url": "https://github.com/rust-lang/rust/commit/9b95d511316ae7124046de61d19335fdfaa021cc"}], "stats": {"total": 5221, "additions": 2614, "deletions": 2607}, "files": [{"sha": "ccd102e9ca543d66fe159de674713678908135d7", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -144,7 +144,7 @@ pub mod send_map;\n \n // Concurrency\n pub mod comm;\n-#[merge = \"task/mod.rs\"]\n+#[path = \"task/mod.rs\"]\n pub mod task;\n pub mod pipes;\n "}, {"sha": "a2b5c3229ad89330d83a255f9c36ba0cde8a8131", "filename": "src/libcore/task.rs", "status": "removed", "additions": 0, "deletions": 1301, "changes": 1301, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,1301 +0,0 @@\n-// NB: transitionary, de-mode-ing.\n-// tjc: Deprecated modes allowed because of function arg issue\n-// in task::spawn. Re-forbid after snapshot.\n-#[forbid(deprecated_pattern)];\n-\n-/*!\n- * Task management.\n- *\n- * An executing Rust program consists of a tree of tasks, each with their own\n- * stack, and sole ownership of their allocated heap data. Tasks communicate\n- * with each other using ports and channels.\n- *\n- * When a task fails, that failure will propagate to its parent (the task\n- * that spawned it) and the parent will fail as well. The reverse is not\n- * true: when a parent task fails its children will continue executing. When\n- * the root (main) task fails, all tasks fail, and then so does the entire\n- * process.\n- *\n- * Tasks may execute in parallel and are scheduled automatically by the\n- * runtime.\n- *\n- * # Example\n- *\n- * ~~~\n- * do spawn {\n- *     log(error, \"Hello, World!\");\n- * }\n- * ~~~\n- */\n-\n-use cmp::Eq;\n-use result::Result;\n-use pipes::{stream, Chan, Port};\n-use local_data_priv::{local_get, local_set};\n-use util::replace;\n-\n-use rt::task_id;\n-use rt::rust_task;\n-\n-/// A handle to a task\n-pub enum Task {\n-    TaskHandle(task_id)\n-}\n-\n-impl Task : cmp::Eq {\n-    pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }\n-}\n-\n-/**\n- * Indicates the manner in which a task exited.\n- *\n- * A task that completes without failing is considered to exit successfully.\n- * Supervised ancestors and linked siblings may yet fail after this task\n- * succeeds. Also note that in such a case, it may be nondeterministic whether\n- * linked failure or successful exit happen first.\n- *\n- * If you wish for this result's delivery to block until all linked and/or\n- * children tasks complete, recommend using a result future.\n- */\n-pub enum TaskResult {\n-    Success,\n-    Failure,\n-}\n-\n-impl TaskResult : Eq {\n-    pure fn eq(&self, other: &TaskResult) -> bool {\n-        match ((*self), (*other)) {\n-            (Success, Success) | (Failure, Failure) => true,\n-            (Success, _) | (Failure, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n-}\n-\n-/// Scheduler modes\n-pub enum SchedMode {\n-    /// All tasks run in the same OS thread\n-    SingleThreaded,\n-    /// Tasks are distributed among available CPUs\n-    ThreadPerCore,\n-    /// Each task runs in its own OS thread\n-    ThreadPerTask,\n-    /// Tasks are distributed among a fixed number of OS threads\n-    ManualThreads(uint),\n-    /**\n-     * Tasks are scheduled on the main OS thread\n-     *\n-     * The main OS thread is the thread used to launch the runtime which,\n-     * in most cases, is the process's initial thread as created by the OS.\n-     */\n-    PlatformThread\n-}\n-\n-impl SchedMode : cmp::Eq {\n-    pure fn eq(&self, other: &SchedMode) -> bool {\n-        match (*self) {\n-            SingleThreaded => {\n-                match (*other) {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match (*other) {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match (*other) {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match (*other) {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match (*other) {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &SchedMode) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n-/**\n- * Scheduler configuration options\n- *\n- * # Fields\n- *\n- * * sched_mode - The operating mode of the scheduler\n- *\n- * * foreign_stack_size - The size of the foreign stack, in bytes\n- *\n- *     Rust code runs on Rust-specific stacks. When Rust code calls foreign\n- *     code (via functions in foreign modules) it switches to a typical, large\n- *     stack appropriate for running code written in languages like C. By\n- *     default these foreign stacks have unspecified size, but with this\n- *     option their size can be precisely specified.\n- */\n-pub type SchedOpts = {\n-    mode: SchedMode,\n-    foreign_stack_size: Option<uint>\n-};\n-\n-/**\n- * Task configuration options\n- *\n- * # Fields\n- *\n- * * linked - Propagate failure bidirectionally between child and parent.\n- *            True by default. If both this and 'supervised' are false, then\n- *            either task's failure will not affect the other (\"unlinked\").\n- *\n- * * supervised - Propagate failure unidirectionally from parent to child,\n- *                but not from child to parent. False by default.\n- *\n- * * notify_chan - Enable lifecycle notifications on the given channel\n- *\n- * * sched - Specify the configuration of a new scheduler to create the task\n- *           in\n- *\n- *     By default, every task is created in the same scheduler as its\n- *     parent, where it is scheduled cooperatively with all other tasks\n- *     in that scheduler. Some specialized applications may want more\n- *     control over their scheduling, in which case they can be spawned\n- *     into a new scheduler with the specific properties required.\n- *\n- *     This is of particular importance for libraries which want to call\n- *     into foreign code that blocks. Without doing so in a different\n- *     scheduler other tasks will be impeded or even blocked indefinitely.\n- */\n-pub type TaskOpts = {\n-    linked: bool,\n-    supervised: bool,\n-    mut notify_chan: Option<Chan<TaskResult>>,\n-    sched: Option<SchedOpts>,\n-};\n-\n-/**\n- * The task builder type.\n- *\n- * Provides detailed control over the properties and behavior of new tasks.\n- */\n-// NB: Builders are designed to be single-use because they do stateful\n-// things that get weird when reusing - e.g. if you create a result future\n-// it only applies to a single task, so then you have to maintain Some\n-// potentially tricky state to ensure that everything behaves correctly\n-// when you try to reuse the builder to spawn a new task. We'll just\n-// sidestep that whole issue by making builders uncopyable and making\n-// the run function move them in.\n-\n-// FIXME (#3724): Replace the 'consumed' bit with move mode on self\n-pub enum TaskBuilder = {\n-    opts: TaskOpts,\n-    gen_body: fn@(v: fn~()) -> fn~(),\n-    can_not_copy: Option<util::NonCopyable>,\n-    mut consumed: bool,\n-};\n-\n-/**\n- * Generate the base configuration for spawning a task, off of which more\n- * configuration methods can be chained.\n- * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n- */\n-pub fn task() -> TaskBuilder {\n-    TaskBuilder({\n-        opts: default_task_opts(),\n-        gen_body: |body| move body, // Identity function\n-        can_not_copy: None,\n-        mut consumed: false,\n-    })\n-}\n-\n-#[doc(hidden)] // FIXME #3538\n-priv impl TaskBuilder {\n-    fn consume() -> TaskBuilder {\n-        if self.consumed {\n-            fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n-        }\n-        self.consumed = true;\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n-                sched: self.opts.sched\n-            },\n-            gen_body: self.gen_body,\n-            can_not_copy: None,\n-            mut consumed: false\n-        })\n-    }\n-}\n-\n-impl TaskBuilder {\n-    /**\n-     * Decouple the child task's failure from the parent's. If either fails,\n-     * the other will not be killed.\n-     */\n-    fn unlinked() -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: false,\n-                supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-    /**\n-     * Unidirectionally link the child task's failure with the parent's. The\n-     * child's failure will not kill the parent, but the parent's will kill\n-     * the child.\n-     */\n-    fn supervised() -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: false,\n-                supervised: true,\n-                mut notify_chan: move notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-    /**\n-     * Link the child task's and parent task's failures. If either fails, the\n-     * other will be killed.\n-     */\n-    fn linked() -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: true,\n-                supervised: false,\n-                mut notify_chan: move notify_chan,\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-\n-    /**\n-     * Get a future representing the exit status of the task.\n-     *\n-     * Taking the value of the future will block until the child task\n-     * terminates. The future-receiving callback specified will be called\n-     * *before* the task is spawned; as such, do not invoke .get() within the\n-     * closure; rather, store it in an outer variable/list for later use.\n-     *\n-     * Note that the future returning by this function is only useful for\n-     * obtaining the value of the next task to be spawning with the\n-     * builder. If additional tasks are spawned with the same builder\n-     * then a new result future must be obtained prior to spawning each\n-     * task.\n-     *\n-     * # Failure\n-     * Fails if a future_result was already set for this task.\n-     */\n-    fn future_result(blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n-        // FIXME (#3725): Once linked failure and notification are\n-        // handled in the library, I can imagine implementing this by just\n-        // registering an arbitrary number of task::on_exit handlers and\n-        // sending out messages.\n-\n-        if self.opts.notify_chan.is_some() {\n-            fail ~\"Can't set multiple future_results for one task!\";\n-        }\n-\n-        // Construct the future and give it to the caller.\n-        let (notify_pipe_ch, notify_pipe_po) = stream::<TaskResult>();\n-\n-        blk(move notify_pipe_po);\n-\n-        // Reconfigure self to use a notify channel.\n-        TaskBuilder({\n-            opts: {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                mut notify_chan: Some(move notify_pipe_ch),\n-                sched: self.opts.sched\n-            },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-    /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(mode: SchedMode) -> TaskBuilder {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n-                sched: Some({ mode: mode, foreign_stack_size: None})\n-            },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-\n-    /**\n-     * Add a wrapper to the body of the spawned task.\n-     *\n-     * Before the task is spawned it is passed through a 'body generator'\n-     * function that may perform local setup operations as well as wrap\n-     * the task body in remote setup operations. With this the behavior\n-     * of tasks can be extended in simple ways.\n-     *\n-     * This function augments the current body generator with a new body\n-     * generator by applying the task body which results from the\n-     * existing body generator to the new body generator.\n-     */\n-    fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder {\n-        let prev_gen_body = self.gen_body;\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        TaskBuilder({\n-            opts: {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n-                sched: self.opts.sched\n-            },\n-            // tjc: I think this is the line that gets miscompiled\n-            // w/ last-use off, if we leave out the move prev_gen_body?\n-            // that makes no sense, though...\n-            gen_body: |move prev_gen_body,\n-                       body| { wrapper(prev_gen_body(move body)) },\n-            can_not_copy: None,\n-            .. *self.consume()\n-        })\n-    }\n-\n-    /**\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure. The task has the properties and behavior\n-     * specified by the task_builder.\n-     *\n-     * # Failure\n-     *\n-     * When spawning into a new scheduler, the number of threads requested\n-     * must be greater than zero.\n-     */\n-    fn spawn(f: fn~()) {\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n-        let x = self.consume();\n-        let opts = {\n-            linked: x.opts.linked,\n-            supervised: x.opts.supervised,\n-            mut notify_chan: move notify_chan,\n-            sched: x.opts.sched\n-        };\n-        spawn::spawn_raw(move opts, x.gen_body(move f));\n-    }\n-    /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {\n-        let arg = ~mut Some(move arg);\n-        do self.spawn |move arg, move f| {\n-            f(option::swap_unwrap(arg))\n-        }\n-    }\n-\n-    /**\n-     * Runs a new task while providing a channel from the parent to the child\n-     *\n-     * Sets up a communication channel from the current task to the new\n-     * child task, passes the port to child's body, and returns a channel\n-     * linked to the port to the parent.\n-     *\n-     * This encapsulates some boilerplate handshaking logic that would\n-     * otherwise be required to establish communication from the parent\n-     * to the child.\n-     */\n-    fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-        let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(&setup_po);\n-        do self.spawn |move f| {\n-            let po = comm::Port();\n-            let ch = comm::Chan(&po);\n-            comm::send(setup_ch, ch);\n-            f(move po);\n-        }\n-        comm::recv(setup_po)\n-    }\n-\n-    /**\n-     * Runs a new task, setting up communication in both directions\n-     */\n-    fn spawn_conversation<A: Send, B: Send>\n-        (f: fn~(comm::Port<A>, comm::Chan<B>))\n-        -> (comm::Port<B>, comm::Chan<A>) {\n-        let from_child = comm::Port();\n-        let to_parent = comm::Chan(&from_child);\n-        let to_child = do self.spawn_listener |move f, from_parent| {\n-            f(from_parent, to_parent)\n-        };\n-        (from_child, to_child)\n-    }\n-\n-    /**\n-     * Execute a function in another task and return either the return value\n-     * of the function or result::err.\n-     *\n-     * # Return value\n-     *\n-     * If the function executed successfully then try returns result::ok\n-     * containing the value returned by the function. If the function fails\n-     * then try returns result::err containing nil.\n-     *\n-     * # Failure\n-     * Fails if a future_result was already set for this task.\n-     */\n-    fn try<T: Send>(f: fn~() -> T) -> Result<T,()> {\n-        let po = comm::Port();\n-        let ch = comm::Chan(&po);\n-        let mut result = None;\n-\n-        let fr_task_builder = self.future_result(|+r| {\n-            result = Some(move r);\n-        });\n-        do fr_task_builder.spawn |move f| {\n-            comm::send(ch, f());\n-        }\n-        match option::unwrap(move result).recv() {\n-            Success => result::Ok(comm::recv(po)),\n-            Failure => result::Err(())\n-        }\n-    }\n-}\n-\n-\n-/* Task construction */\n-\n-pub fn default_task_opts() -> TaskOpts {\n-    /*!\n-     * The default task options\n-     *\n-     * By default all tasks are supervised by their parent, are spawned\n-     * into the same scheduler, and do not post lifecycle notifications.\n-     */\n-\n-    {\n-        linked: true,\n-        supervised: false,\n-        mut notify_chan: None,\n-        sched: None\n-    }\n-}\n-\n-/* Spawn convenience functions */\n-\n-pub fn spawn(f: fn~()) {\n-    /*!\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure.\n-     *\n-     * This function is equivalent to `task().spawn(f)`.\n-     */\n-\n-    task().spawn(move f)\n-}\n-\n-pub fn spawn_unlinked(f: fn~()) {\n-    /*!\n-     * Creates a child task unlinked from the current one. If either this\n-     * task or the child task fails, the other will not be killed.\n-     */\n-\n-    task().unlinked().spawn(move f)\n-}\n-\n-pub fn spawn_supervised(f: fn~()) {\n-    /*!\n-     * Creates a child task unlinked from the current one. If either this\n-     * task or the child task fails, the other will not be killed.\n-     */\n-\n-    task().supervised().spawn(move f)\n-}\n-\n-pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n-    /*!\n-     * Runs a task, while transfering ownership of one argument to the\n-     * child.\n-     *\n-     * This is useful for transfering ownership of noncopyables to\n-     * another task.\n-     *\n-     * This function is equivalent to `task().spawn_with(arg, f)`.\n-     */\n-\n-    task().spawn_with(move arg, move f)\n-}\n-\n-pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-    /*!\n-     * Runs a new task while providing a channel from the parent to the child\n-     *\n-     * This function is equivalent to `task().spawn_listener(f)`.\n-     */\n-\n-    task().spawn_listener(move f)\n-}\n-\n-pub fn spawn_conversation<A: Send, B: Send>\n-    (f: fn~(comm::Port<A>, comm::Chan<B>))\n-    -> (comm::Port<B>, comm::Chan<A>) {\n-    /*!\n-     * Runs a new task, setting up communication in both directions\n-     *\n-     * This function is equivalent to `task().spawn_conversation(f)`.\n-     */\n-\n-    task().spawn_conversation(move f)\n-}\n-\n-pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n-    /*!\n-     * Creates a new scheduler and executes a task on it\n-     *\n-     * Tasks subsequently spawned by that task will also execute on\n-     * the new scheduler. When there are no more tasks to execute the\n-     * scheduler terminates.\n-     *\n-     * # Failure\n-     *\n-     * In manual threads mode the number of threads requested must be\n-     * greater than zero.\n-     */\n-\n-    task().sched_mode(mode).spawn(move f)\n-}\n-\n-pub fn try<T:Send>(f: fn~() -> T) -> Result<T,()> {\n-    /*!\n-     * Execute a function in another task and return either the return value\n-     * of the function or result::err.\n-     *\n-     * This is equivalent to task().supervised().try.\n-     */\n-\n-    task().supervised().try(move f)\n-}\n-\n-\n-/* Lifecycle functions */\n-\n-pub fn yield() {\n-    //! Yield control to the task scheduler\n-\n-    let task_ = rt::rust_get_task();\n-    let killed = rt::rust_task_yield(task_);\n-    if killed && !failing() {\n-        fail ~\"killed\";\n-    }\n-}\n-\n-pub fn failing() -> bool {\n-    //! True if the running task has failed\n-\n-    rt::rust_task_is_unwinding(rt::rust_get_task())\n-}\n-\n-pub fn get_task() -> Task {\n-    //! Get a handle to the running task\n-\n-    TaskHandle(rt::get_task_id())\n-}\n-\n-/**\n- * Temporarily make the task unkillable\n- *\n- * # Example\n- *\n- * ~~~\n- * do task::unkillable {\n- *     // detach / yield / destroy must all be called together\n- *     rustrt::rust_port_detach(po);\n- *     // This must not result in the current task being killed\n- *     task::yield();\n- *     rustrt::rust_port_destroy(po);\n- * }\n- * ~~~\n- */\n-pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n-    struct AllowFailure {\n-        t: *rust_task,\n-        drop { rt::rust_task_allow_kill(self.t); }\n-    }\n-\n-    fn AllowFailure(t: *rust_task) -> AllowFailure{\n-        AllowFailure {\n-            t: t\n-        }\n-    }\n-\n-    let t = rt::rust_get_task();\n-    let _allow_failure = AllowFailure(t);\n-    rt::rust_task_inhibit_kill(t);\n-    f()\n-}\n-\n-/// The inverse of unkillable. Only ever to be used nested in unkillable().\n-pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n-    struct DisallowFailure {\n-        t: *rust_task,\n-        drop { rt::rust_task_inhibit_kill(self.t); }\n-    }\n-\n-    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n-        DisallowFailure {\n-            t: t\n-        }\n-    }\n-\n-    let t = rt::rust_get_task();\n-    let _allow_failure = DisallowFailure(t);\n-    rt::rust_task_allow_kill(t);\n-    f()\n-}\n-\n-/**\n- * A stronger version of unkillable that also inhibits scheduling operations.\n- * For use with exclusive ARCs, which use pthread mutexes directly.\n- */\n-pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n-    struct DeferInterrupts {\n-        t: *rust_task,\n-        drop {\n-            rt::rust_task_allow_yield(self.t);\n-            rt::rust_task_allow_kill(self.t);\n-        }\n-    }\n-\n-    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n-        DeferInterrupts {\n-            t: t\n-        }\n-    }\n-\n-    let t = rt::rust_get_task();\n-    let _interrupts = DeferInterrupts(t);\n-    rt::rust_task_inhibit_kill(t);\n-    rt::rust_task_inhibit_yield(t);\n-    f()\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_cant_dup_task_builder() {\n-    let b = task().unlinked();\n-    do b.spawn { }\n-    // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n-    // got move mode on self. When 3724 is fixed, this test should fail to\n-    // compile instead, and should go in tests/compile-fail.\n-    do b.spawn { } // b should have been consumed by the previous call\n-}\n-\n-// The following 8 tests test the following 2^3 combinations:\n-// {un,}linked {un,}supervised failure propagation {up,down}wards.\n-\n-// !!! These tests are dangerous. If Something is buggy, they will hang, !!!\n-// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n-\n-#[test] #[ignore(cfg(windows))]\n-fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    do spawn_unlinked {\n-        do spawn_unlinked {\n-            // Give middle task a chance to fail-but-not-kill-us.\n-            for iter::repeat(16) { task::yield(); }\n-            comm::send(ch, ()); // If killed first, grandparent hangs.\n-        }\n-        fail; // Shouldn't kill either (grand)parent or (grand)child.\n-    }\n-    comm::recv(po);\n-}\n-#[test] #[ignore(cfg(windows))]\n-fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    do spawn_unlinked { fail; }\n-}\n-#[test] #[ignore(cfg(windows))]\n-fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    do spawn_supervised { fail; }\n-    // Give child a chance to fail-but-not-kill-us.\n-    for iter::repeat(16) { task::yield(); }\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_unlinked_sup_fail_down() {\n-    do spawn_supervised { loop { task::yield(); } }\n-    fail; // Shouldn't leave a child hanging around.\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    let po = comm::Port::<()>();\n-    let _ch = comm::Chan(&po);\n-    // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        move opts\n-    };\n-\n-    let b0 = task();\n-    let b1 = TaskBuilder({\n-        opts: move opts,\n-        can_not_copy: None,\n-        .. *b0\n-    });\n-    do b1.spawn { fail; }\n-    comm::recv(po); // We should get punted awake\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        move opts\n-    };\n-\n-    let b0 = task();\n-    let b1 = TaskBuilder({\n-        opts: move opts,\n-        can_not_copy: None,\n-        .. *b0\n-    });\n-    do b1.spawn { loop { task::yield(); } }\n-    fail; // *both* mechanisms would be wrong if this didn't kill the child...\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    let po = comm::Port::<()>();\n-    let _ch = comm::Chan(&po);\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { fail; }\n-    comm::recv(po); // We should get punted awake\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { loop { task::yield(); } }\n-    fail;\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n-    // Make sure the above test is the same as this one.\n-    do task().linked().spawn { loop { task::yield(); } }\n-    fail;\n-}\n-\n-// A couple bonus linked failure tests - testing for failure propagation even\n-// when the middle task exits successfully early before kill signals are sent.\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_failure_propagate_grandchild() {\n-    // Middle task exits; does grandparent's failure propagate across the gap?\n-    do spawn_supervised {\n-        do spawn_supervised {\n-            loop { task::yield(); }\n-        }\n-    }\n-    for iter::repeat(16) { task::yield(); }\n-    fail;\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_failure_propagate_secondborn() {\n-    // First-born child exits; does parent's failure propagate to sibling?\n-    do spawn_supervised {\n-        do spawn { // linked\n-            loop { task::yield(); }\n-        }\n-    }\n-    for iter::repeat(16) { task::yield(); }\n-    fail;\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_failure_propagate_nephew_or_niece() {\n-    // Our sibling exits; does our failure propagate to sibling's child?\n-    do spawn { // linked\n-        do spawn_supervised {\n-            loop { task::yield(); }\n-        }\n-    }\n-    for iter::repeat(16) { task::yield(); }\n-    fail;\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_spawn_linked_sup_propagate_sibling() {\n-    // Middle sibling exits - does eldest's failure propagate to youngest?\n-    do spawn { // linked\n-        do spawn { // linked\n-            loop { task::yield(); }\n-        }\n-    }\n-    for iter::repeat(16) { task::yield(); }\n-    fail;\n-}\n-\n-#[test]\n-fn test_run_basic() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    do task().spawn {\n-        comm::send(ch, ());\n-    }\n-    comm::recv(po);\n-}\n-\n-#[test]\n-fn test_add_wrapper() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    let b0 = task();\n-    let b1 = do b0.add_wrapper |body| {\n-        fn~(move body) {\n-            body();\n-            comm::send(ch, ());\n-        }\n-    };\n-    do b1.spawn { }\n-    comm::recv(po);\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_future_result() {\n-    let mut result = None;\n-    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n-    assert option::unwrap(move result).recv() == Success;\n-\n-    result = None;\n-    do task().future_result(|+r|\n-        { result = Some(move r); }).unlinked().spawn {\n-        fail;\n-    }\n-    assert option::unwrap(move result).recv() == Failure;\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_back_to_the_future_result() {\n-    let _ = task().future_result(util::ignore).future_result(util::ignore);\n-}\n-\n-#[test]\n-fn test_spawn_listiner_bidi() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    let ch = do spawn_listener |po| {\n-        // Now the child has a port called 'po' to read from and\n-        // an environment-captured channel called 'ch'.\n-        let res: ~str = comm::recv(po);\n-        assert res == ~\"ping\";\n-        comm::send(ch, ~\"pong\");\n-    };\n-    // Likewise, the parent has both a 'po' and 'ch'\n-    comm::send(ch, ~\"ping\");\n-    let res: ~str = comm::recv(po);\n-    assert res == ~\"pong\";\n-}\n-\n-#[test]\n-fn test_spawn_conversation() {\n-    let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n-        let input = comm::recv(recv_int);\n-        let output = int::str(input);\n-        comm::send(send_str, move output);\n-    };\n-    comm::send(send_int, 1);\n-    assert comm::recv(recv_str) == ~\"1\";\n-}\n-\n-#[test]\n-fn test_try_success() {\n-    match do try {\n-        ~\"Success!\"\n-    } {\n-        result::Ok(~\"Success!\") => (),\n-        _ => fail\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_try_fail() {\n-    match do try {\n-        fail\n-    } {\n-        result::Err(()) => (),\n-        result::Ok(()) => fail\n-    }\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_spawn_sched_no_threads() {\n-    do spawn_sched(ManualThreads(0u)) { }\n-}\n-\n-#[test]\n-fn test_spawn_sched() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-\n-    fn f(i: int, ch: comm::Chan<()>) {\n-        let parent_sched_id = rt::rust_get_sched_id();\n-\n-        do spawn_sched(SingleThreaded) {\n-            let child_sched_id = rt::rust_get_sched_id();\n-            assert parent_sched_id != child_sched_id;\n-\n-            if (i == 0) {\n-                comm::send(ch, ());\n-            } else {\n-                f(i - 1, ch);\n-            }\n-        };\n-\n-    }\n-    f(10, ch);\n-    comm::recv(po);\n-}\n-\n-#[test]\n-fn test_spawn_sched_childs_on_same_sched() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-\n-    do spawn_sched(SingleThreaded) {\n-        let parent_sched_id = rt::rust_get_sched_id();\n-        do spawn {\n-            let child_sched_id = rt::rust_get_sched_id();\n-            // This should be on the same scheduler\n-            assert parent_sched_id == child_sched_id;\n-            comm::send(ch, ());\n-        };\n-    };\n-\n-    comm::recv(po);\n-}\n-\n-#[nolink]\n-#[cfg(test)]\n-extern mod testrt {\n-    fn rust_dbg_lock_create() -> *libc::c_void;\n-    fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-    fn rust_dbg_lock_lock(lock: *libc::c_void);\n-    fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-    fn rust_dbg_lock_wait(lock: *libc::c_void);\n-    fn rust_dbg_lock_signal(lock: *libc::c_void);\n-}\n-\n-#[test]\n-fn test_spawn_sched_blocking() {\n-\n-    // Testing that a task in one scheduler can block in foreign code\n-    // without affecting other schedulers\n-    for iter::repeat(20u) {\n-\n-        let start_po = comm::Port();\n-        let start_ch = comm::Chan(&start_po);\n-        let fin_po = comm::Port();\n-        let fin_ch = comm::Chan(&fin_po);\n-\n-        let lock = testrt::rust_dbg_lock_create();\n-\n-        do spawn_sched(SingleThreaded) {\n-            testrt::rust_dbg_lock_lock(lock);\n-\n-            comm::send(start_ch, ());\n-\n-            // Block the scheduler thread\n-            testrt::rust_dbg_lock_wait(lock);\n-            testrt::rust_dbg_lock_unlock(lock);\n-\n-            comm::send(fin_ch, ());\n-        };\n-\n-        // Wait until the other task has its lock\n-        comm::recv(start_po);\n-\n-        fn pingpong(po: comm::Port<int>, ch: comm::Chan<int>) {\n-            let mut val = 20;\n-            while val > 0 {\n-                val = comm::recv(po);\n-                comm::send(ch, val - 1);\n-            }\n-        }\n-\n-        let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(&setup_po);\n-        let parent_po = comm::Port();\n-        let parent_ch = comm::Chan(&parent_po);\n-        do spawn {\n-            let child_po = comm::Port();\n-            comm::send(setup_ch, comm::Chan(&child_po));\n-            pingpong(child_po, parent_ch);\n-        };\n-\n-        let child_ch = comm::recv(setup_po);\n-        comm::send(child_ch, 20);\n-        pingpong(parent_po, child_ch);\n-        testrt::rust_dbg_lock_lock(lock);\n-        testrt::rust_dbg_lock_signal(lock);\n-        testrt::rust_dbg_lock_unlock(lock);\n-        comm::recv(fin_po);\n-        testrt::rust_dbg_lock_destroy(lock);\n-    }\n-}\n-\n-#[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n-    let p = comm::Port::<uint>();\n-    let ch = comm::Chan(&p);\n-\n-    let x = ~1;\n-    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n-\n-    do spawnfn |move x| {\n-        let x_in_child = ptr::addr_of(&(*x)) as uint;\n-        comm::send(ch, x_in_child);\n-    }\n-\n-    let x_in_child = comm::recv(p);\n-    assert x_in_parent == x_in_child;\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_spawn() {\n-    avoid_copying_the_body(spawn);\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |f| {\n-        spawn_listener(fn~(move f, _po: comm::Port<int>) {\n-            f();\n-        });\n-    }\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_task_spawn() {\n-    do avoid_copying_the_body |f| {\n-        do task().spawn |move f| {\n-            f();\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |f| {\n-        task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n-            f();\n-        });\n-    }\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_try() {\n-    do avoid_copying_the_body |f| {\n-        do try |move f| {\n-            f()\n-        };\n-    }\n-}\n-\n-#[test]\n-fn test_avoid_copying_the_body_unlinked() {\n-    do avoid_copying_the_body |f| {\n-        do spawn_unlinked |move f| {\n-            f();\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_platform_thread() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    do task().sched_mode(PlatformThread).spawn {\n-        comm::send(ch, ());\n-    }\n-    comm::recv(po);\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-#[should_fail]\n-fn test_unkillable() {\n-    let po = comm::Port();\n-    let ch = po.chan();\n-\n-    // We want to do this after failing\n-    do spawn_unlinked {\n-        for iter::repeat(10) { yield() }\n-        ch.send(());\n-    }\n-\n-    do spawn {\n-        yield();\n-        // We want to fail after the unkillable task\n-        // blocks on recv\n-        fail;\n-    }\n-\n-    unsafe {\n-        do unkillable {\n-            let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n-\n-            // If we are killed here then the box will leak\n-            po.recv();\n-\n-            let _p: ~int = cast::transmute(move pp);\n-        }\n-    }\n-\n-    // Now we can be killed\n-    po.recv();\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-#[should_fail]\n-fn test_unkillable_nested() {\n-    let (ch, po) = pipes::stream();\n-\n-    // We want to do this after failing\n-    do spawn_unlinked |move ch| {\n-        for iter::repeat(10) { yield() }\n-        ch.send(());\n-    }\n-\n-    do spawn {\n-        yield();\n-        // We want to fail after the unkillable task\n-        // blocks on recv\n-        fail;\n-    }\n-\n-    unsafe {\n-        do unkillable {\n-            do unkillable {} // Here's the difference from the previous test.\n-            let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n-\n-            // If we are killed here then the box will leak\n-            po.recv();\n-\n-            let _p: ~int = cast::transmute(move pp);\n-        }\n-    }\n-\n-    // Now we can be killed\n-    po.recv();\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically() {\n-    unsafe { do atomically { yield(); } }\n-}\n-\n-#[test]\n-fn test_atomically2() {\n-    unsafe { do atomically { } } yield(); // shouldn't fail\n-}\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_atomically_nested() {\n-    unsafe { do atomically { do atomically { } yield(); } }\n-}\n-\n-#[test]\n-fn test_child_doesnt_ref_parent() {\n-    // If the child refcounts the parent task, this will stack overflow when\n-    // climbing the task tree to dereference each ancestor. (See #1789)\n-    // (well, it would if the constant were 8000+ - I lowered it to be more\n-    // valgrind-friendly. try this at home, instead..!)\n-    const generations: uint = 16;\n-    fn child_no(x: uint) -> fn~() {\n-        return || {\n-            if x < generations {\n-                task::spawn(child_no(x+1));\n-            }\n-        }\n-    }\n-    task::spawn(child_no(0));\n-}\n-\n-#[test]\n-fn test_sched_thread_per_core() {\n-    let (chan, port) = pipes::stream();\n-\n-    do spawn_sched(ThreadPerCore) |move chan| {\n-        let cores = rt::rust_num_threads();\n-        let reported_threads = rt::rust_sched_threads();\n-        assert(cores as uint == reported_threads as uint);\n-        chan.send(());\n-    }\n-\n-    port.recv();\n-}\n-\n-#[test]\n-fn test_spawn_thread_on_demand() {\n-    let (chan, port) = pipes::stream();\n-\n-    do spawn_sched(ManualThreads(2)) |move chan| {\n-        let max_threads = rt::rust_sched_threads();\n-        assert(max_threads as int == 2);\n-        let running_threads = rt::rust_sched_current_nonlazy_threads();\n-        assert(running_threads as int == 1);\n-\n-        let (chan2, port2) = pipes::stream();\n-\n-        do spawn() |move chan2| {\n-            chan2.send(());\n-        }\n-\n-        let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-        assert(running_threads2 as int == 2);\n-\n-        port2.recv();\n-        chan.send(());\n-    }\n-\n-    port.recv();\n-}"}, {"sha": "9078104427712b9e5c502ddb5f15a1f9971eb493", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1301, "deletions": 3, "changes": 1304, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,8 +1,1306 @@\n+// NB: transitionary, de-mode-ing.\n+// tjc: Deprecated modes allowed because of function arg issue\n+// in task::spawn. Re-forbid after snapshot.\n+#[forbid(deprecated_pattern)];\n \n-mod local_data_priv;\n+/*!\n+ * Task management.\n+ *\n+ * An executing Rust program consists of a tree of tasks, each with their own\n+ * stack, and sole ownership of their allocated heap data. Tasks communicate\n+ * with each other using ports and channels.\n+ *\n+ * When a task fails, that failure will propagate to its parent (the task\n+ * that spawned it) and the parent will fail as well. The reverse is not\n+ * true: when a parent task fails its children will continue executing. When\n+ * the root (main) task fails, all tasks fail, and then so does the entire\n+ * process.\n+ *\n+ * Tasks may execute in parallel and are scheduled automatically by the\n+ * runtime.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * do spawn {\n+ *     log(error, \"Hello, World!\");\n+ * }\n+ * ~~~\n+ */\n \n-pub mod local_data;\n+use cmp::Eq;\n+use result::Result;\n+use pipes::{stream, Chan, Port};\n+use local_data_priv::{local_get, local_set};\n+use util::replace;\n \n-pub mod rt;\n+use rt::task_id;\n+use rt::rust_task;\n \n+mod local_data_priv;\n+pub mod local_data;\n+pub mod rt;\n pub mod spawn;\n+\n+/// A handle to a task\n+pub enum Task {\n+    TaskHandle(task_id)\n+}\n+\n+impl Task : cmp::Eq {\n+    pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n+    pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }\n+}\n+\n+/**\n+ * Indicates the manner in which a task exited.\n+ *\n+ * A task that completes without failing is considered to exit successfully.\n+ * Supervised ancestors and linked siblings may yet fail after this task\n+ * succeeds. Also note that in such a case, it may be nondeterministic whether\n+ * linked failure or successful exit happen first.\n+ *\n+ * If you wish for this result's delivery to block until all linked and/or\n+ * children tasks complete, recommend using a result future.\n+ */\n+pub enum TaskResult {\n+    Success,\n+    Failure,\n+}\n+\n+impl TaskResult : Eq {\n+    pure fn eq(&self, other: &TaskResult) -> bool {\n+        match ((*self), (*other)) {\n+            (Success, Success) | (Failure, Failure) => true,\n+            (Success, _) | (Failure, _) => false\n+        }\n+    }\n+    pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n+}\n+\n+/// Scheduler modes\n+pub enum SchedMode {\n+    /// All tasks run in the same OS thread\n+    SingleThreaded,\n+    /// Tasks are distributed among available CPUs\n+    ThreadPerCore,\n+    /// Each task runs in its own OS thread\n+    ThreadPerTask,\n+    /// Tasks are distributed among a fixed number of OS threads\n+    ManualThreads(uint),\n+    /**\n+     * Tasks are scheduled on the main OS thread\n+     *\n+     * The main OS thread is the thread used to launch the runtime which,\n+     * in most cases, is the process's initial thread as created by the OS.\n+     */\n+    PlatformThread\n+}\n+\n+impl SchedMode : cmp::Eq {\n+    pure fn eq(&self, other: &SchedMode) -> bool {\n+        match (*self) {\n+            SingleThreaded => {\n+                match (*other) {\n+                    SingleThreaded => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerCore => {\n+                match (*other) {\n+                    ThreadPerCore => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerTask => {\n+                match (*other) {\n+                    ThreadPerTask => true,\n+                    _ => false\n+                }\n+            }\n+            ManualThreads(e0a) => {\n+                match (*other) {\n+                    ManualThreads(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            PlatformThread => {\n+                match (*other) {\n+                    PlatformThread => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&self, other: &SchedMode) -> bool {\n+        !(*self).eq(other)\n+    }\n+}\n+\n+/**\n+ * Scheduler configuration options\n+ *\n+ * # Fields\n+ *\n+ * * sched_mode - The operating mode of the scheduler\n+ *\n+ * * foreign_stack_size - The size of the foreign stack, in bytes\n+ *\n+ *     Rust code runs on Rust-specific stacks. When Rust code calls foreign\n+ *     code (via functions in foreign modules) it switches to a typical, large\n+ *     stack appropriate for running code written in languages like C. By\n+ *     default these foreign stacks have unspecified size, but with this\n+ *     option their size can be precisely specified.\n+ */\n+pub type SchedOpts = {\n+    mode: SchedMode,\n+    foreign_stack_size: Option<uint>\n+};\n+\n+/**\n+ * Task configuration options\n+ *\n+ * # Fields\n+ *\n+ * * linked - Propagate failure bidirectionally between child and parent.\n+ *            True by default. If both this and 'supervised' are false, then\n+ *            either task's failure will not affect the other (\"unlinked\").\n+ *\n+ * * supervised - Propagate failure unidirectionally from parent to child,\n+ *                but not from child to parent. False by default.\n+ *\n+ * * notify_chan - Enable lifecycle notifications on the given channel\n+ *\n+ * * sched - Specify the configuration of a new scheduler to create the task\n+ *           in\n+ *\n+ *     By default, every task is created in the same scheduler as its\n+ *     parent, where it is scheduled cooperatively with all other tasks\n+ *     in that scheduler. Some specialized applications may want more\n+ *     control over their scheduling, in which case they can be spawned\n+ *     into a new scheduler with the specific properties required.\n+ *\n+ *     This is of particular importance for libraries which want to call\n+ *     into foreign code that blocks. Without doing so in a different\n+ *     scheduler other tasks will be impeded or even blocked indefinitely.\n+ */\n+pub type TaskOpts = {\n+    linked: bool,\n+    supervised: bool,\n+    mut notify_chan: Option<Chan<TaskResult>>,\n+    sched: Option<SchedOpts>,\n+};\n+\n+/**\n+ * The task builder type.\n+ *\n+ * Provides detailed control over the properties and behavior of new tasks.\n+ */\n+// NB: Builders are designed to be single-use because they do stateful\n+// things that get weird when reusing - e.g. if you create a result future\n+// it only applies to a single task, so then you have to maintain Some\n+// potentially tricky state to ensure that everything behaves correctly\n+// when you try to reuse the builder to spawn a new task. We'll just\n+// sidestep that whole issue by making builders uncopyable and making\n+// the run function move them in.\n+\n+// FIXME (#3724): Replace the 'consumed' bit with move mode on self\n+pub enum TaskBuilder = {\n+    opts: TaskOpts,\n+    gen_body: fn@(v: fn~()) -> fn~(),\n+    can_not_copy: Option<util::NonCopyable>,\n+    mut consumed: bool,\n+};\n+\n+/**\n+ * Generate the base configuration for spawning a task, off of which more\n+ * configuration methods can be chained.\n+ * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n+ */\n+pub fn task() -> TaskBuilder {\n+    TaskBuilder({\n+        opts: default_task_opts(),\n+        gen_body: |body| move body, // Identity function\n+        can_not_copy: None,\n+        mut consumed: false,\n+    })\n+}\n+\n+#[doc(hidden)] // FIXME #3538\n+priv impl TaskBuilder {\n+    fn consume() -> TaskBuilder {\n+        if self.consumed {\n+            fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n+        }\n+        self.consumed = true;\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: move notify_chan,\n+                sched: self.opts.sched\n+            },\n+            gen_body: self.gen_body,\n+            can_not_copy: None,\n+            mut consumed: false\n+        })\n+    }\n+}\n+\n+impl TaskBuilder {\n+    /**\n+     * Decouple the child task's failure from the parent's. If either fails,\n+     * the other will not be killed.\n+     */\n+    fn unlinked() -> TaskBuilder {\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: false,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: move notify_chan,\n+                sched: self.opts.sched\n+            },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+    /**\n+     * Unidirectionally link the child task's failure with the parent's. The\n+     * child's failure will not kill the parent, but the parent's will kill\n+     * the child.\n+     */\n+    fn supervised() -> TaskBuilder {\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: false,\n+                supervised: true,\n+                mut notify_chan: move notify_chan,\n+                sched: self.opts.sched\n+            },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+    /**\n+     * Link the child task's and parent task's failures. If either fails, the\n+     * other will be killed.\n+     */\n+    fn linked() -> TaskBuilder {\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: true,\n+                supervised: false,\n+                mut notify_chan: move notify_chan,\n+                sched: self.opts.sched\n+            },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+\n+    /**\n+     * Get a future representing the exit status of the task.\n+     *\n+     * Taking the value of the future will block until the child task\n+     * terminates. The future-receiving callback specified will be called\n+     * *before* the task is spawned; as such, do not invoke .get() within the\n+     * closure; rather, store it in an outer variable/list for later use.\n+     *\n+     * Note that the future returning by this function is only useful for\n+     * obtaining the value of the next task to be spawning with the\n+     * builder. If additional tasks are spawned with the same builder\n+     * then a new result future must be obtained prior to spawning each\n+     * task.\n+     *\n+     * # Failure\n+     * Fails if a future_result was already set for this task.\n+     */\n+    fn future_result(blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n+        // FIXME (#3725): Once linked failure and notification are\n+        // handled in the library, I can imagine implementing this by just\n+        // registering an arbitrary number of task::on_exit handlers and\n+        // sending out messages.\n+\n+        if self.opts.notify_chan.is_some() {\n+            fail ~\"Can't set multiple future_results for one task!\";\n+        }\n+\n+        // Construct the future and give it to the caller.\n+        let (notify_pipe_ch, notify_pipe_po) = stream::<TaskResult>();\n+\n+        blk(move notify_pipe_po);\n+\n+        // Reconfigure self to use a notify channel.\n+        TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: Some(move notify_pipe_ch),\n+                sched: self.opts.sched\n+            },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+    /// Configure a custom scheduler mode for the task.\n+    fn sched_mode(mode: SchedMode) -> TaskBuilder {\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: move notify_chan,\n+                sched: Some({ mode: mode, foreign_stack_size: None})\n+            },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+\n+    /**\n+     * Add a wrapper to the body of the spawned task.\n+     *\n+     * Before the task is spawned it is passed through a 'body generator'\n+     * function that may perform local setup operations as well as wrap\n+     * the task body in remote setup operations. With this the behavior\n+     * of tasks can be extended in simple ways.\n+     *\n+     * This function augments the current body generator with a new body\n+     * generator by applying the task body which results from the\n+     * existing body generator to the new body generator.\n+     */\n+    fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder {\n+        let prev_gen_body = self.gen_body;\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: move notify_chan,\n+                sched: self.opts.sched\n+            },\n+            // tjc: I think this is the line that gets miscompiled\n+            // w/ last-use off, if we leave out the move prev_gen_body?\n+            // that makes no sense, though...\n+            gen_body: |move prev_gen_body,\n+                       body| { wrapper(prev_gen_body(move body)) },\n+            can_not_copy: None,\n+            .. *self.consume()\n+        })\n+    }\n+\n+    /**\n+     * Creates and executes a new child task\n+     *\n+     * Sets up a new task with its own call stack and schedules it to run\n+     * the provided unique closure. The task has the properties and behavior\n+     * specified by the task_builder.\n+     *\n+     * # Failure\n+     *\n+     * When spawning into a new scheduler, the number of threads requested\n+     * must be greater than zero.\n+     */\n+    fn spawn(f: fn~()) {\n+        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        let x = self.consume();\n+        let opts = {\n+            linked: x.opts.linked,\n+            supervised: x.opts.supervised,\n+            mut notify_chan: move notify_chan,\n+            sched: x.opts.sched\n+        };\n+        spawn::spawn_raw(move opts, x.gen_body(move f));\n+    }\n+    /// Runs a task, while transfering ownership of one argument to the child.\n+    fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {\n+        let arg = ~mut Some(move arg);\n+        do self.spawn |move arg, move f| {\n+            f(option::swap_unwrap(arg))\n+        }\n+    }\n+\n+    /**\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * Sets up a communication channel from the current task to the new\n+     * child task, passes the port to child's body, and returns a channel\n+     * linked to the port to the parent.\n+     *\n+     * This encapsulates some boilerplate handshaking logic that would\n+     * otherwise be required to establish communication from the parent\n+     * to the child.\n+     */\n+    fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+        let setup_po = comm::Port();\n+        let setup_ch = comm::Chan(&setup_po);\n+        do self.spawn |move f| {\n+            let po = comm::Port();\n+            let ch = comm::Chan(&po);\n+            comm::send(setup_ch, ch);\n+            f(move po);\n+        }\n+        comm::recv(setup_po)\n+    }\n+\n+    /**\n+     * Runs a new task, setting up communication in both directions\n+     */\n+    fn spawn_conversation<A: Send, B: Send>\n+        (f: fn~(comm::Port<A>, comm::Chan<B>))\n+        -> (comm::Port<B>, comm::Chan<A>) {\n+        let from_child = comm::Port();\n+        let to_parent = comm::Chan(&from_child);\n+        let to_child = do self.spawn_listener |move f, from_parent| {\n+            f(from_parent, to_parent)\n+        };\n+        (from_child, to_child)\n+    }\n+\n+    /**\n+     * Execute a function in another task and return either the return value\n+     * of the function or result::err.\n+     *\n+     * # Return value\n+     *\n+     * If the function executed successfully then try returns result::ok\n+     * containing the value returned by the function. If the function fails\n+     * then try returns result::err containing nil.\n+     *\n+     * # Failure\n+     * Fails if a future_result was already set for this task.\n+     */\n+    fn try<T: Send>(f: fn~() -> T) -> Result<T,()> {\n+        let po = comm::Port();\n+        let ch = comm::Chan(&po);\n+        let mut result = None;\n+\n+        let fr_task_builder = self.future_result(|+r| {\n+            result = Some(move r);\n+        });\n+        do fr_task_builder.spawn |move f| {\n+            comm::send(ch, f());\n+        }\n+        match option::unwrap(move result).recv() {\n+            Success => result::Ok(comm::recv(po)),\n+            Failure => result::Err(())\n+        }\n+    }\n+}\n+\n+\n+/* Task construction */\n+\n+pub fn default_task_opts() -> TaskOpts {\n+    /*!\n+     * The default task options\n+     *\n+     * By default all tasks are supervised by their parent, are spawned\n+     * into the same scheduler, and do not post lifecycle notifications.\n+     */\n+\n+    {\n+        linked: true,\n+        supervised: false,\n+        mut notify_chan: None,\n+        sched: None\n+    }\n+}\n+\n+/* Spawn convenience functions */\n+\n+pub fn spawn(f: fn~()) {\n+    /*!\n+     * Creates and executes a new child task\n+     *\n+     * Sets up a new task with its own call stack and schedules it to run\n+     * the provided unique closure.\n+     *\n+     * This function is equivalent to `task().spawn(f)`.\n+     */\n+\n+    task().spawn(move f)\n+}\n+\n+pub fn spawn_unlinked(f: fn~()) {\n+    /*!\n+     * Creates a child task unlinked from the current one. If either this\n+     * task or the child task fails, the other will not be killed.\n+     */\n+\n+    task().unlinked().spawn(move f)\n+}\n+\n+pub fn spawn_supervised(f: fn~()) {\n+    /*!\n+     * Creates a child task unlinked from the current one. If either this\n+     * task or the child task fails, the other will not be killed.\n+     */\n+\n+    task().supervised().spawn(move f)\n+}\n+\n+pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n+    /*!\n+     * Runs a task, while transfering ownership of one argument to the\n+     * child.\n+     *\n+     * This is useful for transfering ownership of noncopyables to\n+     * another task.\n+     *\n+     * This function is equivalent to `task().spawn_with(arg, f)`.\n+     */\n+\n+    task().spawn_with(move arg, move f)\n+}\n+\n+pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    /*!\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * This function is equivalent to `task().spawn_listener(f)`.\n+     */\n+\n+    task().spawn_listener(move f)\n+}\n+\n+pub fn spawn_conversation<A: Send, B: Send>\n+    (f: fn~(comm::Port<A>, comm::Chan<B>))\n+    -> (comm::Port<B>, comm::Chan<A>) {\n+    /*!\n+     * Runs a new task, setting up communication in both directions\n+     *\n+     * This function is equivalent to `task().spawn_conversation(f)`.\n+     */\n+\n+    task().spawn_conversation(move f)\n+}\n+\n+pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n+    /*!\n+     * Creates a new scheduler and executes a task on it\n+     *\n+     * Tasks subsequently spawned by that task will also execute on\n+     * the new scheduler. When there are no more tasks to execute the\n+     * scheduler terminates.\n+     *\n+     * # Failure\n+     *\n+     * In manual threads mode the number of threads requested must be\n+     * greater than zero.\n+     */\n+\n+    task().sched_mode(mode).spawn(move f)\n+}\n+\n+pub fn try<T:Send>(f: fn~() -> T) -> Result<T,()> {\n+    /*!\n+     * Execute a function in another task and return either the return value\n+     * of the function or result::err.\n+     *\n+     * This is equivalent to task().supervised().try.\n+     */\n+\n+    task().supervised().try(move f)\n+}\n+\n+\n+/* Lifecycle functions */\n+\n+pub fn yield() {\n+    //! Yield control to the task scheduler\n+\n+    let task_ = rt::rust_get_task();\n+    let killed = rt::rust_task_yield(task_);\n+    if killed && !failing() {\n+        fail ~\"killed\";\n+    }\n+}\n+\n+pub fn failing() -> bool {\n+    //! True if the running task has failed\n+\n+    rt::rust_task_is_unwinding(rt::rust_get_task())\n+}\n+\n+pub fn get_task() -> Task {\n+    //! Get a handle to the running task\n+\n+    TaskHandle(rt::get_task_id())\n+}\n+\n+/**\n+ * Temporarily make the task unkillable\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * do task::unkillable {\n+ *     // detach / yield / destroy must all be called together\n+ *     rustrt::rust_port_detach(po);\n+ *     // This must not result in the current task being killed\n+ *     task::yield();\n+ *     rustrt::rust_port_destroy(po);\n+ * }\n+ * ~~~\n+ */\n+pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n+    struct AllowFailure {\n+        t: *rust_task,\n+        drop { rt::rust_task_allow_kill(self.t); }\n+    }\n+\n+    fn AllowFailure(t: *rust_task) -> AllowFailure{\n+        AllowFailure {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = AllowFailure(t);\n+    rt::rust_task_inhibit_kill(t);\n+    f()\n+}\n+\n+/// The inverse of unkillable. Only ever to be used nested in unkillable().\n+pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n+    struct DisallowFailure {\n+        t: *rust_task,\n+        drop { rt::rust_task_inhibit_kill(self.t); }\n+    }\n+\n+    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n+        DisallowFailure {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = DisallowFailure(t);\n+    rt::rust_task_allow_kill(t);\n+    f()\n+}\n+\n+/**\n+ * A stronger version of unkillable that also inhibits scheduling operations.\n+ * For use with exclusive ARCs, which use pthread mutexes directly.\n+ */\n+pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n+    struct DeferInterrupts {\n+        t: *rust_task,\n+        drop {\n+            rt::rust_task_allow_yield(self.t);\n+            rt::rust_task_allow_kill(self.t);\n+        }\n+    }\n+\n+    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n+        DeferInterrupts {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _interrupts = DeferInterrupts(t);\n+    rt::rust_task_inhibit_kill(t);\n+    rt::rust_task_inhibit_yield(t);\n+    f()\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_cant_dup_task_builder() {\n+    let b = task().unlinked();\n+    do b.spawn { }\n+    // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n+    // got move mode on self. When 3724 is fixed, this test should fail to\n+    // compile instead, and should go in tests/compile-fail.\n+    do b.spawn { } // b should have been consumed by the previous call\n+}\n+\n+// The following 8 tests test the following 2^3 combinations:\n+// {un,}linked {un,}supervised failure propagation {up,down}wards.\n+\n+// !!! These tests are dangerous. If Something is buggy, they will hang, !!!\n+// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n+\n+#[test] #[ignore(cfg(windows))]\n+fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+    do spawn_unlinked {\n+        do spawn_unlinked {\n+            // Give middle task a chance to fail-but-not-kill-us.\n+            for iter::repeat(16) { task::yield(); }\n+            comm::send(ch, ()); // If killed first, grandparent hangs.\n+        }\n+        fail; // Shouldn't kill either (grand)parent or (grand)child.\n+    }\n+    comm::recv(po);\n+}\n+#[test] #[ignore(cfg(windows))]\n+fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n+    do spawn_unlinked { fail; }\n+}\n+#[test] #[ignore(cfg(windows))]\n+fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n+    do spawn_supervised { fail; }\n+    // Give child a chance to fail-but-not-kill-us.\n+    for iter::repeat(16) { task::yield(); }\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_unlinked_sup_fail_down() {\n+    do spawn_supervised { loop { task::yield(); } }\n+    fail; // Shouldn't leave a child hanging around.\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n+    let po = comm::Port::<()>();\n+    let _ch = comm::Chan(&po);\n+    // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n+    // We have to cheat with opts - the interface doesn't support them because\n+    // they don't make sense (redundant with task().supervised()).\n+    let opts = {\n+        let mut opts = default_task_opts();\n+        opts.linked = true;\n+        opts.supervised = true;\n+        move opts\n+    };\n+\n+    let b0 = task();\n+    let b1 = TaskBuilder({\n+        opts: move opts,\n+        can_not_copy: None,\n+        .. *b0\n+    });\n+    do b1.spawn { fail; }\n+    comm::recv(po); // We should get punted awake\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n+    // We have to cheat with opts - the interface doesn't support them because\n+    // they don't make sense (redundant with task().supervised()).\n+    let opts = {\n+        let mut opts = default_task_opts();\n+        opts.linked = true;\n+        opts.supervised = true;\n+        move opts\n+    };\n+\n+    let b0 = task();\n+    let b1 = TaskBuilder({\n+        opts: move opts,\n+        can_not_copy: None,\n+        .. *b0\n+    });\n+    do b1.spawn { loop { task::yield(); } }\n+    fail; // *both* mechanisms would be wrong if this didn't kill the child...\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n+    let po = comm::Port::<()>();\n+    let _ch = comm::Chan(&po);\n+    // Default options are to spawn linked & unsupervised.\n+    do spawn { fail; }\n+    comm::recv(po); // We should get punted awake\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n+    // Default options are to spawn linked & unsupervised.\n+    do spawn { loop { task::yield(); } }\n+    fail;\n+}\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n+    // Make sure the above test is the same as this one.\n+    do task().linked().spawn { loop { task::yield(); } }\n+    fail;\n+}\n+\n+// A couple bonus linked failure tests - testing for failure propagation even\n+// when the middle task exits successfully early before kill signals are sent.\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_failure_propagate_grandchild() {\n+    // Middle task exits; does grandparent's failure propagate across the gap?\n+    do spawn_supervised {\n+        do spawn_supervised {\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(16) { task::yield(); }\n+    fail;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_failure_propagate_secondborn() {\n+    // First-born child exits; does parent's failure propagate to sibling?\n+    do spawn_supervised {\n+        do spawn { // linked\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(16) { task::yield(); }\n+    fail;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_failure_propagate_nephew_or_niece() {\n+    // Our sibling exits; does our failure propagate to sibling's child?\n+    do spawn { // linked\n+        do spawn_supervised {\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(16) { task::yield(); }\n+    fail;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_spawn_linked_sup_propagate_sibling() {\n+    // Middle sibling exits - does eldest's failure propagate to youngest?\n+    do spawn { // linked\n+        do spawn { // linked\n+            loop { task::yield(); }\n+        }\n+    }\n+    for iter::repeat(16) { task::yield(); }\n+    fail;\n+}\n+\n+#[test]\n+fn test_run_basic() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+    do task().spawn {\n+        comm::send(ch, ());\n+    }\n+    comm::recv(po);\n+}\n+\n+#[test]\n+fn test_add_wrapper() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+    let b0 = task();\n+    let b1 = do b0.add_wrapper |body| {\n+        fn~(move body) {\n+            body();\n+            comm::send(ch, ());\n+        }\n+    };\n+    do b1.spawn { }\n+    comm::recv(po);\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+fn test_future_result() {\n+    let mut result = None;\n+    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n+    assert option::unwrap(move result).recv() == Success;\n+\n+    result = None;\n+    do task().future_result(|+r|\n+        { result = Some(move r); }).unlinked().spawn {\n+        fail;\n+    }\n+    assert option::unwrap(move result).recv() == Failure;\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_back_to_the_future_result() {\n+    let _ = task().future_result(util::ignore).future_result(util::ignore);\n+}\n+\n+#[test]\n+fn test_spawn_listiner_bidi() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+    let ch = do spawn_listener |po| {\n+        // Now the child has a port called 'po' to read from and\n+        // an environment-captured channel called 'ch'.\n+        let res: ~str = comm::recv(po);\n+        assert res == ~\"ping\";\n+        comm::send(ch, ~\"pong\");\n+    };\n+    // Likewise, the parent has both a 'po' and 'ch'\n+    comm::send(ch, ~\"ping\");\n+    let res: ~str = comm::recv(po);\n+    assert res == ~\"pong\";\n+}\n+\n+#[test]\n+fn test_spawn_conversation() {\n+    let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n+        let input = comm::recv(recv_int);\n+        let output = int::str(input);\n+        comm::send(send_str, move output);\n+    };\n+    comm::send(send_int, 1);\n+    assert comm::recv(recv_str) == ~\"1\";\n+}\n+\n+#[test]\n+fn test_try_success() {\n+    match do try {\n+        ~\"Success!\"\n+    } {\n+        result::Ok(~\"Success!\") => (),\n+        _ => fail\n+    }\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+fn test_try_fail() {\n+    match do try {\n+        fail\n+    } {\n+        result::Err(()) => (),\n+        result::Ok(()) => fail\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(windows))]\n+fn test_spawn_sched_no_threads() {\n+    do spawn_sched(ManualThreads(0u)) { }\n+}\n+\n+#[test]\n+fn test_spawn_sched() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+\n+    fn f(i: int, ch: comm::Chan<()>) {\n+        let parent_sched_id = rt::rust_get_sched_id();\n+\n+        do spawn_sched(SingleThreaded) {\n+            let child_sched_id = rt::rust_get_sched_id();\n+            assert parent_sched_id != child_sched_id;\n+\n+            if (i == 0) {\n+                comm::send(ch, ());\n+            } else {\n+                f(i - 1, ch);\n+            }\n+        };\n+\n+    }\n+    f(10, ch);\n+    comm::recv(po);\n+}\n+\n+#[test]\n+fn test_spawn_sched_childs_on_same_sched() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+\n+    do spawn_sched(SingleThreaded) {\n+        let parent_sched_id = rt::rust_get_sched_id();\n+        do spawn {\n+            let child_sched_id = rt::rust_get_sched_id();\n+            // This should be on the same scheduler\n+            assert parent_sched_id == child_sched_id;\n+            comm::send(ch, ());\n+        };\n+    };\n+\n+    comm::recv(po);\n+}\n+\n+#[nolink]\n+#[cfg(test)]\n+extern mod testrt {\n+    fn rust_dbg_lock_create() -> *libc::c_void;\n+    fn rust_dbg_lock_destroy(lock: *libc::c_void);\n+    fn rust_dbg_lock_lock(lock: *libc::c_void);\n+    fn rust_dbg_lock_unlock(lock: *libc::c_void);\n+    fn rust_dbg_lock_wait(lock: *libc::c_void);\n+    fn rust_dbg_lock_signal(lock: *libc::c_void);\n+}\n+\n+#[test]\n+fn test_spawn_sched_blocking() {\n+\n+    // Testing that a task in one scheduler can block in foreign code\n+    // without affecting other schedulers\n+    for iter::repeat(20u) {\n+\n+        let start_po = comm::Port();\n+        let start_ch = comm::Chan(&start_po);\n+        let fin_po = comm::Port();\n+        let fin_ch = comm::Chan(&fin_po);\n+\n+        let lock = testrt::rust_dbg_lock_create();\n+\n+        do spawn_sched(SingleThreaded) {\n+            testrt::rust_dbg_lock_lock(lock);\n+\n+            comm::send(start_ch, ());\n+\n+            // Block the scheduler thread\n+            testrt::rust_dbg_lock_wait(lock);\n+            testrt::rust_dbg_lock_unlock(lock);\n+\n+            comm::send(fin_ch, ());\n+        };\n+\n+        // Wait until the other task has its lock\n+        comm::recv(start_po);\n+\n+        fn pingpong(po: comm::Port<int>, ch: comm::Chan<int>) {\n+            let mut val = 20;\n+            while val > 0 {\n+                val = comm::recv(po);\n+                comm::send(ch, val - 1);\n+            }\n+        }\n+\n+        let setup_po = comm::Port();\n+        let setup_ch = comm::Chan(&setup_po);\n+        let parent_po = comm::Port();\n+        let parent_ch = comm::Chan(&parent_po);\n+        do spawn {\n+            let child_po = comm::Port();\n+            comm::send(setup_ch, comm::Chan(&child_po));\n+            pingpong(child_po, parent_ch);\n+        };\n+\n+        let child_ch = comm::recv(setup_po);\n+        comm::send(child_ch, 20);\n+        pingpong(parent_po, child_ch);\n+        testrt::rust_dbg_lock_lock(lock);\n+        testrt::rust_dbg_lock_signal(lock);\n+        testrt::rust_dbg_lock_unlock(lock);\n+        comm::recv(fin_po);\n+        testrt::rust_dbg_lock_destroy(lock);\n+    }\n+}\n+\n+#[cfg(test)]\n+fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n+    let p = comm::Port::<uint>();\n+    let ch = comm::Chan(&p);\n+\n+    let x = ~1;\n+    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n+\n+    do spawnfn |move x| {\n+        let x_in_child = ptr::addr_of(&(*x)) as uint;\n+        comm::send(ch, x_in_child);\n+    }\n+\n+    let x_in_child = comm::recv(p);\n+    assert x_in_parent == x_in_child;\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_spawn() {\n+    avoid_copying_the_body(spawn);\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_spawn_listener() {\n+    do avoid_copying_the_body |f| {\n+        spawn_listener(fn~(move f, _po: comm::Port<int>) {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_task_spawn() {\n+    do avoid_copying_the_body |f| {\n+        do task().spawn |move f| {\n+            f();\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_spawn_listener_1() {\n+    do avoid_copying_the_body |f| {\n+        task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n+            f();\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_try() {\n+    do avoid_copying_the_body |f| {\n+        do try |move f| {\n+            f()\n+        };\n+    }\n+}\n+\n+#[test]\n+fn test_avoid_copying_the_body_unlinked() {\n+    do avoid_copying_the_body |f| {\n+        do spawn_unlinked |move f| {\n+            f();\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_platform_thread() {\n+    let po = comm::Port();\n+    let ch = comm::Chan(&po);\n+    do task().sched_mode(PlatformThread).spawn {\n+        comm::send(ch, ());\n+    }\n+    comm::recv(po);\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+#[should_fail]\n+fn test_unkillable() {\n+    let po = comm::Port();\n+    let ch = po.chan();\n+\n+    // We want to do this after failing\n+    do spawn_unlinked {\n+        for iter::repeat(10) { yield() }\n+        ch.send(());\n+    }\n+\n+    do spawn {\n+        yield();\n+        // We want to fail after the unkillable task\n+        // blocks on recv\n+        fail;\n+    }\n+\n+    unsafe {\n+        do unkillable {\n+            let p = ~0;\n+            let pp: *uint = cast::transmute(move p);\n+\n+            // If we are killed here then the box will leak\n+            po.recv();\n+\n+            let _p: ~int = cast::transmute(move pp);\n+        }\n+    }\n+\n+    // Now we can be killed\n+    po.recv();\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+#[should_fail]\n+fn test_unkillable_nested() {\n+    let (ch, po) = pipes::stream();\n+\n+    // We want to do this after failing\n+    do spawn_unlinked |move ch| {\n+        for iter::repeat(10) { yield() }\n+        ch.send(());\n+    }\n+\n+    do spawn {\n+        yield();\n+        // We want to fail after the unkillable task\n+        // blocks on recv\n+        fail;\n+    }\n+\n+    unsafe {\n+        do unkillable {\n+            do unkillable {} // Here's the difference from the previous test.\n+            let p = ~0;\n+            let pp: *uint = cast::transmute(move p);\n+\n+            // If we are killed here then the box will leak\n+            po.recv();\n+\n+            let _p: ~int = cast::transmute(move pp);\n+        }\n+    }\n+\n+    // Now we can be killed\n+    po.recv();\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_atomically() {\n+    unsafe { do atomically { yield(); } }\n+}\n+\n+#[test]\n+fn test_atomically2() {\n+    unsafe { do atomically { } } yield(); // shouldn't fail\n+}\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_atomically_nested() {\n+    unsafe { do atomically { do atomically { } yield(); } }\n+}\n+\n+#[test]\n+fn test_child_doesnt_ref_parent() {\n+    // If the child refcounts the parent task, this will stack overflow when\n+    // climbing the task tree to dereference each ancestor. (See #1789)\n+    // (well, it would if the constant were 8000+ - I lowered it to be more\n+    // valgrind-friendly. try this at home, instead..!)\n+    const generations: uint = 16;\n+    fn child_no(x: uint) -> fn~() {\n+        return || {\n+            if x < generations {\n+                task::spawn(child_no(x+1));\n+            }\n+        }\n+    }\n+    task::spawn(child_no(0));\n+}\n+\n+#[test]\n+fn test_sched_thread_per_core() {\n+    let (chan, port) = pipes::stream();\n+\n+    do spawn_sched(ThreadPerCore) |move chan| {\n+        let cores = rt::rust_num_threads();\n+        let reported_threads = rt::rust_sched_threads();\n+        assert(cores as uint == reported_threads as uint);\n+        chan.send(());\n+    }\n+\n+    port.recv();\n+}\n+\n+#[test]\n+fn test_spawn_thread_on_demand() {\n+    let (chan, port) = pipes::stream();\n+\n+    do spawn_sched(ManualThreads(2)) |move chan| {\n+        let max_threads = rt::rust_sched_threads();\n+        assert(max_threads as int == 2);\n+        let running_threads = rt::rust_sched_current_nonlazy_threads();\n+        assert(running_threads as int == 1);\n+\n+        let (chan2, port2) = pipes::stream();\n+\n+        do spawn() |move chan2| {\n+            chan2.send(());\n+        }\n+\n+        let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n+        assert(running_threads2 as int == 2);\n+\n+        port2.recv();\n+        chan.send(());\n+    }\n+\n+    port.recv();\n+}"}, {"sha": "cbe6345a9f19f2bcaab7481731b0172e8cfc9799", "filename": "src/librustc/driver.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,5 +0,0 @@\n-use syntax::diagnostic;\n-export diagnostic;\n-\n-export driver;\n-export session;"}, {"sha": "a9d5afeb5222d653ac42a81a07d9e7cd86029c66", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,4 +1,12 @@\n #[legacy_exports];\n+\n+use syntax::diagnostic;\n+\n+export diagnostic;\n+\n+export driver;\n+export session;\n+\n #[legacy_exports]\n mod driver;\n #[legacy_exports]"}, {"sha": "2d2d6a3f79ee1619fab04a29cc900a098ff063d3", "filename": "src/librustc/metadata.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,31 +0,0 @@\n-// Define the rustc API's that the metadata module has access to\n-// Over time we will reduce these dependencies and, once metadata has\n-// no dependencies on rustc it can move into its own crate.\n-\n-mod middle {\n-    #[legacy_exports];\n-    pub use middle_::ty;\n-    pub use middle_::resolve;\n-}\n-\n-mod front {\n-    #[legacy_exports];\n-}\n-\n-mod back {\n-    #[legacy_exports];\n-}\n-\n-mod driver {\n-    #[legacy_exports];\n-}\n-\n-mod util {\n-    #[legacy_exports];\n-    pub use util_::ppaux;\n-}\n-\n-mod lib {\n-    #[legacy_exports];\n-    pub use lib_::llvm;\n-}"}, {"sha": "dfe983cc32bbb9093d3e10869e48a6b9a65bfb59", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -30,3 +30,36 @@ mod csearch;\n mod loader;\n #[legacy_exports]\n mod filesearch;\n+\n+\n+// Define the rustc API's that the metadata module has access to\n+// Over time we will reduce these dependencies and, once metadata has\n+// no dependencies on rustc it can move into its own crate.\n+\n+mod middle {\n+    #[legacy_exports];\n+    pub use middle_::ty;\n+    pub use middle_::resolve;\n+}\n+\n+mod front {\n+    #[legacy_exports];\n+}\n+\n+mod back {\n+    #[legacy_exports];\n+}\n+\n+mod driver {\n+    #[legacy_exports];\n+}\n+\n+mod util {\n+    #[legacy_exports];\n+    pub use util_::ppaux;\n+}\n+\n+mod lib {\n+    #[legacy_exports];\n+    pub use lib_::llvm;\n+}"}, {"sha": "df573b121f8e3f0de172121fa9fd784d913af674", "filename": "src/librustc/middle/borrowck.rs", "status": "removed", "additions": 0, "deletions": 618, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,618 +0,0 @@\n-/*!\n-# Borrow check\n-\n-This pass is in job of enforcing *memory safety* and *purity*.  As\n-memory safety is by far the more complex topic, I'll focus on that in\n-this description, but purity will be covered later on. In the context\n-of Rust, memory safety means three basic things:\n-\n-- no writes to immutable memory;\n-- all pointers point to non-freed memory;\n-- all pointers point to memory of the same type as the pointer.\n-\n-The last point might seem confusing: after all, for the most part,\n-this condition is guaranteed by the type check.  However, there are\n-two cases where the type check effectively delegates to borrow check.\n-\n-The first case has to do with enums.  If there is a pointer to the\n-interior of an enum, and the enum is in a mutable location (such as a\n-local variable or field declared to be mutable), it is possible that\n-the user will overwrite the enum with a new value of a different\n-variant, and thus effectively change the type of the memory that the\n-pointer is pointing at.\n-\n-The second case has to do with mutability.  Basically, the type\n-checker has only a limited understanding of mutability.  It will allow\n-(for example) the user to get an immutable pointer with the address of\n-a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n-pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n-are in fact intentional; they allow the user to temporarily treat a\n-mutable value as immutable.  It is up to the borrow check to guarantee\n-that the value in question is not in fact mutated during the lifetime\n-`r` of the reference.\n-\n-# Definition of unstable memory\n-\n-The primary danger to safety arises due to *unstable memory*.\n-Unstable memory is memory whose validity or type may change as a\n-result of an assignment, move, or a variable going out of scope.\n-There are two cases in Rust where memory is unstable: the contents of\n-unique boxes and enums.\n-\n-Unique boxes are unstable because when the variable containing the\n-unique box is re-assigned, moves, or goes out of scope, the unique box\n-is freed or---in the case of a move---potentially given to another\n-task.  In either case, if there is an extant and usable pointer into\n-the box, then safety guarantees would be compromised.\n-\n-Enum values are unstable because they are reassigned the types of\n-their contents may change if they are assigned with a different\n-variant than they had previously.\n-\n-# Safety criteria that must be enforced\n-\n-Whenever a piece of memory is borrowed for lifetime L, there are two\n-things which the borrow checker must guarantee.  First, it must\n-guarantee that the memory address will remain allocated (and owned by\n-the current task) for the entirety of the lifetime L.  Second, it must\n-guarantee that the type of the data will not change for the entirety\n-of the lifetime L.  In exchange, the region-based type system will\n-guarantee that the pointer is not used outside the lifetime L.  These\n-guarantees are to some extent independent but are also inter-related.\n-\n-In some cases, the type of a pointer cannot be invalidated but the\n-lifetime can.  For example, imagine a pointer to the interior of\n-a shared box like:\n-\n-    let mut x = @mut {f: 5, g: 6};\n-    let y = &mut x.f;\n-\n-Here, a pointer was created to the interior of a shared box which\n-contains a record.  Even if `*x` were to be mutated like so:\n-\n-    *x = {f: 6, g: 7};\n-\n-This would cause `*y` to change from 5 to 6, but the pointer pointer\n-`y` remains valid.  It still points at an integer even if that integer\n-has been overwritten.\n-\n-However, if we were to reassign `x` itself, like so:\n-\n-    x = @{f: 6, g: 7};\n-\n-This could potentially invalidate `y`, because if `x` were the final\n-reference to the shared box, then that memory would be released and\n-now `y` points at freed memory.  (We will see that to prevent this\n-scenario we will *root* shared boxes that reside in mutable memory\n-whose contents are borrowed; rooting means that we create a temporary\n-to ensure that the box is not collected).\n-\n-In other cases, like an enum on the stack, the memory cannot be freed\n-but its type can change:\n-\n-    let mut x = Some(5);\n-    match x {\n-      Some(ref y) => { ... }\n-      None => { ... }\n-    }\n-\n-Here as before, the pointer `y` would be invalidated if we were to\n-reassign `x` to `none`.  (We will see that this case is prevented\n-because borrowck tracks data which resides on the stack and prevents\n-variables from reassigned if there may be pointers to their interior)\n-\n-Finally, in some cases, both dangers can arise.  For example, something\n-like the following:\n-\n-    let mut x = ~some(5);\n-    match x {\n-      ~some(ref y) => { ... }\n-      ~none => { ... }\n-    }\n-\n-In this case, if `x` to be reassigned or `*x` were to be mutated, then\n-the pointer `y` would be invalided.  (This case is also prevented by\n-borrowck tracking data which is owned by the current stack frame)\n-\n-# Summary of the safety check\n-\n-In order to enforce mutability, the borrow check has a few tricks up\n-its sleeve:\n-\n-- When data is owned by the current stack frame, we can identify every\n-  possible assignment to a local variable and simply prevent\n-  potentially dangerous assignments directly.\n-\n-- If data is owned by a shared box, we can root the box to increase\n-  its lifetime.\n-\n-- If data is found within a borrowed pointer, we can assume that the\n-  data will remain live for the entirety of the borrowed pointer.\n-\n-- We can rely on the fact that pure actions (such as calling pure\n-  functions) do not mutate data which is not owned by the current\n-  stack frame.\n-\n-# Possible future directions\n-\n-There are numerous ways that the `borrowck` could be strengthened, but\n-these are the two most likely:\n-\n-- flow-sensitivity: we do not currently consider flow at all but only\n-  block-scoping.  This means that innocent code like the following is\n-  rejected:\n-\n-      let mut x: int;\n-      ...\n-      x = 5;\n-      let y: &int = &x; // immutable ptr created\n-      ...\n-\n-  The reason is that the scope of the pointer `y` is the entire\n-  enclosing block, and the assignment `x = 5` occurs within that\n-  block.  The analysis is not smart enough to see that `x = 5` always\n-  happens before the immutable pointer is created.  This is relatively\n-  easy to fix and will surely be fixed at some point.\n-\n-- finer-grained purity checks: currently, our fallback for\n-  guaranteeing random references into mutable, aliasable memory is to\n-  require *total purity*.  This is rather strong.  We could use local\n-  type-based alias analysis to distinguish writes that could not\n-  possibly invalid the references which must be guaranteed.  This\n-  would only work within the function boundaries; function calls would\n-  still require total purity.  This seems less likely to be\n-  implemented in the short term as it would make the code\n-  significantly more complex; there is currently no code to analyze\n-  the types and determine the possible impacts of a write.\n-\n-# How the code works\n-\n-The borrow check code is divided into several major modules, each of\n-which is documented in its own file.\n-\n-The `gather_loans` and `check_loans` are the two major passes of the\n-analysis.  The `gather_loans` pass runs over the IR once to determine\n-what memory must remain valid and for how long.  Its name is a bit of\n-a misnomer; it does in fact gather up the set of loans which are\n-granted, but it also determines when @T pointers must be rooted and\n-for which scopes purity must be required.\n-\n-The `check_loans` pass walks the IR and examines the loans and purity\n-requirements computed in `gather_loans`.  It checks to ensure that (a)\n-the conditions of all loans are honored; (b) no contradictory loans\n-were granted (for example, loaning out the same memory as mutable and\n-immutable simultaneously); and (c) any purity requirements are\n-honored.\n-\n-The remaining modules are helper modules used by `gather_loans` and\n-`check_loans`:\n-\n-- `categorization` has the job of analyzing an expression to determine\n-  what kind of memory is used in evaluating it (for example, where\n-  dereferences occur and what kind of pointer is dereferenced; whether\n-  the memory is mutable; etc)\n-- `loan` determines when data uniquely tied to the stack frame can be\n-  loaned out.\n-- `preserve` determines what actions (if any) must be taken to preserve\n-  aliasable data.  This is the code which decides when to root\n-  an @T pointer or to require purity.\n-\n-# Maps that are created\n-\n-Borrowck results in two maps.\n-\n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted.  Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call).  The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n-\n-- `mutbl_map`: identifies those local variables which are modified or\n-  moved. This is used by trans to guarantee that such variables are\n-  given a memory location and not used as immediates.\n- */\n-\n-use syntax::ast;\n-use syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n-use syntax::visit;\n-use syntax::ast_util;\n-use syntax::ast_map;\n-use syntax::codemap::span;\n-use util::ppaux::{ty_to_str, region_to_str, explain_region,\n-                  expr_repr, note_and_explain_region};\n-use std::map::{HashMap, Set};\n-use std::list;\n-use std::list::{List, Cons, Nil};\n-use result::{Result, Ok, Err};\n-use syntax::print::pprust;\n-use util::common::indenter;\n-use ty::to_str;\n-use dvec::DVec;\n-use mem_categorization::*;\n-\n-export check_crate, root_map, mutbl_map;\n-\n-fn check_crate(tcx: ty::ctxt,\n-               method_map: typeck::method_map,\n-               last_use_map: liveness::last_use_map,\n-               crate: @ast::crate) -> (root_map, mutbl_map) {\n-\n-    let bccx = borrowck_ctxt_(@{tcx: tcx,\n-                                method_map: method_map,\n-                                last_use_map: last_use_map,\n-                                root_map: root_map(),\n-                                mutbl_map: HashMap(),\n-                                mut loaned_paths_same: 0,\n-                                mut loaned_paths_imm: 0,\n-                                mut stable_paths: 0,\n-                                mut req_pure_paths: 0,\n-                                mut guaranteed_paths: 0});\n-\n-    let req_maps = gather_loans::gather_loans(bccx, crate);\n-    check_loans::check_loans(bccx, req_maps, crate);\n-\n-    if tcx.sess.borrowck_stats() {\n-        io::println(~\"--- borrowck stats ---\");\n-        io::println(fmt!(\"paths requiring guarantees: %u\",\n-                        bccx.guaranteed_paths));\n-        io::println(fmt!(\"paths requiring loans     : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_same)));\n-        io::println(fmt!(\"paths requiring imm loans : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_imm)));\n-        io::println(fmt!(\"stable paths              : %s\",\n-                         make_stat(bccx, bccx.stable_paths)));\n-        io::println(fmt!(\"paths requiring purity    : %s\",\n-                         make_stat(bccx, bccx.req_pure_paths)));\n-    }\n-\n-    return (bccx.root_map, bccx.mutbl_map);\n-\n-    fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n-        let stat_f = stat as float;\n-        let total = bccx.guaranteed_paths as float;\n-        fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n-    }\n-}\n-\n-// ----------------------------------------------------------------------\n-// Type definitions\n-\n-type borrowck_ctxt_ = {tcx: ty::ctxt,\n-                       method_map: typeck::method_map,\n-                       last_use_map: liveness::last_use_map,\n-                       root_map: root_map,\n-                       mutbl_map: mutbl_map,\n-\n-                       // Statistics:\n-                       mut loaned_paths_same: uint,\n-                       mut loaned_paths_imm: uint,\n-                       mut stable_paths: uint,\n-                       mut req_pure_paths: uint,\n-                       mut guaranteed_paths: uint};\n-\n-enum borrowck_ctxt {\n-    borrowck_ctxt_(@borrowck_ctxt_)\n-}\n-\n-// a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n-// the box needs to be kept live to the id of the scope for which they\n-// must stay live.\n-type root_map = HashMap<root_map_key, ast::node_id>;\n-\n-// the keys to the root map combine the `id` of the expression with\n-// the number of types that it is autodereferenced.  So, for example,\n-// if you have an expression `x.f` and x has type ~@T, we could add an\n-// entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n-// to refer to the deref of the unique pointer, and so on.\n-type root_map_key = {id: ast::node_id, derefs: uint};\n-\n-// set of ids of local vars / formal arguments that are modified / moved.\n-// this is used in trans for optimization purposes.\n-type mutbl_map = std::map::HashMap<ast::node_id, ()>;\n-\n-// Errors that can occur\"]\n-enum bckerr_code {\n-    err_mut_uniq,\n-    err_mut_variant,\n-    err_root_not_permitted,\n-    err_mutbl(ast::mutability),\n-    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n-}\n-\n-impl bckerr_code : cmp::Eq {\n-    pure fn eq(&self, other: &bckerr_code) -> bool {\n-        match (*self) {\n-            err_mut_uniq => {\n-                match (*other) {\n-                    err_mut_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            err_mut_variant => {\n-                match (*other) {\n-                    err_mut_variant => true,\n-                    _ => false\n-                }\n-            }\n-            err_root_not_permitted => {\n-                match (*other) {\n-                    err_root_not_permitted => true,\n-                    _ => false\n-                }\n-            }\n-            err_mutbl(e0a) => {\n-                match (*other) {\n-                    err_mutbl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_root_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_root_scope(e0b, e1b) =>\n-                        e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n-}\n-\n-// Combination of an error code and the categorization of the expression\n-// that caused it\n-type bckerr = {cmt: cmt, code: bckerr_code};\n-\n-impl bckerr : cmp::Eq {\n-    pure fn eq(&self, other: &bckerr) -> bool {\n-        (*self).cmt == (*other).cmt && (*self).code == (*other).code\n-    }\n-    pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n-}\n-\n-// shorthand for something that fails with `bckerr` or succeeds with `T`\n-type bckres<T> = Result<T, bckerr>;\n-\n-/// a complete record of a loan that was granted\n-struct Loan {lp: @loan_path, cmt: cmt, mutbl: ast::mutability}\n-\n-/// maps computed by `gather_loans` that are then used by `check_loans`\n-///\n-/// - `req_loan_map`: map from each block/expr to the required loans needed\n-///   for the duration of that block/expr\n-/// - `pure_map`: map from block/expr that must be pure to the error message\n-///   that should be reported if they are not pure\n-type req_maps = {\n-    req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n-    pure_map: HashMap<ast::node_id, bckerr>\n-};\n-\n-fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n-    let old_save_and_restore_t = *save_and_restore_t;\n-    let u = f();\n-    *save_and_restore_t = old_save_and_restore_t;\n-    move u\n-}\n-\n-/// Creates and returns a new root_map\n-\n-impl root_map_key : cmp::Eq {\n-    pure fn eq(&self, other: &root_map_key) -> bool {\n-        (*self).id == (*other).id && (*self).derefs == (*other).derefs\n-    }\n-    pure fn ne(&self, other: &root_map_key) -> bool {\n-        ! ((*self) == (*other))\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl root_map_key : to_bytes::IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-impl root_map_key : to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n-    }\n-}\n-\n-fn root_map() -> root_map {\n-    return HashMap();\n-\n-    pure fn root_map_key_eq(k1: &root_map_key, k2: &root_map_key) -> bool {\n-        k1.id == k2.id && k1.derefs == k2.derefs\n-    }\n-\n-    pure fn root_map_key_hash(k: &root_map_key) -> uint {\n-        (k.id << 4) as uint | k.derefs\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Misc\n-\n-impl borrowck_ctxt {\n-    fn is_subregion_of(r_sub: ty::Region, r_sup: ty::Region) -> bool {\n-        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n-    }\n-\n-    fn cat_expr(expr: @ast::expr) -> cmt {\n-        cat_expr(self.tcx, self.method_map, expr)\n-    }\n-\n-    fn cat_expr_unadjusted(expr: @ast::expr) -> cmt {\n-        cat_expr_unadjusted(self.tcx, self.method_map, expr)\n-    }\n-\n-    fn cat_expr_autoderefd(expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment)\n-                        -> cmt {\n-        cat_expr_autoderefd(self.tcx, self.method_map, expr, adj)\n-    }\n-\n-    fn cat_def(id: ast::node_id,\n-               span: span,\n-               ty: ty::t,\n-               def: ast::def) -> cmt {\n-        cat_def(self.tcx, self.method_map, id, span, ty, def)\n-    }\n-\n-    fn cat_variant<N: ast_node>(arg: N,\n-                                enum_did: ast::def_id,\n-                                cmt: cmt) -> cmt {\n-        cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n-    }\n-\n-    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n-        return @{cat:cat_discr(cmt, alt_id),.. *cmt};\n-    }\n-\n-    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cat_pattern(cmt, pat, op);\n-    }\n-\n-    fn report_if_err(bres: bckres<()>) {\n-        match bres {\n-          Ok(()) => (),\n-          Err(e) => self.report(e)\n-        }\n-    }\n-\n-    fn report(err: bckerr) {\n-        self.span_err(\n-            err.cmt.span,\n-            fmt!(\"illegal borrow: %s\",\n-                 self.bckerr_to_str(err)));\n-        self.note_and_explain_bckerr(err);\n-    }\n-\n-    fn span_err(s: span, m: ~str) {\n-        self.tcx.sess.span_err(s, m);\n-    }\n-\n-    fn span_note(s: span, m: ~str) {\n-        self.tcx.sess.span_note(s, m);\n-    }\n-\n-    fn add_to_mutbl_map(cmt: cmt) {\n-        match cmt.cat {\n-          cat_local(id) | cat_arg(id) => {\n-            self.mutbl_map.insert(id, ());\n-          }\n-          cat_stack_upvar(cmt) => {\n-            self.add_to_mutbl_map(cmt);\n-          }\n-          _ => ()\n-        }\n-    }\n-\n-    fn bckerr_to_str(err: bckerr) -> ~str {\n-        match err.code {\n-            err_mutbl(req) => {\n-                fmt!(\"creating %s alias to %s\",\n-                     self.mut_to_str(req),\n-                     self.cmt_to_str(err.cmt))\n-            }\n-            err_mut_uniq => {\n-                ~\"unique value in aliasable, mutable location\"\n-            }\n-            err_mut_variant => {\n-                ~\"enum variant in aliasable, mutable location\"\n-            }\n-            err_root_not_permitted => {\n-                // note: I don't expect users to ever see this error\n-                // message, reasons are discussed in attempt_root() in\n-                // preserve.rs.\n-                ~\"rooting is not permitted\"\n-            }\n-            err_out_of_root_scope(*) => {\n-                ~\"cannot root managed value long enough\"\n-            }\n-            err_out_of_scope(*) => {\n-                ~\"borrowed value does not live long enough\"\n-            }\n-        }\n-    }\n-\n-    fn note_and_explain_bckerr(err: bckerr) {\n-        let code = err.code;\n-        match code {\n-            err_mutbl(*) | err_mut_uniq | err_mut_variant |\n-            err_root_not_permitted => {}\n-\n-            err_out_of_root_scope(super_scope, sub_scope) => {\n-                note_and_explain_region(\n-                    self.tcx,\n-                    ~\"managed value would have to be rooted for \",\n-                    sub_scope,\n-                    ~\"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    ~\"...but can only be rooted for \",\n-                    super_scope,\n-                    ~\"\");\n-            }\n-\n-            err_out_of_scope(super_scope, sub_scope) => {\n-                note_and_explain_region(\n-                    self.tcx,\n-                    ~\"borrowed pointer must be valid for \",\n-                    sub_scope,\n-                    ~\"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    ~\"...but borrowed value is only valid for \",\n-                    super_scope,\n-                    ~\"\");\n-          }\n-        }\n-    }\n-\n-\n-    fn cmt_to_str(cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_str(cmt)\n-    }\n-\n-    fn cmt_to_repr(cmt: cmt) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.cmt_to_repr(cmt)\n-    }\n-\n-    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n-        mc.mut_to_str(mutbl)\n-    }\n-\n-    fn loan_to_repr(loan: &Loan) -> ~str {\n-        fmt!(\"Loan(lp=%?, cmt=%s, mutbl=%?)\",\n-             loan.lp, self.cmt_to_repr(loan.cmt), loan.mutbl)\n-    }\n-}\n-\n-// The inherent mutability of a component is its default mutability\n-// assuming it is embedded in an immutable context.  In general, the\n-// mutability can be \"overridden\" if the component is embedded in a\n-// mutable structure.\n-fn inherent_mutability(ck: comp_kind) -> mutability {\n-    match ck {\n-      comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n-      comp_field(_, m) | comp_index(_, m)            => m\n-    }\n-}"}, {"sha": "6ef80321ec223861ef34ee689a20e62ee9a6a137", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 620, "deletions": 0, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,4 +1,239 @@\n+/*!\n+# Borrow check\n+\n+This pass is in job of enforcing *memory safety* and *purity*.  As\n+memory safety is by far the more complex topic, I'll focus on that in\n+this description, but purity will be covered later on. In the context\n+of Rust, memory safety means three basic things:\n+\n+- no writes to immutable memory;\n+- all pointers point to non-freed memory;\n+- all pointers point to memory of the same type as the pointer.\n+\n+The last point might seem confusing: after all, for the most part,\n+this condition is guaranteed by the type check.  However, there are\n+two cases where the type check effectively delegates to borrow check.\n+\n+The first case has to do with enums.  If there is a pointer to the\n+interior of an enum, and the enum is in a mutable location (such as a\n+local variable or field declared to be mutable), it is possible that\n+the user will overwrite the enum with a new value of a different\n+variant, and thus effectively change the type of the memory that the\n+pointer is pointing at.\n+\n+The second case has to do with mutability.  Basically, the type\n+checker has only a limited understanding of mutability.  It will allow\n+(for example) the user to get an immutable pointer with the address of\n+a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n+pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n+are in fact intentional; they allow the user to temporarily treat a\n+mutable value as immutable.  It is up to the borrow check to guarantee\n+that the value in question is not in fact mutated during the lifetime\n+`r` of the reference.\n+\n+# Definition of unstable memory\n+\n+The primary danger to safety arises due to *unstable memory*.\n+Unstable memory is memory whose validity or type may change as a\n+result of an assignment, move, or a variable going out of scope.\n+There are two cases in Rust where memory is unstable: the contents of\n+unique boxes and enums.\n+\n+Unique boxes are unstable because when the variable containing the\n+unique box is re-assigned, moves, or goes out of scope, the unique box\n+is freed or---in the case of a move---potentially given to another\n+task.  In either case, if there is an extant and usable pointer into\n+the box, then safety guarantees would be compromised.\n+\n+Enum values are unstable because they are reassigned the types of\n+their contents may change if they are assigned with a different\n+variant than they had previously.\n+\n+# Safety criteria that must be enforced\n+\n+Whenever a piece of memory is borrowed for lifetime L, there are two\n+things which the borrow checker must guarantee.  First, it must\n+guarantee that the memory address will remain allocated (and owned by\n+the current task) for the entirety of the lifetime L.  Second, it must\n+guarantee that the type of the data will not change for the entirety\n+of the lifetime L.  In exchange, the region-based type system will\n+guarantee that the pointer is not used outside the lifetime L.  These\n+guarantees are to some extent independent but are also inter-related.\n+\n+In some cases, the type of a pointer cannot be invalidated but the\n+lifetime can.  For example, imagine a pointer to the interior of\n+a shared box like:\n+\n+    let mut x = @mut {f: 5, g: 6};\n+    let y = &mut x.f;\n+\n+Here, a pointer was created to the interior of a shared box which\n+contains a record.  Even if `*x` were to be mutated like so:\n+\n+    *x = {f: 6, g: 7};\n+\n+This would cause `*y` to change from 5 to 6, but the pointer pointer\n+`y` remains valid.  It still points at an integer even if that integer\n+has been overwritten.\n+\n+However, if we were to reassign `x` itself, like so:\n+\n+    x = @{f: 6, g: 7};\n+\n+This could potentially invalidate `y`, because if `x` were the final\n+reference to the shared box, then that memory would be released and\n+now `y` points at freed memory.  (We will see that to prevent this\n+scenario we will *root* shared boxes that reside in mutable memory\n+whose contents are borrowed; rooting means that we create a temporary\n+to ensure that the box is not collected).\n+\n+In other cases, like an enum on the stack, the memory cannot be freed\n+but its type can change:\n+\n+    let mut x = Some(5);\n+    match x {\n+      Some(ref y) => { ... }\n+      None => { ... }\n+    }\n+\n+Here as before, the pointer `y` would be invalidated if we were to\n+reassign `x` to `none`.  (We will see that this case is prevented\n+because borrowck tracks data which resides on the stack and prevents\n+variables from reassigned if there may be pointers to their interior)\n+\n+Finally, in some cases, both dangers can arise.  For example, something\n+like the following:\n+\n+    let mut x = ~some(5);\n+    match x {\n+      ~some(ref y) => { ... }\n+      ~none => { ... }\n+    }\n+\n+In this case, if `x` to be reassigned or `*x` were to be mutated, then\n+the pointer `y` would be invalided.  (This case is also prevented by\n+borrowck tracking data which is owned by the current stack frame)\n+\n+# Summary of the safety check\n+\n+In order to enforce mutability, the borrow check has a few tricks up\n+its sleeve:\n+\n+- When data is owned by the current stack frame, we can identify every\n+  possible assignment to a local variable and simply prevent\n+  potentially dangerous assignments directly.\n+\n+- If data is owned by a shared box, we can root the box to increase\n+  its lifetime.\n+\n+- If data is found within a borrowed pointer, we can assume that the\n+  data will remain live for the entirety of the borrowed pointer.\n+\n+- We can rely on the fact that pure actions (such as calling pure\n+  functions) do not mutate data which is not owned by the current\n+  stack frame.\n+\n+# Possible future directions\n+\n+There are numerous ways that the `borrowck` could be strengthened, but\n+these are the two most likely:\n+\n+- flow-sensitivity: we do not currently consider flow at all but only\n+  block-scoping.  This means that innocent code like the following is\n+  rejected:\n+\n+      let mut x: int;\n+      ...\n+      x = 5;\n+      let y: &int = &x; // immutable ptr created\n+      ...\n+\n+  The reason is that the scope of the pointer `y` is the entire\n+  enclosing block, and the assignment `x = 5` occurs within that\n+  block.  The analysis is not smart enough to see that `x = 5` always\n+  happens before the immutable pointer is created.  This is relatively\n+  easy to fix and will surely be fixed at some point.\n+\n+- finer-grained purity checks: currently, our fallback for\n+  guaranteeing random references into mutable, aliasable memory is to\n+  require *total purity*.  This is rather strong.  We could use local\n+  type-based alias analysis to distinguish writes that could not\n+  possibly invalid the references which must be guaranteed.  This\n+  would only work within the function boundaries; function calls would\n+  still require total purity.  This seems less likely to be\n+  implemented in the short term as it would make the code\n+  significantly more complex; there is currently no code to analyze\n+  the types and determine the possible impacts of a write.\n+\n+# How the code works\n+\n+The borrow check code is divided into several major modules, each of\n+which is documented in its own file.\n+\n+The `gather_loans` and `check_loans` are the two major passes of the\n+analysis.  The `gather_loans` pass runs over the IR once to determine\n+what memory must remain valid and for how long.  Its name is a bit of\n+a misnomer; it does in fact gather up the set of loans which are\n+granted, but it also determines when @T pointers must be rooted and\n+for which scopes purity must be required.\n+\n+The `check_loans` pass walks the IR and examines the loans and purity\n+requirements computed in `gather_loans`.  It checks to ensure that (a)\n+the conditions of all loans are honored; (b) no contradictory loans\n+were granted (for example, loaning out the same memory as mutable and\n+immutable simultaneously); and (c) any purity requirements are\n+honored.\n+\n+The remaining modules are helper modules used by `gather_loans` and\n+`check_loans`:\n+\n+- `categorization` has the job of analyzing an expression to determine\n+  what kind of memory is used in evaluating it (for example, where\n+  dereferences occur and what kind of pointer is dereferenced; whether\n+  the memory is mutable; etc)\n+- `loan` determines when data uniquely tied to the stack frame can be\n+  loaned out.\n+- `preserve` determines what actions (if any) must be taken to preserve\n+  aliasable data.  This is the code which decides when to root\n+  an @T pointer or to require purity.\n+\n+# Maps that are created\n+\n+Borrowck results in two maps.\n+\n+- `root_map`: identifies those expressions or patterns whose result\n+  needs to be rooted.  Conceptually the root_map maps from an\n+  expression or pattern node to a `node_id` identifying the scope for\n+  which the expression must be rooted (this `node_id` should identify\n+  a block or call).  The actual key to the map is not an expression id,\n+  however, but a `root_map_key`, which combines an expression id with a\n+  deref count and is used to cope with auto-deref.\n+\n+- `mutbl_map`: identifies those local variables which are modified or\n+  moved. This is used by trans to guarantee that such variables are\n+  given a memory location and not used as immediates.\n+ */\n+\n #[legacy_exports];\n+\n+use syntax::ast;\n+use syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n+use syntax::visit;\n+use syntax::ast_util;\n+use syntax::ast_map;\n+use syntax::codemap::span;\n+use util::ppaux::{ty_to_str, region_to_str, explain_region,\n+                  expr_repr, note_and_explain_region};\n+use std::map::{HashMap, Set};\n+use std::list;\n+use std::list::{List, Cons, Nil};\n+use result::{Result, Ok, Err};\n+use syntax::print::pprust;\n+use util::common::indenter;\n+use ty::to_str;\n+use dvec::DVec;\n+use mem_categorization::*;\n+\n #[legacy_exports]\n mod check_loans;\n #[legacy_exports]\n@@ -7,3 +242,388 @@ mod gather_loans;\n mod loan;\n #[legacy_exports]\n mod preserve;\n+\n+export check_crate, root_map, mutbl_map;\n+\n+fn check_crate(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               last_use_map: liveness::last_use_map,\n+               crate: @ast::crate) -> (root_map, mutbl_map) {\n+\n+    let bccx = borrowck_ctxt_(@{tcx: tcx,\n+                                method_map: method_map,\n+                                last_use_map: last_use_map,\n+                                root_map: root_map(),\n+                                mutbl_map: HashMap(),\n+                                mut loaned_paths_same: 0,\n+                                mut loaned_paths_imm: 0,\n+                                mut stable_paths: 0,\n+                                mut req_pure_paths: 0,\n+                                mut guaranteed_paths: 0});\n+\n+    let req_maps = gather_loans::gather_loans(bccx, crate);\n+    check_loans::check_loans(bccx, req_maps, crate);\n+\n+    if tcx.sess.borrowck_stats() {\n+        io::println(~\"--- borrowck stats ---\");\n+        io::println(fmt!(\"paths requiring guarantees: %u\",\n+                        bccx.guaranteed_paths));\n+        io::println(fmt!(\"paths requiring loans     : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_same)));\n+        io::println(fmt!(\"paths requiring imm loans : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_imm)));\n+        io::println(fmt!(\"stable paths              : %s\",\n+                         make_stat(bccx, bccx.stable_paths)));\n+        io::println(fmt!(\"paths requiring purity    : %s\",\n+                         make_stat(bccx, bccx.req_pure_paths)));\n+    }\n+\n+    return (bccx.root_map, bccx.mutbl_map);\n+\n+    fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n+        let stat_f = stat as float;\n+        let total = bccx.guaranteed_paths as float;\n+        fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n+    }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Type definitions\n+\n+type borrowck_ctxt_ = {tcx: ty::ctxt,\n+                       method_map: typeck::method_map,\n+                       last_use_map: liveness::last_use_map,\n+                       root_map: root_map,\n+                       mutbl_map: mutbl_map,\n+\n+                       // Statistics:\n+                       mut loaned_paths_same: uint,\n+                       mut loaned_paths_imm: uint,\n+                       mut stable_paths: uint,\n+                       mut req_pure_paths: uint,\n+                       mut guaranteed_paths: uint};\n+\n+enum borrowck_ctxt {\n+    borrowck_ctxt_(@borrowck_ctxt_)\n+}\n+\n+// a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n+// the box needs to be kept live to the id of the scope for which they\n+// must stay live.\n+type root_map = HashMap<root_map_key, ast::node_id>;\n+\n+// the keys to the root map combine the `id` of the expression with\n+// the number of types that it is autodereferenced.  So, for example,\n+// if you have an expression `x.f` and x has type ~@T, we could add an\n+// entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n+// to refer to the deref of the unique pointer, and so on.\n+type root_map_key = {id: ast::node_id, derefs: uint};\n+\n+// set of ids of local vars / formal arguments that are modified / moved.\n+// this is used in trans for optimization purposes.\n+type mutbl_map = std::map::HashMap<ast::node_id, ()>;\n+\n+// Errors that can occur\"]\n+enum bckerr_code {\n+    err_mut_uniq,\n+    err_mut_variant,\n+    err_root_not_permitted,\n+    err_mutbl(ast::mutability),\n+    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n+}\n+\n+impl bckerr_code : cmp::Eq {\n+    pure fn eq(&self, other: &bckerr_code) -> bool {\n+        match (*self) {\n+            err_mut_uniq => {\n+                match (*other) {\n+                    err_mut_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            err_mut_variant => {\n+                match (*other) {\n+                    err_mut_variant => true,\n+                    _ => false\n+                }\n+            }\n+            err_root_not_permitted => {\n+                match (*other) {\n+                    err_root_not_permitted => true,\n+                    _ => false\n+                }\n+            }\n+            err_mutbl(e0a) => {\n+                match (*other) {\n+                    err_mutbl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_root_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_root_scope(e0b, e1b) =>\n+                        e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n+}\n+\n+// Combination of an error code and the categorization of the expression\n+// that caused it\n+type bckerr = {cmt: cmt, code: bckerr_code};\n+\n+impl bckerr : cmp::Eq {\n+    pure fn eq(&self, other: &bckerr) -> bool {\n+        (*self).cmt == (*other).cmt && (*self).code == (*other).code\n+    }\n+    pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n+}\n+\n+// shorthand for something that fails with `bckerr` or succeeds with `T`\n+type bckres<T> = Result<T, bckerr>;\n+\n+/// a complete record of a loan that was granted\n+struct Loan {lp: @loan_path, cmt: cmt, mutbl: ast::mutability}\n+\n+/// maps computed by `gather_loans` that are then used by `check_loans`\n+///\n+/// - `req_loan_map`: map from each block/expr to the required loans needed\n+///   for the duration of that block/expr\n+/// - `pure_map`: map from block/expr that must be pure to the error message\n+///   that should be reported if they are not pure\n+type req_maps = {\n+    req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n+    pure_map: HashMap<ast::node_id, bckerr>\n+};\n+\n+fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n+    let old_save_and_restore_t = *save_and_restore_t;\n+    let u = f();\n+    *save_and_restore_t = old_save_and_restore_t;\n+    move u\n+}\n+\n+/// Creates and returns a new root_map\n+\n+impl root_map_key : cmp::Eq {\n+    pure fn eq(&self, other: &root_map_key) -> bool {\n+        (*self).id == (*other).id && (*self).derefs == (*other).derefs\n+    }\n+    pure fn ne(&self, other: &root_map_key) -> bool {\n+        ! ((*self) == (*other))\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl root_map_key : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+    }\n+}\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl root_map_key : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+    }\n+}\n+\n+fn root_map() -> root_map {\n+    return HashMap();\n+\n+    pure fn root_map_key_eq(k1: &root_map_key, k2: &root_map_key) -> bool {\n+        k1.id == k2.id && k1.derefs == k2.derefs\n+    }\n+\n+    pure fn root_map_key_hash(k: &root_map_key) -> uint {\n+        (k.id << 4) as uint | k.derefs\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Misc\n+\n+impl borrowck_ctxt {\n+    fn is_subregion_of(r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+    }\n+\n+    fn cat_expr(expr: @ast::expr) -> cmt {\n+        cat_expr(self.tcx, self.method_map, expr)\n+    }\n+\n+    fn cat_expr_unadjusted(expr: @ast::expr) -> cmt {\n+        cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+    }\n+\n+    fn cat_expr_autoderefd(expr: @ast::expr,\n+                           adj: @ty::AutoAdjustment)\n+                        -> cmt {\n+        cat_expr_autoderefd(self.tcx, self.method_map, expr, adj)\n+    }\n+\n+    fn cat_def(id: ast::node_id,\n+               span: span,\n+               ty: ty::t,\n+               def: ast::def) -> cmt {\n+        cat_def(self.tcx, self.method_map, id, span, ty, def)\n+    }\n+\n+    fn cat_variant<N: ast_node>(arg: N,\n+                                enum_did: ast::def_id,\n+                                cmt: cmt) -> cmt {\n+        cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n+    }\n+\n+    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n+        return @{cat:cat_discr(cmt, alt_id),.. *cmt};\n+    }\n+\n+    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cat_pattern(cmt, pat, op);\n+    }\n+\n+    fn report_if_err(bres: bckres<()>) {\n+        match bres {\n+          Ok(()) => (),\n+          Err(e) => self.report(e)\n+        }\n+    }\n+\n+    fn report(err: bckerr) {\n+        self.span_err(\n+            err.cmt.span,\n+            fmt!(\"illegal borrow: %s\",\n+                 self.bckerr_to_str(err)));\n+        self.note_and_explain_bckerr(err);\n+    }\n+\n+    fn span_err(s: span, m: ~str) {\n+        self.tcx.sess.span_err(s, m);\n+    }\n+\n+    fn span_note(s: span, m: ~str) {\n+        self.tcx.sess.span_note(s, m);\n+    }\n+\n+    fn add_to_mutbl_map(cmt: cmt) {\n+        match cmt.cat {\n+          cat_local(id) | cat_arg(id) => {\n+            self.mutbl_map.insert(id, ());\n+          }\n+          cat_stack_upvar(cmt) => {\n+            self.add_to_mutbl_map(cmt);\n+          }\n+          _ => ()\n+        }\n+    }\n+\n+    fn bckerr_to_str(err: bckerr) -> ~str {\n+        match err.code {\n+            err_mutbl(req) => {\n+                fmt!(\"creating %s alias to %s\",\n+                     self.mut_to_str(req),\n+                     self.cmt_to_str(err.cmt))\n+            }\n+            err_mut_uniq => {\n+                ~\"unique value in aliasable, mutable location\"\n+            }\n+            err_mut_variant => {\n+                ~\"enum variant in aliasable, mutable location\"\n+            }\n+            err_root_not_permitted => {\n+                // note: I don't expect users to ever see this error\n+                // message, reasons are discussed in attempt_root() in\n+                // preserve.rs.\n+                ~\"rooting is not permitted\"\n+            }\n+            err_out_of_root_scope(*) => {\n+                ~\"cannot root managed value long enough\"\n+            }\n+            err_out_of_scope(*) => {\n+                ~\"borrowed value does not live long enough\"\n+            }\n+        }\n+    }\n+\n+    fn note_and_explain_bckerr(err: bckerr) {\n+        let code = err.code;\n+        match code {\n+            err_mutbl(*) | err_mut_uniq | err_mut_variant |\n+            err_root_not_permitted => {}\n+\n+            err_out_of_root_scope(super_scope, sub_scope) => {\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"managed value would have to be rooted for \",\n+                    sub_scope,\n+                    ~\"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"...but can only be rooted for \",\n+                    super_scope,\n+                    ~\"\");\n+            }\n+\n+            err_out_of_scope(super_scope, sub_scope) => {\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"borrowed pointer must be valid for \",\n+                    sub_scope,\n+                    ~\"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    ~\"...but borrowed value is only valid for \",\n+                    super_scope,\n+                    ~\"\");\n+          }\n+        }\n+    }\n+\n+\n+    fn cmt_to_str(cmt: cmt) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cmt_to_str(cmt)\n+    }\n+\n+    fn cmt_to_repr(cmt: cmt) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cmt_to_repr(cmt)\n+    }\n+\n+    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.mut_to_str(mutbl)\n+    }\n+\n+    fn loan_to_repr(loan: &Loan) -> ~str {\n+        fmt!(\"Loan(lp=%?, cmt=%s, mutbl=%?)\",\n+             loan.lp, self.cmt_to_repr(loan.cmt), loan.mutbl)\n+    }\n+}\n+\n+// The inherent mutability of a component is its default mutability\n+// assuming it is embedded in an immutable context.  In general, the\n+// mutability can be \"overridden\" if the component is embedded in a\n+// mutable structure.\n+fn inherent_mutability(ck: comp_kind) -> mutability {\n+    match ck {\n+      comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n+      comp_field(_, m) | comp_index(_, m)            => m\n+    }\n+}"}, {"sha": "421c68fa9a21ee7add90dd267ec657af37cd23c4", "filename": "src/librustc/middle/typeck.rs", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibrustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,376 +0,0 @@\n-/*\n-\n-typeck.rs, an introduction\n-\n-The type checker is responsible for:\n-\n-1. Determining the type of each expression\n-2. Resolving methods and traits\n-3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n-   Well, dear reader, read on)\n-\n-The main entry point is `check_crate()`.  Type checking operates in two major\n-phases: collect and check.  The collect phase passes over all items and\n-determines their type, without examining their \"innards\".  The check phase\n-then checks function bodies and so forth.\n-\n-Within the check phase, we check each function body one at a time (bodies of\n-function expressions are checked as part of the containing function).\n-Inference is used to supply types wherever they are unknown. The actual\n-checking of a function itself has several phases (check, regionck, writeback),\n-as discussed in the documentation for the `check` module.\n-\n-The type checker is defined into various submodules which are documented\n-independently:\n-\n-- astconv: converts the AST representation of types\n-  into the `ty` representation\n-\n-- collect: computes the types of each top-level item and enters them into\n-  the `cx.tcache` table for later use\n-\n-- check: walks over function bodies and type checks them, inferring types for\n-  local variables, type parameters, etc as necessary.\n-\n-- infer: finds the types to use for each type variable such that\n-  all subtyping and assignment constraints are met.  In essence, the check\n-  module specifies the constraints, and the infer module solves them.\n-\n-*/\n-\n-use result::Result;\n-use syntax::{ast, ast_util, ast_map};\n-use ast::spanned;\n-use ast::{required, provided};\n-use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::{local_def, respan, split_trait_methods};\n-use syntax::visit;\n-use metadata::csearch;\n-use util::common::{block_query, loop_query};\n-use syntax::codemap::span;\n-use pat_util::{pat_id_map, PatIdMap};\n-use middle::ty;\n-use middle::ty::{arg, field, node_type_table, mk_nil, ty_param_bounds_and_ty};\n-use middle::ty::{ty_param_substs_and_ty, vstore_uniq};\n-use std::smallintmap;\n-use std::map;\n-use std::map::HashMap;\n-use syntax::print::pprust::*;\n-use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n-                  bound_region_to_str, vstore_to_str, expr_repr};\n-use util::common::{indent, indenter};\n-use std::list;\n-use list::{List, Nil, Cons};\n-use dvec::DVec;\n-\n-export check;\n-export check_crate;\n-export infer;\n-export method_map;\n-export method_origin;\n-export method_map_entry;\n-export vtable_map;\n-export vtable_res;\n-export vtable_origin;\n-export method_static, method_param, method_trait, method_self;\n-export vtable_static, vtable_param, vtable_trait;\n-export provided_methods_map;\n-\n-#[auto_serialize]\n-#[auto_deserialize]\n-enum method_origin {\n-    // fully statically resolved method\n-    method_static(ast::def_id),\n-\n-    // method invoked on a type parameter with a bounded trait\n-    method_param(method_param),\n-\n-    // method invoked on a trait instance\n-    method_trait(ast::def_id, uint, ty::vstore),\n-\n-    // method invoked on \"self\" inside a default method\n-    method_self(ast::def_id, uint),\n-}\n-\n-// details for a method invoked with a receiver whose type is a type parameter\n-// with a bounded trait.\n-#[auto_serialize]\n-#[auto_deserialize]\n-type method_param = {\n-    // the trait containing the method to be invoked\n-    trait_id: ast::def_id,\n-\n-    // index of the method to be invoked amongst the trait's methods\n-    method_num: uint,\n-\n-    // index of the type parameter (from those that are in scope) that is\n-    // the type of the receiver\n-    param_num: uint,\n-\n-    // index of the bound for this type parameter which specifies the trait\n-    bound_num: uint\n-};\n-\n-type method_map_entry = {\n-    // the type and mode of the self parameter, which is not reflected\n-    // in the fn type (FIXME #3446)\n-    self_arg: ty::arg,\n-\n-    // method details being invoked\n-    origin: method_origin\n-};\n-\n-// maps from an expression id that corresponds to a method call to the details\n-// of the method to be invoked\n-type method_map = HashMap<ast::node_id, method_map_entry>;\n-\n-// Resolutions for bounds of all parameters, left to right, for a given path.\n-type vtable_res = @~[vtable_origin];\n-\n-enum vtable_origin {\n-    /*\n-      Statically known vtable. def_id gives the class or impl item\n-      from whence comes the vtable, and tys are the type substs.\n-      vtable_res is the vtable itself\n-     */\n-    vtable_static(ast::def_id, ~[ty::t], vtable_res),\n-    /*\n-      Dynamic vtable, comes from a parameter that has a bound on it:\n-      fn foo<T: quux, baz, bar>(a: T) -- a's vtable would have a\n-      vtable_param origin\n-\n-      The first uint is the param number (identifying T in the example),\n-      and the second is the bound number (identifying baz)\n-     */\n-    vtable_param(uint, uint),\n-    /*\n-      Dynamic vtable, comes from something known to have a trait\n-      type. def_id refers to the trait item, tys are the substs\n-     */\n-    vtable_trait(ast::def_id, ~[ty::t]),\n-}\n-\n-impl vtable_origin {\n-    fn to_str(tcx: ty::ctxt) -> ~str {\n-        match self {\n-            vtable_static(def_id, ref tys, ref vtable_res) => {\n-                fmt!(\"vtable_static(%?:%s, %?, %?)\",\n-                     def_id, ty::item_path_str(tcx, def_id),\n-                     tys,\n-                     vtable_res.map(|o| o.to_str(tcx)))\n-            }\n-\n-            vtable_param(x, y) => {\n-                fmt!(\"vtable_param(%?, %?)\", x, y)\n-            }\n-\n-            vtable_trait(def_id, ref tys) => {\n-                fmt!(\"vtable_trait(%?:%s, %?)\",\n-                     def_id, ty::item_path_str(tcx, def_id),\n-                     tys.map(|t| ty_to_str(tcx, *t)))\n-            }\n-        }\n-    }\n-}\n-\n-type vtable_map = HashMap<ast::node_id, vtable_res>;\n-\n-type crate_ctxt_ = {// A mapping from method call sites to traits that have\n-                    // that method.\n-                    trait_map: resolve::TraitMap,\n-                    method_map: method_map,\n-                    vtable_map: vtable_map,\n-                    coherence_info: @coherence::CoherenceInfo,\n-                    tcx: ty::ctxt};\n-\n-enum crate_ctxt {\n-    crate_ctxt_(crate_ctxt_)\n-}\n-\n-// Functions that write types into the node type table\n-fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n-    debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty));\n-    smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n-}\n-fn write_substs_to_tcx(tcx: ty::ctxt,\n-                       node_id: ast::node_id,\n-                       +substs: ~[ty::t]) {\n-    if substs.len() > 0u {\n-        debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n-               substs.map(|t| ty_to_str(tcx, *t)));\n-        tcx.node_type_substs.insert(node_id, substs);\n-    }\n-}\n-\n-fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    match tcx.def_map.find(id) {\n-      Some(x) => x,\n-      _ => {\n-        tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n-      }\n-    }\n-}\n-\n-fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    lookup_def_tcx(ccx.tcx, sp, id)\n-}\n-\n-fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n-    {bounds: @~[], region_param: None, ty: t}\n-}\n-\n-fn require_same_types(\n-    tcx: ty::ctxt,\n-    maybe_infcx: Option<infer::infer_ctxt>,\n-    t1_is_expected: bool,\n-    span: span,\n-    t1: ty::t,\n-    t2: ty::t,\n-    msg: fn() -> ~str) -> bool {\n-\n-    let l_tcx, l_infcx;\n-    match maybe_infcx {\n-      None => {\n-        l_tcx = tcx;\n-        l_infcx = infer::new_infer_ctxt(tcx);\n-      }\n-      Some(i) => {\n-        l_tcx = i.tcx;\n-        l_infcx = i;\n-      }\n-    }\n-\n-    match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n-        result::Ok(()) => true,\n-        result::Err(ref terr) => {\n-            l_tcx.sess.span_err(span, msg() + ~\": \" +\n-                                ty::type_err_to_str(l_tcx, terr));\n-            ty::note_and_explain_type_err(l_tcx, terr);\n-            false\n-        }\n-    }\n-}\n-\n-// a list of mapping from in-scope-region-names (\"isr\") to the\n-// corresponding ty::Region\n-type isr_alist = @List<(ty::bound_region, ty::Region)>;\n-\n-trait get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::Region;\n-    fn find(br: ty::bound_region) -> Option<ty::Region>;\n-}\n-\n-impl isr_alist: get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::Region {\n-        self.find(br).get()\n-    }\n-\n-    fn find(br: ty::bound_region) -> Option<ty::Region> {\n-        for list::each(self) |isr| {\n-            let (isr_br, isr_r) = *isr;\n-            if isr_br == br { return Some(isr_r); }\n-        }\n-        return None;\n-    }\n-}\n-\n-fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n-    match ty::resolved_mode(tcx, a.mode) {\n-        ast::by_val => { /*ok*/ }\n-        _ => {\n-            return false;\n-        }\n-    }\n-\n-    match ty::get(a.ty).sty {\n-      ty::ty_evec(mt, vstore_uniq) => {\n-        if mt.mutbl != ast::m_imm { return false; }\n-        match ty::get(mt.ty).sty {\n-          ty::ty_estr(vstore_uniq) => return true,\n-          _ => return false\n-        }\n-      }\n-      _ => return false\n-    }\n-}\n-\n-fn check_main_fn_ty(ccx: @crate_ctxt,\n-                    main_id: ast::node_id,\n-                    main_span: span) {\n-\n-    let tcx = ccx.tcx;\n-    let main_t = ty::node_id_to_type(tcx, main_id);\n-    match ty::get(main_t).sty {\n-        ty::ty_fn(fn_ty) => {\n-            match tcx.items.find(main_id) {\n-                Some(ast_map::node_item(it,_)) => {\n-                    match it.node {\n-                        ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n-                            tcx.sess.span_err(\n-                                main_span,\n-                                ~\"main function is not allowed \\\n-                                  to have type parameters\");\n-                            return;\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-                _ => ()\n-            }\n-            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n-            let num_args = vec::len(fn_ty.sig.inputs);\n-            ok &= num_args == 0u;\n-            if !ok {\n-                tcx.sess.span_err(\n-                    main_span,\n-                    fmt!(\"Wrong type in main function: found `%s`, \\\n-                          expected `fn() -> ()`\",\n-                         ty_to_str(tcx, main_t)));\n-            }\n-        }\n-        _ => {\n-            tcx.sess.span_bug(main_span,\n-                              ~\"main has a non-function type: found `\" +\n-                              ty_to_str(tcx, main_t) + ~\"`\");\n-        }\n-    }\n-}\n-\n-fn check_for_main_fn(ccx: @crate_ctxt) {\n-    let tcx = ccx.tcx;\n-    if !tcx.sess.building_library {\n-        match copy tcx.sess.main_fn {\n-          Some((id, sp)) => check_main_fn_ty(ccx, id, sp),\n-          None => tcx.sess.err(~\"main function not found\")\n-        }\n-    }\n-}\n-\n-fn check_crate(tcx: ty::ctxt,\n-               trait_map: resolve::TraitMap,\n-               crate: @ast::crate)\n-            -> (method_map, vtable_map) {\n-\n-    let ccx = @crate_ctxt_({trait_map: trait_map,\n-                            method_map: std::map::HashMap(),\n-                            vtable_map: std::map::HashMap(),\n-                            coherence_info: @coherence::CoherenceInfo(),\n-                            tcx: tcx});\n-    collect::collect_item_types(ccx, crate);\n-    coherence::check_coherence(ccx, crate);\n-    deriving::check_deriving(ccx, crate);\n-\n-    check::check_item_types(ccx, crate);\n-    check_for_main_fn(ccx);\n-    tcx.sess.abort_if_errors();\n-    (ccx.method_map, ccx.vtable_map)\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "6241cac2f5d1207cada5efd9752de73dc3e3f01d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,5 +1,83 @@\n+/*\n+\n+typeck.rs, an introduction\n+\n+The type checker is responsible for:\n+\n+1. Determining the type of each expression\n+2. Resolving methods and traits\n+3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n+   Well, dear reader, read on)\n+\n+The main entry point is `check_crate()`.  Type checking operates in two major\n+phases: collect and check.  The collect phase passes over all items and\n+determines their type, without examining their \"innards\".  The check phase\n+then checks function bodies and so forth.\n+\n+Within the check phase, we check each function body one at a time (bodies of\n+function expressions are checked as part of the containing function).\n+Inference is used to supply types wherever they are unknown. The actual\n+checking of a function itself has several phases (check, regionck, writeback),\n+as discussed in the documentation for the `check` module.\n+\n+The type checker is defined into various submodules which are documented\n+independently:\n+\n+- astconv: converts the AST representation of types\n+  into the `ty` representation\n+\n+- collect: computes the types of each top-level item and enters them into\n+  the `cx.tcache` table for later use\n+\n+- check: walks over function bodies and type checks them, inferring types for\n+  local variables, type parameters, etc as necessary.\n+\n+- infer: finds the types to use for each type variable such that\n+  all subtyping and assignment constraints are met.  In essence, the check\n+  module specifies the constraints, and the infer module solves them.\n+\n+*/\n+\n #[legacy_exports];\n \n+use result::Result;\n+use syntax::{ast, ast_util, ast_map};\n+use ast::spanned;\n+use ast::{required, provided};\n+use syntax::ast_map::node_id_to_str;\n+use syntax::ast_util::{local_def, respan, split_trait_methods};\n+use syntax::visit;\n+use metadata::csearch;\n+use util::common::{block_query, loop_query};\n+use syntax::codemap::span;\n+use pat_util::{pat_id_map, PatIdMap};\n+use middle::ty;\n+use middle::ty::{arg, field, node_type_table, mk_nil, ty_param_bounds_and_ty};\n+use middle::ty::{ty_param_substs_and_ty, vstore_uniq};\n+use std::smallintmap;\n+use std::map;\n+use std::map::HashMap;\n+use syntax::print::pprust::*;\n+use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n+                  bound_region_to_str, vstore_to_str, expr_repr};\n+use util::common::{indent, indenter};\n+use std::list;\n+use list::{List, Nil, Cons};\n+use dvec::DVec;\n+\n+export check;\n+export check_crate;\n+export infer;\n+export method_map;\n+export method_origin;\n+export method_map_entry;\n+export vtable_map;\n+export vtable_res;\n+export vtable_origin;\n+export method_static, method_param, method_trait, method_self;\n+export vtable_static, vtable_param, vtable_trait;\n+export provided_methods_map;\n+\n #[legacy_exports]\n #[merge = \"check/mod.rs\"]\n pub mod check;\n@@ -14,3 +92,302 @@ mod collect;\n #[legacy_exports]\n mod coherence;\n mod deriving;\n+\n+#[auto_serialize]\n+#[auto_deserialize]\n+enum method_origin {\n+    // fully statically resolved method\n+    method_static(ast::def_id),\n+\n+    // method invoked on a type parameter with a bounded trait\n+    method_param(method_param),\n+\n+    // method invoked on a trait instance\n+    method_trait(ast::def_id, uint, ty::vstore),\n+\n+    // method invoked on \"self\" inside a default method\n+    method_self(ast::def_id, uint),\n+}\n+\n+// details for a method invoked with a receiver whose type is a type parameter\n+// with a bounded trait.\n+#[auto_serialize]\n+#[auto_deserialize]\n+type method_param = {\n+    // the trait containing the method to be invoked\n+    trait_id: ast::def_id,\n+\n+    // index of the method to be invoked amongst the trait's methods\n+    method_num: uint,\n+\n+    // index of the type parameter (from those that are in scope) that is\n+    // the type of the receiver\n+    param_num: uint,\n+\n+    // index of the bound for this type parameter which specifies the trait\n+    bound_num: uint\n+};\n+\n+type method_map_entry = {\n+    // the type and mode of the self parameter, which is not reflected\n+    // in the fn type (FIXME #3446)\n+    self_arg: ty::arg,\n+\n+    // method details being invoked\n+    origin: method_origin\n+};\n+\n+// maps from an expression id that corresponds to a method call to the details\n+// of the method to be invoked\n+type method_map = HashMap<ast::node_id, method_map_entry>;\n+\n+// Resolutions for bounds of all parameters, left to right, for a given path.\n+type vtable_res = @~[vtable_origin];\n+\n+enum vtable_origin {\n+    /*\n+      Statically known vtable. def_id gives the class or impl item\n+      from whence comes the vtable, and tys are the type substs.\n+      vtable_res is the vtable itself\n+     */\n+    vtable_static(ast::def_id, ~[ty::t], vtable_res),\n+    /*\n+      Dynamic vtable, comes from a parameter that has a bound on it:\n+      fn foo<T: quux, baz, bar>(a: T) -- a's vtable would have a\n+      vtable_param origin\n+\n+      The first uint is the param number (identifying T in the example),\n+      and the second is the bound number (identifying baz)\n+     */\n+    vtable_param(uint, uint),\n+    /*\n+      Dynamic vtable, comes from something known to have a trait\n+      type. def_id refers to the trait item, tys are the substs\n+     */\n+    vtable_trait(ast::def_id, ~[ty::t]),\n+}\n+\n+impl vtable_origin {\n+    fn to_str(tcx: ty::ctxt) -> ~str {\n+        match self {\n+            vtable_static(def_id, ref tys, ref vtable_res) => {\n+                fmt!(\"vtable_static(%?:%s, %?, %?)\",\n+                     def_id, ty::item_path_str(tcx, def_id),\n+                     tys,\n+                     vtable_res.map(|o| o.to_str(tcx)))\n+            }\n+\n+            vtable_param(x, y) => {\n+                fmt!(\"vtable_param(%?, %?)\", x, y)\n+            }\n+\n+            vtable_trait(def_id, ref tys) => {\n+                fmt!(\"vtable_trait(%?:%s, %?)\",\n+                     def_id, ty::item_path_str(tcx, def_id),\n+                     tys.map(|t| ty_to_str(tcx, *t)))\n+            }\n+        }\n+    }\n+}\n+\n+type vtable_map = HashMap<ast::node_id, vtable_res>;\n+\n+type crate_ctxt_ = {// A mapping from method call sites to traits that have\n+                    // that method.\n+                    trait_map: resolve::TraitMap,\n+                    method_map: method_map,\n+                    vtable_map: vtable_map,\n+                    coherence_info: @coherence::CoherenceInfo,\n+                    tcx: ty::ctxt};\n+\n+enum crate_ctxt {\n+    crate_ctxt_(crate_ctxt_)\n+}\n+\n+// Functions that write types into the node type table\n+fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+    debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty));\n+    smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n+}\n+fn write_substs_to_tcx(tcx: ty::ctxt,\n+                       node_id: ast::node_id,\n+                       +substs: ~[ty::t]) {\n+    if substs.len() > 0u {\n+        debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n+               substs.map(|t| ty_to_str(tcx, *t)));\n+        tcx.node_type_substs.insert(node_id, substs);\n+    }\n+}\n+\n+fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n+    match tcx.def_map.find(id) {\n+      Some(x) => x,\n+      _ => {\n+        tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n+      }\n+    }\n+}\n+\n+fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+    lookup_def_tcx(ccx.tcx, sp, id)\n+}\n+\n+fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n+    {bounds: @~[], region_param: None, ty: t}\n+}\n+\n+fn require_same_types(\n+    tcx: ty::ctxt,\n+    maybe_infcx: Option<infer::infer_ctxt>,\n+    t1_is_expected: bool,\n+    span: span,\n+    t1: ty::t,\n+    t2: ty::t,\n+    msg: fn() -> ~str) -> bool {\n+\n+    let l_tcx, l_infcx;\n+    match maybe_infcx {\n+      None => {\n+        l_tcx = tcx;\n+        l_infcx = infer::new_infer_ctxt(tcx);\n+      }\n+      Some(i) => {\n+        l_tcx = i.tcx;\n+        l_infcx = i;\n+      }\n+    }\n+\n+    match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n+        result::Ok(()) => true,\n+        result::Err(ref terr) => {\n+            l_tcx.sess.span_err(span, msg() + ~\": \" +\n+                                ty::type_err_to_str(l_tcx, terr));\n+            ty::note_and_explain_type_err(l_tcx, terr);\n+            false\n+        }\n+    }\n+}\n+\n+// a list of mapping from in-scope-region-names (\"isr\") to the\n+// corresponding ty::Region\n+type isr_alist = @List<(ty::bound_region, ty::Region)>;\n+\n+trait get_and_find_region {\n+    fn get(br: ty::bound_region) -> ty::Region;\n+    fn find(br: ty::bound_region) -> Option<ty::Region>;\n+}\n+\n+impl isr_alist: get_and_find_region {\n+    fn get(br: ty::bound_region) -> ty::Region {\n+        self.find(br).get()\n+    }\n+\n+    fn find(br: ty::bound_region) -> Option<ty::Region> {\n+        for list::each(self) |isr| {\n+            let (isr_br, isr_r) = *isr;\n+            if isr_br == br { return Some(isr_r); }\n+        }\n+        return None;\n+    }\n+}\n+\n+fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n+    match ty::resolved_mode(tcx, a.mode) {\n+        ast::by_val => { /*ok*/ }\n+        _ => {\n+            return false;\n+        }\n+    }\n+\n+    match ty::get(a.ty).sty {\n+      ty::ty_evec(mt, vstore_uniq) => {\n+        if mt.mutbl != ast::m_imm { return false; }\n+        match ty::get(mt.ty).sty {\n+          ty::ty_estr(vstore_uniq) => return true,\n+          _ => return false\n+        }\n+      }\n+      _ => return false\n+    }\n+}\n+\n+fn check_main_fn_ty(ccx: @crate_ctxt,\n+                    main_id: ast::node_id,\n+                    main_span: span) {\n+\n+    let tcx = ccx.tcx;\n+    let main_t = ty::node_id_to_type(tcx, main_id);\n+    match ty::get(main_t).sty {\n+        ty::ty_fn(fn_ty) => {\n+            match tcx.items.find(main_id) {\n+                Some(ast_map::node_item(it,_)) => {\n+                    match it.node {\n+                        ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n+                            tcx.sess.span_err(\n+                                main_span,\n+                                ~\"main function is not allowed \\\n+                                  to have type parameters\");\n+                            return;\n+                        }\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n+            let num_args = vec::len(fn_ty.sig.inputs);\n+            ok &= num_args == 0u;\n+            if !ok {\n+                tcx.sess.span_err(\n+                    main_span,\n+                    fmt!(\"Wrong type in main function: found `%s`, \\\n+                          expected `fn() -> ()`\",\n+                         ty_to_str(tcx, main_t)));\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(main_span,\n+                              ~\"main has a non-function type: found `\" +\n+                              ty_to_str(tcx, main_t) + ~\"`\");\n+        }\n+    }\n+}\n+\n+fn check_for_main_fn(ccx: @crate_ctxt) {\n+    let tcx = ccx.tcx;\n+    if !tcx.sess.building_library {\n+        match copy tcx.sess.main_fn {\n+          Some((id, sp)) => check_main_fn_ty(ccx, id, sp),\n+          None => tcx.sess.err(~\"main function not found\")\n+        }\n+    }\n+}\n+\n+fn check_crate(tcx: ty::ctxt,\n+               trait_map: resolve::TraitMap,\n+               crate: @ast::crate)\n+            -> (method_map, vtable_map) {\n+\n+    let ccx = @crate_ctxt_({trait_map: trait_map,\n+                            method_map: std::map::HashMap(),\n+                            vtable_map: std::map::HashMap(),\n+                            coherence_info: @coherence::CoherenceInfo(),\n+                            tcx: tcx});\n+    collect::collect_item_types(ccx, crate);\n+    coherence::check_coherence(ccx, crate);\n+    deriving::check_deriving(ccx, crate);\n+\n+    check::check_item_types(ccx, crate);\n+    check_for_main_fn(ccx);\n+    tcx.sess.abort_if_errors();\n+    (ccx.method_map, ccx.vtable_map)\n+}\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "14af4bc443e93acbeb3799bf950e3e56dc664563", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -122,8 +122,7 @@ mod middle {\n     #[legacy_exports]\n     #[path = \"middle/resolve.rs\"]\n     mod resolve;\n-    #[path = \"middle/typeck.rs\"]\n-    #[merge = \"middle/typeck/mod.rs\"]\n+    #[path = \"middle/typeck/mod.rs\"]\n     pub mod typeck;\n     #[legacy_exports]\n     #[path = \"middle/check_loop.rs\"]\n@@ -137,8 +136,7 @@ mod middle {\n     #[legacy_exports]\n     #[path = \"middle/lint.rs\"]\n     mod lint;\n-    #[path = \"middle/borrowck.rs\"]\n-    #[merge = \"middle/borrowck/mod.rs\"]\n+    #[path = \"middle/borrowck/mod.rs\"]\n     mod borrowck;\n     #[legacy_exports]\n     #[path = \"middle/mem_categorization.rs\"]\n@@ -216,10 +214,10 @@ mod back {\n     mod target_strs;\n }\n \n-#[merge = \"metadata/mod.rs\"]\n+#[path = \"metadata/mod.rs\"]\n mod metadata;\n \n-#[merge = \"driver/mod.rs\"]\n+#[path = \"driver/mod.rs\"]\n mod driver;\n \n mod util {"}, {"sha": "b4c49b12d5936c3f35ebac8e2a0f0080d8bb16e5", "filename": "src/libsyntax/ext/pipes.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,67 +0,0 @@\n-/*! Implementation of proto! extension.\n-\n-This is frequently called the pipe compiler. It handles code such as...\n-\n-~~~\n-proto! pingpong (\n-    ping: send {\n-        ping -> pong\n-    }\n-    pong: recv {\n-        pong -> ping\n-    }\n-)\n-~~~\n-\n-There are several components:\n-\n- * The parser (libsyntax/ext/pipes/parse_proto.rs)\n-   * Responsible for building an AST from a protocol specification.\n-\n- * The checker (libsyntax/ext/pipes/check.rs)\n-   * Basic correctness checking for protocols (i.e. no undefined states, etc.)\n-\n- * The analyzer (libsyntax/ext/pipes/liveness.rs)\n-   * Determines whether the protocol is bounded or unbounded.\n-\n- * The compiler (libsynatx/ext/pipes/pipec.rs)\n-   * Generates a Rust AST from the protocol AST and the results of analysis.\n-\n-There is more documentation in each of the files referenced above.\n-\n-FIXME (#3072) - This is still incomplete.\n-\n-*/\n-\n-use codemap::span;\n-use ext::base::ext_ctxt;\n-use ast::tt_delim;\n-use parse::lexer::{new_tt_reader, reader};\n-use parse::parser::Parser;\n-use parse::common::parser_common;\n-\n-use pipes::parse_proto::proto_parser;\n-\n-use pipes::proto::{visit, protocol};\n-\n-fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n-                tt: ~[ast::token_tree]) -> base::mac_result\n-{\n-    let sess = cx.parse_sess();\n-    let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, tt);\n-    let rdr = tt_rdr as reader;\n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n-\n-    let proto = rust_parser.parse_proto(cx.str_of(id));\n-\n-    // check for errors\n-    visit(proto, cx);\n-\n-    // do analysis\n-    liveness::analyze(proto, cx);\n-\n-    // compile\n-    base::mr_item(proto.compile(cx))\n-}"}, {"sha": "b064f39eb3a1c675289dfa55f41e111d53ea7e57", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,3 +1,49 @@\n+/*! Implementation of proto! extension.\n+\n+This is frequently called the pipe compiler. It handles code such as...\n+\n+~~~\n+proto! pingpong (\n+    ping: send {\n+        ping -> pong\n+    }\n+    pong: recv {\n+        pong -> ping\n+    }\n+)\n+~~~\n+\n+There are several components:\n+\n+ * The parser (libsyntax/ext/pipes/parse_proto.rs)\n+   * Responsible for building an AST from a protocol specification.\n+\n+ * The checker (libsyntax/ext/pipes/check.rs)\n+   * Basic correctness checking for protocols (i.e. no undefined states, etc.)\n+\n+ * The analyzer (libsyntax/ext/pipes/liveness.rs)\n+   * Determines whether the protocol is bounded or unbounded.\n+\n+ * The compiler (libsynatx/ext/pipes/pipec.rs)\n+   * Generates a Rust AST from the protocol AST and the results of analysis.\n+\n+There is more documentation in each of the files referenced above.\n+\n+FIXME (#3072) - This is still incomplete.\n+\n+*/\n+\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ast::tt_delim;\n+use parse::lexer::{new_tt_reader, reader};\n+use parse::parser::Parser;\n+use parse::common::parser_common;\n+\n+use pipes::parse_proto::proto_parser;\n+\n+use pipes::proto::{visit, protocol};\n+\n #[legacy_exports]\n mod ast_builder;\n #[legacy_exports]\n@@ -10,3 +56,27 @@ mod proto;\n mod check;\n #[legacy_exports]\n mod liveness;\n+\n+\n+fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n+                tt: ~[ast::token_tree]) -> base::mac_result\n+{\n+    let sess = cx.parse_sess();\n+    let cfg = cx.cfg();\n+    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+                               cx.parse_sess().interner, None, tt);\n+    let rdr = tt_rdr as reader;\n+    let rust_parser = Parser(sess, cfg, rdr.dup());\n+\n+    let proto = rust_parser.parse_proto(cx.str_of(id));\n+\n+    // check for errors\n+    visit(proto, cx);\n+\n+    // do analysis\n+    liveness::analyze(proto, cx);\n+\n+    // compile\n+    base::mr_item(proto.compile(cx))\n+}\n+"}, {"sha": "9d243556c037039a04d999b84b1b0cca8c0fcd5f", "filename": "src/libsyntax/parse.rs", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b95d511316ae7124046de61d19335fdfaa021cc/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=9b95d511316ae7124046de61d19335fdfaa021cc", "patch": "@@ -1,196 +0,0 @@\n-//! The main parser interface\n-\n-#[legacy_exports];\n-\n-export parser;\n-export common;\n-export lexer;\n-export token;\n-export comments;\n-export prec;\n-export classify;\n-export attr;\n-\n-export parse_sess;\n-export new_parse_sess, new_parse_sess_special_handler;\n-export next_node_id;\n-export new_parser_from_file, new_parser_etc_from_file;\n-export new_parser_from_source_str;\n-export new_parser_from_tts;\n-export new_sub_parser_from_file;\n-export parse_crate_from_file, parse_crate_from_crate_file;\n-export parse_crate_from_source_str;\n-export parse_expr_from_source_str, parse_item_from_source_str;\n-export parse_stmt_from_source_str;\n-export parse_tts_from_source_str;\n-export parse_from_source_str;\n-\n-use parser::Parser;\n-use attr::parser_attr;\n-use common::parser_common;\n-use ast::node_id;\n-use util::interner;\n-use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n-use lexer::{reader, string_reader};\n-use parse::token::{ident_interner, mk_ident_interner};\n-use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n-\n-type parse_sess = @{\n-    cm: @codemap::CodeMap,\n-    mut next_id: node_id,\n-    span_diagnostic: span_handler,\n-    interner: @ident_interner,\n-};\n-\n-fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n-    let cm = @CodeMap::new();\n-    return @{cm: cm,\n-             mut next_id: 1,\n-             span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-             interner: mk_ident_interner(),\n-            };\n-}\n-\n-fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n-    -> parse_sess {\n-    return @{cm: cm,\n-             mut next_id: 1,\n-             span_diagnostic: sh,\n-             interner: mk_ident_interner(),\n-             };\n-}\n-\n-fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n-                         sess: parse_sess) -> @ast::crate {\n-    let p = new_crate_parser_from_file(sess, cfg, input);\n-    let r = p.parse_crate_mod(cfg);\n-    return r;\n-}\n-\n-fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n-                               sess: parse_sess) -> @ast::crate {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    let r = p.parse_crate_mod(cfg);\n-    p.abort_if_errors();\n-    return r;\n-}\n-\n-fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n-                              sess: parse_sess) -> @ast::expr {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    let r = p.parse_expr();\n-    p.abort_if_errors();\n-    return r;\n-}\n-\n-fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n-                              +attrs: ~[ast::attribute],\n-                              sess: parse_sess) -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    let r = p.parse_item(attrs);\n-    p.abort_if_errors();\n-    return r;\n-}\n-\n-fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n-                              +attrs: ~[ast::attribute],\n-                              sess: parse_sess) -> @ast::stmt {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    let r = p.parse_stmt(attrs);\n-    p.abort_if_errors();\n-    return r;\n-}\n-\n-fn parse_tts_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n-                             sess: parse_sess) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    p.quote_depth += 1u;\n-    let r = p.parse_all_token_trees();\n-    p.abort_if_errors();\n-    return r;\n-}\n-\n-fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n-                            name: ~str, ss: codemap::FileSubstr,\n-                            source: @~str, cfg: ast::crate_cfg,\n-                            sess: parse_sess)\n-    -> T\n-{\n-    let p = new_parser_from_source_str(sess, cfg, name, ss,\n-                                       source);\n-    let r = f(p);\n-    if !p.reader.is_eof() {\n-        p.reader.fatal(~\"expected end-of-string\");\n-    }\n-    p.abort_if_errors();\n-    move r\n-}\n-\n-fn next_node_id(sess: parse_sess) -> node_id {\n-    let rv = sess.next_id;\n-    sess.next_id += 1;\n-    // ID 0 is reserved for the crate and doesn't actually exist in the AST\n-    assert rv != 0;\n-    return rv;\n-}\n-\n-fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                              +name: ~str, +ss: codemap::FileSubstr,\n-                              source: @~str) -> Parser {\n-    let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n-                                        sess.interner);\n-    return Parser(sess, cfg, srdr as reader);\n-}\n-\n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                        path: &Path) -> Result<Parser, ~str> {\n-    match io::read_whole_file_str(path) {\n-      result::Ok(move src) => {\n-\n-          let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n-          let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n-                                              sess.interner);\n-\n-          Ok(Parser(sess, cfg, srdr as reader))\n-\n-      }\n-      result::Err(move e) => Err(move e)\n-    }\n-}\n-\n-/// Create a new parser for an entire crate, handling errors as appropriate\n-/// if the file doesn't exist\n-fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                              path: &Path) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n-            sess.span_diagnostic.handler().fatal(e)\n-        }\n-    }\n-}\n-\n-/// Create a new parser based on a span from an existing parser. Handles\n-/// error messages correctly when the file does not exist.\n-fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                            path: &Path, sp: span) -> Parser {\n-    match new_parser_from_file(sess, cfg, path) {\n-        Ok(move parser) => move parser,\n-        Err(move e) => {\n-            sess.span_diagnostic.span_fatal(sp, e)\n-        }\n-    }\n-}\n-\n-fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n-                       tts: ~[ast::token_tree]) -> Parser {\n-    let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n-                                    None, tts);\n-    return Parser(sess, cfg, trdr as reader)\n-}"}, {"sha": "c290e7cf30731738cefafd031af3bbbd49af4caa", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -1,3 +1,40 @@\n+//! The main parser interface\n+\n+#[legacy_exports];\n+\n+export parser;\n+export common;\n+export lexer;\n+export token;\n+export comments;\n+export prec;\n+export classify;\n+export attr;\n+\n+export parse_sess;\n+export new_parse_sess, new_parse_sess_special_handler;\n+export next_node_id;\n+export new_parser_from_file, new_parser_etc_from_file;\n+export new_parser_from_source_str;\n+export new_parser_from_tts;\n+export new_sub_parser_from_file;\n+export parse_crate_from_file, parse_crate_from_crate_file;\n+export parse_crate_from_source_str;\n+export parse_expr_from_source_str, parse_item_from_source_str;\n+export parse_stmt_from_source_str;\n+export parse_tts_from_source_str;\n+export parse_from_source_str;\n+\n+use parser::Parser;\n+use attr::parser_attr;\n+use common::parser_common;\n+use ast::node_id;\n+use util::interner;\n+use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n+use lexer::{reader, string_reader};\n+use parse::token::{ident_interner, mk_ident_interner};\n+use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n+\n \n #[legacy_exports]\n mod lexer;\n@@ -26,3 +63,164 @@ mod classify;\n /// Reporting obsolete syntax\n #[legacy_exports]\n mod obsolete;\n+\n+\n+type parse_sess = @{\n+    cm: @codemap::CodeMap,\n+    mut next_id: node_id,\n+    span_diagnostic: span_handler,\n+    interner: @ident_interner,\n+};\n+\n+fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n+    let cm = @CodeMap::new();\n+    return @{cm: cm,\n+             mut next_id: 1,\n+             span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n+             interner: mk_ident_interner(),\n+            };\n+}\n+\n+fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n+    -> parse_sess {\n+    return @{cm: cm,\n+             mut next_id: 1,\n+             span_diagnostic: sh,\n+             interner: mk_ident_interner(),\n+             };\n+}\n+\n+fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n+                         sess: parse_sess) -> @ast::crate {\n+    let p = new_crate_parser_from_file(sess, cfg, input);\n+    let r = p.parse_crate_mod(cfg);\n+    return r;\n+}\n+\n+fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                               sess: parse_sess) -> @ast::crate {\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n+    let r = p.parse_crate_mod(cfg);\n+    p.abort_if_errors();\n+    return r;\n+}\n+\n+fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                              sess: parse_sess) -> @ast::expr {\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n+    let r = p.parse_expr();\n+    p.abort_if_errors();\n+    return r;\n+}\n+\n+fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                              +attrs: ~[ast::attribute],\n+                              sess: parse_sess) -> Option<@ast::item> {\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n+    let r = p.parse_item(attrs);\n+    p.abort_if_errors();\n+    return r;\n+}\n+\n+fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                              +attrs: ~[ast::attribute],\n+                              sess: parse_sess) -> @ast::stmt {\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n+    let r = p.parse_stmt(attrs);\n+    p.abort_if_errors();\n+    return r;\n+}\n+\n+fn parse_tts_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n+                             sess: parse_sess) -> ~[ast::token_tree] {\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n+    p.quote_depth += 1u;\n+    let r = p.parse_all_token_trees();\n+    p.abort_if_errors();\n+    return r;\n+}\n+\n+fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n+                            name: ~str, ss: codemap::FileSubstr,\n+                            source: @~str, cfg: ast::crate_cfg,\n+                            sess: parse_sess)\n+    -> T\n+{\n+    let p = new_parser_from_source_str(sess, cfg, name, ss,\n+                                       source);\n+    let r = f(p);\n+    if !p.reader.is_eof() {\n+        p.reader.fatal(~\"expected end-of-string\");\n+    }\n+    p.abort_if_errors();\n+    move r\n+}\n+\n+fn next_node_id(sess: parse_sess) -> node_id {\n+    let rv = sess.next_id;\n+    sess.next_id += 1;\n+    // ID 0 is reserved for the crate and doesn't actually exist in the AST\n+    assert rv != 0;\n+    return rv;\n+}\n+\n+fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n+                              +name: ~str, +ss: codemap::FileSubstr,\n+                              source: @~str) -> Parser {\n+    let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n+    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+                                        sess.interner);\n+    return Parser(sess, cfg, srdr as reader);\n+}\n+\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                        path: &Path) -> Result<Parser, ~str> {\n+    match io::read_whole_file_str(path) {\n+      result::Ok(move src) => {\n+\n+          let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n+          let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+                                              sess.interner);\n+\n+          Ok(Parser(sess, cfg, srdr as reader))\n+\n+      }\n+      result::Err(move e) => Err(move e)\n+    }\n+}\n+\n+/// Create a new parser for an entire crate, handling errors as appropriate\n+/// if the file doesn't exist\n+fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                              path: &Path) -> Parser {\n+    match new_parser_from_file(sess, cfg, path) {\n+        Ok(move parser) => move parser,\n+        Err(move e) => {\n+            sess.span_diagnostic.handler().fatal(e)\n+        }\n+    }\n+}\n+\n+/// Create a new parser based on a span from an existing parser. Handles\n+/// error messages correctly when the file does not exist.\n+fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                            path: &Path, sp: span) -> Parser {\n+    match new_parser_from_file(sess, cfg, path) {\n+        Ok(move parser) => move parser,\n+        Err(move e) => {\n+            sess.span_diagnostic.span_fatal(sp, e)\n+        }\n+    }\n+}\n+\n+fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n+                       tts: ~[ast::token_tree]) -> Parser {\n+    let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n+                                    None, tts);\n+    return Parser(sess, cfg, trdr as reader)\n+}"}, {"sha": "60036fe7737c15138f29a6690605de88dcb40b6d", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/65bd40e300323f1e4806dd84834b8d71bb89c08c/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=65bd40e300323f1e4806dd84834b8d71bb89c08c", "patch": "@@ -44,7 +44,7 @@ mod util {\n     mod interner;\n }\n \n-#[merge = \"parse/mod.rs\"]\n+#[path = \"parse/mod.rs\"]\n mod parse;\n \n mod print {\n@@ -118,8 +118,7 @@ mod ext {\n     mod source_util;\n \n     #[legacy_exports]\n-    #[path = \"ext/pipes.rs\"]\n-    #[merge = \"ext/pipes/mod.rs\"]\n+    #[path = \"ext/pipes/mod.rs\"]\n     mod pipes;\n \n     #[legacy_exports]"}]}