{"sha": "75e23e1b032d87300392a4f3835bde8d5d873823", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZTIzZTFiMDMyZDg3MzAwMzkyYTRmMzgzNWJkZThkNWQ4NzM4MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T01:10:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T01:10:53Z"}, "message": "Auto merge of #33137 - nikomatsakis:issue-32330-lbr-in-return-type-warning-2, r=aturon\n\nWarnings for issue #32330\n\nThis is an extension of the previous PR that issues warnings in more situations than before. It does not handle *all* cases of #32330 but I believe it issues warnings for all cases I've seen in practice.\n\nBefore merging I'd like to address:\n\n- open a good issue explaining the problem and how to fix it (I have a [draft writeup][])\n- work on the error message, which I think is not as clear as it could/should be (suggestions welcome)\n\nr? @aturon\n\n[draft writeup]: https://gist.github.com/nikomatsakis/631ec8b4af9a18b5d062d9d9b7d3d967", "tree": {"sha": "82f44282079fd2ff88f8cb45e5877441546867a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82f44282079fd2ff88f8cb45e5877441546867a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75e23e1b032d87300392a4f3835bde8d5d873823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75e23e1b032d87300392a4f3835bde8d5d873823", "html_url": "https://github.com/rust-lang/rust/commit/75e23e1b032d87300392a4f3835bde8d5d873823", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75e23e1b032d87300392a4f3835bde8d5d873823/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0667ae93fb72eb25594258e55de9b4ae8f9f02a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0667ae93fb72eb25594258e55de9b4ae8f9f02a8", "html_url": "https://github.com/rust-lang/rust/commit/0667ae93fb72eb25594258e55de9b4ae8f9f02a8"}, {"sha": "639890d92da1bbe62dc669ff1a122a23da7bc0cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/639890d92da1bbe62dc669ff1a122a23da7bc0cd", "html_url": "https://github.com/rust-lang/rust/commit/639890d92da1bbe62dc669ff1a122a23da7bc0cd"}], "stats": {"total": 993, "additions": 760, "deletions": 233}, "files": [{"sha": "d7971cd2cf040743dfec64b62ca6e6bf09a7974a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -167,6 +167,13 @@ declare_lint! {\n     \"transmute from function item type to pointer-sized type erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub HR_LIFETIME_IN_ASSOC_TYPE,\n+    Warn,\n+    \"binding for associated type references higher-ranked lifetime \\\n+     that does not appear in the trait input types\"\n+}\n+\n declare_lint! {\n     pub OVERLAPPING_INHERENT_IMPLS,\n     Warn,\n@@ -234,7 +241,8 @@ impl LintPass for HardwiredLints {\n             RENAMED_AND_REMOVED_LINTS,\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n             UNSIZED_IN_TUPLE,\n-            OBJECT_UNSAFE_FRAGMENT\n+            OBJECT_UNSAFE_FRAGMENT,\n+            HR_LIFETIME_IN_ASSOC_TYPE\n         )\n     }\n }"}, {"sha": "5c7095beb79c8e6221aa99dbbb9931061b93ed7c", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 281, "deletions": 188, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -152,14 +152,8 @@ enum ProjectionTyCandidate<'tcx> {\n     // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n-    // defined in an impl\n-    Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n-\n-    // closure return type\n-    Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n-\n-    // fn pointer return type\n-    FnPointer(VtableFnPointerData<'tcx, PredicateObligation<'tcx>>),\n+    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    Select,\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n@@ -599,10 +593,8 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n         candidates.vec.retain(|c| match *c {\n             ProjectionTyCandidate::ParamEnv(..) => true,\n-            ProjectionTyCandidate::Impl(..) |\n-            ProjectionTyCandidate::Closure(..) |\n             ProjectionTyCandidate::TraitDef(..) |\n-            ProjectionTyCandidate::FnPointer(..) => false,\n+            ProjectionTyCandidate::Select => false,\n         });\n         debug!(\"resulting candidate set: {:?}\", candidates.vec);\n         if candidates.vec.len() != 1 {\n@@ -612,78 +604,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n \n     assert!(candidates.vec.len() <= 1);\n \n-    let possible_candidate = candidates.vec.pop().and_then(|candidate| {\n-        // In Any (i.e. trans) mode, all projections succeed;\n-        // otherwise, we need to be sensitive to `default` and\n-        // specialization.\n-        if !selcx.projection_mode().is_any() {\n-            if let ProjectionTyCandidate::Impl(ref impl_data) = candidate {\n-                if let Some(node_item) = assoc_ty_def(selcx,\n-                                                      impl_data.impl_def_id,\n-                                                      obligation.predicate.item_name) {\n-                    if node_item.node.is_from_trait() {\n-                        if node_item.item.ty.is_some() {\n-                            // If the associated type has a default from the\n-                            // trait, that should be considered `default` and\n-                            // hence not projected.\n-                            //\n-                            // Note, however, that we allow a projection from\n-                            // the trait specifically in the case that the trait\n-                            // does *not* give a default. This is purely to\n-                            // avoid spurious errors: the situation can only\n-                            // arise when *no* impl in the specialization chain\n-                            // has provided a definition for the type. When we\n-                            // confirm the candidate, we'll turn the projection\n-                            // into a TyError, since the actual error will be\n-                            // reported in `check_impl_items_against_trait`.\n-                            return None;\n-                        }\n-                    } else if node_item.item.defaultness.is_default() {\n-                        return None;\n-                    }\n-                } else {\n-                    // Normally this situation could only arise througha\n-                    // compiler bug, but at coherence-checking time we only look\n-                    // at the topmost impl (we don't even consider the trait\n-                    // itself) for the definition -- so we can fail to find a\n-                    // definition of the type even if it exists.\n-\n-                    // For now, we just unconditionally ICE, because otherwise,\n-                    // examples like the following will succeed:\n-                    //\n-                    // ```\n-                    // trait Assoc {\n-                    //     type Output;\n-                    // }\n-                    //\n-                    // impl<T> Assoc for T {\n-                    //     default type Output = bool;\n-                    // }\n-                    //\n-                    // impl Assoc for u8 {}\n-                    // impl Assoc for u16 {}\n-                    //\n-                    // trait Foo {}\n-                    // impl Foo for <u8 as Assoc>::Output {}\n-                    // impl Foo for <u16 as Assoc>::Output {}\n-                    //     return None;\n-                    // }\n-                    // ```\n-                    //\n-                    // The essential problem here is that the projection fails,\n-                    // leaving two unnormalized types, which appear not to unify\n-                    // -- so the overlap check succeeds, when it should fail.\n-                    bug!(\"Tried to project an inherited associated type during \\\n-                          coherence checking, which is currently not supported.\");\n-                }\n-            }\n-        }\n-        Some(candidate)\n-    });\n-\n-    match possible_candidate {\n+    match candidates.vec.pop() {\n         Some(candidate) => {\n-            let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n+            let (ty, obligations) = confirm_candidate(selcx,\n+                                                      obligation,\n+                                                      &obligation_trait_ref,\n+                                                      candidate);\n             Ok(ProjectedTy::Progress(ty, obligations))\n         }\n         None => {\n@@ -802,38 +728,6 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     }\n }\n \n-fn assemble_candidates_from_object_type<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-{\n-    let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n-    debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n-           object_ty);\n-    let data = match object_ty.sty {\n-        ty::TyTrait(ref data) => data,\n-        _ => {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"assemble_candidates_from_object_type called with non-object: {:?}\",\n-                object_ty);\n-        }\n-    };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n-    let env_predicates = projection_bounds.iter()\n-                                          .map(|p| p.to_predicate())\n-                                          .collect();\n-    let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-    assemble_candidates_from_predicates(selcx,\n-                                        obligation,\n-                                        obligation_trait_ref,\n-                                        candidate_set,\n-                                        ProjectionTyCandidate::ParamEnv,\n-                                        env_predicates)\n-}\n-\n fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n@@ -845,82 +739,183 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let vtable = match selcx.select(&trait_obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        Ok(None) => {\n-            candidate_set.ambiguous = true;\n-            return Ok(());\n-        }\n-        Err(e) => {\n-            debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n-                   e);\n-            return Err(e);\n-        }\n-    };\n+    selcx.infcx().probe(|_| {\n+        let vtable = match selcx.select(&trait_obligation) {\n+            Ok(Some(vtable)) => vtable,\n+            Ok(None) => {\n+                candidate_set.ambiguous = true;\n+                return Ok(());\n+            }\n+            Err(e) => {\n+                debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n+                       e);\n+                return Err(e);\n+            }\n+        };\n \n-    match vtable {\n-        super::VtableImpl(data) => {\n-            debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n-                   data);\n+        match vtable {\n+            super::VtableClosure(_) |\n+            super::VtableFnPointer(_) |\n+            super::VtableObject(_) => {\n+                debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n+                       vtable);\n \n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::Impl(data));\n-        }\n-        super::VtableObject(_) => {\n-            assemble_candidates_from_object_type(\n-                selcx, obligation, obligation_trait_ref, candidate_set);\n-        }\n-        super::VtableClosure(data) => {\n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::Closure(data));\n-        }\n-        super::VtableFnPointer(data) => {\n-            candidate_set.vec.push(\n-                ProjectionTyCandidate::FnPointer(data));\n-        }\n-        super::VtableParam(..) => {\n-            // This case tell us nothing about the value of an\n-            // associated type. Consider:\n-            //\n-            // ```\n-            // trait SomeTrait { type Foo; }\n-            // fn foo<T:SomeTrait>(...) { }\n-            // ```\n-            //\n-            // If the user writes `<T as SomeTrait>::Foo`, then the `T\n-            // : SomeTrait` binding does not help us decide what the\n-            // type `Foo` is (at least, not more specifically than\n-            // what we already knew).\n-            //\n-            // But wait, you say! What about an example like this:\n-            //\n-            // ```\n-            // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n-            // ```\n-            //\n-            // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n-            // resolve `T::Foo`? And of course it does, but in fact\n-            // that single predicate is desugared into two predicates\n-            // in the compiler: a trait predicate (`T : SomeTrait`) and a\n-            // projection. And the projection where clause is handled\n-            // in `assemble_candidates_from_param_env`.\n-        }\n-        super::VtableDefaultImpl(..) |\n-        super::VtableBuiltin(..) => {\n-            // These traits have no associated types.\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Cannot project an associated type from `{:?}`\",\n-                vtable);\n+                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+            }\n+            super::VtableImpl(ref impl_data) if !selcx.projection_mode().is_any() => {\n+                // We have to be careful when projecting out of an\n+                // impl because of specialization. If we are not in\n+                // trans (i.e., projection mode is not \"any\"), and the\n+                // impl's type is declared as default, then we disable\n+                // projection (even if the trait ref is fully\n+                // monomorphic). In the case where trait ref is not\n+                // fully monomorphic (i.e., includes type parameters),\n+                // this is because those type parameters may\n+                // ultimately be bound to types from other crates that\n+                // may have specialized impls we can't see. In the\n+                // case where the trait ref IS fully monomorphic, this\n+                // is a policy decision that we made in the RFC in\n+                // order to preserve flexibility for the crate that\n+                // defined the specializable impl to specialize later\n+                // for existing types.\n+                //\n+                // In either case, we handle this by not adding a\n+                // candidate for an impl if it contains a `default`\n+                // type.\n+                let opt_node_item = assoc_ty_def(selcx,\n+                                                 impl_data.impl_def_id,\n+                                                 obligation.predicate.item_name);\n+                let new_candidate = if let Some(node_item) = opt_node_item {\n+                    if node_item.node.is_from_trait() {\n+                        if node_item.item.ty.is_some() {\n+                            // The impl inherited a `type Foo =\n+                            // Bar` given in the trait, which is\n+                            // implicitly default. No candidate.\n+                            None\n+                        } else {\n+                            // The impl did not specify `type` and neither\n+                            // did the trait:\n+                            //\n+                            // ```rust\n+                            // trait Foo { type T; }\n+                            // impl Foo for Bar { }\n+                            // ```\n+                            //\n+                            // This is an error, but it will be\n+                            // reported in `check_impl_items_against_trait`.\n+                            // We accept it here but will flag it as\n+                            // an error when we confirm the candidate\n+                            // (which will ultimately lead to `normalize_to_error`\n+                            // being invoked).\n+                            Some(ProjectionTyCandidate::Select)\n+                        }\n+                    } else if node_item.item.defaultness.is_default() {\n+                        // The impl specified `default type Foo =\n+                        // Bar`. No candidate.\n+                        None\n+                    } else {\n+                        // The impl specified `type Foo = Bar`\n+                        // with no default. Add a candidate.\n+                        Some(ProjectionTyCandidate::Select)\n+                    }\n+                } else {\n+                    // This is saying that neither the trait nor\n+                    // the impl contain a definition for this\n+                    // associated type.  Normally this situation\n+                    // could only arise through a compiler bug --\n+                    // if the user wrote a bad item name, it\n+                    // should have failed in astconv. **However**,\n+                    // at coherence-checking time, we only look at\n+                    // the topmost impl (we don't even consider\n+                    // the trait itself) for the definition -- and\n+                    // so in that case it may be that the trait\n+                    // *DOES* have a declaration, but we don't see\n+                    // it, and we end up in this branch.\n+                    //\n+                    // This is kind of tricky to handle actually.\n+                    // For now, we just unconditionally ICE,\n+                    // because otherwise, examples like the\n+                    // following will succeed:\n+                    //\n+                    // ```\n+                    // trait Assoc {\n+                    //     type Output;\n+                    // }\n+                    //\n+                    // impl<T> Assoc for T {\n+                    //     default type Output = bool;\n+                    // }\n+                    //\n+                    // impl Assoc for u8 {}\n+                    // impl Assoc for u16 {}\n+                    //\n+                    // trait Foo {}\n+                    // impl Foo for <u8 as Assoc>::Output {}\n+                    // impl Foo for <u16 as Assoc>::Output {}\n+                    //     return None;\n+                    // }\n+                    // ```\n+                    //\n+                    // The essential problem here is that the\n+                    // projection fails, leaving two unnormalized\n+                    // types, which appear not to unify -- so the\n+                    // overlap check succeeds, when it should\n+                    // fail.\n+                    bug!(\"Tried to project an inherited associated type during \\\n+                          coherence checking, which is currently not supported.\");\n+                };\n+                candidate_set.vec.extend(new_candidate);\n+            }\n+            super::VtableImpl(_) => {\n+                // In trans mode, we can just project out of impls, no prob.\n+                assert!(selcx.projection_mode().is_any());\n+                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+            }\n+            super::VtableParam(..) => {\n+                // This case tell us nothing about the value of an\n+                // associated type. Consider:\n+                //\n+                // ```\n+                // trait SomeTrait { type Foo; }\n+                // fn foo<T:SomeTrait>(...) { }\n+                // ```\n+                //\n+                // If the user writes `<T as SomeTrait>::Foo`, then the `T\n+                // : SomeTrait` binding does not help us decide what the\n+                // type `Foo` is (at least, not more specifically than\n+                // what we already knew).\n+                //\n+                // But wait, you say! What about an example like this:\n+                //\n+                // ```\n+                // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n+                // ```\n+                //\n+                // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n+                // resolve `T::Foo`? And of course it does, but in fact\n+                // that single predicate is desugared into two predicates\n+                // in the compiler: a trait predicate (`T : SomeTrait`) and a\n+                // projection. And the projection where clause is handled\n+                // in `assemble_candidates_from_param_env`.\n+            }\n+            super::VtableDefaultImpl(..) |\n+            super::VtableBuiltin(..) => {\n+                // These traits have no associated types.\n+                span_bug!(\n+                    obligation.cause.span,\n+                    \"Cannot project an associated type from `{:?}`\",\n+                    vtable);\n+            }\n         }\n-    }\n \n-    Ok(())\n+        Ok(())\n+    })\n }\n \n fn confirm_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n@@ -934,18 +929,116 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Impl(impl_vtable) => {\n-            confirm_impl_candidate(selcx, obligation, impl_vtable)\n+        ProjectionTyCandidate::Select => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref)\n+        }\n+    }\n+}\n+\n+fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n+    let vtable = match selcx.select(&trait_obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        _ => {\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Failed to select `{:?}`\",\n+                trait_obligation);\n         }\n+    };\n+\n+    match vtable {\n+        super::VtableImpl(data) =>\n+            confirm_impl_candidate(selcx, obligation, data),\n+        super::VtableClosure(data) =>\n+            confirm_closure_candidate(selcx, obligation, data),\n+        super::VtableFnPointer(data) =>\n+            confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::VtableObject(_) =>\n+            confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n+        super::VtableDefaultImpl(..) |\n+        super::VtableParam(..) |\n+        super::VtableBuiltin(..) =>\n+            // we don't create Select candidates with this kind of resolution\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Cannot project an associated type from `{:?}`\",\n+                vtable),\n+    }\n+}\n \n-        ProjectionTyCandidate::Closure(closure_vtable) => {\n-            confirm_closure_candidate(selcx, obligation, closure_vtable)\n+fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    debug!(\"confirm_object_candidate(object_ty={:?})\",\n+           object_ty);\n+    let data = match object_ty.sty {\n+        ty::TyTrait(ref data) => data,\n+        _ => {\n+            span_bug!(\n+                obligation.cause.span,\n+                \"confirm_object_candidate called with non-object: {:?}\",\n+                object_ty);\n         }\n+    };\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n+    let env_predicates = projection_bounds.iter()\n+                                          .map(|p| p.to_predicate())\n+                                          .collect();\n+    let env_predicate = {\n+        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n+\n+        // select only those projections that are actually projecting an\n+        // item with the correct name\n+        let env_predicates = env_predicates.filter_map(|p| match p {\n+            ty::Predicate::Projection(data) =>\n+                if data.item_name() == obligation.predicate.item_name {\n+                    Some(data)\n+                } else {\n+                    None\n+                },\n+            _ => None\n+        });\n \n-        ProjectionTyCandidate::FnPointer(fn_pointer_vtable) => {\n-            confirm_fn_pointer_candidate(selcx, obligation, fn_pointer_vtable)\n+        // select those with a relevant trait-ref\n+        let mut env_predicates = env_predicates.filter(|data| {\n+            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+            let data_poly_trait_ref = data.to_poly_trait_ref();\n+            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+            selcx.infcx().probe(|_| {\n+                selcx.infcx().sub_poly_trait_refs(false,\n+                                                  origin,\n+                                                  data_poly_trait_ref,\n+                                                  obligation_poly_trait_ref).is_ok()\n+            })\n+        });\n+\n+        // select the first matching one; there really ought to be one or\n+        // else the object type is not WF, since an object type should\n+        // include all of its projections explicitly\n+        match env_predicates.next() {\n+            Some(env_predicate) => env_predicate,\n+            None => {\n+                debug!(\"confirm_object_candidate: no env-predicate \\\n+                        found in object type `{:?}`; ill-formed\",\n+                       object_ty);\n+                return (selcx.tcx().types.err, vec!());\n+            }\n         }\n-    }\n+    };\n+\n+    confirm_param_env_candidate(selcx, obligation, env_predicate)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>("}, {"sha": "4a14185b6e3add0f47048a4a4dbfcf9100b3ef1f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -382,6 +382,35 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Returns a set of all late-bound regions that are constrained\n+    /// by `value`, meaning that if we instantiate those LBR with\n+    /// variables and equate `value` with something else, those\n+    /// variables will also be equated.\n+    pub fn collect_constrained_late_bound_regions<T>(&self, value: &Binder<T>)\n+                                                     -> FnvHashSet<ty::BoundRegion>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.collect_late_bound_regions(value, true)\n+    }\n+\n+    /// Returns a set of all late-bound regions that appear in `value` anywhere.\n+    pub fn collect_referenced_late_bound_regions<T>(&self, value: &Binder<T>)\n+                                                    -> FnvHashSet<ty::BoundRegion>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.collect_late_bound_regions(value, false)\n+    }\n+\n+    fn collect_late_bound_regions<T>(&self, value: &Binder<T>, just_constraint: bool)\n+                                     -> FnvHashSet<ty::BoundRegion>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let mut collector = LateBoundRegionsCollector::new(just_constraint);\n+        let result = value.skip_binder().visit_with(&mut collector);\n+        assert!(!result); // should never have stopped early\n+        collector.regions\n+    }\n+\n     /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n     /// method lookup and a few other places where precise region relationships are not required.\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n@@ -625,3 +654,54 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         false\n     }\n }\n+\n+/// Collects all the late-bound regions it finds into a hash set.\n+struct LateBoundRegionsCollector {\n+    current_depth: u32,\n+    regions: FnvHashSet<ty::BoundRegion>,\n+    just_constrained: bool,\n+}\n+\n+impl LateBoundRegionsCollector {\n+    fn new(just_constrained: bool) -> Self {\n+        LateBoundRegionsCollector {\n+            current_depth: 1,\n+            regions: FnvHashSet(),\n+            just_constrained: just_constrained,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+        self.current_depth += 1;\n+        let result = t.super_visit_with(self);\n+        self.current_depth -= 1;\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        // if we are only looking for \"constrained\" region, we have to\n+        // ignore the inputs to a projection, as they may not appear\n+        // in the normalized form\n+        if self.just_constrained {\n+            match t.sty {\n+                ty::TyProjection(..) => { return false; }\n+                _ => { }\n+            }\n+        }\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region) -> bool {\n+        match r {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n+                self.regions.insert(br);\n+            }\n+            _ => { }\n+        }\n+        false\n+    }\n+}\n+"}, {"sha": "9fca6d3d201390b93f51e7a233061eb4525a3d8a", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -197,7 +197,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         FutureIncompatibleInfo {\n             id: LintId::of(OBJECT_UNSAFE_FRAGMENT),\n             reference: \"issue #33243 <https://github.com/rust-lang/rust/issues/33243>\",\n-        }\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(HR_LIFETIME_IN_ASSOC_TYPE),\n+            reference: \"issue #33685 <https://github.com/rust-lang/rust/issues/33685>\",\n+        },\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "ac86b7c8740603c27ac7c7aa9626646a0aed7cb8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -52,13 +52,17 @@ use middle::const_val::ConstVal;\n use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n+use hir::{self, SelfKind};\n use hir::def::{self, Def};\n use hir::def_id::DefId;\n+use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n+use rustc::lint;\n use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n+use rustc_back::slice;\n use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n@@ -74,10 +78,6 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, keywords};\n \n-use rustc::hir::print as pprust;\n-use rustc::hir::{self, SelfKind};\n-use rustc_back::slice;\n-\n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n@@ -679,6 +679,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         PathParamMode::Explicit,\n                                         trait_def_id,\n                                         self_ty,\n+                                        trait_ref.ref_id,\n                                         trait_ref.path.segments.last().unwrap(),\n                                         poly_projections)\n     }\n@@ -723,6 +724,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         span: Span,\n         param_mode: PathParamMode,\n         trait_def_id: DefId,\n+        trait_path_ref_id: ast::NodeId,\n         trait_segment: &hir::PathSegment,\n         mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n@@ -732,6 +734,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         param_mode,\n                                         trait_def_id,\n                                         None,\n+                                        trait_path_ref_id,\n                                         trait_segment,\n                                         projections)\n     }\n@@ -742,6 +745,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         param_mode: PathParamMode,\n         trait_def_id: DefId,\n         self_ty: Option<Ty<'tcx>>,\n+        path_id: ast::NodeId,\n         trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n@@ -770,7 +774,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 .filter_map(|binding| {\n                     // specify type to assert that error was already reported in Err case:\n                     let predicate: Result<_, ErrorReported> =\n-                        self.ast_type_binding_to_poly_projection_predicate(poly_trait_ref.clone(),\n+                        self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                                                                           poly_trait_ref.clone(),\n                                                                            self_ty,\n                                                                            binding);\n                     predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n@@ -863,7 +868,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (self.tcx().mk_substs(substs), assoc_bindings)\n     }\n \n-    fn ast_type_binding_to_poly_projection_predicate(&self,\n+    fn ast_type_binding_to_poly_projection_predicate(\n+        &self,\n+        path_id: ast::NodeId,\n         mut trait_ref: ty::PolyTraitRef<'tcx>,\n         self_ty: Option<Ty<'tcx>>,\n         binding: &ConvertedBinding<'tcx>)\n@@ -887,6 +894,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         //\n         // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n+        // Find any late-bound regions declared in `ty` that are not\n+        // declared in the trait-ref. These are not wellformed.\n+        //\n+        // Example:\n+        //\n+        //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n+        //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n+        let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n+        let late_bound_in_ty = tcx.collect_referenced_late_bound_regions(&ty::Binder(binding.ty));\n+        debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n+        debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+        for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n+            let br_name = match *br {\n+                ty::BrNamed(_, name) => name,\n+                _ => {\n+                    span_bug!(\n+                        binding.span,\n+                        \"anonymous bound region {:?} in binding but not trait ref\",\n+                        br);\n+                }\n+            };\n+            tcx.sess.add_lint(\n+                lint::builtin::HR_LIFETIME_IN_ASSOC_TYPE,\n+                path_id,\n+                binding.span,\n+                format!(\"binding for associated type `{}` references lifetime `{}`, \\\n+                         which does not appear in the trait input types\",\n+                        binding.item_name, br_name));\n+        }\n+\n         // Simple case: X is defined in the current trait.\n         if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n             return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n@@ -1012,6 +1049,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                                path.span,\n                                                                PathParamMode::Explicit,\n                                                                trait_def_id,\n+                                                               ty.id,\n                                                                path.segments.last().unwrap(),\n                                                                &mut projection_bounds);\n                         Ok((trait_ref, projection_bounds))\n@@ -1416,6 +1454,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                       param_mode: PathParamMode,\n                       def: Def,\n                       opt_self_ty: Option<Ty<'tcx>>,\n+                      base_path_ref_id: ast::NodeId,\n                       base_segments: &[hir::PathSegment])\n                       -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -1434,6 +1473,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                        span,\n                                                        param_mode,\n                                                        trait_def_id,\n+                                                       base_path_ref_id,\n                                                        base_segments.last().unwrap(),\n                                                        &mut projection_bounds);\n \n@@ -1518,6 +1558,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                       param_mode: PathParamMode,\n                                       mut def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n+                                      base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n                                       assoc_segments: &[hir::PathSegment])\n                                       -> (Ty<'tcx>, Def) {\n@@ -1532,6 +1573,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                          param_mode,\n                                          def,\n                                          opt_self_ty,\n+                                         base_path_ref_id,\n                                          base_segments);\n         debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", ty);\n         // If any associated type segments remain, attempt to resolve them.\n@@ -1607,7 +1649,45 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                tcx.mk_fn_ptr(self.ty_of_bare_fn(bf.unsafety, bf.abi, &bf.decl))\n+                let bare_fn_ty = self.ty_of_bare_fn(bf.unsafety, bf.abi, &bf.decl);\n+\n+                // Find any late-bound regions declared in return type that do\n+                // not appear in the arguments. These are not wellformed.\n+                //\n+                // Example:\n+                //\n+                //     for<'a> fn() -> &'a str <-- 'a is bad\n+                //     for<'a> fn(&'a String) -> &'a str <-- 'a is ok\n+                //\n+                // Note that we do this check **here** and not in\n+                // `ty_of_bare_fn` because the latter is also used to make\n+                // the types for fn items, and we do not want to issue a\n+                // warning then. (Once we fix #32330, the regions we are\n+                // checking for here would be considered early bound\n+                // anyway.)\n+                let inputs = bare_fn_ty.sig.inputs();\n+                let late_bound_in_args = tcx.collect_constrained_late_bound_regions(&inputs);\n+                let output = bare_fn_ty.sig.output();\n+                let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n+                for br in late_bound_in_ret.difference(&late_bound_in_args) {\n+                    let br_name = match *br {\n+                        ty::BrNamed(_, name) => name,\n+                        _ => {\n+                            span_bug!(\n+                                bf.decl.output.span(),\n+                                \"anonymous bound region {:?} in return but not args\",\n+                                br);\n+                        }\n+                    };\n+                    tcx.sess.add_lint(\n+                        lint::builtin::HR_LIFETIME_IN_ASSOC_TYPE,\n+                        ast_ty.id,\n+                        ast_ty.span,\n+                        format!(\"return type references lifetime `{}`, \\\n+                                 which does not appear in the trait input types\",\n+                                br_name));\n+                }\n+                tcx.mk_fn_ptr(bare_fn_ty)\n             }\n             hir::TyPolyTraitRef(ref bounds) => {\n                 self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n@@ -1635,6 +1715,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                                  PathParamMode::Explicit,\n                                                                  def,\n                                                                  opt_self_ty,\n+                                                                 ast_ty.id,\n                                                                  &path.segments[..base_ty_end],\n                                                                  &path.segments[base_ty_end..]);\n "}, {"sha": "1ee9d1032a6ee47ad65748422ed13692a753d6a8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -3866,6 +3866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                  PathParamMode::Optional,\n                                                                  def,\n                                                                  opt_self_ty,\n+                                                                 node_id,\n                                                                  &ty_segments[..base_ty_end],\n                                                                  &ty_segments[base_ty_end..]);\n             let item_segment = path.segments.last().unwrap();"}, {"sha": "5896a34b0d1603b953b0281c414d7d80bdff1e96", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -568,7 +568,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let (fty, explicit_self_category) =\n         AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                              sig, untransformed_rcvr_ty);\n+                              sig,\n+                              untransformed_rcvr_ty);\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n     let substs = mk_item_substs(ccx, &ty_generics);"}, {"sha": "2ca61ba76d47c6ffef87689bbebd4593c44c09d2", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -180,7 +180,7 @@ impl error::Error for ExplicitBug {\n #[must_use]\n #[derive(Clone)]\n pub struct DiagnosticBuilder<'a> {\n-    emitter: &'a RefCell<Box<Emitter>>,\n+    handler: &'a Handler,\n     level: Level,\n     message: String,\n     code: Option<String>,\n@@ -204,8 +204,9 @@ impl<'a> DiagnosticBuilder<'a> {\n             return;\n         }\n \n-        self.emitter.borrow_mut().emit_struct(&self);\n+        self.handler.emit.borrow_mut().emit_struct(&self);\n         self.cancel();\n+        self.handler.panic_if_treat_err_as_bug();\n \n         // if self.is_fatal() {\n         //     panic!(FatalError);\n@@ -321,11 +322,11 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n-    fn new(emitter: &'a RefCell<Box<Emitter>>,\n+    fn new(handler: &'a Handler,\n            level: Level,\n            message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n-            emitter: emitter,\n+            handler: handler,\n             level: level,\n             message: message.to_owned(),\n             code: None,\n@@ -362,10 +363,10 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n-            self.emitter.borrow_mut().emit(&MultiSpan::new(),\n-                                           \"Error constructed but not emitted\",\n-                                           None,\n-                                           Bug);\n+            self.handler.emit.borrow_mut().emit(&MultiSpan::new(),\n+                                                \"Error constructed but not emitted\",\n+                                                None,\n+                                                Bug);\n             panic!();\n         }\n     }\n@@ -412,14 +413,14 @@ impl Handler {\n     }\n \n     pub fn struct_dummy<'a>(&'a self) -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder::new(&self.emit, Level::Cancelled, \"\")\n+        DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n     }\n \n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n                                                     msg: &str)\n                                                     -> DiagnosticBuilder<'a> {\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         result.set_span(sp);\n         if !self.can_emit_warnings {\n             result.cancel();\n@@ -431,7 +432,7 @@ impl Handler {\n                                                               msg: &str,\n                                                               code: &str)\n                                                               -> DiagnosticBuilder<'a> {\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         if !self.can_emit_warnings {\n@@ -440,7 +441,7 @@ impl Handler {\n         result\n     }\n     pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n@@ -451,7 +452,7 @@ impl Handler {\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result\n     }\n@@ -461,21 +462,21 @@ impl Handler {\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Error, msg)\n+        DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n     pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n                                                      sp: S,\n                                                      msg: &str)\n                                                      -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result\n     }\n@@ -485,14 +486,14 @@ impl Handler {\n                                                                code: &str)\n                                                                -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg)\n+        DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n     pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n@@ -503,36 +504,35 @@ impl Handler {\n         err.cancel();\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n+    fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n+            panic!(\"encountered error with `-Z treat_err_as_bug\");\n         }\n+    }\n+\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n+                                          -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n         self.bump_err_count();\n+        self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str)\n-    -> FatalError {\n-        if self.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n+                                                    -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n         self.bump_err_count();\n+        self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        if self.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         self.emit(&sp.into(), msg, Error);\n         self.bump_err_count();\n+        self.panic_if_treat_err_as_bug();\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        if self.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         self.emit_with_code(&sp.into(), msg, code, Error);\n         self.bump_err_count();\n+        self.panic_if_treat_err_as_bug();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Warning);"}, {"sha": "52a2ca9082d230c297028aabfc9baa63d560d191", "filename": "src/test/compile-fail/associated-types-eq-hr.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -40,6 +40,17 @@ impl<'a> TheTrait<&'a isize> for UintStruct {\n     }\n }\n \n+struct Tuple {\n+}\n+\n+impl<'a> TheTrait<(&'a isize, &'a isize)> for Tuple {\n+    type A = &'a isize;\n+\n+    fn get(&self, t: (&'a isize, &'a isize)) -> &'a isize {\n+        t.0\n+    }\n+}\n+\n fn foo<T>()\n     where T : for<'x> TheTrait<&'x isize, A = &'x isize>\n {\n@@ -52,10 +63,28 @@ fn bar<T>()\n     // ok for UintStruct, but not IntStruct\n }\n \n-fn baz<T>()\n-    where T : for<'x,'y> TheTrait<&'x isize, A = &'y isize>\n+fn tuple_one<T>()\n+    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n+{\n+    // not ok for tuple, two lifetimes and we pick first\n+}\n+\n+fn tuple_two<T>()\n+    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n {\n-    // not ok for either struct, due to the use of two lifetimes\n+    // not ok for tuple, two lifetimes and we pick second\n+}\n+\n+fn tuple_three<T>()\n+    where T : for<'x> TheTrait<(&'x isize, &'x isize), A = &'x isize>\n+{\n+    // ok for tuple\n+}\n+\n+fn tuple_four<T>()\n+    where T : for<'x,'y> TheTrait<(&'x isize, &'y isize)>\n+{\n+    // not ok for tuple, two lifetimes, and lifetime matching is invariant\n }\n \n pub fn main() {\n@@ -65,6 +94,16 @@ pub fn main() {\n     bar::<IntStruct>(); //~ ERROR type mismatch\n     bar::<UintStruct>();\n \n-    baz::<IntStruct>(); //~ ERROR type mismatch\n-    baz::<UintStruct>(); //~ ERROR type mismatch\n+    tuple_one::<Tuple>();\n+    //~^ ERROR E0277\n+    //~| ERROR type mismatch\n+\n+    tuple_two::<Tuple>();\n+    //~^ ERROR E0277\n+    //~| ERROR type mismatch\n+\n+    tuple_three::<Tuple>();\n+\n+    tuple_four::<Tuple>();\n+    //~^ ERROR E0277\n }"}, {"sha": "f60f06b4ec8330ae36a1c90c7d66a4fbbe648a74", "filename": "src/test/compile-fail/associated-types/bound-lifetime-constrained.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-constrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-constrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-constrained.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: func object clause\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+#![feature(unboxed_closures)]\n+#![deny(hr_lifetime_in_assoc_type)]\n+\n+trait Foo<'a> {\n+    type Item;\n+}\n+\n+impl<'a> Foo<'a> for() {\n+    type Item = ();\n+}\n+\n+// Check that appearing in a projection input in the argument is not enough:\n+#[cfg(func)]\n+fn func1(_: for<'a> fn(<() as Foo<'a>>::Item) -> &'a i32) {\n+    //[func]~^ ERROR return type references lifetime `'a`\n+    //[func]~| WARNING previously accepted\n+}\n+\n+// Check that appearing in a projection input in the return still\n+// causes an error:\n+#[cfg(func)]\n+fn func2(_: for<'a> fn() -> <() as Foo<'a>>::Item) {\n+    //[func]~^ ERROR return type references lifetime `'a`\n+    //[func]~| WARNING previously accepted\n+}\n+\n+#[cfg(object)]\n+fn object1(_: Box<for<'a> Fn(<() as Foo<'a>>::Item) -> &'a i32>) {\n+    //[object]~^ ERROR `Output` references lifetime `'a`\n+    //[object]~| WARNING previously accepted\n+}\n+\n+#[cfg(object)]\n+fn object2(_: Box<for<'a> Fn() -> <() as Foo<'a>>::Item>) {\n+    //[object]~^ ERROR `Output` references lifetime `'a`\n+    //[object]~| WARNING previously accepted\n+}\n+\n+#[cfg(clause)]\n+fn clause1<T>() where T: for<'a> Fn(<() as Foo<'a>>::Item) -> &'a i32 {\n+    //[clause]~^ ERROR `Output` references lifetime `'a`\n+    //[clause]~| WARNING previously accepted\n+}\n+\n+#[cfg(clause)]\n+fn clause2<T>() where T: for<'a> Fn() -> <() as Foo<'a>>::Item {\n+    //[clause]~^ ERROR `Output` references lifetime `'a`\n+    //[clause]~| WARNING previously accepted\n+}\n+\n+#[rustc_error]\n+fn main() { } //[ok]~ ERROR compilation successful"}, {"sha": "020c9e5e1db5999280df72fbdb813ba9f62e57b2", "filename": "src/test/compile-fail/associated-types/bound-lifetime-in-binding-only.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: angle paren ok elision\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+#![feature(unboxed_closures)]\n+#![deny(hr_lifetime_in_assoc_type)]\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+#[cfg(angle)]\n+fn angle<T: for<'a> Foo<Item=&'a i32>>() {\n+    //[angle]~^ ERROR binding for associated type `Item` references lifetime `'a`\n+    //[angle]~| WARNING previously accepted\n+}\n+\n+#[cfg(angle)]\n+fn angle1<T>() where T: for<'a> Foo<Item=&'a i32> {\n+    //[angle]~^ ERROR binding for associated type `Item` references lifetime `'a`\n+    //[angle]~| WARNING previously accepted\n+}\n+\n+#[cfg(angle)]\n+fn angle2<T>() where for<'a> T: Foo<Item=&'a i32> {\n+    //[angle]~^ ERROR binding for associated type `Item` references lifetime `'a`\n+    //[angle]~| WARNING previously accepted\n+}\n+\n+#[cfg(angle)]\n+fn angle3(_: &for<'a> Foo<Item=&'a i32>) {\n+    //[angle]~^ ERROR binding for associated type `Item` references lifetime `'a`\n+    //[angle]~| WARNING previously accepted\n+}\n+\n+#[cfg(paren)]\n+fn paren<T: for<'a> Fn() -> &'a i32>() {\n+    //[paren]~^ ERROR binding for associated type `Output` references lifetime `'a`\n+    //[paren]~| WARNING previously accepted\n+}\n+\n+#[cfg(paren)]\n+fn paren1<T>() where T: for<'a> Fn() -> &'a i32 {\n+    //[paren]~^ ERROR binding for associated type `Output` references lifetime `'a`\n+    //[paren]~| WARNING previously accepted\n+}\n+\n+#[cfg(paren)]\n+fn paren2<T>() where for<'a> T: Fn() -> &'a i32 {\n+    //[paren]~^ ERROR binding for associated type `Output` references lifetime `'a`\n+    //[paren]~| WARNING previously accepted\n+}\n+\n+#[cfg(paren)]\n+fn paren3(_: &for<'a> Fn() -> &'a i32) {\n+    //[paren]~^ ERROR binding for associated type `Output` references lifetime `'a`\n+    //[paren]~| WARNING previously accepted\n+}\n+\n+#[cfg(elision)]\n+fn elision<T: Fn() -> &i32>() {\n+    //[elision]~^ ERROR E0106\n+}\n+\n+struct Parameterized<'a> { x: &'a str }\n+\n+#[cfg(ok)]\n+fn ok1<T: for<'a> Fn(&Parameterized<'a>) -> &'a i32>() {\n+}\n+\n+#[cfg(ok)]\n+fn ok2<T: for<'a,'b> Fn<(&'b Parameterized<'a>,), Output=&'a i32>>() {\n+}\n+\n+#[cfg(ok)]\n+fn ok3<T>() where for<'a> Parameterized<'a>: Foo<Item=&'a i32> {\n+}\n+\n+#[rustc_error]\n+fn main() { } //[ok]~ ERROR compilation successful"}, {"sha": "0b4a9bf58a66c6af56abd9043d0c084eba46aadf", "filename": "src/test/compile-fail/associated-types/bound-lifetime-in-return-only.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-return-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23e1b032d87300392a4f3835bde8d5d873823/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-return-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fbound-lifetime-in-return-only.rs?ref=75e23e1b032d87300392a4f3835bde8d5d873823", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: sig local structure ok elision\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+#![feature(unboxed_closures)]\n+#![deny(hr_lifetime_in_assoc_type)]\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+#[cfg(sig)]\n+fn sig1(_: for<'a> fn() -> &'a i32) {\n+    //[sig]~^ ERROR return type references lifetime `'a`\n+    //[sig]~| WARNING previously accepted\n+}\n+\n+#[cfg(sig)]\n+fn sig2(_: for<'a, 'b> fn(&'b i32) -> &'a i32) {\n+    //[sig]~^ ERROR return type references lifetime `'a`\n+    //[sig]~| WARNING previously accepted\n+}\n+\n+#[cfg(local)]\n+fn local1() {\n+    let _: for<'a> fn() -> &'a i32 = loop { };\n+    //[local]~^ ERROR return type references lifetime `'a`\n+    //[local]~| WARNING previously accepted\n+}\n+\n+#[cfg(structure)]\n+struct Struct1 {\n+    x: for<'a> fn() -> &'a i32\n+    //[structure]~^ ERROR return type references lifetime `'a`\n+    //[structure]~| WARNING previously accepted\n+}\n+\n+#[cfg(elision)]\n+fn elision(_: fn() -> &i32) {\n+    //[elision]~^ ERROR E0106\n+}\n+\n+struct Parameterized<'a> { x: &'a str }\n+\n+#[cfg(ok)]\n+fn ok1(_: &for<'a> Fn(&Parameterized<'a>) -> &'a i32) {\n+}\n+\n+#[cfg(ok)]\n+fn ok2(_: &for<'a,'b> Fn<(&'b Parameterized<'a>,), Output=&'a i32>) {\n+}\n+\n+#[rustc_error]\n+fn main() { } //[ok]~ ERROR compilation successful"}]}