{"sha": "43134714f529d087aecb8c6327ca282c2fa261f1", "node_id": "C_kwDOAAsO6NoAKDQzMTM0NzE0ZjUyOWQwODdhZWNiOGM2MzI3Y2EyODJjMmZhMjYxZjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-14T17:45:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-14T17:45:26Z"}, "message": "Rollup merge of #106661 - mjguzik:linux_statx, r=Mark-Simulacrum\n\nStop probing for statx unless necessary\n\nAs is the current toy program:\nfn main() -> std::io::Result<()> {\n    use std::fs;\n\n    let metadata = fs::metadata(\"foo.txt\")?;\n\n    assert!(!metadata.is_dir());\n    Ok(())\n}\n\n... observed under strace will issue:\n[snip]\nstatx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address) statx(AT_FDCWD, \"foo.txt\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\n\nWhile statx is not necessarily always present, checking for it can be delayed to the first error condition. Said condition may very well never happen, in which case the check got avoided altogether.\n\nNote this is still suboptimal as there still will be programs issuing it, but bulk of the problem is removed.\n\nTested by forbidding the syscall for the binary and observing it correctly falls back to newfstatat.\n\nWhile here tidy up the commentary, in particular by denoting some problems with the current approach.", "tree": {"sha": "95e1e490c4697b591a7570ab761ad250d2a27113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e1e490c4697b591a7570ab761ad250d2a27113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43134714f529d087aecb8c6327ca282c2fa261f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwuo2CRBK7hj4Ov3rIwAAFywIAKw9c5FjJcWp15lD3+bELczQ\nfLbHdqUUpvBBYHB4hvm9A+ZAcA3kRqcRvO5oy1wF2z4X6KdmAPaDa69grs+VLpcA\nh5tPgTr/9dJ5Kg8KzeC/jJrK4G/Q2UOyjjERhS9FPUAA8+QPCcnUcOG77uiyeg1Y\n2XfjU4DxRNdrx1Sj+IkGiQzNyiaD4LEMdMZDoXnFheWv6+M87tLq9JnDIfLJaHb9\n862KRezXri5X/utb/430X51xOhvEqYB2vhZQVZ9Y4TxvYlB+5K3LooIQN00p/qGW\nUBnfG0oM3Q72Row2VtjWcXkvRYnOOLURncE+hZBzSFueBFOkqWvLTrs2CdcgAy0=\n=JpL0\n-----END PGP SIGNATURE-----\n", "payload": "tree 95e1e490c4697b591a7570ab761ad250d2a27113\nparent d7bc758638772dbc5718eb33347998cfce0bee5e\nparent b49aa8d53e2e1424f5d9997734cfd71b2ae647b4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673718326 +0100\ncommitter GitHub <noreply@github.com> 1673718326 +0100\n\nRollup merge of #106661 - mjguzik:linux_statx, r=Mark-Simulacrum\n\nStop probing for statx unless necessary\n\nAs is the current toy program:\nfn main() -> std::io::Result<()> {\n    use std::fs;\n\n    let metadata = fs::metadata(\"foo.txt\")?;\n\n    assert!(!metadata.is_dir());\n    Ok(())\n}\n\n... observed under strace will issue:\n[snip]\nstatx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address) statx(AT_FDCWD, \"foo.txt\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\n\nWhile statx is not necessarily always present, checking for it can be delayed to the first error condition. Said condition may very well never happen, in which case the check got avoided altogether.\n\nNote this is still suboptimal as there still will be programs issuing it, but bulk of the problem is removed.\n\nTested by forbidding the syscall for the binary and observing it correctly falls back to newfstatat.\n\nWhile here tidy up the commentary, in particular by denoting some problems with the current approach.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43134714f529d087aecb8c6327ca282c2fa261f1", "html_url": "https://github.com/rust-lang/rust/commit/43134714f529d087aecb8c6327ca282c2fa261f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43134714f529d087aecb8c6327ca282c2fa261f1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7bc758638772dbc5718eb33347998cfce0bee5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7bc758638772dbc5718eb33347998cfce0bee5e", "html_url": "https://github.com/rust-lang/rust/commit/d7bc758638772dbc5718eb33347998cfce0bee5e"}, {"sha": "b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4", "html_url": "https://github.com/rust-lang/rust/commit/b49aa8d53e2e1424f5d9997734cfd71b2ae647b4"}], "stats": {"total": 73, "additions": 44, "deletions": 29}, "files": [{"sha": "0e7d23a5c7c9d916bb9c4bdabe6329eee3c78088", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/43134714f529d087aecb8c6327ca282c2fa261f1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43134714f529d087aecb8c6327ca282c2fa261f1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=43134714f529d087aecb8c6327ca282c2fa261f1", "patch": "@@ -149,12 +149,13 @@ cfg_has_statx! {{\n     ) -> Option<io::Result<FileAttr>> {\n         use crate::sync::atomic::{AtomicU8, Ordering};\n \n-        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in global to avoid unnecessary syscalls.\n-        // 0: Unknown\n-        // 1: Not available\n-        // 2: Available\n-        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n+        // We check for it on first failure and remember availability to avoid having to\n+        // do it again.\n+        #[repr(u8)]\n+        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n+        static STATX_SAVED_STATE: AtomicU8 = AtomicU8::new(STATX_STATE::Unknown as u8);\n+\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -165,31 +166,44 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        match STATX_STATE.load(Ordering::Relaxed) {\n-            0 => {\n-                // It is a trick to call `statx` with null pointers to check if the syscall\n-                // is available. According to the manual, it is expected to fail with EFAULT.\n-                // We do this mainly for performance, since it is nearly hundreds times\n-                // faster than a normal successful call.\n-                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n-                    .err()\n-                    .and_then(|e| e.raw_os_error());\n-                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n-                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n-                // See: https://github.com/rust-lang/rust/issues/65662\n-                if err != Some(libc::EFAULT) {\n-                    STATX_STATE.store(1, Ordering::Relaxed);\n-                    return None;\n-                }\n-                STATX_STATE.store(2, Ordering::Relaxed);\n-            }\n-            1 => return None,\n-            _ => {}\n+        if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Unavailable as u8 {\n+            return None;\n         }\n \n         let mut buf: libc::statx = mem::zeroed();\n         if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n-            return Some(Err(err));\n+            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n+                return Some(Err(err));\n+            }\n+\n+            // Availability not checked yet.\n+            //\n+            // First try the cheap way.\n+            if err.raw_os_error() == Some(libc::ENOSYS) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n+\n+            // Error other than `ENOSYS` is not a good enough indicator -- it is\n+            // known that `EPERM` can be returned as a result of using seccomp to\n+            // block the syscall.\n+            // Availability is checked by performing a call which expects `EFAULT`\n+            // if the syscall is usable.\n+            // See: https://github.com/rust-lang/rust/issues/65662\n+            // FIXME this can probably just do the call if `EPERM` was received, but\n+            // previous iteration of the code checked it for all errors and for now\n+            // this is retained.\n+            // FIXME what about transient conditions like `ENOMEM`?\n+            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                .err()\n+                .and_then(|e| e.raw_os_error());\n+            if err2 == Some(libc::EFAULT) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n+                return Some(Err(err));\n+            } else {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n         }\n \n         // We cannot fill `stat64` exhaustively because of private padding fields."}, {"sha": "d6d19a3fe8159ccc66ceb1ad7cf44e9ba9da742b", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43134714f529d087aecb8c6327ca282c2fa261f1/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43134714f529d087aecb8c6327ca282c2fa261f1/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=43134714f529d087aecb8c6327ca282c2fa261f1", "patch": "@@ -22,7 +22,8 @@ fn main() {\n     }\n \n     // test `stat`\n-    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    let err = fs::metadata(\"foo.txt\").unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::PermissionDenied);\n     // check that it is the right kind of `PermissionDenied`\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    assert_eq!(err.raw_os_error(), Some(libc::EACCES));\n }"}]}