{"sha": "66fccdb2958fef88e00236497aec5e0f99fe7d02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZmNjZGIyOTU4ZmVmODhlMDAyMzY0OTdhZWM1ZTBmOTlmZTdkMDI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T17:18:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T23:48:17Z"}, "message": "std: Tests for RandomAccessIterators", "tree": {"sha": "7aff548c08b80e70f934298248d8c1dfc73af46f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aff548c08b80e70f934298248d8c1dfc73af46f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66fccdb2958fef88e00236497aec5e0f99fe7d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66fccdb2958fef88e00236497aec5e0f99fe7d02", "html_url": "https://github.com/rust-lang/rust/commit/66fccdb2958fef88e00236497aec5e0f99fe7d02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66fccdb2958fef88e00236497aec5e0f99fe7d02/comments", "author": null, "committer": null, "parents": [{"sha": "630627c3d43c17a6a657e7b91b754c45929a5bf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/630627c3d43c17a6a657e7b91b754c45929a5bf6", "html_url": "https://github.com/rust-lang/rust/commit/630627c3d43c17a6a657e7b91b754c45929a5bf6"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "9fe865333a2157c68ce9ed174e86ad6ee8478522", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/66fccdb2958fef88e00236497aec5e0f99fe7d02/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fccdb2958fef88e00236497aec5e0f99fe7d02/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=66fccdb2958fef88e00236497aec5e0f99fe7d02", "patch": "@@ -1532,6 +1532,7 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    use cmp;\n     use uint;\n \n     #[test]\n@@ -1924,6 +1925,26 @@ mod tests {\n         assert_eq!(it.next_back(), None)\n     }\n \n+    #[cfg(test)]\n+    fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+    {\n+        let mut b = a.clone();\n+        assert_eq!(len, b.indexable());\n+        let mut n = 0;\n+        for a.enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(elt), b.idx(i));\n+            n += 1;\n+        }\n+        assert_eq!(n, len);\n+        assert_eq!(None, b.idx(n));\n+        // call recursively to check after picking off an element\n+        if len > 0 {\n+            b.next();\n+            check_randacc_iter(b, len-1);\n+        }\n+    }\n+\n+\n     #[test]\n     fn test_double_ended_flat_map() {\n         let u = [0u,1];\n@@ -1958,5 +1979,71 @@ mod tests {\n         assert_eq!(it.idx(0).unwrap(), &3);\n         assert_eq!(it.idx(4).unwrap(), &9);\n         assert!(it.idx(6).is_none());\n+\n+        check_randacc_iter(it, xs.len() + ys.len() - 3);\n+    }\n+\n+    #[test]\n+    fn test_random_access_enumerate() {\n+        let xs = [1, 2, 3, 4, 5];\n+        check_randacc_iter(xs.iter().enumerate(), xs.len());\n+    }\n+\n+    #[test]\n+    fn test_random_access_zip() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let ys = [7, 9, 11];\n+        check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n+    }\n+\n+    #[test]\n+    fn test_random_access_take() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().take_(3), 3);\n+        check_randacc_iter(xs.iter().take_(20), xs.len());\n+        check_randacc_iter(xs.iter().take_(0), 0);\n+        check_randacc_iter(empty.iter().take_(2), 0);\n+    }\n+\n+    #[test]\n+    fn test_random_access_skip() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n+        check_randacc_iter(empty.iter().skip(2), 0);\n+    }\n+\n+    #[test]\n+    fn test_random_access_peek() {\n+        let xs = [1, 2, 3, 4, 5];\n+\n+        // test .transform and .peek_ that don't implement Clone\n+        let it = xs.iter().peek_(|_| {});\n+        assert_eq!(xs.len(), it.indexable());\n+        for xs.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(elt), it.idx(i));\n+        }\n+\n+    }\n+\n+    #[test]\n+    fn test_random_access_transform() {\n+        let xs = [1, 2, 3, 4, 5];\n+\n+        // test .transform and .peek_ that don't implement Clone\n+        let it = xs.iter().transform(|x| *x);\n+        assert_eq!(xs.len(), it.indexable());\n+        for xs.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(*elt), it.idx(i));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_random_access_cycle() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().cycle().take_(27), 27);\n+        check_randacc_iter(empty.iter().cycle(), 0);\n     }\n }"}]}