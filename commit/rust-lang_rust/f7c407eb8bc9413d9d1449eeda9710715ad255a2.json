{"sha": "f7c407eb8bc9413d9d1449eeda9710715ad255a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YzQwN2ViOGJjOTQxM2Q5ZDE0NDllZWRhOTcxMDcxNWFkMjU1YTI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T17:05:54Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-30T17:53:15Z"}, "message": "Rollup merge of #56216 - SimonSapin:array-tryfrom-slice, r=withoutboats\n\nAdd TryFrom<&[T]> for [T; $N] where T: Copy\n\n`TryFrom<&[T]> for &[T; $N]` (note *reference* to an array) already exists, but not needing to dereference makes type inference easier for example when using `u32::from_be_bytes`.\n\nAlso add doc examples doing just that.", "tree": {"sha": "542ce91523921e3eea5c57a0606b342a29c33e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/542ce91523921e3eea5c57a0606b342a29c33e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7c407eb8bc9413d9d1449eeda9710715ad255a2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwBeQsACgkQ/vbIBR0O\nATwLCxAAugPqcudrm/xPBTPoDL6i4RSAp5vaGsXdjTLPrYV0d9CB8wRElyZPVgO1\nDFUpLaWua4k2m4QcKnPuK2uK8y8CQKYxnuKPuOybTsbEcVkSlzuvCt8PUSlpQJBL\nGSKzo/nJVs/5poLAw6iFfQH6id3AlVaI/75sGVgG5W3yBgu3L++BoNztcwG7zrf9\nc00th7zszCsHMiFHTu0XS6DOQlaOo7OSkb0wJJ/+JQ10IVm/beJcfG2wzHeUyUIs\nRyq2yEQFnPZttKRRd+j1egel7P05cHvtgUbnSTRZwHxllvMo6bLqpBpMx9WHHoze\nW0RgcGA/cqgYlsOaMsOedv4KzlYW4ibIAkKpFOg2iOpNE4uGyPewa1/f4DvqSVFL\nEqQ6deAMhDuf50arwkHWx/yeR5TFv/S6rtacD0GN1bpBDJ01eeRWd7MLVoGCZELv\nuqDoacVQ1Z1zePppKWCK6sXVjEM9BGs7dM1Gd/TYpzyY6KdiAQIVAce5SPvL2Nve\nlMrBqErRtbWfhThXia2+vHOJ/qC02b+eLHrs+gRFZFqz2nVbOTTyVqLibTZK6hyC\noZO6xtPzV0Cskcus92u4KsId3zDsxuo0L72zIejUmhb51AZNcrSQibwbO5iPHwur\nj2x0F5O+Jep5h/uDEiDe5qvCx0vPIwqS7ZZQYqVQBjnRx72wtW4=\n=Wv3f\n-----END PGP SIGNATURE-----", "payload": "tree 542ce91523921e3eea5c57a0606b342a29c33e10\nparent c3950c84c0ce89d6aad6f95042836912ce3ff3dc\nparent 057e6d3a35a54e8b88c2cef1e6a1b9e590066276\nauthor kennytm <kennytm@gmail.com> 1543597554 +0800\ncommitter kennytm <kennytm@gmail.com> 1543600395 +0800\n\nRollup merge of #56216 - SimonSapin:array-tryfrom-slice, r=withoutboats\n\nAdd TryFrom<&[T]> for [T; $N] where T: Copy\n\n`TryFrom<&[T]> for &[T; $N]` (note *reference* to an array) already exists, but not needing to dereference makes type inference easier for example when using `u32::from_be_bytes`.\n\nAlso add doc examples doing just that.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c407eb8bc9413d9d1449eeda9710715ad255a2", "html_url": "https://github.com/rust-lang/rust/commit/f7c407eb8bc9413d9d1449eeda9710715ad255a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7c407eb8bc9413d9d1449eeda9710715ad255a2/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3950c84c0ce89d6aad6f95042836912ce3ff3dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3950c84c0ce89d6aad6f95042836912ce3ff3dc", "html_url": "https://github.com/rust-lang/rust/commit/c3950c84c0ce89d6aad6f95042836912ce3ff3dc"}, {"sha": "057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "url": "https://api.github.com/repos/rust-lang/rust/commits/057e6d3a35a54e8b88c2cef1e6a1b9e590066276", "html_url": "https://github.com/rust-lang/rust/commit/057e6d3a35a54e8b88c2cef1e6a1b9e590066276"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "26e7a79d35df606e15d969c26ae9258370ccb6c3", "filename": "src/libcore/array.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7c407eb8bc9413d9d1449eeda9710715ad255a2/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c407eb8bc9413d9d1449eeda9710715ad255a2/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=f7c407eb8bc9413d9d1449eeda9710715ad255a2", "patch": "@@ -148,6 +148,15 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            impl<'a, T> TryFrom<&'a [T]> for [T; $N] where T: Copy {\n+                type Error = TryFromSliceError;\n+\n+                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n+                    <&Self>::try_from(slice).map(|r| *r)\n+                }\n+            }\n+\n             #[unstable(feature = \"try_from\", issue = \"33417\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;"}, {"sha": "46c098c8236a0498eececb310d3394d2c8a82a45", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f7c407eb8bc9413d9d1449eeda9710715ad255a2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c407eb8bc9413d9d1449eeda9710715ad255a2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f7c407eb8bc9413d9d1449eeda9710715ad255a2", "patch": "@@ -1989,6 +1989,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2008,6 +2021,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2037,6 +2063,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3719,6 +3758,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3738,6 +3790,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3767,6 +3832,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]"}]}