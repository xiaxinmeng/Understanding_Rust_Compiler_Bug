{"sha": "3e90a12a8a95933604a8b609197fce61bb24a38c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTBhMTJhOGE5NTkzMzYwNGE4YjYwOTE5N2ZjZTYxYmIyNGEzOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-29T19:28:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-29T19:28:21Z"}, "message": "Auto merge of #49878 - dlrobertson:va_list_pt0, r=eddyb\n\nlibcore: Add VaList and variadic arg handling intrinsics\n\n## Summary\n\n - Add intrinsics for `va_start`, `va_end`, `va_copy`, and `va_arg`.\n - Add `core::va_list::VaList` to `libcore`.\n\nPart 1 of (at least) 3 for #44930\n\nComments and critiques are very much welcomed \ud83d\ude04", "tree": {"sha": "cf4c1b0648179447fb3b5de1f51d2645c8b693f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf4c1b0648179447fb3b5de1f51d2645c8b693f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e90a12a8a95933604a8b609197fce61bb24a38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e90a12a8a95933604a8b609197fce61bb24a38c", "html_url": "https://github.com/rust-lang/rust/commit/3e90a12a8a95933604a8b609197fce61bb24a38c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e90a12a8a95933604a8b609197fce61bb24a38c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dde9e132207b5a40e12f8d5a1a363ebea60e0b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dde9e132207b5a40e12f8d5a1a363ebea60e0b0", "html_url": "https://github.com/rust-lang/rust/commit/3dde9e132207b5a40e12f8d5a1a363ebea60e0b0"}, {"sha": "e9e084f5fa8820aca67e5cf0ec301e52bbae1028", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e084f5fa8820aca67e5cf0ec301e52bbae1028", "html_url": "https://github.com/rust-lang/rust/commit/e9e084f5fa8820aca67e5cf0ec301e52bbae1028"}], "stats": {"total": 724, "additions": 711, "deletions": 13}, "files": [{"sha": "edeb3b0d368b3077b4e7982c4a46a3ab5bf2a05a", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -1,6 +1,7 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n \n #![allow(non_camel_case_types)]\n+#![cfg_attr(stage0, allow(dead_code))]\n \n //! Utilities related to FFI bindings.\n \n@@ -40,3 +41,187 @@ impl fmt::Debug for c_void {\n         f.pad(\"c_void\")\n     }\n }\n+\n+/// Basic implementation of a `va_list`.\n+#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+              not(target_arch = \"x86_64\")),\n+          windows))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+extern {\n+    type VaListImpl;\n+}\n+\n+#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+              not(target_arch = \"x86_64\")),\n+          windows))]\n+impl fmt::Debug for VaListImpl {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"va_list* {:p}\", self)\n+    }\n+}\n+\n+/// AArch64 ABI implementation of a `va_list`. See the\n+/// [Aarch64 Procedure Call Standard] for more details.\n+///\n+/// [AArch64 Procedure Call Standard]:\n+/// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n+#[cfg(all(target_arch = \"aarch64\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    stack: *mut (),\n+    gr_top: *mut (),\n+    vr_top: *mut (),\n+    gr_offs: i32,\n+    vr_offs: i32,\n+}\n+\n+/// PowerPC ABI implementation of a `va_list`.\n+#[cfg(all(target_arch = \"powerpc\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    gpr: u8,\n+    fpr: u8,\n+    reserved: u16,\n+    overflow_arg_area: *mut (),\n+    reg_save_area: *mut (),\n+}\n+\n+/// x86_64 ABI implementation of a `va_list`.\n+#[cfg(all(target_arch = \"x86_64\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    gp_offset: i32,\n+    fp_offset: i32,\n+    overflow_arg_area: *mut (),\n+    reg_save_area: *mut (),\n+}\n+\n+/// A wrapper for a `va_list`\n+#[lang = \"va_list\"]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+#[repr(transparent)]\n+#[cfg(not(stage0))]\n+pub struct VaList<'a>(&'a mut VaListImpl);\n+\n+// The VaArgSafe trait needs to be used in public interfaces, however, the trait\n+// itself must not be allowed to be used outside this module. Allowing users to\n+// implement the trait for a new type (thereby allowing the va_arg intrinsic to\n+// be used on a new type) is likely to cause undefined behavior.\n+//\n+// FIXME(dlrobertson): In order to use the VaArgSafe trait in a public interface\n+// but also ensure it cannot be used elsewhere, the trait needs to be public\n+// within a private module. Once RFC 2145 has been implemented look into\n+// improving this.\n+mod sealed_trait {\n+    /// Trait which whitelists the allowed types to be used with [VaList::arg]\n+    ///\n+    /// [VaList::va_arg]: struct.VaList.html#method.arg\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub trait VaArgSafe {}\n+}\n+\n+macro_rules! impl_va_arg_safe {\n+    ($($t:ty),+) => {\n+        $(\n+            #[unstable(feature = \"c_variadic\",\n+                       reason = \"the `c_variadic` feature has not been properly tested on \\\n+                                 all supported platforms\",\n+                       issue = \"27745\")]\n+            impl sealed_trait::VaArgSafe for $t {}\n+        )+\n+    }\n+}\n+\n+impl_va_arg_safe!{i8, i16, i32, i64, usize}\n+impl_va_arg_safe!{u8, u16, u32, u64, isize}\n+impl_va_arg_safe!{f64}\n+\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+impl<T> sealed_trait::VaArgSafe for *mut T {}\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+impl<T> sealed_trait::VaArgSafe for *const T {}\n+\n+#[cfg(not(stage0))]\n+impl<'a> VaList<'a> {\n+    /// Advance to the next arg.\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n+        va_arg(self)\n+    }\n+\n+    /// Copy the `va_list` at the current location.\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub unsafe fn copy<F, R>(&mut self, f: F) -> R\n+            where F: for<'copy> FnOnce(VaList<'copy>) -> R {\n+        #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+                      not(target_arch = \"x86_64\")),\n+                  windows))]\n+        let mut ap = va_copy(self);\n+        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+                  not(windows)))]\n+        let mut ap_inner = va_copy(self);\n+        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+                  not(windows)))]\n+        let mut ap = VaList(&mut ap_inner);\n+        let ret = f(VaList(ap.0));\n+        va_end(&mut ap);\n+        ret\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    /// Destroy the arglist `ap` after initialization with `va_start` or\n+    /// `va_copy`.\n+    fn va_end(ap: &mut VaList);\n+\n+    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+                  not(target_arch = \"x86_64\")),\n+              windows))]\n+    fn va_copy<'a>(src: &VaList<'a>) -> VaList<'a>;\n+    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+              not(windows)))]\n+    fn va_copy(src: &VaList) -> VaListImpl;\n+\n+    /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n+    /// argument `ap` points to.\n+    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaList) -> T;\n+}"}, {"sha": "e7a8baf7383956e9172af5ecdd6f335e2608e3f5", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -297,6 +297,7 @@ language_item_table! {\n     IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n \n     UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n \n     DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n     DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;"}, {"sha": "d954eb838cb8a5fed42a31a11f5c1f64f916aefd", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -723,17 +723,17 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n         ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n \n-    ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+        ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+        ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+        ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+        ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+        ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+\n+        ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+        ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+        ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+        ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+        ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n \n         ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n         ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n@@ -783,6 +783,11 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.assume\", fn(i1) -> void);\n         ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n+        // variadic intrinsics\n+        ifn!(\"llvm.va_start\", fn(i8p) -> void);\n+        ifn!(\"llvm.va_end\", fn(i8p) -> void);\n+        ifn!(\"llvm.va_copy\", fn(i8p, i8p) -> void);\n+\n         if self.sess().opts.debuginfo != DebugInfo::None {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);"}, {"sha": "9c9b73f63faedd54390983da48a668382bc6d45a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -24,13 +24,14 @@ use context::CodegenCx;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n use rustc_codegen_ssa::common::TypeKind;\n use rustc::hir;\n-use syntax::ast;\n+use syntax::ast::{self, FloatTy};\n use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n+use va_arg::emit_va_arg;\n \n use rustc_codegen_ssa::traits::*;\n \n@@ -146,6 +147,59 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 self.cx().const_usize(self.cx().size_of(tp_ty).bytes())\n             }\n+            func @ \"va_start\" | func @ \"va_end\" => {\n+                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n+                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n+                    (Some(_), _) => self.load(args[0].immediate(),\n+                                              tcx.data_layout.pointer_align.abi),\n+                    (None, _) => bug!(\"va_list language item must be defined\")\n+                };\n+                let intrinsic = self.cx().get_intrinsic(&format!(\"llvm.{}\", func));\n+                self.call(intrinsic, &[va_list], None)\n+            }\n+            \"va_copy\" => {\n+                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n+                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n+                    (Some(_), _)  => self.load(args[0].immediate(),\n+                                               tcx.data_layout.pointer_align.abi),\n+                    (None, _) => bug!(\"va_list language item must be defined\")\n+                };\n+                let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n+                self.call(intrinsic, &[llresult, va_list], None);\n+                return;\n+            }\n+            \"va_arg\" => {\n+                match fn_ty.ret.layout.abi {\n+                    layout::Abi::Scalar(ref scalar) => {\n+                        match scalar.value {\n+                            Primitive::Int(..) => {\n+                                if self.cx().size_of(ret_ty).bytes() < 4 {\n+                                    // va_arg should not be called on a integer type\n+                                    // less than 4 bytes in length. If it is, promote\n+                                    // the integer to a `i32` and truncate the result\n+                                    // back to the smaller type.\n+                                    let promoted_result = emit_va_arg(self, args[0],\n+                                                                      tcx.types.i32);\n+                                    self.trunc(promoted_result, llret_ty)\n+                                } else {\n+                                    emit_va_arg(self, args[0], ret_ty)\n+                                }\n+                            }\n+                            Primitive::Float(FloatTy::F64) |\n+                            Primitive::Pointer => {\n+                                emit_va_arg(self, args[0], ret_ty)\n+                            }\n+                            // `va_arg` should never be used with the return type f32.\n+                            Primitive::Float(FloatTy::F32) => {\n+                                bug!(\"the va_arg intrinsic does not work with `f32`\")\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"the va_arg intrinsic does not work with non-scalar types\")\n+                    }\n+                }\n+            }\n             \"size_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {"}, {"sha": "4f90cb793b6d22a107bba9963b8362ea20f14e57", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -127,6 +127,7 @@ mod mono_item;\n mod type_;\n mod type_of;\n mod value;\n+mod va_arg;\n \n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());"}, {"sha": "fbc3e6f06d147446511d49447939ea34ad816cb4", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use builder::Builder;\n+use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods, ConstMethods, DerivedTypeMethods};\n+use rustc::ty::layout::{Align, HasDataLayout, HasTyCtxt, LayoutOf, Size};\n+use rustc::ty::Ty;\n+use type_::Type;\n+use type_of::LayoutLlvmExt;\n+use value::Value;\n+\n+#[allow(dead_code)]\n+fn round_pointer_up_to_alignment(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    addr: &'ll Value,\n+    align: Align,\n+    ptr_ty: &'ll Type\n+) -> &'ll Value {\n+    let mut ptr_as_int = bx.ptrtoint(addr, bx.cx().type_isize());\n+    ptr_as_int = bx.add(ptr_as_int, bx.cx().const_i32(align.bytes() as i32 - 1));\n+    ptr_as_int = bx.and(ptr_as_int, bx.cx().const_i32(-(align.bytes() as i32)));\n+    bx.inttoptr(ptr_as_int, ptr_ty)\n+}\n+\n+fn emit_direct_ptr_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    list: OperandRef<'tcx, &'ll Value>,\n+    llty: &'ll Type,\n+    size: Size,\n+    align: Align,\n+    slot_size: Align,\n+    allow_higher_align: bool\n+) -> (&'ll Value, Align) {\n+    let va_list_ptr_ty = bx.cx().type_ptr_to(bx.cx.type_i8p());\n+    let va_list_addr = if list.layout.llvm_type(bx.cx) != va_list_ptr_ty {\n+        bx.bitcast(list.immediate(), va_list_ptr_ty)\n+    } else {\n+        list.immediate()\n+    };\n+\n+    let ptr = bx.load(va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+\n+    let (addr, addr_align) = if allow_higher_align && align > slot_size {\n+        (round_pointer_up_to_alignment(bx, ptr, align, bx.cx().type_i8p()), align)\n+    } else {\n+        (ptr, slot_size)\n+    };\n+\n+\n+    let aligned_size = size.align_to(slot_size).bytes() as i32;\n+    let full_direct_size = bx.cx().const_i32(aligned_size);\n+    let next = bx.inbounds_gep(addr, &[full_direct_size]);\n+    bx.store(next, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+\n+    if size.bytes() < slot_size.bytes() &&\n+            &*bx.tcx().sess.target.target.target_endian == \"big\" {\n+        let adjusted_size = bx.cx().const_i32((slot_size.bytes() - size.bytes()) as i32);\n+        let adjusted = bx.inbounds_gep(addr, &[adjusted_size]);\n+        (bx.bitcast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)\n+    } else {\n+        (bx.bitcast(addr, bx.cx().type_ptr_to(llty)), addr_align)\n+    }\n+}\n+\n+fn emit_ptr_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    list: OperandRef<'tcx, &'ll Value>,\n+    target_ty: Ty<'tcx>,\n+    indirect: bool,\n+    slot_size: Align,\n+    allow_higher_align: bool\n+) -> &'ll Value {\n+    let layout = bx.cx.layout_of(target_ty);\n+    let (llty, size, align) = if indirect {\n+        (bx.cx.layout_of(bx.cx.tcx.mk_imm_ptr(target_ty)).llvm_type(bx.cx),\n+         bx.cx.data_layout().pointer_size,\n+         bx.cx.data_layout().pointer_align)\n+    } else {\n+        (layout.llvm_type(bx.cx),\n+         layout.size,\n+         layout.align)\n+    };\n+    let (addr, addr_align) = emit_direct_ptr_va_arg(bx, list, llty, size, align.abi,\n+                                                    slot_size, allow_higher_align);\n+    if indirect {\n+        let tmp_ret = bx.load(addr, addr_align);\n+        bx.load(tmp_ret, align.abi)\n+    } else {\n+        bx.load(addr, addr_align)\n+    }\n+}\n+\n+pub(super) fn emit_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    addr: OperandRef<'tcx, &'ll Value>,\n+    target_ty: Ty<'tcx>,\n+) -> &'ll Value {\n+    // Determine the va_arg implementation to use. The LLVM va_arg instruction\n+    // is lacking in some instances, so we should only use it as a fallback.\n+    let arch = &bx.cx.tcx.sess.target.target.arch;\n+    match (&**arch,\n+           bx.cx.tcx.sess.target.target.options.is_like_windows) {\n+        (\"x86\", true) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(4).unwrap(), false)\n+        }\n+        (\"x86_64\", true) => {\n+            let target_ty_size = bx.cx.size_of(target_ty).bytes();\n+            let indirect = if target_ty_size > 8 || !target_ty_size.is_power_of_two() {\n+                true\n+            } else {\n+                false\n+            };\n+            emit_ptr_va_arg(bx, addr, target_ty, indirect,\n+                            Align::from_bytes(8).unwrap(), false)\n+        }\n+        (\"x86\", false) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(4).unwrap(), true)\n+        }\n+        _ => {\n+            let va_list = if (bx.tcx().sess.target.target.arch == \"aarch64\" ||\n+                              bx.tcx().sess.target.target.arch == \"x86_64\" ||\n+                              bx.tcx().sess.target.target.arch == \"powerpc\") &&\n+                             !bx.tcx().sess.target.target.options.is_like_windows {\n+                bx.load(addr.immediate(), bx.tcx().data_layout.pointer_align.abi)\n+            } else {\n+                addr.immediate()\n+            };\n+            bx.va_arg(va_list, bx.cx.layout_of(target_ty).llvm_type(bx.cx))\n+        }\n+    }\n+}\n+"}, {"sha": "2af21f547445eb202659f2cd31907b2308a3b1ed", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -14,6 +14,7 @@\n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::subst::Subst;\n use rustc::util::nodemap::FxHashMap;\n use require_same_types;\n \n@@ -81,6 +82,16 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n     let name = it.name.as_str();\n+\n+    let mk_va_list_ty = || {\n+        tcx.lang_items().va_list().map(|did| {\n+            let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n+            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+            let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n+            tcx.mk_mut_ref(tcx.mk_region(env_region), va_list_ty)\n+        })\n+    };\n+\n     let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n@@ -323,6 +334,47 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n+            \"va_start\" | \"va_end\" => {\n+                match mk_va_list_ty() {\n+                    Some(va_list_ty) => (0, vec![va_list_ty], tcx.mk_unit()),\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n+            \"va_copy\" => {\n+                match tcx.lang_items().va_list() {\n+                    Some(did) => {\n+                        let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n+                        let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+                        let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n+                        let ret_ty = match va_list_ty.sty {\n+                            ty::Adt(def, _) if def.is_struct() => {\n+                                let fields = &def.non_enum_variant().fields;\n+                                match tcx.type_of(fields[0].did).subst(tcx, &[region.into()]).sty {\n+                                    ty::Ref(_, element_ty, _) => match element_ty.sty {\n+                                        ty::Adt(..) => element_ty,\n+                                        _ => va_list_ty\n+                                    }\n+                                    _ => bug!(\"va_list structure is invalid\")\n+                                }\n+                            }\n+                            _ => {\n+                                bug!(\"va_list structure is invalid\")\n+                            }\n+                        };\n+                        (0, vec![tcx.mk_imm_ref(tcx.mk_region(env_region), va_list_ty)], ret_ty)\n+                    }\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n+            \"va_arg\" => {\n+                match mk_va_list_ty() {\n+                    Some(va_list_ty) => (1, vec![va_list_ty], param(0)),\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n             \"nontemporal_store\" => {\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_unit())\n             }"}, {"sha": "bd5fc3fa24a851f9948317c017a74db1cecb0188", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -174,5 +174,12 @@ pub use self::os_str::{OsString, OsStr};\n #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n pub use core::ffi::c_void;\n \n+#[cfg(not(stage0))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+pub use core::ffi::VaList;\n+\n mod c_str;\n mod os_str;"}, {"sha": "5945ba6b09066d7aa3e44c732f12a6358dce7463", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -244,6 +244,7 @@\n #![feature(array_error_internals)]\n #![feature(asm)]\n #![feature(box_syntax)]\n+#![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(cfg_target_vendor)]"}, {"sha": "f124ca2ab614ae3a20adcba48776792c51b9fb0a", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2FMakefile?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) checkrust.rs\n+\t$(CC) test.c $(call STATICLIB,checkrust) $(call OUT_EXE,test) $(EXTRACFLAGS)\n+\t$(call RUN,test)"}, {"sha": "d4cc4a0ed5e2b08ca27d439aa56b7840c4c19839", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/checkrust.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"staticlib\"]\n+#![feature(c_variadic)]\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+use libc::{c_char, c_double, c_int, c_long, c_longlong};\n+use std::ffi::VaList;\n+use std::slice;\n+use std::ffi::CStr;\n+\n+#[repr(C)]\n+#[derive(Clone, Copy, Debug)]\n+pub enum AnswerType {\n+    Double,\n+    Long,\n+    LongLong,\n+    Int,\n+    Byte,\n+    CStr,\n+    Skip,\n+}\n+\n+#[repr(C)]\n+pub union AnswerData {\n+    pub double: c_double,\n+    pub long: c_long,\n+    pub longlong: c_longlong,\n+    pub int: c_int,\n+    pub byte: c_char,\n+    pub cstr: *const c_char,\n+    pub skip_ty: AnswerType,\n+}\n+\n+#[repr(C)]\n+pub struct Answer {\n+    tag: AnswerType,\n+    data: AnswerData,\n+}\n+\n+#[no_mangle]\n+pub unsafe fn compare_answers(answers: &[Answer], mut ap: VaList) -> usize {\n+    for (i, answer) in answers.iter().enumerate() {\n+        match answer {\n+            Answer { tag: AnswerType::Double, data: AnswerData { double: d } } => {\n+                let tmp = ap.arg::<c_double>();\n+                if d.floor() != tmp.floor() {\n+                    println!(\"Double: {} != {}\", d, tmp);\n+                    return i + 1;\n+                }\n+            }\n+            Answer { tag: AnswerType::Long, data: AnswerData { long: l } } => {\n+                let tmp =  ap.arg::<c_long>();\n+                if *l != tmp {\n+                    println!(\"Long: {} != {}\", l, tmp);\n+                    return i + 1;\n+                }\n+            }\n+            Answer { tag: AnswerType::LongLong, data: AnswerData { longlong: l } } => {\n+                let tmp =  ap.arg::<c_longlong>();\n+                if *l != tmp {\n+                    println!(\"Long Long: {} != {}\", l, tmp);\n+                    return i + 1;\n+                }\n+            }\n+            Answer { tag: AnswerType::Int, data: AnswerData { int: n } } => {\n+                let tmp = ap.arg::<c_int>();\n+                if *n != tmp {\n+                    println!(\"Int: {} != {}\", n, tmp);\n+                    return i + 1;\n+                }\n+            }\n+            Answer { tag: AnswerType::Byte, data: AnswerData { byte: b } } => {\n+                let tmp = ap.arg::<c_char>();\n+                if *b != tmp {\n+                    println!(\"Byte: {} != {}\", b, tmp);\n+                    return i + 1;\n+                }\n+            }\n+            Answer { tag: AnswerType::CStr, data: AnswerData { cstr: c0 } } => {\n+                let c1 = ap.arg::<*const c_char>();\n+                let cstr0 = CStr::from_ptr(*c0);\n+                let cstr1 = CStr::from_ptr(c1);\n+                if cstr0 != cstr1 {\n+                    println!(\"C String: {:?} != {:?}\", cstr0, cstr1);\n+                    return i + 1;\n+                }\n+            }\n+            _ => {\n+                println!(\"Unknown type!\");\n+                return i + 1;\n+            }\n+        }\n+    }\n+    return 0;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_rust(argc: usize, answers: *const Answer, ap: VaList) -> usize {\n+    let slice = slice::from_raw_parts(answers, argc);\n+    compare_answers(slice, ap)\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_rust_copy(argc: usize, answers: *const Answer,\n+                                         mut ap: VaList) -> usize {\n+    let slice = slice::from_raw_parts(answers, argc);\n+    let mut skip_n = 0;\n+    for (i, answer) in slice.iter().enumerate() {\n+        match answer {\n+            Answer { tag: AnswerType::Skip, data: AnswerData { skip_ty } } => {\n+                match skip_ty {\n+                    AnswerType::Double => { ap.arg::<c_double>(); }\n+                    AnswerType::Long => { ap.arg::<c_long>(); }\n+                    AnswerType::LongLong => { ap.arg::<c_longlong>(); }\n+                    AnswerType::Int => { ap.arg::<c_int>(); }\n+                    AnswerType::Byte => { ap.arg::<c_char>(); }\n+                    AnswerType::CStr => { ap.arg::<*const c_char>(); }\n+                    _ => { return i; }\n+                };\n+            }\n+            _ => {\n+                skip_n = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    ap.copy(|ap| {\n+        compare_answers(&slice[skip_n..], ap)\n+    })\n+}"}, {"sha": "80d9a48014203544ab7df4972dee5afc7e8d4abe", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/test.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdarg.h>\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+typedef enum {\n+    TAG_DOUBLE,\n+    TAG_LONG,\n+    TAG_LONGLONG,\n+    TAG_INT,\n+    TAG_BYTE,\n+    TAG_CSTR,\n+    TAG_SKIP,\n+} tag;\n+\n+typedef struct {\n+    tag answer_type;\n+    union {\n+        double double_precision;\n+        long num_long;\n+        long long num_longlong;\n+        int num_int;\n+        int8_t byte;\n+        char* cstr;\n+        tag skip_ty;\n+    } answer_data;\n+} answer;\n+\n+#define MK_DOUBLE(n) \\\n+    { TAG_DOUBLE, { .double_precision = n } }\n+#define MK_LONG(n) \\\n+    { TAG_LONG, { .num_long = n } }\n+#define MK_LONGLONG(n) \\\n+    { TAG_LONGLONG, { .num_longlong = n } }\n+#define MK_INT(n) \\\n+    { TAG_INT, { .num_int = n } }\n+#define MK_BYTE(b) \\\n+    { TAG_BYTE, { .byte = b } }\n+#define MK_CSTR(s) \\\n+    { TAG_CSTR, { .cstr = s } }\n+#define MK_SKIP(ty) \\\n+    { TAG_SKIP, { .skip_ty = TAG_ ## ty } }\n+\n+extern size_t check_rust(size_t argc, const answer* answers, va_list ap);\n+extern size_t check_rust_copy(size_t argc, const answer* answers, va_list ap);\n+\n+size_t test_check_rust(size_t argc, const answer* answers, ...) {\n+    size_t ret = 0;\n+    va_list ap;\n+    va_start(ap, answers);\n+    ret = check_rust(argc, answers, ap);\n+    va_end(ap);\n+    return ret;\n+}\n+\n+size_t test_check_rust_copy(size_t argc, const answer* answers, ...) {\n+    size_t ret = 0;\n+    va_list ap;\n+    va_start(ap, answers);\n+    ret = check_rust_copy(argc, answers, ap);\n+    va_end(ap);\n+    return ret;\n+}\n+\n+int main(int argc, char* argv[]) {\n+    answer test_alignment0[] = {MK_LONGLONG(0x01LL), MK_INT(0x02), MK_LONGLONG(0x03LL)};\n+    assert(test_check_rust(3, test_alignment0, 0x01LL, 0x02, 0x03LL) == 0);\n+\n+    answer test_alignment1[] = {MK_INT(-1), MK_BYTE('A'), MK_BYTE('4'), MK_BYTE(';'),\n+                                MK_INT(0x32), MK_INT(0x10000001), MK_CSTR(\"Valid!\")};\n+    assert(test_check_rust(7, test_alignment1, -1, 'A', '4', ';', 0x32, 0x10000001,\n+                           \"Valid!\") == 0);\n+\n+    answer basic_answers[] = {MK_DOUBLE(3.14), MK_LONG(12l), MK_BYTE('a'),\n+                              MK_DOUBLE(6.28), MK_CSTR(\"Hello\"), MK_INT(42),\n+                              MK_CSTR(\"World\")};\n+    assert(test_check_rust(7, basic_answers, 3.14, 12l, 'a', 6.28, \"Hello\",\n+                           42, \"World\") == 0);\n+\n+    answer copy_answers[] = { MK_SKIP(DOUBLE), MK_SKIP(INT), MK_SKIP(BYTE), MK_SKIP(CSTR),\n+                              MK_CSTR(\"Correctly skipped and copied list\") };\n+    assert(test_check_rust_copy(5, copy_answers, 6.28, 16, 'A', \"Skip Me!\",\n+                                \"Correctly skipped and copied list\") == 0);\n+    return 0;\n+}"}, {"sha": "822db253191387ddd384d734c4dffecf558f9eaa", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e90a12a8a95933604a8b609197fce61bb24a38c/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=3e90a12a8a95933604a8b609197fce61bb24a38c", "patch": "@@ -74,6 +74,13 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libcore/tests\",\n     \"src/liballoc/tests/lib.rs\",\n \n+    // The `VaList` implementation must have platform specific code.\n+    // The Windows implementation of a `va_list` is always a character\n+    // pointer regardless of the target architecture. As a result,\n+    // we must use `#[cfg(windows)]` to conditionally compile the\n+    // correct `VaList` structure for windows.\n+    \"src/libcore/ffi.rs\",\n+\n     // non-std crates\n     \"src/test\",\n     \"src/tools\","}]}