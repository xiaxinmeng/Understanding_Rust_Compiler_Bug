{"sha": "1529067a046b079c1348ead39199e9c491a5f472", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MjkwNjdhMDQ2YjA3OWMxMzQ4ZWFkMzkxOTllOWM0OTFhNWY0NzI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-29T08:00:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-29T08:00:13Z"}, "message": "split libcore::mem into multiple files", "tree": {"sha": "ddc4c1173e6852b24884f94efb67e6c82dd013cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddc4c1173e6852b24884f94efb67e6c82dd013cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1529067a046b079c1348ead39199e9c491a5f472", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1529067a046b079c1348ead39199e9c491a5f472", "html_url": "https://github.com/rust-lang/rust/commit/1529067a046b079c1348ead39199e9c491a5f472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1529067a046b079c1348ead39199e9c491a5f472/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "html_url": "https://github.com/rust-lang/rust/commit/4b9d80325a65b0375eea526409a0f3aaf1cbc23c"}], "stats": {"total": 2823, "additions": 1417, "deletions": 1406}, "files": [{"sha": "40f4354213b40849bf253c7d1bb10bab04a86761", "filename": "src/libcore/mem.rs", "status": "removed", "additions": 0, "deletions": 1406, "changes": 1406, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,1406 +0,0 @@\n-//! Basic functions for dealing with memory.\n-//!\n-//! This module contains functions for querying the size and alignment of\n-//! types, initializing and manipulating memory.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::clone;\n-use crate::cmp;\n-use crate::fmt;\n-use crate::hash;\n-use crate::intrinsics;\n-use crate::marker::{Copy, PhantomData, Sized};\n-use crate::ptr;\n-use crate::ops::{Deref, DerefMut};\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(inline)]\n-pub use crate::intrinsics::transmute;\n-\n-/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n-///\n-/// Any resources the value manages, such as heap memory or a file handle, will linger\n-/// forever in an unreachable state. However, it does not guarantee that pointers\n-/// to this memory will remain valid.\n-///\n-/// * If you want to leak memory, see [`Box::leak`][leak].\n-/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n-/// * If you want to dispose of a value properly, running its destructor, see\n-/// [`mem::drop`][drop].\n-///\n-/// # Safety\n-///\n-/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n-/// do not include a guarantee that destructors will always run. For example,\n-/// a program can create a reference cycle using [`Rc`][rc], or call\n-/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n-/// `mem::forget` from safe code does not fundamentally change Rust's safety\n-/// guarantees.\n-///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n-///\n-/// Because forgetting a value is allowed, any `unsafe` code you write must\n-/// allow for this possibility. You cannot return a value and expect that the\n-/// caller will necessarily run the value's destructor.\n-///\n-/// [rc]: ../../std/rc/struct.Rc.html\n-/// [exit]: ../../std/process/fn.exit.html\n-///\n-/// # Examples\n-///\n-/// Leak an I/O object, never closing the file:\n-///\n-/// ```no_run\n-/// use std::mem;\n-/// use std::fs::File;\n-///\n-/// let file = File::open(\"foo.txt\").unwrap();\n-/// mem::forget(file);\n-/// ```\n-///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n-///\n-/// [drop]: fn.drop.html\n-/// [uninit]: fn.uninitialized.html\n-/// [clone]: ../clone/trait.Clone.html\n-/// [swap]: fn.swap.html\n-/// [box]: ../../std/boxed/struct.Box.html\n-/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n-/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn forget<T>(t: T) {\n-    ManuallyDrop::new(t);\n-}\n-\n-/// Like [`forget`], but also accepts unsized values.\n-///\n-/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n-/// stabilized.\n-///\n-/// [`forget`]: fn.forget.html\n-#[inline]\n-#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n-pub fn forget_unsized<T: ?Sized>(t: T) {\n-    unsafe { intrinsics::forget(t) }\n-}\n-\n-/// Returns the size of a type in bytes.\n-///\n-/// More specifically, this is the offset in bytes between successive elements\n-/// in an array with that item type including alignment padding. Thus, for any\n-/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n-///\n-/// In general, the size of a type is not stable across compilations, but\n-/// specific types such as primitives are.\n-///\n-/// The following table gives the size for primitives.\n-///\n-/// Type | size_of::\\<Type>()\n-/// ---- | ---------------\n-/// () | 0\n-/// bool | 1\n-/// u8 | 1\n-/// u16 | 2\n-/// u32 | 4\n-/// u64 | 8\n-/// u128 | 16\n-/// i8 | 1\n-/// i16 | 2\n-/// i32 | 4\n-/// i64 | 8\n-/// i128 | 16\n-/// f32 | 4\n-/// f64 | 8\n-/// char | 4\n-///\n-/// Furthermore, `usize` and `isize` have the same size.\n-///\n-/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n-/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n-///\n-/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n-/// have the same size. Likewise for `*const T` and `*mut T`.\n-///\n-/// # Size of `#[repr(C)]` items\n-///\n-/// The `C` representation for items has a defined layout. With this layout,\n-/// the size of items is also stable as long as all fields have a stable size.\n-///\n-/// ## Size of Structs\n-///\n-/// For `structs`, the size is determined by the following algorithm.\n-///\n-/// For each field in the struct ordered by declaration order:\n-///\n-/// 1. Add the size of the field.\n-/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n-///\n-/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n-/// The alignment of the struct is usually the largest alignment of all its\n-/// fields; this can be changed with the use of `repr(align(N))`.\n-///\n-/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n-///\n-/// ## Size of Enums\n-///\n-/// Enums that carry no data other than the discriminant have the same size as C enums\n-/// on the platform they are compiled for.\n-///\n-/// ## Size of Unions\n-///\n-/// The size of a union is the size of its largest field.\n-///\n-/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// // Some primitives\n-/// assert_eq!(4, mem::size_of::<i32>());\n-/// assert_eq!(8, mem::size_of::<f64>());\n-/// assert_eq!(0, mem::size_of::<()>());\n-///\n-/// // Some arrays\n-/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n-/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n-/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n-///\n-///\n-/// // Pointer size equality\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n-/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n-/// ```\n-///\n-/// Using `#[repr(C)]`.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(C)]\n-/// struct FieldStruct {\n-///     first: u8,\n-///     second: u16,\n-///     third: u8\n-/// }\n-///\n-/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n-/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n-/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n-/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n-/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n-/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n-/// // fields is 2), so add 1 to the size for padding. Size is 6.\n-/// assert_eq!(6, mem::size_of::<FieldStruct>());\n-///\n-/// #[repr(C)]\n-/// struct TupleStruct(u8, u16, u8);\n-///\n-/// // Tuple structs follow the same rules.\n-/// assert_eq!(6, mem::size_of::<TupleStruct>());\n-///\n-/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n-/// // by putting `third` before `second`.\n-/// #[repr(C)]\n-/// struct FieldStructOptimized {\n-///     first: u8,\n-///     third: u8,\n-///     second: u16\n-/// }\n-///\n-/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n-///\n-/// // Union size is the size of the largest field.\n-/// #[repr(C)]\n-/// union ExampleUnion {\n-///     smaller: u8,\n-///     larger: u16\n-/// }\n-///\n-/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n-/// ```\n-///\n-/// [alignment]: ./fn.align_of.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn size_of<T>() -> usize {\n-    intrinsics::size_of::<T>()\n-}\n-\n-/// Returns the size of the pointed-to value in bytes.\n-///\n-/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n-/// then `size_of_val` can be used to get the dynamically-known size.\n-///\n-/// [slice]: ../../std/primitive.slice.html\n-/// [trait object]: ../../book/ch17-02-trait-objects.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of_val(&5i32));\n-///\n-/// let x: [u8; 13] = [0; 13];\n-/// let y: &[u8] = &x;\n-/// assert_eq!(13, mem::size_of_val(y));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::size_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n-pub fn min_align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n-pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns `true` if dropping values of type `T` matters.\n-///\n-/// This is purely an optimization hint, and may be implemented conservatively:\n-/// it may return `true` for types that don't actually need to be dropped.\n-/// As such always returning `true` would be a valid implementation of\n-/// this function. However if this function actually returns `false`, then you\n-/// can be certain dropping `T` has no side effect.\n-///\n-/// Low level implementations of things like collections, which need to manually\n-/// drop their data, should use this function to avoid unnecessarily\n-/// trying to drop all their contents when they are destroyed. This might not\n-/// make a difference in release builds (where a loop that has no side-effects\n-/// is easily detected and eliminated), but is often a big win for debug builds.\n-///\n-/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n-/// can be reduced to some small number of drop_in_place calls, using this is\n-/// unnecessary. In particular note that you can drop_in_place a slice, and that\n-/// will do a single needs_drop check for all the values.\n-///\n-/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n-/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n-/// values one at a time and should use this API.\n-///\n-///\n-/// # Examples\n-///\n-/// Here's an example of how a collection might make use of needs_drop:\n-///\n-/// ```\n-/// use std::{mem, ptr};\n-///\n-/// pub struct MyCollection<T> {\n-/// #   data: [T; 1],\n-///     /* ... */\n-/// }\n-/// # impl<T> MyCollection<T> {\n-/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n-/// #   fn free_buffer(&mut self) {}\n-/// # }\n-///\n-/// impl<T> Drop for MyCollection<T> {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // drop the data\n-///             if mem::needs_drop::<T>() {\n-///                 for x in self.iter_mut() {\n-///                     ptr::drop_in_place(x);\n-///                 }\n-///             }\n-///             self.free_buffer();\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n-pub const fn needs_drop<T>() -> bool {\n-    intrinsics::needs_drop::<T>()\n-}\n-\n-/// Creates a value whose bytes are all zero.\n-///\n-/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n-/// It is useful for FFI sometimes, but should generally be avoided.\n-///\n-/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n-/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n-/// that there always is a valid value in a variable it considers initialized.\n-///\n-/// [zeroed]: union.MaybeUninit.html#method.zeroed\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-///\n-/// # Examples\n-///\n-/// Correct usage of this function: initializing an integer with zero.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let x: i32 = unsafe { mem::zeroed() };\n-/// assert_eq!(0, x);\n-/// ```\n-///\n-/// *Incorrect* usage of this function: initializing a reference with zero.\n-///\n-/// ```no_run\n-/// use std::mem;\n-///\n-/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::init()\n-}\n-\n-/// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type `T`, while doing nothing at all.\n-///\n-/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n-///\n-/// The reason for deprecation is that the function basically cannot be used\n-/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n-/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n-/// undefined behavior for returning a `bool` that is not definitely either `true`\n-/// or `false`. Worse, truly uninitialized memory like what gets returned here\n-/// is special in that the compiler knows that it does not have a fixed value.\n-/// This makes it undefined behavior to have uninitialized data in a variable even\n-/// if that variable has an integer type.\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-#[inline]\n-#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::uninit()\n-}\n-\n-/// Swaps the values at two mutable locations, without deinitializing either one.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut x = 5;\n-/// let mut y = 42;\n-///\n-/// mem::swap(&mut x, &mut y);\n-///\n-/// assert_eq!(42, x);\n-/// assert_eq!(5, y);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn swap<T>(x: &mut T, y: &mut T) {\n-    unsafe {\n-        ptr::swap_nonoverlapping_one(x, y);\n-    }\n-}\n-\n-/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n-///\n-/// Neither value is dropped.\n-///\n-/// # Examples\n-///\n-/// A simple example:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut v: Vec<i32> = vec![1, 2];\n-///\n-/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n-/// assert_eq!(vec![1, 2], old_v);\n-/// assert_eq!(vec![3, 4, 5], v);\n-/// ```\n-///\n-/// `replace` allows consumption of a struct field by replacing it with another value.\n-/// Without `replace` you can run into issues like these:\n-///\n-/// ```compile_fail,E0507\n-/// struct Buffer<T> { buf: Vec<T> }\n-///\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         // error: cannot move out of dereference of `&mut`-pointer\n-///         let buf = self.buf;\n-///         self.buf = Vec::new();\n-///         buf\n-///     }\n-/// }\n-/// ```\n-///\n-/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n-/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n-/// `self`, allowing it to be returned:\n-///\n-/// ```\n-/// # #![allow(dead_code)]\n-/// use std::mem;\n-///\n-/// # struct Buffer<T> { buf: Vec<T> }\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         mem::replace(&mut self.buf, Vec::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n-    swap(dest, &mut src);\n-    src\n-}\n-\n-/// Disposes of a value.\n-///\n-/// This does call the argument's implementation of [`Drop`][drop].\n-///\n-/// This effectively does nothing for types which implement `Copy`, e.g.\n-/// integers. Such values are copied and _then_ moved into the function, so the\n-/// value persists after this function call.\n-///\n-/// This function is not magic; it is literally defined as\n-///\n-/// ```\n-/// pub fn drop<T>(_x: T) { }\n-/// ```\n-///\n-/// Because `_x` is moved into the function, it is automatically dropped before\n-/// the function returns.\n-///\n-/// [drop]: ../ops/trait.Drop.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-///\n-/// drop(v); // explicitly drop the vector\n-/// ```\n-///\n-/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n-/// release a [`RefCell`] borrow:\n-///\n-/// ```\n-/// use std::cell::RefCell;\n-///\n-/// let x = RefCell::new(1);\n-///\n-/// let mut mutable_borrow = x.borrow_mut();\n-/// *mutable_borrow = 1;\n-///\n-/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n-///\n-/// let borrow = x.borrow();\n-/// println!(\"{}\", *borrow);\n-/// ```\n-///\n-/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct Foo(u8);\n-///\n-/// let x = 1;\n-/// let y = Foo(2);\n-/// drop(x); // a copy of `x` is moved and dropped\n-/// drop(y); // a copy of `y` is moved and dropped\n-///\n-/// println!(\"x: {}, y: {}\", x, y.0); // still available\n-/// ```\n-///\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T>(_x: T) { }\n-\n-/// Interprets `src` as having type `&U`, and then reads `src` without moving\n-/// the contained value.\n-///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n-/// the `&U`. It will also unsafely create a copy of the contained value instead of\n-/// moving out of `src`.\n-///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n-/// `T`.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [size_of]: fn.size_of.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(packed)]\n-/// struct Foo {\n-///     bar: u8,\n-/// }\n-///\n-/// let foo_slice = [10u8];\n-///\n-/// unsafe {\n-///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n-///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n-///     assert_eq!(foo_struct.bar, 10);\n-///\n-///     // Modify the copied data\n-///     foo_struct.bar = 20;\n-///     assert_eq!(foo_struct.bar, 20);\n-/// }\n-///\n-/// // The contents of 'foo_slice' should not have changed\n-/// assert_eq!(foo_slice, [10]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read_unaligned(src as *const T as *const U)\n-}\n-\n-/// Opaque type representing the discriminant of an enum.\n-///\n-/// See the [`discriminant`] function in this module for more information.\n-///\n-/// [`discriminant`]: fn.discriminant.html\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n-\n-// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> Copy for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> clone::Clone for Discriminant<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::PartialEq for Discriminant<T> {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.0 == rhs.0\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::Eq for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> hash::Hash for Discriminant<T> {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.0.hash(state);\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> fmt::Debug for Discriminant<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_tuple(\"Discriminant\")\n-           .field(&self.0)\n-           .finish()\n-    }\n-}\n-\n-/// Returns a value uniquely identifying the enum variant in `v`.\n-///\n-/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n-/// return value is unspecified.\n-///\n-/// # Stability\n-///\n-/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n-/// of some variant will not change between compilations with the same compiler.\n-///\n-/// # Examples\n-///\n-/// This can be used to compare enums that carry data, while disregarding\n-/// the actual data:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// enum Foo { A(&'static str), B(i32), C(i32) }\n-///\n-/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n-/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n-/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n-/// ```\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n-    unsafe {\n-        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n-    }\n-}\n-\n-/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n-///\n-/// This wrapper is 0-cost.\n-///\n-/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n-/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n-/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n-///\n-/// # Examples\n-///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n-///\n-/// ```rust\n-/// use std::mem::ManuallyDrop;\n-/// struct Peach;\n-/// struct Banana;\n-/// struct Melon;\n-/// struct FruitBox {\n-///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n-///     peach: ManuallyDrop<Peach>,\n-///     melon: Melon, // Field that\u2019s independent of the other two.\n-///     banana: ManuallyDrop<Banana>,\n-/// }\n-///\n-/// impl Drop for FruitBox {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // Explicit ordering in which field destructors are run specified in the intuitive\n-///             // location \u2013 the destructor of the structure containing the fields.\n-///             // Moreover, one can now reorder fields within the struct however much they want.\n-///             ManuallyDrop::drop(&mut self.peach);\n-///             ManuallyDrop::drop(&mut self.banana);\n-///         }\n-///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n-///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`mem::zeroed`]: fn.zeroed.html\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[lang = \"manually_drop\"]\n-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[repr(transparent)]\n-pub struct ManuallyDrop<T: ?Sized> {\n-    value: T,\n-}\n-\n-impl<T> ManuallyDrop<T> {\n-    /// Wrap a value to be manually dropped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// ManuallyDrop::new(Box::new(()));\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn new(value: T) -> ManuallyDrop<T> {\n-        ManuallyDrop { value }\n-    }\n-\n-    /// Extracts the value from the `ManuallyDrop` container.\n-    ///\n-    /// This allows the value to be dropped again.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// let x = ManuallyDrop::new(Box::new(()));\n-    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n-        slot.value\n-    }\n-\n-    /// Takes the contained value out.\n-    ///\n-    /// This method is primarily intended for moving out values in drop.\n-    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n-    /// you can use this method to take the value and use it however desired.\n-    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n-    ///\n-    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function semantically moves out the contained value without preventing further usage.\n-    /// It is up to the user of this method to ensure that this container is not used again.\n-    ///\n-    /// [`ManuallyDrop::drop`]: #method.drop\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n-    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n-    #[inline]\n-    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ManuallyDrop::into_inner(ptr::read(slot))\n-    }\n-}\n-\n-impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n-    ///\n-    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    ///\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> Deref for ManuallyDrop<T> {\n-    type Target = T;\n-    #[inline(always)]\n-    fn deref(&self) -> &T {\n-        &self.value\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n-    #[inline(always)]\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.value\n-    }\n-}\n-\n-/// A wrapper type to construct uninitialized instances of `T`.\n-///\n-/// # Initialization invariant\n-///\n-/// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type. For example, a variable of reference type must\n-/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n-/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n-/// ever gets used to access memory:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<&i32>`:\n-/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// This is exploited by the compiler for various optimizations, such as eliding\n-/// run-time checks and optimizing `enum` layout.\n-///\n-/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n-/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<bool>`:\n-/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// Moreover, uninitialized memory is special in that the compiler knows that\n-/// it does not have a fixed value. This makes it undefined behavior to have\n-/// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any *fixed* bit pattern:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<i32>`:\n-/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// On top of that, remember that most types have additional invariants beyond merely\n-/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n-/// is considered initialized because the only requirement the compiler knows about it\n-/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n-/// *immediate* undefined behavior, but will cause undefined behavior with most\n-/// safe operations (including dropping it).\n-///\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-///\n-/// # Examples\n-///\n-/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n-/// It is a signal to the compiler indicating that the data here might *not*\n-/// be initialized:\n-///\n-/// ```rust\n-/// use std::mem::MaybeUninit;\n-///\n-/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n-/// let mut x = MaybeUninit::<&i32>::uninit();\n-/// // Set it to a valid value.\n-/// unsafe { x.as_mut_ptr().write(&0); }\n-/// // Extract the initialized data -- this is only allowed *after* properly\n-/// // initializing `x`!\n-/// let x = unsafe { x.assume_init() };\n-/// ```\n-///\n-/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-///\n-/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n-/// any of the run-time tracking and without any of the safety checks.\n-///\n-/// ## out-pointers\n-///\n-/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n-/// from a function, pass it a pointer to some (uninitialized) memory to put the\n-/// result into. This can be useful when it is important for the caller to control\n-/// how the memory the result is stored in gets allocated, and you want to avoid\n-/// unnecessary moves.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-///\n-/// unsafe fn make_vec(out: *mut Vec<i32>) {\n-///     // `write` does not drop the old contents, which is important.\n-///     out.write(vec![1, 2, 3]);\n-/// }\n-///\n-/// let mut v = MaybeUninit::uninit();\n-/// unsafe { make_vec(v.as_mut_ptr()); }\n-/// // Now we know `v` is initialized! This also makes sure the vector gets\n-/// // properly dropped.\n-/// let v = unsafe { v.assume_init() };\n-/// assert_eq!(&v, &[1, 2, 3]);\n-/// ```\n-///\n-/// ## Initializing an array element-by-element\n-///\n-/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n-///\n-/// ```\n-/// use std::mem::{self, MaybeUninit};\n-/// use std::ptr;\n-///\n-/// let data = {\n-///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-///     // safe because the type we are claiming to have initialized here is a\n-///     // bunch of `MaybeUninit`s, which do not require initialization.\n-///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n-///         MaybeUninit::uninit().assume_init()\n-///     };\n-///\n-///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n-///     // we have a memory leak, but there is no memory safety issue.\n-///     for elem in &mut data[..] {\n-///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n-///     }\n-///\n-///     // Everything is initialized. Transmute the array to the\n-///     // initialized type.\n-///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n-/// };\n-///\n-/// assert_eq!(&data[0], &[42]);\n-/// ```\n-///\n-/// You can also work with partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-/// use std::ptr;\n-///\n-/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-/// // safe because the type we are claiming to have initialized here is a\n-/// // bunch of `MaybeUninit`s, which do not require initialization.\n-/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-///\n-/// for elem in &mut data[0..500] {\n-///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n-///     data_len += 1;\n-/// }\n-///\n-/// // For each item in the array, drop if we allocated it.\n-/// for elem in &mut data[0..data_len] {\n-///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n-/// }\n-/// ```\n-///\n-/// ## Initializing a struct field-by-field\n-///\n-/// There is currently no supported way to create a raw pointer or reference\n-/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n-/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n-/// to its fields.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-///\n-/// # Layout\n-///\n-/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n-///\n-/// ```rust\n-/// use std::mem::{MaybeUninit, size_of, align_of};\n-/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n-/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n-/// ```\n-///\n-/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n-/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n-/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n-/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n-/// optimizations, potentially resulting in a larger size:\n-///\n-/// ```rust\n-/// # use std::mem::{MaybeUninit, size_of};\n-/// assert_eq!(size_of::<Option<bool>>(), 1);\n-/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n-/// ```\n-#[allow(missing_debug_implementations)]\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-#[derive(Copy)]\n-pub union MaybeUninit<T> {\n-    uninit: (),\n-    value: ManuallyDrop<T>,\n-}\n-\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-impl<T: Copy> Clone for MaybeUninit<T> {\n-    #[inline(always)]\n-    fn clone(&self) -> Self {\n-        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n-        *self\n-    }\n-}\n-\n-impl<T> MaybeUninit<T> {\n-    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n-    /// It is safe to call [`assume_init`] on the return value of this function.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// [`assume_init`]: #method.assume_init\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn new(val: T) -> MaybeUninit<T> {\n-        MaybeUninit { value: ManuallyDrop::new(val) }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// See the [type-level documentation][type] for some examples.\n-    ///\n-    /// [type]: union.MaybeUninit.html\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn uninit() -> MaybeUninit<T> {\n-        MaybeUninit { uninit: () }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes. It depends on `T` whether that already makes for\n-    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n-    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n-    /// be null.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// # Example\n-    ///\n-    /// Correct usage of this function: initializing a struct with zero, where all\n-    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// assert_eq!(x, (0, false));\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n-    /// cannot hold 0 as a valid value.\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// enum NotZero { One = 1, Two = 2 };\n-    ///\n-    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n-    /// // This is undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline]\n-    pub fn zeroed() -> MaybeUninit<T> {\n-        let mut u = MaybeUninit::<T>::uninit();\n-        unsafe {\n-            u.as_mut_ptr().write_bytes(0u8, 1);\n-        }\n-        u\n-    }\n-\n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn write(&mut self, val: T) -> &mut T {\n-        unsafe {\n-            self.value = ManuallyDrop::new(val);\n-            self.get_mut()\n-        }\n-    }\n-\n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n-    /// (except inside an `UnsafeCell<T>`).\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// assert_eq!(x_vec.len(), 3);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n-    /// // This is okay because we initialized it.\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// x_vec.push(3);\n-    /// assert_eq!(x_vec.len(), 4);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n-    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n-    /// to ensure that the data will get dropped, because the resulting `T` is\n-    /// subject to the usual drop handling.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<bool>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(true); }\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// assert_eq!(x_init, true);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub unsafe fn assume_init(self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n-    }\n-\n-    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n-    /// to the usual drop handling.\n-    ///\n-    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n-    /// prevents duplicating the content of the `MaybeUninit<T>`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read` multiple times, or first\n-    /// calling `read` and then [`assume_init`]), it is your responsibility\n-    /// to ensure that that data may indeed be duplicated.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    /// [`assume_init`]: #method.assume_init\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<u32>::uninit();\n-    /// x.write(13);\n-    /// let x1 = unsafe { x.read() };\n-    /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(None);\n-    /// let x1 = unsafe { x.read() };\n-    /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read() };\n-    /// let x2 = unsafe { x.read() };\n-    /// // We now created two copies of the same vector, leading to a double-free when\n-    /// // they both get dropped!\n-    /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn read(&self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        self.as_ptr().read()\n-    }\n-\n-    /// Gets a reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_ref(&self) -> &T {\n-        &*self.value\n-    }\n-\n-    /// Gets a mutable reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n-    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n-    // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut *self.value\n-    }\n-\n-    /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n-        this as *const [MaybeUninit<T>] as *const T\n-    }\n-\n-    /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n-        this as *mut [MaybeUninit<T>] as *mut T\n-    }\n-}"}, {"sha": "3ad1223e331ece91ca1b996e2e87bcc94c3e5786", "filename": "src/libcore/mem/manually_drop.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=1529067a046b079c1348ead39199e9c491a5f472", "patch": "@@ -0,0 +1,146 @@\n+use crate::ptr;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n+///\n+/// This wrapper is 0-cost.\n+///\n+/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n+/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n+/// about all values being initialized at their type.  In particular, initializing\n+/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n+///\n+/// # Examples\n+///\n+/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n+/// the type:\n+///\n+/// ```rust\n+/// use std::mem::ManuallyDrop;\n+/// struct Peach;\n+/// struct Banana;\n+/// struct Melon;\n+/// struct FruitBox {\n+///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n+///     peach: ManuallyDrop<Peach>,\n+///     melon: Melon, // Field that\u2019s independent of the other two.\n+///     banana: ManuallyDrop<Banana>,\n+/// }\n+///\n+/// impl Drop for FruitBox {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // Explicit ordering in which field destructors are run specified in the intuitive\n+///             // location \u2013 the destructor of the structure containing the fields.\n+///             // Moreover, one can now reorder fields within the struct however much they want.\n+///             ManuallyDrop::drop(&mut self.peach);\n+///             ManuallyDrop::drop(&mut self.banana);\n+///         }\n+///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n+///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+#[lang = \"manually_drop\"]\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct ManuallyDrop<T: ?Sized> {\n+    value: T,\n+}\n+\n+impl<T> ManuallyDrop<T> {\n+    /// Wrap a value to be manually dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// ManuallyDrop::new(Box::new(()));\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn new(value: T) -> ManuallyDrop<T> {\n+        ManuallyDrop { value }\n+    }\n+\n+    /// Extracts the value from the `ManuallyDrop` container.\n+    ///\n+    /// This allows the value to be dropped again.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// let x = ManuallyDrop::new(Box::new(()));\n+    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n+        slot.value\n+    }\n+\n+    /// Takes the contained value out.\n+    ///\n+    /// This method is primarily intended for moving out values in drop.\n+    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n+    /// you can use this method to take the value and use it however desired.\n+    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n+    ///\n+    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function semantically moves out the contained value without preventing further usage.\n+    /// It is up to the user of this method to ensure that this container is not used again.\n+    ///\n+    /// [`ManuallyDrop::drop`]: #method.drop\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n+    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n+    #[inline]\n+    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n+        ManuallyDrop::into_inner(ptr::read(slot))\n+    }\n+}\n+\n+impl<T: ?Sized> ManuallyDrop<T> {\n+    /// Manually drops the contained value.\n+    ///\n+    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function runs the destructor of the contained value and thus the wrapped value\n+    /// now represents uninitialized data. It is up to the user of this method to ensure the\n+    /// uninitialized data is not actually used.\n+    ///\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n+        ptr::drop_in_place(&mut slot.value)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> Deref for ManuallyDrop<T> {\n+    type Target = T;\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n+    #[inline(always)]\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}"}, {"sha": "eeff9d0303a3b83f8b96e3c10248ae8ea115a45b", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=1529067a046b079c1348ead39199e9c491a5f472", "patch": "@@ -0,0 +1,519 @@\n+use crate::intrinsics;\n+use crate::mem::ManuallyDrop;\n+\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n+///\n+/// The compiler, in general, assumes that variables are properly initialized\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n+/// ever gets used to access memory:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// This is exploited by the compiler for various optimizations, such as eliding\n+/// run-time checks and optimizing `enum` layout.\n+///\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any *fixed* bit pattern:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<i32>`:\n+/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n+/// be initialized:\n+///\n+/// ```rust\n+/// use std::mem::MaybeUninit;\n+///\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n+/// let mut x = MaybeUninit::<&i32>::uninit();\n+/// // Set it to a valid value.\n+/// unsafe { x.as_mut_ptr().write(&0); }\n+/// // Extract the initialized data -- this is only allowed *after* properly\n+/// // initializing `x`!\n+/// let x = unsafe { x.assume_init() };\n+/// ```\n+///\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+///\n+/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n+/// any of the run-time tracking and without any of the safety checks.\n+///\n+/// ## out-pointers\n+///\n+/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n+/// from a function, pass it a pointer to some (uninitialized) memory to put the\n+/// result into. This can be useful when it is important for the caller to control\n+/// how the memory the result is stored in gets allocated, and you want to avoid\n+/// unnecessary moves.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+///\n+/// unsafe fn make_vec(out: *mut Vec<i32>) {\n+///     // `write` does not drop the old contents, which is important.\n+///     out.write(vec![1, 2, 3]);\n+/// }\n+///\n+/// let mut v = MaybeUninit::uninit();\n+/// unsafe { make_vec(v.as_mut_ptr()); }\n+/// // Now we know `v` is initialized! This also makes sure the vector gets\n+/// // properly dropped.\n+/// let v = unsafe { v.assume_init() };\n+/// assert_eq!(&v, &[1, 2, 3]);\n+/// ```\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n+/// };\n+///\n+/// assert_eq!(&data[0], &[42]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+///\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n+///\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Layout\n+///\n+/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+///\n+/// ```rust\n+/// use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n+/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n+/// ```\n+///\n+/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n+/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n+/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n+/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n+/// optimizations, potentially resulting in a larger size:\n+///\n+/// ```rust\n+/// # use std::mem::{MaybeUninit, size_of};\n+/// assert_eq!(size_of::<Option<bool>>(), 1);\n+/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n+/// ```\n+#[allow(missing_debug_implementations)]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+#[derive(Copy)]\n+pub union MaybeUninit<T> {\n+    uninit: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n+impl<T> MaybeUninit<T> {\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn new(val: T) -> MaybeUninit<T> {\n+        MaybeUninit { value: ManuallyDrop::new(val) }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn uninit() -> MaybeUninit<T> {\n+        MaybeUninit { uninit: () }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n+    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n+    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n+    /// be null.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline]\n+    pub fn zeroed() -> MaybeUninit<T> {\n+        let mut u = MaybeUninit::<T>::uninit();\n+        unsafe {\n+            u.as_mut_ptr().write_bytes(0u8, 1);\n+        }\n+        u\n+    }\n+\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn write(&mut self, val: T) -> &mut T {\n+        unsafe {\n+            self.value = ManuallyDrop::new(val);\n+            self.get_mut()\n+        }\n+    }\n+\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell<T>`).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n+    /// to ensure that the data will get dropped, because the resulting `T` is\n+    /// subject to the usual drop handling.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub unsafe fn assume_init(self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        ManuallyDrop::into_inner(self.value)\n+    }\n+\n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read` multiple times, or first\n+    /// calling `read` and then [`assume_init`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    /// [`assume_init`]: #method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninit();\n+    /// x.write(13);\n+    /// let x1 = unsafe { x.read() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(None);\n+    /// let x1 = unsafe { x.read() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.read() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n+    /// Gets a reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_ref(&self) -> &T {\n+        &*self.value\n+    }\n+\n+    /// Gets a mutable reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n+    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n+    // a final decision about the rules before stabilization.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut *self.value\n+    }\n+\n+    /// Gets a pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n+        this as *const [MaybeUninit<T>] as *const T\n+    }\n+\n+    /// Gets a mutable pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n+        this as *mut [MaybeUninit<T>] as *mut T\n+    }\n+}"}, {"sha": "91449f09936aa2597487e6f5aa10e3cb1893df3b", "filename": "src/libcore/mem/mod.rs", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/rust-lang/rust/blob/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1529067a046b079c1348ead39199e9c491a5f472/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=1529067a046b079c1348ead39199e9c491a5f472", "patch": "@@ -0,0 +1,752 @@\n+//! Basic functions for dealing with memory.\n+//!\n+//! This module contains functions for querying the size and alignment of\n+//! types, initializing and manipulating memory.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::clone;\n+use crate::cmp;\n+use crate::fmt;\n+use crate::hash;\n+use crate::intrinsics;\n+use crate::marker::{Copy, PhantomData, Sized};\n+use crate::ptr;\n+\n+mod manually_drop;\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+pub use manually_drop::ManuallyDrop;\n+\n+mod maybe_uninit;\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+pub use maybe_uninit::MaybeUninit;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n+pub use crate::intrinsics::transmute;\n+\n+/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n+///\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state. However, it does not guarantee that pointers\n+/// to this memory will remain valid.\n+///\n+/// * If you want to leak memory, see [`Box::leak`][leak].\n+/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n+/// * If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n+///\n+/// # Safety\n+///\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n+///\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n+///\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n+///\n+/// # Examples\n+///\n+/// Leak an I/O object, never closing the file:\n+///\n+/// ```no_run\n+/// use std::mem;\n+/// use std::fs::File;\n+///\n+/// let file = File::open(\"foo.txt\").unwrap();\n+/// mem::forget(file);\n+/// ```\n+///\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn forget<T>(t: T) {\n+    ManuallyDrop::new(t);\n+}\n+\n+/// Like [`forget`], but also accepts unsized values.\n+///\n+/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n+/// stabilized.\n+///\n+/// [`forget`]: fn.forget.html\n+#[inline]\n+#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n+pub fn forget_unsized<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n+\n+/// Returns the size of a type in bytes.\n+///\n+/// More specifically, this is the offset in bytes between successive elements\n+/// in an array with that item type including alignment padding. Thus, for any\n+/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n+///\n+/// In general, the size of a type is not stable across compilations, but\n+/// specific types such as primitives are.\n+///\n+/// The following table gives the size for primitives.\n+///\n+/// Type | size_of::\\<Type>()\n+/// ---- | ---------------\n+/// () | 0\n+/// bool | 1\n+/// u8 | 1\n+/// u16 | 2\n+/// u32 | 4\n+/// u64 | 8\n+/// u128 | 16\n+/// i8 | 1\n+/// i16 | 2\n+/// i32 | 4\n+/// i64 | 8\n+/// i128 | 16\n+/// f32 | 4\n+/// f64 | 8\n+/// char | 4\n+///\n+/// Furthermore, `usize` and `isize` have the same size.\n+///\n+/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n+/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n+///\n+/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n+/// have the same size. Likewise for `*const T` and `*mut T`.\n+///\n+/// # Size of `#[repr(C)]` items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Size of Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+/// The alignment of the struct is usually the largest alignment of all its\n+/// fields; this can be changed with the use of `repr(align(N))`.\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Size of Enums\n+///\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Size of Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // Some primitives\n+/// assert_eq!(4, mem::size_of::<i32>());\n+/// assert_eq!(8, mem::size_of::<f64>());\n+/// assert_eq!(0, mem::size_of::<()>());\n+///\n+/// // Some arrays\n+/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n+/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n+/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n+///\n+///\n+/// // Pointer size equality\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n+/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n+/// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n+/// // fields is 2), so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::size_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n+pub fn min_align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n+pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns `true` if dropping values of type `T` matters.\n+///\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n+///\n+/// Low level implementations of things like collections, which need to manually\n+/// drop their data, should use this function to avoid unnecessarily\n+/// trying to drop all their contents when they are destroyed. This might not\n+/// make a difference in release builds (where a loop that has no side-effects\n+/// is easily detected and eliminated), but is often a big win for debug builds.\n+///\n+/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n+/// can be reduced to some small number of drop_in_place calls, using this is\n+/// unnecessary. In particular note that you can drop_in_place a slice, and that\n+/// will do a single needs_drop check for all the values.\n+///\n+/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n+/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n+/// values one at a time and should use this API.\n+///\n+///\n+/// # Examples\n+///\n+/// Here's an example of how a collection might make use of needs_drop:\n+///\n+/// ```\n+/// use std::{mem, ptr};\n+///\n+/// pub struct MyCollection<T> {\n+/// #   data: [T; 1],\n+///     /* ... */\n+/// }\n+/// # impl<T> MyCollection<T> {\n+/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n+/// #   fn free_buffer(&mut self) {}\n+/// # }\n+///\n+/// impl<T> Drop for MyCollection<T> {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // drop the data\n+///             if mem::needs_drop::<T>() {\n+///                 for x in self.iter_mut() {\n+///                     ptr::drop_in_place(x);\n+///                 }\n+///             }\n+///             self.free_buffer();\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n+pub const fn needs_drop<T>() -> bool {\n+    intrinsics::needs_drop::<T>()\n+}\n+\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n+///\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n+///\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+///\n+/// # Examples\n+///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n+/// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn zeroed<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::init()\n+}\n+\n+/// Bypasses Rust's normal memory-initialization checks by pretending to\n+/// produce a value of type `T`, while doing nothing at all.\n+///\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n+///\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+#[inline]\n+#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn uninitialized<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::uninit()\n+}\n+\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut x = 5;\n+/// let mut y = 42;\n+///\n+/// mem::swap(&mut x, &mut y);\n+///\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn swap<T>(x: &mut T, y: &mut T) {\n+    unsafe {\n+        ptr::swap_nonoverlapping_one(x, y);\n+    }\n+}\n+\n+/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n+///\n+/// Neither value is dropped.\n+///\n+/// # Examples\n+///\n+/// A simple example:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v: Vec<i32> = vec![1, 2];\n+///\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(vec![1, 2], old_v);\n+/// assert_eq!(vec![3, 4, 5], v);\n+/// ```\n+///\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n+///\n+/// ```compile_fail,E0507\n+/// struct Buffer<T> { buf: Vec<T> }\n+///\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         // error: cannot move out of dereference of `&mut`-pointer\n+///         let buf = self.buf;\n+///         self.buf = Vec::new();\n+///         buf\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n+/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// `self`, allowing it to be returned:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// use std::mem;\n+///\n+/// # struct Buffer<T> { buf: Vec<T> }\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         mem::replace(&mut self.buf, Vec::new())\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n+    swap(dest, &mut src);\n+    src\n+}\n+\n+/// Disposes of a value.\n+///\n+/// This does call the argument's implementation of [`Drop`][drop].\n+///\n+/// This effectively does nothing for types which implement `Copy`, e.g.\n+/// integers. Such values are copied and _then_ moved into the function, so the\n+/// value persists after this function call.\n+///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// drop(v); // explicitly drop the vector\n+/// ```\n+///\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n+///\n+/// ```\n+/// use std::cell::RefCell;\n+///\n+/// let x = RefCell::new(1);\n+///\n+/// let mut mutable_borrow = x.borrow_mut();\n+/// *mutable_borrow = 1;\n+///\n+/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n+///\n+/// let borrow = x.borrow();\n+/// println!(\"{}\", *borrow);\n+/// ```\n+///\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct Foo(u8);\n+///\n+/// let x = 1;\n+/// let y = Foo(2);\n+/// drop(x); // a copy of `x` is moved and dropped\n+/// drop(y); // a copy of `y` is moved and dropped\n+///\n+/// println!(\"x: {}, y: {}\", x, y.0); // still available\n+/// ```\n+///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn drop<T>(_x: T) { }\n+\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for\n+/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `T` and `U` have the\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n+/// `T`.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [size_of]: fn.size_of.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     bar: u8,\n+/// }\n+///\n+/// let foo_slice = [10u8];\n+///\n+/// unsafe {\n+///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n+///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n+///     assert_eq!(foo_struct.bar, 10);\n+///\n+///     // Modify the copied data\n+///     foo_struct.bar = 20;\n+///     assert_eq!(foo_struct.bar, 20);\n+/// }\n+///\n+/// // The contents of 'foo_slice' should not have changed\n+/// assert_eq!(foo_slice, [10]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    ptr::read_unaligned(src as *const T as *const U)\n+}\n+\n+/// Opaque type representing the discriminant of an enum.\n+///\n+/// See the [`discriminant`] function in this module for more information.\n+///\n+/// [`discriminant`]: fn.discriminant.html\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n+\n+// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> Copy for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> clone::Clone for Discriminant<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::PartialEq for Discriminant<T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::Eq for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> hash::Hash for Discriminant<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> fmt::Debug for Discriminant<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_tuple(\"Discriminant\")\n+           .field(&self.0)\n+           .finish()\n+    }\n+}\n+\n+/// Returns a value uniquely identifying the enum variant in `v`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified.\n+///\n+/// # Stability\n+///\n+/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n+/// of some variant will not change between compilations with the same compiler.\n+///\n+/// # Examples\n+///\n+/// This can be used to compare enums that carry data, while disregarding\n+/// the actual data:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n+/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n+/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// ```\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    unsafe {\n+        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    }\n+}"}]}