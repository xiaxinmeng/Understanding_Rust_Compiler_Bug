{"sha": "a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYTdiMDdhZDMzYjdkY2FkZWRjMmFmMjZjM2E1ZjhlZjNkYWNhMjc=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-09-06T18:34:01Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-09-06T18:34:01Z"}, "message": "Fix handling of consuming self, refactor shared logic into a single function", "tree": {"sha": "c41abbdb6dd82b04a232533e824a6b395ccbd3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c41abbdb6dd82b04a232533e824a6b395ccbd3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "html_url": "https://github.com/rust-lang/rust/commit/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7af947a032bd2e6f6df6b903b40f142cd7b8d9e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7af947a032bd2e6f6df6b903b40f142cd7b8d9e0", "html_url": "https://github.com/rust-lang/rust/commit/7af947a032bd2e6f6df6b903b40f142cd7b8d9e0"}], "stats": {"total": 64, "additions": 34, "deletions": 30}, "files": [{"sha": "d9fc25d88bc8423eebfed1d8a8451be98e4807f9", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "patch": "@@ -4,7 +4,7 @@ mod injection;\n #[cfg(test)]\n mod tests;\n \n-use hir::{Name, Semantics, VariantDef};\n+use hir::{Local, Name, Semantics, VariantDef};\n use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n@@ -14,7 +14,7 @@ use syntax::{\n     ast::{self, HasFormatSpecifier},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::{self, *},\n-    SyntaxNode, TextRange, WalkEvent, T,\n+    SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n };\n \n use crate::FileId;\n@@ -455,22 +455,31 @@ fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n }\n \n /// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.\n-fn parents_match(mut node: SyntaxNode, mut kinds: &[SyntaxKind]) -> bool {\n+fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {\n     while let (Some(parent), [kind, rest @ ..]) = (&node.parent(), kinds) {\n         if parent.kind() != *kind {\n             return false;\n         }\n \n         // FIXME: Would be nice to get parent out of the match, but binding by-move and by-value\n         // in the same pattern is unstable: rust-lang/rust#68354.\n-        node = node.parent().unwrap();\n+        node = node.parent().unwrap().into();\n         kinds = rest;\n     }\n \n     // Only true if we matched all expected kinds\n     kinds.len() == 0\n }\n \n+fn is_consumed_lvalue(\n+    node: NodeOrToken<SyntaxNode, SyntaxToken>,\n+    local: &Local,\n+    db: &RootDatabase,\n+) -> bool {\n+    // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.\n+    parents_match(node, &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST]) && !local.ty(db).is_copy(db)\n+}\n+\n fn highlight_element(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n@@ -539,23 +548,9 @@ fn highlight_element(\n \n                             let mut h = highlight_def(db, def);\n \n-                            // When lvalues are passed as arguments and they're not Copy, then mark\n-                            // them as Consuming.\n-                            if parents_match(\n-                                name_ref.syntax().clone(),\n-                                &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST],\n-                            ) {\n-                                let lvalue_ty = if let Definition::Local(local) = &def {\n-                                    Some(local.ty(db))\n-                                } else if let Definition::SelfType(impl_def) = &def {\n-                                    Some(impl_def.target_ty(db))\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(lvalue_ty) = lvalue_ty {\n-                                    if !lvalue_ty.is_copy(db) {\n-                                        h |= HighlightModifier::Consuming;\n-                                    }\n+                            if let Definition::Local(local) = &def {\n+                                if is_consumed_lvalue(name_ref.syntax().clone().into(), local, db) {\n+                                    h |= HighlightModifier::Consuming;\n                                 }\n                             }\n \n@@ -682,21 +677,30 @@ fn highlight_element(\n                         .and_then(ast::SelfParam::cast)\n                         .and_then(|p| p.mut_token())\n                         .is_some();\n-                    // closure to enforce lazyness\n-                    let self_path = || {\n-                        sema.resolve_path(&element.parent()?.parent().and_then(ast::Path::cast)?)\n-                    };\n+                    let self_path = &element\n+                        .parent()\n+                        .as_ref()\n+                        .and_then(SyntaxNode::parent)\n+                        .and_then(ast::Path::cast)\n+                        .and_then(|p| sema.resolve_path(&p));\n+                    let mut h = HighlightTag::SelfKeyword.into();\n                     if self_param_is_mut\n-                        || matches!(self_path(),\n+                        || matches!(self_path,\n                             Some(hir::PathResolution::Local(local))\n                                 if local.is_self(db)\n                                     && (local.is_mut(db) || local.ty(db).is_mutable_reference())\n                         )\n                     {\n-                        HighlightTag::SelfKeyword | HighlightModifier::Mutable\n-                    } else {\n-                        HighlightTag::SelfKeyword.into()\n+                        h |= HighlightModifier::Mutable\n+                    }\n+\n+                    if let Some(hir::PathResolution::Local(local)) = self_path {\n+                        if is_consumed_lvalue(element, &local, db) {\n+                            h |= HighlightModifier::Consuming;\n+                        }\n                     }\n+\n+                    h\n                 }\n                 T![ref] => element\n                     .parent()"}, {"sha": "cde42024c03defa31f4a041c34f6d01656949a7f", "filename": "crates/ide/src/syntax_highlighting/test_data/highlighting.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html?ref=a1a7b07ad33b7dcadedc2af26c3a5f8ef3daca27", "patch": "@@ -62,7 +62,7 @@\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"keyword\">fn</span> <span class=\"function declaration\">baz</span><span class=\"punctuation\">(</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">,</span> <span class=\"value_param declaration\">f</span><span class=\"punctuation\">:</span> <span class=\"struct\">Foo</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n-        <span class=\"value_param\">f</span><span class=\"punctuation\">.</span><span class=\"function consuming\">baz</span><span class=\"punctuation\">(</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span>\n+        <span class=\"value_param\">f</span><span class=\"punctuation\">.</span><span class=\"function consuming\">baz</span><span class=\"punctuation\">(</span><span class=\"self_keyword consuming\">self</span><span class=\"punctuation\">)</span>\n     <span class=\"punctuation\">}</span>\n \n     <span class=\"keyword\">fn</span> <span class=\"function declaration\">qux</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>"}]}