{"sha": "a4a6a67a0142d46205f0aa662dc29c1f37aca86d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YTZhNjdhMDE0MmQ0NjIwNWYwYWE2NjJkYzI5YzFmMzdhY2E4NmQ=", "commit": {"author": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-07-07T17:26:06Z"}, "committer": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-07-07T17:44:21Z"}, "message": "Remove while loop in DrainFilter::drop and add additional docs", "tree": {"sha": "a4794de3664bc21a3cd0a9b9667772842b96c910", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4794de3664bc21a3cd0a9b9667772842b96c910"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a6a67a0142d46205f0aa662dc29c1f37aca86d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a6a67a0142d46205f0aa662dc29c1f37aca86d", "html_url": "https://github.com/rust-lang/rust/commit/a4a6a67a0142d46205f0aa662dc29c1f37aca86d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a6a67a0142d46205f0aa662dc29c1f37aca86d/comments", "author": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5ab0313fe9330717e6697b148bcdd0bb78f3508", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ab0313fe9330717e6697b148bcdd0bb78f3508", "html_url": "https://github.com/rust-lang/rust/commit/f5ab0313fe9330717e6697b148bcdd0bb78f3508"}], "stats": {"total": 40, "additions": 21, "deletions": 19}, "files": [{"sha": "4adbe6467a1e8063881e863c3f28e93454408b16", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a4a6a67a0142d46205f0aa662dc29c1f37aca86d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a6a67a0142d46205f0aa662dc29c1f37aca86d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a4a6a67a0142d46205f0aa662dc29c1f37aca86d", "patch": "@@ -2748,10 +2748,19 @@ pub struct DrainFilter<'a, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     vec: &'a mut Vec<T>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n     idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n     del: usize,\n+    /// The original length of `vec` prior to draining.\n     old_len: usize,\n+    /// The filter test predicate.\n     pred: F,\n+    /// A flag that indicates a panic has occured in the filter test prodicate.\n+    /// This is used as a hint in the drop implmentation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n     panic_flag: bool,\n }\n \n@@ -2810,25 +2819,18 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n         {\n             fn drop(&mut self) {\n                 unsafe {\n-                    // Backshift any unprocessed elements, preventing double-drop\n-                    // of any element that *should* have been previously overwritten\n-                    // but was not due to a panic in the filter predicate. This is\n-                    // implemented via drop so that it's guaranteed to run even in\n-                    // the event of a panic while consuming the remainder of the\n-                    // DrainFilter.\n-                    while self.drain.idx < self.drain.old_len {\n-                        let i = self.drain.idx;\n-                        self.drain.idx += 1;\n-                        let v = slice::from_raw_parts_mut(\n-                            self.drain.vec.as_mut_ptr(),\n-                            self.drain.old_len,\n-                        );\n-                        if self.drain.del > 0 {\n-                            let del = self.drain.del;\n-                            let src: *const T = &v[i];\n-                            let dst: *mut T = &mut v[i - del];\n-                            ptr::copy_nonoverlapping(src, dst, 1);\n-                        }\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item following a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n                     }\n                     self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n                 }"}]}