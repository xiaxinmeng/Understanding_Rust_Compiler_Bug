{"sha": "85d44c42764fb87e1f581fa6206727e82cd7d52d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZDQ0YzQyNzY0ZmI4N2UxZjU4MWZhNjIwNjcyN2U4MmNkN2Q1MmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-28T11:16:09Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-30T17:30:09Z"}, "message": "rustc: rename mir::VisibilityScope to mir::SourceScope.", "tree": {"sha": "ec32fc25dcc7b3962c9fa5120887c16b55b80184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec32fc25dcc7b3962c9fa5120887c16b55b80184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85d44c42764fb87e1f581fa6206727e82cd7d52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85d44c42764fb87e1f581fa6206727e82cd7d52d", "html_url": "https://github.com/rust-lang/rust/commit/85d44c42764fb87e1f581fa6206727e82cd7d52d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85d44c42764fb87e1f581fa6206727e82cd7d52d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d09399c1289a20b1c258153f005f2604f9ec46", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d09399c1289a20b1c258153f005f2604f9ec46", "html_url": "https://github.com/rust-lang/rust/commit/74d09399c1289a20b1c258153f005f2604f9ec46"}], "stats": {"total": 384, "additions": 193, "deletions": 191}, "files": [{"sha": "d4081d29c25d492b976f59cadc0228ab60ad5530", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -127,7 +127,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::VisibilityScope {\n+for mir::SourceScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -363,8 +363,8 @@ for mir::ProjectionElem<'gcx, V, T>\n     }\n }\n \n-impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n-impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n+impl_stable_hash_for!(struct mir::SourceScopeData { span, parent_scope });\n+impl_stable_hash_for!(struct mir::SourceScopeInfo {\n     lint_root, safety\n });\n "}, {"sha": "3956d150232b6e9fc402c61db1f6d65950461578", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -78,13 +78,13 @@ pub struct Mir<'tcx> {\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n-    /// List of visibility (lexical) scopes; these are referenced by statements\n-    /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n-    pub visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+    /// List of source scopes; these are referenced by statements\n+    /// and used for debuginfo. Indexed by a `SourceScope`.\n+    pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n \n-    /// Crate-local information for each visibility scope, that can't (and\n+    /// Crate-local information for each source scope, that can't (and\n     /// needn't) be tracked across crates.\n-    pub visibility_scope_info: ClearCrossCrate<IndexVec<VisibilityScope, VisibilityScopeInfo>>,\n+    pub source_scope_info: ClearCrossCrate<IndexVec<SourceScope, SourceScopeInfo>>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n@@ -137,9 +137,9 @@ pub const START_BLOCK: BasicBlock = BasicBlock(0);\n \n impl<'tcx> Mir<'tcx> {\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-               visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n-               visibility_scope_info: ClearCrossCrate<IndexVec<VisibilityScope,\n-                                                               VisibilityScopeInfo>>,\n+               source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+               source_scope_info: ClearCrossCrate<IndexVec<SourceScope,\n+                                                               SourceScopeInfo>>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                yield_ty: Option<Ty<'tcx>>,\n                local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n@@ -153,8 +153,8 @@ impl<'tcx> Mir<'tcx> {\n \n         Mir {\n             basic_blocks,\n-            visibility_scopes,\n-            visibility_scope_info,\n+            source_scopes,\n+            source_scope_info,\n             promoted,\n             yield_ty,\n             generator_drop: None,\n@@ -309,7 +309,7 @@ impl<'tcx> Mir<'tcx> {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct VisibilityScopeInfo {\n+pub struct SourceScopeInfo {\n     /// A NodeId with lint levels equivalent to this scope's lint levels.\n     pub lint_root: ast::NodeId,\n     /// The unsafe block that contains this node.\n@@ -329,8 +329,8 @@ pub enum Safety {\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n     basic_blocks,\n-    visibility_scopes,\n-    visibility_scope_info,\n+    source_scopes,\n+    source_scope_info,\n     promoted,\n     yield_ty,\n     generator_drop,\n@@ -376,8 +376,9 @@ pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n \n-    /// The lexical visibility scope, i.e. which bindings can be seen.\n-    pub scope: VisibilityScope\n+    /// The source scope, keeping track of which bindings can be\n+    /// seen by debuginfo, active lint levels, `unsafe {...}`, etc.\n+    pub scope: SourceScope\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -512,16 +513,17 @@ pub struct LocalDecl<'tcx> {\n     /// to generate better debuginfo.\n     pub name: Option<Name>,\n \n-    /// Source info of the local.\n+    /// Source info of the local. The `SourceScope` is the *visibility* one,\n+    /// not the the *syntactic* one (see `syntactic_scope` for more details).\n     pub source_info: SourceInfo,\n \n-    /// The *syntactic* visibility scope the local is defined\n+    /// The *syntactic* (i.e. not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n     /// is *within* the let-statement, rather than outside\n     /// of it.\n     ///\n-    /// This is needed because visibility scope of locals within a let-statement\n-    /// is weird.\n+    /// This is needed because the visibility source scope of locals within\n+    /// a let-statement is weird.\n     ///\n     /// The reason is that we want the local to be *within* the let-statement\n     /// for lint purposes, but we want the local to be *after* the let-statement\n@@ -594,7 +596,7 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502 \u2502\u2190 x.source_info.scope\n     ///  \u2502 \u2502\u2190 `drop(x)` // this accesses `x: u32`\n     /// ```\n-    pub syntactic_scope: VisibilityScope,\n+    pub syntactic_scope: SourceScope,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -607,9 +609,9 @@ impl<'tcx> LocalDecl<'tcx> {\n             name: None,\n             source_info: SourceInfo {\n                 span,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+            syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             is_user_variable: false\n         }\n@@ -624,9 +626,9 @@ impl<'tcx> LocalDecl<'tcx> {\n             name: None,\n             source_info: SourceInfo {\n                 span,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+            syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: true,\n             is_user_variable: false\n         }\n@@ -642,9 +644,9 @@ impl<'tcx> LocalDecl<'tcx> {\n             ty: return_ty,\n             source_info: SourceInfo {\n                 span,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+            syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             name: None,     // FIXME maybe we do want some name here?\n             is_user_variable: false\n@@ -1047,7 +1049,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.statements.resize(gap.end, Statement {\n             source_info: SourceInfo {\n                 span: DUMMY_SP,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n             kind: StatementKind::Nop\n         });\n@@ -1501,16 +1503,16 @@ impl<'tcx> Debug for Place<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-newtype_index!(VisibilityScope\n+newtype_index!(SourceScope\n     {\n         DEBUG_FORMAT = \"scope[{}]\",\n-        const ARGUMENT_VISIBILITY_SCOPE = 0,\n+        const OUTERMOST_SOURCE_SCOPE = 0,\n     });\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct VisibilityScopeData {\n+pub struct SourceScopeData {\n     pub span: Span,\n-    pub parent_scope: Option<VisibilityScope>,\n+    pub parent_scope: Option<SourceScope>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -2153,16 +2155,16 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceInfo,\n     UpvarDecl,\n     ValidationOp,\n-    VisibilityScopeData,\n-    VisibilityScope,\n-    VisibilityScopeInfo,\n+    SourceScopeData,\n+    SourceScope,\n+    SourceScopeInfo,\n }\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n         basic_blocks,\n-        visibility_scopes,\n-        visibility_scope_info,\n+        source_scopes,\n+        source_scope_info,\n         promoted,\n         yield_ty,\n         generator_drop,"}, {"sha": "0b50d55b1af27210ee0d33d94313fbaba291c9a3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -92,9 +92,9 @@ macro_rules! make_mir_visitor {\n                 self.super_basic_block_data(block, data);\n             }\n \n-            fn visit_visibility_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* VisibilityScopeData) {\n-                self.super_visibility_scope_data(scope_data);\n+            fn visit_source_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* SourceScopeData) {\n+                self.super_source_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n@@ -261,9 +261,9 @@ macro_rules! make_mir_visitor {\n                             _location: Location) {\n             }\n \n-            fn visit_visibility_scope(&mut self,\n-                                      scope: & $($mutability)* VisibilityScope) {\n-                self.super_visibility_scope(scope);\n+            fn visit_source_scope(&mut self,\n+                                      scope: & $($mutability)* SourceScope) {\n+                self.super_source_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n@@ -274,7 +274,7 @@ macro_rules! make_mir_visitor {\n                 if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n-                        scope: ARGUMENT_VISIBILITY_SCOPE,\n+                        scope: OUTERMOST_SOURCE_SCOPE,\n                     }));\n                 }\n \n@@ -289,13 +289,13 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)* mir.visibility_scopes {\n-                    self.visit_visibility_scope_data(scope);\n+                for scope in &$($mutability)* mir.source_scopes {\n+                    self.visit_source_scope_data(scope);\n                 }\n \n                 self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n-                    scope: ARGUMENT_VISIBILITY_SCOPE,\n+                    scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n                 for local in mir.local_decls.indices() {\n@@ -327,16 +327,16 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_visibility_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* VisibilityScopeData) {\n-                let VisibilityScopeData {\n+            fn super_source_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* SourceScopeData) {\n+                let SourceScopeData {\n                     ref $($mutability)* span,\n                     ref $($mutability)* parent_scope,\n                 } = *scope_data;\n \n                 self.visit_span(span);\n                 if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n-                    self.visit_visibility_scope(parent_scope);\n+                    self.visit_source_scope(parent_scope);\n                 }\n             }\n \n@@ -725,11 +725,11 @@ macro_rules! make_mir_visitor {\n                     source_info: *source_info,\n                 });\n                 self.visit_source_info(source_info);\n-                self.visit_visibility_scope(syntactic_scope);\n+                self.visit_source_scope(syntactic_scope);\n             }\n \n-            fn super_visibility_scope(&mut self,\n-                                      _scope: & $($mutability)* VisibilityScope) {\n+            fn super_source_scope(&mut self,\n+                                      _scope: & $($mutability)* SourceScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -775,7 +775,7 @@ macro_rules! make_mir_visitor {\n                 } = *source_info;\n \n                 self.visit_span(span);\n-                self.visit_visibility_scope(scope);\n+                self.visit_source_scope(scope);\n             }\n \n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {"}, {"sha": "24d9ff492d50970101307faf8b88fca6f26fa58c", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -15,7 +15,7 @@ use super::utils::{DIB, span_start};\n use llvm;\n use llvm::debuginfo::DIScope;\n use common::CodegenCx;\n-use rustc::mir::{Mir, VisibilityScope};\n+use rustc::mir::{Mir, SourceScope};\n \n use libc::c_uint;\n use std::ptr;\n@@ -45,13 +45,13 @@ impl MirDebugScope {\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n-    -> IndexVec<VisibilityScope, MirDebugScope> {\n+    -> IndexVec<SourceScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n         file_start_pos: BytePos(0),\n         file_end_pos: BytePos(0)\n     };\n-    let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n+    let mut scopes = IndexVec::from_elem(null_scope, &mir.source_scopes);\n \n     let debug_context = match *debug_context {\n         FunctionDebugContext::RegularContext(ref data) => data,\n@@ -62,15 +62,15 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n+    let mut has_variables = BitVector::new(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.source_info.scope.index());\n     }\n \n     // Instantiate all scopes.\n-    for idx in 0..mir.visibility_scopes.len() {\n-        let scope = VisibilityScope::new(idx);\n+    for idx in 0..mir.source_scopes.len() {\n+        let scope = SourceScope::new(idx);\n         make_mir_scope(cx, &mir, &has_variables, debug_context, scope, &mut scopes);\n     }\n \n@@ -81,13 +81,13 @@ fn make_mir_scope(cx: &CodegenCx,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   debug_context: &FunctionDebugContextData,\n-                  scope: VisibilityScope,\n-                  scopes: &mut IndexVec<VisibilityScope, MirDebugScope>) {\n+                  scope: SourceScope,\n+                  scopes: &mut IndexVec<SourceScope, MirDebugScope>) {\n     if scopes[scope].is_valid() {\n         return;\n     }\n \n-    let scope_data = &mir.visibility_scopes[scope];\n+    let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n         make_mir_scope(cx, mir, has_variables, debug_context, parent, scopes);\n         scopes[parent]"}, {"sha": "4c0d7fee783cc255412371185654c2a539be1054", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -99,7 +99,7 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n     locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: &'tcx Substs<'tcx>,\n@@ -158,9 +158,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n     // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n     // it may so happen that the current span belongs to a different file than the DIScope\n-    // corresponding to span's containing visibility scope.  If so, we need to create a DIScope\n+    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n-    fn scope_metadata_for_loc(&self, scope_id: mir::VisibilityScope, pos: BytePos)\n+    fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n                                -> llvm::debuginfo::DIScope {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n@@ -411,7 +411,7 @@ fn create_funclets<'a, 'tcx>(\n /// indirect.\n fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                             fx: &FunctionCx<'a, 'tcx>,\n-                            scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n+                            scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n                             memory_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = fx.mir;\n@@ -420,7 +420,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n+    let arg_scope = scopes[mir::OUTERMOST_SOURCE_SCOPE];\n     let arg_scope = if arg_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope.scope_metadata)\n     } else {"}, {"sha": "d18c9d72c6d460baa5517d46d84f1902cdb15cc9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -292,7 +292,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n \n     for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n-        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.visibility_scope_info {\n+        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_info {\n             let local_decl = &mbcx.mir.local_decls[local];\n \n             // Skip implicit `self` argument for closures"}, {"sha": "7096f91dc1ddb0751402e9f72f7588a08bf7fb3c", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -81,10 +81,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //\n         // First we build all the statements in the block.\n         let mut let_scope_stack = Vec::with_capacity(8);\n-        let outer_visibility_scope = this.visibility_scope;\n+        let outer_source_scope = this.source_scope;\n         let outer_push_unsafe_count = this.push_unsafe_count;\n         let outer_unpushed_unsafe = this.unpushed_unsafe;\n-        this.update_visibility_scope_for_safety_mode(span, safety_mode);\n+        this.update_source_scope_for_safety_mode(span, safety_mode);\n \n         let source_info = this.source_info(span);\n         for stmt in stmts {\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.push_scope((remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n \n-                    // Declare the bindings, which may create a visibility scope.\n+                    // Declare the bindings, which may create a source scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n                     let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n@@ -143,9 +143,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         })\n                     }\n \n-                    // Enter the visibility scope, after evaluating the initializer.\n-                    if let Some(visibility_scope) = scope {\n-                        this.visibility_scope = visibility_scope;\n+                    // Enter the source scope, after evaluating the initializer.\n+                    if let Some(source_scope) = scope {\n+                        this.source_scope = source_scope;\n                     }\n                 }\n             }\n@@ -172,19 +172,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         for scope in let_scope_stack.into_iter().rev() {\n             unpack!(block = this.pop_scope((scope, source_info), block));\n         }\n-        // Restore the original visibility scope.\n-        this.visibility_scope = outer_visibility_scope;\n+        // Restore the original source scope.\n+        this.source_scope = outer_source_scope;\n         this.push_unsafe_count = outer_push_unsafe_count;\n         this.unpushed_unsafe = outer_unpushed_unsafe;\n         block.unit()\n     }\n \n-    /// If we are changing the safety mode, create a new visibility scope\n-    fn update_visibility_scope_for_safety_mode(&mut self,\n+    /// If we are changing the safety mode, create a new source scope\n+    fn update_source_scope_for_safety_mode(&mut self,\n                                                span: Span,\n                                                safety_mode: BlockSafety)\n     {\n-        debug!(\"update_visibility_scope_for({:?}, {:?})\", span, safety_mode);\n+        debug!(\"update_source_scope_for({:?}, {:?})\", span, safety_mode);\n         let new_unsafety = match safety_mode {\n             BlockSafety::Safe => None,\n             BlockSafety::ExplicitUnsafe(node_id) => {\n@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(unsafety) = new_unsafety {\n-            self.visibility_scope = self.new_visibility_scope(\n+            self.source_scope = self.new_source_scope(\n                 span, LintLevel::Inherited, Some(unsafety));\n         }\n     }"}, {"sha": "6d731da0cfb6de20c9ba51211c815a560657bddc", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               LintLevel::Inherited,\n                                               &arm.patterns[0],\n                                               ArmHasGuard(arm.guard.is_some()));\n-            (body, scope.unwrap_or(self.visibility_scope))\n+            (body, scope.unwrap_or(self.source_scope))\n         }).collect();\n \n         // create binding start block for link them by false edges\n@@ -200,15 +200,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let end_block = self.cfg.start_new_block();\n \n         let outer_source_info = self.source_info(span);\n-        for (arm_index, (body, visibility_scope)) in arm_bodies.into_iter().enumerate() {\n+        for (arm_index, (body, source_scope)) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n-            // Re-enter the visibility scope we created the bindings in.\n-            self.visibility_scope = visibility_scope;\n+            // Re-enter the source scope we created the bindings in.\n+            self.source_scope = source_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n             self.cfg.terminate(arm_block, outer_source_info,\n                                TerminatorKind::Goto { target: end_block });\n         }\n-        self.visibility_scope = outer_source_info.scope;\n+        self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n@@ -294,30 +294,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         block.unit()\n     }\n \n-    /// Declares the bindings of the given pattern and returns the visibility scope\n+    /// Declares the bindings of the given pattern and returns the source scope\n     /// for the bindings in this patterns, if such a scope had to be created.\n     /// NOTE: Declaring the bindings should always be done in their drop scope.\n     pub fn declare_bindings(&mut self,\n-                            mut var_scope: Option<VisibilityScope>,\n+                            mut var_scope: Option<SourceScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n                             pattern: &Pattern<'tcx>,\n                             has_guard: ArmHasGuard)\n-                            -> Option<VisibilityScope> {\n+                            -> Option<SourceScope> {\n         assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a var and a lint scope at the same time\");\n-        let mut syntactic_scope = self.visibility_scope;\n+        let mut syntactic_scope = self.source_scope;\n         self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n             if var_scope.is_none() {\n-                var_scope = Some(this.new_visibility_scope(scope_span,\n+                var_scope = Some(this.new_source_scope(scope_span,\n                                                            LintLevel::Inherited,\n                                                            None));\n-                // If we have lints, create a new visibility scope\n+                // If we have lints, create a new source scope\n                 // that marks the lints for the locals. See the comment\n                 // on the `syntactic_scope` field for why this is needed.\n                 if lint_level.is_explicit() {\n                     syntactic_scope =\n-                        this.new_visibility_scope(scope_span, lint_level, None);\n+                        this.new_source_scope(scope_span, lint_level, None);\n                 }\n             }\n             let source_info = SourceInfo {\n@@ -1114,7 +1114,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// in the arm body, which will have type `T`.\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n-                       syntactic_scope: VisibilityScope,\n+                       syntactic_scope: SourceScope,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,"}, {"sha": "2bc885fb442801929932c9b4c20fa31086714a3c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -256,9 +256,9 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n-    visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n-    visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n-    visibility_scope: VisibilityScope,\n+    source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+    source_scope_info: IndexVec<SourceScope, SourceScopeInfo>,\n+    source_scope: SourceScope,\n \n     /// the guard-context: each time we build the guard expression for\n     /// a match arm, we push onto this stack, and then pop when we\n@@ -593,9 +593,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             fn_span: span,\n             arg_count,\n             scopes: vec![],\n-            visibility_scopes: IndexVec::new(),\n-            visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n-            visibility_scope_info: IndexVec::new(),\n+            source_scopes: IndexVec::new(),\n+            source_scope: OUTERMOST_SOURCE_SCOPE,\n+            source_scope_info: IndexVec::new(),\n             guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n@@ -611,9 +611,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n         assert_eq!(\n-            builder.new_visibility_scope(span, lint_level, Some(safety)),\n-            ARGUMENT_VISIBILITY_SCOPE);\n-        builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n+            builder.new_source_scope(span, lint_level, Some(safety)),\n+            OUTERMOST_SOURCE_SCOPE);\n+        builder.source_scopes[OUTERMOST_SOURCE_SCOPE].parent_scope = None;\n \n         builder\n     }\n@@ -629,8 +629,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         Mir::new(self.cfg.basic_blocks,\n-                 self.visibility_scopes,\n-                 ClearCrossCrate::Set(self.visibility_scope_info),\n+                 self.source_scopes,\n+                 ClearCrossCrate::Set(self.source_scope_info),\n                  IndexVec::new(),\n                  yield_ty,\n                  self.local_decls,\n@@ -661,10 +661,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 mutability: Mutability::Mut,\n                 ty,\n                 source_info: SourceInfo {\n-                    scope: ARGUMENT_VISIBILITY_SCOPE,\n+                    scope: OUTERMOST_SOURCE_SCOPE,\n                     span: pattern.map_or(self.fn_span, |pat| pat.span)\n                 },\n-                syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+                syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n                 name,\n                 internal: false,\n                 is_user_variable: false,\n@@ -702,9 +702,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         }\n \n-        // Enter the argument pattern bindings visibility scope, if it exists.\n-        if let Some(visibility_scope) = scope {\n-            self.visibility_scope = visibility_scope;\n+        // Enter the argument pattern bindings source scope, if it exists.\n+        if let Some(source_scope) = scope {\n+            self.source_scope = source_scope;\n         }\n \n         let body = self.hir.mirror(ast_body);"}, {"sha": "a1eb8bcdf7c1cbb2623ee6a74922adf8229f4a04", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -100,8 +100,8 @@ use rustc_data_structures::fx::FxHashMap;\n \n #[derive(Debug)]\n pub struct Scope<'tcx> {\n-    /// The visibility scope this scope was created in.\n-    visibility_scope: VisibilityScope,\n+    /// The source scope this scope was created in.\n+    source_scope: SourceScope,\n \n     /// the region span of this scope within source code.\n     region_scope: region::Scope,\n@@ -251,11 +251,11 @@ impl<'tcx> Scope<'tcx> {\n         }\n     }\n \n-    /// Given a span and this scope's visibility scope, make a SourceInfo.\n+    /// Given a span and this scope's source scope, make a SourceInfo.\n     fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo {\n             span,\n-            scope: self.visibility_scope\n+            scope: self.source_scope\n         }\n     }\n }\n@@ -316,14 +316,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n-        let visibility_scope = self.visibility_scope;\n+        let source_scope = self.source_scope;\n         let tcx = self.hir.tcx();\n         if let LintLevel::Explicit(node_id) = lint_level {\n             let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n                 let sets = tcx.lint_levels(LOCAL_CRATE);\n                 let parent_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(\n-                        self.visibility_scope_info[visibility_scope].lint_root\n+                        self.source_scope_info[source_scope].lint_root\n                             );\n                 let current_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(node_id);\n@@ -332,15 +332,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             });\n \n             if !same_lint_scopes {\n-                self.visibility_scope =\n-                    self.new_visibility_scope(region_scope.1.span, lint_level,\n+                self.source_scope =\n+                    self.new_source_scope(region_scope.1.span, lint_level,\n                                               None);\n             }\n         }\n         self.push_scope(region_scope);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n-        self.visibility_scope = visibility_scope;\n+        self.source_scope = source_scope;\n         debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n         block.and(rv)\n     }\n@@ -351,9 +351,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// wrapper maybe preferable.\n     pub fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n         debug!(\"push_scope({:?})\", region_scope);\n-        let vis_scope = self.visibility_scope;\n+        let vis_scope = self.source_scope;\n         self.scopes.push(Scope {\n-            visibility_scope: vis_scope,\n+            source_scope: vis_scope,\n             region_scope: region_scope.0,\n             region_scope_span: region_scope.1.span,\n             needs_cleanup: false,\n@@ -509,30 +509,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Some(result)\n     }\n \n-    /// Creates a new visibility scope, nested in the current one.\n-    pub fn new_visibility_scope(&mut self,\n+    /// Creates a new source scope, nested in the current one.\n+    pub fn new_source_scope(&mut self,\n                                 span: Span,\n                                 lint_level: LintLevel,\n-                                safety: Option<Safety>) -> VisibilityScope {\n-        let parent = self.visibility_scope;\n-        debug!(\"new_visibility_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n+                                safety: Option<Safety>) -> SourceScope {\n+        let parent = self.source_scope;\n+        debug!(\"new_source_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n                span, lint_level, safety,\n-               parent, self.visibility_scope_info.get(parent));\n-        let scope = self.visibility_scopes.push(VisibilityScopeData {\n+               parent, self.source_scope_info.get(parent));\n+        let scope = self.source_scopes.push(SourceScopeData {\n             span,\n             parent_scope: Some(parent),\n         });\n-        let scope_info = VisibilityScopeInfo {\n+        let scope_info = SourceScopeInfo {\n             lint_root: if let LintLevel::Explicit(lint_root) = lint_level {\n                 lint_root\n             } else {\n-                self.visibility_scope_info[parent].lint_root\n+                self.source_scope_info[parent].lint_root\n             },\n             safety: safety.unwrap_or_else(|| {\n-                self.visibility_scope_info[parent].safety\n+                self.source_scope_info[parent].safety\n             })\n         };\n-        self.visibility_scope_info.push(scope_info);\n+        self.source_scope_info.push(scope_info);\n         scope\n     }\n \n@@ -552,11 +552,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n     }\n \n-    /// Given a span and the current visibility scope, make a SourceInfo.\n+    /// Given a span and the current source scope, make a SourceInfo.\n     pub fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo {\n             span,\n-            scope: self.visibility_scope\n+            scope: self.source_scope\n         }\n     }\n \n@@ -730,7 +730,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let resumeblk = self.cfg.start_new_cleanup_block();\n             self.cfg.terminate(resumeblk,\n                                SourceInfo {\n-                                   scope: ARGUMENT_VISIBILITY_SCOPE,\n+                                   scope: OUTERMOST_SOURCE_SCOPE,\n                                    span: self.fn_span\n                                },\n                                TerminatorKind::Resume);\n@@ -939,10 +939,10 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // remainder. If everything is cached, we'll just walk right to\n     // left reading the cached results but never create anything.\n \n-    let visibility_scope = scope.visibility_scope;\n+    let source_scope = scope.source_scope;\n     let source_info = |span| SourceInfo {\n         span,\n-        scope: visibility_scope\n+        scope: source_scope\n     };\n \n     // Next, build up the drops. Here we iterate the vector in"}, {"sha": "71f76f47afedfbf7f9071c7e435daa672f19ba58", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -140,8 +140,8 @@ enum CallKind {\n fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     LocalDecl {\n         mutability, ty, name: None,\n-        source_info: SourceInfo { scope: ARGUMENT_VISIBILITY_SCOPE, span },\n-        syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+        source_info: SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span },\n+        syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n         internal: false,\n         is_user_variable: false\n     }\n@@ -178,7 +178,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n-    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n     let return_block = BasicBlock::new(1);\n     let mut blocks = IndexVec::new();\n@@ -195,7 +195,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut mir = Mir::new(\n         blocks,\n         IndexVec::from_elem_n(\n-            VisibilityScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n         IndexVec::new(),\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         Mir::new(\n             self.blocks,\n             IndexVec::from_elem_n(\n-                VisibilityScopeData { span: self.span, parent_scope: None }, 1\n+                SourceScopeData { span: self.span, parent_scope: None }, 1\n             ),\n             ClearCrossCrate::Clear,\n             IndexVec::new(),\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n \n     fn source_info(&self) -> SourceInfo {\n-        SourceInfo { span: self.span, scope: ARGUMENT_VISIBILITY_SCOPE }\n+        SourceInfo { span: self.span, scope: OUTERMOST_SOURCE_SCOPE }\n     }\n \n     fn block(\n@@ -688,7 +688,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"build_call_shim: sig={:?}\", sig);\n \n     let mut local_decls = local_decls_for_sig(&sig, span);\n-    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n     let rcvr_arg = Local::new(1+0);\n     let rcvr_l = Place::Local(rcvr_arg);\n@@ -794,7 +794,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut mir = Mir::new(\n         blocks,\n         IndexVec::from_elem_n(\n-            VisibilityScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n         IndexVec::new(),\n@@ -836,7 +836,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n \n     let source_info = SourceInfo {\n         span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE\n+        scope: OUTERMOST_SOURCE_SCOPE\n     };\n \n     let variant_no = if adt_def.is_enum() {\n@@ -869,7 +869,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     Mir::new(\n         IndexVec::from_elem_n(start_block, 1),\n         IndexVec::from_elem_n(\n-            VisibilityScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span: span, parent_scope: None }, 1\n         ),\n         ClearCrossCrate::Clear,\n         IndexVec::new(),"}, {"sha": "44f9477c2ecbf14d4d391fefc4aeab040fb93427", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -231,7 +231,7 @@ impl MirPass for AddValidation {\n         // Add an AcquireValid at the beginning of the start block.\n         {\n             let source_info = SourceInfo {\n-                scope: ARGUMENT_VISIBILITY_SCOPE,\n+                scope: OUTERMOST_SOURCE_SCOPE,\n                 span: mir.span, // FIXME: Consider using just the span covering the function\n                                 // argument declaration.\n             };"}, {"sha": "e5a71c6ac3a2d8b35c9c3ee27a93e6c8704c21b4", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -27,7 +27,7 @@ use util;\n \n pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+    source_scope_info: &'a IndexVec<SourceScope, SourceScopeInfo>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -38,16 +38,16 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn new(mir: &'a Mir<'tcx>,\n-           visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+           source_scope_info: &'a IndexVec<SourceScope, SourceScopeInfo>,\n            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            param_env: ty::ParamEnv<'tcx>) -> Self {\n         Self {\n             mir,\n-            visibility_scope_info,\n+            source_scope_info,\n             violations: vec![],\n             source_info: SourceInfo {\n                 span: mir.span,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n             tcx,\n             param_env,\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n                 let source_info = self.source_info;\n                 let lint_root =\n-                    self.visibility_scope_info[source_info.scope].lint_root;\n+                    self.source_scope_info[source_info.scope].lint_root;\n                 self.register_violations(&[UnsafetyViolation {\n                     source_info,\n                     description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;\n                     let lint_root =\n-                        self.visibility_scope_info[source_info.scope].lint_root;\n+                        self.source_scope_info[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n                         description: Symbol::intern(\"use of extern static\").as_interned_str(),\n@@ -240,7 +240,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn register_violations(&mut self,\n                            violations: &[UnsafetyViolation],\n                            unsafe_blocks: &[(ast::NodeId, bool)]) {\n-        let within_unsafe = match self.visibility_scope_info[self.source_info.scope].safety {\n+        let within_unsafe = match self.source_scope_info[self.source_info.scope].safety {\n             Safety::Safe => {\n                 for violation in violations {\n                     if !self.violations.contains(violation) {\n@@ -327,7 +327,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     // `mir_built` force this.\n     let mir = &tcx.mir_built(def_id).borrow();\n \n-    let visibility_scope_info = match mir.visibility_scope_info {\n+    let source_scope_info = match mir.source_scope_info {\n         ClearCrossCrate::Set(ref data) => data,\n         ClearCrossCrate::Clear => {\n             debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n@@ -340,7 +340,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     let param_env = tcx.param_env(def_id);\n     let mut checker = UnsafetyChecker::new(\n-        mir, visibility_scope_info, tcx, param_env);\n+        mir, source_scope_info, tcx, param_env);\n     checker.visit_mir(mir);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);"}, {"sha": "580b7e208f91cea9aaa843dfa2d524313c2f3b7c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -338,7 +338,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         .bits();\n                     let right_size = self.tcx.layout_of(self.param_env.and(right.1)).unwrap().size;\n                     if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n-                        let scope_info = match self.mir.visibility_scope_info {\n+                        let scope_info = match self.mir.source_scope_info {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n                         };"}, {"sha": "f7ee6276aaa887569c3f0bd55b3fe2a6dbb94fa1", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -300,7 +300,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n         ty: ret_ty,\n         name: None,\n         source_info: source_info(mir),\n-        syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+        syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -641,7 +641,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         ty: tcx.mk_nil(),\n         name: None,\n         source_info,\n-        syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+        syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -657,7 +657,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         }),\n         name: None,\n         source_info,\n-        syntactic_scope: ARGUMENT_VISIBILITY_SCOPE,\n+        syntactic_scope: OUTERMOST_SOURCE_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -762,7 +762,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n     SourceInfo {\n         span: mir.span,\n-        scope: ARGUMENT_VISIBILITY_SCOPE,\n+        scope: OUTERMOST_SOURCE_SCOPE,\n     }\n }\n "}, {"sha": "9fa078f8dab2fe3fc8aa4f2a2b28013653c88d24", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -380,18 +380,18 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n-                let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n+                let mut scope_map = IndexVec::with_capacity(callee_mir.source_scopes.len());\n                 let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n \n-                for mut scope in callee_mir.visibility_scopes.iter().cloned() {\n+                for mut scope in callee_mir.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n                         scope.parent_scope = Some(callsite.location.scope);\n                         scope.span = callee_mir.span;\n                     }\n \n                     scope.span = callsite.location.span;\n \n-                    let idx = caller_mir.visibility_scopes.push(scope);\n+                    let idx = caller_mir.source_scopes.push(scope);\n                     scope_map.push(idx);\n                 }\n \n@@ -618,7 +618,7 @@ struct Integrator<'a, 'tcx: 'a> {\n     block_idx: usize,\n     args: &'a [Local],\n     local_map: IndexVec<Local, Local>,\n-    scope_map: IndexVec<VisibilityScope, VisibilityScope>,\n+    scope_map: IndexVec<SourceScope, SourceScope>,\n     promoted_map: IndexVec<Promoted, Promoted>,\n     _callsite: CallSite<'tcx>,\n     destination: Place<'tcx>,\n@@ -745,7 +745,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_visibility_scope(&mut self, scope: &mut VisibilityScope) {\n+    fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n         *scope = self.scope_map[*scope];\n     }\n "}, {"sha": "e9face62ad3d9de07929ccf13c41584533e4e702", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             terminator: Some(Terminator {\n                 source_info: SourceInfo {\n                     span,\n-                    scope: ARGUMENT_VISIBILITY_SCOPE\n+                    scope: OUTERMOST_SOURCE_SCOPE\n                 },\n                 kind: TerminatorKind::Return\n             }),\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span,\n-                scope: ARGUMENT_VISIBILITY_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE\n             },\n             kind: StatementKind::Assign(Place::Local(dest), rvalue)\n         });\n@@ -424,8 +424,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?\n-                mir.visibility_scopes.clone(),\n-                mir.visibility_scope_info.clone(),\n+                mir.source_scopes.clone(),\n+                mir.source_scope_info.clone(),\n                 IndexVec::new(),\n                 None,\n                 initial_locals,"}, {"sha": "21ff7eaa72d9d298be595b11d0a2aca70e980a62", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> MirPatch<'tcx> {\n                 terminator: Some(Terminator {\n                     source_info: SourceInfo {\n                         span: mir.span,\n-                        scope: ARGUMENT_VISIBILITY_SCOPE\n+                        scope: OUTERMOST_SOURCE_SCOPE\n                     },\n                     kind: TerminatorKind::Resume\n                 }),"}, {"sha": "8176c644dd7457b392b1fd07a62af275cd304e24", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -447,9 +447,9 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n fn write_scope_tree(\n     tcx: TyCtxt,\n     mir: &Mir,\n-    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+    scope_tree: &FxHashMap<SourceScope, Vec<SourceScope>>,\n     w: &mut dyn Write,\n-    parent: VisibilityScope,\n+    parent: SourceScope,\n     depth: usize,\n ) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n@@ -460,7 +460,7 @@ fn write_scope_tree(\n     };\n \n     for &child in children {\n-        let data = &mir.visibility_scopes[child];\n+        let data = &mir.source_scopes[child];\n         assert_eq!(data.parent_scope, Some(parent));\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n@@ -519,16 +519,16 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     writeln!(w, \"{{\")?;\n \n     // construct a scope tree and write it out\n-    let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n-    for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n+    let mut scope_tree: FxHashMap<SourceScope, Vec<SourceScope>> = FxHashMap();\n+    for (index, scope_data) in mir.source_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n             scope_tree\n                 .entry(parent)\n                 .or_insert(vec![])\n-                .push(VisibilityScope::new(index));\n+                .push(SourceScope::new(index));\n         } else {\n             // Only the argument scope has no parent, because it's the root.\n-            assert_eq!(index, ARGUMENT_VISIBILITY_SCOPE.index());\n+            assert_eq!(index, OUTERMOST_SOURCE_SCOPE.index());\n         }\n     }\n \n@@ -541,7 +541,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n              indented_retptr,\n              ALIGN)?;\n \n-    write_scope_tree(tcx, mir, &scope_tree, w, ARGUMENT_VISIBILITY_SCOPE, 1)?;\n+    write_scope_tree(tcx, mir, &scope_tree, w, OUTERMOST_SOURCE_SCOPE, 1)?;\n \n     write_temp_decls(mir, w)?;\n "}, {"sha": "b795685bb6fd80a904a7a8ee448cd59853d61087", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d44c42764fb87e1f581fa6206727e82cd7d52d/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=85d44c42764fb87e1f581fa6206727e82cd7d52d", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n use rustc::mir::{Place, PlaceElem, PlaceProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n-use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n+use rustc::mir::{Terminator, TerminatorKind, SourceScope, SourceScopeData};\n use rustc::mir::interpret::EvalErrorKind;\n use rustc::mir::visit as mir_visit;\n use rustc::ty::{self, ClosureSubsts, TyCtxt};\n@@ -72,10 +72,10 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_basic_block_data(block, data);\n     }\n \n-    fn visit_visibility_scope_data(&mut self,\n-                                   scope_data: &VisibilityScopeData) {\n-        self.record(\"VisibilityScopeData\", scope_data);\n-        self.super_visibility_scope_data(scope_data);\n+    fn visit_source_scope_data(&mut self,\n+                                   scope_data: &SourceScopeData) {\n+        self.record(\"SourceScopeData\", scope_data);\n+        self.super_source_scope_data(scope_data);\n     }\n \n     fn visit_statement(&mut self,\n@@ -278,9 +278,9 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_local_decl(local, local_decl);\n     }\n \n-    fn visit_visibility_scope(&mut self,\n-                              scope: &VisibilityScope) {\n+    fn visit_source_scope(&mut self,\n+                              scope: &SourceScope) {\n         self.record(\"VisiblityScope\", scope);\n-        self.super_visibility_scope(scope);\n+        self.super_source_scope(scope);\n     }\n }"}]}