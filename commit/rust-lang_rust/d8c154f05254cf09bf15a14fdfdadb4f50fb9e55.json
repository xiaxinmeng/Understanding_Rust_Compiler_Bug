{"sha": "d8c154f05254cf09bf15a14fdfdadb4f50fb9e55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YzE1NGYwNTI1NGNmMDliZjE1YTE0ZmRmZGFkYjRmNTBmYjllNTU=", "commit": {"author": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-01-30T18:19:47Z"}, "committer": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-02-04T11:55:08Z"}, "message": "Extract branch rewrite function", "tree": {"sha": "b304e2e890ae7e3d3c52ca679bb0c3e071062842", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b304e2e890ae7e3d3c52ca679bb0c3e071062842"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55", "html_url": "https://github.com/rust-lang/rust/commit/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55/comments", "author": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "571af9d4b11d8ccc64ab637d9881485e0f6a059a", "url": "https://api.github.com/repos/rust-lang/rust/commits/571af9d4b11d8ccc64ab637d9881485e0f6a059a", "html_url": "https://github.com/rust-lang/rust/commit/571af9d4b11d8ccc64ab637d9881485e0f6a059a"}], "stats": {"total": 193, "additions": 95, "deletions": 98}, "files": [{"sha": "bb623368b9794dd74d51847a1c93ff1002e3700e", "filename": "src/macros.rs", "status": "modified", "additions": 95, "deletions": 98, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c154f05254cf09bf15a14fdfdadb4f50fb9e55/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d8c154f05254cf09bf15a14fdfdadb4f50fb9e55", "patch": "@@ -310,118 +310,27 @@ pub fn rewrite_macro_def(\n \n     let multi_branch_style = def.legacy || parsed_def.branches.len() != 1;\n \n-    let mac_indent = if multi_branch_style {\n-        indent.block_indent(context.config)\n+    let arm_shape = if multi_branch_style {\n+        shape\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config)\n     } else {\n-        indent\n+        shape\n     };\n \n-    let mac_indent_str = mac_indent.to_string(context.config);\n-\n     let branch_items = itemize_list(\n         context.codemap,\n         parsed_def.branches.iter(),\n         \"}\",\n         \";\",\n         |branch| branch.span.lo(),\n         |branch| branch.span.hi(),\n-        |branch| {\n-            // Only attempt to format function-like macros.\n-            if branch.args_paren_kind != DelimToken::Paren {\n-                // FIXME(#1539): implement for non-sugared macros.\n-                return None;\n-            }\n-\n-            let mut result = format_macro_args(branch.args.clone())?;\n-\n-            if multi_branch_style {\n-                result += \" =>\";\n-            }\n-\n-            // The macro body is the most interesting part. It might end up as various\n-            // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n-            // parsed as regular Rust code (and note that these can be escaped using\n-            // `$$`). We'll try and format like an AST node, but we'll substitute\n-            // variables for new names with the same length first.\n-\n-            let old_body = context.snippet(branch.body).trim();\n-            let (body_str, substs) = match replace_names(old_body) {\n-                Some(result) => result,\n-                None => return snippet,\n-            };\n-\n-            let mut config = context.config.clone();\n-            config.set().hide_parse_errors(true);\n-\n-            result += \" {\";\n-\n-            let has_block_body = old_body.starts_with('{');\n-\n-            let body_indent = if has_block_body {\n-                mac_indent\n-            } else {\n-                // We'll hack the indent below, take this into account when formatting,\n-                let body_indent = mac_indent.block_indent(&config);\n-                let new_width = config.max_width() - body_indent.width();\n-                config.set().max_width(new_width);\n-                body_indent\n-            };\n-\n-            // First try to format as items, then as statements.\n-            let new_body = match ::format_snippet(&body_str, &config) {\n-                Some(new_body) => new_body,\n-                None => match ::format_code_block(&body_str, &config) {\n-                    Some(new_body) => new_body,\n-                    None => return None,\n-                },\n-            };\n-\n-            // Indent the body since it is in a block.\n-            let indent_str = body_indent.to_string(&config);\n-            let mut new_body = new_body\n-                .trim_right()\n-                .lines()\n-                .fold(String::new(), |mut s, l| {\n-                    if !l.is_empty() {\n-                        s += &indent_str;\n-                    }\n-                    s + l + \"\\n\"\n-                });\n-\n-            // Undo our replacement of macro variables.\n-            // FIXME: this could be *much* more efficient.\n-            for (old, new) in &substs {\n-                if old_body.find(new).is_some() {\n-                    debug!(\n-                        \"rewrite_macro_def: bailing matching variable: `{}` in `{}`\",\n-                        new, ident\n-                    );\n-                    return None;\n-                }\n-                new_body = new_body.replace(new, old);\n-            }\n-\n-            if has_block_body {\n-                result += new_body.trim();\n-            } else if !new_body.is_empty() {\n-                result += \"\\n\";\n-                result += &new_body;\n-                result += &mac_indent_str;\n-            }\n-\n-            result += \"}\";\n-\n-            Some(result)\n-        },\n+        |branch| branch.rewrite(context, arm_shape, multi_branch_style),\n         context.codemap.span_after(span, \"{\"),\n         span.hi(),\n         false,\n     ).collect::<Vec<_>>();\n \n-    let arm_shape = shape\n-        .block_indent(context.config.tab_spaces())\n-        .with_max_width(context.config);\n-\n     let fmt = ListFormatting {\n         tactic: DefinitiveListTactic::Vertical,\n         separator: if def.legacy { \";\" } else { \"\" },\n@@ -435,7 +344,7 @@ pub fn rewrite_macro_def(\n \n     if multi_branch_style {\n         result += \" {\\n\";\n-        result += &mac_indent_str;\n+        result += &arm_shape.indent.to_string(context.config);\n     }\n \n     result += write_list(&branch_items, &fmt)?.as_str();\n@@ -833,6 +742,94 @@ struct MacroBranch {\n     body: Span,\n }\n \n+impl MacroBranch {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape, multi_branch_style: bool) -> Option<String> {\n+        // Only attempt to format function-like macros.\n+        if self.args_paren_kind != DelimToken::Paren {\n+            // FIXME(#1539): implement for non-sugared macros.\n+            return None;\n+        }\n+\n+        let mut result = format_macro_args(self.args.clone())?;\n+\n+        if multi_branch_style {\n+            result += \" =>\";\n+        }\n+\n+        // The macro body is the most interesting part. It might end up as various\n+        // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n+        // parsed as regular Rust code (and note that these can be escaped using\n+        // `$$`). We'll try and format like an AST node, but we'll substitute\n+        // variables for new names with the same length first.\n+\n+        let old_body = context.snippet(self.body).trim();\n+        let (body_str, substs) = replace_names(old_body)?;\n+\n+        let mut config = context.config.clone();\n+        config.set().hide_parse_errors(true);\n+\n+        result += \" {\";\n+\n+        let has_block_body = old_body.starts_with('{');\n+\n+        let body_indent = if has_block_body {\n+            shape.indent\n+        } else {\n+            // We'll hack the indent below, take this into account when formatting,\n+            let body_indent = shape.indent.block_indent(&config);\n+            let new_width = config.max_width() - body_indent.width();\n+            config.set().max_width(new_width);\n+            body_indent\n+        };\n+\n+        // First try to format as items, then as statements.\n+        let new_body = match ::format_snippet(&body_str, &config) {\n+            Some(new_body) => new_body,\n+            None => match ::format_code_block(&body_str, &config) {\n+                Some(new_body) => new_body,\n+                None => return None,\n+            },\n+        };\n+\n+        // Indent the body since it is in a block.\n+        let indent_str = body_indent.to_string(&config);\n+        let mut new_body = new_body\n+            .trim_right()\n+            .lines()\n+            .fold(String::new(), |mut s, l| {\n+                if !l.is_empty() {\n+                    s += &indent_str;\n+                }\n+                s + l + \"\\n\"\n+            });\n+\n+        // Undo our replacement of macro variables.\n+        // FIXME: this could be *much* more efficient.\n+        for (old, new) in &substs {\n+            if old_body.find(new).is_some() {\n+                debug!(\n+                    \"rewrite_macro_def: bailing matching variable: `{}`\",\n+                    new\n+                );\n+                return None;\n+            }\n+            new_body = new_body.replace(new, old);\n+        }\n+\n+        if has_block_body {\n+            result += new_body.trim();\n+        } else if !new_body.is_empty() {\n+            result += \"\\n\";\n+            result += &new_body;\n+            result += &shape.indent.to_string(&config);\n+        }\n+\n+        result += \"}\";\n+\n+        Some(result)\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}]}